{
  "recutils/recutils-1.7/bash/readrec.c": {
    "readrec_builtin": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\nreadrec_builtin (WORD_LIST *list)\n{\n  SHELL_VAR *var;\n  rec_parser_t parser;\n  rec_record_t record;\n\n  no_options (list);\n\n  /* Create a librec parser to operate on the standard input and try\n     to read a record.  If there is a parse error then report it and\n     fail.  */\n\n  parser = rec_parser_new (stdin, \"stdin\");\n  if (!parser)\n    return EXECUTION_FAILURE;\n\n  if (!rec_parse_record (parser, &record))\n    {\n      return EXECUTION_FAILURE;\n    }\n\n  {\n    size_t record_str_size = 0;\n    char *record_str = NULL;\n    char *record_str_dequoted = NULL;\n    rec_writer_t writer = rec_writer_new_str (&record_str, &record_str_size);\n\n    if (!writer || !rec_write_record (writer, record))\n      return EXIT_FAILURE;\n    rec_writer_destroy (writer);\n\n    /* Set the REPLY_REC environment variable to the read record.  */\n    record_str_dequoted = dequote_string (record_str);\n    var = bind_variable (\"REPLY_REC\", record_str_dequoted, 0);\n    VUNSETATTR (var, att_invisible);\n    xfree (record_str_dequoted);\n\n    /* Set the environment variables for the fields.  */\n    {\n      rec_field_t field = NULL;\n      rec_mset_iterator_t iter = rec_mset_iterator (rec_record_mset (record));\n\n      //      rec_record_reset_marks (record);\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n        {\n          char *var_name = rec_field_name (field);\n          size_t num_fields = rec_record_get_num_fields_by_name (record, var_name);\n\n          //          if (rec_record_field_mark (record, field))\n          //            continue;\n\n#if defined ARRAY_VARS\n          if (num_fields > 1)\n            {\n              /* In case several fields share the same field name, create\n                 an array variable containing all the values.  */\n\n              size_t i = 0;\n              for (; i < num_fields; i++)\n                {\n                  //                  rec_record_mark_field (record, field, true);\n                  field = rec_record_get_field_by_name (record, var_name, i);\n                  var = bind_array_variable (var_name, i, rec_field_value (field), 0);\n                  VUNSETATTR (var, att_invisible);\n                }\n            }\n          else\n            {\n              /* Bind a normal variable.  */\n              char *var_value = rec_field_value (field);\n              var = bind_variable (var_name, var_value, 0);\n              VUNSETATTR (var, att_invisible);\n            }\n#endif /* ARRAY_VARS */\n        }\n      rec_mset_iterator_free (&iter);\n    }\n  }\n\n  return EXECUTION_SUCCESS;\n}",
      "lines": 82,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/bash/testrec.c": {
    "testrec_builtin": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\ntestrec_builtin (WORD_LIST *list)\n{\n  int res = EXECUTION_SUCCESS;\n  const char **argv;\n  int argc;\n  SHELL_VAR *var;\n  rec_record_t record;\n  rec_parser_t parser;\n  char *record_str, *sex_str;\n\n  /* Get arguments and verify them.  */\n\n  argv = make_builtin_argv (list, &argc);\n  if ((argc != 3)\n      || ((strcmp (argv[0], \"[%\") == 0) && ((strlen (argv[2]) == 2) && ((argv[2][0] != '%') || (argv[2][1] != ']')))))\n    {\n      fprintf (stderr, \"Usage: [%% SEX %%]\\n\");\n      return EXECUTION_FAILURE;\n    }\n\n  sex_str = argv[1];\n\n  /* Get the record to operate on from the REPLY_REC environment\n     variable.  */\n  var = find_variable (\"REPLY_REC\");\n  if (!var)\n    return EXECUTION_FAILURE;\n\n  record_str = get_variable_value (var);\n  parser = rec_parser_new_str (record_str, \"REPLY_REC\");\n  if (!parser || !rec_parse_record (parser, &record))\n    {\n      fprintf (stderr, \"testrec: error: invalid record in REPLY_REC\\n\");\n      return EXECUTION_FAILURE;\n    }\n\n  /* Apply the selection expression.  */\n  {\n    bool status = false;\n    rec_sex_t sex = rec_sex_new (false);\n    if (!sex)\n      return EXECUTION_FAILURE;\n\n    if (!rec_sex_compile (sex, sex_str))\n      {\n        fprintf (stderr, \"testrec: error: wrong selection expression\\n\");\n        return EXECUTION_FAILURE;\n      }\n\n    res = rec_sex_eval (sex, record, &status) ? EXECUTION_SUCCESS : EXECUTION_FAILURE;\n    rec_sex_destroy (sex);\n  }\n\n  /* Cleanup.  */\n  rec_record_destroy (record);\n\n  return res;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/build-aux/snippet/arg-nonnull.h": {},
  "recutils/recutils-1.7/build-aux/snippet/c++defs.h": {},
  "recutils/recutils-1.7/build-aux/snippet/unused-parameter.h": {},
  "recutils/recutils-1.7/build-aux/snippet/warn-on-use.h": {},
  "recutils/recutils-1.7/build-aux/snippet/_Noreturn.h": {},
  "recutils/recutils-1.7/lib/acl-errno-valid.c": {
    "acl_errno_valid": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "bool\nacl_errno_valid (int errnum)\n{\n  /* Recognize some common errors such as from an NFS mount that does\n     not support ACLs, even when local drives do.  */\n  switch (errnum)\n    {\n    case EBUSY: return false;\n    case EINVAL: return false;\n#if defined __APPLE__ && defined __MACH__\n    case ENOENT: return false;\n#endif\n    case ENOSYS: return false;\n\n#if defined ENOTSUP && ENOTSUP != EOPNOTSUPP\n# if ENOTSUP != ENOSYS /* Needed for the MS-Windows port of GNU Emacs.  */\n    case ENOTSUP: return false;\n# endif\n#endif\n\n    case EOPNOTSUPP: return false;\n    default: return true;\n    }\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/acl-internal.h": {
    "rpl_acl_get_fd": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "ACL_INTERNAL_INLINE acl_t\nrpl_acl_get_fd (int fd)\n{\n  return acl_get_fd (fd, ACL_TYPE_ACCESS);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "acl_t",
        "acl_t"
      ]
    },
    "rpl_acl_set_fd": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "ACL_INTERNAL_INLINE int\nrpl_acl_set_fd (int fd, acl_t acl)\n{\n  return acl_set_fd (fd, ACL_TYPE_ACCESS, acl);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "ACL_INTERNAL_INLINE",
        "int",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/acl.h": {},
  "recutils/recutils-1.7/lib/acl_entries.c": {
    "acl_entries": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nacl_entries (acl_t acl)\n{\n  int count = 0;\n\n  if (acl != NULL)\n    {\n#if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD, Mac OS X */\n# if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n      /* acl_get_entry returns 0 when it successfully fetches an entry,\n         and -1/EINVAL at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one >= 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n# else /* Linux, FreeBSD */\n      /* acl_get_entry returns 1 when it successfully fetches an entry,\n         and 0 at the end.  */\n      acl_entry_t ace;\n      int got_one;\n\n      for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n           got_one > 0;\n           got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n        count++;\n      if (got_one < 0)\n        return -1;\n# endif\n#else /* IRIX, Tru64 */\n# if HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n      /* Don't use acl_get_entry: it is undocumented.  */\n      count = acl->acl_cnt;\n# endif\n# if HAVE_ACL_FREE_TEXT /* Tru64 */\n      /* Don't use acl_get_entry: it takes only one argument and does not\n         work.  */\n      count = acl->acl_num;\n# endif\n#endif\n    }\n\n  return count;\n}",
      "lines": 46,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/alloca.c": {
    "find_stack_direction": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static int\nfind_stack_direction (int *addr, int depth)\n{\n  int dir, dummy = 0;\n  if (! addr)\n    addr = &dummy;\n  *addr = addr < &dummy ? 1 : addr == &dummy ? 0 : -1;\n  dir = depth ? find_stack_direction (addr, depth - 1) : 0;\n  return dir + dummy;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloca": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void *\nalloca (size_t size)\n{\n  auto char probe;              /* Probes stack depth: */\n  register char *depth = ADDRESS_FUNCTION (probe);\n\n#  if STACK_DIRECTION == 0\n  if (STACK_DIR == 0)           /* Unknown growth direction.  */\n    STACK_DIR = find_stack_direction (NULL, (size & 1) + 20);\n#  endif\n\n  /* Reclaim garbage, defined as all alloca'd storage that\n     was allocated from deeper in the stack than currently.  */\n\n  {\n    register header *hp;        /* Traverses linked list.  */\n\n#  ifdef emacs\n    BLOCK_INPUT;\n#  endif\n\n    for (hp = last_alloca_header; hp != NULL;)\n      if ((STACK_DIR > 0 && hp->h.deep > depth)\n          || (STACK_DIR < 0 && hp->h.deep < depth))\n        {\n          register header *np = hp->h.next;\n\n          free (hp);            /* Collect garbage.  */\n\n          hp = np;              /* -> next header.  */\n        }\n      else\n        break;                  /* Rest are not deeper.  */\n\n    last_alloca_header = hp;    /* -> last valid storage.  */\n\n#  ifdef emacs\n    UNBLOCK_INPUT;\n#  endif\n  }\n\n  if (size == 0)\n    return NULL;                /* No allocation required.  */\n\n  /* Allocate combined header + user data storage.  */\n\n  {\n    /* Address of header.  */\n    register header *new;\n\n    size_t combined_size = sizeof (header) + size;\n    if (combined_size < sizeof (header))\n      memory_full ();\n\n    new = malloc (combined_size);\n\n    if (! new)\n      memory_full ();\n\n    new->h.next = last_alloca_header;\n    new->h.deep = depth;\n\n    last_alloca_header = new;\n\n    /* User storage begins just after header.  */\n\n    return (void *) (new + 1);\n  }\n}",
      "lines": 69,
      "depth": 13,
      "decorators": [
        "void",
        "*\nalloca (size_t size)",
        "*"
      ]
    },
    "i00afunc": [
      {
        "start_point": [
          328,
          0
        ],
        "end_point": [
          393,
          1
        ],
        "content": "static long\ni00afunc (long *address)\n{\n  struct stk_stat status;\n  struct stk_trailer *trailer;\n  long *block, size;\n  long result = 0;\n\n  /* We want to iterate through all of the segments.  The first\n     step is to get the stack status structure.  We could do this\n     more quickly and more directly, perhaps, by referencing the\n     $LM00 common block, but I know that this works.  */\n\n  STKSTAT (&status);\n\n  /* Set up the iteration.  */\n\n  trailer = (struct stk_trailer *) (status.current_address\n                                    + status.current_size\n                                    - 15);\n\n  /* There must be at least one stack segment.  Therefore it is\n     a fatal error if \"trailer\" is null.  */\n\n  if (trailer == 0)\n    abort ();\n\n  /* Discard segments that do not contain our argument address.  */\n\n  while (trailer != 0)\n    {\n      block = (long *) trailer->this_address;\n      size = trailer->this_size;\n      if (block == 0 || size == 0)\n        abort ();\n      trailer = (struct stk_trailer *) trailer->link;\n      if ((block <= address) && (address < (block + size)))\n        break;\n    }\n\n  /* Set the result to the offset in this segment and add the sizes\n     of all predecessor segments.  */\n\n  result = address - block;\n\n  if (trailer == 0)\n    {\n      return result;\n    }\n\n  do\n    {\n      if (trailer->this_size <= 0)\n        abort ();\n      result += trailer->this_size;\n      trailer = (struct stk_trailer *) trailer->link;\n    }\n  while (trailer != 0);\n\n  /* We are done.  Note that if you present a bogus address (one\n     not in any segment), you will get a different number back, formed\n     from subtracting the address of the first block.  This is probably\n     not what you want.  */\n\n  return (result);\n}",
        "lines": 66,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      },
      {
        "start_point": [
          402,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "static long\ni00afunc (long address)\n{\n  long stkl = 0;\n\n  long size, pseg, this_segment, stack;\n  long result = 0;\n\n  struct stack_segment_linkage *ssptr;\n\n  /* Register B67 contains the address of the end of the\n     current stack segment.  If you (as a subprogram) store\n     your registers on the stack and find that you are past\n     the contents of B67, you have overflowed the segment.\n\n     B67 also points to the stack segment linkage control\n     area, which is what we are really interested in.  */\n\n  stkl = CRAY_STACKSEG_END ();\n  ssptr = (struct stack_segment_linkage *) stkl;\n\n  /* If one subtracts 'size' from the end of the segment,\n     one has the address of the first word of the segment.\n\n     If this is not the first segment, 'pseg' will be\n     nonzero.  */\n\n  pseg = ssptr->sspseg;\n  size = ssptr->sssize;\n\n  this_segment = stkl - size;\n\n  /* It is possible that calling this routine itself caused\n     a stack overflow.  Discard stack segments which do not\n     contain the target address.  */\n\n  while (!(this_segment <= address && address <= stkl))\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o %011o\\n\", this_segment, address, stkl);\n#    endif\n      if (pseg == 0)\n        break;\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      this_segment = stkl - size;\n    }\n\n  result = address - this_segment;\n\n  /* If you subtract pseg from the current end of the stack,\n     you get the address of the previous stack segment's end.\n     This seems a little convoluted to me, but I'll bet you save\n     a cycle somewhere.  */\n\n  while (pseg != 0)\n    {\n#    ifdef DEBUG_I00AFUNC\n      fprintf (stderr, \"%011o %011o\\n\", pseg, size);\n#    endif\n      stkl = stkl - pseg;\n      ssptr = (struct stack_segment_linkage *) stkl;\n      size = ssptr->sssize;\n      pseg = ssptr->sspseg;\n      result += size;\n    }\n  return (result);\n}",
        "lines": 70,
        "depth": 10,
        "decorators": [
          "static",
          "static",
          "long",
          "long"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/alloca.in.h": {},
  "recutils/recutils-1.7/lib/asnprintf.c": {
    "asnprintf": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "char *\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)\n{\n  va_list args;\n  char *result;\n\n  va_start (args, format);\n  result = vasnprintf (resultbuf, lengthp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "char",
        "*\nasnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/asprintf.c": {
    "asprintf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "int\nasprintf (char **resultp, const char *format, ...)\n{\n  va_list args;\n  int result;\n\n  va_start (args, format);\n  result = vasprintf (resultp, format, args);\n  va_end (args);\n  return result;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/base64.c": {
    "to_uchar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static unsigned char\nto_uchar (char ch)\n{\n  return ch;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "base64_encode_fast": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\nbase64_encode_fast (const char *restrict in, size_t inlen, char *restrict out)\n{\n  while (inlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      *out++ = b64c[((to_uchar (in[0]) << 4) + (to_uchar (in[1]) >> 4)) & 0x3f];\n      *out++ = b64c[((to_uchar (in[1]) << 2) + (to_uchar (in[2]) >> 6)) & 0x3f];\n      *out++ = b64c[to_uchar (in[2]) & 0x3f];\n\n      inlen -= 3;\n      in += 3;\n    }\n}",
      "lines": 14,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nbase64_encode (const char *restrict in, size_t inlen,\n               char *restrict out, size_t outlen)\n{\n  /* Note this outlen constraint can be enforced at compile time.\n     I.E. that the output buffer is exactly large enough to hold\n     the encoded inlen bytes.  The inlen constraints (of corresponding\n     to outlen, and being a multiple of 3) can change at runtime\n     at the end of input.  However the common case when reading\n     large inputs is to have both constraints satisfied, so we depend\n     on both in base_encode_fast().  */\n  if (outlen % 4 == 0 && inlen == outlen / 4 * 3)\n    {\n      base64_encode_fast (in, inlen, out);\n      return;\n    }\n\n  while (inlen && outlen)\n    {\n      *out++ = b64c[to_uchar (in[0]) >> 2];\n      if (!--outlen)\n        break;\n      *out++ = b64c[((to_uchar (in[0]) << 4)\n                       + (--inlen ? to_uchar (in[1]) >> 4 : 0))\n                      & 0x3f];\n      if (!--outlen)\n        break;\n      *out++ =\n        (inlen\n         ? b64c[((to_uchar (in[1]) << 2)\n                   + (--inlen ? to_uchar (in[2]) >> 6 : 0))\n                  & 0x3f]\n         : '=');\n      if (!--outlen)\n        break;\n      *out++ = inlen ? b64c[to_uchar (in[2]) & 0x3f] : '=';\n      if (!--outlen)\n        break;\n      if (inlen)\n        inlen--;\n      if (inlen)\n        in += 3;\n    }\n\n  if (outlen)\n    *out = '\\0';\n}",
      "lines": 47,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_alloc": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "size_t\nbase64_encode_alloc (const char *in, size_t inlen, char **out)\n{\n  size_t outlen = 1 + BASE64_LENGTH (inlen);\n\n  /* Check for overflow in outlen computation.\n   *\n   * If there is no overflow, outlen >= inlen.\n   *\n   * If the operation (inlen + 2) overflows then it yields at most +1, so\n   * outlen is 0.\n   *\n   * If the multiplication overflows, we lose at least half of the\n   * correct value, so the result is < ((inlen + 2) / 3) * 2, which is\n   * less than (inlen + 2) * 0.66667, which is less than inlen as soon as\n   * (inlen > 4).\n   */\n  if (inlen > outlen)\n    {\n      *out = NULL;\n      return 0;\n    }\n\n  *out = malloc (outlen);\n  if (!*out)\n    return outlen;\n\n  base64_encode (in, inlen, *out, outlen);\n\n  return outlen - 1;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "isbase64": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "bool\nisbase64 (char ch)\n{\n  return uchar_in_range (to_uchar (ch)) && 0 <= b64[to_uchar (ch)];\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_ctx_init": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "void\nbase64_decode_ctx_init (struct base64_decode_context *ctx)\n{\n  ctx->i = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "get_4": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static char *\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)\n{\n  if (ctx->i == 4)\n    ctx->i = 0;\n\n  if (ctx->i == 0)\n    {\n      char const *t = *in;\n      if (4 <= in_end - *in && memchr (t, '\\n', 4) == NULL)\n        {\n          /* This is the common case: no newline.  */\n          *in += 4;\n          *n_non_newline = 4;\n          return (char *) t;\n        }\n    }\n\n  {\n    /* Copy non-newline bytes into BUF.  */\n    char const *p = *in;\n    while (p < in_end)\n      {\n        char c = *p++;\n        if (c != '\\n')\n          {\n            ctx->buf[ctx->i++] = c;\n            if (ctx->i == 4)\n              break;\n          }\n      }\n\n    *in = p;\n    *n_non_newline = ctx->i;\n    return ctx->buf;\n  }\n}",
      "lines": 39,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_4 (struct base64_decode_context *ctx,\n       char const *restrict *in, char const *restrict in_end,\n       size_t *n_non_newline)",
        "*"
      ]
    },
    "decode_4": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        466,
        1
      ],
      "content": "static bool\ndecode_4 (char const *restrict in, size_t inlen,\n          char *restrict *outp, size_t *outleft)\n{\n  char *out = *outp;\n  if (inlen < 2)\n    return false;\n\n  if (!isbase64 (in[0]) || !isbase64 (in[1]))\n    return false;\n\n  if (*outleft)\n    {\n      *out++ = ((b64[to_uchar (in[0])] << 2)\n                | (b64[to_uchar (in[1])] >> 4));\n      --*outleft;\n    }\n\n  if (inlen == 2)\n    return_false;\n\n  if (in[2] == '=')\n    {\n      if (inlen != 4)\n        return_false;\n\n      if (in[3] != '=')\n        return_false;\n    }\n  else\n    {\n      if (!isbase64 (in[2]))\n        return_false;\n\n      if (*outleft)\n        {\n          *out++ = (((b64[to_uchar (in[1])] << 4) & 0xf0)\n                    | (b64[to_uchar (in[2])] >> 2));\n          --*outleft;\n        }\n\n      if (inlen == 3)\n        return_false;\n\n      if (in[3] == '=')\n        {\n          if (inlen != 4)\n            return_false;\n        }\n      else\n        {\n          if (!isbase64 (in[3]))\n            return_false;\n\n          if (*outleft)\n            {\n              *out++ = (((b64[to_uchar (in[2])] << 6) & 0xc0)\n                        | b64[to_uchar (in[3])]);\n              --*outleft;\n            }\n        }\n    }\n\n  *outp = out;\n  return true;\n}",
      "lines": 66,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "base64_decode_ctx": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "bool\nbase64_decode_ctx (struct base64_decode_context *ctx,\n                   const char *restrict in, size_t inlen,\n                   char *restrict out, size_t *outlen)\n{\n  size_t outleft = *outlen;\n  bool ignore_newlines = ctx != NULL;\n  bool flush_ctx = false;\n  unsigned int ctx_i = 0;\n\n  if (ignore_newlines)\n    {\n      ctx_i = ctx->i;\n      flush_ctx = inlen == 0;\n    }\n\n\n  while (true)\n    {\n      size_t outleft_save = outleft;\n      if (ctx_i == 0 && !flush_ctx)\n        {\n          while (true)\n            {\n              /* Save a copy of outleft, in case we need to re-parse this\n                 block of four bytes.  */\n              outleft_save = outleft;\n              if (!decode_4 (in, inlen, &out, &outleft))\n                break;\n\n              in += 4;\n              inlen -= 4;\n            }\n        }\n\n      if (inlen == 0 && !flush_ctx)\n        break;\n\n      /* Handle the common case of 72-byte wrapped lines.\n         This also handles any other multiple-of-4-byte wrapping.  */\n      if (inlen && *in == '\\n' && ignore_newlines)\n        {\n          ++in;\n          --inlen;\n          continue;\n        }\n\n      /* Restore OUT and OUTLEFT.  */\n      out -= outleft_save - outleft;\n      outleft = outleft_save;\n\n      {\n        char const *in_end = in + inlen;\n        char const *non_nl;\n\n        if (ignore_newlines)\n          non_nl = get_4 (ctx, &in, in_end, &inlen);\n        else\n          non_nl = in;  /* Might have nl in this case. */\n\n        /* If the input is empty or consists solely of newlines (0 non-newlines),\n           then we're done.  Likewise if there are fewer than 4 bytes when not\n           flushing context and not treating newlines as garbage.  */\n        if (inlen == 0 || (inlen < 4 && !flush_ctx && ignore_newlines))\n          {\n            inlen = 0;\n            break;\n          }\n        if (!decode_4 (non_nl, inlen, &out, &outleft))\n          break;\n\n        inlen = in_end - in;\n      }\n    }\n\n  *outlen -= outleft;\n\n  return inlen == 0;\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "base64_decode_alloc_ctx": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        604,
        1
      ],
      "content": "bool\nbase64_decode_alloc_ctx (struct base64_decode_context *ctx,\n                         const char *in, size_t inlen, char **out,\n                         size_t *outlen)\n{\n  /* This may allocate a few bytes too many, depending on input,\n     but it's not worth the extra CPU time to compute the exact size.\n     The exact size is 3 * (inlen + (ctx ? ctx->i : 0)) / 4, minus 1 if the\n     input ends with \"=\" and minus another 1 if the input ends with \"==\".\n     Dividing before multiplying avoids the possibility of overflow.  */\n  size_t needlen = 3 * (inlen / 4) + 3;\n\n  *out = malloc (needlen);\n  if (!*out)\n    return true;\n\n  if (!base64_decode_ctx (ctx, in, inlen, *out, &needlen))\n    {\n      free (*out);\n      *out = NULL;\n      return false;\n    }\n\n  if (outlen)\n    *outlen = needlen;\n\n  return true;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/base64.h": {},
  "recutils/recutils-1.7/lib/basename-lgpl.c": {
    "last_component": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "char *\nlast_component (char const *name)\n{\n  char const *base = name + FILE_SYSTEM_PREFIX_LEN (name);\n  char const *p;\n  bool saw_slash = false;\n\n  while (ISSLASH (*base))\n    base++;\n\n  for (p = base; *p; p++)\n    {\n      if (ISSLASH (*p))\n        saw_slash = true;\n      else if (saw_slash)\n        {\n          base = p;\n          saw_slash = false;\n        }\n    }\n\n  return (char *) base;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "char",
        "*\nlast_component (char const *name)",
        "*"
      ]
    },
    "base_len": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nbase_len (char const *name)\n{\n  size_t len;\n  size_t prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  for (len = strlen (name);  1 < len && ISSLASH (name[len - 1]);  len--)\n    continue;\n\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && len == 1\n      && ISSLASH (name[0]) && ISSLASH (name[1]) && ! name[2])\n    return 2;\n\n  if (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE && prefix_len\n      && len == prefix_len && ISSLASH (name[prefix_len]))\n    return prefix_len + 1;\n\n  return len;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/btowc.c": {
    "btowc": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "wint_t\nbtowc (int c)\n{\n  if (c != EOF)\n    {\n      char buf[1];\n      wchar_t wc;\n\n      buf[0] = c;\n      if (mbtowc (&wc, buf, 1) >= 0)\n        return wc;\n    }\n  return WEOF;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "wint_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/c-ctype.c": {
    "c_isascii": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "bool\nc_isascii (int c)\n{\n  return (c >= 0x00 && c <= 0x7f);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "c_isalnum": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "bool\nc_isalnum (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'Z')\n          || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_isalpha": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "bool\nc_isalpha (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z');\n#else\n  return ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));\n#endif\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "c_isblank": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "bool\nc_isblank (int c)\n{\n  return (c == ' ' || c == '\\t');\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "c_iscntrl": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "bool\nc_iscntrl (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c & ~0x1f) == 0 || c == 0x7f);\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 0;\n    default:\n      return 1;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "c_isdigit": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "bool\nc_isdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS\n  return (c >= '0' && c <= '9');\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_islower": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "bool\nc_islower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z');\n#else\n  switch (c)\n    {\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isgraph": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "bool\nc_isgraph (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= '!' && c <= '~');\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isprint": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "bool\nc_isprint (int c)\n{\n#if C_CTYPE_ASCII\n  return (c >= ' ' && c <= '~');\n#else\n  switch (c)\n    {\n    case ' ': case '!': case '\"': case '#': case '$': case '%':\n    case '&': case '\\'': case '(': case ')': case '*': case '+':\n    case ',': case '-': case '.': case '/':\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n    case 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n    case 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n    case 's': case 't': case 'u': case 'v': case 'w': case 'x':\n    case 'y': case 'z':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_ispunct": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "bool\nc_ispunct (int c)\n{\n#if C_CTYPE_ASCII\n  return ((c >= '!' && c <= '~')\n          && !((c >= '0' && c <= '9')\n               || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'Z')));\n#else\n  switch (c)\n    {\n    case '!': case '\"': case '#': case '$': case '%': case '&':\n    case '\\'': case '(': case ')': case '*': case '+': case ',':\n    case '-': case '.': case '/':\n    case ':': case ';': case '<': case '=': case '>': case '?':\n    case '@':\n    case '[': case '\\\\': case ']': case '^': case '_': case '`':\n    case '{': case '|': case '}': case '~':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "c_isspace": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "bool\nc_isspace (int c)\n{\n  return (c == ' ' || c == '\\t'\n          || c == '\\n' || c == '\\v' || c == '\\f' || c == '\\r');\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "c_isupper": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nc_isupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE\n  return (c >= 'A' && c <= 'Z');\n#else\n  switch (c)\n    {\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n    case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n    case 'Y': case 'Z':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "c_isxdigit": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nc_isxdigit (int c)\n{\n#if C_CTYPE_CONSECUTIVE_DIGITS \\\n    && C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n#if C_CTYPE_ASCII\n  return ((c >= '0' && c <= '9')\n          || ((c & ~0x20) >= 'A' && (c & ~0x20) <= 'F'));\n#else\n  return ((c >= '0' && c <= '9')\n          || (c >= 'A' && c <= 'F')\n          || (c >= 'a' && c <= 'f'));\n#endif\n#else\n  switch (c)\n    {\n    case '0': case '1': case '2': case '3': case '4': case '5':\n    case '6': case '7': case '8': case '9':\n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n      return 1;\n    default:\n      return 0;\n    }\n#endif\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "c_tolower": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "int\nc_tolower (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'A' && c <= 'Z' ? c - 'A' + 'a' : c);\n#else\n  switch (c)\n    {\n    case 'A': return 'a';\n    case 'B': return 'b';\n    case 'C': return 'c';\n    case 'D': return 'd';\n    case 'E': return 'e';\n    case 'F': return 'f';\n    case 'G': return 'g';\n    case 'H': return 'h';\n    case 'I': return 'i';\n    case 'J': return 'j';\n    case 'K': return 'k';\n    case 'L': return 'l';\n    case 'M': return 'm';\n    case 'N': return 'n';\n    case 'O': return 'o';\n    case 'P': return 'p';\n    case 'Q': return 'q';\n    case 'R': return 'r';\n    case 'S': return 's';\n    case 'T': return 't';\n    case 'U': return 'u';\n    case 'V': return 'v';\n    case 'W': return 'w';\n    case 'X': return 'x';\n    case 'Y': return 'y';\n    case 'Z': return 'z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "c_toupper": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "int\nc_toupper (int c)\n{\n#if C_CTYPE_CONSECUTIVE_UPPERCASE && C_CTYPE_CONSECUTIVE_LOWERCASE\n  return (c >= 'a' && c <= 'z' ? c - 'a' + 'A' : c);\n#else\n  switch (c)\n    {\n    case 'a': return 'A';\n    case 'b': return 'B';\n    case 'c': return 'C';\n    case 'd': return 'D';\n    case 'e': return 'E';\n    case 'f': return 'F';\n    case 'g': return 'G';\n    case 'h': return 'H';\n    case 'i': return 'I';\n    case 'j': return 'J';\n    case 'k': return 'K';\n    case 'l': return 'L';\n    case 'm': return 'M';\n    case 'n': return 'N';\n    case 'o': return 'O';\n    case 'p': return 'P';\n    case 'q': return 'Q';\n    case 'r': return 'R';\n    case 's': return 'S';\n    case 't': return 'T';\n    case 'u': return 'U';\n    case 'v': return 'V';\n    case 'w': return 'W';\n    case 'x': return 'X';\n    case 'y': return 'Y';\n    case 'z': return 'Z';\n    default: return c;\n    }\n#endif\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/c-ctype.h": {},
  "recutils/recutils-1.7/lib/c-strcase.h": {},
  "recutils/recutils-1.7/lib/c-strcasecmp.c": {
    "c_strcasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strcasecmp (const char *s1, const char *s2)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/c-strcaseeq.h": {
    "strcaseeq9": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static inline int\nstrcaseeq9 (const char *s1, const char *s2)\n{\n  return c_strcasecmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq8": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static inline int\nstrcaseeq8 (const char *s1, const char *s2, char s28)\n{\n  if (CASEEQ (s1[8], s28))\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return strcaseeq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq7": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static inline int\nstrcaseeq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (CASEEQ (s1[7], s27))\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return strcaseeq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq6": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static inline int\nstrcaseeq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[6], s26))\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return strcaseeq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq5": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static inline int\nstrcaseeq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[5], s25))\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return strcaseeq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq4": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "static inline int\nstrcaseeq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[4], s24))\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return strcaseeq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq3": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static inline int\nstrcaseeq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[3], s23))\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return strcaseeq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq2": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static inline int\nstrcaseeq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[2], s22))\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return strcaseeq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq1": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static inline int\nstrcaseeq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[1], s21))\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return strcaseeq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "strcaseeq0": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static inline int\nstrcaseeq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (CASEEQ (s1[0], s20))\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return strcaseeq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/c-strncasecmp.c": {
    "c_strncasecmp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nc_strncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = c_tolower (*p1);\n      c2 = c_tolower (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/canonicalize-lgpl.c": {
    "__realpath": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "char *\n__realpath (const char *name, char *resolved)\n{\n  char *rpath, *dest, *extra_buf = NULL;\n  const char *start, *end, *rpath_limit;\n  long int path_max;\n  int num_links = 0;\n  size_t prefix_len;\n\n  if (name == NULL)\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         either parameter is a null pointer.  We extend this to allow\n         the RESOLVED parameter to be NULL in case the we are expected to\n         allocate the room for the return value.  */\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (name[0] == '\\0')\n    {\n      /* As per Single Unix Specification V2 we must return an error if\n         the name argument points to an empty string.  */\n      __set_errno (ENOENT);\n      return NULL;\n    }\n\n#ifdef PATH_MAX\n  path_max = PATH_MAX;\n#else\n  path_max = pathconf (name, _PC_PATH_MAX);\n  if (path_max <= 0)\n    path_max = 8192;\n#endif\n\n  if (resolved == NULL)\n    {\n      rpath = malloc (path_max);\n      if (rpath == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' gnulib module.  */\n          errno = ENOMEM;\n          return NULL;\n        }\n    }\n  else\n    rpath = resolved;\n  rpath_limit = rpath + path_max;\n\n  /* This is always zero for Posix hosts, but can be 2 for MS-Windows\n     and MS-DOS X:/foo/bar file names.  */\n  prefix_len = FILE_SYSTEM_PREFIX_LEN (name);\n\n  if (!IS_ABSOLUTE_FILE_NAME (name))\n    {\n      if (!__getcwd (rpath, path_max))\n        {\n          rpath[0] = '\\0';\n          goto error;\n        }\n      dest = strchr (rpath, '\\0');\n      start = name;\n      prefix_len = FILE_SYSTEM_PREFIX_LEN (rpath);\n    }\n  else\n    {\n      dest = rpath;\n      if (prefix_len)\n        {\n          memcpy (rpath, name, prefix_len);\n          dest += prefix_len;\n        }\n      *dest++ = '/';\n      if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n        {\n          if (ISSLASH (name[1]) && !ISSLASH (name[2]) && !prefix_len)\n            *dest++ = '/';\n          *dest = '\\0';\n        }\n      start = name + prefix_len;\n    }\n\n  for (end = start; *start; start = end)\n    {\n#ifdef _LIBC\n      struct stat64 st;\n#else\n      struct stat st;\n#endif\n      int n;\n\n      /* Skip sequence of multiple path-separators.  */\n      while (ISSLASH (*start))\n        ++start;\n\n      /* Find end of path component.  */\n      for (end = start; *end && !ISSLASH (*end); ++end)\n        /* Nothing.  */;\n\n      if (end - start == 0)\n        break;\n      else if (end - start == 1 && start[0] == '.')\n        /* nothing */;\n      else if (end - start == 2 && start[0] == '.' && start[1] == '.')\n        {\n          /* Back up to previous component, ignore if at root already.  */\n          if (dest > rpath + prefix_len + 1)\n            for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n              continue;\n          if (DOUBLE_SLASH_IS_DISTINCT_ROOT\n              && dest == rpath + 1 && !prefix_len\n              && ISSLASH (*dest) && !ISSLASH (dest[1]))\n            dest++;\n        }\n      else\n        {\n          size_t new_size;\n\n          if (!ISSLASH (dest[-1]))\n            *dest++ = '/';\n\n          if (dest + (end - start) >= rpath_limit)\n            {\n              ptrdiff_t dest_offset = dest - rpath;\n              char *new_rpath;\n\n              if (resolved)\n                {\n                  __set_errno (ENAMETOOLONG);\n                  if (dest > rpath + prefix_len + 1)\n                    dest--;\n                  *dest = '\\0';\n                  goto error;\n                }\n              new_size = rpath_limit - rpath;\n              if (end - start + 1 > path_max)\n                new_size += end - start + 1;\n              else\n                new_size += path_max;\n              new_rpath = (char *) realloc (rpath, new_size);\n              if (new_rpath == NULL)\n                {\n                  /* It's easier to set errno to ENOMEM than to rely on the\n                     'realloc-posix' gnulib module.  */\n                  errno = ENOMEM;\n                  goto error;\n                }\n              rpath = new_rpath;\n              rpath_limit = rpath + new_size;\n\n              dest = rpath + dest_offset;\n            }\n\n#ifdef _LIBC\n          dest = __mempcpy (dest, start, end - start);\n#else\n          memcpy (dest, start, end - start);\n          dest += end - start;\n#endif\n          *dest = '\\0';\n\n#ifdef _LIBC\n          if (__lxstat64 (_STAT_VER, rpath, &st) < 0)\n#else\n          if (lstat (rpath, &st) < 0)\n#endif\n            goto error;\n\n          if (S_ISLNK (st.st_mode))\n            {\n              char *buf;\n              size_t len;\n\n              if (++num_links > MAXSYMLINKS)\n                {\n                  __set_errno (ELOOP);\n                  goto error;\n                }\n\n              buf = malloca (path_max);\n              if (!buf)\n                {\n                  errno = ENOMEM;\n                  goto error;\n                }\n\n              n = __readlink (rpath, buf, path_max - 1);\n              if (n < 0)\n                {\n                  int saved_errno = errno;\n                  freea (buf);\n                  errno = saved_errno;\n                  goto error;\n                }\n              buf[n] = '\\0';\n\n              if (!extra_buf)\n                {\n                  extra_buf = malloca (path_max);\n                  if (!extra_buf)\n                    {\n                      freea (buf);\n                      errno = ENOMEM;\n                      goto error;\n                    }\n                }\n\n              len = strlen (end);\n              if ((long int) (n + len) >= path_max)\n                {\n                  freea (buf);\n                  __set_errno (ENAMETOOLONG);\n                  goto error;\n                }\n\n              /* Careful here, end may be a pointer into extra_buf... */\n              memmove (&extra_buf[n], end, len + 1);\n              name = end = memcpy (extra_buf, buf, n);\n\n              if (IS_ABSOLUTE_FILE_NAME (buf))\n                {\n                  size_t pfxlen = FILE_SYSTEM_PREFIX_LEN (buf);\n\n                  if (pfxlen)\n                    memcpy (rpath, buf, pfxlen);\n                  dest = rpath + pfxlen;\n                  *dest++ = '/'; /* It's an absolute symlink */\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT)\n                    {\n                      if (ISSLASH (buf[1]) && !ISSLASH (buf[2]) && !pfxlen)\n                        *dest++ = '/';\n                      *dest = '\\0';\n                    }\n                  /* Install the new prefix to be in effect hereafter.  */\n                  prefix_len = pfxlen;\n                }\n              else\n                {\n                  /* Back up to previous component, ignore if at root\n                     already: */\n                  if (dest > rpath + prefix_len + 1)\n                    for (--dest; dest > rpath && !ISSLASH (dest[-1]); --dest)\n                      continue;\n                  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1\n                      && ISSLASH (*dest) && !ISSLASH (dest[1]) && !prefix_len)\n                    dest++;\n                }\n            }\n          else if (!S_ISDIR (st.st_mode) && *end != '\\0')\n            {\n              __set_errno (ENOTDIR);\n              goto error;\n            }\n        }\n    }\n  if (dest > rpath + prefix_len + 1 && ISSLASH (dest[-1]))\n    --dest;\n  if (DOUBLE_SLASH_IS_DISTINCT_ROOT && dest == rpath + 1 && !prefix_len\n      && ISSLASH (*dest) && !ISSLASH (dest[1]))\n    dest++;\n  *dest = '\\0';\n\n  if (extra_buf)\n    freea (extra_buf);\n\n  return rpath;\n\nerror:\n  {\n    int saved_errno = errno;\n    if (extra_buf)\n      freea (extra_buf);\n    if (resolved == NULL)\n      free (rpath);\n    errno = saved_errno;\n  }\n  return NULL;\n}",
      "lines": 279,
      "depth": 24,
      "decorators": [
        "char",
        "*\n__realpath (const char *name, char *resolved)",
        "*"
      ]
    },
    "__old_realpath": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "char *\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)\n{\n  if (resolved == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  return __realpath (name, resolved);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "char",
        "*\nattribute_compat_text_section\n__old_realpath (const char *name, char *resolved)",
        "*",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "__canonicalize_file_name": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "char *\n__canonicalize_file_name (const char *name)\n{\n  return __realpath (name, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\n__canonicalize_file_name (const char *name)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/cloexec.c": {
    "set_cloexec_flag": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nset_cloexec_flag (int desc, bool value)\n{\n#ifdef F_SETFD\n\n  int flags = fcntl (desc, F_GETFD, 0);\n\n  if (0 <= flags)\n    {\n      int newflags = (value ? flags | FD_CLOEXEC : flags & ~FD_CLOEXEC);\n\n      if (flags == newflags\n          || fcntl (desc, F_SETFD, newflags) != -1)\n        return 0;\n    }\n\n  return -1;\n\n#else /* !F_SETFD */\n\n  /* Use dup2 to reject invalid file descriptors; the cloexec flag\n     will be unaffected.  */\n  if (desc < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (dup2 (desc, desc) < 0)\n    /* errno is EBADF here.  */\n    return -1;\n\n  /* There is nothing we can do on this kind of platform.  Punt.  */\n  return 0;\n#endif /* !F_SETFD */\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "dup_cloexec": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ndup_cloexec (int fd)\n{\n  return fcntl (fd, F_DUPFD_CLOEXEC, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/cloexec.h": {},
  "recutils/recutils-1.7/lib/close-stream.c": {
    "close_stream": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\nclose_stream (FILE *stream)\n{\n  const bool some_pending = (__fpending (stream) != 0);\n  const bool prev_fail = (ferror (stream) != 0);\n  const bool fclose_fail = (fclose (stream) != 0);\n\n  /* Return an error indication if there was a previous failure or if\n     fclose failed, with one exception: ignore an fclose failure if\n     there was no previous error, no data remains to be flushed, and\n     fclose failed with EBADF.  That can happen when a program like cp\n     is invoked like this 'cp a b >&-' (i.e., with standard output\n     closed) and doesn't generate any output (hence no previous error\n     and nothing to be flushed).  */\n\n  if (prev_fail || (fclose_fail && (some_pending || errno != EBADF)))\n    {\n      if (! fclose_fail)\n        errno = 0;\n      return EOF;\n    }\n\n  return 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/close-stream.h": {},
  "recutils/recutils-1.7/lib/close.c": {
    "close_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\nclose_nothrow (int fd)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = close (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_close": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\nrpl_close (int fd)\n{\n#if WINDOWS_SOCKETS\n  int retval = execute_all_close_hooks (close_nothrow, fd);\n#else\n  int retval = close_nothrow (fd);\n#endif\n\n#if REPLACE_FCHDIR\n  if (retval >= 0)\n    _gl_unregister_fd (fd);\n#endif\n\n  return retval;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/closeout.c": {
    "close_stdout_set_file_name": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nclose_stdout_set_file_name (const char *file)\n{\n  file_name = file;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "close_stdout_set_ignore_EPIPE": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nclose_stdout_set_ignore_EPIPE (bool ignore)\n{\n  ignore_EPIPE = ignore;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "close_stdout": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nclose_stdout (void)\n{\n  if (close_stream (stdout) != 0\n      && !(ignore_EPIPE && errno == EPIPE))\n    {\n      char const *write_error = _(\"write error\");\n      if (file_name)\n        error (0, errno, \"%s: %s\", quotearg_colon (file_name),\n               write_error);\n      else\n        error (0, errno, \"%s\", write_error);\n\n      _exit (exit_failure);\n    }\n\n   if (close_stream (stderr) != 0)\n     _exit (exit_failure);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/closeout.h": {},
  "recutils/recutils-1.7/lib/copy-acl.c": {
    "copy_acl": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\ncopy_acl (const char *src_name, int source_desc, const char *dst_name,\n          int dest_desc, mode_t mode)\n{\n  int ret = qcopy_acl (src_name, source_desc, dst_name, dest_desc, mode);\n  switch (ret)\n    {\n    case -2:\n      error (0, errno, \"%s\", quote (src_name));\n      break;\n\n    case -1:\n      error (0, errno, _(\"preserving permissions for %s\"), quote (dst_name));\n      break;\n\n    default:\n      break;\n    }\n  return ret;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/crc.c": {
    "crc32_update_no_xor": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "uint32_t\ncrc32_update_no_xor (uint32_t crc, const char *buf, size_t len)\n{\n  size_t n;\n\n  for (n = 0; n < len; n++)\n    crc = crc32_table[(crc ^ buf[n]) & 0xff] ^ (crc >> 8);\n\n  return crc;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "uint32_t"
      ]
    },
    "crc32_no_xor": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "uint32_t\ncrc32_no_xor (const char *buf, size_t len)\n{\n  return crc32_update_no_xor (0L, buf, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "uint32_t"
      ]
    },
    "crc32_update": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "uint32_t\ncrc32_update (uint32_t crc, const char *buf, size_t len)\n{\n  return crc32_update_no_xor (crc ^ 0xffffffff, buf, len) ^ 0xffffffff;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "uint32_t"
      ]
    },
    "crc32": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "uint32_t\ncrc32 (const char *buf, size_t len)\n{\n  return crc32_update (0L, buf, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "uint32_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/crc.h": {},
  "recutils/recutils-1.7/lib/dirname-lgpl.c": {
    "dir_len": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\ndir_len (char const *file)\n{\n  size_t prefix_length = FILE_SYSTEM_PREFIX_LEN (file);\n  size_t length;\n\n  /* Advance prefix_length beyond important leading slashes.  */\n  prefix_length += (prefix_length != 0\n                    ? (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                       && ISSLASH (file[prefix_length]))\n                    : (ISSLASH (file[0])\n                       ? ((DOUBLE_SLASH_IS_DISTINCT_ROOT\n                           && ISSLASH (file[1]) && ! ISSLASH (file[2])\n                           ? 2 : 1))\n                       : 0));\n\n  /* Strip the basename and any redundant slashes before it.  */\n  for (length = last_component (file) - file;\n       prefix_length < length; length--)\n    if (! ISSLASH (file[length - 1]))\n      break;\n  return length;\n}",
      "lines": 23,
      "depth": 17,
      "decorators": [
        "size_t"
      ]
    },
    "mdir_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\nmdir_name (char const *file)\n{\n  size_t length = dir_len (file);\n  bool append_dot = (length == 0\n                     || (FILE_SYSTEM_DRIVE_PREFIX_CAN_BE_RELATIVE\n                         && length == FILE_SYSTEM_PREFIX_LEN (file)\n                         && file[2] != '\\0' && ! ISSLASH (file[2])));\n  char *dir = malloc (length + append_dot + 1);\n  if (!dir)\n    return NULL;\n  memcpy (dir, file, length);\n  if (append_dot)\n    dir[length++] = '.';\n  dir[length] = '\\0';\n  return dir;\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmdir_name (char const *file)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/dirname.h": {},
  "recutils/recutils-1.7/lib/dosname.h": {},
  "recutils/recutils-1.7/lib/dup2.c": {
    "ms_windows_dup2": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        71,
        5
      ],
      "content": "static int\nms_windows_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n  /* If fd is closed, mingw hangs on dup2 (fd, fd).  If fd is open,\n     dup2 (fd, fd) returns 0, but all further attempts to use fd in\n     future dup2 calls will hang.  */\n  if (fd == desired_fd)\n    {\n      if ((HANDLE) _get_osfhandle (fd) == INVALID_HANDLE_VALUE)\n        {\n          errno = EBADF;\n          return -1;\n        }\n      return fd;\n    }\n\n  /* Wine 1.0.1 return 0 when desired_fd is negative but not -1:\n     http://bugs.winehq.org/show_bug.cgi?id=21289 */\n  if (desired_fd < 0)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  TRY_MSVC_INVAL\n    {\n      result = dup2 (fd, desired_fd);\n    }",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_dup2": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrpl_dup2 (int fd, int desired_fd)\n{\n  int result;\n\n# ifdef F_GETFL\n  /* On Linux kernels 2.6.26-2.6.29, dup2 (fd, fd) returns -EBADF.\n     On Cygwin 1.5.x, dup2 (1, 1) returns 0.\n     On Cygwin 1.7.17, dup2 (1, -1) dumps core.\n     On Cygwin 1.7.25, dup2 (1, 256) can dump core.\n     On Haiku, dup2 (fd, fd) mistakenly clears FD_CLOEXEC.  */\n#  if HAVE_SETDTABLESIZE\n  setdtablesize (desired_fd + 1);\n#  endif\n  if (desired_fd < 0)\n    fd = desired_fd;\n  if (fd == desired_fd)\n    return fcntl (fd, F_GETFL) == -1 ? -1 : fd;\n# endif\n\n  result = dup2 (fd, desired_fd);\n\n  /* Correct an errno value on FreeBSD 6.1 and Cygwin 1.5.x.  */\n  if (result == -1 && errno == EMFILE)\n    errno = EBADF;\n# if REPLACE_FCHDIR\n  if (fd != desired_fd && result != -1)\n    result = _gl_register_dup (fd, result);\n# endif\n  return result;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "dupfd": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static int\ndupfd (int fd, int desired_fd)\n{\n  int duplicated_fd = dup (fd);\n  if (duplicated_fd < 0 || duplicated_fd == desired_fd)\n    return duplicated_fd;\n  else\n    {\n      int r = dupfd (fd, desired_fd);\n      int e = errno;\n      close (duplicated_fd);\n      errno = e;\n      return r;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup2": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "int\ndup2 (int fd, int desired_fd)\n{\n  int result = fcntl (fd, F_GETFL) < 0 ? -1 : fd;\n  if (result == -1 || fd == desired_fd)\n    return result;\n  close (desired_fd);\n# ifdef F_DUPFD\n  result = fcntl (fd, F_DUPFD, desired_fd);\n#  if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (fd, result);\n#  endif\n# else\n  result = dupfd (fd, desired_fd);\n# endif\n  if (result == -1 && (errno == EMFILE || errno == EINVAL))\n    errno = EBADF;\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/errno.in.h": {},
  "recutils/recutils-1.7/lib/error.c": {
    "is_open": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static int\nis_open (int fd)\n{\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* On native Windows: The initial state of unassigned standard file\n     descriptors is that they are open but point to an INVALID_HANDLE_VALUE.\n     There is no fcntl, and the gnulib replacement fcntl does not support\n     F_GETFL.  */\n  return (HANDLE) _get_osfhandle (fd) != INVALID_HANDLE_VALUE;\n# else\n#  ifndef F_GETFL\n#   error Please port fcntl to your platform\n#  endif\n  return 0 <= fcntl (fd, F_GETFL);\n# endif\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "flush_stdout": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "static void\nflush_stdout (void)\n{\n#if !_LIBC\n  int stdout_fd;\n\n# if GNULIB_FREOPEN_SAFER\n  /* Use of gnulib's freopen-safer module normally ensures that\n       fileno (stdout) == 1\n     whenever stdout is open.  */\n  stdout_fd = STDOUT_FILENO;\n# else\n  /* POSIX states that fileno (stdout) after fclose is unspecified.  But in\n     practice it is not a problem, because stdout is statically allocated and\n     the fd of a FILE stream is stored as a field in its allocated memory.  */\n  stdout_fd = fileno (stdout);\n# endif\n  /* POSIX states that fflush (stdout) after fclose is unspecified; it\n     is safe in glibc, but not on all other platforms.  fflush (NULL)\n     is always defined, but too draconian.  */\n  if (0 <= stdout_fd && is_open (stdout_fd))\n#endif\n    fflush (stdout);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_errno_message": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\nprint_errno_message (int errnum)\n{\n  char const *s;\n\n#if defined HAVE_STRERROR_R || _LIBC\n  char errbuf[1024];\n# if STRERROR_R_CHAR_P || _LIBC\n  s = __strerror_r (errnum, errbuf, sizeof errbuf);\n# else\n  if (__strerror_r (errnum, errbuf, sizeof errbuf) == 0)\n    s = errbuf;\n  else\n    s = 0;\n# endif\n#else\n  s = strerror (errnum);\n#endif\n\n#if !_LIBC\n  if (! s)\n    s = _(\"Unknown system error\");\n#endif\n\n#if _LIBC\n  __fxprintf (NULL, \": %s\", s);\n#else\n  fprintf (stderr, \": %s\", s);\n#endif\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_tail": {
      "start_point": [
        198,
        42
      ],
      "end_point": [
        281,
        1
      ],
      "content": "char *message, va_list args)\n{\n#if _LIBC\n  if (_IO_fwide (stderr, 0) > 0)\n    {\n# define ALLOCA_LIMIT 2000\n      size_t len = strlen (message) + 1;\n      wchar_t *wmessage = NULL;\n      mbstate_t st;\n      size_t res;\n      const char *tmp;\n      bool use_malloc = false;\n\n      while (1)\n        {\n          if (__libc_use_alloca (len * sizeof (wchar_t)))\n            wmessage = (wchar_t *) alloca (len * sizeof (wchar_t));\n          else\n            {\n              if (!use_malloc)\n                wmessage = NULL;\n\n              wchar_t *p = (wchar_t *) realloc (wmessage,\n                                                len * sizeof (wchar_t));\n              if (p == NULL)\n                {\n                  free (wmessage);\n                  fputws_unlocked (L\"out of memory\\n\", stderr);\n                  return;\n                }\n              wmessage = p;\n              use_malloc = true;\n            }\n\n          memset (&st, '\\0', sizeof (st));\n          tmp = message;\n\n          res = mbsrtowcs (wmessage, &tmp, len, &st);\n          if (res != len)\n            break;\n\n          if (__builtin_expect (len >= SIZE_MAX / 2, 0))\n            {\n              /* This really should not happen if everything is fine.  */\n              res = (size_t) -1;\n              break;\n            }\n\n          len *= 2;\n        }\n\n      if (res == (size_t) -1)\n        {\n          /* The string cannot be converted.  */\n          if (use_malloc)\n            {\n              free (wmessage);\n              use_malloc = false;\n            }\n          wmessage = (wchar_t *) L\"???\";\n        }\n\n      __vfwprintf (stderr, wmessage, args);\n\n      if (use_malloc)\n        free (wmessage);\n    }\n  else\n#endif\n    vfprintf (stderr, message, args);\n  va_end (args);\n\n  ++error_message_count;\n  if (errnum)\n    print_errno_message (errnum);\n#if _LIBC\n  __fxprintf (NULL, \"\\n\");\n#else\n  putc ('\\n', stderr);\n#endif\n  fflush (stderr);\n  if (status)\n    exit (status);\n}",
      "lines": 84,
      "depth": 18,
      "decorators": null
    },
    "error": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\nerror (int status, int errnum, const char *message, ...)\n{\n  va_list args;\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s: \", program_name);\n#else\n      fprintf (stderr, \"%s: \", program_name);\n#endif\n    }\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "error_at_line": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "void\nerror_at_line (int status, int errnum, const char *file_name,\n               unsigned int line_number, const char *message, ...)\n{\n  va_list args;\n\n  if (error_one_per_line)\n    {\n      static const char *old_file_name;\n      static unsigned int old_line_number;\n\n      if (old_line_number == line_number\n          && (file_name == old_file_name\n              || strcmp (old_file_name, file_name) == 0))\n        /* Simply return and print nothing.  */\n        return;\n\n      old_file_name = file_name;\n      old_line_number = line_number;\n    }\n\n#if defined _LIBC && defined __libc_ptf_call\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __libc_ptf_call (pthread_setcancelstate, (PTHREAD_CANCEL_DISABLE, &state),\n                   0);\n#endif\n\n  flush_stdout ();\n#ifdef _LIBC\n  _IO_flockfile (stderr);\n#endif\n  if (error_print_progname)\n    (*error_print_progname) ();\n  else\n    {\n#if _LIBC\n      __fxprintf (NULL, \"%s:\", program_name);\n#else\n      fprintf (stderr, \"%s:\", program_name);\n#endif\n    }\n\n#if _LIBC\n  __fxprintf (NULL, file_name != NULL ? \"%s:%d: \" : \" \",\n              file_name, line_number);\n#else\n  fprintf (stderr, file_name != NULL ? \"%s:%d: \" : \" \",\n           file_name, line_number);\n#endif\n\n  va_start (args, message);\n  error_tail (status, errnum, message, args);\n\n#ifdef _LIBC\n  _IO_funlockfile (stderr);\n# ifdef __libc_ptf_call\n  __libc_ptf_call (pthread_setcancelstate, (state, NULL), 0);\n# endif\n#endif\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/error.h": {},
  "recutils/recutils-1.7/lib/euidaccess.c": {
    "euidaccess": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\neuidaccess (const char *file, int mode)\n{\n#if HAVE_FACCESSAT                   /* glibc, AIX 7, Solaris 11, Cygwin 1.7 */\n  return faccessat (AT_FDCWD, file, mode, AT_EACCESS);\n#elif defined EFF_ONLY_OK               /* IRIX, OSF/1, Interix */\n  return access (file, mode | EFF_ONLY_OK);\n#elif defined ACC_SELF                  /* AIX */\n  return accessx (file, mode, ACC_SELF);\n#elif HAVE_EACCESS                      /* FreeBSD */\n  return eaccess (file, mode);\n#else       /* Mac OS X, NetBSD, OpenBSD, HP-UX, Solaris, Cygwin, mingw, BeOS */\n\n  uid_t uid = getuid ();\n  gid_t gid = getgid ();\n  uid_t euid = geteuid ();\n  gid_t egid = getegid ();\n  struct stat stats;\n\n# if HAVE_DECL_SETREGID && PREFER_NONREENTRANT_EUIDACCESS\n\n  /* Define PREFER_NONREENTRANT_EUIDACCESS if you prefer euidaccess to\n     return the correct result even if this would make it\n     nonreentrant.  Define this only if your entire application is\n     safe even if the uid or gid might temporarily change.  If your\n     application uses signal handlers or threads it is probably not\n     safe.  */\n\n  if (mode == F_OK)\n    return stat (file, &stats);\n  else\n    {\n      int result;\n      int saved_errno;\n\n      if (uid != euid)\n        setreuid (euid, uid);\n      if (gid != egid)\n        setregid (egid, gid);\n\n      result = access (file, mode);\n      saved_errno = errno;\n\n      /* Restore them.  */\n      if (uid != euid)\n        setreuid (uid, euid);\n      if (gid != egid)\n        setregid (gid, egid);\n\n      errno = saved_errno;\n      return result;\n    }\n\n# else\n\n  /* The following code assumes the traditional Unix model, and is not\n     correct on systems that have ACLs or the like.  However, it's\n     better than nothing, and it is reentrant.  */\n\n  unsigned int granted;\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (file, mode);\n\n  if (stat (file, &stats) != 0)\n    return -1;\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute.  */\n  if (euid == ROOT_UID\n      && ((mode & X_OK) == 0\n          || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  /* Convert the mode to traditional form, clearing any bogus bits.  */\n  if (R_OK == 4 && W_OK == 2 && X_OK == 1 && F_OK == 0)\n    mode &= 7;\n  else\n    mode = ((mode & R_OK ? 4 : 0)\n            + (mode & W_OK ? 2 : 0)\n            + (mode & X_OK ? 1 : 0));\n\n  if (mode == 0)\n    return 0;                   /* The file exists.  */\n\n  /* Convert the file's permission bits to traditional form.  */\n  if (S_IRUSR == (4 << 6) && S_IWUSR == (2 << 6) && S_IXUSR == (1 << 6)\n      && S_IRGRP == (4 << 3) && S_IWGRP == (2 << 3) && S_IXGRP == (1 << 3)\n      && S_IROTH == (4 << 0) && S_IWOTH == (2 << 0) && S_IXOTH == (1 << 0))\n    granted = stats.st_mode;\n  else\n    granted = ((stats.st_mode & S_IRUSR ? 4 << 6 : 0)\n               + (stats.st_mode & S_IWUSR ? 2 << 6 : 0)\n               + (stats.st_mode & S_IXUSR ? 1 << 6 : 0)\n               + (stats.st_mode & S_IRGRP ? 4 << 3 : 0)\n               + (stats.st_mode & S_IWGRP ? 2 << 3 : 0)\n               + (stats.st_mode & S_IXGRP ? 1 << 3 : 0)\n               + (stats.st_mode & S_IROTH ? 4 << 0 : 0)\n               + (stats.st_mode & S_IWOTH ? 2 << 0 : 0)\n               + (stats.st_mode & S_IXOTH ? 1 << 0 : 0));\n\n  if (euid == stats.st_uid)\n    granted >>= 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted >>= 3;\n\n  if ((mode & ~granted) == 0)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n\n# endif\n#endif\n}",
      "lines": 114,
      "depth": 26,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char *file;\n  int mode;\n  int err;\n\n  program_name = argv[0];\n  if (argc < 3)\n    abort ();\n  file = argv[1];\n  mode = atoi (argv[2]);\n\n  err = euidaccess (file, mode);\n  printf (\"%d\\n\", err);\n  if (err != 0)\n    error (0, errno, \"%s\", file);\n  exit (0);\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/execute.c": {
    "nonintr_close": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static int\nnonintr_close (int fd)\n{\n  int retval;\n\n  do\n    retval = close (fd);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "nonintr_open": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\nnonintr_open (const char *pathname, int oflag, mode_t mode)\n{\n  int retval;\n\n  do\n    retval = open (pathname, oflag, mode);\n  while (retval < 0 && errno == EINTR);\n\n  return retval;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "execute": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "int\nexecute (const char *progname,\n         const char *prog_path, char **prog_argv,\n         bool ignore_sigpipe,\n         bool null_stdin, bool null_stdout, bool null_stderr,\n         bool slave_process, bool exit_on_error,\n         int *termsigp)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n\n  /* Native Windows API.  */\n  int orig_stdin;\n  int orig_stdout;\n  int orig_stderr;\n  int exitcode;\n  int nullinfd;\n  int nulloutfd;\n\n  /* FIXME: Need to free memory allocated by prepare_spawn.  */\n  prog_argv = prepare_spawn (prog_argv);\n\n  /* Save standard file handles of parent process.  */\n  if (null_stdin)\n    orig_stdin = dup_safer_noinherit (STDIN_FILENO);\n  if (null_stdout)\n    orig_stdout = dup_safer_noinherit (STDOUT_FILENO);\n  if (null_stderr)\n    orig_stderr = dup_safer_noinherit (STDERR_FILENO);\n  exitcode = -1;\n\n  /* Create standard file handles of child process.  */\n  nullinfd = -1;\n  nulloutfd = -1;\n  if ((!null_stdin\n       || ((nullinfd = open (\"NUL\", O_RDONLY, 0)) >= 0\n           && (nullinfd == STDIN_FILENO\n               || (dup2 (nullinfd, STDIN_FILENO) >= 0\n                   && close (nullinfd) >= 0))))\n      && (!(null_stdout || null_stderr)\n          || ((nulloutfd = open (\"NUL\", O_RDWR, 0)) >= 0\n              && (!null_stdout\n                  || nulloutfd == STDOUT_FILENO\n                  || dup2 (nulloutfd, STDOUT_FILENO) >= 0)\n              && (!null_stderr\n                  || nulloutfd == STDERR_FILENO\n                  || dup2 (nulloutfd, STDERR_FILENO) >= 0)\n              && ((null_stdout && nulloutfd == STDOUT_FILENO)\n                  || (null_stderr && nulloutfd == STDERR_FILENO)\n                  || close (nulloutfd) >= 0))))\n    /* Use spawnvpe and pass the environment explicitly.  This is needed if\n       the program has modified the environment using putenv() or [un]setenv().\n       On Windows, programs have two environments, one in the \"environment\n       block\" of the process and managed through SetEnvironmentVariable(), and\n       one inside the process, in the location retrieved by the 'environ'\n       macro.  When using spawnvp() without 'e', the child process inherits a\n       copy of the environment block - ignoring the effects of putenv() and\n       [un]setenv().  */\n    {\n      exitcode = spawnvpe (P_WAIT, prog_path, (const char **) prog_argv,\n                           (const char **) environ);\n      if (exitcode < 0 && errno == ENOEXEC)\n        {\n          /* prog is not a native executable.  Try to execute it as a\n             shell script.  Note that prepare_spawn() has already prepended\n             a hidden element \"sh.exe\" to prog_argv.  */\n          --prog_argv;\n          exitcode = spawnvpe (P_WAIT, prog_argv[0], (const char **) prog_argv,\n                               (const char **) environ);\n        }\n    }\n  if (nulloutfd >= 0)\n    close (nulloutfd);\n  if (nullinfd >= 0)\n    close (nullinfd);\n\n  /* Restore standard file handles of parent process.  */\n  if (null_stderr)\n    undup_safer_noinherit (orig_stderr, STDERR_FILENO);\n  if (null_stdout)\n    undup_safer_noinherit (orig_stdout, STDOUT_FILENO);\n  if (null_stdin)\n    undup_safer_noinherit (orig_stdin, STDIN_FILENO);\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n\n  if (exitcode == -1)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, errno,\n               _(\"%s subprocess failed\"), progname);\n      return 127;\n    }\n\n  return exitcode;\n\n#else\n\n  /* Unix API.  */\n  /* Note about 127: Some errors during posix_spawnp() cause the function\n     posix_spawnp() to return an error code; some other errors cause the\n     subprocess to exit with return code 127.  It is implementation\n     dependent which error is reported which way.  We treat both cases as\n     equivalent.  */\n  sigset_t blocked_signals;\n  posix_spawn_file_actions_t actions;\n  bool actions_allocated;\n  posix_spawnattr_t attrs;\n  bool attrs_allocated;\n  int err;\n  pid_t child;\n\n  if (slave_process)\n    {\n      sigprocmask (SIG_SETMASK, NULL, &blocked_signals);\n      block_fatal_signals ();\n    }\n  actions_allocated = false;\n  attrs_allocated = false;\n  if ((err = posix_spawn_file_actions_init (&actions)) != 0\n      || (actions_allocated = true,\n          (null_stdin\n            && (err = posix_spawn_file_actions_addopen (&actions,\n                                                        STDIN_FILENO,\n                                                        \"/dev/null\", O_RDONLY,\n                                                        0))\n               != 0)\n          || (null_stdout\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDOUT_FILENO,\n                                                          \"/dev/null\", O_RDWR,\n                                                          0))\n                 != 0)\n          || (null_stderr\n              && (err = posix_spawn_file_actions_addopen (&actions,\n                                                          STDERR_FILENO,\n                                                          \"/dev/null\", O_RDWR,\n                                                          0))\n                 != 0)\n          || (slave_process\n              && ((err = posix_spawnattr_init (&attrs)) != 0\n                  || (attrs_allocated = true,\n                      (err = posix_spawnattr_setsigmask (&attrs,\n                                                         &blocked_signals))\n                      != 0\n                      || (err = posix_spawnattr_setflags (&attrs,\n                                                        POSIX_SPAWN_SETSIGMASK))\n                         != 0)))\n          || (err = posix_spawnp (&child, prog_path, &actions,\n                                  attrs_allocated ? &attrs : NULL, prog_argv,\n                                  environ))\n             != 0))\n    {\n      if (actions_allocated)\n        posix_spawn_file_actions_destroy (&actions);\n      if (attrs_allocated)\n        posix_spawnattr_destroy (&attrs);\n      if (slave_process)\n        unblock_fatal_signals ();\n      if (termsigp != NULL)\n        *termsigp = 0;\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, err,\n               _(\"%s subprocess failed\"), progname);\n      return 127;\n    }\n  posix_spawn_file_actions_destroy (&actions);\n  if (attrs_allocated)\n    posix_spawnattr_destroy (&attrs);\n  if (slave_process)\n    {\n      register_slave_subprocess (child);\n      unblock_fatal_signals ();\n    }\n\n  return wait_subprocess (child, progname, ignore_sigpipe, null_stderr,\n                          slave_process, exit_on_error, termsigp);\n\n#endif\n}",
      "lines": 180,
      "depth": 25,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/execute.h": {},
  "recutils/recutils-1.7/lib/exitfail.c": {},
  "recutils/recutils-1.7/lib/exitfail.h": {},
  "recutils/recutils-1.7/lib/fatal-signal.c": {
    "init_fatal_signals": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\ninit_fatal_signals (void)\n{\n  static bool fatal_signals_initialized = false;\n  if (!fatal_signals_initialized)\n    {\n      size_t i;\n\n      for (i = 0; i < num_fatal_signals; i++)\n        {\n          struct sigaction action;\n\n          if (sigaction (fatal_signals[i], NULL, &action) >= 0\n              && get_handler (&action) == SIG_IGN)\n            fatal_signals[i] = -1;\n        }\n\n      fatal_signals_initialized = true;\n    }\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uninstall_handlers": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\nuninstall_handlers (void)\n{\n  size_t i;\n\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n        if (saved_sigactions[sig].sa_handler == SIG_IGN)\n          saved_sigactions[sig].sa_handler = SIG_DFL;\n        sigaction (sig, &saved_sigactions[sig], NULL);\n      }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "fatal_signal_handler": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nfatal_signal_handler (int sig)\n{\n  for (;;)\n    {\n      /* Get the last registered cleanup action, in a reentrant way.  */\n      action_t action;\n      size_t n = actions_count;\n      if (n == 0)\n        break;\n      n--;\n      actions_count = n;\n      action = actions[n].action;\n      /* Execute the action.  */\n      action ();\n    }\n\n  /* Now execute the signal's default action.\n     If the signal being delivered was blocked, the re-raised signal would be\n     delivered when this handler returns.  But the way we install this handler,\n     no signal is blocked, and the re-raised signal is delivered already\n     during raise().  */\n  uninstall_handlers ();\n  raise (sig);\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "install_handlers": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static void\ninstall_handlers (void)\n{\n  size_t i;\n  struct sigaction action;\n\n  action.sa_handler = &fatal_signal_handler;\n  /* If we get a fatal signal while executing fatal_signal_handler, enter\n     fatal_signal_handler recursively, since it is reentrant.  Hence no\n     SA_RESETHAND.  */\n  action.sa_flags = SA_NODEFER;\n  sigemptyset (&action.sa_mask);\n  for (i = 0; i < num_fatal_signals; i++)\n    if (fatal_signals[i] >= 0)\n      {\n        int sig = fatal_signals[i];\n\n        if (!(sig < sizeof (saved_sigactions) / sizeof (saved_sigactions[0])))\n          abort ();\n        sigaction (sig, &action, &saved_sigactions[sig]);\n      }\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "at_fatal_signal": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\nat_fatal_signal (action_t action)\n{\n  static bool cleanup_initialized = false;\n  if (!cleanup_initialized)\n    {\n      init_fatal_signals ();\n      install_handlers ();\n      cleanup_initialized = true;\n    }\n\n  if (actions_count == actions_allocated)\n    {\n      /* Extend the actions array.  Note that we cannot use xrealloc(),\n         because then the cleanup() function could access an already\n         deallocated array.  */\n      actions_entry_t *old_actions = actions;\n      size_t old_actions_allocated = actions_allocated;\n      size_t new_actions_allocated = 2 * actions_allocated;\n      actions_entry_t *new_actions =\n        XNMALLOC (new_actions_allocated, actions_entry_t);\n      size_t k;\n\n      /* Don't use memcpy() here, because memcpy takes non-volatile arguments\n         and is therefore not guaranteed to complete all memory stores before\n         the next statement.  */\n      for (k = 0; k < old_actions_allocated; k++)\n        new_actions[k] = old_actions[k];\n      actions = new_actions;\n      actions_allocated = new_actions_allocated;\n      /* Now we can free the old actions array.  */\n      if (old_actions != static_actions)\n        free (old_actions);\n    }\n  /* The two uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the actions_count only after\n     the new action has been written to the memory location\n     actions[actions_count].  */\n  actions[actions_count].action = action;\n  actions_count++;\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "init_fatal_signal_set": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void\ninit_fatal_signal_set (void)\n{\n  static bool fatal_signal_set_initialized = false;\n  if (!fatal_signal_set_initialized)\n    {\n      size_t i;\n\n      init_fatal_signals ();\n\n      sigemptyset (&fatal_signal_set);\n      for (i = 0; i < num_fatal_signals; i++)\n        if (fatal_signals[i] >= 0)\n          sigaddset (&fatal_signal_set, fatal_signals[i]);\n\n      fatal_signal_set_initialized = true;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "block_fatal_signals": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_BLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "unblock_fatal_signals": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "void\nunblock_fatal_signals (void)\n{\n  init_fatal_signal_set ();\n  sigprocmask (SIG_UNBLOCK, &fatal_signal_set, NULL);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fatal-signal.h": {},
  "recutils/recutils-1.7/lib/fcntl.c": {
    "dupfd": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static int\ndupfd (int oldfd, int newfd, int flags)\n{\n  /* Mingw has no way to create an arbitrary fd.  Iterate until all\n     file descriptors less than newfd are filled up.  */\n  HANDLE curr_process = GetCurrentProcess ();\n  HANDLE old_handle = (HANDLE) _get_osfhandle (oldfd);\n  unsigned char fds_to_close[OPEN_MAX_MAX / CHAR_BIT];\n  unsigned int fds_to_close_bound = 0;\n  int result;\n  BOOL inherit = flags & O_CLOEXEC ? FALSE : TRUE;\n  int mode;\n\n  if (newfd < 0 || getdtablesize () <= newfd)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  if (old_handle == INVALID_HANDLE_VALUE\n      || (mode = setmode (oldfd, O_BINARY)) == -1)\n    {\n      /* oldfd is not open, or is an unassigned standard file\n         descriptor.  */\n      errno = EBADF;\n      return -1;\n    }\n  setmode (oldfd, mode);\n  flags |= mode;\n\n  for (;;)\n    {\n      HANDLE new_handle;\n      int duplicated_fd;\n      unsigned int index;\n\n      if (!DuplicateHandle (curr_process,           /* SourceProcessHandle */\n                            old_handle,             /* SourceHandle */\n                            curr_process,           /* TargetProcessHandle */\n                            (PHANDLE) &new_handle,  /* TargetHandle */\n                            (DWORD) 0,              /* DesiredAccess */\n                            inherit,                /* InheritHandle */\n                            DUPLICATE_SAME_ACCESS)) /* Options */\n        {\n          /* TODO: Translate GetLastError () into errno.  */\n          errno = EMFILE;\n          result = -1;\n          break;\n        }\n      duplicated_fd = _open_osfhandle ((intptr_t) new_handle, flags);\n      if (duplicated_fd < 0)\n        {\n          CloseHandle (new_handle);\n          errno = EMFILE;\n          result = -1;\n          break;\n        }\n      if (newfd <= duplicated_fd)\n        {\n          result = duplicated_fd;\n          break;\n        }\n\n      /* Set the bit duplicated_fd in fds_to_close[].  */\n      index = (unsigned int) duplicated_fd / CHAR_BIT;\n      if (fds_to_close_bound <= index)\n        {\n          if (sizeof fds_to_close <= index)\n            /* Need to increase OPEN_MAX_MAX.  */\n            abort ();\n          memset (fds_to_close + fds_to_close_bound, '\\0',\n                  index + 1 - fds_to_close_bound);\n          fds_to_close_bound = index + 1;\n        }\n      fds_to_close[index] |= 1 << ((unsigned int) duplicated_fd % CHAR_BIT);\n    }\n\n  /* Close the previous fds that turned out to be too small.  */\n  {\n    int saved_errno = errno;\n    unsigned int duplicated_fd;\n\n    for (duplicated_fd = 0;\n         duplicated_fd < fds_to_close_bound * CHAR_BIT;\n         duplicated_fd++)\n      if ((fds_to_close[duplicated_fd / CHAR_BIT]\n           >> (duplicated_fd % CHAR_BIT))\n          & 1)\n        close (duplicated_fd);\n\n    errno = saved_errno;\n  }\n\n# if REPLACE_FCHDIR\n  if (0 <= result)\n    result = _gl_register_dup (oldfd, result);\n# endif\n  return result;\n}",
      "lines": 98,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fcntl": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "int\nrpl_fcntl (int fd, int action, /* arg */...)\n{\n  va_list arg;\n  int result = -1;\n  va_start (arg, action);\n  switch (action)\n    {\n\n#if !HAVE_FCNTL\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        result = dupfd (fd, target, 0);\n        break;\n      }\n#elif FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR\n    case F_DUPFD:\n      {\n        int target = va_arg (arg, int);\n        /* Detect invalid target; needed for cygwin 1.5.x.  */\n        if (target < 0 || getdtablesize () <= target)\n          errno = EINVAL;\n        else\n          {\n            /* Haiku alpha 2 loses fd flags on original.  */\n            int flags = fcntl (fd, F_GETFD);\n            if (flags < 0)\n              {\n                result = -1;\n                break;\n              }\n            result = fcntl (fd, action, target);\n            if (0 <= result && fcntl (fd, F_SETFD, flags) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                result = -1;\n                errno = saved_errno;\n              }\n# if REPLACE_FCHDIR\n            if (0 <= result)\n              result = _gl_register_dup (fd, result);\n# endif\n          }\n        break;\n      } /* F_DUPFD */\n#endif /* FCNTL_DUPFD_BUGGY || REPLACE_FCHDIR */\n\n    case F_DUPFD_CLOEXEC:\n      {\n        int target = va_arg (arg, int);\n\n#if !HAVE_FCNTL\n        result = dupfd (fd, target, O_CLOEXEC);\n        break;\n#else /* HAVE_FCNTL */\n        /* Try the system call first, if the headers claim it exists\n           (that is, if GNULIB_defined_F_DUPFD_CLOEXEC is 0), since we\n           may be running with a glibc that has the macro but with an\n           older kernel that does not support it.  Cache the\n           information on whether the system call really works, but\n           avoid caching failure if the corresponding F_DUPFD fails\n           for any reason.  0 = unknown, 1 = yes, -1 = no.  */\n        static int have_dupfd_cloexec = GNULIB_defined_F_DUPFD_CLOEXEC ? -1 : 0;\n        if (0 <= have_dupfd_cloexec)\n          {\n            result = fcntl (fd, action, target);\n            if (0 <= result || errno != EINVAL)\n              {\n                have_dupfd_cloexec = 1;\n# if REPLACE_FCHDIR\n                if (0 <= result)\n                  result = _gl_register_dup (fd, result);\n# endif\n              }\n            else\n              {\n                result = rpl_fcntl (fd, F_DUPFD, target);\n                if (result < 0)\n                  break;\n                have_dupfd_cloexec = -1;\n              }\n          }\n        else\n          result = rpl_fcntl (fd, F_DUPFD, target);\n        if (0 <= result && have_dupfd_cloexec == -1)\n          {\n            int flags = fcntl (result, F_GETFD);\n            if (flags < 0 || fcntl (result, F_SETFD, flags | FD_CLOEXEC) == -1)\n              {\n                int saved_errno = errno;\n                close (result);\n                errno = saved_errno;\n                result = -1;\n              }\n          }\n        break;\n#endif /* HAVE_FCNTL */\n      } /* F_DUPFD_CLOEXEC */\n\n#if !HAVE_FCNTL\n    case F_GETFD:\n      {\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n        HANDLE handle = (HANDLE) _get_osfhandle (fd);\n        DWORD flags;\n        if (handle == INVALID_HANDLE_VALUE\n            || GetHandleInformation (handle, &flags) == 0)\n          errno = EBADF;\n        else\n          result = (flags & HANDLE_FLAG_INHERIT) ? 0 : FD_CLOEXEC;\n# else /* !W32 */\n        /* Use dup2 to reject invalid file descriptors.  No way to\n           access this information, so punt.  */\n        if (0 <= dup2 (fd, fd))\n          result = 0;\n# endif /* !W32 */\n        break;\n      } /* F_GETFD */\n#endif /* !HAVE_FCNTL */\n\n      /* Implementing F_SETFD on mingw is not trivial - there is no\n         API for changing the O_NOINHERIT bit on an fd, and merely\n         changing the HANDLE_FLAG_INHERIT bit on the underlying handle\n         can lead to odd state.  It may be possible by duplicating the\n         handle, using _open_osfhandle with the right flags, then\n         using dup2 to move the duplicate onto the original, but that\n         is not supported for now.  */\n\n    default:\n      {\n#if HAVE_FCNTL\n        void *p = va_arg (arg, void *);\n        result = fcntl (fd, action, p);\n#else\n        errno = EINVAL;\n#endif\n        break;\n      }\n    }\n  va_end (arg);\n  return result;\n}",
      "lines": 144,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fcntl.in.h": {},
  "recutils/recutils-1.7/lib/fd-hook.c": {
    "execute_close_hooks": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nexecute_close_hooks (const struct fd_hook *remaining_list, gl_close_fn primary,\n                     int fd)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd);\n  else\n    return remaining_list->private_close_fn (remaining_list->private_next,\n                                             primary, fd);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_close_hooks": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "int\nexecute_all_close_hooks (gl_close_fn primary, int fd)\n{\n  return execute_close_hooks (anchor.private_next, primary, fd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "execute_ioctl_hooks": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nexecute_ioctl_hooks (const struct fd_hook *remaining_list, gl_ioctl_fn primary,\n                     int fd, int request, void *arg)\n{\n  if (remaining_list == &anchor)\n    /* End of list reached.  */\n    return primary (fd, request, arg);\n  else\n    return remaining_list->private_ioctl_fn (remaining_list->private_next,\n                                             primary, fd, request, arg);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "execute_all_ioctl_hooks": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nexecute_all_ioctl_hooks (gl_ioctl_fn primary,\n                         int fd, int request, void *arg)\n{\n  return execute_ioctl_hooks (anchor.private_next, primary, fd, request, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "register_fd_hook": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nregister_fd_hook (close_hook_fn close_hook, ioctl_hook_fn ioctl_hook, struct fd_hook *link)\n{\n  if (close_hook == NULL)\n    close_hook = execute_close_hooks;\n  if (ioctl_hook == NULL)\n    ioctl_hook = execute_ioctl_hooks;\n\n  if (link->private_next == NULL && link->private_prev == NULL)\n    {\n      /* Add the link to the doubly linked list.  */\n      link->private_next = anchor.private_next;\n      link->private_prev = &anchor;\n      link->private_close_fn = close_hook;\n      link->private_ioctl_fn = ioctl_hook;\n      anchor.private_next->private_prev = link;\n      anchor.private_next = link;\n    }\n  else\n    {\n      /* The link is already in use.  */\n      if (link->private_close_fn != close_hook\n          || link->private_ioctl_fn != ioctl_hook)\n        abort ();\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "unregister_fd_hook": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nunregister_fd_hook (struct fd_hook *link)\n{\n  struct fd_hook *next = link->private_next;\n  struct fd_hook *prev = link->private_prev;\n\n  if (next != NULL && prev != NULL)\n    {\n      /* The link is in use.  Remove it from the doubly linked list.  */\n      prev->private_next = next;\n      next->private_prev = prev;\n      /* Clear the link, to mark it unused.  */\n      link->private_next = NULL;\n      link->private_prev = NULL;\n      link->private_close_fn = NULL;\n      link->private_ioctl_fn = NULL;\n    }\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fd-hook.h": {},
  "recutils/recutils-1.7/lib/file-has-acl.c": {
    "acl_extended_nontrivial": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nacl_extended_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it is non-empty.  */\n  return (acl_entries (acl) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "acl_access_nontrivial": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nacl_access_nontrivial (acl_t acl)\n{\n  /* acl is non-trivial if it has some entries other than for \"user::\",\n     \"group::\", and \"other::\".  Normally these three should be present\n     at least, allowing us to write\n        return (3 < acl_entries (acl));\n     but the following code is more robust.  */\n#  if HAVE_ACL_FIRST_ENTRY /* Linux, FreeBSD */\n\n  acl_entry_t ace;\n  int got_one;\n\n  for (got_one = acl_get_entry (acl, ACL_FIRST_ENTRY, &ace);\n       got_one > 0;\n       got_one = acl_get_entry (acl, ACL_NEXT_ENTRY, &ace))\n    {\n      acl_tag_t tag;\n      if (acl_get_tag_type (ace, &tag) < 0)\n        return -1;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n    }\n  return got_one;\n\n#  elif HAVE_ACL_TO_SHORT_TEXT /* IRIX */\n  /* Don't use acl_get_entry: it is undocumented.  */\n\n  int count = acl->acl_cnt;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      acl_entry_t ace = &acl->acl_entry[i];\n      acl_tag_t tag = ace->ae_tag;\n\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ\n            || tag == ACL_OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n\n#  elif HAVE_ACL_FREE_TEXT /* Tru64 */\n  /* Don't use acl_get_entry: it takes only one argument and does not work.  */\n\n  int count = acl->acl_num;\n  acl_entry_t ace;\n\n  for (ace = acl->acl_first; count > 0; ace = ace->next, count--)\n    {\n      acl_tag_t tag;\n      acl_perm_t perm;\n\n      tag = ace->entry->acl_type;\n      if (!(tag == ACL_USER_OBJ || tag == ACL_GROUP_OBJ || tag == ACL_OTHER))\n        return 1;\n\n      perm = ace->entry->acl_perm;\n      /* On Tru64, perm can also contain non-standard bits such as\n         PERM_INSERT, PERM_DELETE, PERM_MODIFY, PERM_LOOKUP, ... */\n      if ((perm & ~(ACL_READ | ACL_WRITE | ACL_EXECUTE)) != 0)\n        return 1;\n    }\n  return 0;\n\n#  else\n\n  errno = ENOSYS;\n  return -1;\n#  endif\n}",
      "lines": 71,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "acl_nontrivial": [
      {
        "start_point": [
          132,
          0
        ],
        "end_point": [
          153,
          1
        ],
        "content": "int\nacl_nontrivial (int count, aclent_t *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      aclent_t *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ\n            || ace->a_type == GROUP_OBJ\n            || ace->a_type == OTHER_OBJ\n            /* Note: Cygwin does not return a CLASS_OBJ (\"mask:\") entry\n               sometimes.  */\n            || ace->a_type == CLASS_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 22,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          345,
          0
        ],
        "end_point": [
          360,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl_entry *entries, struct stat *sb)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl_entry *ace = &entries[i];\n\n      if (!((ace->uid == sb->st_uid && ace->gid == ACL_NSGROUP)\n            || (ace->uid == ACL_NSUSER && ace->gid == sb->st_gid)\n            || (ace->uid == ACL_NSUSER && ace->gid == ACL_NSGROUP)))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 16,
        "depth": 15,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          393,
          0
        ],
        "end_point": [
          413,
          1
        ],
        "content": "int\nacl_nontrivial (struct acl *a)\n{\n  /* The normal way to iterate through an ACL is like this:\n       struct acl_entry *ace;\n       for (ace = a->acl_ext; ace != acl_last (a); ace = acl_nxt (ace))\n         {\n           struct ace_id *aei;\n           switch (ace->ace_type)\n             {\n             case ACC_PERMIT:\n             case ACC_DENY:\n             case ACC_SPECIFY:\n               ...;\n             }\n           for (aei = ace->ace_id; aei != id_last (ace); aei = id_nxt (aei))\n             ...\n         }\n   */\n  return (acl_last (a) != a->acl_ext ? 1 : 0);\n}",
        "lines": 21,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          454,
          0
        ],
        "end_point": [
          473,
          1
        ],
        "content": "int\nacl_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "acl_ace_nontrivial": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "int\nacl_ace_nontrivial (int count, ace_t *entries)\n{\n  int i;\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     In the old convention, usually three ACEs have a_flags = ACE_OWNER /\n     ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.  In the new\n     convention, these values are not used.  */\n  int old_convention = 0;\n\n  for (i = 0; i < count; i++)\n    if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n      {\n        old_convention = 1;\n        break;\n      }\n\n  if (old_convention)\n    /* Running on Solaris 10.  */\n    for (i = 0; i < count; i++)\n      {\n        ace_t *ace = &entries[i];\n\n        /* Note:\n           If ace->a_flags = ACE_OWNER, ace->a_who is the st_uid from stat().\n           If ace->a_flags = ACE_GROUP, ace->a_who is the st_gid from stat().\n           We don't need to check ace->a_who in these cases.  */\n        if (!(ace->a_type == OLD_ALLOW\n              && (ace->a_flags == OLD_ACE_OWNER\n                  || ace->a_flags == OLD_ACE_GROUP\n                  || ace->a_flags == OLD_ACE_OTHER)))\n          return 1;\n      }\n  else\n    {\n      /* Running on Solaris 10 (newer version) or Solaris 11.  */\n      unsigned int access_masks[6] =\n        {\n          0, /* owner@ deny */\n          0, /* owner@ allow */\n          0, /* group@ deny */\n          0, /* group@ allow */\n          0, /* everyone@ deny */\n          0  /* everyone@ allow */\n        };\n\n      for (i = 0; i < count; i++)\n        {\n          ace_t *ace = &entries[i];\n          unsigned int index1;\n          unsigned int index2;\n\n          if (ace->a_type == NEW_ACE_ACCESS_ALLOWED_ACE_TYPE)\n            index1 = 1;\n          else if (ace->a_type == NEW_ACE_ACCESS_DENIED_ACE_TYPE)\n            index1 = 0;\n          else\n            return 1;\n\n          if (ace->a_flags == NEW_ACE_OWNER)\n            index2 = 0;\n          else if (ace->a_flags == (NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP))\n            index2 = 2;\n          else if (ace->a_flags == NEW_ACE_EVERYONE)\n            index2 = 4;\n          else\n            return 1;\n\n          access_masks[index1 + index2] |= ace->a_access_mask;\n        }\n\n      /* The same bit shouldn't be both allowed and denied.  */\n      if (access_masks[0] & access_masks[1])\n        return 1;\n      if (access_masks[2] & access_masks[3])\n        return 1;\n      if (access_masks[4] & access_masks[5])\n        return 1;\n\n      /* Check minimum masks.  */\n      if ((NEW_ACE_WRITE_NAMED_ATTRS\n           | NEW_ACE_WRITE_ATTRIBUTES\n           | NEW_ACE_WRITE_ACL\n           | NEW_ACE_WRITE_OWNER)\n          & ~ access_masks[1])\n        return 1;\n      access_masks[1] &= ~(NEW_ACE_WRITE_NAMED_ATTRS\n                           | NEW_ACE_WRITE_ATTRIBUTES\n                           | NEW_ACE_WRITE_ACL\n                           | NEW_ACE_WRITE_OWNER);\n      if ((NEW_ACE_READ_NAMED_ATTRS\n           | NEW_ACE_READ_ATTRIBUTES\n           | NEW_ACE_READ_ACL\n           | NEW_ACE_SYNCHRONIZE)\n          & ~ access_masks[5])\n        return 1;\n      access_masks[5] &= ~(NEW_ACE_READ_NAMED_ATTRS\n                           | NEW_ACE_READ_ATTRIBUTES\n                           | NEW_ACE_READ_ACL\n                           | NEW_ACE_SYNCHRONIZE);\n\n      /* Check the allowed or denied bits.  */\n      switch ((access_masks[0] | access_masks[1])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[2] | access_masks[3])\n              & ~(NEW_ACE_READ_NAMED_ATTRS\n                  | NEW_ACE_READ_ATTRIBUTES\n                  | NEW_ACE_READ_ACL\n                  | NEW_ACE_SYNCHRONIZE))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n      switch ((access_masks[4] | access_masks[5])\n              & ~(NEW_ACE_WRITE_NAMED_ATTRS\n                  | NEW_ACE_WRITE_ATTRIBUTES\n                  | NEW_ACE_WRITE_ACL\n                  | NEW_ACE_WRITE_OWNER))\n        {\n        case 0:\n        case NEW_ACE_READ_DATA:\n        case                     NEW_ACE_WRITEA_DATA:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA:\n        case                                           NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA |                       NEW_ACE_EXECUTE:\n        case                     NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n        case NEW_ACE_READ_DATA | NEW_ACE_WRITEA_DATA | NEW_ACE_EXECUTE:\n          break;\n        default:\n          return 1;\n        }\n\n      /* Check that the NEW_ACE_WRITE_DATA and NEW_ACE_APPEND_DATA bits are\n         either both allowed or both denied.  */\n      if (((access_masks[0] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[0] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[2] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[2] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n      if (((access_masks[4] & NEW_ACE_WRITE_DATA) != 0)\n          != ((access_masks[4] & NEW_ACE_APPEND_DATA) != 0))\n        return 1;\n    }\n\n  return 0;\n}",
      "lines": 175,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "aclv_nontrivial": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "int\naclv_nontrivial (int count, struct acl *entries)\n{\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      struct acl *ace = &entries[i];\n\n      /* Note: If ace->a_type = USER_OBJ, ace->a_id is the st_uid from stat().\n         If ace->a_type = GROUP_OBJ, ace->a_id is the st_gid from stat().\n         We don't need to check ace->a_id in these cases.  */\n      if (!(ace->a_type == USER_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == GROUP_OBJ /* no need to check ace->a_id here */\n            || ace->a_type == CLASS_OBJ\n            || ace->a_type == OTHER_OBJ))\n        return 1;\n    }\n  return 0;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "acl_nfs4_nontrivial": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "int\nacl_nfs4_nontrivial (nfs4_acl_int_t *a)\n{\n#  if 1 /* let's try this first */\n  return (a->aclEntryN > 0 ? 1 : 0);\n#  else\n  int count = a->aclEntryN;\n  int i;\n\n  for (i = 0; i < count; i++)\n    {\n      nfs4_ace_int_t *ace = &a->aclEntry[i];\n\n      if (!((ace->flags & ACE4_ID_SPECIAL) != 0\n            && (ace->aceWho.special_whoid == ACE4_WHO_OWNER\n                || ace->aceWho.special_whoid == ACE4_WHO_GROUP\n                || ace->aceWho.special_whoid == ACE4_WHO_EVERYONE)\n            && ace->aceType == ACE4_ACCESS_ALLOWED_ACE_TYPE\n            && ace->aceFlags == 0\n            && (ace->aceMask & ~(ACE4_READ_DATA | ACE4_LIST_DIRECTORY\n                                 | ACE4_WRITE_DATA | ACE4_ADD_FILE\n                                 | ACE4_EXECUTE)) == 0))\n        return 1;\n    }\n  return 0;\n#  endif\n}",
      "lines": 27,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "file_has_acl": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "int\nfile_has_acl (char const *name, struct stat const *sb)\n{\n#if USE_ACL\n  if (! S_ISLNK (sb->st_mode))\n    {\n# if HAVE_ACL_GET_FILE\n\n      /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n      /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n      int ret;\n\n      if (HAVE_ACL_EXTENDED_FILE) /* Linux */\n        {\n          /* On Linux, acl_extended_file is an optimized function: It only\n             makes two calls to getxattr(), one for ACL_TYPE_ACCESS, one for\n             ACL_TYPE_DEFAULT.  */\n          ret = acl_extended_file (name);\n        }\n      else /* FreeBSD, Mac OS X, IRIX, Tru64 */\n        {\n#  if HAVE_ACL_TYPE_EXTENDED /* Mac OS X */\n          /* On Mac OS X, acl_get_file (name, ACL_TYPE_ACCESS)\n             and acl_get_file (name, ACL_TYPE_DEFAULT)\n             always return NULL / EINVAL.  There is no point in making\n             these two useless calls.  The real ACL is retrieved through\n             acl_get_file (name, ACL_TYPE_EXTENDED).  */\n          acl_t acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n          if (acl)\n            {\n              ret = acl_extended_nontrivial (acl);\n              acl_free (acl);\n            }\n          else\n            ret = -1;\n#  else /* FreeBSD, IRIX, Tru64 */\n          acl_t acl = acl_get_file (name, ACL_TYPE_ACCESS);\n          if (acl)\n            {\n              int saved_errno;\n\n              ret = acl_access_nontrivial (acl);\n              saved_errno = errno;\n              acl_free (acl);\n              errno = saved_errno;\n#   if HAVE_ACL_FREE_TEXT /* Tru64 */\n              /* On OSF/1, acl_get_file (name, ACL_TYPE_DEFAULT) always\n                 returns NULL with errno not set.  There is no point in\n                 making this call.  */\n#   else /* FreeBSD, IRIX */\n              /* On Linux, FreeBSD, IRIX, acl_get_file (name, ACL_TYPE_ACCESS)\n                 and acl_get_file (name, ACL_TYPE_DEFAULT) on a directory\n                 either both succeed or both fail; it depends on the\n                 file system.  Therefore there is no point in making the second\n                 call if the first one already failed.  */\n              if (ret == 0 && S_ISDIR (sb->st_mode))\n                {\n                  acl = acl_get_file (name, ACL_TYPE_DEFAULT);\n                  if (acl)\n                    {\n                      ret = (0 < acl_entries (acl));\n                      acl_free (acl);\n                    }\n                  else\n                    ret = -1;\n                }\n#   endif\n            }\n          else\n            ret = -1;\n#  endif\n        }\n      if (ret < 0)\n        return - acl_errno_valid (errno);\n      return ret;\n\n# elif HAVE_FACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n#  if defined ACL_NO_TRIVIAL\n\n      /* Solaris 10 (newer version), which has additional API declared in\n         <sys/acl.h> (acl_t) and implemented in libsec (acl_set, acl_trivial,\n         acl_fromtext, ...).  */\n      return acl_trivial (name);\n\n#  else /* Solaris, Cygwin, general case */\n\n      /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n         of Unixware.  The acl() call returns the access and default ACL both\n         at once.  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (aclent_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (aclent_t))\n          };\n        aclent_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        aclent_t *entries = buf;\n        aclent_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced =\n                  (aclent_t *) malloc (alloc * sizeof (aclent_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* Don't use MIN_ACL_ENTRIES:  It's set to 4 on Cygwin, but Cygwin\n               returns only 3 entries for files with no ACL.  But this is safe:\n               If there are more than 4 entries, there cannot be only the\n               \"user::\", \"group::\", \"other:\", and \"mask:\" entries.  */\n            if (count > 4)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n\n#   ifdef ACE_GETACL\n      /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n         file systems (whereas the other ones are used in UFS file systems).  */\n      {\n        /* Initially, try to read the entries into a stack-allocated buffer.\n           Use malloc if it does not fit.  */\n        enum\n          {\n            alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n            alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n          };\n        ace_t buf[alloc_init];\n        size_t alloc = alloc_init;\n        ace_t *entries = buf;\n        ace_t *malloced = NULL;\n        int count;\n\n        for (;;)\n          {\n            count = acl (name, ACE_GETACL, alloc, entries);\n            if (count < 0 && errno == ENOSPC)\n              {\n                /* Increase the size of the buffer.  */\n                free (malloced);\n                if (alloc > alloc_max / 2)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                alloc = 2 * alloc; /* <= alloc_max */\n                entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n                if (entries == NULL)\n                  {\n                    errno = ENOMEM;\n                    return -1;\n                  }\n                continue;\n              }\n            break;\n          }\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == EINVAL)\n              ;\n            else\n              {\n                int saved_errno = errno;\n                free (malloced);\n                errno = saved_errno;\n                return -1;\n              }\n          }\n        else if (count == 0)\n          ;\n        else\n          {\n            /* In the old (original Solaris 10) convention:\n               If there are more than 3 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_OTHER entries.\n               In the newer Solaris 10 and Solaris 11 convention:\n               If there are more than 6 entries, there cannot be only the\n               ACE_OWNER, ACE_GROUP, ACE_EVERYONE entries, each once with\n               NEW_ACE_ACCESS_ALLOWED_ACE_TYPE and once with\n               NEW_ACE_ACCESS_DENIED_ACE_TYPE.  */\n            if (count > 6)\n              {\n                free (malloced);\n                return 1;\n              }\n\n            if (acl_ace_nontrivial (count, entries))\n              {\n                free (malloced);\n                return 1;\n              }\n          }\n        free (malloced);\n      }\n#   endif\n\n      return 0;\n#  endif\n\n# elif HAVE_GETACL /* HP-UX */\n\n      {\n        struct acl_entry entries[NACLENTRIES];\n        int count;\n\n        count = getacl (name, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* ENOSYS is seen on newer HP-UX versions.\n               EOPNOTSUPP is typically seen on NFS mounts.\n               ENOTSUP was seen on Quantum StorNext file systems (cvfs).  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 3 entries, there cannot be only the\n               (uid,%), (%,gid), (%,%) entries.  */\n            if (count > 3)\n              return 1;\n\n            {\n              struct stat statbuf;\n\n              if (stat (name, &statbuf) < 0)\n                return -1;\n\n              return acl_nontrivial (count, entries, &statbuf);\n            }\n          }\n      }\n\n#  if HAVE_ACLV_H /* HP-UX >= 11.11 */\n\n      {\n        struct acl entries[NACLVENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLVENTRIES, entries);\n\n        if (count < 0)\n          {\n            /* EOPNOTSUPP is seen on NFS in HP-UX 11.11, 11.23.\n               EINVAL is seen on NFS in HP-UX 11.31.  */\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLVENTRIES)\n              /* If NACLVENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return aclv_nontrivial (count, entries);\n          }\n      }\n\n#  endif\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP /* AIX */\n\n      acl_type_t type;\n      char aclbuf[1024];\n      void *acl = aclbuf;\n      size_t aclsize = sizeof (aclbuf);\n      mode_t mode;\n\n      for (;;)\n        {\n          /* The docs say that type being 0 is equivalent to ACL_ANY, but it\n             is not true, in AIX 5.3.  */\n          type.u64 = ACL_ANY;\n          if (aclx_get (name, 0, &type, aclbuf, &aclsize, &mode) >= 0)\n            break;\n          if (errno == ENOSYS)\n            return 0;\n          if (errno != ENOSPC)\n            {\n              if (acl != aclbuf)\n                {\n                  int saved_errno = errno;\n                  free (acl);\n                  errno = saved_errno;\n                }\n              return -1;\n            }\n          aclsize = 2 * aclsize;\n          if (acl != aclbuf)\n            free (acl);\n          acl = malloc (aclsize);\n          if (acl == NULL)\n            {\n              errno = ENOMEM;\n              return -1;\n            }\n        }\n\n      if (type.u64 == ACL_AIXC)\n        {\n          int result = acl_nontrivial ((struct acl *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else if (type.u64 == ACL_NFS4)\n        {\n          int result = acl_nfs4_nontrivial ((nfs4_acl_int_t *) acl);\n          if (acl != aclbuf)\n            free (acl);\n          return result;\n        }\n      else\n        {\n          /* A newer type of ACL has been introduced in the system.\n             We should better support it.  */\n          if (acl != aclbuf)\n            free (acl);\n          errno = EINVAL;\n          return -1;\n        }\n\n# elif HAVE_STATACL /* older AIX */\n\n      union { struct acl a; char room[4096]; } u;\n\n      if (statacl (name, STX_NORMAL, &u.a, sizeof (u)) < 0)\n        return -1;\n\n      return acl_nontrivial (&u.a);\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n      {\n        struct acl entries[NACLENTRIES];\n        int count;\n\n        count = acl ((char *) name, ACL_GET, NACLENTRIES, entries);\n\n        if (count < 0)\n          {\n            if (errno == ENOSYS || errno == ENOTSUP)\n              ;\n            else\n              return -1;\n          }\n        else if (count == 0)\n          return 0;\n        else /* count > 0 */\n          {\n            if (count > NACLENTRIES)\n              /* If NACLENTRIES cannot be trusted, use dynamic memory\n                 allocation.  */\n              abort ();\n\n            /* If there are more than 4 entries, there cannot be only the\n               four base ACL entries.  */\n            if (count > 4)\n              return 1;\n\n            return acl_nontrivial (count, entries);\n          }\n      }\n\n# endif\n    }\n#endif\n\n  return 0;\n}",
      "lines": 436,
      "depth": 25,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/float+.h": {},
  "recutils/recutils-1.7/lib/float.c": {},
  "recutils/recutils-1.7/lib/float.in.h": {},
  "recutils/recutils-1.7/lib/flock.c": {
    "file_size": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static BOOL\nfile_size (HANDLE h, DWORD * lower, DWORD * upper)\n{\n  *lower = GetFileSize (h, upper);\n  return 1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "do_lock": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static BOOL\ndo_lock (HANDLE h, int non_blocking, int exclusive)\n{\n  BOOL res;\n  DWORD size_lower, size_upper;\n  OVERLAPPED ovlp;\n  int flags = 0;\n\n  /* We're going to lock the whole file, so get the file size. */\n  res = file_size (h, &size_lower, &size_upper);\n  if (!res)\n    return 0;\n\n  /* Start offset is 0, and also zero the remaining members of this struct. */\n  memset (&ovlp, 0, sizeof ovlp);\n\n  if (non_blocking)\n    flags |= LOCKFILE_FAIL_IMMEDIATELY;\n  if (exclusive)\n    flags |= LOCKFILE_EXCLUSIVE_LOCK;\n\n  return LockFileEx (h, flags, 0, size_lower, size_upper, &ovlp);\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "do_unlock": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static BOOL\ndo_unlock (HANDLE h)\n{\n  int res;\n  DWORD size_lower, size_upper;\n\n  res = file_size (h, &size_lower, &size_upper);\n  if (!res)\n    return 0;\n\n  return UnlockFile (h, 0, 0, size_lower, size_upper);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "BOOL"
      ]
    },
    "flock": [
      {
        "start_point": [
          93,
          0
        ],
        "end_point": [
          158,
          1
        ],
        "content": "int\nflock (int fd, int operation)\n{\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  DWORD res;\n  int non_blocking;\n\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n\n  non_blocking = operation & LOCK_NB;\n  operation &= ~LOCK_NB;\n\n  switch (operation)\n    {\n    case LOCK_SH:\n      res = do_lock (h, non_blocking, 0);\n      break;\n    case LOCK_EX:\n      res = do_lock (h, non_blocking, 1);\n      break;\n    case LOCK_UN:\n      res = do_unlock (h);\n      break;\n    default:\n      errno = EINVAL;\n      return -1;\n    }\n\n  /* Map Windows errors into Unix errnos.  As usual MSDN fails to\n   * document the permissible error codes.\n   */\n  if (!res)\n    {\n      DWORD err = GetLastError ();\n      switch (err)\n        {\n          /* This means someone else is holding a lock. */\n        case ERROR_LOCK_VIOLATION:\n          errno = EAGAIN;\n          break;\n\n          /* Out of memory. */\n        case ERROR_NOT_ENOUGH_MEMORY:\n          errno = ENOMEM;\n          break;\n\n        case ERROR_BAD_COMMAND:\n          errno = EINVAL;\n          break;\n\n          /* Unlikely to be other errors, but at least don't lose the\n           * error code.\n           */\n        default:\n          errno = err;\n        }\n\n      return -1;\n    }\n\n  return 0;\n}",
        "lines": 66,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          211,
          1
        ],
        "content": "int\nflock (int fd, int operation)\n{\n  int cmd, r;\n  struct flock fl;\n\n  if (operation & LOCK_NB)\n    cmd = F_SETLK;\n  else\n    cmd = F_SETLKW;\n  operation &= ~LOCK_NB;\n\n  memset (&fl, 0, sizeof fl);\n  fl.l_whence = SEEK_SET;\n  /* l_start & l_len are 0, which as a special case means \"whole file\". */\n\n  switch (operation)\n    {\n    case LOCK_SH:\n      fl.l_type = F_RDLCK;\n      break;\n    case LOCK_EX:\n      fl.l_type = F_WRLCK;\n      break;\n    case LOCK_UN:\n      fl.l_type = F_UNLCK;\n      break;\n    default:\n      errno = EINVAL;\n      return -1;\n    }\n\n  r = fcntl (fd, cmd, &fl);\n  if (r == -1 && errno == EACCES)\n    errno = EAGAIN;\n\n  return r;\n}",
        "lines": 38,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/floor.c": {
    "FUNC": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x)\n{\n  /* The use of 'volatile' guarantees that excess precision bits are dropped\n     at each addition step and before the following comparison at the caller's\n     site.  It is necessary on x86 systems where double-floats are not IEEE\n     compliant by default, to avoid that the results become platform and compiler\n     option dependent.  'volatile' is a portable alternative to gcc's\n     -ffloat-store option.  */\n  volatile DOUBLE y = x;\n  volatile DOUBLE z = y;\n\n  if (z > L_(0.0))\n    {\n      /* For 0 < x < 1, return +0.0 even if the current rounding mode is\n         FE_DOWNWARD.  */\n      if (z < L_(1.0))\n        z = L_(0.0);\n      /* Avoid rounding errors for values near 2^k, where k >= MANT_DIG-1.  */\n      else if (z < TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z += TWO_MANT_DIG;\n          z -= TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  else if (z < L_(0.0))\n    {\n      /* Avoid rounding errors for values near -2^k, where k >= MANT_DIG-1.  */\n      if (z > - TWO_MANT_DIG)\n        {\n          /* Round to the next integer (nearest or up or down, doesn't matter).  */\n          z -= TWO_MANT_DIG;\n          z += TWO_MANT_DIG;\n          /* Enforce rounding down.  */\n          if (z > y)\n            z -= L_(1.0);\n        }\n    }\n  return z;\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fpending.c": {
    "__fpending": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "size_t\n__fpending (FILE *fp)\n{\n  return PENDING_OUTPUT_N_BYTES;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fpending.h": {},
  "recutils/recutils-1.7/lib/fprintf.c": {
    "fprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nfprintf (FILE *fp, const char *format, ...)\n{\n  char buf[2000];\n  char *output;\n  size_t len;\n  size_t lenbuf = sizeof (buf);\n  va_list args;\n\n  va_start (args, format);\n  output = vasnprintf (buf, &lenbuf, format, args);\n  len = lenbuf;\n  va_end (args);\n\n  if (!output)\n    {\n      fseterr (fp);\n      return -1;\n    }\n\n  if (fwrite (output, 1, len, fp) < len)\n    {\n      if (output != buf)\n        {\n          int saved_errno = errno;\n          free (output);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  if (output != buf)\n    free (output);\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      fseterr (fp);\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fpucw.h": {},
  "recutils/recutils-1.7/lib/frexp.c": {
    "FUNC": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int sign;\n  int exponent;\n  DECL_ROUNDING\n\n  /* Test for NaN, infinity, and zero.  */\n  if (ISNAN (x) || x + x == x)\n    {\n      *expptr = 0;\n      return x;\n    }\n\n  sign = 0;\n  if (x < 0)\n    {\n      x = - x;\n      sign = -1;\n    }\n\n  BEGIN_ROUNDING ();\n\n  {\n    /* Since the exponent is an 'int', it fits in 64 bits.  Therefore the\n       loops are executed no more than 64 times.  */\n    DOUBLE pow2[64]; /* pow2[i] = 2^2^i */\n    DOUBLE powh[64]; /* powh[i] = 2^-2^i */\n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n        /* A positive exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x >= 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x >= pow2_i)\n              {\n                exponent += (1 << i);\n                x *= powh_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Avoid making x too small, as it could become a denormalized\n           number and thus lose precision.  */\n        while (i > 0 && x < pow2[i - 1])\n          {\n            i--;\n            powh_i = powh[i];\n          }\n        exponent += (1 << i);\n        x *= powh_i;\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n    else\n      {\n        /* A negative or zero exponent.  */\n        DOUBLE pow2_i; /* = pow2[i] */\n        DOUBLE powh_i; /* = powh[i] */\n\n        /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n           x * 2^exponent = argument, x < 1.0.  */\n        for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n             ;\n             i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n          {\n            if (x < powh_i)\n              {\n                exponent -= (1 << i);\n                x *= pow2_i;\n              }\n            else\n              break;\n\n            pow2[i] = pow2_i;\n            powh[i] = powh_i;\n          }\n        /* Here 2^-2^i <= x < 1.0.  */\n      }\n\n    /* Invariants: x * 2^exponent = argument, and 2^-2^i <= x < 1.0.  */\n    while (i > 0)\n      {\n        i--;\n        if (x < powh[i])\n          {\n            exponent -= (1 << i);\n            x *= pow2[i];\n          }\n      }\n    /* Here 0.5 <= x < 1.0.  */\n  }\n\n  if (sign < 0)\n    x = - x;\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "recutils/recutils-1.7/lib/frexpl.c": {
    "frexpl": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "long double\nfrexpl (long double x, int *expptr)\n{\n  return frexp (x, expptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fseek.c": {
    "fseek": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "int\nfseek (FILE *fp, long offset, int whence)\n{\n  /* Use the replacement fseeko function with all its workarounds.  */\n  return fseeko (fp, (off_t)offset, whence);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fseeko.c": {},
  "recutils/recutils-1.7/lib/fseterr.c": {
    "fseterr": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\nfseterr (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  fp->_flags |= _IO_ERR_SEEN;\n#elif defined __sferror || defined __DragonFly__ /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin */\n  fp_->_flags |= __SERR;\n#elif defined __EMX__               /* emx+gcc */\n  fp->_flags |= _IOERR;\n#elif defined __minix               /* Minix */\n  fp->_flags |= _IOERR;\n#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  fp_->_flag |= _IOERR;\n#elif defined __UCLIBC__            /* uClibc */\n  fp->__modeflags |= __FLAG_ERROR;\n#elif defined __QNX__               /* QNX */\n  fp->_Mode |= 0x200 /* _MERR */;\n#elif defined __MINT__              /* Atari FreeMiNT */\n  fp->__error = 1;\n#elif defined EPLAN9                /* Plan9 */\n  if (fp->state != 0 /* CLOSED */)\n    fp->state = 5 /* ERR */;\n#elif 0                             /* unknown  */\n  /* Portable fallback, based on an idea by Rich Felker.\n     Wow! 6 system calls for something that is just a bit operation!\n     Not activated on any system, because there is no way to repair FP when\n     the sequence of system calls fails, and library code should not call\n     abort().  */\n  int saved_errno;\n  int fd;\n  int fd2;\n\n  saved_errno = errno;\n  fflush (fp);\n  fd = fileno (fp);\n  fd2 = dup (fd);\n  if (fd2 >= 0)\n    {\n      close (fd);\n      fputc ('\\0', fp); /* This should set the error indicator.  */\n      fflush (fp);      /* Or this.  */\n      if (dup2 (fd2, fd) < 0)\n        /* Whee... we botched the stream and now cannot restore it!  */\n        abort ();\n      close (fd2);\n    }\n  errno = saved_errno;\n#else\n #error \"Please port gnulib fseterr.c to your platform! Look at the definitions of ferror and clearerr on your system, then report this to bug-gnulib.\"\n#endif\n}",
      "lines": 54,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fseterr.h": {},
  "recutils/recutils-1.7/lib/fstat.c": {
    "orig_fstat": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\norig_fstat (int fd, struct stat *buf)\n{\n  return fstat (fd, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fstat_nothrow": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        5
      ],
      "content": "static int\nfstat_nothrow (int fd, struct stat *buf)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = orig_fstat (fd, buf);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_fstat": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\nrpl_fstat (int fd, struct stat *buf)\n{\n#if REPLACE_FCHDIR && REPLACE_OPEN_DIRECTORY\n  /* Handle the case when rpl_open() used a dummy file descriptor to work\n     around an open() that can't normally visit directories.  */\n  const char *name = _gl_directory_name (fd);\n  if (name != NULL)\n    return stat (name, buf);\n#endif\n\n  return fstat_nothrow (fd, buf);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/ftell.c": {
    "ftell": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "long\nftell (FILE *fp)\n{\n  /* Use the replacement ftello function with all its workarounds.  */\n  off_t offset = ftello (fp);\n  if (LONG_MIN <= offset && offset <= LONG_MAX)\n    return /* (long) */ offset;\n  else\n    {\n      errno = EOVERFLOW;\n      return -1;\n    }\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "long",
        "long"
      ]
    }
  },
  "recutils/recutils-1.7/lib/ftello.c": {},
  "recutils/recutils-1.7/lib/fwriting.c": {
    "fwriting": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "bool\nfwriting (FILE *fp)\n{\n  /* Most systems provide FILE as a struct and the necessary bitmask in\n     <stdio.h>, because they need it for implementing getc() and putc() as\n     fast macros.  */\n#if defined _IO_ftrylockfile || __GNU_LIBRARY__ == 1 /* GNU libc, BeOS, Haiku, Linux libc5 */\n  return (fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING)) != 0;\n#elif defined __sferror || defined __DragonFly__ /* FreeBSD, NetBSD, OpenBSD, DragonFly, Mac OS X, Cygwin */\n  return (fp_->_flags & __SWR) != 0;\n#elif defined __EMX__               /* emx+gcc */\n  return (fp->_flags & _IOWRT) != 0;\n#elif defined __minix               /* Minix */\n  return (fp->_flags & _IOWRITING) != 0;\n#elif defined _IOERR                /* AIX, HP-UX, IRIX, OSF/1, Solaris, OpenServer, mingw, NonStop Kernel */\n  return (fp->_flag & _IOWRT) != 0;\n#elif defined __UCLIBC__            /* uClibc */\n  return (fp->__modeflags & __FLAG_WRITING) != 0;\n#elif defined __QNX__               /* QNX */\n  return ((fp->_Mode & 0x1 /* _MOPENR */) == 0\n          || (fp->_Mode & 0x2000 /* _MWRITE */) != 0);\n#elif defined __MINT__              /* Atari FreeMiNT */\n  if (!fp->__mode.__read)\n    return 1;\n  if (!fp->__mode.__write)\n    return 0;\n# ifdef _IO_CURRENTLY_PUTTING /* Flag added on 2009-02-28 */\n  return (fp->__flags & _IO_CURRENTLY_PUTTING) != 0;\n# else\n  return (fp->__buffer < fp->__put_limit /*|| fp->__bufp == fp->__get_limit ??*/);\n# endif\n#elif defined EPLAN9                /* Plan9 */\n  if (fp->state == 0 /* CLOSED */ || fp->state == 3 /* RD */)\n    return 0;\n  return (fp->state == 4 /* WR */ && (fp->bufl == 0 || fp->wp < fp->rp));\n#else\n# error \"Please port gnulib fwriting.c to your platform!\"\n#endif\n}",
      "lines": 39,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/fwriting.h": {},
  "recutils/recutils-1.7/lib/getdelim.c": {
    "getdelim": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "ssize_t\ngetdelim (char **lineptr, size_t *n, int delimiter, FILE *fp)\n{\n  ssize_t result;\n  size_t cur_len = 0;\n\n  if (lineptr == NULL || n == NULL || fp == NULL)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  flockfile (fp);\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      char *new_lineptr;\n      *n = 120;\n      new_lineptr = (char *) realloc (*lineptr, *n);\n      if (new_lineptr == NULL)\n        {\n          result = -1;\n          goto unlock_return;\n        }\n      *lineptr = new_lineptr;\n    }\n\n  for (;;)\n    {\n      int i;\n\n      i = getc_maybe_unlocked (fp);\n      if (i == EOF)\n        {\n          result = -1;\n          break;\n        }\n\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      if (cur_len + 1 >= *n)\n        {\n          size_t needed_max =\n            SSIZE_MAX < SIZE_MAX ? (size_t) SSIZE_MAX + 1 : SIZE_MAX;\n          size_t needed = 2 * *n + 1;   /* Be generous. */\n          char *new_lineptr;\n\n          if (needed_max < needed)\n            needed = needed_max;\n          if (cur_len + 1 >= needed)\n            {\n              result = -1;\n              errno = EOVERFLOW;\n              goto unlock_return;\n            }\n\n          new_lineptr = (char *) realloc (*lineptr, needed);\n          if (new_lineptr == NULL)\n            {\n              result = -1;\n              goto unlock_return;\n            }\n\n          *lineptr = new_lineptr;\n          *n = needed;\n        }\n\n      (*lineptr)[cur_len] = i;\n      cur_len++;\n\n      if (i == delimiter)\n        break;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len ? cur_len : result;\n\n unlock_return:\n  funlockfile (fp); /* doesn't set errno */\n\n  return result;\n}",
      "lines": 80,
      "depth": 13,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getdtablesize.c": {
    "_setmaxstdio_nothrow": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        5
      ],
      "content": "static int\n_setmaxstdio_nothrow (int newmax)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _setmaxstdio (newmax);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "getdtablesize": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\ngetdtablesize (void)\n{\n  if (dtablesize == 0)\n    {\n      /* We are looking for the number N such that the valid file descriptors\n         are 0..N-1.  It can be obtained through a loop as follows:\n           {\n             int fd;\n             for (fd = 3; fd < 65536; fd++)\n               if (dup2 (0, fd) == -1)\n                 break;\n             return fd;\n           }\n         On Windows XP, the result is 2048.\n         The drawback of this loop is that it allocates memory for a libc\n         internal array that is never freed.\n\n         The number N can also be obtained as the upper bound for\n         _getmaxstdio ().  _getmaxstdio () returns the maximum number of open\n         FILE objects.  The sanity check in _setmaxstdio reveals the maximum\n         number of file descriptors.  This too allocates memory, but it is\n         freed when we call _setmaxstdio with the original value.  */\n      int orig_max_stdio = _getmaxstdio ();\n      unsigned int bound;\n      for (bound = 0x10000; _setmaxstdio (bound) < 0; bound = bound / 2)\n        ;\n      _setmaxstdio (orig_max_stdio);\n      dtablesize = bound;\n    }\n  return dtablesize;\n}",
      "lines": 32,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "rpl_getdtablesize": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\nrpl_getdtablesize(void)\n{\n  /* To date, this replacement is only compiled for Cygwin 1.7.25,\n     which auto-increased the RLIMIT_NOFILE soft limit until it\n     hits the compile-time constant hard limit of 3200.  Although\n     that version of cygwin supported a child process inheriting\n     a smaller soft limit, the smaller limit is not enforced, so\n     we might as well just report the hard limit.  */\n  struct rlimit lim;\n  if (!getrlimit (RLIMIT_NOFILE, &lim) && lim.rlim_max != RLIM_INFINITY)\n    return lim.rlim_max;\n  return getdtablesize ();\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getfilecon.c": {
    "map_to_failure": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nmap_to_failure (int ret, security_context_t *con)\n{\n  if (ret == 0)\n    {\n      errno = ENOTSUP;\n      return -1;\n    }\n\n  if (ret == 10 && strcmp (*con, \"unlabeled\") == 0)\n    {\n      freecon (*con);\n      errno = ENODATA;\n      return -1;\n    }\n\n  return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_getfilecon": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nrpl_getfilecon (char const *file, security_context_t *con)\n{\n  int ret = getfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_lgetfilecon": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_lgetfilecon (char const *file, security_context_t *con)\n{\n  int ret = lgetfilecon (file, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_fgetfilecon": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nrpl_fgetfilecon (int fd, security_context_t *con)\n{\n  int ret = fgetfilecon (fd, con);\n  return map_to_failure (ret, con);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getgroups.c": {
    "getgroups": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "int\ngetgroups (int n _GL_UNUSED, GETGROUPS_T *groups _GL_UNUSED)\n{\n  errno = ENOSYS;\n  return -1;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "rpl_getgroups": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "int\nrpl_getgroups (int n, gid_t *group)\n{\n  int n_groups;\n  GETGROUPS_T *gbuf;\n  int saved_errno;\n\n  if (n < 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (n != 0 || !GETGROUPS_ZERO_BUG)\n    {\n      int result;\n      if (sizeof *group == sizeof *gbuf)\n        return getgroups (n, (GETGROUPS_T *) group);\n\n      if (SIZE_MAX / sizeof *gbuf <= n)\n        {\n          errno = ENOMEM;\n          return -1;\n        }\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      result = getgroups (n, gbuf);\n      if (0 <= result)\n        {\n          n = result;\n          while (n--)\n            group[n] = gbuf[n];\n        }\n      saved_errno = errno;\n      free (gbuf);\n      errno = saved_errno;\n      return result;\n    }\n\n  n = 20;\n  while (1)\n    {\n      /* No need to worry about address arithmetic overflow here,\n         since the ancient systems that we're running on have low\n         limits on the number of secondary groups.  */\n      gbuf = malloc (n * sizeof *gbuf);\n      if (!gbuf)\n        return -1;\n      n_groups = getgroups (n, gbuf);\n      if (n_groups == -1 ? errno != EINVAL : n_groups < n)\n        break;\n      free (gbuf);\n      n *= 2;\n    }\n\n  saved_errno = errno;\n  free (gbuf);\n  errno = saved_errno;\n\n  return n_groups;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getline.c": {
    "getline": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "ssize_t\ngetline (char **lineptr, size_t *n, FILE *stream)\n{\n  return getdelim (lineptr, n, '\\n', stream);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getopt.c": {
    "exchange": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the '__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n         presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n        d->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n        {\n          memset (__mempcpy (new_str, __getopt_nonoption_flags,\n                             d->__nonoption_flags_max_len),\n                  '\\0', top + 1 - d->__nonoption_flags_max_len);\n          d->__nonoption_flags_max_len = top + 1;\n          __getopt_nonoption_flags = new_str;\n        }\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n        {\n          /* Bottom segment is the short one.  */\n          int len = middle - bottom;\n          register int i;\n\n          /* Swap it with the top part of the top segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[top - (middle - bottom) + i];\n              argv[top - (middle - bottom) + i] = tem;\n              SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n            }\n          /* Exclude the moved bottom segment from further swapping.  */\n          top -= len;\n        }\n      else\n        {\n          /* Top segment is the short one.  */\n          int len = top - middle;\n          register int i;\n\n          /* Swap it with the bottom part of the bottom segment.  */\n          for (i = 0; i < len; i++)\n            {\n              tem = argv[bottom + i];\n              argv[bottom + i] = argv[middle + i];\n              argv[middle + i] = tem;\n              SWAP_FLAGS (bottom + i, middle + i);\n            }\n          /* Exclude the moved top segment from further swapping.  */\n          bottom += len;\n        }\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct || !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n        {\n          if (__getopt_nonoption_flags == NULL\n              || __getopt_nonoption_flags[0] == '\\0')\n            d->__nonoption_flags_max_len = -1;\n          else\n            {\n              const char *orig_str = __getopt_nonoption_flags;\n              int len = d->__nonoption_flags_max_len = strlen (orig_str);\n              if (d->__nonoption_flags_max_len < argc)\n                d->__nonoption_flags_max_len = argc;\n              __getopt_nonoption_flags =\n                (char *) malloc (d->__nonoption_flags_max_len);\n              if (__getopt_nonoption_flags == NULL)\n                d->__nonoption_flags_max_len = -1;\n              else\n                memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n                        '\\0', d->__nonoption_flags_max_len - len);\n            }\n        }\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 64,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc _GL_UNUSED,\n                    char **argv _GL_UNUSED, const char *optstring,\n                    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        1124,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char **argv, const char *optstring,\n                    const struct option *longopts, int *longind,\n                    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n        d->optind = 1;  /* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n                                      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n                      || (d->optind < d->__nonoption_flags_len                \\\n                          && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n         moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n        d->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n        d->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n        {\n          /* If we have just processed some options following some non-options,\n             exchange them so that the options come first.  */\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__last_nonopt != d->optind)\n            d->__first_nonopt = d->optind;\n\n          /* Skip any additional non-options\n             and extend the range of non-options previously skipped.  */\n\n          while (d->optind < argc && NONOPTION_P)\n            d->optind++;\n          d->__last_nonopt = d->optind;\n        }\n\n      /* The special ARGV-element '--' means premature end of options.\n         Skip it like a null option,\n         then exchange with previous non-options as if it were an option,\n         then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n        {\n          d->optind++;\n\n          if (d->__first_nonopt != d->__last_nonopt\n              && d->__last_nonopt != d->optind)\n            exchange ((char **) argv, d);\n          else if (d->__first_nonopt == d->__last_nonopt)\n            d->__first_nonopt = d->optind;\n          d->__last_nonopt = argc;\n\n          d->optind = argc;\n        }\n\n      /* If we have done all the ARGV-elements, stop the scan\n         and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n        {\n          /* Set the next-arg-index to point at the non-options\n             that we previously skipped, so the caller will digest them.  */\n          if (d->__first_nonopt != d->__last_nonopt)\n            d->optind = d->__first_nonopt;\n          return -1;\n        }\n\n      /* If we have come to a non-option and did not permute it,\n         either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n        {\n          if (d->__ordering == REQUIRE_ORDER)\n            return -1;\n          d->optarg = argv[d->optind++];\n          return 1;\n        }\n\n      /* We have found another option-ARGV-element.\n         Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n                  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n          || (long_only && (argv[d->optind][2]\n                            || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n        const struct option *p;\n        struct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n        /* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n         or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n        if (!strncmp (p->name, d->__nextchar, namelen))\n          {\n            if (namelen == (unsigned int) strlen (p->name))\n              {\n                /* Exact match found.  */\n                pfound = p;\n                indfound = option_index;\n                exact = 1;\n                break;\n              }\n            else if (pfound == NULL)\n              {\n                /* First nonexact match found.  */\n                pfound = p;\n                indfound = option_index;\n              }\n            else if (long_only\n                     || pfound->has_arg != p->has_arg\n                     || pfound->flag != p->flag\n                     || pfound->val != p->val)\n              {\n                /* Second or later nonexact match found.  */\n                struct option_list *newp = malloc (sizeof (*newp));\n                newp->p = p;\n                newp->next = ambig_list;\n                ambig_list = newp;\n              }\n          }\n\n      if (ambig_list != NULL && !exact)\n        {\n          if (print_errors)\n            {\n              struct option_list first;\n              first.p = pfound;\n              first.next = ambig_list;\n              ambig_list = &first;\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf = NULL;\n              size_t buflen = 0;\n\n              FILE *fp = open_memstream (&buf, &buflen);\n              if (fp != NULL)\n                {\n                  fprintf (fp,\n                           _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                           argv[0], argv[d->optind]);\n\n                  do\n                    {\n                      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n                      ambig_list = ambig_list->next;\n                    }\n                  while (ambig_list != NULL);\n\n                  fputc_unlocked ('\\n', fp);\n\n                  if (__builtin_expect (fclose (fp) != EOF, 1))\n                    {\n                      _IO_flockfile (stderr);\n\n                      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                      __fxprintf (NULL, \"%s\", buf);\n\n                      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                      _IO_funlockfile (stderr);\n\n                      free (buf);\n                    }\n                }\n#else\n              fprintf (stderr,\n                       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n                       argv[0], argv[d->optind]);\n              do\n                {\n                  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n                  ambig_list = ambig_list->next;\n                }\n              while (ambig_list != NULL);\n\n              fputc ('\\n', stderr);\n#endif\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n\n      while (ambig_list != NULL)\n        {\n          struct option_list *pn = ambig_list->next;\n          free (ambig_list);\n          ambig_list = pn;\n        }\n\n      if (pfound != NULL)\n        {\n          option_index = indfound;\n          d->optind++;\n          if (*nameend)\n            {\n              /* Don't test has_arg with >, because some C compilers don't\n                 allow it to be used on enums.  */\n              if (pfound->has_arg)\n                d->optarg = nameend + 1;\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n                      int n;\n#endif\n\n                      if (argv[d->optind - 1][1] == '-')\n                        {\n                          /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                          argv[0], pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n                                   argv[0], pfound->name);\n#endif\n                        }\n                      else\n                        {\n                          /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                          n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                          argv[0], argv[d->optind - 1][0],\n                                          pfound->name);\n#else\n                          fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n                                   argv[0], argv[d->optind - 1][0],\n                                   pfound->name);\n#endif\n                        }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n                      if (n >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#endif\n                    }\n\n                  d->__nextchar += strlen (d->__nextchar);\n\n                  d->optopt = pfound->val;\n                  return '?';\n                }\n            }\n          else if (pfound->has_arg == 1)\n            {\n              if (d->optind < argc)\n                d->optarg = argv[d->optind++];\n              else\n                {\n                  if (print_errors)\n                    {\n#if defined _LIBC && defined USE_IN_LIBIO\n                      char *buf;\n\n                      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n                                      argv[0], pfound->name) >= 0)\n                        {\n                          _IO_flockfile (stderr);\n\n                          int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                          ((_IO_FILE *) stderr)->_flags2\n                            |= _IO_FLAGS2_NOTCANCEL;\n\n                          __fxprintf (NULL, \"%s\", buf);\n\n                          ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                          _IO_funlockfile (stderr);\n\n                          free (buf);\n                        }\n#else\n                      fprintf (stderr,\n                               _(\"%s: option '--%s' requires an argument\\n\"),\n                               argv[0], pfound->name);\n#endif\n                    }\n                  d->__nextchar += strlen (d->__nextchar);\n                  d->optopt = pfound->val;\n                  return optstring[0] == ':' ? ':' : '?';\n                }\n            }\n          d->__nextchar += strlen (d->__nextchar);\n          if (longind != NULL)\n            *longind = option_index;\n          if (pfound->flag)\n            {\n              *(pfound->flag) = pfound->val;\n              return 0;\n            }\n          return pfound->val;\n        }\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n         or the option starts with '--' or is not a valid short\n         option, then it's an error.\n         Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n          || strchr (optstring, *d->__nextchar) == NULL)\n        {\n          if (print_errors)\n            {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n              if (argv[d->optind][1] == '-')\n                {\n                  /* --option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n                                  argv[0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n                           argv[0], d->__nextchar);\n#endif\n                }\n              else\n                {\n                  /* +option or -option */\n#if defined _LIBC && defined USE_IN_LIBIO\n                  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n                                  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n                  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n                           argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n                }\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              if (n >= 0)\n                {\n                  _IO_flockfile (stderr);\n\n                  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                  __fxprintf (NULL, \"%s\", buf);\n\n                  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                  _IO_funlockfile (stderr);\n\n                  free (buf);\n                }\n#endif\n            }\n          d->__nextchar = (char *) \"\";\n          d->optind++;\n          d->optopt = 0;\n          return '?';\n        }\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    const char *temp = strchr (optstring, c);\n\n    /* Increment 'optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n        if (print_errors)\n          {\n#if defined _LIBC && defined USE_IN_LIBIO\n              char *buf;\n              int n;\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n              n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n                              argv[0], c);\n#else\n              fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC && defined USE_IN_LIBIO\n            if (n >= 0)\n              {\n                _IO_flockfile (stderr);\n\n                int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                __fxprintf (NULL, \"%s\", buf);\n\n                ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                _IO_funlockfile (stderr);\n\n                free (buf);\n              }\n#endif\n          }\n        d->optopt = c;\n        return '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n        char *nameend;\n        const struct option *p;\n        const struct option *pfound = NULL;\n        int exact = 0;\n        int ambig = 0;\n        int indfound = 0;\n        int option_index;\n\n        if (longopts == NULL)\n          goto no_longs;\n\n        /* This is an option that requires an argument.  */\n        if (*d->__nextchar != '\\0')\n          {\n            d->optarg = d->__nextchar;\n            /* If we end this ARGV-element by taking the rest as an arg,\n               we must advance to the next element now.  */\n            d->optind++;\n          }\n        else if (d->optind == argc)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf,\n                                _(\"%s: option requires an argument -- '%c'\\n\"),\n                                argv[0], c) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr,\n                         _(\"%s: option requires an argument -- '%c'\\n\"),\n                         argv[0], c);\n#endif\n              }\n            d->optopt = c;\n            if (optstring[0] == ':')\n              c = ':';\n            else\n              c = '?';\n            return c;\n          }\n        else\n          /* We already incremented 'd->optind' once;\n             increment it again when taking next ARGV-elt as argument.  */\n          d->optarg = argv[d->optind++];\n\n        /* optarg is now the argument, see if it's in the\n           table of longopts.  */\n\n        for (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n             nameend++)\n          /* Do nothing.  */ ;\n\n        /* Test all long options for either exact match\n           or abbreviated matches.  */\n        for (p = longopts, option_index = 0; p->name; p++, option_index++)\n          if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n            {\n              if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n                {\n                  /* Exact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                  exact = 1;\n                  break;\n                }\n              else if (pfound == NULL)\n                {\n                  /* First nonexact match found.  */\n                  pfound = p;\n                  indfound = option_index;\n                }\n              else if (long_only\n                       || pfound->has_arg != p->has_arg\n                       || pfound->flag != p->flag\n                       || pfound->val != p->val)\n                /* Second or later nonexact match found.  */\n                ambig = 1;\n            }\n        if (ambig && !exact)\n          {\n            if (print_errors)\n              {\n#if defined _LIBC && defined USE_IN_LIBIO\n                char *buf;\n\n                if (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                                argv[0], d->optarg) >= 0)\n                  {\n                    _IO_flockfile (stderr);\n\n                    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                    __fxprintf (NULL, \"%s\", buf);\n\n                    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                    _IO_funlockfile (stderr);\n\n                    free (buf);\n                  }\n#else\n                fprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n                         argv[0], d->optarg);\n#endif\n              }\n            d->__nextchar += strlen (d->__nextchar);\n            d->optind++;\n            return '?';\n          }\n        if (pfound != NULL)\n          {\n            option_index = indfound;\n            if (*nameend)\n              {\n                /* Don't test has_arg with >, because some C compilers don't\n                   allow it to be used on enums.  */\n                if (pfound->has_arg)\n                  d->optarg = nameend + 1;\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n\n                    d->__nextchar += strlen (d->__nextchar);\n                    return '?';\n                  }\n              }\n            else if (pfound->has_arg == 1)\n              {\n                if (d->optind < argc)\n                  d->optarg = argv[d->optind++];\n                else\n                  {\n                    if (print_errors)\n                      {\n#if defined _LIBC && defined USE_IN_LIBIO\n                        char *buf;\n\n                        if (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                        argv[0], pfound->name) >= 0)\n                          {\n                            _IO_flockfile (stderr);\n\n                            int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                            ((_IO_FILE *) stderr)->_flags2\n                              |= _IO_FLAGS2_NOTCANCEL;\n\n                            __fxprintf (NULL, \"%s\", buf);\n\n                            ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                            _IO_funlockfile (stderr);\n\n                            free (buf);\n                          }\n#else\n                        fprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n                                 argv[0], pfound->name);\n#endif\n                      }\n                    d->__nextchar += strlen (d->__nextchar);\n                    return optstring[0] == ':' ? ':' : '?';\n                  }\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar += strlen (d->__nextchar);\n            if (longind != NULL)\n              *longind = option_index;\n            if (pfound->flag)\n              {\n                *(pfound->flag) = pfound->val;\n                return 0;\n              }\n            return pfound->val;\n          }\n\n      no_longs:\n        d->__nextchar = NULL;\n        return 'W';   /* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n        if (temp[2] == ':')\n          {\n            /* This is an option that accepts an argument optionally.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                d->optind++;\n              }\n            else\n              d->optarg = NULL;\n            d->__nextchar = NULL;\n          }\n        else\n          {\n            /* This is an option that requires an argument.  */\n            if (*d->__nextchar != '\\0')\n              {\n                d->optarg = d->__nextchar;\n                /* If we end this ARGV-element by taking the rest as an arg,\n                   we must advance to the next element now.  */\n                d->optind++;\n              }\n            else if (d->optind == argc)\n              {\n                if (print_errors)\n                  {\n#if defined _LIBC && defined USE_IN_LIBIO\n                    char *buf;\n\n                    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n                                    argv[0], c) >= 0)\n                      {\n                        _IO_flockfile (stderr);\n\n                        int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n                        ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n                        __fxprintf (NULL, \"%s\", buf);\n\n                        ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n                        _IO_funlockfile (stderr);\n\n                        free (buf);\n                      }\n#else\n                    fprintf (stderr,\n                             _(\"%s: option requires an argument -- '%c'\\n\"),\n                             argv[0], c);\n#endif\n                  }\n                d->optopt = c;\n                if (optstring[0] == ':')\n                  c = ':';\n                else\n                  c = '?';\n              }\n            else\n              /* We already incremented 'optind' once;\n                 increment it again when taking next ARGV-elt as argument.  */\n              d->optarg = argv[d->optind++];\n            d->__nextchar = NULL;\n          }\n      }\n    return c;\n  }\n}",
      "lines": 781,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1126,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char **argv, const char *optstring,\n                  const struct option *longopts, int *longind, int long_only,\n                  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n                               longind, long_only, &getopt_data,\n                               posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1155,
        0
      ],
      "end_point": [
        1162,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, (char **) argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, POSIXLY_CORRECT);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1172,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n                           (const struct option *) 0,\n                           (int *) 0,\n                           0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1242,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getopt.in.h": {},
  "recutils/recutils-1.7/lib/getopt1.c": {
    "getopt_long": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n             const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 0, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char **argv, const char *options,\n                const struct option *long_options, int *opt_index,\n                struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *__getopt_argv_const *argv,\n                  const char *options,\n                  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n                           opt_index, 1, 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char **argv, const char *options,\n                     const struct option *long_options, int *opt_index,\n                     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n                             1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static const struct option long_options[] =\n      {\n        {\"add\", 1, 0, 0},\n        {\"append\", 0, 0, 0},\n        {\"delete\", 1, 0, 0},\n        {\"verbose\", 0, 0, 0},\n        {\"create\", 0, 0, 0},\n        {\"file\", 1, 0, 0},\n        {0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n                       long_options, &option_index);\n      if (c == -1)\n        break;\n\n      switch (c)\n        {\n        case 0:\n          printf (\"option %s\", long_options[option_index].name);\n          if (optarg)\n            printf (\" with arg %s\", optarg);\n          printf (\"\\n\");\n          break;\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n          if (digit_optind != 0 && digit_optind != this_option_optind)\n            printf (\"digits occur in two different argv-elements.\\n\");\n          digit_optind = this_option_optind;\n          printf (\"option %c\\n\", c);\n          break;\n\n        case 'a':\n          printf (\"option a\\n\");\n          break;\n\n        case 'b':\n          printf (\"option b\\n\");\n          break;\n\n        case 'c':\n          printf (\"option c with value '%s'\\n\", optarg);\n          break;\n\n        case 'd':\n          printf (\"option d with value '%s'\\n\", optarg);\n          break;\n\n        case '?':\n          break;\n\n        default:\n          printf (\"?? getopt returned character code 0%o ??\\n\", c);\n        }\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n        printf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/getopt_int.h": {},
  "recutils/recutils-1.7/lib/getpass.c": {
    "call_fclose": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static void\ncall_fclose (void *arg)\n{\n  if (arg != NULL)\n    fclose (arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getpass": [
      {
        "start_point": [
          82,
          0
        ],
        "end_point": [
          169,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  FILE *tty;\n  FILE *in, *out;\n  struct termios s, t;\n  bool tty_changed = false;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n  /* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */\n\n  tty = fopen (\"/dev/tty\", \"w+\");\n  if (tty == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n      /* We do the locking ourselves.  */\n      __fsetlocking (tty, FSETLOCKING_BYCALLER);\n\n      out = in = tty;\n    }\n\n  flockfile (out);\n\n  /* Turn echoing off if it is on now.  */\n# if HAVE_TCGETATTR\n  if (tcgetattr (fileno (in), &t) == 0)\n    {\n      /* Save the old one. */\n      s = t;\n      /* Tricky, tricky. */\n      t.c_lflag &= ~(ECHO | ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &t) == 0);\n    }\n# endif\n\n  /* Write the prompt.  */\n  fputs_unlocked (prompt, out);\n  fflush_unlocked (out);\n\n  /* Read the password.  */\n  nread = getline (&buf, &bufsize, in);\n\n  /* According to the C standard, input may not be followed by output\n     on the same stream without an intervening call to a file\n     positioning function.  Suppose in == out; then without this fseek\n     call, on Solaris, HP-UX, AIX, OSF/1, the previous input gets\n     echoed, whereas on IRIX, the following newline is not output as\n     it should be.  POSIX imposes similar restrictions if fileno (in)\n     == fileno (out).  The POSIX restrictions are tricky and change\n     from POSIX version to POSIX version, so play it safe and invoke\n     fseek even if in != out.  */\n  fseeko (out, 0, SEEK_CUR);\n\n  if (buf != NULL)\n    {\n      if (nread < 0)\n        buf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n        {\n          /* Remove the newline.  */\n          buf[nread - 1] = '\\0';\n          if (tty_changed)\n            {\n              /* Write the newline that was not echoed.  */\n              putc_unlocked ('\\n', out);\n            }\n        }\n    }\n\n  /* Restore the original setting.  */\n# if HAVE_TCSETATTR\n  if (tty_changed)\n    tcsetattr (fileno (in), TCSAFLUSH | TCSASOFT, &s);\n# endif\n\n  funlockfile (out);\n\n  call_fclose (tty);\n\n  return buf;\n}",
        "lines": 88,
        "depth": 14,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      },
      {
        "start_point": [
          187,
          0
        ],
        "end_point": [
          227,
          1
        ],
        "content": "char *\ngetpass (const char *prompt)\n{\n  char getpassbuf[PASS_MAX + 1];\n  size_t i = 0;\n  int c;\n\n  if (prompt)\n    {\n      fputs (prompt, stderr);\n      fflush (stderr);\n    }\n\n  for (;;)\n    {\n      c = _getch ();\n      if (c == '\\r')\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n      else if (i < PASS_MAX)\n        {\n          getpassbuf[i++] = c;\n        }\n\n      if (i >= PASS_MAX)\n        {\n          getpassbuf[i] = '\\0';\n          break;\n        }\n    }\n\n  if (prompt)\n    {\n      fputs (\"\\r\\n\", stderr);\n      fflush (stderr);\n    }\n\n  return strdup (getpassbuf);\n}",
        "lines": 41,
        "depth": 12,
        "decorators": [
          "char",
          "*\ngetpass (const char *prompt)",
          "*"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/getpass.h": {},
  "recutils/recutils-1.7/lib/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/gettime.c": {
    "gettime": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ngettime (struct timespec *ts)\n{\n#if HAVE_NANOTIME\n  nanotime (ts);\n#else\n\n# if defined CLOCK_REALTIME && HAVE_CLOCK_GETTIME\n  if (clock_gettime (CLOCK_REALTIME, ts) == 0)\n    return;\n# endif\n\n  {\n    struct timeval tv;\n    gettimeofday (&tv, NULL);\n    ts->tv_sec = tv.tv_sec;\n    ts->tv_nsec = tv.tv_usec * 1000;\n  }\n\n#endif\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/gettimeofday.c": {
    "rpl_localtime": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "struct tm *\nrpl_localtime (time_t const *timep)\n{\n  struct tm *tm = localtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_localtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_gmtime": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct tm *\nrpl_gmtime (time_t const *timep)\n{\n  struct tm *tm = gmtime (timep);\n\n  if (localtime_buffer_addr == &tm_zero_buffer)\n    localtime_buffer_addr = tm;\n\n  return tm;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nrpl_gmtime (time_t const *timep)",
        "*"
      ]
    },
    "rpl_tzset": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "void\nrpl_tzset (void)\n{\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to tzset.  */\n  struct tm save = *localtime_buffer_addr;\n  tzset ();\n  *localtime_buffer_addr = save;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gettimeofday": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\ngettimeofday (struct timeval *restrict tv, void *restrict tz)\n{\n#undef gettimeofday\n#if HAVE_GETTIMEOFDAY\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  /* Save and restore the contents of the buffer used for localtime's\n     result around the call to gettimeofday.  */\n  struct tm save = *localtime_buffer_addr;\n# endif\n\n# if defined timeval /* 'struct timeval' overridden by gnulib?  */\n#  undef timeval\n  struct timeval otv;\n  int result = gettimeofday (&otv, (struct timezone *) tz);\n  if (result == 0)\n    {\n      tv->tv_sec = otv.tv_sec;\n      tv->tv_usec = otv.tv_usec;\n    }\n# else\n  int result = gettimeofday (tv, (struct timezone *) tz);\n# endif\n\n# if GETTIMEOFDAY_CLOBBERS_LOCALTIME\n  *localtime_buffer_addr = save;\n# endif\n\n  return result;\n\n#else\n\n# if HAVE__FTIME\n\n  struct _timeb timebuf;\n  _ftime (&timebuf);\n  tv->tv_sec = timebuf.time;\n  tv->tv_usec = timebuf.millitm * 1000;\n\n# else\n\n#  if !defined OK_TO_USE_1S_CLOCK\n#   error \"Only 1-second nominal clock resolution found.  Is that intended?\" \\\n          \"If so, compile with the -DOK_TO_USE_1S_CLOCK option.\"\n#  endif\n  tv->tv_sec = time (NULL);\n  tv->tv_usec = 0;\n\n# endif\n\n  return 0;\n\n#endif\n}",
      "lines": 54,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/gl_array_list.c": {
    "gl_array_nx_create_empty": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static gl_list_t\ngl_array_nx_create_empty (gl_list_implementation_t implementation,\n                          gl_listelement_equals_fn equals_fn,\n                          gl_listelement_hashcode_fn hashcode_fn,\n                          gl_listelement_dispose_fn dispose_fn,\n                          bool allow_duplicates)\n{\n  struct gl_list_impl *list =\n    (struct gl_list_impl *) malloc (sizeof (struct gl_list_impl));\n\n  if (list == NULL)\n    return NULL;\n\n  list->base.vtable = implementation;\n  list->base.equals_fn = equals_fn;\n  list->base.hashcode_fn = hashcode_fn;\n  list->base.dispose_fn = dispose_fn;\n  list->base.allow_duplicates = allow_duplicates;\n  list->elements = NULL;\n  list->count = 0;\n  list->allocated = 0;\n\n  return list;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_t"
      ]
    },
    "gl_array_nx_create": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static gl_list_t\ngl_array_nx_create (gl_list_implementation_t implementation,\n                    gl_listelement_equals_fn equals_fn,\n                    gl_listelement_hashcode_fn hashcode_fn,\n                    gl_listelement_dispose_fn dispose_fn,\n                    bool allow_duplicates,\n                    size_t count, const void **contents)\n{\n  struct gl_list_impl *list =\n    (struct gl_list_impl *) malloc (sizeof (struct gl_list_impl));\n\n  if (list == NULL)\n    return NULL;\n\n  list->base.vtable = implementation;\n  list->base.equals_fn = equals_fn;\n  list->base.hashcode_fn = hashcode_fn;\n  list->base.dispose_fn = dispose_fn;\n  list->base.allow_duplicates = allow_duplicates;\n  if (count > 0)\n    {\n      if (size_overflow_p (xtimes (count, sizeof (const void *))))\n        goto fail;\n      list->elements = (const void **) malloc (count * sizeof (const void *));\n      if (list->elements == NULL)\n        goto fail;\n      memcpy (list->elements, contents, count * sizeof (const void *));\n    }\n  else\n    list->elements = NULL;\n  list->count = count;\n  list->allocated = count;\n\n  return list;\n\n fail:\n  free (list);\n  return NULL;\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "gl_list_t"
      ]
    },
    "gl_array_size": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static size_t\ngl_array_size (gl_list_t list)\n{\n  return list->count;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "gl_array_node_value": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "static const void *\ngl_array_node_value (gl_list_t list, gl_list_node_t node)\n{\n  uintptr_t index = NODE_TO_INDEX (node);\n  if (!(index < list->count))\n    /* Invalid argument.  */\n    abort ();\n  return list->elements[index];\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "void",
        "*\ngl_array_node_value (gl_list_t list, gl_list_node_t node)",
        "*"
      ]
    },
    "gl_array_node_nx_set_value": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\ngl_array_node_nx_set_value (gl_list_t list, gl_list_node_t node,\n                            const void *elt)\n{\n  uintptr_t index = NODE_TO_INDEX (node);\n  if (!(index < list->count))\n    /* Invalid argument.  */\n    abort ();\n  list->elements[index] = elt;\n  return 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_array_next_node": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_next_node (gl_list_t list, gl_list_node_t node)\n{\n  uintptr_t index = NODE_TO_INDEX (node);\n  if (!(index < list->count))\n    /* Invalid argument.  */\n    abort ();\n  index++;\n  if (index < list->count)\n    return INDEX_TO_NODE (index);\n  else\n    return NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_previous_node": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_previous_node (gl_list_t list, gl_list_node_t node)\n{\n  uintptr_t index = NODE_TO_INDEX (node);\n  if (!(index < list->count))\n    /* Invalid argument.  */\n    abort ();\n  if (index > 0)\n    return INDEX_TO_NODE (index - 1);\n  else\n    return NULL;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_get_at": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static const void *\ngl_array_get_at (gl_list_t list, size_t position)\n{\n  size_t count = list->count;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  return list->elements[position];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "void",
        "*\ngl_array_get_at (gl_list_t list, size_t position)",
        "*"
      ]
    },
    "gl_array_nx_set_at": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_set_at (gl_list_t list, size_t position, const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  list->elements[position] = elt;\n  return INDEX_TO_NODE (position);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_indexof_from_to": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static size_t\ngl_array_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                          const void *elt)\n{\n  size_t count = list->count;\n\n  if (!(start_index <= end_index && end_index <= count))\n    /* Invalid arguments.  */\n    abort ();\n\n  if (start_index < end_index)\n    {\n      gl_listelement_equals_fn equals = list->base.equals_fn;\n      if (equals != NULL)\n        {\n          size_t i;\n\n          for (i = start_index;;)\n            {\n              if (equals (elt, list->elements[i]))\n                return i;\n              i++;\n              if (i == end_index)\n                break;\n            }\n        }\n      else\n        {\n          size_t i;\n\n          for (i = start_index;;)\n            {\n              if (elt == list->elements[i])\n                return i;\n              i++;\n              if (i == end_index)\n                break;\n            }\n        }\n    }\n  return (size_t)(-1);\n}",
      "lines": 42,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "gl_array_search_from_to": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_search_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                         const void *elt)\n{\n  size_t index = gl_array_indexof_from_to (list, start_index, end_index, elt);\n  return INDEX_TO_NODE (index);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "grow": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "static int\ngrow (gl_list_t list)\n{\n  size_t new_allocated;\n  size_t memory_size;\n  const void **memory;\n\n  new_allocated = xtimes (list->allocated, 2);\n  new_allocated = xsum (new_allocated, 1);\n  memory_size = xtimes (new_allocated, sizeof (const void *));\n  if (size_overflow_p (memory_size))\n    /* Overflow, would lead to out of memory.  */\n    return -1;\n  memory = (const void **) realloc (list->elements, memory_size);\n  if (memory == NULL)\n    /* Out of memory.  */\n    return -1;\n  list->elements = memory;\n  list->allocated = new_allocated;\n  return 0;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "gl_array_nx_add_first": {
      "start_point": [
        269,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_add_first (gl_list_t list, const void *elt)\n{\n  size_t count = list->count;\n  const void **elements;\n  size_t i;\n\n  if (count == list->allocated)\n    if (grow (list) < 0)\n      return NULL;\n  elements = list->elements;\n  for (i = count; i > 0; i--)\n    elements[i] = elements[i - 1];\n  elements[0] = elt;\n  list->count = count + 1;\n  return INDEX_TO_NODE (0);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_nx_add_last": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_add_last (gl_list_t list, const void *elt)\n{\n  size_t count = list->count;\n\n  if (count == list->allocated)\n    if (grow (list) < 0)\n      return NULL;\n  list->elements[count] = elt;\n  list->count = count + 1;\n  return INDEX_TO_NODE (count);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_nx_add_before": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_add_before (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  size_t count = list->count;\n  uintptr_t index = NODE_TO_INDEX (node);\n  size_t position;\n  const void **elements;\n  size_t i;\n\n  if (!(index < count))\n    /* Invalid argument.  */\n    abort ();\n  position = index;\n  if (count == list->allocated)\n    if (grow (list) < 0)\n      return NULL;\n  elements = list->elements;\n  for (i = count; i > position; i--)\n    elements[i] = elements[i - 1];\n  elements[position] = elt;\n  list->count = count + 1;\n  return INDEX_TO_NODE (position);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_nx_add_after": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_add_after (gl_list_t list, gl_list_node_t node, const void *elt)\n{\n  size_t count = list->count;\n  uintptr_t index = NODE_TO_INDEX (node);\n  size_t position;\n  const void **elements;\n  size_t i;\n\n  if (!(index < count))\n    /* Invalid argument.  */\n    abort ();\n  position = index + 1;\n  if (count == list->allocated)\n    if (grow (list) < 0)\n      return NULL;\n  elements = list->elements;\n  for (i = count; i > position; i--)\n    elements[i] = elements[i - 1];\n  elements[position] = elt;\n  list->count = count + 1;\n  return INDEX_TO_NODE (position);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_nx_add_at": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        367,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_nx_add_at (gl_list_t list, size_t position, const void *elt)\n{\n  size_t count = list->count;\n  const void **elements;\n  size_t i;\n\n  if (!(position <= count))\n    /* Invalid argument.  */\n    abort ();\n  if (count == list->allocated)\n    if (grow (list) < 0)\n      return NULL;\n  elements = list->elements;\n  for (i = count; i > position; i--)\n    elements[i] = elements[i - 1];\n  elements[position] = elt;\n  list->count = count + 1;\n  return INDEX_TO_NODE (position);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_remove_node": {
      "start_point": [
        369,
        0
      ],
      "end_point": [
        389,
        1
      ],
      "content": "static bool\ngl_array_remove_node (gl_list_t list, gl_list_node_t node)\n{\n  size_t count = list->count;\n  uintptr_t index = NODE_TO_INDEX (node);\n  size_t position;\n  const void **elements;\n  size_t i;\n\n  if (!(index < count))\n    /* Invalid argument.  */\n    abort ();\n  position = index;\n  elements = list->elements;\n  if (list->base.dispose_fn != NULL)\n    list->base.dispose_fn (elements[position]);\n  for (i = position + 1; i < count; i++)\n    elements[i - 1] = elements[i];\n  list->count = count - 1;\n  return true;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_array_remove_at": {
      "start_point": [
        391,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static bool\ngl_array_remove_at (gl_list_t list, size_t position)\n{\n  size_t count = list->count;\n  const void **elements;\n  size_t i;\n\n  if (!(position < count))\n    /* Invalid argument.  */\n    abort ();\n  elements = list->elements;\n  if (list->base.dispose_fn != NULL)\n    list->base.dispose_fn (elements[position]);\n  for (i = position + 1; i < count; i++)\n    elements[i - 1] = elements[i];\n  list->count = count - 1;\n  return true;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_array_remove": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "static bool\ngl_array_remove (gl_list_t list, const void *elt)\n{\n  size_t position = gl_array_indexof_from_to (list, 0, list->count, elt);\n  if (position == (size_t)(-1))\n    return false;\n  else\n    return gl_array_remove_at (list, position);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_array_list_free": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "static void\ngl_array_list_free (gl_list_t list)\n{\n  if (list->elements != NULL)\n    {\n      if (list->base.dispose_fn != NULL)\n        {\n          size_t count = list->count;\n\n          if (count > 0)\n            {\n              gl_listelement_dispose_fn dispose = list->base.dispose_fn;\n              const void **elements = list->elements;\n\n              do\n                dispose (*elements++);\n              while (--count > 0);\n            }\n        }\n      free (list->elements);\n    }\n  free (list);\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_array_iterator": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "static gl_list_iterator_t\ngl_array_iterator (gl_list_t list)\n{\n  gl_list_iterator_t result;\n\n  result.vtable = list->base.vtable;\n  result.list = list;\n  result.count = list->count;\n  result.p = list->elements + 0;\n  result.q = list->elements + list->count;\n#ifdef lint\n  result.i = 0;\n  result.j = 0;\n#endif\n\n  return result;\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "gl_list_iterator_t"
      ]
    },
    "gl_array_iterator_from_to": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static gl_list_iterator_t\ngl_array_iterator_from_to (gl_list_t list, size_t start_index, size_t end_index)\n{\n  gl_list_iterator_t result;\n\n  if (!(start_index <= end_index && end_index <= list->count))\n    /* Invalid arguments.  */\n    abort ();\n  result.vtable = list->base.vtable;\n  result.list = list;\n  result.count = list->count;\n  result.p = list->elements + start_index;\n  result.q = list->elements + end_index;\n#ifdef lint\n  result.i = 0;\n  result.j = 0;\n#endif\n\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "gl_list_iterator_t"
      ]
    },
    "gl_array_iterator_next": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "static bool\ngl_array_iterator_next (gl_list_iterator_t *iterator,\n                        const void **eltp, gl_list_node_t *nodep)\n{\n  gl_list_t list = iterator->list;\n  if (iterator->count != list->count)\n    {\n      if (iterator->count != list->count + 1)\n        /* Concurrent modifications were done on the list.  */\n        abort ();\n      /* The last returned element was removed.  */\n      iterator->count--;\n      iterator->p = (const void **) iterator->p - 1;\n      iterator->q = (const void **) iterator->q - 1;\n    }\n  if (iterator->p < iterator->q)\n    {\n      const void **p = (const void **) iterator->p;\n      *eltp = *p;\n      if (nodep != NULL)\n        *nodep = INDEX_TO_NODE (p - list->elements);\n      iterator->p = p + 1;\n      return true;\n    }\n  else\n    return false;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "gl_array_iterator_free": {
      "start_point": [
        513,
        0
      ],
      "end_point": [
        516,
        1
      ],
      "content": "static void\ngl_array_iterator_free (gl_list_iterator_t *iterator)\n{\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_array_sortedlist_indexof_from_to": {
      "start_point": [
        520,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "static size_t\ngl_array_sortedlist_indexof_from_to (gl_list_t list,\n                                     gl_listelement_compar_fn compar,\n                                     size_t low, size_t high,\n                                     const void *elt)\n{\n  if (!(low <= high && high <= list->count))\n    /* Invalid arguments.  */\n    abort ();\n  if (low < high)\n    {\n      /* At each loop iteration, low < high; for indices < low the values\n         are smaller than ELT; for indices >= high the values are greater\n         than ELT.  So, if the element occurs in the list, it is at\n         low <= position < high.  */\n      do\n        {\n          size_t mid = low + (high - low) / 2; /* low <= mid < high */\n          int cmp = compar (list->elements[mid], elt);\n\n          if (cmp < 0)\n            low = mid + 1;\n          else if (cmp > 0)\n            high = mid;\n          else /* cmp == 0 */\n            {\n              /* We have an element equal to ELT at index MID.  But we need\n                 the minimal such index.  */\n              high = mid;\n              /* At each loop iteration, low <= high and\n                   compar (list->elements[high], elt) == 0,\n                 and we know that the first occurrence of the element is at\n                 low <= position <= high.  */\n              while (low < high)\n                {\n                  size_t mid2 = low + (high - low) / 2; /* low <= mid2 < high */\n                  int cmp2 = compar (list->elements[mid2], elt);\n\n                  if (cmp2 < 0)\n                    low = mid2 + 1;\n                  else if (cmp2 > 0)\n                    /* The list was not sorted.  */\n                    abort ();\n                  else /* cmp2 == 0 */\n                    {\n                      if (mid2 == low)\n                        break;\n                      high = mid2 - 1;\n                    }\n                }\n              return low;\n            }\n        }\n      while (low < high);\n      /* Here low == high.  */\n    }\n  return (size_t)(-1);\n}",
      "lines": 58,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "gl_array_sortedlist_indexof": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static size_t\ngl_array_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar,\n                             const void *elt)\n{\n  return gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count,\n                                              elt);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "gl_array_sortedlist_search_from_to": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        596,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_sortedlist_search_from_to (gl_list_t list,\n                                    gl_listelement_compar_fn compar,\n                                    size_t low, size_t high,\n                                    const void *elt)\n{\n  size_t index =\n    gl_array_sortedlist_indexof_from_to (list, compar, low, high, elt);\n  return INDEX_TO_NODE (index);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_sortedlist_search": {
      "start_point": [
        598,
        0
      ],
      "end_point": [
        605,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar,\n                            const void *elt)\n{\n  size_t index =\n    gl_array_sortedlist_indexof_from_to (list, compar, 0, list->count, elt);\n  return INDEX_TO_NODE (index);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_sortedlist_nx_add": {
      "start_point": [
        607,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static gl_list_node_t\ngl_array_sortedlist_nx_add (gl_list_t list, gl_listelement_compar_fn compar,\n                            const void *elt)\n{\n  size_t count = list->count;\n  size_t low = 0;\n  size_t high = count;\n\n  /* At each loop iteration, low <= high; for indices < low the values are\n     smaller than ELT; for indices >= high the values are greater than ELT.  */\n  while (low < high)\n    {\n      size_t mid = low + (high - low) / 2; /* low <= mid < high */\n      int cmp = compar (list->elements[mid], elt);\n\n      if (cmp < 0)\n        low = mid + 1;\n      else if (cmp > 0)\n        high = mid;\n      else /* cmp == 0 */\n        {\n          low = mid;\n          break;\n        }\n    }\n  return gl_array_nx_add_at (list, low, elt);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "gl_list_node_t"
      ]
    },
    "gl_array_sortedlist_remove": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static bool\ngl_array_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar,\n                            const void *elt)\n{\n  size_t index = gl_array_sortedlist_indexof (list, compar, elt);\n  if (index == (size_t)(-1))\n    return false;\n  else\n    return gl_array_remove_at (list, index);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/gl_array_list.h": {},
  "recutils/recutils-1.7/lib/gl_list.c": {},
  "recutils/recutils-1.7/lib/gl_list.h": {
    "gl_list_nx_create_empty": {
      "start_point": [
        554,
        0
      ],
      "end_point": [
        564,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create_empty (gl_list_implementation_t implementation,\n                         gl_listelement_equals_fn equals_fn,\n                         gl_listelement_hashcode_fn hashcode_fn,\n                         gl_listelement_dispose_fn dispose_fn,\n                         bool allow_duplicates)\n{\n  return implementation->nx_create_empty (implementation, equals_fn,\n                                          hashcode_fn, dispose_fn,\n                                          allow_duplicates);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_nx_create": {
      "start_point": [
        566,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_t\ngl_list_nx_create (gl_list_implementation_t implementation,\n                   gl_listelement_equals_fn equals_fn,\n                   gl_listelement_hashcode_fn hashcode_fn,\n                   gl_listelement_dispose_fn dispose_fn,\n                   bool allow_duplicates,\n                   size_t count, const void **contents)\n{\n  return implementation->nx_create (implementation, equals_fn, hashcode_fn,\n                                    dispose_fn, allow_duplicates, count,\n                                    contents);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_t",
        "gl_list_t"
      ]
    },
    "gl_list_size": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        584,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_size (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->size (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_node_value": {
      "start_point": [
        586,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_node_value (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_value (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_node_value (gl_list_t list, gl_list_node_t node)",
        "*"
      ]
    },
    "__warn_unused_result__": [
      {
        "start_point": [
          598,
          33
        ],
        "end_point": [
          602,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->node_nx_set_value (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          629,
          58
        ],
        "end_point": [
          633,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_set_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          687,
          44
        ],
        "end_point": [
          691,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_first (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          697,
          43
        ],
        "end_point": [
          701,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_last (list, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          707,
          66
        ],
        "end_point": [
          711,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_before (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          717,
          65
        ],
        "end_point": [
          721,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_after (list, node, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          727,
          58
        ],
        "end_point": [
          731,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->nx_add_at (list, position, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      },
      {
        "start_point": [
          821,
          77
        ],
        "end_point": [
          825,
          1
        ],
        "content": "void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_nx_add (list, compar, elt);\n}",
        "lines": 5,
        "depth": 11,
        "decorators": null
      }
    ],
    "gl_list_next_node": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        609,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_next_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->next_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_previous_node": {
      "start_point": [
        611,
        0
      ],
      "end_point": [
        616,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_previous_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->previous_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_get_at": {
      "start_point": [
        618,
        0
      ],
      "end_point": [
        623,
        1
      ],
      "content": "GL_LIST_INLINE const void *\ngl_list_get_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->get_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "const",
        "const",
        "void",
        "void",
        "*\ngl_list_get_at (gl_list_t list, size_t position)",
        "*"
      ]
    },
    "gl_list_search": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_search_from_to": {
      "start_point": [
        651,
        0
      ],
      "end_point": [
        657,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_list_search_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                        const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->search_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_list_indexof": {
      "start_point": [
        659,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof (gl_list_t list, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, 0, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        673,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from (gl_list_t list, size_t start_index, const void *elt)\n{\n  size_t size = ((const struct gl_list_impl_base *) list)->vtable->size (list);\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, size, elt);\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_indexof_from_to": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_list_indexof_from_to (gl_list_t list, size_t start_index, size_t end_index,\n                         const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->indexof_from_to (list, start_index, end_index, elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_list_remove_node": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_node (gl_list_t list, gl_list_node_t node)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_node (list, node);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove_at": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        745,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove_at (gl_list_t list, size_t position)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_at (list, position);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_remove": {
      "start_point": [
        747,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_remove (gl_list_t list, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->remove_elt (list, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_free": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        758,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_free (gl_list_t list)\n{\n  ((const struct gl_list_impl_base *) list)->vtable->list_free (list);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_list_iterator": {
      "start_point": [
        760,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator (gl_list_t list)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator (list);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_from_to": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_iterator_t\ngl_list_iterator_from_to (gl_list_t list, size_t start_index, size_t end_index)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->iterator_from_to (list, start_index, end_index);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_iterator_t",
        "gl_list_iterator_t"
      ]
    },
    "gl_list_iterator_next": {
      "start_point": [
        774,
        0
      ],
      "end_point": [
        779,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_list_iterator_next (gl_list_iterator_t *iterator,\n                       const void **eltp, gl_list_node_t *nodep)\n{\n  return iterator->vtable->iterator_next (iterator, eltp, nodep);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    },
    "gl_list_iterator_free": {
      "start_point": [
        781,
        0
      ],
      "end_point": [
        785,
        1
      ],
      "content": "GL_LIST_INLINE void\ngl_list_iterator_free (gl_list_iterator_t *iterator)\n{\n  iterator->vtable->iterator_free (iterator);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "GL_LIST_INLINE",
        "void",
        "void"
      ]
    },
    "gl_sortedlist_search": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        792,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_search_from_to": {
      "start_point": [
        794,
        0
      ],
      "end_point": [
        800,
        1
      ],
      "content": "GL_LIST_INLINE gl_list_node_t\ngl_sortedlist_search_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_search_from_to (list, compar, start_index, end_index,\n                                      elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "gl_list_node_t",
        "gl_list_node_t"
      ]
    },
    "gl_sortedlist_indexof": {
      "start_point": [
        802,
        0
      ],
      "end_point": [
        807,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_indexof_from_to": {
      "start_point": [
        809,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "GL_LIST_INLINE size_t\ngl_sortedlist_indexof_from_to (gl_list_t list, gl_listelement_compar_fn compar, size_t start_index, size_t end_index, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_indexof_from_to (list, compar, start_index, end_index,\n                                       elt);\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "size_t",
        "size_t"
      ]
    },
    "gl_sortedlist_remove": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        832,
        1
      ],
      "content": "GL_LIST_INLINE bool\ngl_sortedlist_remove (gl_list_t list, gl_listelement_compar_fn compar, const void *elt)\n{\n  return ((const struct gl_list_impl_base *) list)->vtable\n         ->sortedlist_remove (list, compar, elt);\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "GL_LIST_INLINE",
        "bool",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/group-member.c": {
    "free_group_info": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nfree_group_info (struct group_info const *g)\n{\n  if (g->group != g->groupbuf)\n    free (g->group);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_group_info": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nget_group_info (struct group_info *gi)\n{\n  int n_groups = getgroups (GROUPBUF_SIZE, gi->groupbuf);\n  gi->group = gi->groupbuf;\n\n  if (n_groups < 0)\n    {\n      int n_group_slots = getgroups (0, NULL);\n      if (0 <= n_group_slots\n          && ! xalloc_oversized (n_group_slots, sizeof *gi->group))\n        {\n          gi->group = malloc (n_group_slots * sizeof *gi->group);\n          if (gi->group)\n            n_groups = getgroups (n_group_slots, gi->group);\n        }\n    }\n\n  /* In case of error, the user loses.  */\n  return n_groups;\n}",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "group_member": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\ngroup_member (gid_t gid)\n{\n  int i;\n  int found;\n  struct group_info gi;\n  int n_groups = get_group_info (&gi);\n\n  /* Search through the list looking for GID. */\n  found = 0;\n  for (i = 0; i < n_groups; i++)\n    {\n      if (gid == gi.group[i])\n        {\n          found = 1;\n          break;\n        }\n    }\n\n  free_group_info (&gi);\n\n  return found;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int i;\n\n  program_name = argv[0];\n\n  for (i = 1; i < argc; i++)\n    {\n      gid_t gid;\n\n      gid = atoi (argv[i]);\n      printf (\"%d: %s\\n\", gid, group_member (gid) ? \"yes\" : \"no\");\n    }\n  exit (0);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/intprops.h": {},
  "recutils/recutils-1.7/lib/isnan.c": {
    "FUNC": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\nFUNC (DOUBLE x)\n{\n#if defined KNOWN_EXPBIT0_LOCATION && IEEE_FLOATING_POINT\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n  /* Special CPU dependent code is needed to treat bit patterns outside the\n     IEEE 754 specification (such as Pseudo-NaNs, Pseudo-Infinities,\n     Pseudo-Zeroes, Unnormalized Numbers, and Pseudo-Denormals) as NaNs.\n     These bit patterns are:\n       - exponent = 0x0001..0x7FFF, mantissa bit 63 = 0,\n       - exponent = 0x0000, mantissa bit 63 = 1.\n     The NaN bit pattern is:\n       - exponent = 0x7FFF, mantissa >= 0x8000000000000001.  */\n  memory_double m;\n  unsigned int exponent;\n\n  m.value = x;\n  exponent = (m.word[EXPBIT0_WORD] >> EXPBIT0_BIT) & EXP_MASK;\n#  ifdef WORDS_BIGENDIAN\n  /* Big endian: EXPBIT0_WORD = 0, EXPBIT0_BIT = 16.  */\n  if (exponent == 0)\n    return 1 & (m.word[0] >> 15);\n  else if (exponent == EXP_MASK)\n    return (((m.word[0] ^ 0x8000U) << 16) | m.word[1] | (m.word[2] >> 16)) != 0;\n  else\n    return 1 & ~(m.word[0] >> 15);\n#  else\n  /* Little endian: EXPBIT0_WORD = 2, EXPBIT0_BIT = 0.  */\n  if (exponent == 0)\n    return (m.word[1] >> 31);\n  else if (exponent == EXP_MASK)\n    return ((m.word[1] ^ 0x80000000U) | m.word[0]) != 0;\n  else\n    return (m.word[1] >> 31) ^ 1;\n#  endif\n# else\n  /* Be careful to not do any floating-point operation on x, such as x == x,\n     because x may be a signaling NaN.  */\n#  if defined __SUNPRO_C || defined __ICC || defined _MSC_VER \\\n      || defined __DECC || defined __TINYC__ \\\n      || (defined __sgi && !defined __GNUC__)\n  /* The Sun C 5.0, Intel ICC 10.0, Microsoft Visual C/C++ 9.0, Compaq (ex-DEC)\n     6.4, and TinyCC compilers don't recognize the initializers as constant\n     expressions.  The Compaq compiler also fails when constant-folding\n     0.0 / 0.0 even when constant-folding is not required.  The Microsoft\n     Visual C/C++ compiler also fails when constant-folding 1.0 / 0.0 even\n     when constant-folding is not required. The SGI MIPSpro C compiler\n     complains about \"floating-point operation result is out of range\".  */\n  static DOUBLE zero = L_(0.0);\n  memory_double nan;\n  DOUBLE plus_inf = L_(1.0) / zero;\n  DOUBLE minus_inf = -L_(1.0) / zero;\n  nan.value = zero / zero;\n#  else\n  static memory_double nan = { L_(0.0) / L_(0.0) };\n  static DOUBLE plus_inf = L_(1.0) / L_(0.0);\n  static DOUBLE minus_inf = -L_(1.0) / L_(0.0);\n#  endif\n  {\n    memory_double m;\n\n    /* A NaN can be recognized through its exponent.  But exclude +Infinity and\n       -Infinity, which have the same exponent.  */\n    m.value = x;\n    if (((m.word[EXPBIT0_WORD] ^ nan.word[EXPBIT0_WORD])\n         & (EXP_MASK << EXPBIT0_BIT))\n        == 0)\n      return (memcmp (&m.value, &plus_inf, SIZE) != 0\n              && memcmp (&m.value, &minus_inf, SIZE) != 0);\n    else\n      return 0;\n  }\n# endif\n#else\n  /* The configuration did not find sufficient information, or does\n     not use IEEE floating point.  Give up about the signaling NaNs;\n     handle only the quiet NaNs.  */\n  if (x == x)\n    {\n# if defined USE_LONG_DOUBLE && ((defined __ia64 && LDBL_MANT_DIG == 64) || (defined __x86_64__ || defined __amd64__) || (defined __i386 || defined __i386__ || defined _I386 || defined _M_IX86 || defined _X86_)) && !HAVE_SAME_LONG_DOUBLE_AS_DOUBLE\n      /* Detect any special bit patterns that pass ==; see comment above.  */\n      memory_double m1;\n      memory_double m2;\n\n      memset (&m1.value, 0, SIZE);\n      memset (&m2.value, 0, SIZE);\n      m1.value = x;\n      m2.value = x + (x ? 0.0L : -0.0L);\n      if (memcmp (&m1.value, &m2.value, SIZE) != 0)\n        return 1;\n# endif\n      return 0;\n    }\n  else\n    return 1;\n#endif\n}",
      "lines": 97,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/isnand-nolibm.h": {},
  "recutils/recutils-1.7/lib/isnand.c": {},
  "recutils/recutils-1.7/lib/isnanf-nolibm.h": {},
  "recutils/recutils-1.7/lib/isnanf.c": {},
  "recutils/recutils-1.7/lib/isnanl-nolibm.h": {},
  "recutils/recutils-1.7/lib/isnanl.c": {},
  "recutils/recutils-1.7/lib/itold.c": {
    "_Qp_itoq": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\n_Qp_itoq (long double *result, int a)\n{\n  /* Convert from 'int' to 'double', then from 'double' to 'long double'.  */\n  *result = (double) a;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/langinfo.in.h": {},
  "recutils/recutils-1.7/lib/localcharset.c": {
    "get_charset_aliases": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "static const char *\nget_charset_aliases (void)\n{\n  const char *cp;\n\n  cp = charset_aliases;\n  if (cp == NULL)\n    {\n#if !(defined DARWIN7 || defined VMS || defined WINDOWS_NATIVE || defined __CYGWIN__)\n      const char *dir;\n      const char *base = \"charset.alias\";\n      char *file_name;\n\n      /* Make it possible to override the charset.alias location.  This is\n         necessary for running the testsuite before \"make install\".  */\n      dir = getenv (\"CHARSETALIASDIR\");\n      if (dir == NULL || dir[0] == '\\0')\n        dir = relocate (LIBDIR);\n\n      /* Concatenate dir and base into freshly allocated file_name.  */\n      {\n        size_t dir_len = strlen (dir);\n        size_t base_len = strlen (base);\n        int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));\n        file_name = (char *) malloc (dir_len + add_slash + base_len + 1);\n        if (file_name != NULL)\n          {\n            memcpy (file_name, dir, dir_len);\n            if (add_slash)\n              file_name[dir_len] = DIRECTORY_SEPARATOR;\n            memcpy (file_name + dir_len + add_slash, base, base_len + 1);\n          }\n      }\n\n      if (file_name == NULL)\n        /* Out of memory.  Treat the file as empty.  */\n        cp = \"\";\n      else\n        {\n          int fd;\n\n          /* Open the file.  Reject symbolic links on platforms that support\n             O_NOFOLLOW.  This is a security feature.  Without it, an attacker\n             could retrieve parts of the contents (namely, the tail of the\n             first line that starts with \"* \") of an arbitrary file by placing\n             a symbolic link to that file under the name \"charset.alias\" in\n             some writable directory and defining the environment variable\n             CHARSETALIASDIR to point to that directory.  */\n          fd = open (file_name,\n                     O_RDONLY | (HAVE_WORKING_O_NOFOLLOW ? O_NOFOLLOW : 0));\n          if (fd < 0)\n            /* File not found.  Treat it as empty.  */\n            cp = \"\";\n          else\n            {\n              FILE *fp;\n\n              fp = fdopen (fd, \"r\");\n              if (fp == NULL)\n                {\n                  /* Out of memory.  Treat the file as empty.  */\n                  close (fd);\n                  cp = \"\";\n                }\n              else\n                {\n                  /* Parse the file's contents.  */\n                  char *res_ptr = NULL;\n                  size_t res_size = 0;\n\n                  for (;;)\n                    {\n                      int c;\n                      char buf1[50+1];\n                      char buf2[50+1];\n                      size_t l1, l2;\n                      char *old_res_ptr;\n\n                      c = getc (fp);\n                      if (c == EOF)\n                        break;\n                      if (c == '\\n' || c == ' ' || c == '\\t')\n                        continue;\n                      if (c == '#')\n                        {\n                          /* Skip comment, to end of line.  */\n                          do\n                            c = getc (fp);\n                          while (!(c == EOF || c == '\\n'));\n                          if (c == EOF)\n                            break;\n                          continue;\n                        }\n                      ungetc (c, fp);\n                      if (fscanf (fp, \"%50s %50s\", buf1, buf2) < 2)\n                        break;\n                      l1 = strlen (buf1);\n                      l2 = strlen (buf2);\n                      old_res_ptr = res_ptr;\n                      if (res_size == 0)\n                        {\n                          res_size = l1 + 1 + l2 + 1;\n                          res_ptr = (char *) malloc (res_size + 1);\n                        }\n                      else\n                        {\n                          res_size += l1 + 1 + l2 + 1;\n                          res_ptr = (char *) realloc (res_ptr, res_size + 1);\n                        }\n                      if (res_ptr == NULL)\n                        {\n                          /* Out of memory. */\n                          res_size = 0;\n                          free (old_res_ptr);\n                          break;\n                        }\n                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);\n                      strcpy (res_ptr + res_size - (l2 + 1), buf2);\n                    }\n                  fclose (fp);\n                  if (res_size == 0)\n                    cp = \"\";\n                  else\n                    {\n                      *(res_ptr + res_size) = '\\0';\n                      cp = res_ptr;\n                    }\n                }\n            }\n\n          free (file_name);\n        }\n\n#else\n\n# if defined DARWIN7\n      /* To avoid the trouble of installing a file that is shared by many\n         GNU packages -- many packaging systems have problems with this --,\n         simply inline the aliases here.  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-4\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"ISO8859-13\" \"\\0\" \"ISO-8859-13\" \"\\0\"\n           \"ISO8859-15\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"KOI8-R\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"KOI8-U\" \"\\0\" \"KOI8-U\" \"\\0\"\n           \"CP866\" \"\\0\" \"CP866\" \"\\0\"\n           \"CP949\" \"\\0\" \"CP949\" \"\\0\"\n           \"CP1131\" \"\\0\" \"CP1131\" \"\\0\"\n           \"CP1251\" \"\\0\" \"CP1251\" \"\\0\"\n           \"eucCN\" \"\\0\" \"GB2312\" \"\\0\"\n           \"GB2312\" \"\\0\" \"GB2312\" \"\\0\"\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"eucKR\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"Big5\" \"\\0\" \"BIG5\" \"\\0\"\n           \"Big5HKSCS\" \"\\0\" \"BIG5-HKSCS\" \"\\0\"\n           \"GBK\" \"\\0\" \"GBK\" \"\\0\"\n           \"GB18030\" \"\\0\" \"GB18030\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"ARMSCII-8\" \"\\0\" \"ARMSCII-8\" \"\\0\"\n           \"PT154\" \"\\0\" \"PT154\" \"\\0\"\n         /*\"ISCII-DEV\" \"\\0\" \"?\" \"\\0\"*/\n           \"*\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n\n# if defined VMS\n      /* To avoid the troubles of an extra file charset.alias_vms in the\n         sources of many GNU packages, simply inline the aliases here.  */\n      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation\n         \"Compaq C Run-Time Library Reference Manual for OpenVMS systems\"\n         section 10.7 \"Handling Different Character Sets\".  */\n      cp = \"ISO8859-1\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"ISO8859-2\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"ISO8859-5\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"ISO8859-7\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"ISO8859-8\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"ISO8859-9\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           /* Japanese */\n           \"eucJP\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"SJIS\" \"\\0\" \"SHIFT_JIS\" \"\\0\"\n           \"DECKANJI\" \"\\0\" \"DEC-KANJI\" \"\\0\"\n           \"SDECKANJI\" \"\\0\" \"EUC-JP\" \"\\0\"\n           /* Chinese */\n           \"eucTW\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"DECHANYU\" \"\\0\" \"DEC-HANYU\" \"\\0\"\n           \"DECHANZI\" \"\\0\" \"GB2312\" \"\\0\"\n           /* Korean */\n           \"DECKOREAN\" \"\\0\" \"EUC-KR\" \"\\0\";\n# endif\n\n# if defined WINDOWS_NATIVE || defined __CYGWIN__\n      /* To avoid the troubles of installing a separate file in the same\n         directory as the DLL and of retrieving the DLL's directory at\n         runtime, simply inline the aliases here.  */\n\n      cp = \"CP936\" \"\\0\" \"GBK\" \"\\0\"\n           \"CP1361\" \"\\0\" \"JOHAB\" \"\\0\"\n           \"CP20127\" \"\\0\" \"ASCII\" \"\\0\"\n           \"CP20866\" \"\\0\" \"KOI8-R\" \"\\0\"\n           \"CP20936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP21866\" \"\\0\" \"KOI8-RU\" \"\\0\"\n           \"CP28591\" \"\\0\" \"ISO-8859-1\" \"\\0\"\n           \"CP28592\" \"\\0\" \"ISO-8859-2\" \"\\0\"\n           \"CP28593\" \"\\0\" \"ISO-8859-3\" \"\\0\"\n           \"CP28594\" \"\\0\" \"ISO-8859-4\" \"\\0\"\n           \"CP28595\" \"\\0\" \"ISO-8859-5\" \"\\0\"\n           \"CP28596\" \"\\0\" \"ISO-8859-6\" \"\\0\"\n           \"CP28597\" \"\\0\" \"ISO-8859-7\" \"\\0\"\n           \"CP28598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP28599\" \"\\0\" \"ISO-8859-9\" \"\\0\"\n           \"CP28605\" \"\\0\" \"ISO-8859-15\" \"\\0\"\n           \"CP38598\" \"\\0\" \"ISO-8859-8\" \"\\0\"\n           \"CP51932\" \"\\0\" \"EUC-JP\" \"\\0\"\n           \"CP51936\" \"\\0\" \"GB2312\" \"\\0\"\n           \"CP51949\" \"\\0\" \"EUC-KR\" \"\\0\"\n           \"CP51950\" \"\\0\" \"EUC-TW\" \"\\0\"\n           \"CP54936\" \"\\0\" \"GB18030\" \"\\0\"\n           \"CP65001\" \"\\0\" \"UTF-8\" \"\\0\";\n# endif\n#endif\n\n      charset_aliases = cp;\n    }\n\n  return cp;\n}",
      "lines": 229,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nget_charset_aliases (void)",
        "*"
      ]
    },
    "locale_charset": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        557,
        1
      ],
      "content": "const char *\nlocale_charset (void)\n{\n  const char *codeset;\n  const char *aliases;\n\n#if !(defined WINDOWS_NATIVE || defined OS2)\n\n# if HAVE_LANGINFO_CODESET\n\n  /* Most systems support nl_langinfo (CODESET) nowadays.  */\n  codeset = nl_langinfo (CODESET);\n\n#  ifdef __CYGWIN__\n  /* Cygwin < 1.7 does not have locales.  nl_langinfo (CODESET) always\n     returns \"US-ASCII\".  Return the suffix of the locale name from the\n     environment variables (if present) or the codepage as a number.  */\n  if (codeset != NULL && strcmp (codeset, \"US-ASCII\") == 0)\n    {\n      const char *locale;\n      static char buf[2 + 10 + 1];\n\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n      if (locale != NULL && locale[0] != '\\0')\n        {\n          /* If the locale name contains an encoding after the dot, return\n             it.  */\n          const char *dot = strchr (locale, '.');\n\n          if (dot != NULL)\n            {\n              const char *modifier;\n\n              dot++;\n              /* Look for the possible @... trailer and remove it, if any.  */\n              modifier = strchr (dot, '@');\n              if (modifier == NULL)\n                return dot;\n              if (modifier - dot < sizeof (buf))\n                {\n                  memcpy (buf, dot, modifier - dot);\n                  buf [modifier - dot] = '\\0';\n                  return buf;\n                }\n            }\n        }\n\n      /* The Windows API has a function returning the locale's codepage as a\n         number: GetACP().  This encoding is used by Cygwin, unless the user\n         has set the environment variable CYGWIN=codepage:oem (which very few\n         people do).\n         Output directed to console windows needs to be converted (to\n         GetOEMCP() if the console is using a raster font, or to\n         GetConsoleOutputCP() if it is using a TrueType font).  Cygwin does\n         this conversion transparently (see winsup/cygwin/fhandler_console.cc),\n         converting to GetConsoleOutputCP().  This leads to correct results,\n         except when SetConsoleOutputCP has been called and a raster font is\n         in use.  */\n      sprintf (buf, \"CP%u\", GetACP ());\n      codeset = buf;\n    }\n#  endif\n\n# else\n\n  /* On old systems which lack it, use setlocale or getenv.  */\n  const char *locale = NULL;\n\n  /* But most old systems don't have a complete set of locales.  Some\n     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't\n     use setlocale here; it would return \"C\" when it doesn't support the\n     locale name the user has set.  */\n#  if 0\n  locale = setlocale (LC_CTYPE, NULL);\n#  endif\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_ALL\");\n      if (locale == NULL || locale[0] == '\\0')\n        {\n          locale = getenv (\"LC_CTYPE\");\n          if (locale == NULL || locale[0] == '\\0')\n            locale = getenv (\"LANG\");\n        }\n    }\n\n  /* On some old systems, one used to set locale = \"iso8859_1\". On others,\n     you set it to \"language_COUNTRY.charset\". In any case, we resolve it\n     through the charset.alias file.  */\n  codeset = locale;\n\n# endif\n\n#elif defined WINDOWS_NATIVE\n\n  static char buf[2 + 10 + 1];\n\n  /* The Windows API has a function returning the locale's codepage as a\n     number: GetACP().\n     When the output goes to a console window, it needs to be provided in\n     GetOEMCP() encoding if the console is using a raster font, or in\n     GetConsoleOutputCP() encoding if it is using a TrueType font.\n     But in GUI programs and for output sent to files and pipes, GetACP()\n     encoding is the best bet.  */\n  sprintf (buf, \"CP%u\", GetACP ());\n  codeset = buf;\n\n#elif defined OS2\n\n  const char *locale;\n  static char buf[2 + 10 + 1];\n  ULONG cp[3];\n  ULONG cplen;\n\n  /* Allow user to override the codeset, as set in the operating system,\n     with standard language environment variables.  */\n  locale = getenv (\"LC_ALL\");\n  if (locale == NULL || locale[0] == '\\0')\n    {\n      locale = getenv (\"LC_CTYPE\");\n      if (locale == NULL || locale[0] == '\\0')\n        locale = getenv (\"LANG\");\n    }\n  if (locale != NULL && locale[0] != '\\0')\n    {\n      /* If the locale name contains an encoding after the dot, return it.  */\n      const char *dot = strchr (locale, '.');\n\n      if (dot != NULL)\n        {\n          const char *modifier;\n\n          dot++;\n          /* Look for the possible @... trailer and remove it, if any.  */\n          modifier = strchr (dot, '@');\n          if (modifier == NULL)\n            return dot;\n          if (modifier - dot < sizeof (buf))\n            {\n              memcpy (buf, dot, modifier - dot);\n              buf [modifier - dot] = '\\0';\n              return buf;\n            }\n        }\n\n      /* Resolve through the charset.alias file.  */\n      codeset = locale;\n    }\n  else\n    {\n      /* OS/2 has a function returning the locale's codepage as a number.  */\n      if (DosQueryCp (sizeof (cp), cp, &cplen))\n        codeset = \"\";\n      else\n        {\n          sprintf (buf, \"CP%u\", cp[0]);\n          codeset = buf;\n        }\n    }\n\n#endif\n\n  if (codeset == NULL)\n    /* The canonical name cannot be determined.  */\n    codeset = \"\";\n\n  /* Resolve alias. */\n  for (aliases = get_charset_aliases ();\n       *aliases != '\\0';\n       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)\n    if (strcmp (codeset, aliases) == 0\n        || (aliases[0] == '*' && aliases[1] == '\\0'))\n      {\n        codeset = aliases + strlen (aliases) + 1;\n        break;\n      }\n\n  /* Don't return an empty string.  GNU libc and GNU libiconv interpret\n     the empty string as denoting \"the locale's character encoding\",\n     thus GNU libiconv would call this function a second time.  */\n  if (codeset[0] == '\\0')\n    codeset = \"ASCII\";\n\n#ifdef DARWIN7\n  /* Mac OS X sets MB_CUR_MAX to 1 when LC_ALL=C, and \"UTF-8\"\n     (the default codeset) does not work when MB_CUR_MAX is 1.  */\n  if (strcmp (codeset, \"UTF-8\") == 0 && MB_CUR_MAX_L (uselocale (NULL)) <= 1)\n    codeset = \"ASCII\";\n#endif\n\n  return codeset;\n}",
      "lines": 198,
      "depth": 18,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nlocale_charset (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/localcharset.h": {},
  "recutils/recutils-1.7/lib/locale.in.h": {},
  "recutils/recutils-1.7/lib/localeconv.c": {
    "localeconv": [
      {
        "start_point": [
          26,
          0
        ],
        "end_point": [
          60,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static struct lconv result;\n# undef lconv\n# undef localeconv\n  struct lconv *sys_result = localeconv ();\n\n  result.decimal_point = sys_result->decimal_point;\n  result.thousands_sep = sys_result->thousands_sep;\n  result.grouping = sys_result->grouping;\n  result.mon_decimal_point = sys_result->mon_decimal_point;\n  result.mon_thousands_sep = sys_result->mon_thousands_sep;\n  result.mon_grouping = sys_result->mon_grouping;\n  result.positive_sign = sys_result->positive_sign;\n  result.negative_sign = sys_result->negative_sign;\n  result.currency_symbol = sys_result->currency_symbol;\n  result.frac_digits = sys_result->frac_digits;\n  result.p_cs_precedes = sys_result->p_cs_precedes;\n  result.p_sign_posn = sys_result->p_sign_posn;\n  result.p_sep_by_space = sys_result->p_sep_by_space;\n  result.n_cs_precedes = sys_result->n_cs_precedes;\n  result.n_sign_posn = sys_result->n_sign_posn;\n  result.n_sep_by_space = sys_result->n_sep_by_space;\n  result.int_curr_symbol = sys_result->int_curr_symbol;\n  result.int_frac_digits = sys_result->int_frac_digits;\n  result.int_p_cs_precedes = sys_result->p_cs_precedes;\n  result.int_p_sign_posn = sys_result->p_sign_posn;\n  result.int_p_sep_by_space = sys_result->p_sep_by_space;\n  result.int_n_cs_precedes = sys_result->n_cs_precedes;\n  result.int_n_sign_posn = sys_result->n_sign_posn;\n  result.int_n_sep_by_space = sys_result->n_sep_by_space;\n\n  return &result;\n}",
        "lines": 35,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      },
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          100,
          1
        ],
        "content": "struct lconv *\nlocaleconv (void)\n{\n  static /*const*/ struct lconv result =\n    {\n      /* decimal_point */ \".\",\n      /* thousands_sep */ \"\",\n      /* grouping */ \"\",\n      /* mon_decimal_point */ \"\",\n      /* mon_thousands_sep */ \"\",\n      /* mon_grouping */ \"\",\n      /* positive_sign */ \"\",\n      /* negative_sign */ \"\",\n      /* currency_symbol */ \"\",\n      /* frac_digits */ CHAR_MAX,\n      /* p_cs_precedes */ CHAR_MAX,\n      /* p_sign_posn */ CHAR_MAX,\n      /* p_sep_by_space */ CHAR_MAX,\n      /* n_cs_precedes */ CHAR_MAX,\n      /* n_sign_posn */ CHAR_MAX,\n      /* n_sep_by_space */ CHAR_MAX,\n      /* int_curr_symbol */ \"\",\n      /* int_frac_digits */ CHAR_MAX,\n      /* int_p_cs_precedes */ CHAR_MAX,\n      /* int_p_sign_posn */ CHAR_MAX,\n      /* int_p_sep_by_space */ CHAR_MAX,\n      /* int_n_cs_precedes */ CHAR_MAX,\n      /* int_n_sign_posn */ CHAR_MAX,\n      /* int_n_sep_by_space */ CHAR_MAX\n    };\n\n  return &result;\n}",
        "lines": 33,
        "depth": 7,
        "decorators": [
          "struct lconv",
          "struct",
          "lconv",
          "*\nlocaleconv (void)",
          "*"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/lseek.c": {
    "rpl_lseek": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "off_t\nrpl_lseek (int fd, off_t offset, int whence)\n{\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  /* mingw lseek mistakenly succeeds on pipes, sockets, and terminals.  */\n  HANDLE h = (HANDLE) _get_osfhandle (fd);\n  if (h == INVALID_HANDLE_VALUE)\n    {\n      errno = EBADF;\n      return -1;\n    }\n  if (GetFileType (h) != FILE_TYPE_DISK)\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#else\n  /* BeOS lseek mistakenly succeeds on pipes...  */\n  struct stat statbuf;\n  if (fstat (fd, &statbuf) < 0)\n    return -1;\n  if (!S_ISREG (statbuf.st_mode))\n    {\n      errno = ESPIPE;\n      return -1;\n    }\n#endif\n#if _GL_WINDOWS_64_BIT_OFF_T\n  return _lseeki64 (fd, offset, whence);\n#else\n  return lseek (fd, offset, whence);\n#endif\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "off_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/lstat.c": {
    "orig_lstat": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static int\norig_lstat (const char *filename, struct stat *buf)\n{\n  return lstat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_lstat": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\nrpl_lstat (const char *file, struct stat *sbuf)\n{\n  size_t len;\n  int lstat_result = orig_lstat (file, sbuf);\n\n  if (lstat_result != 0)\n    return lstat_result;\n\n  /* This replacement file can blindly check against '/' rather than\n     using the ISSLASH macro, because all platforms with '\\\\' either\n     lack symlinks (mingw) or have working lstat (cygwin) and thus do\n     not compile this file.  0 len should have already been filtered\n     out above, with a failure return of ENOENT.  */\n  len = strlen (file);\n  if (file[len - 1] != '/' || S_ISDIR (sbuf->st_mode))\n    return 0;\n\n  /* At this point, a trailing slash is only permitted on\n     symlink-to-dir; but it should have found information on the\n     directory, not the symlink.  Call stat() to get info about the\n     link's referent.  Our replacement stat guarantees valid results,\n     even if the symlink is not pointing to a directory.  */\n  if (!S_ISLNK (sbuf->st_mode))\n    {\n      errno = ENOTDIR;\n      return -1;\n    }\n  return stat (file, sbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/malloc.c": {
    "rpl_malloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void *\nrpl_malloc (size_t n)\n{\n  void *result;\n\n#if NEED_MALLOC_GNU\n  if (n == 0)\n    n = 1;\n#endif\n\n  result = malloc (n);\n\n#if !HAVE_MALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 19,
      "depth": 7,
      "decorators": [
        "void",
        "*\nrpl_malloc (size_t n)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/malloca.c": {
    "mmalloca": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void *\nmmalloca (size_t n)\n{\n#if HAVE_ALLOCA\n  /* Allocate one more word, that serves as an indicator for malloc()ed\n     memory, so that freea() of an alloca() result is fast.  */\n  size_t nplus = n + HEADER_SIZE;\n\n  if (nplus >= n)\n    {\n      void *p = malloc (nplus);\n\n      if (p != NULL)\n        {\n          size_t slot;\n          union header *h = p;\n\n          p = h + 1;\n\n          /* Put a magic number into the indicator word.  */\n          h->magic.word = MAGIC_NUMBER;\n\n          /* Enter p into the hash table.  */\n          slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          h->next = mmalloca_results[slot];\n          mmalloca_results[slot] = p;\n\n          return p;\n        }\n    }\n  /* Out of memory.  */\n  return NULL;\n#else\n# if !MALLOC_0_IS_NONNULL\n  if (n == 0)\n    n = 1;\n# endif\n  return malloc (n);\n#endif\n}",
      "lines": 40,
      "depth": 13,
      "decorators": [
        "void",
        "*\nmmalloca (size_t n)",
        "*"
      ]
    },
    "freea": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\nfreea (void *p)\n{\n  /* mmalloca() may have returned NULL.  */\n  if (p != NULL)\n    {\n      /* Attempt to quickly distinguish the mmalloca() result - which has\n         a magic indicator word - and the alloca() result - which has an\n         uninitialized indicator word.  It is for this test that sa_increment\n         additional bytes are allocated in the alloca() case.  */\n      if (((int *) p)[-1] == MAGIC_NUMBER)\n        {\n          /* Looks like a mmalloca() result.  To see whether it really is one,\n             perform a lookup in the hash table.  */\n          size_t slot = (uintptr_t) p % HASH_TABLE_SIZE;\n          void **chain = &mmalloca_results[slot];\n          for (; *chain != NULL;)\n            {\n              union header *h = p;\n              if (*chain == p)\n                {\n                  /* Found it.  Remove it from the hash table and free it.  */\n                  union header *p_begin = h - 1;\n                  *chain = p_begin->next;\n                  free (p_begin);\n                  return;\n                }\n              h = *chain;\n              chain = &h[-1].next;\n            }\n        }\n      /* At this point, we know it was not a mmalloca() result.  */\n    }\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/malloca.h": {},
  "recutils/recutils-1.7/lib/math.c": {},
  "recutils/recutils-1.7/lib/math.in.h": {
    "float": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "_GL_MATH_INLINE float\n_NaN ()\n{\n  static float zero = 0.0f;\n  return zero / zero;\n}",
      "lines": 6,
      "depth": 5,
      "decorators": [
        "_GL_MATH_INLINE"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mbrlen.c": {
    "mbrlen": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "size_t\nmbrlen (const char *s, size_t n, mbstate_t *ps)\n{\n  if (ps == NULL)\n    ps = &internal_state;\n  return mbrtowc (NULL, s, n, ps);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mbrtowc.c": {
    "mbrtowc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "size_t\nmbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n  char *pstate = (char *)ps;\n\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t)(-2);\n\n  /* Here n > 0.  */\n\n  if (pstate == NULL)\n    pstate = internal_state;\n\n  {\n    size_t nstate = pstate[0];\n    char buf[4];\n    const char *p;\n    size_t m;\n\n    switch (nstate)\n      {\n      case 0:\n        p = s;\n        m = n;\n        break;\n      case 3:\n        buf[2] = pstate[3];\n        /*FALLTHROUGH*/\n      case 2:\n        buf[1] = pstate[2];\n        /*FALLTHROUGH*/\n      case 1:\n        buf[0] = pstate[1];\n        p = buf;\n        m = nstate;\n        buf[m++] = s[0];\n        if (n >= 2 && m < 4)\n          {\n            buf[m++] = s[1];\n            if (n >= 3 && m < 4)\n              buf[m++] = s[2];\n          }\n        break;\n      default:\n        errno = EINVAL;\n        return (size_t)(-1);\n      }\n\n    /* Here m > 0.  */\n\n# if __GLIBC__ || defined __UCLIBC__\n    /* Work around bug <http://sourceware.org/bugzilla/show_bug.cgi?id=9674> */\n    mbtowc (NULL, NULL, 0);\n# endif\n    {\n      int res = mbtowc (pwc, p, m);\n\n      if (res >= 0)\n        {\n          if (pwc != NULL && ((*pwc == 0) != (res == 0)))\n            abort ();\n          if (nstate >= (res > 0 ? res : 1))\n            abort ();\n          res -= nstate;\n          pstate[0] = 0;\n          return res;\n        }\n\n      /* mbtowc does not distinguish between invalid and incomplete multibyte\n         sequences.  But mbrtowc needs to make this distinction.\n         There are two possible approaches:\n           - Use iconv() and its return value.\n           - Use built-in knowledge about the possible encodings.\n         Given the low quality of implementation of iconv() on the systems that\n         lack mbrtowc(), we use the second approach.\n         The possible encodings are:\n           - 8-bit encodings,\n           - EUC-JP, EUC-KR, GB2312, EUC-TW, BIG5, GB18030, SJIS,\n           - UTF-8.\n         Use specialized code for each.  */\n      if (m >= 4 || m >= MB_CUR_MAX)\n        goto invalid;\n      /* Here MB_CUR_MAX > 1 and 0 < m < 4.  */\n      {\n        const char *encoding = locale_charset ();\n\n        if (STREQ_OPT (encoding, \"UTF-8\", 'U', 'T', 'F', '-', '8', 0, 0, 0, 0))\n          {\n            /* Cf. unistr/u8-mblen.c.  */\n            unsigned char c = (unsigned char) p[0];\n\n            if (c >= 0xc2)\n              {\n                if (c < 0xe0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                  }\n                else if (c < 0xf0)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    if (m == 2)\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xe1 || c2 >= 0xa0)\n                            && (c != 0xed || c2 < 0xa0))\n                          goto incomplete;\n                      }\n                  }\n                else if (c <= 0xf4)\n                  {\n                    if (m == 1)\n                      goto incomplete;\n                    else /* m == 2 || m == 3 */\n                      {\n                        unsigned char c2 = (unsigned char) p[1];\n\n                        if ((c2 ^ 0x80) < 0x40\n                            && (c >= 0xf1 || c2 >= 0x90)\n                            && (c < 0xf4 || (c == 0xf4 && c2 < 0x90)))\n                          {\n                            if (m == 2)\n                              goto incomplete;\n                            else /* m == 3 */\n                              {\n                                unsigned char c3 = (unsigned char) p[2];\n\n                                if ((c3 ^ 0x80) < 0x40)\n                                  goto incomplete;\n                              }\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n\n        /* As a reference for this code, you can use the GNU libiconv\n           implementation.  Look for uses of the RET_TOOFEW macro.  */\n\n        if (STREQ_OPT (encoding,\n                       \"EUC-JP\", 'E', 'U', 'C', '-', 'J', 'P', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e || c == 0x8f)\n                  goto incomplete;\n              }\n            if (m == 2)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8f)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0xa1 && c2 < 0xff)\n                      goto incomplete;\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-KR\", 'E', 'U', 'C', '-', 'K', 'R', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"GB2312\", 'G', 'B', '2', '3', '1', '2', 0, 0, 0)\n            || STREQ_OPT (encoding,\n                          \"BIG5\", 'B', 'I', 'G', '5', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0xa1 && c < 0xff)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"EUC-TW\", 'E', 'U', 'C', '-', 'T', 'W', 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0xa1 && c < 0xff) || c == 0x8e)\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c == 0x8e)\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding,\n                       \"GB18030\", 'G', 'B', '1', '8', '0', '3', '0', 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x90 && c <= 0xe3) || (c >= 0xf8 && c <= 0xfe))\n                  goto incomplete;\n              }\n            else /* m == 2 || m == 3 */\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if (c >= 0x90 && c <= 0xe3)\n                  {\n                    unsigned char c2 = (unsigned char) p[1];\n\n                    if (c2 >= 0x30 && c2 <= 0x39)\n                      {\n                        if (m == 2)\n                          goto incomplete;\n                        else /* m == 3 */\n                          {\n                            unsigned char c3 = (unsigned char) p[2];\n\n                            if (c3 >= 0x81 && c3 <= 0xfe)\n                              goto incomplete;\n                          }\n                      }\n                  }\n              }\n            goto invalid;\n          }\n        if (STREQ_OPT (encoding, \"SJIS\", 'S', 'J', 'I', 'S', 0, 0, 0, 0, 0))\n          {\n            if (m == 1)\n              {\n                unsigned char c = (unsigned char) p[0];\n\n                if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)\n                    || (c >= 0xf0 && c <= 0xf9))\n                  goto incomplete;\n              }\n            goto invalid;\n          }\n\n        /* An unknown multibyte encoding.  */\n        goto incomplete;\n      }\n\n     incomplete:\n      {\n        size_t k = nstate;\n        /* Here 0 <= k < m < 4.  */\n        pstate[++k] = s[0];\n        if (k < m)\n          {\n            pstate[++k] = s[1];\n            if (k < m)\n              pstate[++k] = s[2];\n          }\n        if (k != m)\n          abort ();\n      }\n      pstate[0] = m;\n      return (size_t)(-2);\n\n     invalid:\n      errno = EILSEQ;\n      /* The conversion state is undefined, says POSIX.  */\n      return (size_t)(-1);\n    }\n  }\n}",
      "lines": 284,
      "depth": 25,
      "decorators": [
        "size_t"
      ]
    },
    "rpl_mbrtowc": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "size_t\nrpl_mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps)\n{\n# if MBRTOWC_NULL_ARG2_BUG || MBRTOWC_RETVAL_BUG\n  if (s == NULL)\n    {\n      pwc = NULL;\n      s = \"\";\n      n = 1;\n    }\n# endif\n\n# if MBRTOWC_RETVAL_BUG\n  {\n    static mbstate_t internal_state;\n\n    /* Override mbrtowc's internal state.  We cannot call mbsinit() on the\n       hidden internal state, but we can call it on our variable.  */\n    if (ps == NULL)\n      ps = &internal_state;\n\n    if (!mbsinit (ps))\n      {\n        /* Parse the rest of the multibyte character byte for byte.  */\n        size_t count = 0;\n        for (; n > 0; s++, n--)\n          {\n            wchar_t wc;\n            size_t ret = mbrtowc (&wc, s, 1, ps);\n\n            if (ret == (size_t)(-1))\n              return (size_t)(-1);\n            count++;\n            if (ret != (size_t)(-2))\n              {\n                /* The multibyte character has been completed.  */\n                if (pwc != NULL)\n                  *pwc = wc;\n                return (wc == 0 ? 0 : count);\n              }\n          }\n        return (size_t)(-2);\n      }\n  }\n# endif\n\n# if MBRTOWC_NUL_RETVAL_BUG\n  {\n    wchar_t wc;\n    size_t ret = mbrtowc (&wc, s, n, ps);\n\n    if (ret != (size_t)(-1) && ret != (size_t)(-2))\n      {\n        if (pwc != NULL)\n          *pwc = wc;\n        if (wc == 0)\n          ret = 0;\n      }\n    return ret;\n  }\n# else\n  {\n#   if MBRTOWC_NULL_ARG1_BUG\n    wchar_t dummy;\n\n    if (pwc == NULL)\n      pwc = &dummy;\n#   endif\n\n    return mbrtowc (pwc, s, n, ps);\n  }\n# endif\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mbsinit.c": {
    "mbsinit": [
      {
        "start_point": [
          28,
          0
        ],
        "end_point": [
          32,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  return ps == NULL || *ps == 0;\n}",
        "lines": 5,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          52,
          0
        ],
        "end_point": [
          58,
          1
        ],
        "content": "int\nmbsinit (const mbstate_t *ps)\n{\n  const char *pstate = (const char *)ps;\n\n  return pstate == NULL || pstate[0] == 0;\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/mbtowc-impl.h": {
    "mbtowc": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "int\nmbtowc (wchar_t *pwc, const char *s, size_t n)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      wchar_t wc;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = mbrtowc (&wc, s, n, &state);\n      if (result == (size_t)-1 || result == (size_t)-2)\n        {\n          errno = EILSEQ;\n          return -1;\n        }\n      if (pwc != NULL)\n        *pwc = wc;\n      return (wc == 0 ? 0 : result);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mbtowc.c": {},
  "recutils/recutils-1.7/lib/memchr.c": {
    "__memchr": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "void *\n__memchr (void const *s, int c_in, size_t n)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned reg_char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;\n       --n, ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will test a\n     longword at a time.  The tricky part is testing if *any of the four*\n     bytes in the longword in question are equal to c.  We first use an xor\n     with repeated_c.  This reduces the task to testing whether *any of the\n     four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     So, the test whether any byte in longword1 is zero is equivalent to\n     testing whether tmp is nonzero.  */\n\n  while (n >= sizeof (longword))\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n      n -= sizeof (longword);\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that either n < sizeof (longword), or one of the\n     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian\n     machines, we could determine the first such byte without any further\n     memory accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.  Choose code\n     that works in both cases.  */\n\n  for (; n > 0; --n, ++char_ptr)\n    {\n      if (*char_ptr == c)\n        return (void *) char_ptr;\n    }\n\n  return NULL;\n}",
      "lines": 112,
      "depth": 14,
      "decorators": [
        "void",
        "*\n__memchr (void const *s, int c_in, size_t n)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/minmax.h": {},
  "recutils/recutils-1.7/lib/mkostemp.c": {
    "mkostemp": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\nmkostemp (char *xtemplate, int flags)\n{\n  return __gen_tempname (xtemplate, 0, flags, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mkstemp.c": {
    "mkstemp": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nmkstemp (char *xtemplate)\n{\n  return __gen_tempname (xtemplate, 0, 0, __GT_FILE);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/mktime-internal.h": {},
  "recutils/recutils-1.7/lib/mktime.c": {
    "leapyear": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\nleapyear (long_int year)\n{\n  /* Don't add YEAR to TM_YEAR_BASE, as that might overflow.\n     Also, work even if YEAR is negative.  */\n  return\n    ((year & 3) == 0\n     && (year % 100 != 0\n\t || ((year / 100) & 3) == (- (TM_YEAR_BASE / 100) & 3)));\n}",
      "lines": 10,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isdst_differ": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nisdst_differ (int a, int b)\n{\n  return (!a != !b) && (0 <= a) && (0 <= b);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ydhms_diff": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "static time_t\nydhms_diff (long_int year1, long_int yday1, int hour1, int min1, int sec1,\n\t    int year0, int yday0, int hour0, int min0, int sec0)\n{\n  verify (C99_integer_division, -1 / 2 == 0);\n\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid integer overflow here.  */\n  int a4 = SHR (year1, 2) + SHR (TM_YEAR_BASE, 2) - ! (year1 & 3);\n  int b4 = SHR (year0, 2) + SHR (TM_YEAR_BASE, 2) - ! (year0 & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n\n  /* Compute the desired time in time_t precision.  Overflow might\n     occur here.  */\n  time_t tyear1 = year1;\n  time_t years = tyear1 - year0;\n  time_t days = 365 * years + yday1 - yday0 + intervening_leap_days;\n  time_t hours = 24 * days + hour1 - hour0;\n  time_t minutes = 60 * hours + min1 - min0;\n  time_t seconds = 60 * minutes + sec1 - sec0;\n  return seconds;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_avg": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static time_t\ntime_t_avg (time_t a, time_t b)\n{\n  return SHR (a, 1) + SHR (b, 1) + (a & b & 1);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "time_t_add_ok": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "static int\ntime_t_add_ok (time_t a, time_t b)\n{\n  if (! TYPE_SIGNED (time_t))\n    {\n      time_t sum = a + b;\n      return (sum < a) == (TIME_T_MIDPOINT <= b);\n    }\n  else if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      time_t avg = time_t_avg (a, b);\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_t_int_add_ok": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static int\ntime_t_int_add_ok (time_t a, int b)\n{\n  verify (int_no_wider_than_time_t, INT_MAX <= TIME_T_MAX);\n  if (WRAPV)\n    {\n      time_t sum = a + b;\n      return (sum < a) == (b < 0);\n    }\n  else\n    {\n      int a_odd = a & 1;\n      time_t avg = SHR (a, 1) + (SHR (b, 1) + (a_odd & b));\n      return TIME_T_MIN / 2 <= avg && avg <= TIME_T_MAX / 2;\n    }\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "guess_time_tm": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static time_t\nguess_time_tm (long_int year, long_int yday, int hour, int min, int sec,\n\t       const time_t *t, const struct tm *tp)\n{\n  if (tp)\n    {\n      time_t d = ydhms_diff (year, yday, hour, min, sec,\n\t\t\t     tp->tm_year, tp->tm_yday,\n\t\t\t     tp->tm_hour, tp->tm_min, tp->tm_sec);\n      if (time_t_add_ok (*t, d))\n\treturn *t + d;\n    }\n\n  /* Overflow occurred one way or another.  Return the nearest result\n     that is actually in range, except don't report a zero difference\n     if the actual difference is nonzero, as that would cause a false\n     match; and don't oscillate between two values, as that would\n     confuse the spring-forward gap detector.  */\n  return (*t < TIME_T_MIDPOINT\n\t  ? (*t <= TIME_T_MIN + 1 ? *t + 1 : TIME_T_MIN)\n\t  : (TIME_T_MAX - 1 <= *t ? *t - 1 : TIME_T_MAX));\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "time_t"
      ]
    },
    "ranged_convert": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static struct tm *\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)\n{\n  struct tm *r = convert (t, tp);\n\n  if (!r && *t)\n    {\n      time_t bad = *t;\n      time_t ok = 0;\n\n      /* BAD is a known unconvertible time_t, and OK is a known good one.\n\t Use binary search to narrow the range between BAD and OK until\n\t they differ by 1.  */\n      while (bad != ok + (bad < 0 ? -1 : 1))\n\t{\n\t  time_t mid = *t = time_t_avg (ok, bad);\n\t  r = convert (t, tp);\n\t  if (r)\n\t    ok = mid;\n\t  else\n\t    bad = mid;\n\t}\n\n      if (!r && ok)\n\t{\n\t  /* The last conversion attempt failed;\n\t     revert to the most recent successful attempt.  */\n\t  *t = ok;\n\t  r = convert (t, tp);\n\t}\n    }\n\n  return r;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\nranged_convert (struct tm *(*convert) (const time_t *, struct tm *),\n\t\ttime_t *t, struct tm *tp)",
        "*"
      ]
    },
    "__mktime_internal": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "time_t\n__mktime_internal (struct tm *tp,\n\t\t   struct tm *(*convert) (const time_t *, struct tm *),\n\t\t   time_t *offset)\n{\n  time_t t, gt, t0, t1, t2;\n  struct tm tm;\n\n  /* The maximum number of probes (calls to CONVERT) should be enough\n     to handle any combinations of time zone rule changes, solar time,\n     leap seconds, and oscillations around a spring-forward gap.\n     POSIX.1 prohibits leap seconds, but some hosts have them anyway.  */\n  int remaining_probes = 6;\n\n  /* Time requested.  Copy it in case CONVERT modifies *TP; this can\n     occur if TP is localtime's returned value and CONVERT is localtime.  */\n  int sec = tp->tm_sec;\n  int min = tp->tm_min;\n  int hour = tp->tm_hour;\n  int mday = tp->tm_mday;\n  int mon = tp->tm_mon;\n  int year_requested = tp->tm_year;\n  int isdst = tp->tm_isdst;\n\n  /* 1 if the previous probe was DST.  */\n  int dst2;\n\n  /* Ensure that mon is in range, and set year accordingly.  */\n  int mon_remainder = mon % 12;\n  int negative_mon_remainder = mon_remainder < 0;\n  int mon_years = mon / 12 - negative_mon_remainder;\n  long_int lyear_requested = year_requested;\n  long_int year = lyear_requested + mon_years;\n\n  /* The other values need not be in range:\n     the remaining code handles minor overflows correctly,\n     assuming int and time_t arithmetic wraps around.\n     Major overflows are caught at the end.  */\n\n  /* Calculate day of year from year, month, and day of month.\n     The result need not be in range.  */\n  int mon_yday = ((__mon_yday[leapyear (year)]\n\t\t   [mon_remainder + 12 * negative_mon_remainder])\n\t\t  - 1);\n  long_int lmday = mday;\n  long_int yday = mon_yday + lmday;\n\n  time_t guessed_offset = *offset;\n\n  int sec_requested = sec;\n\n  if (LEAP_SECONDS_POSSIBLE)\n    {\n      /* Handle out-of-range seconds specially,\n\t since ydhms_tm_diff assumes every minute has 60 seconds.  */\n      if (sec < 0)\n\tsec = 0;\n      if (59 < sec)\n\tsec = 59;\n    }\n\n  /* Invert CONVERT by probing.  First assume the same offset as last\n     time.  */\n\n  t0 = ydhms_diff (year, yday, hour, min, sec,\n\t\t   EPOCH_YEAR - TM_YEAR_BASE, 0, 0, 0, - guessed_offset);\n\n  if (TIME_T_MAX / INT_MAX / 366 / 24 / 60 / 60 < 3)\n    {\n      /* time_t isn't large enough to rule out overflows, so check\n\t for major overflows.  A gross check suffices, since if t0\n\t has overflowed, it is off by a multiple of TIME_T_MAX -\n\t TIME_T_MIN + 1.  So ignore any component of the difference\n\t that is bounded by a small value.  */\n\n      /* Approximate log base 2 of the number of time units per\n\t biennium.  A biennium is 2 years; use this unit instead of\n\t years to avoid integer overflow.  For example, 2 average\n\t Gregorian years are 2 * 365.2425 * 24 * 60 * 60 seconds,\n\t which is 63113904 seconds, and rint (log2 (63113904)) is\n\t 26.  */\n      int ALOG2_SECONDS_PER_BIENNIUM = 26;\n      int ALOG2_MINUTES_PER_BIENNIUM = 20;\n      int ALOG2_HOURS_PER_BIENNIUM = 14;\n      int ALOG2_DAYS_PER_BIENNIUM = 10;\n      int LOG2_YEARS_PER_BIENNIUM = 1;\n\n      int approx_requested_biennia =\n\t(SHR (year_requested, LOG2_YEARS_PER_BIENNIUM)\n\t - SHR (EPOCH_YEAR - TM_YEAR_BASE, LOG2_YEARS_PER_BIENNIUM)\n\t + SHR (mday, ALOG2_DAYS_PER_BIENNIUM)\n\t + SHR (hour, ALOG2_HOURS_PER_BIENNIUM)\n\t + SHR (min, ALOG2_MINUTES_PER_BIENNIUM)\n\t + (LEAP_SECONDS_POSSIBLE\n\t    ? 0\n\t    : SHR (sec, ALOG2_SECONDS_PER_BIENNIUM)));\n\n      int approx_biennia = SHR (t0, ALOG2_SECONDS_PER_BIENNIUM);\n      int diff = approx_biennia - approx_requested_biennia;\n      int approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\n      /* IRIX 4.0.5 cc miscalculates TIME_T_MIN / 3: it erroneously\n\t gives a positive value of 715827882.  Setting a variable\n\t first then doing math on it seems to work.\n\t (ghazi@caip.rutgers.edu) */\n      time_t time_t_max = TIME_T_MAX;\n      time_t time_t_min = TIME_T_MIN;\n      time_t overflow_threshold =\n\t(time_t_max / 3 - time_t_min / 3) >> ALOG2_SECONDS_PER_BIENNIUM;\n\n      if (overflow_threshold < approx_abs_diff)\n\t{\n\t  /* Overflow occurred.  Try repairing it; this might work if\n\t     the time zone offset is enough to undo the overflow.  */\n\t  time_t repaired_t0 = -1 - t0;\n\t  approx_biennia = SHR (repaired_t0, ALOG2_SECONDS_PER_BIENNIUM);\n\t  diff = approx_biennia - approx_requested_biennia;\n\t  approx_abs_diff = diff < 0 ? -1 - diff : diff;\n\t  if (overflow_threshold < approx_abs_diff)\n\t    return -1;\n\t  guessed_offset += repaired_t0 - t0;\n\t  t0 = repaired_t0;\n\t}\n    }\n\n  /* Repeatedly use the error to improve the guess.  */\n\n  for (t = t1 = t2 = t0, dst2 = 0;\n       (gt = guess_time_tm (year, yday, hour, min, sec, &t,\n\t\t\t    ranged_convert (convert, &t, &tm)),\n\tt != gt);\n       t1 = t2, t2 = t, t = gt, dst2 = tm.tm_isdst != 0)\n    if (t == t1 && t != t2\n\t&& (tm.tm_isdst < 0\n\t    || (isdst < 0\n\t\t? dst2 <= (tm.tm_isdst != 0)\n\t\t: (isdst != 0) != (tm.tm_isdst != 0))))\n      /* We can't possibly find a match, as we are oscillating\n\t between two values.  The requested time probably falls\n\t within a spring-forward gap of size GT - T.  Follow the common\n\t practice in this case, which is to return a time that is GT - T\n\t away from the requested time, preferring a time whose\n\t tm_isdst differs from the requested value.  (If no tm_isdst\n\t was requested and only one of the two values has a nonzero\n\t tm_isdst, prefer that value.)  In practice, this is more\n\t useful than returning -1.  */\n      goto offset_found;\n    else if (--remaining_probes == 0)\n      return -1;\n\n  /* We have a match.  Check whether tm.tm_isdst has the requested\n     value, if any.  */\n  if (isdst_differ (isdst, tm.tm_isdst))\n    {\n      /* tm.tm_isdst has the wrong value.  Look for a neighboring\n\t time with the right value, and use its UTC offset.\n\n\t Heuristic: probe the adjacent timestamps in both directions,\n\t looking for the desired isdst.  This should work for all real\n\t time zone histories in the tz database.  */\n\n      /* Distance between probes when looking for a DST boundary.  In\n\t tzdata2003a, the shortest period of DST is 601200 seconds\n\t (e.g., America/Recife starting 2000-10-08 01:00), and the\n\t shortest period of non-DST surrounded by DST is 694800\n\t seconds (Africa/Tunis starting 1943-04-17 01:00).  Use the\n\t minimum of these two values, so we don't miss these short\n\t periods when probing.  */\n      int stride = 601200;\n\n      /* The longest period of DST in tzdata2003a is 536454000 seconds\n\t (e.g., America/Jujuy starting 1946-10-01 01:00).  The longest\n\t period of non-DST is much longer, but it makes no real sense\n\t to search for more than a year of non-DST, so use the DST\n\t max.  */\n      int duration_max = 536454000;\n\n      /* Search in both directions, so the maximum distance is half\n\t the duration; add the stride to avoid off-by-1 problems.  */\n      int delta_bound = duration_max / 2 + stride;\n\n      int delta, direction;\n\n      for (delta = stride; delta < delta_bound; delta += stride)\n\tfor (direction = -1; direction <= 1; direction += 2)\n\t  if (time_t_int_add_ok (t, delta * direction))\n\t    {\n\t      time_t ot = t + delta * direction;\n\t      struct tm otm;\n\t      ranged_convert (convert, &ot, &otm);\n\t      if (! isdst_differ (isdst, otm.tm_isdst))\n\t\t{\n\t\t  /* We found the desired tm_isdst.\n\t\t     Extrapolate back to the desired time.  */\n\t\t  t = guess_time_tm (year, yday, hour, min, sec, &ot, &otm);\n\t\t  ranged_convert (convert, &t, &tm);\n\t\t  goto offset_found;\n\t\t}\n\t    }\n    }\n\n offset_found:\n  *offset = guessed_offset + t - t0;\n\n  if (LEAP_SECONDS_POSSIBLE && sec_requested != tm.tm_sec)\n    {\n      /* Adjust time to reflect the tm_sec requested, not the normalized value.\n\t Also, repair any damage from a false match due to a leap second.  */\n      int sec_adjustment = (sec == 0 && tm.tm_sec == 60) - sec;\n      if (! time_t_int_add_ok (t, sec_requested))\n\treturn -1;\n      t1 = t + sec_requested;\n      if (! time_t_int_add_ok (t1, sec_adjustment))\n\treturn -1;\n      t2 = t1 + sec_adjustment;\n      if (! convert (&t2, &tm))\n\treturn -1;\n      t = t2;\n    }\n\n  *tp = tm;\n  return t;\n}",
      "lines": 223,
      "depth": 16,
      "decorators": [
        "time_t"
      ]
    },
    "mktime": {
      "start_point": [
        580,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "time_t\nmktime (struct tm *tp)\n{\n#ifdef _LIBC\n  /* POSIX.1 8.1.1 requires that whenever mktime() is called, the\n     time zone names contained in the external variable 'tzname' shall\n     be set as if the tzset() function had been called.  */\n  __tzset ();\n#endif\n\n  return __mktime_internal (tp, __localtime_r, &localtime_offset);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "time_t"
      ]
    },
    "not_equal_tm": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        615,
        1
      ],
      "content": "static int\nnot_equal_tm (const struct tm *a, const struct tm *b)\n{\n  return ((a->tm_sec ^ b->tm_sec)\n\t  | (a->tm_min ^ b->tm_min)\n\t  | (a->tm_hour ^ b->tm_hour)\n\t  | (a->tm_mday ^ b->tm_mday)\n\t  | (a->tm_mon ^ b->tm_mon)\n\t  | (a->tm_year ^ b->tm_year)\n\t  | (a->tm_yday ^ b->tm_yday)\n\t  | isdst_differ (a->tm_isdst, b->tm_isdst));\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_tm": {
      "start_point": [
        617,
        0
      ],
      "end_point": [
        627,
        1
      ],
      "content": "static void\nprint_tm (const struct tm *tp)\n{\n  if (tp)\n    printf (\"%04d-%02d-%02d %02d:%02d:%02d yday %03d wday %d isdst %d\",\n\t    tp->tm_year + TM_YEAR_BASE, tp->tm_mon + 1, tp->tm_mday,\n\t    tp->tm_hour, tp->tm_min, tp->tm_sec,\n\t    tp->tm_yday, tp->tm_wday, tp->tm_isdst);\n  else\n    printf (\"0\");\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_result": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        643,
        1
      ],
      "content": "static int\ncheck_result (time_t tk, struct tm tmk, time_t tl, const struct tm *lt)\n{\n  if (tk != tl || !lt || not_equal_tm (&tmk, lt))\n    {\n      printf (\"mktime (\");\n      print_tm (lt);\n      printf (\")\\nyields (\");\n      print_tm (&tmk);\n      printf (\") == %ld, should be %ld\\n\", (long int) tk, (long int) tl);\n      return 1;\n    }\n\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int status = 0;\n  struct tm tm, tmk, tml;\n  struct tm *lt;\n  time_t tk, tl, tl1;\n  char trailer;\n\n  if ((argc == 3 || argc == 4)\n      && (sscanf (argv[1], \"%d-%d-%d%c\",\n\t\t  &tm.tm_year, &tm.tm_mon, &tm.tm_mday, &trailer)\n\t  == 3)\n      && (sscanf (argv[2], \"%d:%d:%d%c\",\n\t\t  &tm.tm_hour, &tm.tm_min, &tm.tm_sec, &trailer)\n\t  == 3))\n    {\n      tm.tm_year -= TM_YEAR_BASE;\n      tm.tm_mon--;\n      tm.tm_isdst = argc == 3 ? -1 : atoi (argv[3]);\n      tmk = tm;\n      tl = mktime (&tmk);\n      lt = localtime (&tl);\n      if (lt)\n\t{\n\t  tml = *lt;\n\t  lt = &tml;\n\t}\n      printf (\"mktime returns %ld == \", (long int) tl);\n      print_tm (&tmk);\n      printf (\"\\n\");\n      status = check_result (tl, tmk, tl, lt);\n    }\n  else if (argc == 4 || (argc == 5 && strcmp (argv[4], \"-\") == 0))\n    {\n      time_t from = atol (argv[1]);\n      time_t by = atol (argv[2]);\n      time_t to = atol (argv[3]);\n\n      if (argc == 4)\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = mktime (&tmk);\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n      else\n\tfor (tl = from; by < 0 ? to <= tl : tl <= to; tl = tl1)\n\t  {\n\t    /* Null benchmark.  */\n\t    lt = localtime (&tl);\n\t    if (lt)\n\t      {\n\t\ttmk = tml = *lt;\n\t\ttk = tl;\n\t\tstatus |= check_result (tk, tmk, tl, &tml);\n\t      }\n\t    else\n\t      {\n\t\tprintf (\"localtime (%ld) yields 0\\n\", (long int) tl);\n\t\tstatus = 1;\n\t      }\n\t    tl1 = tl + by;\n\t    if ((tl1 < tl) != (by < 0))\n\t      break;\n\t  }\n    }\n  else\n    printf (\"Usage:\\\n\\t%s YYYY-MM-DD HH:MM:SS [ISDST] # Test given time.\\n\\\n\\t%s FROM BY TO # Test values FROM, FROM+BY, ..., TO.\\n\\\n\\t%s FROM BY TO - # Do not test those values (for benchmark).\\n\",\n\t    argv[0], argv[0], argv[0]);\n\n  return status;\n}",
      "lines": 88,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/msvc-inval.c": {
    "gl_msvc_invalid_parameter_handler": [
      {
        "start_point": [
          30,
          0
        ],
        "end_point": [
          37,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n}",
        "lines": 8,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          47,
          0
        ],
        "end_point": [
          55,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 9,
        "depth": 6,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      },
      {
        "start_point": [
          96,
          0
        ],
        "end_point": [
          110,
          1
        ],
        "content": "static void __cdecl\ngl_msvc_invalid_parameter_handler (const wchar_t *expression,\n                                   const wchar_t *function,\n                                   const wchar_t *file,\n                                   unsigned int line,\n                                   uintptr_t dummy)\n{\n  struct gl_msvc_inval_per_thread *current = gl_msvc_inval_current ();\n  if (current->restart_valid)\n    longjmp (current->restart, 1);\n  else\n    /* An invalid parameter notification from outside the gnulib code.\n       Give the caller a chance to intervene.  */\n    RaiseException (STATUS_GNULIB_INVALID_PARAMETER, 0, 0, NULL);\n}",
        "lines": 15,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void",
          "__cdecl",
          "__cdecl"
        ]
      }
    ],
    "gl_msvc_inval_current": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "struct gl_msvc_inval_per_thread *\ngl_msvc_inval_current (void)\n{\n  if (!tls_initialized)\n    {\n      tls_index = TlsAlloc ();\n      tls_initialized = 1;\n    }\n  if (tls_index == TLS_OUT_OF_INDEXES)\n    /* TlsAlloc had failed.  */\n    return &not_per_thread;\n  else\n    {\n      struct gl_msvc_inval_per_thread *pointer =\n        (struct gl_msvc_inval_per_thread *) TlsGetValue (tls_index);\n      if (pointer == NULL)\n        {\n          /* First call.  Allocate a new 'struct gl_msvc_inval_per_thread'.  */\n          pointer =\n            (struct gl_msvc_inval_per_thread *)\n            malloc (sizeof (struct gl_msvc_inval_per_thread));\n          if (pointer == NULL)\n            /* Could not allocate memory.  Use the global storage.  */\n            pointer = &not_per_thread;\n          TlsSetValue (tls_index, pointer);\n        }\n      return pointer;\n    }\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "struct gl_msvc_inval_per_thread",
        "struct",
        "gl_msvc_inval_per_thread",
        "*\ngl_msvc_inval_current (void)",
        "*"
      ]
    },
    "gl_msvc_inval_ensure_handler": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ngl_msvc_inval_ensure_handler (void)\n{\n  if (gl_msvc_inval_initialized == 0)\n    {\n      _set_invalid_parameter_handler (gl_msvc_invalid_parameter_handler);\n      gl_msvc_inval_initialized = 1;\n    }\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/msvc-inval.h": {},
  "recutils/recutils-1.7/lib/msvc-nothrow.c": {
    "_gl_nothrow_get_osfhandle": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        39,
        5
      ],
      "content": "intptr_t\n_gl_nothrow_get_osfhandle (int fd)\n{\n  intptr_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = _get_osfhandle (fd);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "intptr_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/msvc-nothrow.h": {},
  "recutils/recutils-1.7/lib/nl_langinfo.c": {
    "rpl_nl_langinfo": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "char *\nrpl_nl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n# if GNULIB_defined_CODESET\n    case CODESET:\n      {\n        const char *locale;\n        static char buf[2 + 10 + 1];\n\n        locale = setlocale (LC_CTYPE, NULL);\n        if (locale != NULL && locale[0] != '\\0')\n          {\n            /* If the locale name contains an encoding after the dot, return\n               it.  */\n            const char *dot = strchr (locale, '.');\n\n            if (dot != NULL)\n              {\n                const char *modifier;\n\n                dot++;\n                /* Look for the possible @... trailer and remove it, if any.  */\n                modifier = strchr (dot, '@');\n                if (modifier == NULL)\n                  return dot;\n                if (modifier - dot < sizeof (buf))\n                  {\n                    memcpy (buf, dot, modifier - dot);\n                    buf [modifier - dot] = '\\0';\n                    return buf;\n                  }\n              }\n          }\n        return \"\";\n      }\n# endif\n# if GNULIB_defined_T_FMT_AMPM\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n# endif\n# if GNULIB_defined_ERA\n    case ERA:\n      /* The format is not standardized.  In glibc it is a sequence of strings\n         of the form \"direction:offset:start_date:end_date:era_name:era_format\"\n         with an empty string at the end.  */\n      return \"\";\n    case ERA_D_FMT:\n      /* The %Ex conversion in strftime behaves like %x if the locale does not\n         have an alternative time format.  */\n      item = D_FMT;\n      break;\n    case ERA_D_T_FMT:\n      /* The %Ec conversion in strftime behaves like %c if the locale does not\n         have an alternative time format.  */\n      item = D_T_FMT;\n      break;\n    case ERA_T_FMT:\n      /* The %EX conversion in strftime behaves like %X if the locale does not\n         have an alternative time format.  */\n      item = T_FMT;\n      break;\n    case ALT_DIGITS:\n      /* The format is not standardized.  In glibc it is a sequence of 10\n         strings, appended in memory.  */\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n# endif\n# if GNULIB_defined_YESEXPR || !FUNC_NL_LANGINFO_YESEXPR_WORKS\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n# endif\n    default:\n      break;\n    }\n  return nl_langinfo (item);\n}",
      "lines": 79,
      "depth": 18,
      "decorators": [
        "char",
        "*\nrpl_nl_langinfo (nl_item item)",
        "*"
      ]
    },
    "nl_langinfo": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "char *\nnl_langinfo (nl_item item)\n{\n  switch (item)\n    {\n    /* nl_langinfo items of the LC_CTYPE category */\n    case CODESET:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n      {\n        static char buf[2 + 10 + 1];\n\n        /* The Windows API has a function returning the locale's codepage as\n           a number.  */\n        sprintf (buf, \"CP%u\", GetACP ());\n        return buf;\n      }\n# elif defined __BEOS__\n      return \"UTF-8\";\n# else\n      return \"ISO-8859-1\";\n# endif\n    /* nl_langinfo items of the LC_NUMERIC category */\n    case RADIXCHAR:\n      return localeconv () ->decimal_point;\n    case THOUSEP:\n      return localeconv () ->thousands_sep;\n    /* nl_langinfo items of the LC_TIME category.\n       TODO: Really use the locale.  */\n    case D_T_FMT:\n    case ERA_D_T_FMT:\n      return \"%a %b %e %H:%M:%S %Y\";\n    case D_FMT:\n    case ERA_D_FMT:\n      return \"%m/%d/%y\";\n    case T_FMT:\n    case ERA_T_FMT:\n      return \"%H:%M:%S\";\n    case T_FMT_AMPM:\n      return \"%I:%M:%S %p\";\n    case AM_STR:\n      return \"AM\";\n    case PM_STR:\n      return \"PM\";\n    case DAY_1:\n      return \"Sunday\";\n    case DAY_2:\n      return \"Monday\";\n    case DAY_3:\n      return \"Tuesday\";\n    case DAY_4:\n      return \"Wednesday\";\n    case DAY_5:\n      return \"Thursday\";\n    case DAY_6:\n      return \"Friday\";\n    case DAY_7:\n      return \"Saturday\";\n    case ABDAY_1:\n      return \"Sun\";\n    case ABDAY_2:\n      return \"Mon\";\n    case ABDAY_3:\n      return \"Tue\";\n    case ABDAY_4:\n      return \"Wed\";\n    case ABDAY_5:\n      return \"Thu\";\n    case ABDAY_6:\n      return \"Fri\";\n    case ABDAY_7:\n      return \"Sat\";\n    case MON_1:\n      return \"January\";\n    case MON_2:\n      return \"February\";\n    case MON_3:\n      return \"March\";\n    case MON_4:\n      return \"April\";\n    case MON_5:\n      return \"May\";\n    case MON_6:\n      return \"June\";\n    case MON_7:\n      return \"July\";\n    case MON_8:\n      return \"August\";\n    case MON_9:\n      return \"September\";\n    case MON_10:\n      return \"October\";\n    case MON_11:\n      return \"November\";\n    case MON_12:\n      return \"December\";\n    case ABMON_1:\n      return \"Jan\";\n    case ABMON_2:\n      return \"Feb\";\n    case ABMON_3:\n      return \"Mar\";\n    case ABMON_4:\n      return \"Apr\";\n    case ABMON_5:\n      return \"May\";\n    case ABMON_6:\n      return \"Jun\";\n    case ABMON_7:\n      return \"Jul\";\n    case ABMON_8:\n      return \"Aug\";\n    case ABMON_9:\n      return \"Sep\";\n    case ABMON_10:\n      return \"Oct\";\n    case ABMON_11:\n      return \"Nov\";\n    case ABMON_12:\n      return \"Dec\";\n    case ERA:\n      return \"\";\n    case ALT_DIGITS:\n      return \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\";\n    /* nl_langinfo items of the LC_MONETARY category\n       TODO: Really use the locale. */\n    case CRNCYSTR:\n      return \"-\";\n    /* nl_langinfo items of the LC_MESSAGES category\n       TODO: Really use the locale. */\n    case YESEXPR:\n      return \"^[yY]\";\n    case NOEXPR:\n      return \"^[nN]\";\n    default:\n      return \"\";\n    }\n}",
      "lines": 137,
      "depth": 12,
      "decorators": [
        "char",
        "*\nnl_langinfo (nl_item item)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/obstack.c": {
    "_obstack_begin": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\n_obstack_begin (struct obstack *h,\n                int size, int alignment,\n                void *(*chunkfun) (long),\n                void (*freefun) (void *))\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->use_extra_arg = 0;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 46,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_begin_1": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "int\n_obstack_begin_1 (struct obstack *h, int size, int alignment,\n                  void *(*chunkfun) (void *, long),\n                  void (*freefun) (void *, void *),\n                  void *arg)\n{\n  register struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n         Use the values for range checking, because if range checking is off,\n         the extra bytes won't be missed terribly, but if range checking is on\n         and we used a larger request, a whole extra 4096 bytes would be\n         allocated.\n\n         These number are irrelevant to the new GNU malloc.  I suspect it is\n         less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n                    + 4 + DEFAULT_ROUNDING - 1)\n                   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n                                               alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "_obstack_newchunk": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "void\n_obstack_newchunk (struct obstack *h, int length)\n{\n  register struct _obstack_chunk *old_chunk = h->chunk;\n  register struct _obstack_chunk *new_chunk;\n  register long new_size;\n  register long obj_size = h->next_free - h->object_base;\n  register long i;\n  long already;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  new_chunk = CALL_CHUNKFUN (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.\n     Word at a time is fast and is safe if the object\n     is sufficiently aligned.  */\n  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n    {\n      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n           i >= 0; i--)\n        ((COPYING_UNIT *)object_base)[i]\n          = ((COPYING_UNIT *)h->object_base)[i];\n      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n         but that can cross a page boundary on a machine\n         which does not do strict alignment for COPYING_UNITS.  */\n      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n    }\n  else\n    already = 0;\n  /* Copy remaining bytes one by one.  */\n  for (i = already; i < obj_size; i++)\n    object_base[i] = h->object_base[i];\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (! h->maybe_empty_object\n      && (h->object_base\n          == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n                          h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      CALL_FREEFUN (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "_obstack_allocated_p": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "int\n_obstack_allocated_p (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__obstack_free": {
      "start_point": [
        340,
        0
      ],
      "end_point": [
        368,
        1
      ],
      "content": "void\n__obstack_free (struct obstack *h, void *obj)\n{\n  register struct _obstack_chunk *lp;   /* below addr of any objects in this chunk */\n  register struct _obstack_chunk *plp;  /* point to previous chunk if any */\n\n  lp = h->chunk;\n  /* We use >= because there cannot be an object at the beginning of a chunk.\n     But there can be an empty object at that address\n     at the end of another chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      CALL_FREEFUN (h, lp);\n      lp = plp;\n      /* If we switch chunks, we can't tell whether the new current\n         chunk contains an empty object, so assume that it may.  */\n      h->maybe_empty_object = 1;\n    }\n  if (lp)\n    {\n      h->object_base = h->next_free = (char *) (obj);\n      h->chunk_limit = lp->limit;\n      h->chunk = lp;\n    }\n  else if (obj != 0)\n    /* obj is not in any of the chunks! */\n    abort ();\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "_obstack_memory_used": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\n_obstack_memory_used (struct obstack *h)\n{\n  register struct _obstack_chunk* lp;\n  register int nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "print_and_abort": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static _Noreturn void\nprint_and_abort (void)\n{\n  /* Don't change any of these strings.  Yes, it would be possible to add\n     the newline to the string and use fputs or so.  But this must not\n     happen because the \"memory exhausted\" message appears in other places\n     like this and the translation should be reused instead of creating\n     a very similar string which requires a separate translation.  */\n# ifdef _LIBC\n  (void) __fxprintf (NULL, \"%s\\n\", _(\"memory exhausted\"));\n# else\n  fprintf (stderr, \"%s\\n\", _(\"memory exhausted\"));\n# endif\n  exit (obstack_exit_failure);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "_Noreturn",
        "void",
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/obstack.h": {},
  "recutils/recutils-1.7/lib/open.c": {
    "orig_open": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static int\norig_open (const char *filename, int flags, mode_t mode)\n{\n  return open (filename, flags, mode);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\nopen (const char *filename, int flags, ...)\n{\n  mode_t mode;\n  int fd;\n\n  mode = 0;\n  if (flags & O_CREAT)\n    {\n      va_list arg;\n      va_start (arg, flags);\n\n      /* We have to use PROMOTED_MODE_T instead of mode_t, otherwise GCC 4\n         creates crashing code when 'mode_t' is smaller than 'int'.  */\n      mode = va_arg (arg, PROMOTED_MODE_T);\n\n      va_end (arg);\n    }\n\n#if GNULIB_defined_O_NONBLOCK\n  /* The only known platform that lacks O_NONBLOCK is mingw, but it\n     also lacks named pipes and Unix sockets, which are the only two\n     file types that require non-blocking handling in open().\n     Therefore, it is safe to ignore O_NONBLOCK here.  It is handy\n     that mingw also lacks openat(), so that is also covered here.  */\n  flags &= ~O_NONBLOCK;\n#endif\n\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n  if (strcmp (filename, \"/dev/null\") == 0)\n    filename = \"NUL\";\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and one of O_CREAT, O_WRONLY, O_RDWR\n     is specified, then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file already exists as a directory, then\n       - if O_CREAT is specified, open() must fail because of the semantics\n         of O_CREAT,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because POSIX\n         <http://www.opengroup.org/susv3/functions/open.html> says that it\n         fails with errno = EISDIR in this case.\n     If the named file does not exist or does not name a directory, then\n       - if O_CREAT is specified, open() must fail since open() cannot create\n         directories,\n       - if O_WRONLY or O_RDWR is specified, open() must fail because the\n         file does not contain a '.' directory.  */\n  if (flags & (O_CREAT | O_WRONLY | O_RDWR))\n    {\n      size_t len = strlen (filename);\n      if (len > 0 && filename[len - 1] == '/')\n        {\n          errno = EISDIR;\n          return -1;\n        }\n    }\n#endif\n\n  fd = orig_open (filename, flags, mode);\n\n#if REPLACE_FCHDIR\n  /* Implementing fchdir and fdopendir requires the ability to open a\n     directory file descriptor.  If open doesn't support that (as on\n     mingw), we use a dummy file that behaves the same as directories\n     on Linux (ie. always reports EOF on attempts to read()), and\n     override fstat() in fchdir.c to hide the fact that we have a\n     dummy.  */\n  if (REPLACE_OPEN_DIRECTORY && fd < 0 && errno == EACCES\n      && ((flags & O_ACCMODE) == O_RDONLY\n          || (O_SEARCH != O_RDONLY && (flags & O_ACCMODE) == O_SEARCH)))\n    {\n      struct stat statbuf;\n      if (stat (filename, &statbuf) == 0 && S_ISDIR (statbuf.st_mode))\n        {\n          /* Maximum recursion depth of 1.  */\n          fd = open (\"/dev/null\", flags, mode);\n          if (0 <= fd)\n            fd = _gl_register_fd (fd, filename);\n        }\n      else\n        errno = EACCES;\n    }\n#endif\n\n#if OPEN_TRAILING_SLASH_BUG\n  /* If the filename ends in a slash and fd does not refer to a directory,\n     then fail.\n     Rationale: POSIX <http://www.opengroup.org/susv3/basedefs/xbd_chap04.html>\n     says that\n       \"A pathname that contains at least one non-slash character and that\n        ends with one or more trailing slashes shall be resolved as if a\n        single dot character ( '.' ) were appended to the pathname.\"\n     and\n       \"The special filename dot shall refer to the directory specified by\n        its predecessor.\"\n     If the named file without the slash is not a directory, open() must fail\n     with ENOTDIR.  */\n  if (fd >= 0)\n    {\n      /* We know len is positive, since open did not fail with ENOENT.  */\n      size_t len = strlen (filename);\n      if (filename[len - 1] == '/')\n        {\n          struct stat statbuf;\n\n          if (fstat (fd, &statbuf) >= 0 && !S_ISDIR (statbuf.st_mode))\n            {\n              close (fd);\n              errno = ENOTDIR;\n              return -1;\n            }\n        }\n    }\n#endif\n\n#if REPLACE_FCHDIR\n  if (!REPLACE_OPEN_DIRECTORY && 0 <= fd)\n    fd = _gl_register_fd (fd, filename);\n#endif\n\n  return fd;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/parse-datetime.c": {
    "to_uchar": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        187,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1299,
        0
      ],
      "end_point": [
        1336,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1473,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  YYSIZE_T yysize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = 0;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n                if (! (yysize <= yysize1\n                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                yysize = yysize1;\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  yysize1 = yysize + yystrlen (yyformat);\n  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  yysize = yysize1;\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_zone_hhmm": {
      "start_point": [
        2838,
        0
      ],
      "end_point": [
        2860,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        2862,
        0
      ],
      "end_point": [
        2875,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        2877,
        0
      ],
      "end_point": [
        2891,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        2893,
        0
      ],
      "end_point": [
        2913,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        2920,
        0
      ],
      "end_point": [
        2939,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        2942,
        0
      ],
      "end_point": [
        3011,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        3013,
        0
      ],
      "end_point": [
        3174,
        1
      ],
      "content": "static int\nyylex (YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p - buff < sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        3177,
        0
      ],
      "end_point": [
        3182,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        3188,
        0
      ],
      "end_point": [
        3207,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        3215,
        0
      ],
      "end_point": [
        3227,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        3233,
        0
      ],
      "end_point": [
        3570,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        3574,
        0
      ],
      "end_point": [
        3605,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/parse-datetime.h": {},
  "recutils/recutils-1.7/lib/parse-datetime.y": {
    "to_uchar": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        118,
        54
      ],
      "content": "static unsigned char to_uchar (char ch) { return ch; }",
      "lines": 1,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "digits_to_date_time": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\ndigits_to_date_time (parser_control *pc, textint text_int)\n{\n  if (pc->dates_seen && ! pc->year.digits\n      && ! pc->rels_seen && (pc->times_seen || 2 < text_int.digits))\n    pc->year = text_int;\n  else\n    {\n      if (4 < text_int.digits)\n        {\n          pc->dates_seen++;\n          pc->day = text_int.value % 100;\n          pc->month = (text_int.value / 100) % 100;\n          pc->year.value = text_int.value / 10000;\n          pc->year.digits = text_int.digits - 4;\n        }\n      else\n        {\n          pc->times_seen++;\n          if (text_int.digits <= 2)\n            {\n              pc->hour = text_int.value;\n              pc->minutes = 0;\n            }\n          else\n            {\n              pc->hour = text_int.value / 100;\n              pc->minutes = text_int.value % 100;\n            }\n          pc->seconds.tv_sec = 0;\n          pc->seconds.tv_nsec = 0;\n          pc->meridian = MER24;\n        }\n    }\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "apply_relative_time": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "static void\napply_relative_time (parser_control *pc, relative_time rel, int factor)\n{\n  pc->rel.ns += factor * rel.ns;\n  pc->rel.seconds += factor * rel.seconds;\n  pc->rel.minutes += factor * rel.minutes;\n  pc->rel.hour += factor * rel.hour;\n  pc->rel.day += factor * rel.day;\n  pc->rel.month += factor * rel.month;\n  pc->rel.year += factor * rel.year;\n  pc->rels_seen = true;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_hhmmss": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void\nset_hhmmss (parser_control *pc, long int hour, long int minutes,\n            time_t sec, long int nsec)\n{\n  pc->hour = hour;\n  pc->minutes = minutes;\n  pc->seconds.tv_sec = sec;\n  pc->seconds.tv_nsec = nsec;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "tZONE": [
      {
        "start_point": [
          377,
          30
        ],
        "end_point": [
          381,
          7
        ],
        "content": "unsigned_seconds tMERIDIAN\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = $6;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          396,
          30
        ],
        "end_point": [
          400,
          7
        ],
        "content": "unsigned_seconds o_zone_offset\n      {\n        set_hhmmss (pc, $1.value, $3.value, $5.tv_sec, $5.tv_nsec);\n        pc->meridian = MER24;\n      }",
        "lines": 5,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          422,
          4
        ],
        "end_point": [
          426,
          7
        ],
        "content": "tLOCAL_ZONE tDST\n      {\n        pc->local_isdst = 1;\n        pc->dsts_seen += (0 < $1) + 1;\n      }",
        "lines": 5,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          436,
          4
        ],
        "end_point": [
          438,
          42
        ],
        "content": "tZONE relunit_snumber\n      { pc->time_zone = $1;\n        apply_relative_time (pc, $2, 1); }",
        "lines": 3,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          442,
          4
        ],
        "end_point": [
          443,
          59
        ],
        "content": "tZONE tSNUMBER o_colon_minutes\n      { pc->time_zone = $1 + time_zone_hhmm (pc, $2, $3); }",
        "lines": 2,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          446,
          4
        ],
        "end_point": [
          447,
          34
        ],
        "content": "tZONE tDST\n      { pc->time_zone = $1 + 60; }",
        "lines": 2,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          461,
          4
        ],
        "end_point": [
          465,
          7
        ],
        "content": "tORDINAL tDAY\n      {\n        pc->day_ordinal = $1;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          466,
          4
        ],
        "end_point": [
          470,
          7
        ],
        "content": "tUNUMBER tDAY\n      {\n        pc->day_ordinal = $1.value;\n        pc->day_number = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          499,
          4
        ],
        "end_point": [
          506,
          7
        ],
        "content": "tUNUMBER tMONTH tSNUMBER\n      {\n        /* e.g. 17-JUN-1992.  */\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          507,
          4
        ],
        "end_point": [
          514,
          7
        ],
        "content": "tMONTH tSNUMBER tSNUMBER\n      {\n        /* e.g. JUN-17-1992.  */\n        pc->month = $1;\n        pc->day = -$2.value;\n        pc->year.value = -$3.value;\n        pc->year.digits = $3.digits;\n      }",
        "lines": 8,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          515,
          4
        ],
        "end_point": [
          519,
          7
        ],
        "content": "tMONTH tUNUMBER\n      {\n        pc->month = $1;\n        pc->day = $2.value;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      }
    ],
    "tUNUMBER": [
      {
        "start_point": [
          526,
          4
        ],
        "end_point": [
          530,
          7
        ],
        "content": "tUNUMBER tMONTH\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n      }",
        "lines": 5,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          531,
          4
        ],
        "end_point": [
          536,
          7
        ],
        "content": "tUNUMBER tMONTH tUNUMBER\n      {\n        pc->day = $1.value;\n        pc->month = $2;\n        pc->year = $3;\n      }",
        "lines": 6,
        "depth": 6,
        "decorators": null
      },
      {
        "start_point": [
          541,
          13
        ],
        "end_point": [
          547,
          7
        ],
        "content": "tSNUMBER tSNUMBER\n      {\n        /* ISO 8601 format.  YYYY-MM-DD.  */\n        pc->year = $1;\n        pc->month = -$2.value;\n        pc->day = -$3.value;\n      }",
        "lines": 7,
        "depth": 7,
        "decorators": null
      }
    ],
    "time_zone_hhmm": {
      "start_point": [
        857,
        0
      ],
      "end_point": [
        879,
        1
      ],
      "content": "static long int\ntime_zone_hhmm (parser_control *pc, textint s, long int mm)\n{\n  long int n_minutes;\n\n  /* If the length of S is 1 or 2 and no minutes are specified,\n     interpret it as a number of hours.  */\n  if (s.digits <= 2 && mm < 0)\n    s.value *= 100;\n\n  if (mm < 0)\n    n_minutes = (s.value / 100) * 60 + s.value % 100;\n  else\n    n_minutes = s.value * 60 + (s.negative ? -mm : mm);\n\n  /* If the absolute number of minutes is larger than 24 hours,\n     arrange to reject it by incrementing pc->zones_seen.  Thus,\n     we allow only values in the range UTC-24:00 to UTC+24:00.  */\n  if (24 * 60 < abs (n_minutes))\n    pc->zones_seen++;\n\n  return n_minutes;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "to_hour": {
      "start_point": [
        881,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "static int\nto_hour (long int hours, int meridian)\n{\n  switch (meridian)\n    {\n    default: /* Pacify GCC.  */\n    case MER24:\n      return 0 <= hours && hours < 24 ? hours : -1;\n    case MERam:\n      return 0 < hours && hours < 12 ? hours : hours == 12 ? 0 : -1;\n    case MERpm:\n      return 0 < hours && hours < 12 ? hours + 12 : hours == 12 ? 12 : -1;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "to_year": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static long int\nto_year (textint textyear)\n{\n  long int year = textyear.value;\n\n  if (year < 0)\n    year = -year;\n\n  /* XPG4 suggests that years 00-68 map to 2000-2068, and\n     years 69-99 map to 1969-1999.  */\n  else if (textyear.digits == 2)\n    year += year < 69 ? 2000 : 1900;\n\n  return year;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_zone": {
      "start_point": [
        912,
        0
      ],
      "end_point": [
        932,
        1
      ],
      "content": "static table const * _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)\n{\n  table const *tp;\n\n  for (tp = universal_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  /* Try local zone abbreviations before those in time_zone_table, as\n     the local ones are more likely to be right.  */\n  for (tp = pc->local_time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  for (tp = time_zone_table; tp->name; tp++)\n    if (strcmp (name, tp->name) == 0)\n      return tp;\n\n  return NULL;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "* _GL_ATTRIBUTE_PURE\nlookup_zone (parser_control const *pc, char const *name)",
        "*",
        "_GL_ATTRIBUTE_PURE",
        "_GL_ATTRIBUTE_PURE"
      ]
    },
    "tm_diff": {
      "start_point": [
        939,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "static long int\ntm_diff (struct tm const *a, struct tm const *b)\n{\n  /* Compute intervening leap days correctly even if year is negative.\n     Take care to avoid int overflow in leap day calculations.  */\n  int a4 = SHR (a->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (a->tm_year & 3);\n  int b4 = SHR (b->tm_year, 2) + SHR (TM_YEAR_BASE, 2) - ! (b->tm_year & 3);\n  int a100 = a4 / 25 - (a4 % 25 < 0);\n  int b100 = b4 / 25 - (b4 % 25 < 0);\n  int a400 = SHR (a100, 2);\n  int b400 = SHR (b100, 2);\n  int intervening_leap_days = (a4 - b4) - (a100 - b100) + (a400 - b400);\n  long int ayear = a->tm_year;\n  long int years = ayear - b->tm_year;\n  long int days = (365 * years + intervening_leap_days\n                   + (a->tm_yday - b->tm_yday));\n  return (60 * (60 * (24 * days + (a->tm_hour - b->tm_hour))\n                + (a->tm_min - b->tm_min))\n          + (a->tm_sec - b->tm_sec));\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "long int",
        "long",
        "int"
      ]
    },
    "lookup_word": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        1030,
        1
      ],
      "content": "static table const *\nlookup_word (parser_control const *pc, char *word)\n{\n  char *p;\n  char *q;\n  size_t wordlen;\n  table const *tp;\n  bool period_found;\n  bool abbrev;\n\n  /* Make it uppercase.  */\n  for (p = word; *p; p++)\n    {\n      unsigned char ch = *p;\n      *p = c_toupper (ch);\n    }\n\n  for (tp = meridian_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* See if we have an abbreviation for a month. */\n  wordlen = strlen (word);\n  abbrev = wordlen == 3 || (wordlen == 4 && word[3] == '.');\n\n  for (tp = month_and_day_table; tp->name; tp++)\n    if ((abbrev ? strncmp (word, tp->name, 3) : strcmp (word, tp->name)) == 0)\n      return tp;\n\n  if ((tp = lookup_zone (pc, word)))\n    return tp;\n\n  if (strcmp (word, dst_table[0].name) == 0)\n    return dst_table;\n\n  for (tp = time_units_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Strip off any plural and try the units table again. */\n  if (word[wordlen - 1] == 'S')\n    {\n      word[wordlen - 1] = '\\0';\n      for (tp = time_units_table; tp->name; tp++)\n        if (strcmp (word, tp->name) == 0)\n          return tp;\n      word[wordlen - 1] = 'S';  /* For \"this\" in relative_time_table.  */\n    }\n\n  for (tp = relative_time_table; tp->name; tp++)\n    if (strcmp (word, tp->name) == 0)\n      return tp;\n\n  /* Military time zones. */\n  if (wordlen == 1)\n    for (tp = military_table; tp->name; tp++)\n      if (word[0] == tp->name[0])\n        return tp;\n\n  /* Drop out any periods and try the time zone table again. */\n  for (period_found = false, p = q = word; (*p = *q); q++)\n    if (*q == '.')\n      period_found = true;\n    else\n      p++;\n  if (period_found && (tp = lookup_zone (pc, word)))\n    return tp;\n\n  return NULL;\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "table",
        "const",
        "const",
        "*\nlookup_word (parser_control const *pc, char *word)",
        "*"
      ]
    },
    "yylex": {
      "start_point": [
        1032,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static int\nyylex (YYSTYPE *lvalp, parser_control *pc)\n{\n  unsigned char c;\n  size_t count;\n\n  for (;;)\n    {\n      while (c = *pc->input, c_isspace (c))\n        pc->input++;\n\n      if (ISDIGIT (c) || c == '-' || c == '+')\n        {\n          char const *p;\n          int sign;\n          unsigned long int value;\n          if (c == '-' || c == '+')\n            {\n              sign = c == '-' ? -1 : 1;\n              while (c = *++pc->input, c_isspace (c))\n                continue;\n              if (! ISDIGIT (c))\n                /* skip the '-' sign */\n                continue;\n            }\n          else\n            sign = 0;\n          p = pc->input;\n          for (value = 0; ; value *= 10)\n            {\n              unsigned long int value1 = value + (c - '0');\n              if (value1 < value)\n                return '?';\n              value = value1;\n              c = *++p;\n              if (! ISDIGIT (c))\n                break;\n              if (ULONG_MAX / 10 < value)\n                return '?';\n            }\n          if ((c == '.' || c == ',') && ISDIGIT (p[1]))\n            {\n              time_t s;\n              int ns;\n              int digits;\n              unsigned long int value1;\n\n              /* Check for overflow when converting value to time_t.  */\n              if (sign < 0)\n                {\n                  s = - value;\n                  if (0 < s)\n                    return '?';\n                  value1 = -s;\n                }\n              else\n                {\n                  s = value;\n                  if (s < 0)\n                    return '?';\n                  value1 = s;\n                }\n              if (value != value1)\n                return '?';\n\n              /* Accumulate fraction, to ns precision.  */\n              p++;\n              ns = *p++ - '0';\n              for (digits = 2; digits <= LOG10_BILLION; digits++)\n                {\n                  ns *= 10;\n                  if (ISDIGIT (*p))\n                    ns += *p++ - '0';\n                }\n\n              /* Skip excess digits, truncating toward -Infinity.  */\n              if (sign < 0)\n                for (; ISDIGIT (*p); p++)\n                  if (*p != '0')\n                    {\n                      ns++;\n                      break;\n                    }\n              while (ISDIGIT (*p))\n                p++;\n\n              /* Adjust to the timespec convention, which is that\n                 tv_nsec is always a positive offset even if tv_sec is\n                 negative.  */\n              if (sign < 0 && ns)\n                {\n                  s--;\n                  if (! (s < 0))\n                    return '?';\n                  ns = BILLION - ns;\n                }\n\n              lvalp->timespec.tv_sec = s;\n              lvalp->timespec.tv_nsec = ns;\n              pc->input = p;\n              return sign ? tSDECIMAL_NUMBER : tUDECIMAL_NUMBER;\n            }\n          else\n            {\n              lvalp->textintval.negative = sign < 0;\n              if (sign < 0)\n                {\n                  lvalp->textintval.value = - value;\n                  if (0 < lvalp->textintval.value)\n                    return '?';\n                }\n              else\n                {\n                  lvalp->textintval.value = value;\n                  if (lvalp->textintval.value < 0)\n                    return '?';\n                }\n              lvalp->textintval.digits = p - pc->input;\n              pc->input = p;\n              return sign ? tSNUMBER : tUNUMBER;\n            }\n        }\n\n      if (c_isalpha (c))\n        {\n          char buff[20];\n          char *p = buff;\n          table const *tp;\n\n          do\n            {\n              if (p - buff < sizeof buff - 1)\n                *p++ = c;\n              c = *++pc->input;\n            }\n          while (c_isalpha (c) || c == '.');\n\n          *p = '\\0';\n          tp = lookup_word (pc, buff);\n          if (! tp)\n            return '?';\n          lvalp->intval = tp->value;\n          return tp->type;\n        }\n\n      if (c != '(')\n        return to_uchar (*pc->input++);\n\n      count = 0;\n      do\n        {\n          c = *pc->input++;\n          if (c == '\\0')\n            return c;\n          if (c == '(')\n            count++;\n          else if (c == ')')\n            count--;\n        }\n      while (count != 0);\n    }\n}",
      "lines": 162,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yyerror": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1201,
        1
      ],
      "content": "static int\nyyerror (parser_control const *pc _GL_UNUSED,\n         char const *s _GL_UNUSED)\n{\n  return 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mktime_ok": {
      "start_point": [
        1207,
        0
      ],
      "end_point": [
        1226,
        1
      ],
      "content": "static bool\nmktime_ok (struct tm const *tm0, struct tm const *tm1, time_t t)\n{\n  if (t == (time_t) -1)\n    {\n      /* Guard against falsely reporting an error when parsing a time\n         stamp that happens to equal (time_t) -1, on a host that\n         supports such a time stamp.  */\n      tm1 = localtime (&t);\n      if (!tm1)\n        return false;\n    }\n\n  return ! ((tm0->tm_sec ^ tm1->tm_sec)\n            | (tm0->tm_min ^ tm1->tm_min)\n            | (tm0->tm_hour ^ tm1->tm_hour)\n            | (tm0->tm_mday ^ tm1->tm_mday)\n            | (tm0->tm_mon ^ tm1->tm_mon)\n            | (tm0->tm_year ^ tm1->tm_year));\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "get_tz": {
      "start_point": [
        1234,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static char *\nget_tz (char tzbuf[TZBUFSIZE])\n{\n  char *tz = getenv (\"TZ\");\n  if (tz)\n    {\n      size_t tzsize = strlen (tz) + 1;\n      tz = (tzsize <= TZBUFSIZE\n            ? memcpy (tzbuf, tz, tzsize)\n            : xmemdup (tz, tzsize));\n    }\n  return tz;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_tz (char tzbuf[TZBUFSIZE])",
        "*"
      ]
    },
    "parse_datetime": {
      "start_point": [
        1252,
        0
      ],
      "end_point": [
        1589,
        1
      ],
      "content": "bool\nparse_datetime (struct timespec *result, char const *p,\n                struct timespec const *now)\n{\n  time_t Start;\n  long int Start_ns;\n  struct tm const *tmp;\n  struct tm tm;\n  struct tm tm0;\n  parser_control pc;\n  struct timespec gettime_buffer;\n  unsigned char c;\n  bool tz_was_altered = false;\n  char *tz0 = NULL;\n  char tz0buf[TZBUFSIZE];\n  bool ok = true;\n\n  if (! now)\n    {\n      gettime (&gettime_buffer);\n      now = &gettime_buffer;\n    }\n\n  Start = now->tv_sec;\n  Start_ns = now->tv_nsec;\n\n  tmp = localtime (&now->tv_sec);\n  if (! tmp)\n    return false;\n\n  while (c = *p, c_isspace (c))\n    p++;\n\n  if (strncmp (p, \"TZ=\\\"\", 4) == 0)\n    {\n      char const *tzbase = p + 4;\n      size_t tzsize = 1;\n      char const *s;\n\n      for (s = tzbase; *s; s++, tzsize++)\n        if (*s == '\\\\')\n          {\n            s++;\n            if (! (*s == '\\\\' || *s == '\"'))\n              break;\n          }\n        else if (*s == '\"')\n          {\n            char *z;\n            char *tz1;\n            char tz1buf[TZBUFSIZE];\n            bool large_tz = TZBUFSIZE < tzsize;\n            bool setenv_ok;\n            tz0 = get_tz (tz0buf);\n            z = tz1 = large_tz ? xmalloc (tzsize) : tz1buf;\n            for (s = tzbase; *s != '\"'; s++)\n              *z++ = *(s += *s == '\\\\');\n            *z = '\\0';\n            setenv_ok = setenv (\"TZ\", tz1, 1) == 0;\n            if (large_tz)\n              free (tz1);\n            if (!setenv_ok)\n              goto fail;\n            tz_was_altered = true;\n\n            p = s + 1;\n            while (c = *p, c_isspace (c))\n              p++;\n\n            break;\n          }\n    }\n\n  /* As documented, be careful to treat the empty string just like\n     a date string of \"0\".  Without this, an empty string would be\n     declared invalid when parsed during a DST transition.  */\n  if (*p == '\\0')\n    p = \"0\";\n\n  pc.input = p;\n  pc.year.value = tmp->tm_year;\n  pc.year.value += TM_YEAR_BASE;\n  pc.year.digits = 0;\n  pc.month = tmp->tm_mon + 1;\n  pc.day = tmp->tm_mday;\n  pc.hour = tmp->tm_hour;\n  pc.minutes = tmp->tm_min;\n  pc.seconds.tv_sec = tmp->tm_sec;\n  pc.seconds.tv_nsec = Start_ns;\n  tm.tm_isdst = tmp->tm_isdst;\n\n  pc.meridian = MER24;\n  pc.rel = RELATIVE_TIME_0;\n  pc.timespec_seen = false;\n  pc.rels_seen = false;\n  pc.dates_seen = 0;\n  pc.days_seen = 0;\n  pc.times_seen = 0;\n  pc.local_zones_seen = 0;\n  pc.dsts_seen = 0;\n  pc.zones_seen = 0;\n\n#if HAVE_STRUCT_TM_TM_ZONE\n  pc.local_time_zone_table[0].name = tmp->tm_zone;\n  pc.local_time_zone_table[0].type = tLOCAL_ZONE;\n  pc.local_time_zone_table[0].value = tmp->tm_isdst;\n  pc.local_time_zone_table[1].name = NULL;\n\n  /* Probe the names used in the next three calendar quarters, looking\n     for a tm_isdst different from the one we already have.  */\n  {\n    int quarter;\n    for (quarter = 1; quarter <= 3; quarter++)\n      {\n        time_t probe = Start + quarter * (90 * 24 * 60 * 60);\n        struct tm const *probe_tm = localtime (&probe);\n        if (probe_tm && probe_tm->tm_zone\n            && probe_tm->tm_isdst != pc.local_time_zone_table[0].value)\n          {\n              {\n                pc.local_time_zone_table[1].name = probe_tm->tm_zone;\n                pc.local_time_zone_table[1].type = tLOCAL_ZONE;\n                pc.local_time_zone_table[1].value = probe_tm->tm_isdst;\n                pc.local_time_zone_table[2].name = NULL;\n              }\n            break;\n          }\n      }\n  }\n#else\n#if HAVE_TZNAME\n  {\n# if !HAVE_DECL_TZNAME\n    extern char *tzname[];\n# endif\n    int i;\n    for (i = 0; i < 2; i++)\n      {\n        pc.local_time_zone_table[i].name = tzname[i];\n        pc.local_time_zone_table[i].type = tLOCAL_ZONE;\n        pc.local_time_zone_table[i].value = i;\n      }\n    pc.local_time_zone_table[i].name = NULL;\n  }\n#else\n  pc.local_time_zone_table[0].name = NULL;\n#endif\n#endif\n\n  if (pc.local_time_zone_table[0].name && pc.local_time_zone_table[1].name\n      && ! strcmp (pc.local_time_zone_table[0].name,\n                   pc.local_time_zone_table[1].name))\n    {\n      /* This locale uses the same abbreviation for standard and\n         daylight times.  So if we see that abbreviation, we don't\n         know whether it's daylight time.  */\n      pc.local_time_zone_table[0].value = -1;\n      pc.local_time_zone_table[1].name = NULL;\n    }\n\n  if (yyparse (&pc) != 0)\n    goto fail;\n\n  if (pc.timespec_seen)\n    *result = pc.seconds;\n  else\n    {\n      if (1 < (pc.times_seen | pc.dates_seen | pc.days_seen | pc.dsts_seen\n               | (pc.local_zones_seen + pc.zones_seen)))\n        goto fail;\n\n      tm.tm_year = to_year (pc.year) - TM_YEAR_BASE;\n      tm.tm_mon = pc.month - 1;\n      tm.tm_mday = pc.day;\n      if (pc.times_seen || (pc.rels_seen && ! pc.dates_seen && ! pc.days_seen))\n        {\n          tm.tm_hour = to_hour (pc.hour, pc.meridian);\n          if (tm.tm_hour < 0)\n            goto fail;\n          tm.tm_min = pc.minutes;\n          tm.tm_sec = pc.seconds.tv_sec;\n        }\n      else\n        {\n          tm.tm_hour = tm.tm_min = tm.tm_sec = 0;\n          pc.seconds.tv_nsec = 0;\n        }\n\n      /* Let mktime deduce tm_isdst if we have an absolute time stamp.  */\n      if (pc.dates_seen | pc.days_seen | pc.times_seen)\n        tm.tm_isdst = -1;\n\n      /* But if the input explicitly specifies local time with or without\n         DST, give mktime that information.  */\n      if (pc.local_zones_seen)\n        tm.tm_isdst = pc.local_isdst;\n\n      tm0 = tm;\n\n      Start = mktime (&tm);\n\n      if (! mktime_ok (&tm0, &tm, Start))\n        {\n          if (! pc.zones_seen)\n            goto fail;\n          else\n            {\n              /* Guard against falsely reporting errors near the time_t\n                 boundaries when parsing times in other time zones.  For\n                 example, suppose the input string \"1969-12-31 23:00:00 -0100\",\n                 the current time zone is 8 hours ahead of UTC, and the min\n                 time_t value is 1970-01-01 00:00:00 UTC.  Then the min\n                 localtime value is 1970-01-01 08:00:00, and mktime will\n                 therefore fail on 1969-12-31 23:00:00.  To work around the\n                 problem, set the time zone to 1 hour behind UTC temporarily\n                 by setting TZ=\"XXX1:00\" and try mktime again.  */\n\n              long int time_zone = pc.time_zone;\n              long int abs_time_zone = time_zone < 0 ? - time_zone : time_zone;\n              long int abs_time_zone_hour = abs_time_zone / 60;\n              int abs_time_zone_min = abs_time_zone % 60;\n              char tz1buf[sizeof \"XXX+0:00\"\n                          + sizeof pc.time_zone * CHAR_BIT / 3];\n              if (!tz_was_altered)\n                tz0 = get_tz (tz0buf);\n              sprintf (tz1buf, \"XXX%s%ld:%02d\", &\"-\"[time_zone < 0],\n                       abs_time_zone_hour, abs_time_zone_min);\n              if (setenv (\"TZ\", tz1buf, 1) != 0)\n                goto fail;\n              tz_was_altered = true;\n              tm = tm0;\n              Start = mktime (&tm);\n              if (! mktime_ok (&tm0, &tm, Start))\n                goto fail;\n            }\n        }\n\n      if (pc.days_seen && ! pc.dates_seen)\n        {\n          tm.tm_mday += ((pc.day_number - tm.tm_wday + 7) % 7\n                         + 7 * (pc.day_ordinal\n                                - (0 < pc.day_ordinal\n                                   && tm.tm_wday != pc.day_number)));\n          tm.tm_isdst = -1;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* Add relative date.  */\n      if (pc.rel.year | pc.rel.month | pc.rel.day)\n        {\n          int year = tm.tm_year + pc.rel.year;\n          int month = tm.tm_mon + pc.rel.month;\n          int day = tm.tm_mday + pc.rel.day;\n          if (((year < tm.tm_year) ^ (pc.rel.year < 0))\n              | ((month < tm.tm_mon) ^ (pc.rel.month < 0))\n              | ((day < tm.tm_mday) ^ (pc.rel.day < 0)))\n            goto fail;\n          tm.tm_year = year;\n          tm.tm_mon = month;\n          tm.tm_mday = day;\n          tm.tm_hour = tm0.tm_hour;\n          tm.tm_min = tm0.tm_min;\n          tm.tm_sec = tm0.tm_sec;\n          tm.tm_isdst = tm0.tm_isdst;\n          Start = mktime (&tm);\n          if (Start == (time_t) -1)\n            goto fail;\n        }\n\n      /* The only \"output\" of this if-block is an updated Start value,\n         so this block must follow others that clobber Start.  */\n      if (pc.zones_seen)\n        {\n          long int delta = pc.time_zone * 60;\n          time_t t1;\n#ifdef HAVE_TM_GMTOFF\n          delta -= tm.tm_gmtoff;\n#else\n          time_t t = Start;\n          struct tm const *gmt = gmtime (&t);\n          if (! gmt)\n            goto fail;\n          delta -= tm_diff (&tm, gmt);\n#endif\n          t1 = Start - delta;\n          if ((Start < t1) != (delta < 0))\n            goto fail;  /* time_t overflow */\n          Start = t1;\n        }\n\n      /* Add relative hours, minutes, and seconds.  On hosts that support\n         leap seconds, ignore the possibility of leap seconds; e.g.,\n         \"+ 10 minutes\" adds 600 seconds, even if one of them is a\n         leap second.  Typically this is not what the user wants, but it's\n         too hard to do it the other way, because the time zone indicator\n         must be applied before relative times, and if mktime is applied\n         again the time zone will be lost.  */\n      {\n        long int sum_ns = pc.seconds.tv_nsec + pc.rel.ns;\n        long int normalized_ns = (sum_ns % BILLION + BILLION) % BILLION;\n        time_t t0 = Start;\n        long int d1 = 60 * 60 * pc.rel.hour;\n        time_t t1 = t0 + d1;\n        long int d2 = 60 * pc.rel.minutes;\n        time_t t2 = t1 + d2;\n        long_time_t d3 = pc.rel.seconds;\n        long_time_t t3 = t2 + d3;\n        long int d4 = (sum_ns - normalized_ns) / BILLION;\n        long_time_t t4 = t3 + d4;\n        time_t t5 = t4;\n\n        if ((d1 / (60 * 60) ^ pc.rel.hour)\n            | (d2 / 60 ^ pc.rel.minutes)\n            | ((t1 < t0) ^ (d1 < 0))\n            | ((t2 < t1) ^ (d2 < 0))\n            | ((t3 < t2) ^ (d3 < 0))\n            | ((t4 < t3) ^ (d4 < 0))\n            | (t5 != t4))\n          goto fail;\n\n        result->tv_sec = t5;\n        result->tv_nsec = normalized_ns;\n      }\n    }\n\n  goto done;\n\n fail:\n  ok = false;\n done:\n  if (tz_was_altered)\n    ok &= (tz0 ? setenv (\"TZ\", tz0, 1) : unsetenv (\"TZ\")) == 0;\n  if (tz0 != tz0buf)\n    free (tz0);\n  return ok;\n}",
      "lines": 338,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        1593,
        0
      ],
      "end_point": [
        1624,
        1
      ],
      "content": "int\nmain (int ac, char **av)\n{\n  char buff[BUFSIZ];\n\n  printf (\"Enter date, or blank line to exit.\\n\\t> \");\n  fflush (stdout);\n\n  buff[BUFSIZ - 1] = '\\0';\n  while (fgets (buff, BUFSIZ - 1, stdin) && buff[0])\n    {\n      struct timespec d;\n      struct tm const *tm;\n      if (! parse_datetime (&d, buff, NULL))\n        printf (\"Bad format - couldn't convert.\\n\");\n      else if (! (tm = localtime (&d.tv_sec)))\n        {\n          long int sec = d.tv_sec;\n          printf (\"localtime (%ld) failed\\n\", sec);\n        }\n      else\n        {\n          int ns = d.tv_nsec;\n          printf (\"%04ld-%02d-%02d %02d:%02d:%02d.%09d\\n\",\n                  tm->tm_year + 1900L, tm->tm_mon + 1, tm->tm_mday,\n                  tm->tm_hour, tm->tm_min, tm->tm_sec, ns);\n        }\n      printf (\"\\t> \");\n      fflush (stdout);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/pathmax.h": {},
  "recutils/recutils-1.7/lib/printf-args.c": {
    "PRINTF_FETCHARGS": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "int\nPRINTF_FETCHARGS (va_list args, arguments *a)\n{\n  size_t i;\n  argument *ap;\n\n  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)\n    switch (ap->type)\n      {\n      case TYPE_SCHAR:\n        ap->a.a_schar = va_arg (args, /*signed char*/ int);\n        break;\n      case TYPE_UCHAR:\n        ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);\n        break;\n      case TYPE_SHORT:\n        ap->a.a_short = va_arg (args, /*short*/ int);\n        break;\n      case TYPE_USHORT:\n        ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);\n        break;\n      case TYPE_INT:\n        ap->a.a_int = va_arg (args, int);\n        break;\n      case TYPE_UINT:\n        ap->a.a_uint = va_arg (args, unsigned int);\n        break;\n      case TYPE_LONGINT:\n        ap->a.a_longint = va_arg (args, long int);\n        break;\n      case TYPE_ULONGINT:\n        ap->a.a_ulongint = va_arg (args, unsigned long int);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_LONGLONGINT:\n        ap->a.a_longlongint = va_arg (args, long long int);\n        break;\n      case TYPE_ULONGLONGINT:\n        ap->a.a_ulonglongint = va_arg (args, unsigned long long int);\n        break;\n#endif\n      case TYPE_DOUBLE:\n        ap->a.a_double = va_arg (args, double);\n        break;\n      case TYPE_LONGDOUBLE:\n        ap->a.a_longdouble = va_arg (args, long double);\n        break;\n      case TYPE_CHAR:\n        ap->a.a_char = va_arg (args, int);\n        break;\n#if HAVE_WINT_T\n      case TYPE_WIDE_CHAR:\n        /* Although ISO C 99 7.24.1.(2) says that wint_t is \"unchanged by\n           default argument promotions\", this is not the case in mingw32,\n           where wint_t is 'unsigned short'.  */\n        ap->a.a_wide_char =\n          (sizeof (wint_t) < sizeof (int)\n           ? (wint_t) va_arg (args, int)\n           : va_arg (args, wint_t));\n        break;\n#endif\n      case TYPE_STRING:\n        ap->a.a_string = va_arg (args, const char *);\n        /* A null pointer is an invalid argument for \"%s\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_string == NULL)\n          ap->a.a_string = \"(NULL)\";\n        break;\n#if HAVE_WCHAR_T\n      case TYPE_WIDE_STRING:\n        ap->a.a_wide_string = va_arg (args, const wchar_t *);\n        /* A null pointer is an invalid argument for \"%ls\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_wide_string == NULL)\n          {\n            static const wchar_t wide_null_string[] =\n              {\n                (wchar_t)'(',\n                (wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',\n                (wchar_t)')',\n                (wchar_t)0\n              };\n            ap->a.a_wide_string = wide_null_string;\n          }\n        break;\n#endif\n      case TYPE_POINTER:\n        ap->a.a_pointer = va_arg (args, void *);\n        break;\n      case TYPE_COUNT_SCHAR_POINTER:\n        ap->a.a_count_schar_pointer = va_arg (args, signed char *);\n        break;\n      case TYPE_COUNT_SHORT_POINTER:\n        ap->a.a_count_short_pointer = va_arg (args, short *);\n        break;\n      case TYPE_COUNT_INT_POINTER:\n        ap->a.a_count_int_pointer = va_arg (args, int *);\n        break;\n      case TYPE_COUNT_LONGINT_POINTER:\n        ap->a.a_count_longint_pointer = va_arg (args, long int *);\n        break;\n#if HAVE_LONG_LONG_INT\n      case TYPE_COUNT_LONGLONGINT_POINTER:\n        ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);\n        break;\n#endif\n#if ENABLE_UNISTDIO\n      /* The unistdio extensions.  */\n      case TYPE_U8_STRING:\n        ap->a.a_u8_string = va_arg (args, const uint8_t *);\n        /* A null pointer is an invalid argument for \"%U\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u8_string == NULL)\n          {\n            static const uint8_t u8_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u8_string = u8_null_string;\n          }\n        break;\n      case TYPE_U16_STRING:\n        ap->a.a_u16_string = va_arg (args, const uint16_t *);\n        /* A null pointer is an invalid argument for \"%lU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u16_string == NULL)\n          {\n            static const uint16_t u16_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u16_string = u16_null_string;\n          }\n        break;\n      case TYPE_U32_STRING:\n        ap->a.a_u32_string = va_arg (args, const uint32_t *);\n        /* A null pointer is an invalid argument for \"%llU\", but in practice\n           it occurs quite frequently in printf statements that produce\n           debug output.  Use a fallback in this case.  */\n        if (ap->a.a_u32_string == NULL)\n          {\n            static const uint32_t u32_null_string[] =\n              { '(', 'N', 'U', 'L', 'L', ')', 0 };\n            ap->a.a_u32_string = u32_null_string;\n          }\n        break;\n#endif\n      default:\n        /* Unknown type.  */\n        return -1;\n      }\n  return 0;\n}",
      "lines": 153,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/printf-args.h": {},
  "recutils/recutils-1.7/lib/printf-frexp.c": {
    "FUNC": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "DOUBLE\nFUNC (DOUBLE x, int *expptr)\n{\n  int exponent;\n  DECL_ROUNDING\n\n  BEGIN_ROUNDING ();\n\n#ifdef USE_FREXP_LDEXP\n  /* frexp and ldexp are usually faster than the loop below.  */\n  x = FREXP (x, &exponent);\n\n  x = x + x;\n  exponent -= 1;\n\n  if (exponent < MIN_EXP - 1)\n    {\n      x = LDEXP (x, exponent - (MIN_EXP - 1));\n      exponent = MIN_EXP - 1;\n    }\n#else\n  {\n    /* Since the exponent is an 'int', it fits in 64 bits.  Therefore the\n       loops are executed no more than 64 times.  */\n    DOUBLE pow2[64]; /* pow2[i] = 2^2^i */\n    DOUBLE powh[64]; /* powh[i] = 2^-2^i */\n    int i;\n\n    exponent = 0;\n    if (x >= L_(1.0))\n      {\n        /* A nonnegative exponent.  */\n        {\n          DOUBLE pow2_i; /* = pow2[i] */\n          DOUBLE powh_i; /* = powh[i] */\n\n          /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n             x * 2^exponent = argument, x >= 1.0.  */\n          for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n               ;\n               i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n            {\n              if (x >= pow2_i)\n                {\n                  exponent += (1 << i);\n                  x *= powh_i;\n                }\n              else\n                break;\n\n              pow2[i] = pow2_i;\n              powh[i] = powh_i;\n            }\n        }\n        /* Here 1.0 <= x < 2^2^i.  */\n      }\n    else\n      {\n        /* A negative exponent.  */\n        {\n          DOUBLE pow2_i; /* = pow2[i] */\n          DOUBLE powh_i; /* = powh[i] */\n\n          /* Invariants: pow2_i = 2^2^i, powh_i = 2^-2^i,\n             x * 2^exponent = argument, x < 1.0, exponent >= MIN_EXP - 1.  */\n          for (i = 0, pow2_i = L_(2.0), powh_i = L_(0.5);\n               ;\n               i++, pow2_i = pow2_i * pow2_i, powh_i = powh_i * powh_i)\n            {\n              if (exponent - (1 << i) < MIN_EXP - 1)\n                break;\n\n              exponent -= (1 << i);\n              x *= pow2_i;\n              if (x >= L_(1.0))\n                break;\n\n              pow2[i] = pow2_i;\n              powh[i] = powh_i;\n            }\n        }\n        /* Here either x < 1.0 and exponent - 2^i < MIN_EXP - 1 <= exponent,\n           or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n\n        if (x < L_(1.0))\n          /* Invariants: x * 2^exponent = argument, x < 1.0 and\n             exponent - 2^i < MIN_EXP - 1 <= exponent.  */\n          while (i > 0)\n            {\n              i--;\n              if (exponent - (1 << i) >= MIN_EXP - 1)\n                {\n                  exponent -= (1 << i);\n                  x *= pow2[i];\n                  if (x >= L_(1.0))\n                    break;\n                }\n            }\n\n        /* Here either x < 1.0 and exponent = MIN_EXP - 1,\n           or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n      }\n\n    /* Invariants: x * 2^exponent = argument, and\n       either x < 1.0 and exponent = MIN_EXP - 1,\n       or 1.0 <= x < 2^2^i and exponent >= MIN_EXP - 1.  */\n    while (i > 0)\n      {\n        i--;\n        if (x >= pow2[i])\n          {\n            exponent += (1 << i);\n            x *= powh[i];\n          }\n      }\n    /* Here either x < 1.0 and exponent = MIN_EXP - 1,\n       or 1.0 <= x < 2.0 and exponent >= MIN_EXP - 1.  */\n  }\n#endif\n\n  END_ROUNDING ();\n\n  *expptr = exponent;\n  return x;\n}",
      "lines": 125,
      "depth": 18,
      "decorators": [
        "DOUBLE"
      ]
    }
  },
  "recutils/recutils-1.7/lib/printf-frexp.h": {},
  "recutils/recutils-1.7/lib/printf-frexpl.c": {
    "printf_frexpl": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "long double\nprintf_frexpl (long double x, int *expptr)\n{\n  return printf_frexp (x, expptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "long double",
        "long",
        "double"
      ]
    }
  },
  "recutils/recutils-1.7/lib/printf-frexpl.h": {},
  "recutils/recutils-1.7/lib/printf-parse.c": {
    "PRINTF_PARSE": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        631,
        1
      ],
      "content": "int\nPRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)\n{\n  const CHAR_T *cp = format;    /* pointer into format */\n  size_t arg_posn = 0;          /* number of regular arguments consumed */\n  size_t d_allocated;           /* allocated elements of d->dir */\n  size_t a_allocated;           /* allocated elements of a->arg */\n  size_t max_width_length = 0;\n  size_t max_precision_length = 0;\n\n  d->count = 0;\n  d_allocated = N_DIRECT_ALLOC_DIRECTIVES;\n  d->dir = d->direct_alloc_dir;\n\n  a->count = 0;\n  a_allocated = N_DIRECT_ALLOC_ARGUMENTS;\n  a->arg = a->direct_alloc_arg;\n\n#define REGISTER_ARG(_index_,_type_) \\\n  {                                                                     \\\n    size_t n = (_index_);                                               \\\n    if (n >= a_allocated)                                               \\\n      {                                                                 \\\n        size_t memory_size;                                             \\\n        argument *memory;                                               \\\n                                                                        \\\n        a_allocated = xtimes (a_allocated, 2);                          \\\n        if (a_allocated <= n)                                           \\\n          a_allocated = xsum (n, 1);                                    \\\n        memory_size = xtimes (a_allocated, sizeof (argument));          \\\n        if (size_overflow_p (memory_size))                              \\\n          /* Overflow, would lead to out of memory.  */                 \\\n          goto out_of_memory;                                           \\\n        memory = (argument *) (a->arg != a->direct_alloc_arg            \\\n                               ? realloc (a->arg, memory_size)          \\\n                               : malloc (memory_size));                 \\\n        if (memory == NULL)                                             \\\n          /* Out of memory.  */                                         \\\n          goto out_of_memory;                                           \\\n        if (a->arg == a->direct_alloc_arg)                              \\\n          memcpy (memory, a->arg, a->count * sizeof (argument));        \\\n        a->arg = memory;                                                \\\n      }                                                                 \\\n    while (a->count <= n)                                               \\\n      a->arg[a->count++].type = TYPE_NONE;                              \\\n    if (a->arg[n].type == TYPE_NONE)                                    \\\n      a->arg[n].type = (_type_);                                        \\\n    else if (a->arg[n].type != (_type_))                                \\\n      /* Ambiguous type for positional argument.  */                    \\\n      goto error;                                                       \\\n  }\n\n  while (*cp != '\\0')\n    {\n      CHAR_T c = *cp++;\n      if (c == '%')\n        {\n          size_t arg_index = ARG_NONE;\n          DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */\n\n          /* Initialize the next directive.  */\n          dp->dir_start = cp - 1;\n          dp->flags = 0;\n          dp->width_start = NULL;\n          dp->width_end = NULL;\n          dp->width_arg_index = ARG_NONE;\n          dp->precision_start = NULL;\n          dp->precision_end = NULL;\n          dp->precision_arg_index = ARG_NONE;\n          dp->arg_index = ARG_NONE;\n\n          /* Test for positional argument.  */\n          if (*cp >= '0' && *cp <= '9')\n            {\n              const CHAR_T *np;\n\n              for (np = cp; *np >= '0' && *np <= '9'; np++)\n                ;\n              if (*np == '$')\n                {\n                  size_t n = 0;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    n = xsum (xtimes (n, 10), *np - '0');\n                  if (n == 0)\n                    /* Positional argument 0.  */\n                    goto error;\n                  if (size_overflow_p (n))\n                    /* n too large, would lead to out of memory later.  */\n                    goto error;\n                  arg_index = n - 1;\n                  cp = np + 1;\n                }\n            }\n\n          /* Read the flags.  */\n          for (;;)\n            {\n              if (*cp == '\\'')\n                {\n                  dp->flags |= FLAG_GROUP;\n                  cp++;\n                }\n              else if (*cp == '-')\n                {\n                  dp->flags |= FLAG_LEFT;\n                  cp++;\n                }\n              else if (*cp == '+')\n                {\n                  dp->flags |= FLAG_SHOWSIGN;\n                  cp++;\n                }\n              else if (*cp == ' ')\n                {\n                  dp->flags |= FLAG_SPACE;\n                  cp++;\n                }\n              else if (*cp == '#')\n                {\n                  dp->flags |= FLAG_ALT;\n                  cp++;\n                }\n              else if (*cp == '0')\n                {\n                  dp->flags |= FLAG_ZERO;\n                  cp++;\n                }\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n              else if (*cp == 'I')\n                {\n                  dp->flags |= FLAG_LOCALIZED;\n                  cp++;\n                }\n#endif\n              else\n                break;\n            }\n\n          /* Parse the field width.  */\n          if (*cp == '*')\n            {\n              dp->width_start = cp;\n              cp++;\n              dp->width_end = cp;\n              if (max_width_length < 1)\n                max_width_length = 1;\n\n              /* Test for positional argument.  */\n              if (*cp >= '0' && *cp <= '9')\n                {\n                  const CHAR_T *np;\n\n                  for (np = cp; *np >= '0' && *np <= '9'; np++)\n                    ;\n                  if (*np == '$')\n                    {\n                      size_t n = 0;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        n = xsum (xtimes (n, 10), *np - '0');\n                      if (n == 0)\n                        /* Positional argument 0.  */\n                        goto error;\n                      if (size_overflow_p (n))\n                        /* n too large, would lead to out of memory later.  */\n                        goto error;\n                      dp->width_arg_index = n - 1;\n                      cp = np + 1;\n                    }\n                }\n              if (dp->width_arg_index == ARG_NONE)\n                {\n                  dp->width_arg_index = arg_posn++;\n                  if (dp->width_arg_index == ARG_NONE)\n                    /* arg_posn wrapped around.  */\n                    goto error;\n                }\n              REGISTER_ARG (dp->width_arg_index, TYPE_INT);\n            }\n          else if (*cp >= '0' && *cp <= '9')\n            {\n              size_t width_length;\n\n              dp->width_start = cp;\n              for (; *cp >= '0' && *cp <= '9'; cp++)\n                ;\n              dp->width_end = cp;\n              width_length = dp->width_end - dp->width_start;\n              if (max_width_length < width_length)\n                max_width_length = width_length;\n            }\n\n          /* Parse the precision.  */\n          if (*cp == '.')\n            {\n              cp++;\n              if (*cp == '*')\n                {\n                  dp->precision_start = cp - 1;\n                  cp++;\n                  dp->precision_end = cp;\n                  if (max_precision_length < 2)\n                    max_precision_length = 2;\n\n                  /* Test for positional argument.  */\n                  if (*cp >= '0' && *cp <= '9')\n                    {\n                      const CHAR_T *np;\n\n                      for (np = cp; *np >= '0' && *np <= '9'; np++)\n                        ;\n                      if (*np == '$')\n                        {\n                          size_t n = 0;\n\n                          for (np = cp; *np >= '0' && *np <= '9'; np++)\n                            n = xsum (xtimes (n, 10), *np - '0');\n                          if (n == 0)\n                            /* Positional argument 0.  */\n                            goto error;\n                          if (size_overflow_p (n))\n                            /* n too large, would lead to out of memory\n                               later.  */\n                            goto error;\n                          dp->precision_arg_index = n - 1;\n                          cp = np + 1;\n                        }\n                    }\n                  if (dp->precision_arg_index == ARG_NONE)\n                    {\n                      dp->precision_arg_index = arg_posn++;\n                      if (dp->precision_arg_index == ARG_NONE)\n                        /* arg_posn wrapped around.  */\n                        goto error;\n                    }\n                  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);\n                }\n              else\n                {\n                  size_t precision_length;\n\n                  dp->precision_start = cp - 1;\n                  for (; *cp >= '0' && *cp <= '9'; cp++)\n                    ;\n                  dp->precision_end = cp;\n                  precision_length = dp->precision_end - dp->precision_start;\n                  if (max_precision_length < precision_length)\n                    max_precision_length = precision_length;\n                }\n            }\n\n          {\n            arg_type type;\n\n            /* Parse argument type/size specifiers.  */\n            {\n              int flags = 0;\n\n              for (;;)\n                {\n                  if (*cp == 'h')\n                    {\n                      flags |= (1 << (flags & 1));\n                      cp++;\n                    }\n                  else if (*cp == 'L')\n                    {\n                      flags |= 4;\n                      cp++;\n                    }\n                  else if (*cp == 'l')\n                    {\n                      flags += 8;\n                      cp++;\n                    }\n                  else if (*cp == 'j')\n                    {\n                      if (sizeof (intmax_t) > sizeof (long))\n                        {\n                          /* intmax_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (intmax_t) > sizeof (int))\n                        {\n                          /* intmax_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 'z' || *cp == 'Z')\n                    {\n                      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'\n                         because the warning facility in gcc-2.95.2 understands\n                         only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */\n                      if (sizeof (size_t) > sizeof (long))\n                        {\n                          /* size_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (size_t) > sizeof (int))\n                        {\n                          /* size_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n                  else if (*cp == 't')\n                    {\n                      if (sizeof (ptrdiff_t) > sizeof (long))\n                        {\n                          /* ptrdiff_t = long long */\n                          flags += 16;\n                        }\n                      else if (sizeof (ptrdiff_t) > sizeof (int))\n                        {\n                          /* ptrdiff_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#if defined __APPLE__ && defined __MACH__\n                  /* On Mac OS X 10.3, PRIdMAX is defined as \"qd\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'q')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* int64_t = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* int64_t = long */\n                          flags += 8;\n                        }\n                      cp++;\n                    }\n#endif\n#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                  /* On native Windows, PRIdMAX is defined as \"I64d\".\n                     We cannot change it to \"lld\" because PRIdMAX must also\n                     be understood by the system's printf routines.  */\n                  else if (*cp == 'I' && cp[1] == '6' && cp[2] == '4')\n                    {\n                      if (64 / 8 > sizeof (long))\n                        {\n                          /* __int64 = long long */\n                          flags += 16;\n                        }\n                      else\n                        {\n                          /* __int64 = long */\n                          flags += 8;\n                        }\n                      cp += 3;\n                    }\n#endif\n                  else\n                    break;\n                }\n\n              /* Read the conversion character.  */\n              c = *cp++;\n              switch (c)\n                {\n                case 'd': case 'i':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGLONGINT;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lld\" into TYPE_LONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_LONGINT;\n                  else if (flags & 2)\n                    type = TYPE_SCHAR;\n                  else if (flags & 1)\n                    type = TYPE_SHORT;\n                  else\n                    type = TYPE_INT;\n                  break;\n                case 'o': case 'u': case 'x': case 'X':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_ULONGLONGINT;\n                  else\n#endif\n                  /* If 'unsigned long long' exists and is the same as\n                     'unsigned long', we parse \"llu\" into TYPE_ULONGINT.  */\n                  if (flags >= 8)\n                    type = TYPE_ULONGINT;\n                  else if (flags & 2)\n                    type = TYPE_UCHAR;\n                  else if (flags & 1)\n                    type = TYPE_USHORT;\n                  else\n                    type = TYPE_UINT;\n                  break;\n                case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                case 'a': case 'A':\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_LONGDOUBLE;\n                  else\n                    type = TYPE_DOUBLE;\n                  break;\n                case 'c':\n                  if (flags >= 8)\n#if HAVE_WINT_T\n                    type = TYPE_WIDE_CHAR;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_CHAR;\n                  break;\n#if HAVE_WINT_T\n                case 'C':\n                  type = TYPE_WIDE_CHAR;\n                  c = 'c';\n                  break;\n#endif\n                case 's':\n                  if (flags >= 8)\n#if HAVE_WCHAR_T\n                    type = TYPE_WIDE_STRING;\n#else\n                    goto error;\n#endif\n                  else\n                    type = TYPE_STRING;\n                  break;\n#if HAVE_WCHAR_T\n                case 'S':\n                  type = TYPE_WIDE_STRING;\n                  c = 's';\n                  break;\n#endif\n                case 'p':\n                  type = TYPE_POINTER;\n                  break;\n                case 'n':\n#if HAVE_LONG_LONG_INT\n                  /* If 'long long' exists and is larger than 'long':  */\n                  if (flags >= 16 || (flags & 4))\n                    type = TYPE_COUNT_LONGLONGINT_POINTER;\n                  else\n#endif\n                  /* If 'long long' exists and is the same as 'long', we parse\n                     \"lln\" into TYPE_COUNT_LONGINT_POINTER.  */\n                  if (flags >= 8)\n                    type = TYPE_COUNT_LONGINT_POINTER;\n                  else if (flags & 2)\n                    type = TYPE_COUNT_SCHAR_POINTER;\n                  else if (flags & 1)\n                    type = TYPE_COUNT_SHORT_POINTER;\n                  else\n                    type = TYPE_COUNT_INT_POINTER;\n                  break;\n#if ENABLE_UNISTDIO\n                /* The unistdio extensions.  */\n                case 'U':\n                  if (flags >= 16)\n                    type = TYPE_U32_STRING;\n                  else if (flags >= 8)\n                    type = TYPE_U16_STRING;\n                  else\n                    type = TYPE_U8_STRING;\n                  break;\n#endif\n                case '%':\n                  type = TYPE_NONE;\n                  break;\n                default:\n                  /* Unknown conversion character.  */\n                  goto error;\n                }\n            }\n\n            if (type != TYPE_NONE)\n              {\n                dp->arg_index = arg_index;\n                if (dp->arg_index == ARG_NONE)\n                  {\n                    dp->arg_index = arg_posn++;\n                    if (dp->arg_index == ARG_NONE)\n                      /* arg_posn wrapped around.  */\n                      goto error;\n                  }\n                REGISTER_ARG (dp->arg_index, type);\n              }\n            dp->conversion = c;\n            dp->dir_end = cp;\n          }\n\n          d->count++;\n          if (d->count >= d_allocated)\n            {\n              size_t memory_size;\n              DIRECTIVE *memory;\n\n              d_allocated = xtimes (d_allocated, 2);\n              memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));\n              if (size_overflow_p (memory_size))\n                /* Overflow, would lead to out of memory.  */\n                goto out_of_memory;\n              memory = (DIRECTIVE *) (d->dir != d->direct_alloc_dir\n                                      ? realloc (d->dir, memory_size)\n                                      : malloc (memory_size));\n              if (memory == NULL)\n                /* Out of memory.  */\n                goto out_of_memory;\n              if (d->dir == d->direct_alloc_dir)\n                memcpy (memory, d->dir, d->count * sizeof (DIRECTIVE));\n              d->dir = memory;\n            }\n        }\n#if CHAR_T_ONLY_ASCII\n      else if (!c_isascii (c))\n        {\n          /* Non-ASCII character.  Not supported.  */\n          goto error;\n        }\n#endif\n    }\n  d->dir[d->count].dir_start = cp;\n\n  d->max_width_length = max_width_length;\n  d->max_precision_length = max_precision_length;\n  return 0;\n\nerror:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = EINVAL;\n  return -1;\n\nout_of_memory:\n  if (a->arg != a->direct_alloc_arg)\n    free (a->arg);\n  if (d->dir != d->direct_alloc_dir)\n    free (d->dir);\n  errno = ENOMEM;\n  return -1;\n}",
      "lines": 551,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/printf-parse.h": {},
  "recutils/recutils-1.7/lib/printf.c": {
    "printf": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "int\nprintf (const char *format, ...)\n{\n  int retval;\n  va_list args;\n\n  va_start (args, format);\n  retval = vfprintf (stdout, format, args);\n  va_end (args);\n\n  return retval;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/progname.c": {
    "set_program_name": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "void\nset_program_name (const char *argv0)\n{\n  /* libtool creates a temporary executable whose name is sometimes prefixed\n     with \"lt-\" (depends on the platform).  It also makes argv[0] absolute.\n     But the name of the temporary executable is a detail that should not be\n     visible to the end user and to the test suite.\n     Remove this \"<dirname>/.libs/\" or \"<dirname>/.libs/lt-\" prefix here.  */\n  const char *slash;\n  const char *base;\n\n  /* Sanity check.  POSIX requires the invoking process to pass a non-NULL\n     argv[0].  */\n  if (argv0 == NULL)\n    {\n      /* It's a bug in the invoking program.  Help diagnosing it.  */\n      fputs (\"A NULL argv[0] was passed through an exec system call.\\n\",\n             stderr);\n      abort ();\n    }\n\n  slash = strrchr (argv0, '/');\n  base = (slash != NULL ? slash + 1 : argv0);\n  if (base - argv0 >= 7 && strncmp (base - 7, \"/.libs/\", 7) == 0)\n    {\n      argv0 = base;\n      if (strncmp (base, \"lt-\", 3) == 0)\n        {\n          argv0 = base + 3;\n          /* On glibc systems, remove the \"lt-\" prefix from the variable\n             program_invocation_short_name.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_SHORT_NAME\n          program_invocation_short_name = (char *) argv0;\n#endif\n        }\n    }\n\n  /* But don't strip off a leading <dirname>/ in general, because when the user\n     runs\n         /some/hidden/place/bin/cp foo foo\n     he should get the error message\n         /some/hidden/place/bin/cp: `foo' and `foo' are the same file\n     not\n         cp: `foo' and `foo' are the same file\n   */\n\n  program_name = argv0;\n\n  /* On glibc systems, the error() function comes from libc and uses the\n     variable program_invocation_name, not program_name.  So set this variable\n     as well.  */\n#if HAVE_DECL_PROGRAM_INVOCATION_NAME\n  program_invocation_name = (char *) argv0;\n#endif\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/progname.h": {},
  "recutils/recutils-1.7/lib/qcopy-acl.c": {
    "qcopy_acl": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "int\nqcopy_acl (const char *src_name, int source_desc, const char *dst_name,\n           int dest_desc, mode_t mode)\n{\n#if USE_ACL && HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e (draft 17 -- abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n# if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n  acl_t acl;\n  int ret;\n\n  if (HAVE_ACL_GET_FD && source_desc != -1)\n    acl = acl_get_fd (source_desc);\n  else\n    acl = acl_get_file (src_name, ACL_TYPE_ACCESS);\n  if (acl == NULL)\n    {\n      if (! acl_errno_valid (errno))\n        return qset_acl (dst_name, dest_desc, mode);\n      else\n        return -2;\n    }\n\n  if (HAVE_ACL_SET_FD && dest_desc != -1)\n    ret = acl_set_fd (dest_desc, acl);\n  else\n    ret = acl_set_file (dst_name, ACL_TYPE_ACCESS, acl);\n  if (ret != 0)\n    {\n      int saved_errno = errno;\n\n      if (! acl_errno_valid (errno) && !acl_access_nontrivial (acl))\n        {\n          acl_free (acl);\n          return chmod_or_fchmod (dst_name, dest_desc, mode);\n        }\n      else\n        {\n          acl_free (acl);\n          chmod_or_fchmod (dst_name, dest_desc, mode);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  else\n    acl_free (acl);\n\n  if (!MODE_INSIDE_ACL || (mode & (S_ISUID | S_ISGID | S_ISVTX)))\n    {\n      /* We did not call chmod so far, and either the mode and the ACL are\n         separate or special bits are to be set which don't fit into ACLs.  */\n\n      if (chmod_or_fchmod (dst_name, dest_desc, mode) != 0)\n        return -1;\n    }\n\n  if (S_ISDIR (mode))\n    {\n      acl = acl_get_file (src_name, ACL_TYPE_DEFAULT);\n      if (acl == NULL)\n        return -2;\n\n      if (acl_set_file (dst_name, ACL_TYPE_DEFAULT, acl))\n        {\n          int saved_errno = errno;\n\n          acl_free (acl);\n          errno = saved_errno;\n          return -1;\n        }\n      else\n        acl_free (acl);\n    }\n  return 0;\n\n# else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  acl_t acl;\n  int ret;\n\n  if (HAVE_ACL_GET_FD && source_desc != -1)\n    acl = acl_get_fd (source_desc);\n  else\n    acl = acl_get_file (src_name, ACL_TYPE_EXTENDED);\n  if (acl == NULL)\n    {\n      if (!acl_errno_valid (errno))\n        return qset_acl (dst_name, dest_desc, mode);\n      else\n        return -2;\n    }\n\n  if (HAVE_ACL_SET_FD && dest_desc != -1)\n    ret = acl_set_fd (dest_desc, acl);\n  else\n    ret = acl_set_file (dst_name, ACL_TYPE_EXTENDED, acl);\n  if (ret != 0)\n    {\n      int saved_errno = errno;\n\n      if (!acl_errno_valid (saved_errno) && !acl_extended_nontrivial (acl))\n        {\n          acl_free (acl);\n          return chmod_or_fchmod (dst_name, dest_desc, mode);\n        }\n      else\n        {\n          acl_free (acl);\n          chmod_or_fchmod (dst_name, dest_desc, mode);\n          errno = saved_errno;\n          return -1;\n        }\n    }\n  else\n    acl_free (acl);\n\n  /* Since !MODE_INSIDE_ACL, we have to call chmod explicitly.  */\n  return chmod_or_fchmod (dst_name, dest_desc, mode);\n\n# endif\n\n#elif USE_ACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  /* Solaris 2.5 through Solaris 10, Cygwin, and contemporaneous versions\n     of Unixware.  The acl() call returns the access and default ACL both\n     at once.  */\n# ifdef ACE_GETACL\n  int ace_count;\n  ace_t *ace_entries;\n# endif\n  int count;\n  aclent_t *entries;\n  int did_chmod;\n  int saved_errno;\n  int ret;\n\n# ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).\n     There is an API\n       pathconf (name, _PC_ACL_ENABLED)\n       fpathconf (desc, _PC_ACL_ENABLED)\n     that allows to determine which of the two kinds of ACLs is supported\n     for the given file.  But some file systems may implement this call\n     incorrectly, so better not use it.\n     When fetching the source ACL, we simply fetch both ACL types.\n     When setting the destination ACL, we try either ACL types, assuming\n     that the kernel will translate the ACL from one form to the other.\n     (See in <http://docs.sun.com/app/docs/doc/819-2241/6n4huc7ia?l=en&a=view>\n     the description of ENOTSUP.)  */\n  for (;;)\n    {\n      ace_count = (source_desc != -1\n                   ? facl (source_desc, ACE_GETACLCNT, 0, NULL)\n                   : acl (src_name, ACE_GETACLCNT, 0, NULL));\n\n      if (ace_count < 0)\n        {\n          if (errno == ENOSYS || errno == EINVAL)\n            {\n              ace_count = 0;\n              ace_entries = NULL;\n              break;\n            }\n          else\n            return -2;\n        }\n\n      if (ace_count == 0)\n        {\n          ace_entries = NULL;\n          break;\n        }\n\n      ace_entries = (ace_t *) malloc (ace_count * sizeof (ace_t));\n      if (ace_entries == NULL)\n        {\n          errno = ENOMEM;\n          return -2;\n        }\n\n      ret = (source_desc != -1\n             ? facl (source_desc, ACE_GETACL, ace_count, ace_entries)\n             : acl (src_name, ACE_GETACL, ace_count, ace_entries));\n      if (ret < 0)\n        {\n          free (ace_entries);\n          if (errno == ENOSYS || errno == EINVAL)\n            {\n              ace_count = 0;\n              ace_entries = NULL;\n              break;\n            }\n          else\n            return -2;\n        }\n      if (ret == ace_count)\n        break;\n      /* Huh? The number of ACL entries changed since the last call.\n         Repeat.  */\n    }\n# endif\n\n  for (;;)\n    {\n      count = (source_desc != -1\n               ? facl (source_desc, GETACLCNT, 0, NULL)\n               : acl (src_name, GETACLCNT, 0, NULL));\n\n      if (count < 0)\n        {\n          if (errno == ENOSYS || errno == ENOTSUP || errno == EOPNOTSUPP)\n            {\n              count = 0;\n              entries = NULL;\n              break;\n            }\n          else\n            return -2;\n        }\n\n      if (count == 0)\n        {\n          entries = NULL;\n          break;\n        }\n\n      entries = (aclent_t *) malloc (count * sizeof (aclent_t));\n      if (entries == NULL)\n        {\n          errno = ENOMEM;\n          return -2;\n        }\n\n      if ((source_desc != -1\n           ? facl (source_desc, GETACL, count, entries)\n           : acl (src_name, GETACL, count, entries))\n          == count)\n        break;\n      /* Huh? The number of ACL entries changed since the last call.\n         Repeat.  */\n    }\n\n  /* Is there an ACL of either kind?  */\n# ifdef ACE_GETACL\n  if (ace_count == 0)\n# endif\n    if (count == 0)\n      return qset_acl (dst_name, dest_desc, mode);\n\n  did_chmod = 0; /* set to 1 once the mode bits in 0777 have been set */\n  saved_errno = 0; /* the first non-ignorable error code */\n\n  if (!MODE_INSIDE_ACL)\n    {\n      /* On Cygwin, it is necessary to call chmod before acl, because\n         chmod can change the contents of the ACL (in ways that don't\n         change the allowed accesses, but still visible).  */\n      if (chmod_or_fchmod (dst_name, dest_desc, mode) != 0)\n        saved_errno = errno;\n      did_chmod = 1;\n    }\n\n  /* If both ace_entries and entries are available, try SETACL before\n     ACE_SETACL, because SETACL cannot fail with ENOTSUP whereas ACE_SETACL\n     can.  */\n\n  if (count > 0)\n    {\n      ret = (dest_desc != -1\n             ? facl (dest_desc, SETACL, count, entries)\n             : acl (dst_name, SETACL, count, entries));\n      if (ret < 0 && saved_errno == 0)\n        {\n          saved_errno = errno;\n          if ((errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              && !acl_nontrivial (count, entries))\n            saved_errno = 0;\n        }\n      else\n        did_chmod = 1;\n    }\n  free (entries);\n\n# ifdef ACE_GETACL\n  if (ace_count > 0)\n    {\n      ret = (dest_desc != -1\n             ? facl (dest_desc, ACE_SETACL, ace_count, ace_entries)\n             : acl (dst_name, ACE_SETACL, ace_count, ace_entries));\n      if (ret < 0 && saved_errno == 0)\n        {\n          saved_errno = errno;\n          if ((errno == ENOSYS || errno == EINVAL || errno == ENOTSUP)\n              && !acl_ace_nontrivial (ace_count, ace_entries))\n            saved_errno = 0;\n        }\n    }\n  free (ace_entries);\n# endif\n\n  if (MODE_INSIDE_ACL\n      && did_chmod <= ((mode & (S_ISUID | S_ISGID | S_ISVTX)) ? 1 : 0))\n    {\n      /* We did not call chmod so far, and either the mode and the ACL are\n         separate or special bits are to be set which don't fit into ACLs.  */\n\n      if (chmod_or_fchmod (dst_name, dest_desc, mode) != 0)\n        {\n          if (saved_errno == 0)\n            saved_errno = errno;\n        }\n    }\n\n  if (saved_errno)\n    {\n      errno = saved_errno;\n      return -1;\n    }\n  return 0;\n\n#elif USE_ACL && HAVE_GETACL /* HP-UX */\n\n  struct acl_entry entries[NACLENTRIES];\n  int count;\n# if HAVE_ACLV_H\n  struct acl aclv_entries[NACLVENTRIES];\n  int aclv_count;\n# endif\n  int did_chmod;\n  int saved_errno;\n  int ret;\n\n  count = (source_desc != -1\n           ? fgetacl (source_desc, NACLENTRIES, entries)\n           : getacl (src_name, NACLENTRIES, entries));\n\n  if (count < 0)\n    {\n      if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n        count = 0;\n      else\n        return -2;\n    }\n  else if (count > 0)\n    {\n      if (count > NACLENTRIES)\n        /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n        abort ();\n    }\n\n# if HAVE_ACLV_H\n  aclv_count = acl ((char *) src_name, ACL_GET, NACLVENTRIES, aclv_entries);\n\n  if (aclv_count < 0)\n    {\n      if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n        count = 0;\n      else\n        return -2;\n    }\n  else if (aclv_count > 0)\n    {\n      if (aclv_count > NACLVENTRIES)\n        /* If NACLVENTRIES cannot be trusted, use dynamic memory allocation.  */\n        abort ();\n    }\n# endif\n\n  if (count == 0)\n# if HAVE_ACLV_H\n    if (aclv_count == 0)\n# endif\n      return qset_acl (dst_name, dest_desc, mode);\n\n  did_chmod = 0; /* set to 1 once the mode bits in 0777 have been set */\n  saved_errno = 0; /* the first non-ignorable error code */\n\n  if (count > 0)\n    {\n      ret = (dest_desc != -1\n             ? fsetacl (dest_desc, count, entries)\n             : setacl (dst_name, count, entries));\n      if (ret < 0 && saved_errno == 0)\n        {\n          saved_errno = errno;\n          if (errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP)\n            {\n              struct stat source_statbuf;\n\n              if ((source_desc != -1\n                   ? fstat (source_desc, &source_statbuf)\n                   : stat (src_name, &source_statbuf)) == 0)\n                {\n                  if (!acl_nontrivial (count, entries, &source_statbuf))\n                    saved_errno = 0;\n                }\n              else\n                saved_errno = errno;\n            }\n        }\n      else\n        did_chmod = 1;\n    }\n\n# if HAVE_ACLV_H\n  if (aclv_count > 0)\n    {\n      ret = acl ((char *) dst_name, ACL_SET, aclv_count, aclv_entries);\n      if (ret < 0 && saved_errno == 0)\n        {\n          saved_errno = errno;\n          if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n            {\n              if (!aclv_nontrivial (aclv_count, aclv_entries))\n                saved_errno = 0;\n            }\n        }\n      else\n        did_chmod = 1;\n    }\n# endif\n\n  if (did_chmod <= ((mode & (S_ISUID | S_ISGID | S_ISVTX)) ? 1 : 0))\n    {\n      /* We did not call chmod so far, and special bits are to be set which\n         don't fit into ACLs.  */\n\n      if (chmod_or_fchmod (dst_name, dest_desc, mode) != 0)\n        {\n          if (saved_errno == 0)\n            saved_errno = errno;\n        }\n    }\n\n  if (saved_errno)\n    {\n      errno = saved_errno;\n      return -1;\n    }\n  return 0;\n\n#elif USE_ACL && HAVE_ACLX_GET && 0 /* AIX */\n\n  /* TODO */\n\n#elif USE_ACL && HAVE_STATACL /* older AIX */\n\n  union { struct acl a; char room[4096]; } u;\n  int ret;\n\n  if ((source_desc != -1\n       ? fstatacl (source_desc, STX_NORMAL, &u.a, sizeof (u))\n       : statacl (src_name, STX_NORMAL, &u.a, sizeof (u)))\n      < 0)\n    return -2;\n\n  ret = (dest_desc != -1\n         ? fchacl (dest_desc, &u.a, u.a.acl_len)\n         : chacl (dst_name, &u.a, u.a.acl_len));\n  if (ret < 0)\n    {\n      int saved_errno = errno;\n\n      chmod_or_fchmod (dst_name, dest_desc, mode);\n      errno = saved_errno;\n      return -1;\n    }\n\n  /* No need to call chmod_or_fchmod at this point, since the mode bits\n     S_ISUID, S_ISGID, S_ISVTX are also stored in the ACL.  */\n\n  return 0;\n\n#elif USE_ACL && HAVE_ACLSORT /* NonStop Kernel */\n\n  struct acl entries[NACLENTRIES];\n  int count;\n  int ret;\n\n  count = acl ((char *) src_name, ACL_GET, NACLENTRIES, entries);\n\n  if (count < 0)\n    {\n      if (0)\n        count = 0;\n      else\n        return -2;\n    }\n  else if (count > 0)\n    {\n      if (count > NACLENTRIES)\n        /* If NACLENTRIES cannot be trusted, use dynamic memory allocation.  */\n        abort ();\n    }\n\n  if (count == 0)\n    return qset_acl (dst_name, dest_desc, mode);\n\n  ret = acl ((char *) dst_name, ACL_SET, count, entries);\n  if (ret < 0)\n    {\n      int saved_errno = errno;\n\n      if (0)\n        {\n          if (!acl_nontrivial (count, entries))\n            return chmod_or_fchmod (dst_name, dest_desc, mode);\n        }\n\n      chmod_or_fchmod (dst_name, dest_desc, mode);\n      errno = saved_errno;\n      return -1;\n    }\n\n  if (mode & (S_ISUID | S_ISGID | S_ISVTX))\n    {\n      /* We did not call chmod so far, and either the mode and the ACL are\n         separate or special bits are to be set which don't fit into ACLs.  */\n\n      return chmod_or_fchmod (dst_name, dest_desc, mode);\n    }\n  return 0;\n\n#else\n\n  return qset_acl (dst_name, dest_desc, mode);\n\n#endif\n}",
      "lines": 546,
      "depth": 20,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/qset-acl.c": {
    "chmod_or_fchmod": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nchmod_or_fchmod (const char *name, int desc, mode_t mode)\n{\n  if (HAVE_FCHMOD && desc != -1)\n    return fchmod (desc, mode);\n  else\n    return chmod (name, mode);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "qset_acl": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "int\nqset_acl (char const *name, int desc, mode_t mode)\n{\n#if USE_ACL\n# if HAVE_ACL_GET_FILE\n  /* POSIX 1003.1e draft 17 (abandoned) specific version.  */\n  /* Linux, FreeBSD, Mac OS X, IRIX, Tru64 */\n#  if !HAVE_ACL_TYPE_EXTENDED\n  /* Linux, FreeBSD, IRIX, Tru64 */\n\n  /* We must also have acl_from_text and acl_delete_def_file.\n     (acl_delete_def_file could be emulated with acl_init followed\n      by acl_set_file, but acl_set_file with an empty acl is\n      unspecified.)  */\n\n#   ifndef HAVE_ACL_FROM_TEXT\n#    error Must have acl_from_text (see POSIX 1003.1e draft 17).\n#   endif\n#   ifndef HAVE_ACL_DELETE_DEF_FILE\n#    error Must have acl_delete_def_file (see POSIX 1003.1e draft 17).\n#   endif\n\n  acl_t acl;\n  int ret;\n\n  if (HAVE_ACL_FROM_MODE) /* Linux */\n    {\n      acl = acl_from_mode (mode);\n      if (!acl)\n        return -1;\n    }\n  else /* FreeBSD, IRIX, Tru64 */\n    {\n      /* If we were to create the ACL using the functions acl_init(),\n         acl_create_entry(), acl_set_tag_type(), acl_set_qualifier(),\n         acl_get_permset(), acl_clear_perm[s](), acl_add_perm(), we\n         would need to create a qualifier.  I don't know how to do this.\n         So create it using acl_from_text().  */\n\n#   if HAVE_ACL_FREE_TEXT /* Tru64 */\n      char acl_text[] = \"u::---,g::---,o::---,\";\n#   else /* FreeBSD, IRIX */\n      char acl_text[] = \"u::---,g::---,o::---\";\n#   endif\n\n      if (mode & S_IRUSR) acl_text[ 3] = 'r';\n      if (mode & S_IWUSR) acl_text[ 4] = 'w';\n      if (mode & S_IXUSR) acl_text[ 5] = 'x';\n      if (mode & S_IRGRP) acl_text[10] = 'r';\n      if (mode & S_IWGRP) acl_text[11] = 'w';\n      if (mode & S_IXGRP) acl_text[12] = 'x';\n      if (mode & S_IROTH) acl_text[17] = 'r';\n      if (mode & S_IWOTH) acl_text[18] = 'w';\n      if (mode & S_IXOTH) acl_text[19] = 'x';\n\n      acl = acl_from_text (acl_text);\n      if (!acl)\n        return -1;\n    }\n  if (HAVE_ACL_SET_FD && desc != -1)\n    ret = acl_set_fd (desc, acl);\n  else\n    ret = acl_set_file (name, ACL_TYPE_ACCESS, acl);\n  if (ret != 0)\n    {\n      int saved_errno = errno;\n      acl_free (acl);\n      if (! acl_errno_valid (errno))\n        return chmod_or_fchmod (name, desc, mode);\n      errno = saved_errno;\n      return -1;\n    }\n  else\n    acl_free (acl);\n\n  if (S_ISDIR (mode) && acl_delete_def_file (name))\n    return -1;\n\n  if (!MODE_INSIDE_ACL || (mode & (S_ISUID | S_ISGID | S_ISVTX)))\n    {\n      /* We did not call chmod so far, and either the mode and the ACL are\n         separate or special bits are to be set which don't fit into ACLs.  */\n      return chmod_or_fchmod (name, desc, mode);\n    }\n  return 0;\n\n#  else /* HAVE_ACL_TYPE_EXTENDED */\n  /* Mac OS X */\n\n  /* On Mac OS X,  acl_get_file (name, ACL_TYPE_ACCESS)\n     and           acl_get_file (name, ACL_TYPE_DEFAULT)\n     always return NULL / EINVAL.  You have to use\n                   acl_get_file (name, ACL_TYPE_EXTENDED)\n     or            acl_get_fd (open (name, ...))\n     to retrieve an ACL.\n     On the other hand,\n                   acl_set_file (name, ACL_TYPE_ACCESS, acl)\n     and           acl_set_file (name, ACL_TYPE_DEFAULT, acl)\n     have the same effect as\n                   acl_set_file (name, ACL_TYPE_EXTENDED, acl):\n     Each of these calls sets the file's ACL.  */\n\n  acl_t acl;\n  int ret;\n\n  /* Remove the ACL if the file has ACLs.  */\n  if (HAVE_ACL_GET_FD && desc != -1)\n    acl = acl_get_fd (desc);\n  else\n    acl = acl_get_file (name, ACL_TYPE_EXTENDED);\n  if (acl)\n    {\n      acl_free (acl);\n\n      acl = acl_init (0);\n      if (acl)\n        {\n          if (HAVE_ACL_SET_FD && desc != -1)\n            ret = acl_set_fd (desc, acl);\n          else\n            ret = acl_set_file (name, ACL_TYPE_EXTENDED, acl);\n          if (ret != 0)\n            {\n              int saved_errno = errno;\n              acl_free (acl);\n              if (! acl_errno_valid (saved_errno))\n                return chmod_or_fchmod (name, desc, mode);\n              errno = saved_errno;\n              return -1;\n            }\n          acl_free (acl);\n        }\n    }\n\n  /* Since !MODE_INSIDE_ACL, we have to call chmod explicitly.  */\n  return chmod_or_fchmod (name, desc, mode);\n#  endif\n\n# elif HAVE_FACL && defined GETACL /* Solaris, Cygwin, not HP-UX */\n\n  int done_setacl = 0;\n\n#  ifdef ACE_GETACL\n  /* Solaris also has a different variant of ACLs, used in ZFS and NFSv4\n     file systems (whereas the other ones are used in UFS file systems).  */\n\n  /* The flags in the ace_t structure changed in a binary incompatible way\n     when ACL_NO_TRIVIAL etc. were introduced in <sys/acl.h> version 1.15.\n     How to distinguish the two conventions at runtime?\n     We fetch the existing ACL.  In the old convention, usually three ACEs have\n     a_flags = ACE_OWNER / ACE_GROUP / ACE_OTHER, in the range 0x0100..0x0400.\n     In the new convention, these values are not used.  */\n  int convention;\n\n  {\n    /* Initially, try to read the entries into a stack-allocated buffer.\n       Use malloc if it does not fit.  */\n    enum\n      {\n        alloc_init = 4000 / sizeof (ace_t), /* >= 3 */\n        alloc_max = MIN (INT_MAX, SIZE_MAX / sizeof (ace_t))\n      };\n    ace_t buf[alloc_init];\n    size_t alloc = alloc_init;\n    ace_t *entries = buf;\n    ace_t *malloced = NULL;\n    int count;\n\n    for (;;)\n      {\n        count = (desc != -1\n                 ? facl (desc, ACE_GETACL, alloc, entries)\n                 : acl (name, ACE_GETACL, alloc, entries));\n        if (count < 0 && errno == ENOSPC)\n          {\n            /* Increase the size of the buffer.  */\n            free (malloced);\n            if (alloc > alloc_max / 2)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            alloc = 2 * alloc; /* <= alloc_max */\n            entries = malloced = (ace_t *) malloc (alloc * sizeof (ace_t));\n            if (entries == NULL)\n              {\n                errno = ENOMEM;\n                return -1;\n              }\n            continue;\n          }\n        break;\n      }\n\n    if (count <= 0)\n      convention = -1;\n    else\n      {\n        int i;\n\n        convention = 0;\n        for (i = 0; i < count; i++)\n          if (entries[i].a_flags & (OLD_ACE_OWNER | OLD_ACE_GROUP | OLD_ACE_OTHER))\n            {\n              convention = 1;\n              break;\n            }\n      }\n    free (malloced);\n  }\n\n  if (convention >= 0)\n    {\n      ace_t entries[6];\n      int count;\n      int ret;\n\n      if (convention)\n        {\n          /* Running on Solaris 10.  */\n          entries[0].a_type = OLD_ALLOW;\n          entries[0].a_flags = OLD_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = (mode >> 6) & 7;\n          entries[1].a_type = OLD_ALLOW;\n          entries[1].a_flags = OLD_ACE_GROUP;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = (mode >> 3) & 7;\n          entries[2].a_type = OLD_ALLOW;\n          entries[2].a_flags = OLD_ACE_OTHER;\n          entries[2].a_who = 0;\n          entries[2].a_access_mask = mode & 7;\n          count = 3;\n        }\n      else\n        {\n          /* Running on Solaris 10 (newer version) or Solaris 11.\n             The details here were found through \"/bin/ls -lvd somefiles\".  */\n          entries[0].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[0].a_flags = NEW_ACE_OWNER;\n          entries[0].a_who = 0; /* irrelevant */\n          entries[0].a_access_mask = 0;\n          entries[1].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[1].a_flags = NEW_ACE_OWNER;\n          entries[1].a_who = 0; /* irrelevant */\n          entries[1].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          if (mode & 0400)\n            entries[1].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0200)\n            entries[1].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[0].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0100)\n            entries[1].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[0].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[2].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[2].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[2].a_who = 0; /* irrelevant */\n          entries[2].a_access_mask = 0;\n          entries[3].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[3].a_flags = NEW_ACE_GROUP | NEW_ACE_IDENTIFIER_GROUP;\n          entries[3].a_who = 0; /* irrelevant */\n          entries[3].a_access_mask = 0;\n          if (mode & 0040)\n            entries[3].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0020)\n            entries[3].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[2].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0010)\n            entries[3].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[2].a_access_mask |= NEW_ACE_EXECUTE;\n          entries[4].a_type = NEW_ACE_ACCESS_DENIED_ACE_TYPE;\n          entries[4].a_flags = NEW_ACE_EVERYONE;\n          entries[4].a_who = 0;\n          entries[4].a_access_mask = NEW_ACE_WRITE_NAMED_ATTRS\n                                     | NEW_ACE_WRITE_ATTRIBUTES\n                                     | NEW_ACE_WRITE_ACL\n                                     | NEW_ACE_WRITE_OWNER;\n          entries[5].a_type = NEW_ACE_ACCESS_ALLOWED_ACE_TYPE;\n          entries[5].a_flags = NEW_ACE_EVERYONE;\n          entries[5].a_who = 0;\n          entries[5].a_access_mask = NEW_ACE_READ_NAMED_ATTRS\n                                     | NEW_ACE_READ_ATTRIBUTES\n                                     | NEW_ACE_READ_ACL\n                                     | NEW_ACE_SYNCHRONIZE;\n          if (mode & 0004)\n            entries[5].a_access_mask |= NEW_ACE_READ_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_READ_DATA;\n          if (mode & 0002)\n            entries[5].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          else\n            entries[4].a_access_mask |= NEW_ACE_WRITE_DATA | NEW_ACE_APPEND_DATA;\n          if (mode & 0001)\n            entries[5].a_access_mask |= NEW_ACE_EXECUTE;\n          else\n            entries[4].a_access_mask |= NEW_ACE_EXECUTE;\n          count = 6;\n        }\n      if (desc != -1)\n        ret = facl (desc, ACE_SETACL, count, entries);\n      else\n        ret = acl (name, ACE_SETACL, count, entries);\n      if (ret < 0 && errno != EINVAL && errno != ENOTSUP)\n        {\n          if (errno == ENOSYS)\n            return chmod_or_fchmod (name, desc, mode);\n          return -1;\n        }\n      if (ret == 0)\n        done_setacl = 1;\n    }\n#  endif\n\n  if (!done_setacl)\n    {\n      aclent_t entries[3];\n      int ret;\n\n      entries[0].a_type = USER_OBJ;\n      entries[0].a_id = 0; /* irrelevant */\n      entries[0].a_perm = (mode >> 6) & 7;\n      entries[1].a_type = GROUP_OBJ;\n      entries[1].a_id = 0; /* irrelevant */\n      entries[1].a_perm = (mode >> 3) & 7;\n      entries[2].a_type = OTHER_OBJ;\n      entries[2].a_id = 0;\n      entries[2].a_perm = mode & 7;\n\n      if (desc != -1)\n        ret = facl (desc, SETACL,\n                    sizeof (entries) / sizeof (aclent_t), entries);\n      else\n        ret = acl (name, SETACL,\n                   sizeof (entries) / sizeof (aclent_t), entries);\n      if (ret < 0)\n        {\n          if (errno == ENOSYS || errno == EOPNOTSUPP)\n            return chmod_or_fchmod (name, desc, mode);\n          return -1;\n        }\n    }\n\n  if (!MODE_INSIDE_ACL || (mode & (S_ISUID | S_ISGID | S_ISVTX)))\n    {\n      /* We did not call chmod so far, so the special bits have not yet\n         been set.  */\n      return chmod_or_fchmod (name, desc, mode);\n    }\n  return 0;\n\n# elif HAVE_GETACL /* HP-UX */\n\n  struct stat statbuf;\n  int ret;\n\n  if (desc != -1)\n    ret = fstat (desc, &statbuf);\n  else\n    ret = stat (name, &statbuf);\n  if (ret < 0)\n    return -1;\n\n  {\n    struct acl_entry entries[3];\n\n    entries[0].uid = statbuf.st_uid;\n    entries[0].gid = ACL_NSGROUP;\n    entries[0].mode = (mode >> 6) & 7;\n    entries[1].uid = ACL_NSUSER;\n    entries[1].gid = statbuf.st_gid;\n    entries[1].mode = (mode >> 3) & 7;\n    entries[2].uid = ACL_NSUSER;\n    entries[2].gid = ACL_NSGROUP;\n    entries[2].mode = mode & 7;\n\n    if (desc != -1)\n      ret = fsetacl (desc, sizeof (entries) / sizeof (struct acl_entry), entries);\n    else\n      ret = setacl (name, sizeof (entries) / sizeof (struct acl_entry), entries);\n  }\n  if (ret < 0)\n    {\n      if (!(errno == ENOSYS || errno == EOPNOTSUPP || errno == ENOTSUP))\n        return -1;\n\n#  if HAVE_ACLV_H /* HP-UX >= 11.11 */\n      {\n        struct acl entries[4];\n\n        entries[0].a_type = USER_OBJ;\n        entries[0].a_id = 0; /* irrelevant */\n        entries[0].a_perm = (mode >> 6) & 7;\n        entries[1].a_type = GROUP_OBJ;\n        entries[1].a_id = 0; /* irrelevant */\n        entries[1].a_perm = (mode >> 3) & 7;\n        entries[2].a_type = CLASS_OBJ;\n        entries[2].a_id = 0;\n        entries[2].a_perm = (mode >> 3) & 7;\n        entries[3].a_type = OTHER_OBJ;\n        entries[3].a_id = 0;\n        entries[3].a_perm = mode & 7;\n\n        ret = aclsort (sizeof (entries) / sizeof (struct acl), 1, entries);\n        if (ret > 0)\n          abort ();\n        if (ret < 0)\n          {\n            if (0)\n              return chmod_or_fchmod (name, desc, mode);\n            return -1;\n          }\n\n        ret = acl ((char *) name, ACL_SET,\n                   sizeof (entries) / sizeof (struct acl), entries);\n        if (ret < 0)\n          {\n            if (errno == ENOSYS || errno == EOPNOTSUPP || errno == EINVAL)\n              return chmod_or_fchmod (name, desc, mode);\n            return -1;\n          }\n      }\n#  else\n      return chmod_or_fchmod (name, desc, mode);\n#  endif\n    }\n\n  if (mode & (S_ISUID | S_ISGID | S_ISVTX))\n    {\n      /* We did not call chmod so far, so the special bits have not yet\n         been set.  */\n      return chmod_or_fchmod (name, desc, mode);\n    }\n  return 0;\n\n# elif HAVE_ACLX_GET && defined ACL_AIX_WIP /* AIX */\n\n  acl_type_list_t types;\n  size_t types_size = sizeof (types);\n  acl_type_t type;\n\n  if (aclx_gettypes (name, &types, &types_size) < 0\n      || types.num_entries == 0)\n    return chmod_or_fchmod (name, desc, mode);\n\n  /* XXX Do we need to clear all types of ACLs for the given file, or is it\n     sufficient to clear the first one?  */\n  type = types.entries[0];\n  if (type.u64 == ACL_AIXC)\n    {\n      union { struct acl a; char room[128]; } u;\n      int ret;\n\n      u.a.acl_len = (char *) &u.a.acl_ext[0] - (char *) &u.a; /* no entries */\n      u.a.acl_mode = mode & ~(S_IXACL | 0777);\n      u.a.u_access = (mode >> 6) & 7;\n      u.a.g_access = (mode >> 3) & 7;\n      u.a.o_access = mode & 7;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.acl_len, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.acl_len, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n  else if (type.u64 == ACL_NFS4)\n    {\n      union { nfs4_acl_int_t a; char room[128]; } u;\n      nfs4_ace_int_t *ace;\n      int ret;\n\n      u.a.aclVersion = NFS4_ACL_INT_STRUCT_VERSION;\n      u.a.aclEntryN = 0;\n      ace = &u.a.aclEntry[0];\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_OWNER;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0400 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0200\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0100 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_GROUP;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0040 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0020\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0010 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      {\n        ace->flags = ACE4_ID_SPECIAL;\n        ace->aceWho.special_whoid = ACE4_WHO_EVERYONE;\n        ace->aceType = ACE4_ACCESS_ALLOWED_ACE_TYPE;\n        ace->aceFlags = 0;\n        ace->aceMask =\n          (mode & 0004 ? ACE4_READ_DATA | ACE4_LIST_DIRECTORY : 0)\n          | (mode & 0002\n             ? ACE4_WRITE_DATA | ACE4_ADD_FILE | ACE4_APPEND_DATA\n               | ACE4_ADD_SUBDIRECTORY\n             : 0)\n          | (mode & 0001 ? ACE4_EXECUTE : 0);\n        ace->aceWhoString[0] = '\\0';\n        ace->entryLen = (char *) &ace->aceWhoString[4] - (char *) ace;\n        ace = (nfs4_ace_int_t *) (char *) &ace->aceWhoString[4];\n        u.a.aclEntryN++;\n      }\n      u.a.aclLength = (char *) ace - (char *) &u.a;\n\n      if (desc != -1)\n        ret = aclx_fput (desc, SET_ACL | SET_MODE_S_BITS,\n                         type, &u.a, u.a.aclLength, mode);\n      else\n        ret = aclx_put (name, SET_ACL | SET_MODE_S_BITS,\n                        type, &u.a, u.a.aclLength, mode);\n      if (!(ret < 0 && errno == ENOSYS))\n        return ret;\n    }\n\n  return chmod_or_fchmod (name, desc, mode);\n\n# elif HAVE_STATACL /* older AIX */\n\n  union { struct acl a; char room[128]; } u;\n  int ret;\n\n  u.a.acl_len = (char *) &u.a.acl_ext[0] - (char *) &u.a; /* no entries */\n  u.a.acl_mode = mode & ~(S_IXACL | 0777);\n  u.a.u_access = (mode >> 6) & 7;\n  u.a.g_access = (mode >> 3) & 7;\n  u.a.o_access = mode & 7;\n\n  if (desc != -1)\n    ret = fchacl (desc, &u.a, u.a.acl_len);\n  else\n    ret = chacl (name, &u.a, u.a.acl_len);\n\n  if (ret < 0 && errno == ENOSYS)\n    return chmod_or_fchmod (name, desc, mode);\n\n  return ret;\n\n# elif HAVE_ACLSORT /* NonStop Kernel */\n\n  struct acl entries[4];\n  int ret;\n\n  entries[0].a_type = USER_OBJ;\n  entries[0].a_id = 0; /* irrelevant */\n  entries[0].a_perm = (mode >> 6) & 7;\n  entries[1].a_type = GROUP_OBJ;\n  entries[1].a_id = 0; /* irrelevant */\n  entries[1].a_perm = (mode >> 3) & 7;\n  entries[2].a_type = CLASS_OBJ;\n  entries[2].a_id = 0;\n  entries[2].a_perm = (mode >> 3) & 7;\n  entries[3].a_type = OTHER_OBJ;\n  entries[3].a_id = 0;\n  entries[3].a_perm = mode & 7;\n\n  ret = aclsort (sizeof (entries) / sizeof (struct acl), 1, entries);\n  if (ret > 0)\n    abort ();\n  if (ret < 0)\n    {\n      if (0)\n        return chmod_or_fchmod (name, desc, mode);\n      return -1;\n    }\n\n  ret = acl ((char *) name, ACL_SET,\n             sizeof (entries) / sizeof (struct acl), entries);\n  if (ret < 0)\n    {\n      if (0)\n        return chmod_or_fchmod (name, desc, mode);\n      return -1;\n    }\n\n  if (mode & (S_ISUID | S_ISGID | S_ISVTX))\n    {\n      /* We did not call chmod so far, so the special bits have not yet\n         been set.  */\n      return chmod_or_fchmod (name, desc, mode);\n    }\n  return 0;\n\n# else /* Unknown flavor of ACLs */\n  return chmod_or_fchmod (name, desc, mode);\n# endif\n#else /* !USE_ACL */\n  return chmod_or_fchmod (name, desc, mode);\n#endif\n}",
      "lines": 625,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/quote.h": {},
  "recutils/recutils-1.7/lib/quotearg.c": {
    "clone_quoting_options": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "struct quoting_options *\nclone_quoting_options (struct quoting_options *o)\n{\n  int e = errno;\n  struct quoting_options *p = xmemdup (o ? o : &default_quoting_options,\n                                       sizeof *o);\n  errno = e;\n  return p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "struct quoting_options",
        "struct",
        "quoting_options",
        "*\nclone_quoting_options (struct quoting_options *o)",
        "*"
      ]
    },
    "get_quoting_style": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "enum quoting_style\nget_quoting_style (struct quoting_options *o)\n{\n  return (o ? o : &default_quoting_options)->style;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "enum quoting_style",
        "enum",
        "quoting_style"
      ]
    },
    "set_quoting_style": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nset_quoting_style (struct quoting_options *o, enum quoting_style s)\n{\n  (o ? o : &default_quoting_options)->style = s;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "set_char_quoting": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\nset_char_quoting (struct quoting_options *o, char c, int i)\n{\n  unsigned char uc = c;\n  unsigned int *p =\n    (o ? o : &default_quoting_options)->quote_these_too + uc / INT_BITS;\n  int shift = uc % INT_BITS;\n  int r = (*p >> shift) & 1;\n  *p ^= ((i & 1) ^ r) << shift;\n  return r;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "set_quoting_flags": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "int\nset_quoting_flags (struct quoting_options *o, int i)\n{\n  int r;\n  if (!o)\n    o = &default_quoting_options;\n  r = o->flags;\n  o->flags = i;\n  return r;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "set_custom_quoting": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nset_custom_quoting (struct quoting_options *o,\n                    char const *left_quote, char const *right_quote)\n{\n  if (!o)\n    o = &default_quoting_options;\n  o->style = custom_quoting_style;\n  if (!left_quote || !right_quote)\n    abort ();\n  o->left_quote = left_quote;\n  o->right_quote = right_quote;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "quoting_options_from_style": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static struct quoting_options /* NOT PURE!! */\nquoting_options_from_style (enum quoting_style style)\n{\n  struct quoting_options o = { 0, 0, { 0 }, NULL, NULL };\n  if (style == custom_quoting_style)\n    abort ();\n  o.style = style;\n  return o;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct quoting_options",
        "struct",
        "quoting_options",
        "/* NOT PURE!! */"
      ]
    },
    "gettext_quote": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static char const *\ngettext_quote (char const *msgid, enum quoting_style s)\n{\n  char const *translation = _(msgid);\n  char const *locale_code;\n\n  if (translation != msgid)\n    return translation;\n\n  /* For UTF-8 and GB-18030, use single quotes U+2018 and U+2019.\n     Here is a list of other locales that include U+2018 and U+2019:\n\n        ISO-8859-7   0xA1                 KOI8-T       0x91\n        CP869        0x8B                 CP874        0x91\n        CP932        0x81 0x65            CP936        0xA1 0xAE\n        CP949        0xA1 0xAE            CP950        0xA1 0xA5\n        CP1250       0x91                 CP1251       0x91\n        CP1252       0x91                 CP1253       0x91\n        CP1254       0x91                 CP1255       0x91\n        CP1256       0x91                 CP1257       0x91\n        EUC-JP       0xA1 0xC6            EUC-KR       0xA1 0xAE\n        EUC-TW       0xA1 0xE4            BIG5         0xA1 0xA5\n        BIG5-HKSCS   0xA1 0xA5            EUC-CN       0xA1 0xAE\n        GBK          0xA1 0xAE            Georgian-PS  0x91\n        PT154        0x91\n\n     None of these is still in wide use; using iconv is overkill.  */\n  locale_code = locale_charset ();\n  if (STRCASEEQ (locale_code, \"UTF-8\", 'U','T','F','-','8',0,0,0,0))\n    return msgid[0] == '`' ? \"\\xe2\\x80\\x98\": \"\\xe2\\x80\\x99\";\n  if (STRCASEEQ (locale_code, \"GB18030\", 'G','B','1','8','0','3','0',0,0))\n    return msgid[0] == '`' ? \"\\xa1\\ae\": \"\\xa1\\xaf\";\n\n  return (s == clocale_quoting_style ? \"\\\"\" : \"'\");\n}",
      "lines": 35,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "const",
        "const",
        "*\ngettext_quote (char const *msgid, enum quoting_style s)",
        "*"
      ]
    },
    "quotearg_buffer_restyled": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        660,
        1
      ],
      "content": "static size_t\nquotearg_buffer_restyled (char *buffer, size_t buffersize,\n                          char const *arg, size_t argsize,\n                          enum quoting_style quoting_style, int flags,\n                          unsigned int const *quote_these_too,\n                          char const *left_quote,\n                          char const *right_quote)\n{\n  size_t i;\n  size_t len = 0;\n  char const *quote_string = 0;\n  size_t quote_string_len = 0;\n  bool backslash_escapes = false;\n  bool unibyte_locale = MB_CUR_MAX == 1;\n  bool elide_outer_quotes = (flags & QA_ELIDE_OUTER_QUOTES) != 0;\n\n#define STORE(c) \\\n    do \\\n      { \\\n        if (len < buffersize) \\\n          buffer[len] = (c); \\\n        len++; \\\n      } \\\n    while (0)\n\n  switch (quoting_style)\n    {\n    case c_maybe_quoting_style:\n      quoting_style = c_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case c_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\"');\n      backslash_escapes = true;\n      quote_string = \"\\\"\";\n      quote_string_len = 1;\n      break;\n\n    case escape_quoting_style:\n      backslash_escapes = true;\n      elide_outer_quotes = false;\n      break;\n\n    case locale_quoting_style:\n    case clocale_quoting_style:\n    case custom_quoting_style:\n      {\n        if (quoting_style != custom_quoting_style)\n          {\n            /* TRANSLATORS:\n               Get translations for open and closing quotation marks.\n               The message catalog should translate \"`\" to a left\n               quotation mark suitable for the locale, and similarly for\n               \"'\".  For example, a French Unicode local should translate\n               these to U+00AB (LEFT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), and U+00BB (RIGHT-POINTING DOUBLE ANGLE\n               QUOTATION MARK), respectively.\n\n               If the catalog has no translation, we will try to\n               use Unicode U+2018 (LEFT SINGLE QUOTATION MARK) and\n               Unicode U+2019 (RIGHT SINGLE QUOTATION MARK).  If the\n               current locale is not Unicode, locale_quoting_style\n               will quote 'like this', and clocale_quoting_style will\n               quote \"like this\".  You should always include translations\n               for \"`\" and \"'\" even if U+2018 and U+2019 are appropriate\n               for your locale.\n\n               If you don't know what to put here, please see\n               <http://en.wikipedia.org/wiki/Quotation_marks_in_other_languages>\n               and use glyphs suitable for your language.  */\n            left_quote = gettext_quote (N_(\"`\"), quoting_style);\n            right_quote = gettext_quote (N_(\"'\"), quoting_style);\n          }\n        if (!elide_outer_quotes)\n          for (quote_string = left_quote; *quote_string; quote_string++)\n            STORE (*quote_string);\n        backslash_escapes = true;\n        quote_string = right_quote;\n        quote_string_len = strlen (quote_string);\n      }\n      break;\n\n    case shell_quoting_style:\n      quoting_style = shell_always_quoting_style;\n      elide_outer_quotes = true;\n      /* Fall through.  */\n    case shell_always_quoting_style:\n      if (!elide_outer_quotes)\n        STORE ('\\'');\n      quote_string = \"'\";\n      quote_string_len = 1;\n      break;\n\n    case literal_quoting_style:\n      elide_outer_quotes = false;\n      break;\n\n    default:\n      abort ();\n    }\n\n  for (i = 0;  ! (argsize == SIZE_MAX ? arg[i] == '\\0' : i == argsize);  i++)\n    {\n      unsigned char c;\n      unsigned char esc;\n      bool is_right_quote = false;\n\n      if (backslash_escapes\n          && quote_string_len\n          && (i + quote_string_len\n              <= (argsize == SIZE_MAX && 1 < quote_string_len\n                  /* Use strlen only if we must: when argsize is SIZE_MAX,\n                     and when the quote string is more than 1 byte long.\n                     If we do call strlen, save the result.  */\n                  ? (argsize = strlen (arg)) : argsize))\n          && memcmp (arg + i, quote_string, quote_string_len) == 0)\n        {\n          if (elide_outer_quotes)\n            goto force_outer_quoting_style;\n          is_right_quote = true;\n        }\n\n      c = arg[i];\n      switch (c)\n        {\n        case '\\0':\n          if (backslash_escapes)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\\\');\n              /* If quote_string were to begin with digits, we'd need to\n                 test for the end of the arg as well.  However, it's\n                 hard to imagine any locale that would use digits in\n                 quotes, and set_custom_quoting is documented not to\n                 accept them.  */\n              if (i + 1 < argsize && '0' <= arg[i + 1] && arg[i + 1] <= '9')\n                {\n                  STORE ('0');\n                  STORE ('0');\n                }\n              c = '0';\n              /* We don't have to worry that this last '0' will be\n                 backslash-escaped because, again, quote_string should\n                 not start with it and because quote_these_too is\n                 documented as not accepting it.  */\n            }\n          else if (flags & QA_ELIDE_NULL_BYTES)\n            continue;\n          break;\n\n        case '?':\n          switch (quoting_style)\n            {\n            case shell_always_quoting_style:\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              break;\n\n            case c_quoting_style:\n              if ((flags & QA_SPLIT_TRIGRAPHS)\n                  && i + 2 < argsize && arg[i + 1] == '?')\n                switch (arg[i + 2])\n                  {\n                  case '!': case '\\'':\n                  case '(': case ')': case '-': case '/':\n                  case '<': case '=': case '>':\n                    /* Escape the second '?' in what would otherwise be\n                       a trigraph.  */\n                    if (elide_outer_quotes)\n                      goto force_outer_quoting_style;\n                    c = arg[i + 2];\n                    i += 2;\n                    STORE ('?');\n                    STORE ('\"');\n                    STORE ('\"');\n                    STORE ('?');\n                    break;\n\n                  default:\n                    break;\n                  }\n              break;\n\n            default:\n              break;\n            }\n          break;\n\n        case '\\a': esc = 'a'; goto c_escape;\n        case '\\b': esc = 'b'; goto c_escape;\n        case '\\f': esc = 'f'; goto c_escape;\n        case '\\n': esc = 'n'; goto c_and_shell_escape;\n        case '\\r': esc = 'r'; goto c_and_shell_escape;\n        case '\\t': esc = 't'; goto c_and_shell_escape;\n        case '\\v': esc = 'v'; goto c_escape;\n        case '\\\\': esc = c;\n          /* No need to escape the escape if we are trying to elide\n             outer quotes and nothing else is problematic.  */\n          if (backslash_escapes && elide_outer_quotes && quote_string_len)\n            goto store_c;\n\n        c_and_shell_escape:\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          /* Fall through.  */\n        c_escape:\n          if (backslash_escapes)\n            {\n              c = esc;\n              goto store_escape;\n            }\n          break;\n\n        case '{': case '}': /* sometimes special if isolated */\n          if (! (argsize == SIZE_MAX ? arg[1] == '\\0' : argsize == 1))\n            break;\n          /* Fall through.  */\n        case '#': case '~':\n          if (i != 0)\n            break;\n          /* Fall through.  */\n        case ' ':\n        case '!': /* special in bash */\n        case '\"': case '$': case '&':\n        case '(': case ')': case '*': case ';':\n        case '<':\n        case '=': /* sometimes special in 0th or (with \"set -k\") later args */\n        case '>': case '[':\n        case '^': /* special in old /bin/sh, e.g. SunOS 4.1.4 */\n        case '`': case '|':\n          /* A shell special character.  In theory, '$' and '`' could\n             be the first bytes of multibyte characters, which means\n             we should check them with mbrtowc, but in practice this\n             doesn't happen so it's not worth worrying about.  */\n          if (quoting_style == shell_always_quoting_style\n              && elide_outer_quotes)\n            goto force_outer_quoting_style;\n          break;\n\n        case '\\'':\n          if (quoting_style == shell_always_quoting_style)\n            {\n              if (elide_outer_quotes)\n                goto force_outer_quoting_style;\n              STORE ('\\'');\n              STORE ('\\\\');\n              STORE ('\\'');\n            }\n          break;\n\n        case '%': case '+': case ',': case '-': case '.': case '/':\n        case '0': case '1': case '2': case '3': case '4': case '5':\n        case '6': case '7': case '8': case '9': case ':':\n        case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n        case 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n        case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n        case 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n        case 'Y': case 'Z': case ']': case '_': case 'a': case 'b':\n        case 'c': case 'd': case 'e': case 'f': case 'g': case 'h':\n        case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n        case 'o': case 'p': case 'q': case 'r': case 's': case 't':\n        case 'u': case 'v': case 'w': case 'x': case 'y': case 'z':\n          /* These characters don't cause problems, no matter what the\n             quoting style is.  They cannot start multibyte sequences.\n             A digit or a special letter would cause trouble if it\n             appeared at the beginning of quote_string because we'd then\n             escape by prepending a backslash.  However, it's hard to\n             imagine any locale that would use digits or letters as\n             quotes, and set_custom_quoting is documented not to accept\n             them.  Also, a digit or a special letter would cause\n             trouble if it appeared in quote_these_too, but that's also\n             documented as not accepting them.  */\n          break;\n\n        default:\n          /* If we have a multibyte sequence, copy it until we reach\n             its end, find an error, or come back to the initial shift\n             state.  For C-like styles, if the sequence has\n             unprintable characters, escape the whole sequence, since\n             we can't easily escape single characters within it.  */\n          {\n            /* Length of multibyte sequence found so far.  */\n            size_t m;\n\n            bool printable;\n\n            if (unibyte_locale)\n              {\n                m = 1;\n                printable = isprint (c) != 0;\n              }\n            else\n              {\n                mbstate_t mbstate;\n                memset (&mbstate, 0, sizeof mbstate);\n\n                m = 0;\n                printable = true;\n                if (argsize == SIZE_MAX)\n                  argsize = strlen (arg);\n\n                do\n                  {\n                    wchar_t w;\n                    size_t bytes = mbrtowc (&w, &arg[i + m],\n                                            argsize - (i + m), &mbstate);\n                    if (bytes == 0)\n                      break;\n                    else if (bytes == (size_t) -1)\n                      {\n                        printable = false;\n                        break;\n                      }\n                    else if (bytes == (size_t) -2)\n                      {\n                        printable = false;\n                        while (i + m < argsize && arg[i + m])\n                          m++;\n                        break;\n                      }\n                    else\n                      {\n                        /* Work around a bug with older shells that \"see\" a '\\'\n                           that is really the 2nd byte of a multibyte character.\n                           In practice the problem is limited to ASCII\n                           chars >= '@' that are shell special chars.  */\n                        if ('[' == 0x5b && elide_outer_quotes\n                            && quoting_style == shell_always_quoting_style)\n                          {\n                            size_t j;\n                            for (j = 1; j < bytes; j++)\n                              switch (arg[i + m + j])\n                                {\n                                case '[': case '\\\\': case '^':\n                                case '`': case '|':\n                                  goto force_outer_quoting_style;\n\n                                default:\n                                  break;\n                                }\n                          }\n\n                        if (! iswprint (w))\n                          printable = false;\n                        m += bytes;\n                      }\n                  }\n                while (! mbsinit (&mbstate));\n              }\n\n            if (1 < m || (backslash_escapes && ! printable))\n              {\n                /* Output a multibyte sequence, or an escaped\n                   unprintable unibyte character.  */\n                size_t ilim = i + m;\n\n                for (;;)\n                  {\n                    if (backslash_escapes && ! printable)\n                      {\n                        if (elide_outer_quotes)\n                          goto force_outer_quoting_style;\n                        STORE ('\\\\');\n                        STORE ('0' + (c >> 6));\n                        STORE ('0' + ((c >> 3) & 7));\n                        c = '0' + (c & 7);\n                      }\n                    else if (is_right_quote)\n                      {\n                        STORE ('\\\\');\n                        is_right_quote = false;\n                      }\n                    if (ilim <= i + 1)\n                      break;\n                    STORE (c);\n                    c = arg[++i];\n                  }\n\n                goto store_c;\n              }\n          }\n        }\n\n      if (! ((backslash_escapes || elide_outer_quotes)\n             && quote_these_too\n             && quote_these_too[c / INT_BITS] >> (c % INT_BITS) & 1)\n          && !is_right_quote)\n        goto store_c;\n\n    store_escape:\n      if (elide_outer_quotes)\n        goto force_outer_quoting_style;\n      STORE ('\\\\');\n\n    store_c:\n      STORE (c);\n    }\n\n  if (len == 0 && quoting_style == shell_always_quoting_style\n      && elide_outer_quotes)\n    goto force_outer_quoting_style;\n\n  if (quote_string && !elide_outer_quotes)\n    for (; *quote_string; quote_string++)\n      STORE (*quote_string);\n\n  if (len < buffersize)\n    buffer[len] = '\\0';\n  return len;\n\n force_outer_quoting_style:\n  /* Don't reuse quote_these_too, since the addition of outer quotes\n     sufficiently quotes the specified characters.  */\n  return quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                   quoting_style,\n                                   flags & ~QA_ELIDE_OUTER_QUOTES, NULL,\n                                   left_quote, right_quote);\n}",
      "lines": 421,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "quotearg_buffer": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        683,
        1
      ],
      "content": "size_t\nquotearg_buffer (char *buffer, size_t buffersize,\n                 char const *arg, size_t argsize,\n                 struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  size_t r = quotearg_buffer_restyled (buffer, buffersize, arg, argsize,\n                                       p->style, p->flags, p->quote_these_too,\n                                       p->left_quote, p->right_quote);\n  errno = e;\n  return r;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "quotearg_alloc": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "char *\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)\n{\n  return quotearg_alloc_mem (arg, argsize, NULL, o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_alloc (char const *arg, size_t argsize,\n                struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_alloc_mem": {
      "start_point": [
        699,
        0
      ],
      "end_point": [
        719,
        1
      ],
      "content": "char *\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)\n{\n  struct quoting_options const *p = o ? o : &default_quoting_options;\n  int e = errno;\n  /* Elide embedded null bytes if we can't return a size.  */\n  int flags = p->flags | (size ? 0 : QA_ELIDE_NULL_BYTES);\n  size_t bufsize = quotearg_buffer_restyled (0, 0, arg, argsize, p->style,\n                                             flags, p->quote_these_too,\n                                             p->left_quote,\n                                             p->right_quote) + 1;\n  char *buf = xcharalloc (bufsize);\n  quotearg_buffer_restyled (buf, bufsize, arg, argsize, p->style, flags,\n                            p->quote_these_too,\n                            p->left_quote, p->right_quote);\n  errno = e;\n  if (size)\n    *size = bufsize - 1;\n  return buf;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "char",
        "*\nquotearg_alloc_mem (char const *arg, size_t argsize, size_t *size,\n                    struct quoting_options const *o)",
        "*"
      ]
    },
    "quotearg_free": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        754,
        1
      ],
      "content": "void\nquotearg_free (void)\n{\n  struct slotvec *sv = slotvec;\n  unsigned int i;\n  for (i = 1; i < nslots; i++)\n    free (sv[i].val);\n  if (sv[0].val != slot0)\n    {\n      free (sv[0].val);\n      slotvec0.size = sizeof slot0;\n      slotvec0.val = slot0;\n    }\n  if (sv != &slotvec0)\n    {\n      free (sv);\n      slotvec = &slotvec0;\n    }\n  nslots = 1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "quotearg_n_options": {
      "start_point": [
        764,
        0
      ],
      "end_point": [
        822,
        1
      ],
      "content": "static char *\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)\n{\n  int e = errno;\n\n  unsigned int n0 = n;\n  struct slotvec *sv = slotvec;\n\n  if (n < 0)\n    abort ();\n\n  if (nslots <= n0)\n    {\n      /* FIXME: technically, the type of n1 should be 'unsigned int',\n         but that evokes an unsuppressible warning from gcc-4.0.1 and\n         older.  If gcc ever provides an option to suppress that warning,\n         revert to the original type, so that the test in xalloc_oversized\n         is once again performed only at compile time.  */\n      size_t n1 = n0 + 1;\n      bool preallocated = (sv == &slotvec0);\n\n      if (xalloc_oversized (n1, sizeof *sv))\n        xalloc_die ();\n\n      slotvec = sv = xrealloc (preallocated ? NULL : sv, n1 * sizeof *sv);\n      if (preallocated)\n        *sv = slotvec0;\n      memset (sv + nslots, 0, (n1 - nslots) * sizeof *sv);\n      nslots = n1;\n    }\n\n  {\n    size_t size = sv[n].size;\n    char *val = sv[n].val;\n    /* Elide embedded null bytes since we don't return a size.  */\n    int flags = options->flags | QA_ELIDE_NULL_BYTES;\n    size_t qsize = quotearg_buffer_restyled (val, size, arg, argsize,\n                                             options->style, flags,\n                                             options->quote_these_too,\n                                             options->left_quote,\n                                             options->right_quote);\n\n    if (size <= qsize)\n      {\n        sv[n].size = size = qsize + 1;\n        if (val != slot0)\n          free (val);\n        sv[n].val = val = xcharalloc (size);\n        quotearg_buffer_restyled (val, size, arg, argsize, options->style,\n                                  flags, options->quote_these_too,\n                                  options->left_quote,\n                                  options->right_quote);\n      }\n\n    errno = e;\n    return val;\n  }\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nquotearg_n_options (int n, char const *arg, size_t argsize,\n                    struct quoting_options const *options)",
        "*"
      ]
    },
    "quotearg_n": {
      "start_point": [
        824,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "char *\nquotearg_n (int n, char const *arg)\n{\n  return quotearg_n_options (n, arg, SIZE_MAX, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n (int n, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_mem": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "char *\nquotearg_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &default_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "char *\nquotearg (char const *arg)\n{\n  return quotearg_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg (char const *arg)",
        "*"
      ]
    },
    "quotearg_mem": {
      "start_point": [
        842,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "char *\nquotearg_mem (char const *arg, size_t argsize)\n{\n  return quotearg_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_style": {
      "start_point": [
        848,
        0
      ],
      "end_point": [
        853,
        1
      ],
      "content": "char *\nquotearg_n_style (int n, enum quoting_style s, char const *arg)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, SIZE_MAX, &o);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style (int n, enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_style_mem": {
      "start_point": [
        855,
        0
      ],
      "end_point": [
        861,
        1
      ],
      "content": "char *\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)\n{\n  struct quoting_options const o = quoting_options_from_style (s);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_style_mem (int n, enum quoting_style s,\n                      char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_style": {
      "start_point": [
        863,
        0
      ],
      "end_point": [
        867,
        1
      ],
      "content": "char *\nquotearg_style (enum quoting_style s, char const *arg)\n{\n  return quotearg_n_style (0, s, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style (enum quoting_style s, char const *arg)",
        "*"
      ]
    },
    "quotearg_style_mem": {
      "start_point": [
        869,
        0
      ],
      "end_point": [
        873,
        1
      ],
      "content": "char *\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)\n{\n  return quotearg_n_style_mem (0, s, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_style_mem (enum quoting_style s, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_char_mem": {
      "start_point": [
        875,
        0
      ],
      "end_point": [
        882,
        1
      ],
      "content": "char *\nquotearg_char_mem (char const *arg, size_t argsize, char ch)\n{\n  struct quoting_options options;\n  options = default_quoting_options;\n  set_char_quoting (&options, ch, 1);\n  return quotearg_n_options (0, arg, argsize, &options);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char_mem (char const *arg, size_t argsize, char ch)",
        "*"
      ]
    },
    "quotearg_char": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "char *\nquotearg_char (char const *arg, char ch)\n{\n  return quotearg_char_mem (arg, SIZE_MAX, ch);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_char (char const *arg, char ch)",
        "*"
      ]
    },
    "quotearg_colon": {
      "start_point": [
        890,
        0
      ],
      "end_point": [
        894,
        1
      ],
      "content": "char *\nquotearg_colon (char const *arg)\n{\n  return quotearg_char (arg, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon (char const *arg)",
        "*"
      ]
    },
    "quotearg_colon_mem": {
      "start_point": [
        896,
        0
      ],
      "end_point": [
        900,
        1
      ],
      "content": "char *\nquotearg_colon_mem (char const *arg, size_t argsize)\n{\n  return quotearg_char_mem (arg, argsize, ':');\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_colon_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_n_custom": {
      "start_point": [
        902,
        0
      ],
      "end_point": [
        908,
        1
      ],
      "content": "char *\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)\n{\n  return quotearg_n_custom_mem (n, left_quote, right_quote, arg,\n                                SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom (int n, char const *left_quote,\n                   char const *right_quote, char const *arg)",
        "*"
      ]
    },
    "quotearg_n_custom_mem": {
      "start_point": [
        910,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "char *\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)\n{\n  struct quoting_options o = default_quoting_options;\n  set_custom_quoting (&o, left_quote, right_quote);\n  return quotearg_n_options (n, arg, argsize, &o);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_n_custom_mem (int n, char const *left_quote,\n                       char const *right_quote,\n                       char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quotearg_custom": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "char *\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)\n{\n  return quotearg_n_custom (0, left_quote, right_quote, arg);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom (char const *left_quote, char const *right_quote,\n                 char const *arg)",
        "*"
      ]
    },
    "quotearg_custom_mem": {
      "start_point": [
        927,
        0
      ],
      "end_point": [
        933,
        1
      ],
      "content": "char *\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)\n{\n  return quotearg_n_custom_mem (0, left_quote, right_quote, arg,\n                                argsize);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "char",
        "*\nquotearg_custom_mem (char const *left_quote, char const *right_quote,\n                     char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n_mem": {
      "start_point": [
        945,
        0
      ],
      "end_point": [
        949,
        1
      ],
      "content": "char const *\nquote_n_mem (int n, char const *arg, size_t argsize)\n{\n  return quotearg_n_options (n, arg, argsize, &quote_quoting_options);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n_mem (int n, char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_mem": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "char const *\nquote_mem (char const *arg, size_t argsize)\n{\n  return quote_n_mem (0, arg, argsize);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_mem (char const *arg, size_t argsize)",
        "*"
      ]
    },
    "quote_n": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        961,
        1
      ],
      "content": "char const *\nquote_n (int n, char const *arg)\n{\n  return quote_n_mem (n, arg, SIZE_MAX);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote_n (int n, char const *arg)",
        "*"
      ]
    },
    "quote": {
      "start_point": [
        963,
        0
      ],
      "end_point": [
        967,
        1
      ],
      "content": "char const *\nquote (char const *arg)\n{\n  return quote_n (0, arg);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "const",
        "const",
        "*\nquote (char const *arg)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/quotearg.h": {},
  "recutils/recutils-1.7/lib/raise.c": {
    "raise_nothrow": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        42,
        5
      ],
      "content": "static int\nraise_nothrow (int sig)\n{\n  int result;\n\n  TRY_MSVC_INVAL\n    {\n      result = raise (sig);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_raise": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrpl_raise (int sig)\n{\n#if GNULIB_defined_signal_blocking && GNULIB_defined_SIGPIPE\n  if (sig == SIGPIPE)\n    return _gl_raise_SIGPIPE ();\n#endif\n\n#if HAVE_RAISE\n  return raise_nothrow (sig);\n#else\n  return kill (getpid (), sig);\n#endif\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/random_r.c": {
    "__srandom_r": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "int\n__srandom_r (unsigned int seed, struct random_data *buf)\n{\n  int type;\n  int32_t *state;\n  long int i;\n  long int word;\n  int32_t *dst;\n  int kc;\n\n  if (buf == NULL)\n    goto fail;\n  type = buf->rand_type;\n  if ((unsigned int) type >= MAX_TYPES)\n    goto fail;\n\n  state = buf->state;\n  /* We must make sure the seed is not 0.  Take arbitrarily 1 in this case.  */\n  if (seed == 0)\n    seed = 1;\n  state[0] = seed;\n  if (type == TYPE_0)\n    goto done;\n\n  dst = state;\n  word = seed;\n  kc = buf->rand_deg;\n  for (i = 1; i < kc; ++i)\n    {\n      /* This does:\n           state[i] = (16807 * state[i - 1]) % 2147483647;\n         but avoids overflowing 31 bits.  */\n      long int hi = word / 127773;\n      long int lo = word % 127773;\n      word = 16807 * lo - 2836 * hi;\n      if (word < 0)\n        word += 2147483647;\n      *++dst = word;\n    }\n\n  buf->fptr = &state[buf->rand_sep];\n  buf->rptr = &state[0];\n  kc *= 10;\n  while (--kc >= 0)\n    {\n      int32_t discard;\n      (void) __random_r (buf, &discard);\n    }\n\n done:\n  return 0;\n\n fail:\n  return -1;\n}",
      "lines": 55,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "__initstate_r": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\n__initstate_r (unsigned int seed, char *arg_state, size_t n,\n               struct random_data *buf)\n{\n  int32_t *old_state;\n  int32_t *state;\n  int type;\n  int degree;\n  int separation;\n\n  if (buf == NULL)\n    goto fail;\n\n  old_state = buf->state;\n  if (old_state != NULL)\n    {\n      int old_type = buf->rand_type;\n      if (old_type == TYPE_0)\n        old_state[-1] = TYPE_0;\n      else\n        old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n    }\n\n  if (n >= BREAK_3)\n    type = n < BREAK_4 ? TYPE_3 : TYPE_4;\n  else if (n < BREAK_1)\n    {\n      if (n < BREAK_0)\n        {\n          __set_errno (EINVAL);\n          goto fail;\n        }\n      type = TYPE_0;\n    }\n  else\n    type = n < BREAK_2 ? TYPE_1 : TYPE_2;\n\n  degree = random_poly_info.degrees[type];\n  separation = random_poly_info.seps[type];\n\n  buf->rand_type = type;\n  buf->rand_sep = separation;\n  buf->rand_deg = degree;\n  state = &((int32_t *) arg_state)[1];  /* First location.  */\n  /* Must set END_PTR before srandom.  */\n  buf->end_ptr = &state[degree];\n\n  buf->state = state;\n\n  __srandom_r (seed, buf);\n\n  state[-1] = TYPE_0;\n  if (type != TYPE_0)\n    state[-1] = (buf->rptr - state) * MAX_TYPES + type;\n\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "__setstate_r": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\n__setstate_r (char *arg_state, struct random_data *buf)\n{\n  int32_t *new_state = 1 + (int32_t *) arg_state;\n  int type;\n  int old_type;\n  int32_t *old_state;\n  int degree;\n  int separation;\n\n  if (arg_state == NULL || buf == NULL)\n    goto fail;\n\n  old_type = buf->rand_type;\n  old_state = buf->state;\n  if (old_type == TYPE_0)\n    old_state[-1] = TYPE_0;\n  else\n    old_state[-1] = (MAX_TYPES * (buf->rptr - old_state)) + old_type;\n\n  type = new_state[-1] % MAX_TYPES;\n  if (type < TYPE_0 || type > TYPE_4)\n    goto fail;\n\n  buf->rand_deg = degree = random_poly_info.degrees[type];\n  buf->rand_sep = separation = random_poly_info.seps[type];\n  buf->rand_type = type;\n\n  if (type != TYPE_0)\n    {\n      int rear = new_state[-1] / MAX_TYPES;\n      buf->rptr = &new_state[rear];\n      buf->fptr = &new_state[(rear + separation) % degree];\n    }\n  buf->state = new_state;\n  /* Set end_ptr too.  */\n  buf->end_ptr = &new_state[degree];\n\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "__random_r": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "int\n__random_r (struct random_data *buf, int32_t *result)\n{\n  int32_t *state;\n\n  if (buf == NULL || result == NULL)\n    goto fail;\n\n  state = buf->state;\n\n  if (buf->rand_type == TYPE_0)\n    {\n      int32_t val = state[0];\n      val = ((state[0] * 1103515245) + 12345) & 0x7fffffff;\n      state[0] = val;\n      *result = val;\n    }\n  else\n    {\n      int32_t *fptr = buf->fptr;\n      int32_t *rptr = buf->rptr;\n      int32_t *end_ptr = buf->end_ptr;\n      int32_t val;\n\n      val = *fptr += *rptr;\n      /* Chucking least random bit.  */\n      *result = (val >> 1) & 0x7fffffff;\n      ++fptr;\n      if (fptr >= end_ptr)\n        {\n          fptr = state;\n          ++rptr;\n        }\n      else\n        {\n          ++rptr;\n          if (rptr >= end_ptr)\n            rptr = state;\n        }\n      buf->fptr = fptr;\n      buf->rptr = rptr;\n    }\n  return 0;\n\n fail:\n  __set_errno (EINVAL);\n  return -1;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/rawmemchr.c": {
    "rawmemchr": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void *\nrawmemchr (const void *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (*char_ptr == c)\n      return (void *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 is zero.\n\n     We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 is zero is equivalent\n     to testing whether tmp is nonzero.\n\n     This test can read beyond the end of a string, depending on where\n     C_IN is encountered.  However, this is considered safe since the\n     initialization phase ensured that the read will be aligned,\n     therefore, the read will not cross page boundaries and will not\n     cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n\n      if ((((longword1 - repeated_one) & ~longword1)\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == c.  On little-endian machines, we\n     could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr != c)\n    char_ptr++;\n  return (void *) char_ptr;\n}",
      "lines": 114,
      "depth": 14,
      "decorators": [
        "void",
        "*\nrawmemchr (const void *s, int c_in)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/read-file.c": {
    "fread_file": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "char *\nfread_file (FILE *stream, size_t *length)\n{\n  char *buf = NULL;\n  size_t alloc = BUFSIZ;\n\n  /* For a regular file, allocate a buffer that has exactly the right\n     size.  This avoids the need to do dynamic reallocations later.  */\n  {\n    struct stat st;\n\n    if (fstat (fileno (stream), &st) >= 0 && S_ISREG (st.st_mode))\n      {\n        off_t pos = ftello (stream);\n\n        if (pos >= 0 && pos < st.st_size)\n          {\n            off_t alloc_off = st.st_size - pos;\n\n            /* '1' below, accounts for the trailing NUL.  */\n            if (SIZE_MAX - 1 < alloc_off)\n              {\n                errno = ENOMEM;\n                return NULL;\n              }\n\n            alloc = alloc_off + 1;\n          }\n      }\n  }\n\n  if (!(buf = malloc (alloc)))\n    return NULL; /* errno is ENOMEM.  */\n\n  {\n    size_t size = 0; /* number of bytes read so far */\n    int save_errno;\n\n    for (;;)\n      {\n        /* This reads 1 more than the size of a regular file\n           so that we get eof immediately.  */\n        size_t requested = alloc - size;\n        size_t count = fread (buf + size, 1, requested, stream);\n        size += count;\n\n        if (count != requested)\n          {\n            save_errno = errno;\n            if (ferror (stream))\n              break;\n\n            /* Shrink the allocated memory if possible.  */\n            if (size < alloc - 1)\n              {\n                char *smaller_buf = realloc (buf, size + 1);\n                if (smaller_buf != NULL)\n                  buf = smaller_buf;\n              }\n\n            buf[size] = '\\0';\n            *length = size;\n            return buf;\n          }\n\n        {\n          char *new_buf;\n\n          if (alloc == SIZE_MAX)\n            {\n              save_errno = ENOMEM;\n              break;\n            }\n\n          if (alloc < SIZE_MAX - alloc / 2)\n            alloc = alloc + alloc / 2;\n          else\n            alloc = SIZE_MAX;\n\n          if (!(new_buf = realloc (buf, alloc)))\n            {\n              save_errno = errno;\n              break;\n            }\n\n          buf = new_buf;\n        }\n      }\n\n    free (buf);\n    errno = save_errno;\n    return NULL;\n  }\n}",
      "lines": 94,
      "depth": 15,
      "decorators": [
        "char",
        "*\nfread_file (FILE *stream, size_t *length)",
        "*"
      ]
    },
    "internal_read_file": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static char *\ninternal_read_file (const char *filename, size_t *length, const char *mode)\n{\n  FILE *stream = fopen (filename, mode);\n  char *out;\n  int save_errno;\n\n  if (!stream)\n    return NULL;\n\n  out = fread_file (stream, length);\n\n  save_errno = errno;\n\n  if (fclose (stream) != 0)\n    {\n      if (out)\n        {\n          save_errno = errno;\n          free (out);\n        }\n      errno = save_errno;\n      return NULL;\n    }\n\n  return out;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\ninternal_read_file (const char *filename, size_t *length, const char *mode)",
        "*"
      ]
    },
    "read_file": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "char *\nread_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"r\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_file (const char *filename, size_t *length)",
        "*"
      ]
    },
    "read_binary_file": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "char *\nread_binary_file (const char *filename, size_t *length)\n{\n  return internal_read_file (filename, length, \"rb\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "char",
        "*\nread_binary_file (const char *filename, size_t *length)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/read-file.h": {},
  "recutils/recutils-1.7/lib/readline.c": {
    "readline": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "char *\nreadline (const char *prompt)\n{\n  char *out = NULL;\n  size_t size = 0;\n\n  if (prompt)\n    {\n      fputs (prompt, stdout);\n      fflush (stdout);\n    }\n\n  if (getline (&out, &size, stdin) < 0)\n    return NULL;\n\n  while (*out && (out[strlen (out) - 1] == '\\r'\n                  || out[strlen (out) - 1] == '\\n'))\n    out[strlen (out) - 1] = '\\0';\n\n  return out;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "char",
        "*\nreadline (const char *prompt)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/readline.h": {},
  "recutils/recutils-1.7/lib/readlink.c": {
    "readlink": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "ssize_t\nreadlink (const char *name, char *buf _GL_UNUSED,\n          size_t bufsize _GL_UNUSED)\n{\n  struct stat statbuf;\n\n  /* In general we should use lstat() here, not stat().  But on platforms\n     without symbolic links, lstat() - if it exists - would be equivalent to\n     stat(), therefore we can use stat().  This saves us a configure check.  */\n  if (stat (name, &statbuf) >= 0)\n    errno = EINVAL;\n  return -1;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "ssize_t"
      ]
    },
    "rpl_readlink": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "ssize_t\nrpl_readlink (const char *name, char *buf, size_t bufsize)\n{\n# if READLINK_TRAILING_SLASH_BUG\n  size_t len = strlen (name);\n  if (len && name[len - 1] == '/')\n    {\n      /* Even if name without the slash is a symlink to a directory,\n         both lstat() and stat() must resolve the trailing slash to\n         the directory rather than the symlink.  We can therefore\n         safely use stat() to distinguish between EINVAL and\n         ENOTDIR/ENOENT, avoiding extra overhead of rpl_lstat().  */\n      struct stat st;\n      if (stat (name, &st) == 0)\n        errno = EINVAL;\n      return -1;\n    }\n# endif /* READLINK_TRAILING_SLASH_BUG */\n  return readlink (name, buf, bufsize);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "ssize_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/realloc.c": {
    "rpl_realloc": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void *\nrpl_realloc (void *p, size_t n)\n{\n  void *result;\n\n#if NEED_REALLOC_GNU\n  if (n == 0)\n    {\n      n = 1;\n\n      /* In theory realloc might fail, so don't rely on it to free.  */\n      free (p);\n      p = NULL;\n    }\n#endif\n\n  if (p == NULL)\n    {\n#if GNULIB_REALLOC_GNU && !NEED_REALLOC_GNU && !SYSTEM_MALLOC_GLIBC_COMPATIBLE\n      if (n == 0)\n        n = 1;\n#endif\n      result = malloc (n);\n    }\n  else\n    result = realloc (p, n);\n\n#if !HAVE_REALLOC_POSIX\n  if (result == NULL)\n    errno = ENOMEM;\n#endif\n\n  return result;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void",
        "*\nrpl_realloc (void *p, size_t n)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/regcomp.c": {
    "re_set_fastmap": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static inline void\n__attribute__ ((always_inline))\nre_set_fastmap (char *fastmap, bool icase, int ch)\n{\n  fastmap[ch] = 1;\n  if (icase)\n    fastmap[tolower (ch)] = 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "re_compile_fastmap_iter": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static void\nre_compile_fastmap_iter (regex_t *bufp, const re_dfastate_t *init_state,\n\t\t\t char *fastmap)\n{\n  re_dfa_t *dfa = bufp->buffer;\n  Idx node_cnt;\n  bool icase = (dfa->mb_cur_max == 1 && (bufp->syntax & RE_ICASE));\n  for (node_cnt = 0; node_cnt < init_state->nodes.nelem; ++node_cnt)\n    {\n      Idx node = init_state->nodes.elems[node_cnt];\n      re_token_type_t type = dfa->nodes[node].type;\n\n      if (type == CHARACTER)\n\t{\n\t  re_set_fastmap (fastmap, icase, dfa->nodes[node].opr.c);\n#ifdef RE_ENABLE_I18N\n\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t    {\n\t      unsigned char buf[MB_LEN_MAX];\n\t      unsigned char *p;\n\t      wchar_t wc;\n\t      mbstate_t state;\n\n\t      p = buf;\n\t      *p++ = dfa->nodes[node].opr.c;\n\t      while (++node < dfa->nodes_len\n\t\t     &&\tdfa->nodes[node].type == CHARACTER\n\t\t     && dfa->nodes[node].mb_partial)\n\t\t*p++ = dfa->nodes[node].opr.c;\n\t      memset (&state, '\\0', sizeof (state));\n\t      if (__mbrtowc (&wc, (const char *) buf, p - buf,\n\t\t\t     &state) == p - buf\n\t\t  && (__wcrtomb ((char *) buf, towlower (wc), &state)\n\t\t      != (size_t) -1))\n\t\tre_set_fastmap (fastmap, false, buf[0]);\n\t    }\n#endif\n\t}\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  int i, ch;\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    {\n\t      int j;\n\t      bitset_word_t w = dfa->nodes[node].opr.sbcset[i];\n\t      for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t\tif (w & ((bitset_word_t) 1 << j))\n\t\t  re_set_fastmap (fastmap, icase, ch);\n\t    }\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == COMPLEX_BRACKET)\n\t{\n\t  re_charset_t *cset = dfa->nodes[node].opr.mbcset;\n\t  Idx i;\n\n# ifdef _LIBC\n\t  /* See if we have to try all bytes which start multiple collation\n\t     elements.\n\t     e.g. In da_DK, we want to catch 'a' since \"aa\" is a valid\n\t\t  collation element, and don't catch 'b' since 'b' is\n\t\t  the only collation element which starts from 'b' (and\n\t\t  it is caught by SIMPLE_BRACKET).  */\n\t      if (_NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES) != 0\n\t\t  && (cset->ncoll_syms || cset->nranges))\n\t\t{\n\t\t  const int32_t *table = (const int32_t *)\n\t\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t\t  for (i = 0; i < SBC_MAX; ++i)\n\t\t    if (table[i] < 0)\n\t\t      re_set_fastmap (fastmap, icase, i);\n\t\t}\n# endif /* _LIBC */\n\n\t  /* See if we have to start the match at all multibyte characters,\n\t     i.e. where we would not find an invalid sequence.  This only\n\t     applies to multibyte character sets; for single byte character\n\t     sets, the SIMPLE_BRACKET again suffices.  */\n\t  if (dfa->mb_cur_max > 1\n\t      && (cset->nchar_classes || cset->non_match || cset->nranges\n# ifdef _LIBC\n\t\t  || cset->nequiv_classes\n# endif /* _LIBC */\n\t\t ))\n\t    {\n\t      unsigned char c = 0;\n\t      do\n\t\t{\n\t\t  mbstate_t mbs;\n\t\t  memset (&mbs, 0, sizeof (mbs));\n\t\t  if (__mbrtowc (NULL, (char *) &c, 1, &mbs) == (size_t) -2)\n\t\t    re_set_fastmap (fastmap, false, (int) c);\n\t\t}\n\t      while (++c != 0);\n\t    }\n\n\t  else\n\t    {\n\t      /* ... Else catch all bytes which can start the mbchars.  */\n\t      for (i = 0; i < cset->nmbchars; ++i)\n\t\t{\n\t\t  char buf[256];\n\t\t  mbstate_t state;\n\t\t  memset (&state, '\\0', sizeof (state));\n\t\t  if (__wcrtomb (buf, cset->mbchars[i], &state) != (size_t) -1)\n\t\t    re_set_fastmap (fastmap, icase, *(unsigned char *) buf);\n\t\t  if ((bufp->syntax & RE_ICASE) && dfa->mb_cur_max > 1)\n\t\t    {\n\t\t      if (__wcrtomb (buf, towlower (cset->mbchars[i]), &state)\n\t\t\t  != (size_t) -1)\n\t\t\tre_set_fastmap (fastmap, false, *(unsigned char *) buf);\n\t\t    }\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      else if (type == OP_PERIOD\n#ifdef RE_ENABLE_I18N\n\t       || type == OP_UTF8_PERIOD\n#endif /* RE_ENABLE_I18N */\n\t       || type == END_OF_RE)\n\t{\n\t  memset (fastmap, '\\1', sizeof (char) * SBC_MAX);\n\t  if (type == END_OF_RE)\n\t    bufp->can_be_null = 1;\n\t  return;\n\t}\n    }\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "regerror": {
      "start_point": [
        541,
        0
      ],
      "end_point": [
        574,
        1
      ],
      "content": "size_t\nregerror (int errcode, const regex_t *_Restrict_ preg,\n\t  char *_Restrict_ errbuf, size_t errbuf_size)\n#endif\n{\n  const char *msg;\n  size_t msg_size;\n\n  if (BE (errcode < 0\n\t  || errcode >= (int) (sizeof (__re_error_msgid_idx)\n\t\t\t       / sizeof (__re_error_msgid_idx[0])), 0))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (BE (errbuf_size != 0, 1))\n    {\n      size_t cpy_size = msg_size;\n      if (BE (msg_size > errbuf_size, 0))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "free_dfa_content": {
      "start_point": [
        609,
        0
      ],
      "end_point": [
        654,
        1
      ],
      "content": "static void\nfree_dfa_content (re_dfa_t *dfa)\n{\n  Idx i, j;\n\n  if (dfa->nodes)\n    for (i = 0; i < dfa->nodes_len; ++i)\n      free_token (dfa->nodes + i);\n  re_free (dfa->nexts);\n  for (i = 0; i < dfa->nodes_len; ++i)\n    {\n      if (dfa->eclosures != NULL)\n\tre_node_set_free (dfa->eclosures + i);\n      if (dfa->inveclosures != NULL)\n\tre_node_set_free (dfa->inveclosures + i);\n      if (dfa->edests != NULL)\n\tre_node_set_free (dfa->edests + i);\n    }\n  re_free (dfa->edests);\n  re_free (dfa->eclosures);\n  re_free (dfa->inveclosures);\n  re_free (dfa->nodes);\n\n  if (dfa->state_table)\n    for (i = 0; i <= dfa->state_hash_mask; ++i)\n      {\n\tstruct re_state_table_entry *entry = dfa->state_table + i;\n\tfor (j = 0; j < entry->num; ++j)\n\t  {\n\t    re_dfastate_t *state = entry->array[j];\n\t    free_state (state);\n\t  }\n\tre_free (entry->array);\n      }\n  re_free (dfa->state_table);\n#ifdef RE_ENABLE_I18N\n  if (dfa->sb_char != utf8_sb_map)\n    re_free (dfa->sb_char);\n#endif\n  re_free (dfa->subexp_map);\n#ifdef DEBUG\n  re_free (dfa->re_str);\n#endif\n\n  re_free (dfa);\n}",
      "lines": 46,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_mem": {
      "start_point": [
        743,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "libc_freeres_fn (free_mem)\n{\n  __regfree (&re_comp_buf);\n}",
      "lines": 4,
      "depth": 7,
      "decorators": null
    },
    "re_compile_internal": {
      "start_point": [
        755,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "static reg_errcode_t\nre_compile_internal (regex_t *preg, const char * pattern, size_t length,\n\t\t     reg_syntax_t syntax)\n{\n  reg_errcode_t err = REG_NOERROR;\n  re_dfa_t *dfa;\n  re_string_t regexp;\n\n  /* Initialize the pattern buffer.  */\n  preg->fastmap_accurate = 0;\n  preg->syntax = syntax;\n  preg->not_bol = preg->not_eol = 0;\n  preg->used = 0;\n  preg->re_nsub = 0;\n  preg->can_be_null = 0;\n  preg->regs_allocated = REGS_UNALLOCATED;\n\n  /* Initialize the dfa.  */\n  dfa = preg->buffer;\n  if (BE (preg->allocated < sizeof (re_dfa_t), 0))\n    {\n      /* If zero allocated, but buffer is non-null, try to realloc\n\t enough space.  This loses if buffer's address is bogus, but\n\t that is the user's responsibility.  If ->buffer is NULL this\n\t is a simple allocation.  */\n      dfa = re_realloc (preg->buffer, re_dfa_t, 1);\n      if (dfa == NULL)\n\treturn REG_ESPACE;\n      preg->allocated = sizeof (re_dfa_t);\n      preg->buffer = dfa;\n    }\n  preg->used = sizeof (re_dfa_t);\n\n  err = init_dfa (dfa, length);\n  if (BE (err == REG_NOERROR && lock_init (dfa->lock) != 0, 0))\n    err = REG_ESPACE;\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n#ifdef DEBUG\n  /* Note: length+1 will not overflow since it is checked in init_dfa.  */\n  dfa->re_str = re_malloc (char, length + 1);\n  strncpy (dfa->re_str, pattern, length + 1);\n#endif\n\n  err = re_string_construct (&regexp, pattern, length, preg->translate,\n\t\t\t     (syntax & RE_ICASE) != 0, dfa);\n  if (BE (err != REG_NOERROR, 0))\n    {\n    re_compile_internal_free_return:\n      free_workarea_compile (preg);\n      re_string_destruct (&regexp);\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n      return err;\n    }\n\n  /* Parse the regular expression, and build a structure tree.  */\n  preg->re_nsub = 0;\n  dfa->str_tree = parse (&regexp, preg, syntax, &err);\n  if (BE (dfa->str_tree == NULL, 0))\n    goto re_compile_internal_free_return;\n\n  /* Analyze the tree and create the nfa.  */\n  err = analyze (preg);\n  if (BE (err != REG_NOERROR, 0))\n    goto re_compile_internal_free_return;\n\n#ifdef RE_ENABLE_I18N\n  /* If possible, do searching in single byte encoding to speed things up.  */\n  if (dfa->is_utf8 && !(syntax & RE_ICASE) && preg->translate == NULL)\n    optimize_utf8 (dfa);\n#endif\n\n  /* Then create the initial state of the dfa.  */\n  err = create_initial_state (dfa);\n\n  /* Release work areas.  */\n  free_workarea_compile (preg);\n  re_string_destruct (&regexp);\n\n  if (BE (err != REG_NOERROR, 0))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n      preg->buffer = NULL;\n      preg->allocated = 0;\n    }\n\n  return err;\n}",
      "lines": 97,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_dfa": {
      "start_point": [
        856,
        0
      ],
      "end_point": [
        950,
        1
      ],
      "content": "static reg_errcode_t\ninit_dfa (re_dfa_t *dfa, size_t pat_len)\n{\n  __re_size_t table_size;\n#ifndef _LIBC\n  const char *codeset_name;\n#endif\n#ifdef RE_ENABLE_I18N\n  size_t max_i18n_object_size = MAX (sizeof (wchar_t), sizeof (wctype_t));\n#else\n  size_t max_i18n_object_size = 0;\n#endif\n  size_t max_object_size =\n    MAX (sizeof (struct re_state_table_entry),\n\t MAX (sizeof (re_token_t),\n\t      MAX (sizeof (re_node_set),\n\t\t   MAX (sizeof (regmatch_t),\n\t\t\tmax_i18n_object_size))));\n\n  memset (dfa, '\\0', sizeof (re_dfa_t));\n\n  /* Force allocation of str_tree_storage the first time.  */\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n\n  /* Avoid overflows.  The extra \"/ 2\" is for the table_size doubling\n     calculation below, and for similar doubling calculations\n     elsewhere.  And it's <= rather than <, because some of the\n     doubling calculations add 1 afterwards.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) / 2 <= pat_len, 0))\n    return REG_ESPACE;\n\n  dfa->nodes_alloc = pat_len + 1;\n  dfa->nodes = re_malloc (re_token_t, dfa->nodes_alloc);\n\n  /*  table_size = 2 ^ ceil(log pat_len) */\n  for (table_size = 1; ; table_size <<= 1)\n    if (table_size > pat_len)\n      break;\n\n  dfa->state_table = calloc (sizeof (struct re_state_table_entry), table_size);\n  dfa->state_hash_mask = table_size - 1;\n\n  dfa->mb_cur_max = MB_CUR_MAX;\n#ifdef _LIBC\n  if (dfa->mb_cur_max == 6\n      && strcmp (_NL_CURRENT (LC_CTYPE, _NL_CTYPE_CODESET_NAME), \"UTF-8\") == 0)\n    dfa->is_utf8 = 1;\n  dfa->map_notascii = (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_MAP_TO_NONASCII)\n\t\t       != 0);\n#else\n  codeset_name = nl_langinfo (CODESET);\n  if ((codeset_name[0] == 'U' || codeset_name[0] == 'u')\n      && (codeset_name[1] == 'T' || codeset_name[1] == 't')\n      && (codeset_name[2] == 'F' || codeset_name[2] == 'f')\n      && strcmp (codeset_name + 3 + (codeset_name[3] == '-'), \"8\") == 0)\n    dfa->is_utf8 = 1;\n\n  /* We check exhaustively in the loop below if this charset is a\n     superset of ASCII.  */\n  dfa->map_notascii = 0;\n#endif\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      if (dfa->is_utf8)\n\tdfa->sb_char = (re_bitset_ptr_t) utf8_sb_map;\n      else\n\t{\n\t  int i, j, ch;\n\n\t  dfa->sb_char = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n\t  if (BE (dfa->sb_char == NULL, 0))\n\t    return REG_ESPACE;\n\n\t  /* Set the bits corresponding to single byte chars.  */\n\t  for (i = 0, ch = 0; i < BITSET_WORDS; ++i)\n\t    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n\t      {\n\t\twint_t wch = __btowc (ch);\n\t\tif (wch != WEOF)\n\t\t  dfa->sb_char[i] |= (bitset_word_t) 1 << j;\n# ifndef _LIBC\n\t\tif (isascii (ch) && wch != ch)\n\t\t  dfa->map_notascii = 1;\n# endif\n\t      }\n\t}\n    }\n#endif\n\n  if (BE (dfa->nodes == NULL || dfa->state_table == NULL, 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "init_word_char": {
      "start_point": [
        956,
        0
      ],
      "end_point": [
        1000,
        1
      ],
      "content": "static void\ninternal_function\ninit_word_char (re_dfa_t *dfa)\n{\n  int i = 0;\n  int j;\n  int ch = 0;\n  dfa->word_ops_used = 1;\n  if (BE (dfa->map_notascii == 0, 1))\n    {\n      bitset_word_t bits0 = 0x00000000;\n      bitset_word_t bits1 = 0x03ff0000;\n      bitset_word_t bits2 = 0x87fffffe;\n      bitset_word_t bits3 = 0x07fffffe;\n      if (BITSET_WORD_BITS == 64)\n\t{\n\t  dfa->word_char[0] = bits1 << 31 << 1 | bits0;\n\t  dfa->word_char[1] = bits3 << 31 << 1 | bits2;\n\t  i = 2;\n\t}\n      else if (BITSET_WORD_BITS == 32)\n\t{\n\t  dfa->word_char[0] = bits0;\n\t  dfa->word_char[1] = bits1;\n\t  dfa->word_char[2] = bits2;\n\t  dfa->word_char[3] = bits3;\n\t  i = 4;\n\t}\n      else\n        goto general_case;\n      ch = 128;\n\n      if (BE (dfa->is_utf8, 1))\n\t{\n\t  memset (&dfa->word_char[i], '\\0', (SBC_MAX - ch) / 8);\n\t  return;\n\t}\n    }\n\n general_case:\n  for (; i < BITSET_WORDS; ++i)\n    for (j = 0; j < BITSET_WORD_BITS; ++j, ++ch)\n      if (isalnum (ch) || ch == '_')\n\tdfa->word_char[i] |= (bitset_word_t) 1 << j;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "free_workarea_compile": {
      "start_point": [
        1004,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "static void\nfree_workarea_compile (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_storage_t *storage, *next;\n  for (storage = dfa->str_tree_storage; storage; storage = next)\n    {\n      next = storage->next;\n      re_free (storage);\n    }\n  dfa->str_tree_storage = NULL;\n  dfa->str_tree_storage_idx = BIN_TREE_STORAGE_SIZE;\n  dfa->str_tree = NULL;\n  re_free (dfa->org_indices);\n  dfa->org_indices = NULL;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_initial_state": {
      "start_point": [
        1023,
        0
      ],
      "end_point": [
        1101,
        1
      ],
      "content": "static reg_errcode_t\ncreate_initial_state (re_dfa_t *dfa)\n{\n  Idx first, i;\n  reg_errcode_t err;\n  re_node_set init_nodes;\n\n  /* Initial states have the epsilon closure of the node which is\n     the first node of the regular expression.  */\n  first = dfa->str_tree->first->node_idx;\n  dfa->init_node = first;\n  err = re_node_set_init_copy (&init_nodes, dfa->eclosures + first);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* The back-references which are in initial states can epsilon transit,\n     since in this case all of the subexpressions can be null.\n     Then we add epsilon closures of the nodes which are the next nodes of\n     the back-references.  */\n  if (dfa->nbackref > 0)\n    for (i = 0; i < init_nodes.nelem; ++i)\n      {\n\tIdx node_idx = init_nodes.elems[i];\n\tre_token_type_t type = dfa->nodes[node_idx].type;\n\n\tIdx clexp_idx;\n\tif (type != OP_BACK_REF)\n\t  continue;\n\tfor (clexp_idx = 0; clexp_idx < init_nodes.nelem; ++clexp_idx)\n\t  {\n\t    re_token_t *clexp_node;\n\t    clexp_node = dfa->nodes + init_nodes.elems[clexp_idx];\n\t    if (clexp_node->type == OP_CLOSE_SUBEXP\n\t\t&& clexp_node->opr.idx == dfa->nodes[node_idx].opr.idx)\n\t      break;\n\t  }\n\tif (clexp_idx == init_nodes.nelem)\n\t  continue;\n\n\tif (type == OP_BACK_REF)\n\t  {\n\t    Idx dest_idx = dfa->edests[node_idx].elems[0];\n\t    if (!re_node_set_contains (&init_nodes, dest_idx))\n\t      {\n\t\treg_errcode_t merge_err\n                  = re_node_set_merge (&init_nodes, dfa->eclosures + dest_idx);\n\t\tif (merge_err != REG_NOERROR)\n\t\t  return merge_err;\n\t\ti = 0;\n\t      }\n\t  }\n      }\n\n  /* It must be the first time to invoke acquire_state.  */\n  dfa->init_state = re_acquire_state_context (&err, dfa, &init_nodes, 0);\n  /* We don't check ERR here, since the initial state must not be NULL.  */\n  if (BE (dfa->init_state == NULL, 0))\n    return err;\n  if (dfa->init_state->has_constraint)\n    {\n      dfa->init_state_word = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t       CONTEXT_WORD);\n      dfa->init_state_nl = re_acquire_state_context (&err, dfa, &init_nodes,\n\t\t\t\t\t\t     CONTEXT_NEWLINE);\n      dfa->init_state_begbuf = re_acquire_state_context (&err, dfa,\n\t\t\t\t\t\t\t &init_nodes,\n\t\t\t\t\t\t\t CONTEXT_NEWLINE\n\t\t\t\t\t\t\t | CONTEXT_BEGBUF);\n      if (BE (dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t      || dfa->init_state_begbuf == NULL, 0))\n\treturn err;\n    }\n  else\n    dfa->init_state_word = dfa->init_state_nl\n      = dfa->init_state_begbuf = dfa->init_state;\n\n  re_node_set_free (&init_nodes);\n  return REG_NOERROR;\n}",
      "lines": 79,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_utf8": {
      "start_point": [
        1108,
        0
      ],
      "end_point": [
        1182,
        1
      ],
      "content": "static void\noptimize_utf8 (re_dfa_t *dfa)\n{\n  Idx node;\n  int i;\n  bool mb_chars = false;\n  bool has_period = false;\n\n  for (node = 0; node < dfa->nodes_len; ++node)\n    switch (dfa->nodes[node].type)\n      {\n      case CHARACTER:\n\tif (dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  mb_chars = true;\n\tbreak;\n      case ANCHOR:\n\tswitch (dfa->nodes[node].opr.ctx_type)\n\t  {\n\t  case LINE_FIRST:\n\t  case LINE_LAST:\n\t  case BUF_FIRST:\n\t  case BUF_LAST:\n\t    break;\n\t  default:\n\t    /* Word anchors etc. cannot be handled.  It's okay to test\n\t       opr.ctx_type since constraints (for all DFA nodes) are\n\t       created by ORing one or more opr.ctx_type values.  */\n\t    return;\n\t  }\n\tbreak;\n      case OP_PERIOD:\n\thas_period = true;\n\tbreak;\n      case OP_BACK_REF:\n      case OP_ALT:\n      case END_OF_RE:\n      case OP_DUP_ASTERISK:\n      case OP_OPEN_SUBEXP:\n      case OP_CLOSE_SUBEXP:\n\tbreak;\n      case COMPLEX_BRACKET:\n\treturn;\n      case SIMPLE_BRACKET:\n\t/* Just double check.  */\n\t{\n\t  int rshift = (ASCII_CHARS % BITSET_WORD_BITS == 0\n\t\t\t? 0\n\t\t\t: BITSET_WORD_BITS - ASCII_CHARS % BITSET_WORD_BITS);\n\t  for (i = ASCII_CHARS / BITSET_WORD_BITS; i < BITSET_WORDS; ++i)\n\t    {\n\t      if (dfa->nodes[node].opr.sbcset[i] >> rshift != 0)\n\t\treturn;\n\t      rshift = 0;\n\t    }\n\t}\n\tbreak;\n      default:\n\tabort ();\n      }\n\n  if (mb_chars || has_period)\n    for (node = 0; node < dfa->nodes_len; ++node)\n      {\n\tif (dfa->nodes[node].type == CHARACTER\n\t    && dfa->nodes[node].opr.c >= ASCII_CHARS)\n\t  dfa->nodes[node].mb_partial = 0;\n\telse if (dfa->nodes[node].type == OP_PERIOD)\n\t  dfa->nodes[node].type = OP_UTF8_PERIOD;\n      }\n\n  /* The search can be in single byte locale.  */\n  dfa->mb_cur_max = 1;\n  dfa->is_utf8 = 0;\n  dfa->has_mb_node = dfa->nbackref > 0 || has_period;\n}",
      "lines": 75,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "analyze": {
      "start_point": [
        1188,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static reg_errcode_t\nanalyze (regex_t *preg)\n{\n  re_dfa_t *dfa = preg->buffer;\n  reg_errcode_t ret;\n\n  /* Allocate arrays.  */\n  dfa->nexts = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->org_indices = re_malloc (Idx, dfa->nodes_alloc);\n  dfa->edests = re_malloc (re_node_set, dfa->nodes_alloc);\n  dfa->eclosures = re_malloc (re_node_set, dfa->nodes_alloc);\n  if (BE (dfa->nexts == NULL || dfa->org_indices == NULL || dfa->edests == NULL\n\t  || dfa->eclosures == NULL, 0))\n    return REG_ESPACE;\n\n  dfa->subexp_map = re_malloc (Idx, preg->re_nsub);\n  if (dfa->subexp_map != NULL)\n    {\n      Idx i;\n      for (i = 0; i < preg->re_nsub; i++)\n\tdfa->subexp_map[i] = i;\n      preorder (dfa->str_tree, optimize_subexps, dfa);\n      for (i = 0; i < preg->re_nsub; i++)\n\tif (dfa->subexp_map[i] != i)\n\t  break;\n      if (i == preg->re_nsub)\n\t{\n\t  free (dfa->subexp_map);\n\t  dfa->subexp_map = NULL;\n\t}\n    }\n\n  ret = postorder (dfa->str_tree, lower_subexps, preg);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = postorder (dfa->str_tree, calc_first, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  preorder (dfa->str_tree, calc_next, dfa);\n  ret = preorder (dfa->str_tree, link_nfa_nodes, dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n  ret = calc_eclosure (dfa);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  /* We only need this during the prune_impossible_nodes pass in regexec.c;\n     skip it if p_i_n will not run, as calc_inveclosure can be quadratic.  */\n  if ((!preg->no_sub && preg->re_nsub > 0 && dfa->has_plural_match)\n      || dfa->nbackref)\n    {\n      dfa->inveclosures = re_malloc (re_node_set, dfa->nodes_len);\n      if (BE (dfa->inveclosures == NULL, 0))\n\treturn REG_ESPACE;\n      ret = calc_inveclosure (dfa);\n    }\n\n  return ret;\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "postorder": {
      "start_point": [
        1251,
        0
      ],
      "end_point": [
        1281,
        1
      ],
      "content": "static reg_errcode_t\npostorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t   void *extra)\n{\n  bin_tree_t *node, *prev;\n\n  for (node = root; ; )\n    {\n      /* Descend down the tree, preferably to the left (or to the right\n\t if that's the only child).  */\n      while (node->left || node->right)\n\tif (node->left)\n\t  node = node->left;\n\telse\n\t  node = node->right;\n\n      do\n\t{\n\t  reg_errcode_t err = fn (extra, node);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  if (node->parent == NULL)\n\t    return REG_NOERROR;\n\t  prev = node;\n\t  node = node->parent;\n\t}\n      /* Go up while we have a node that is reached from the right.  */\n      while (node->right == prev || node->right == NULL);\n      node = node->right;\n    }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "preorder": {
      "start_point": [
        1283,
        0
      ],
      "end_point": [
        1311,
        1
      ],
      "content": "static reg_errcode_t\npreorder (bin_tree_t *root, reg_errcode_t (fn (void *, bin_tree_t *)),\n\t  void *extra)\n{\n  bin_tree_t *node;\n\n  for (node = root; ; )\n    {\n      reg_errcode_t err = fn (extra, node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\tnode = node->left;\n      else\n\t{\n\t  bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      if (!node)\n\t\treturn REG_NOERROR;\n\t    }\n\t  node = node->right;\n\t}\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "optimize_subexps": {
      "start_point": [
        1316,
        0
      ],
      "end_point": [
        1343,
        1
      ],
      "content": "static reg_errcode_t\noptimize_subexps (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n\n  if (node->token.type == OP_BACK_REF && dfa->subexp_map)\n    {\n      int idx = node->token.opr.idx;\n      node->token.opr.idx = dfa->subexp_map[idx];\n      dfa->used_bkref_map |= 1 << node->token.opr.idx;\n    }\n\n  else if (node->token.type == SUBEXP\n\t   && node->left && node->left->token.type == SUBEXP)\n    {\n      Idx other_idx = node->left->token.opr.idx;\n\n      node->left = node->left->left;\n      if (node->left)\n\tnode->left->parent = node;\n\n      dfa->subexp_map[other_idx] = dfa->subexp_map[node->token.opr.idx];\n      if (other_idx < BITSET_WORD_BITS)\n\tdfa->used_bkref_map &= ~((bitset_word_t) 1 << other_idx);\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexps": {
      "start_point": [
        1347,
        0
      ],
      "end_point": [
        1367,
        1
      ],
      "content": "static reg_errcode_t\nlower_subexps (void *extra, bin_tree_t *node)\n{\n  regex_t *preg = (regex_t *) extra;\n  reg_errcode_t err = REG_NOERROR;\n\n  if (node->left && node->left->token.type == SUBEXP)\n    {\n      node->left = lower_subexp (&err, preg, node->left);\n      if (node->left)\n\tnode->left->parent = node;\n    }\n  if (node->right && node->right->token.type == SUBEXP)\n    {\n      node->right = lower_subexp (&err, preg, node->right);\n      if (node->right)\n\tnode->right->parent = node;\n    }\n\n  return err;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "lower_subexp": {
      "start_point": [
        1369,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static bin_tree_t *\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *body = node->left;\n  bin_tree_t *op, *cls, *tree1, *tree;\n\n  if (preg->no_sub\n      /* We do not optimize empty subexpressions, because otherwise we may\n\t have bad CONCAT nodes with NULL children.  This is obviously not\n\t very common, so we do not lose much.  An example that triggers\n\t this case is the sed \"script\" /\\(\\)/x.  */\n      && node->left != NULL\n      && (node->token.opr.idx >= BITSET_WORD_BITS\n\t  || !(dfa->used_bkref_map\n\t       & ((bitset_word_t) 1 << node->token.opr.idx))))\n    return node->left;\n\n  /* Convert the SUBEXP node to the concatenation of an\n     OP_OPEN_SUBEXP, the contents, and an OP_CLOSE_SUBEXP.  */\n  op = create_tree (dfa, NULL, NULL, OP_OPEN_SUBEXP);\n  cls = create_tree (dfa, NULL, NULL, OP_CLOSE_SUBEXP);\n  tree1 = body ? create_tree (dfa, body, cls, CONCAT) : cls;\n  tree = create_tree (dfa, op, tree1, CONCAT);\n  if (BE (tree == NULL || tree1 == NULL || op == NULL || cls == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  op->token.opr.idx = cls->token.opr.idx = node->token.opr.idx;\n  op->token.opt_subexp = cls->token.opt_subexp = node->token.opt_subexp;\n  return tree;\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nlower_subexp (reg_errcode_t *err, regex_t *preg, bin_tree_t *node)",
        "*"
      ]
    },
    "calc_first": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1425,
        1
      ],
      "content": "static reg_errcode_t\ncalc_first (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  if (node->token.type == CONCAT)\n    {\n      node->first = node->left->first;\n      node->node_idx = node->left->node_idx;\n    }\n  else\n    {\n      node->first = node;\n      node->node_idx = re_dfa_add_node (dfa, node->token);\n      if (BE (node->node_idx == REG_MISSING, 0))\n\treturn REG_ESPACE;\n      if (node->token.type == ANCHOR)\n\tdfa->nodes[node->node_idx].constraint = node->token.opr.ctx_type;\n    }\n  return REG_NOERROR;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_next": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static reg_errcode_t\ncalc_next (void *extra, bin_tree_t *node)\n{\n  switch (node->token.type)\n    {\n    case OP_DUP_ASTERISK:\n      node->left->next = node;\n      break;\n    case CONCAT:\n      node->left->next = node->right->first;\n      node->right->next = node->next;\n      break;\n    default:\n      if (node->left)\n\tnode->left->next = node->next;\n      if (node->right)\n\tnode->right->next = node->next;\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "link_nfa_nodes": {
      "start_point": [
        1451,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "static reg_errcode_t\nlink_nfa_nodes (void *extra, bin_tree_t *node)\n{\n  re_dfa_t *dfa = (re_dfa_t *) extra;\n  Idx idx = node->node_idx;\n  reg_errcode_t err = REG_NOERROR;\n\n  switch (node->token.type)\n    {\n    case CONCAT:\n      break;\n\n    case END_OF_RE:\n      assert (node->next == NULL);\n      break;\n\n    case OP_DUP_ASTERISK:\n    case OP_ALT:\n      {\n\tIdx left, right;\n\tdfa->has_plural_match = 1;\n\tif (node->left != NULL)\n\t  left = node->left->first->node_idx;\n\telse\n\t  left = node->next->node_idx;\n\tif (node->right != NULL)\n\t  right = node->right->first->node_idx;\n\telse\n\t  right = node->next->node_idx;\n\tassert (REG_VALID_INDEX (left));\n\tassert (REG_VALID_INDEX (right));\n\terr = re_node_set_init_2 (dfa->edests + idx, left, right);\n      }\n      break;\n\n    case ANCHOR:\n    case OP_OPEN_SUBEXP:\n    case OP_CLOSE_SUBEXP:\n      err = re_node_set_init_1 (dfa->edests + idx, node->next->node_idx);\n      break;\n\n    case OP_BACK_REF:\n      dfa->nexts[idx] = node->next->node_idx;\n      if (node->token.type == OP_BACK_REF)\n\terr = re_node_set_init_1 (dfa->edests + idx, dfa->nexts[idx]);\n      break;\n\n    default:\n      assert (!IS_EPSILON_NODE (node->token.type));\n      dfa->nexts[idx] = node->next->node_idx;\n      break;\n    }\n\n  return err;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_node_closure": {
      "start_point": [
        1511,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nduplicate_node_closure (re_dfa_t *dfa, Idx top_org_node, Idx top_clone_node,\n\t\t\tIdx root_node, unsigned int init_constraint)\n{\n  Idx org_node, clone_node;\n  bool ok;\n  unsigned int constraint = init_constraint;\n  for (org_node = top_org_node, clone_node = top_clone_node;;)\n    {\n      Idx org_dest, clone_dest;\n      if (dfa->nodes[org_node].type == OP_BACK_REF)\n\t{\n\t  /* If the back reference epsilon-transit, its destination must\n\t     also have the constraint.  Then duplicate the epsilon closure\n\t     of the destination of the back reference, and store it in\n\t     edests of the back reference.  */\n\t  org_dest = dfa->nexts[org_node];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else if (dfa->edests[org_node].nelem == 0)\n\t{\n\t  /* In case of the node can't epsilon-transit, don't duplicate the\n\t     destination and store the original destination as the\n\t     destination of the node.  */\n\t  dfa->nexts[clone_node] = dfa->nexts[org_node];\n\t  break;\n\t}\n      else if (dfa->edests[org_node].nelem == 1)\n\t{\n\t  /* In case of the node can epsilon-transit, and it has only one\n\t     destination.  */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* If the node is root_node itself, it means the epsilon closure\n\t     has a loop.  Then tie it to the destination of the root_node.  */\n\t  if (org_node == root_node && clone_node != org_node)\n\t    {\n\t      ok = re_node_set_insert (dfa->edests + clone_node, org_dest);\n\t      if (BE (! ok, 0))\n\t        return REG_ESPACE;\n\t      break;\n\t    }\n\t  /* In case the node has another constraint, append it.  */\n\t  constraint |= dfa->nodes[org_node].constraint;\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      else /* dfa->edests[org_node].nelem == 2 */\n\t{\n\t  /* In case of the node can epsilon-transit, and it has two\n\t     destinations. In the bin_tree_t and DFA, that's '|' and '*'.   */\n\t  org_dest = dfa->edests[org_node].elems[0];\n\t  re_node_set_empty (dfa->edests + clone_node);\n\t  /* Search for a duplicated node which satisfies the constraint.  */\n\t  clone_dest = search_duplicated_node (dfa, org_dest, constraint);\n\t  if (clone_dest == REG_MISSING)\n\t    {\n\t      /* There is no such duplicated node, create a new one.  */\n\t      reg_errcode_t err;\n\t      clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t      if (BE (clone_dest == REG_MISSING, 0))\n\t\treturn REG_ESPACE;\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t      err = duplicate_node_closure (dfa, org_dest, clone_dest,\n\t\t\t\t\t    root_node, constraint);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  else\n\t    {\n\t      /* There is a duplicated node which satisfies the constraint,\n\t\t use it to avoid infinite loop.  */\n\t      ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\n\t  org_dest = dfa->edests[org_node].elems[1];\n\t  clone_dest = duplicate_node (dfa, org_dest, constraint);\n\t  if (BE (clone_dest == REG_MISSING, 0))\n\t    return REG_ESPACE;\n\t  ok = re_node_set_insert (dfa->edests + clone_node, clone_dest);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n      org_node = org_dest;\n      clone_node = clone_dest;\n    }\n  return REG_NOERROR;\n}",
      "lines": 104,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "search_duplicated_node": {
      "start_point": [
        1619,
        0
      ],
      "end_point": [
        1631,
        1
      ],
      "content": "static Idx\nsearch_duplicated_node (const re_dfa_t *dfa, Idx org_node,\n\t\t\tunsigned int constraint)\n{\n  Idx idx;\n  for (idx = dfa->nodes_len - 1; dfa->nodes[idx].duplicated && idx > 0; --idx)\n    {\n      if (org_node == dfa->org_indices[idx]\n\t  && constraint == dfa->nodes[idx].constraint)\n\treturn idx; /* Found.  */\n    }\n  return REG_MISSING; /* Not found.  */\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "duplicate_node": {
      "start_point": [
        1637,
        0
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "static Idx\nduplicate_node (re_dfa_t *dfa, Idx org_idx, unsigned int constraint)\n{\n  Idx dup_idx = re_dfa_add_node (dfa, dfa->nodes[org_idx]);\n  if (BE (dup_idx != REG_MISSING, 1))\n    {\n      dfa->nodes[dup_idx].constraint = constraint;\n      dfa->nodes[dup_idx].constraint |= dfa->nodes[org_idx].constraint;\n      dfa->nodes[dup_idx].duplicated = 1;\n\n      /* Store the index of the original node.  */\n      dfa->org_indices[dup_idx] = org_idx;\n    }\n  return dup_idx;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "calc_inveclosure": {
      "start_point": [
        1653,
        0
      ],
      "end_point": [
        1673,
        1
      ],
      "content": "static reg_errcode_t\ncalc_inveclosure (re_dfa_t *dfa)\n{\n  Idx src, idx;\n  bool ok;\n  for (idx = 0; idx < dfa->nodes_len; ++idx)\n    re_node_set_init_empty (dfa->inveclosures + idx);\n\n  for (src = 0; src < dfa->nodes_len; ++src)\n    {\n      Idx *elems = dfa->eclosures[src].elems;\n      for (idx = 0; idx < dfa->eclosures[src].nelem; ++idx)\n\t{\n\t  ok = re_node_set_insert_last (dfa->inveclosures + elems[idx], src);\n\t  if (BE (! ok, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure": {
      "start_point": [
        1677,
        0
      ],
      "end_point": [
        1718,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure (re_dfa_t *dfa)\n{\n  Idx node_idx;\n  bool incomplete;\n#ifdef DEBUG\n  assert (dfa->nodes_len > 0);\n#endif\n  incomplete = false;\n  /* For each nodes, calculate epsilon closure.  */\n  for (node_idx = 0; ; ++node_idx)\n    {\n      reg_errcode_t err;\n      re_node_set eclosure_elem;\n      if (node_idx == dfa->nodes_len)\n\t{\n\t  if (!incomplete)\n\t    break;\n\t  incomplete = false;\n\t  node_idx = 0;\n\t}\n\n#ifdef DEBUG\n      assert (dfa->eclosures[node_idx].nelem != REG_MISSING);\n#endif\n\n      /* If we have already calculated, skip it.  */\n      if (dfa->eclosures[node_idx].nelem != 0)\n\tcontinue;\n      /* Calculate epsilon closure of 'node_idx'.  */\n      err = calc_eclosure_iter (&eclosure_elem, dfa, node_idx, true);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n\n      if (dfa->eclosures[node_idx].nelem == 0)\n\t{\n\t  incomplete = true;\n\t  re_node_set_free (&eclosure_elem);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 42,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "calc_eclosure_iter": {
      "start_point": [
        1722,
        0
      ],
      "end_point": [
        1796,
        1
      ],
      "content": "static reg_errcode_t\ncalc_eclosure_iter (re_node_set *new_set, re_dfa_t *dfa, Idx node, bool root)\n{\n  reg_errcode_t err;\n  Idx i;\n  re_node_set eclosure;\n  bool ok;\n  bool incomplete = false;\n  err = re_node_set_alloc (&eclosure, dfa->edests[node].nelem + 1);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  /* This indicates that we are calculating this node now.\n     We reference this value to avoid infinite loop.  */\n  dfa->eclosures[node].nelem = REG_MISSING;\n\n  /* If the current node has constraints, duplicate all nodes\n     since they must inherit the constraints.  */\n  if (dfa->nodes[node].constraint\n      && dfa->edests[node].nelem\n      && !dfa->nodes[dfa->edests[node].elems[0]].duplicated)\n    {\n      err = duplicate_node_closure (dfa, node, node, node,\n\t\t\t\t    dfa->nodes[node].constraint);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  /* Expand each epsilon destination nodes.  */\n  if (IS_EPSILON_NODE(dfa->nodes[node].type))\n    for (i = 0; i < dfa->edests[node].nelem; ++i)\n      {\n\tre_node_set eclosure_elem;\n\tIdx edest = dfa->edests[node].elems[i];\n\t/* If calculating the epsilon closure of 'edest' is in progress,\n\t   return intermediate result.  */\n\tif (dfa->eclosures[edest].nelem == REG_MISSING)\n\t  {\n\t    incomplete = true;\n\t    continue;\n\t  }\n\t/* If we haven't calculated the epsilon closure of 'edest' yet,\n\t   calculate now. Otherwise use calculated epsilon closure.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    err = calc_eclosure_iter (&eclosure_elem, dfa, edest, false);\n\t    if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  }\n\telse\n\t  eclosure_elem = dfa->eclosures[edest];\n\t/* Merge the epsilon closure of 'edest'.  */\n\terr = re_node_set_merge (&eclosure, &eclosure_elem);\n\tif (BE (err != REG_NOERROR, 0))\n\t  return err;\n\t/* If the epsilon closure of 'edest' is incomplete,\n\t   the epsilon closure of this node is also incomplete.  */\n\tif (dfa->eclosures[edest].nelem == 0)\n\t  {\n\t    incomplete = true;\n\t    re_node_set_free (&eclosure_elem);\n\t  }\n      }\n\n  /* An epsilon closure includes itself.  */\n  ok = re_node_set_insert (&eclosure, node);\n  if (BE (! ok, 0))\n    return REG_ESPACE;\n  if (incomplete && !root)\n    dfa->eclosures[node].nelem = 0;\n  else\n    dfa->eclosures[node] = eclosure;\n  *new_set = eclosure;\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "fetch_token": {
      "start_point": [
        1803,
        0
      ],
      "end_point": [
        1808,
        1
      ],
      "content": "static void\ninternal_function\nfetch_token (re_token_t *result, re_string_t *input, reg_syntax_t syntax)\n{\n  re_string_skip_bytes (input, peek_token (result, input, syntax));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "internal_function": {
      "start_point": [
        1813,
        0
      ],
      "end_point": [
        2047,
        1
      ],
      "content": "static int\ninternal_function\npeek_token (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n  token->word_char = 0;\n#ifdef RE_ENABLE_I18N\n  token->mb_partial = 0;\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      token->mb_partial = 1;\n      return 1;\n    }\n#endif\n  if (c == '\\\\')\n    {\n      unsigned char c2;\n      if (re_string_cur_idx (input) + 1 >= re_string_length (input))\n\t{\n\t  token->type = BACK_SLASH;\n\t  return 1;\n\t}\n\n      c2 = re_string_peek_byte_case (input, 1);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n      if (input->mb_cur_max > 1)\n\t{\n\t  wint_t wc = re_string_wchar_at (input,\n\t\t\t\t\t  re_string_cur_idx (input) + 1);\n\t  token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n\t}\n      else\n#endif\n\ttoken->word_char = IS_WORD_CHAR (c2) != 0;\n\n      switch (c2)\n\t{\n\tcase '|':\n\t  if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_NO_BK_VBAR))\n\t    token->type = OP_ALT;\n\t  break;\n\tcase '1': case '2': case '3': case '4': case '5':\n\tcase '6': case '7': case '8': case '9':\n\t  if (!(syntax & RE_NO_BK_REFS))\n\t    {\n\t      token->type = OP_BACK_REF;\n\t      token->opr.idx = c2 - '1';\n\t    }\n\t  break;\n\tcase '<':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_FIRST;\n\t    }\n\t  break;\n\tcase '>':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  break;\n\tcase 'b':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'B':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = NOT_WORD_DELIM;\n\t    }\n\t  break;\n\tcase 'w':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_WORD;\n\t  break;\n\tcase 'W':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTWORD;\n\t  break;\n\tcase 's':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_SPACE;\n\t  break;\n\tcase 'S':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    token->type = OP_NOTSPACE;\n\t  break;\n\tcase '`':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_FIRST;\n\t    }\n\t  break;\n\tcase '\\'':\n\t  if (!(syntax & RE_NO_GNU_OPS))\n\t    {\n\t      token->type = ANCHOR;\n\t      token->opr.ctx_type = BUF_LAST;\n\t    }\n\t  break;\n\tcase '(':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_OPEN_SUBEXP;\n\t  break;\n\tcase ')':\n\t  if (!(syntax & RE_NO_BK_PARENS))\n\t    token->type = OP_CLOSE_SUBEXP;\n\t  break;\n\tcase '+':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_PLUS;\n\t  break;\n\tcase '?':\n\t  if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_BK_PLUS_QM))\n\t    token->type = OP_DUP_QUESTION;\n\t  break;\n\tcase '{':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_OPEN_DUP_NUM;\n\t  break;\n\tcase '}':\n\t  if ((syntax & RE_INTERVALS) && (!(syntax & RE_NO_BK_BRACES)))\n\t    token->type = OP_CLOSE_DUP_NUM;\n\t  break;\n\tdefault:\n\t  break;\n\t}\n      return 2;\n    }\n\n  token->type = CHARACTER;\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc = re_string_wchar_at (input, re_string_cur_idx (input));\n      token->word_char = IS_WIDE_WORD_CHAR (wc) != 0;\n    }\n  else\n#endif\n    token->word_char = IS_WORD_CHAR (token->opr.c);\n\n  switch (c)\n    {\n    case '\\n':\n      if (syntax & RE_NEWLINE_ALT)\n\ttoken->type = OP_ALT;\n      break;\n    case '|':\n      if (!(syntax & RE_LIMITED_OPS) && (syntax & RE_NO_BK_VBAR))\n\ttoken->type = OP_ALT;\n      break;\n    case '*':\n      token->type = OP_DUP_ASTERISK;\n      break;\n    case '+':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_PLUS;\n      break;\n    case '?':\n      if (!(syntax & RE_LIMITED_OPS) && !(syntax & RE_BK_PLUS_QM))\n\ttoken->type = OP_DUP_QUESTION;\n      break;\n    case '{':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_OPEN_DUP_NUM;\n      break;\n    case '}':\n      if ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))\n\ttoken->type = OP_CLOSE_DUP_NUM;\n      break;\n    case '(':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_OPEN_SUBEXP;\n      break;\n    case ')':\n      if (syntax & RE_NO_BK_PARENS)\n\ttoken->type = OP_CLOSE_SUBEXP;\n      break;\n    case '[':\n      token->type = OP_OPEN_BRACKET;\n      break;\n    case '.':\n      token->type = OP_PERIOD;\n      break;\n    case '^':\n      if (!(syntax & (RE_CONTEXT_INDEP_ANCHORS | RE_CARET_ANCHORS_HERE)) &&\n\t  re_string_cur_idx (input) != 0)\n\t{\n\t  char prev = re_string_peek_byte (input, -1);\n\t  if (!(syntax & RE_NEWLINE_ALT) || prev != '\\n')\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_FIRST;\n      break;\n    case '$':\n      if (!(syntax & RE_CONTEXT_INDEP_ANCHORS) &&\n\t  re_string_cur_idx (input) + 1 != re_string_length (input))\n\t{\n\t  re_token_t next;\n\t  re_string_skip_bytes (input, 1);\n\t  peek_token (&next, input, syntax);\n\t  re_string_skip_bytes (input, -1);\n\t  if (next.type != OP_ALT && next.type != OP_CLOSE_SUBEXP)\n\t    break;\n\t}\n      token->type = ANCHOR;\n      token->opr.ctx_type = LINE_LAST;\n      break;\n    default:\n      break;\n    }\n  return 1;\n}",
      "lines": 235,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "peek_token_bracket": {
      "start_point": [
        2052,
        0
      ],
      "end_point": [
        2133,
        1
      ],
      "content": "static int\ninternal_function\npeek_token_bracket (re_token_t *token, re_string_t *input, reg_syntax_t syntax)\n{\n  unsigned char c;\n  if (re_string_eoi (input))\n    {\n      token->type = END_OF_RE;\n      return 0;\n    }\n  c = re_string_peek_byte (input, 0);\n  token->opr.c = c;\n\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1 &&\n      !re_string_first_byte (input, re_string_cur_idx (input)))\n    {\n      token->type = CHARACTER;\n      return 1;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  if (c == '\\\\' && (syntax & RE_BACKSLASH_ESCAPE_IN_LISTS)\n      && re_string_cur_idx (input) + 1 < re_string_length (input))\n    {\n      /* In this case, '\\' escape a character.  */\n      unsigned char c2;\n      re_string_skip_bytes (input, 1);\n      c2 = re_string_peek_byte (input, 0);\n      token->opr.c = c2;\n      token->type = CHARACTER;\n      return 1;\n    }\n  if (c == '[') /* '[' is a special char in a bracket exps.  */\n    {\n      unsigned char c2;\n      int token_len;\n      if (re_string_cur_idx (input) + 1 < re_string_length (input))\n\tc2 = re_string_peek_byte (input, 1);\n      else\n\tc2 = 0;\n      token->opr.c = c2;\n      token_len = 2;\n      switch (c2)\n\t{\n\tcase '.':\n\t  token->type = OP_OPEN_COLL_ELEM;\n\t  break;\n\tcase '=':\n\t  token->type = OP_OPEN_EQUIV_CLASS;\n\t  break;\n\tcase ':':\n\t  if (syntax & RE_CHAR_CLASSES)\n\t    {\n\t      token->type = OP_OPEN_CHAR_CLASS;\n\t      break;\n\t    }\n\t  /* else fall through.  */\n\tdefault:\n\t  token->type = CHARACTER;\n\t  token->opr.c = c;\n\t  token_len = 1;\n\t  break;\n\t}\n      return token_len;\n    }\n  switch (c)\n    {\n    case '-':\n      token->type = OP_CHARSET_RANGE;\n      break;\n    case ']':\n      token->type = OP_CLOSE_BRACKET;\n      break;\n    case '^':\n      token->type = OP_NON_MATCH_LIST;\n      break;\n    default:\n      token->type = CHARACTER;\n    }\n  return 1;\n}",
      "lines": 82,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "parse": {
      "start_point": [
        2149,
        0
      ],
      "end_point": [
        2172,
        1
      ],
      "content": "static bin_tree_t *\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *eor, *root;\n  re_token_t current_token;\n  dfa->syntax = syntax;\n  fetch_token (&current_token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n  tree = parse_reg_exp (regexp, preg, &current_token, syntax, 0, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n  eor = create_tree (dfa, NULL, NULL, END_OF_RE);\n  if (tree != NULL)\n    root = create_tree (dfa, tree, eor, CONCAT);\n  else\n    root = eor;\n  if (BE (eor == NULL || root == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  return root;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse (re_string_t *regexp, regex_t *preg, reg_syntax_t syntax,\n       reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_reg_exp": {
      "start_point": [
        2183,
        0
      ],
      "end_point": [
        2213,
        1
      ],
      "content": "static bin_tree_t *\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree, *branch = NULL;\n  tree = parse_branch (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type == OP_ALT)\n    {\n      fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n      if (token->type != OP_ALT && token->type != END_OF_RE\n\t  && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n\t{\n\t  branch = parse_branch (regexp, preg, token, syntax, nest, err);\n\t  if (BE (*err != REG_NOERROR && branch == NULL, 0))\n\t    return NULL;\n\t}\n      else\n\tbranch = NULL;\n      tree = create_tree (dfa, tree, branch, OP_ALT);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n    }\n  return tree;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_reg_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_branch": {
      "start_point": [
        2224,
        0
      ],
      "end_point": [
        2261,
        1
      ],
      "content": "static bin_tree_t *\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  bin_tree_t *tree, *expr;\n  re_dfa_t *dfa = preg->buffer;\n  tree = parse_expression (regexp, preg, token, syntax, nest, err);\n  if (BE (*err != REG_NOERROR && tree == NULL, 0))\n    return NULL;\n\n  while (token->type != OP_ALT && token->type != END_OF_RE\n\t && (nest == 0 || token->type != OP_CLOSE_SUBEXP))\n    {\n      expr = parse_expression (regexp, preg, token, syntax, nest, err);\n      if (BE (*err != REG_NOERROR && expr == NULL, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  return NULL;\n\t}\n      if (tree != NULL && expr != NULL)\n\t{\n\t  bin_tree_t *newtree = create_tree (dfa, tree, expr, CONCAT);\n\t  if (newtree == NULL)\n\t    {\n\t      postorder (expr, free_tree, NULL);\n\t      postorder (tree, free_tree, NULL);\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t  tree = newtree;\n\t}\n      else if (tree == NULL)\n\ttree = expr;\n      /* Otherwise expr == NULL, we don't need to create new tree.  */\n    }\n  return tree;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_branch (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t      reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_expression": {
      "start_point": [
        2269,
        0
      ],
      "end_point": [
        2476,
        1
      ],
      "content": "static bin_tree_t *\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  switch (token->type)\n    {\n    case CHARACTER:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (!re_string_eoi (regexp)\n\t\t && !re_string_first_byte (regexp, re_string_cur_idx (regexp)))\n\t    {\n\t      bin_tree_t *mbc_remain;\n\t      fetch_token (token, regexp, syntax);\n\t      mbc_remain = create_token_tree (dfa, NULL, NULL, token);\n\t      tree = create_tree (dfa, tree, mbc_remain, CONCAT);\n\t      if (BE (mbc_remain == NULL || tree == NULL, 0))\n\t\t{\n\t\t  *err = REG_ESPACE;\n\t\t  return NULL;\n\t\t}\n\t    }\n\t}\n#endif\n      break;\n    case OP_OPEN_SUBEXP:\n      tree = parse_sub_exp (regexp, preg, token, syntax, nest + 1, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_OPEN_BRACKET:\n      tree = parse_bracket_exp (regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_BACK_REF:\n      if (!BE (dfa->completed_bkref_map & (1 << token->opr.idx), 1))\n\t{\n\t  *err = REG_ESUBREG;\n\t  return NULL;\n\t}\n      dfa->used_bkref_map |= 1 << token->opr.idx;\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      ++dfa->nbackref;\n      dfa->has_mb_node = 1;\n      break;\n    case OP_OPEN_DUP_NUM:\n      if (syntax & RE_CONTEXT_INVALID_DUP)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      /* FALLTHROUGH */\n    case OP_DUP_ASTERISK:\n    case OP_DUP_PLUS:\n    case OP_DUP_QUESTION:\n      if (syntax & RE_CONTEXT_INVALID_OPS)\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n      else if (syntax & RE_CONTEXT_INDEP_OPS)\n\t{\n\t  fetch_token (token, regexp, syntax);\n\t  return parse_expression (regexp, preg, token, syntax, nest, err);\n\t}\n      /* else fall through  */\n    case OP_CLOSE_SUBEXP:\n      if ((token->type == OP_CLOSE_SUBEXP) &&\n\t  !(syntax & RE_UNMATCHED_RIGHT_PAREN_ORD))\n\t{\n\t  *err = REG_ERPAREN;\n\t  return NULL;\n\t}\n      /* else fall through  */\n    case OP_CLOSE_DUP_NUM:\n      /* We treat it as a normal character.  */\n\n      /* Then we can these characters as normal characters.  */\n      token->type = CHARACTER;\n      /* mb_partial and word_char bits should be initialized already\n\t by peek_token.  */\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      break;\n    case ANCHOR:\n      if ((token->opr.ctx_type\n\t   & (WORD_DELIM | NOT_WORD_DELIM | WORD_FIRST | WORD_LAST))\n\t  && dfa->word_ops_used == 0)\n\tinit_word_char (dfa);\n      if (token->opr.ctx_type == WORD_DELIM\n\t  || token->opr.ctx_type == NOT_WORD_DELIM)\n\t{\n\t  bin_tree_t *tree_first, *tree_last;\n\t  if (token->opr.ctx_type == WORD_DELIM)\n\t    {\n\t      token->opr.ctx_type = WORD_FIRST;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = WORD_LAST;\n\t    }\n\t  else\n\t    {\n\t      token->opr.ctx_type = INSIDE_WORD;\n\t      tree_first = create_token_tree (dfa, NULL, NULL, token);\n\t      token->opr.ctx_type = INSIDE_NOTWORD;\n\t    }\n\t  tree_last = create_token_tree (dfa, NULL, NULL, token);\n\t  tree = create_tree (dfa, tree_first, tree_last, OP_ALT);\n\t  if (BE (tree_first == NULL || tree_last == NULL || tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      else\n\t{\n\t  tree = create_token_tree (dfa, NULL, NULL, token);\n\t  if (BE (tree == NULL, 0))\n\t    {\n\t      *err = REG_ESPACE;\n\t      return NULL;\n\t    }\n\t}\n      /* We must return here, since ANCHORs can't be followed\n\t by repetition operators.\n\t eg. RE\"^*\" is invalid or \"<ANCHOR(^)><CHAR(*)>\",\n\t     it must not be \"<ANCHOR(^)><REPEAT(*)>\".  */\n      fetch_token (token, regexp, syntax);\n      return tree;\n    case OP_PERIOD:\n      tree = create_token_tree (dfa, NULL, NULL, token);\n      if (BE (tree == NULL, 0))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n      if (dfa->mb_cur_max > 1)\n\tdfa->has_mb_node = 1;\n      break;\n    case OP_WORD:\n    case OP_NOTWORD:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"alnum\",\n\t\t\t\t \"_\",\n\t\t\t\t token->type == OP_NOTWORD, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_SPACE:\n    case OP_NOTSPACE:\n      tree = build_charclass_op (dfa, regexp->trans,\n\t\t\t\t \"space\",\n\t\t\t\t \"\",\n\t\t\t\t token->type == OP_NOTSPACE, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      break;\n    case OP_ALT:\n    case END_OF_RE:\n      return NULL;\n    case BACK_SLASH:\n      *err = REG_EESCAPE;\n      return NULL;\n    default:\n      /* Must not happen?  */\n#ifdef DEBUG\n      assert (0);\n#endif\n      return NULL;\n    }\n  fetch_token (token, regexp, syntax);\n\n  while (token->type == OP_DUP_ASTERISK || token->type == OP_DUP_PLUS\n\t || token->type == OP_DUP_QUESTION || token->type == OP_OPEN_DUP_NUM)\n    {\n      tree = parse_dup_op (tree, regexp, dfa, token, syntax, err);\n      if (BE (*err != REG_NOERROR && tree == NULL, 0))\n\treturn NULL;\n      /* In BRE consecutive duplications are not allowed.  */\n      if ((syntax & RE_CONTEXT_INVALID_DUP)\n\t  && (token->type == OP_DUP_ASTERISK\n\t      || token->type == OP_OPEN_DUP_NUM))\n\t{\n\t  *err = REG_BADRPT;\n\t  return NULL;\n\t}\n    }\n\n  return tree;\n}",
      "lines": 208,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_expression (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t\t  reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_sub_exp": {
      "start_point": [
        2485,
        0
      ],
      "end_point": [
        2523,
        1
      ],
      "content": "static bin_tree_t *\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)\n{\n  re_dfa_t *dfa = preg->buffer;\n  bin_tree_t *tree;\n  size_t cur_nsub;\n  cur_nsub = preg->re_nsub++;\n\n  fetch_token (token, regexp, syntax | RE_CARET_ANCHORS_HERE);\n\n  /* The subexpression may be a null string.  */\n  if (token->type == OP_CLOSE_SUBEXP)\n    tree = NULL;\n  else\n    {\n      tree = parse_reg_exp (regexp, preg, token, syntax, nest, err);\n      if (BE (*err == REG_NOERROR && token->type != OP_CLOSE_SUBEXP, 0))\n\t{\n\t  if (tree != NULL)\n\t    postorder (tree, free_tree, NULL);\n\t  *err = REG_EPAREN;\n\t}\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n\n  if (cur_nsub <= '9' - '1')\n    dfa->completed_bkref_map |= 1 << cur_nsub;\n\n  tree = create_tree (dfa, tree, NULL, SUBEXP);\n  if (BE (tree == NULL, 0))\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n  tree->token.opr.idx = cur_nsub;\n  return tree;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_sub_exp (re_string_t *regexp, regex_t *preg, re_token_t *token,\n\t       reg_syntax_t syntax, Idx nest, reg_errcode_t *err)",
        "*"
      ]
    },
    "parse_dup_op": {
      "start_point": [
        2527,
        0
      ],
      "end_point": [
        2669,
        1
      ],
      "content": "static bin_tree_t *\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)\n{\n  bin_tree_t *tree = NULL, *old_tree = NULL;\n  Idx i, start, end, start_idx = re_string_cur_idx (regexp);\n  re_token_t start_token = *token;\n\n  if (token->type == OP_OPEN_DUP_NUM)\n    {\n      end = 0;\n      start = fetch_number (regexp, token, syntax);\n      if (start == REG_MISSING)\n\t{\n\t  if (token->type == CHARACTER && token->opr.c == ',')\n\t    start = 0; /* We treat \"{,m}\" as \"{0,m}\".  */\n\t  else\n\t    {\n\t      *err = REG_BADBR; /* <re>{} is invalid.  */\n\t      return NULL;\n\t    }\n\t}\n      if (BE (start != REG_ERROR, 1))\n\t{\n\t  /* We treat \"{n}\" as \"{n,n}\".  */\n\t  end = ((token->type == OP_CLOSE_DUP_NUM) ? start\n\t\t : ((token->type == CHARACTER && token->opr.c == ',')\n\t\t    ? fetch_number (regexp, token, syntax) : REG_ERROR));\n\t}\n      if (BE (start == REG_ERROR || end == REG_ERROR, 0))\n\t{\n\t  /* Invalid sequence.  */\n\t  if (BE (!(syntax & RE_INVALID_INTERVAL_ORD), 0))\n\t    {\n\t      if (token->type == END_OF_RE)\n\t\t*err = REG_EBRACE;\n\t      else\n\t\t*err = REG_BADBR;\n\n\t      return NULL;\n\t    }\n\n\t  /* If the syntax bit is set, rollback.  */\n\t  re_string_set_index (regexp, start_idx);\n\t  *token = start_token;\n\t  token->type = CHARACTER;\n\t  /* mb_partial and word_char bits should be already initialized by\n\t     peek_token.  */\n\t  return elem;\n\t}\n\n      if (BE ((end != REG_MISSING && start > end)\n\t      || token->type != OP_CLOSE_DUP_NUM, 0))\n\t{\n\t  /* First number greater than second.  */\n\t  *err = REG_BADBR;\n\t  return NULL;\n\t}\n\n      if (BE (RE_DUP_MAX < (end == REG_MISSING ? start : end), 0))\n\t{\n\t  *err = REG_ESIZE;\n\t  return NULL;\n\t}\n    }\n  else\n    {\n      start = (token->type == OP_DUP_PLUS) ? 1 : 0;\n      end = (token->type == OP_DUP_QUESTION) ? 1 : REG_MISSING;\n    }\n\n  fetch_token (token, regexp, syntax);\n\n  if (BE (elem == NULL, 0))\n    return NULL;\n  if (BE (start == 0 && end == 0, 0))\n    {\n      postorder (elem, free_tree, NULL);\n      return NULL;\n    }\n\n  /* Extract \"<re>{n,m}\" to \"<re><re>...<re><re>{0,<m-n>}\".  */\n  if (BE (start > 0, 0))\n    {\n      tree = elem;\n      for (i = 2; i <= start; ++i)\n\t{\n\t  elem = duplicate_tree (elem, dfa);\n\t  tree = create_tree (dfa, tree, elem, CONCAT);\n\t  if (BE (elem == NULL || tree == NULL, 0))\n\t    goto parse_dup_op_espace;\n\t}\n\n      if (start == end)\n\treturn tree;\n\n      /* Duplicate ELEM before it is marked optional.  */\n      elem = duplicate_tree (elem, dfa);\n      old_tree = tree;\n    }\n  else\n    old_tree = NULL;\n\n  if (elem->token.type == SUBEXP)\n    {\n      uintptr_t subidx = elem->token.opr.idx;\n      postorder (elem, mark_opt_subexp, (void *) subidx);\n    }\n\n  tree = create_tree (dfa, elem, NULL,\n\t\t      (end == REG_MISSING ? OP_DUP_ASTERISK : OP_ALT));\n  if (BE (tree == NULL, 0))\n    goto parse_dup_op_espace;\n\n/* From gnulib's \"intprops.h\":\n   True if the arithmetic type T is signed.  */\n#define TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n\n  /* This loop is actually executed only when end != REG_MISSING,\n     to rewrite <re>{0,n} as (<re>(<re>...<re>?)?)?...  We have\n     already created the start+1-th copy.  */\n  if (TYPE_SIGNED (Idx) || end != REG_MISSING)\n    for (i = start + 2; i <= end; ++i)\n      {\n\telem = duplicate_tree (elem, dfa);\n\ttree = create_tree (dfa, tree, elem, CONCAT);\n\tif (BE (elem == NULL || tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n\n\ttree = create_tree (dfa, tree, NULL, OP_ALT);\n\tif (BE (tree == NULL, 0))\n\t  goto parse_dup_op_espace;\n      }\n\n  if (old_tree)\n    tree = create_tree (dfa, old_tree, tree, CONCAT);\n\n  return tree;\n\n parse_dup_op_espace:\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 143,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_dup_op (bin_tree_t *elem, re_string_t *regexp, re_dfa_t *dfa,\n\t      re_token_t *token, reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "start_elem": {
      "start_point": [
        2696,
        23
      ],
      "end_point": [
        2795,
        1
      ],
      "content": "bracket_elem_t *end_elem)\n# endif /* not RE_ENABLE_I18N */\n{\n  unsigned int start_ch, end_ch;\n  /* Equivalence Classes and Character Classes can't be a range start/end.  */\n  if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t  || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t  0))\n    return REG_ERANGE;\n\n  /* We can handle no multi character collating elements without libc\n     support.  */\n  if (BE ((start_elem->type == COLL_SYM\n\t   && strlen ((char *) start_elem->opr.name) > 1)\n\t  || (end_elem->type == COLL_SYM\n\t      && strlen ((char *) end_elem->opr.name) > 1), 0))\n    return REG_ECOLLATE;\n\n# ifdef RE_ENABLE_I18N\n  {\n    wchar_t wc;\n    wint_t start_wc;\n    wint_t end_wc;\n\n    start_ch = ((start_elem->type == SB_CHAR) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    start_wc = ((start_elem->type == SB_CHAR || start_elem->type == COLL_SYM)\n\t\t? __btowc (start_ch) : start_elem->opr.wch);\n    end_wc = ((end_elem->type == SB_CHAR || end_elem->type == COLL_SYM)\n\t      ? __btowc (end_ch) : end_elem->opr.wch);\n    if (start_wc == WEOF || end_wc == WEOF)\n      return REG_ECOLLATE;\n    else if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_wc > end_wc, 0))\n      return REG_ERANGE;\n\n    /* Got valid collation sequence values, add them as a new entry.\n       However, for !_LIBC we have no collation elements: if the\n       character set is single byte, the single byte character set\n       that we build below suffices.  parse_bracket_exp passes\n       no MBCSET if dfa->mb_cur_max == 1.  */\n    if (mbcset)\n      {\n\t/* Check the space of the arrays.  */\n\tif (BE (*range_alloc == mbcset->nranges, 0))\n\t  {\n\t    /* There is not enough space, need realloc.  */\n\t    wchar_t *new_array_start, *new_array_end;\n\t    Idx new_nranges;\n\n\t    /* +1 in case of mbcset->nranges is 0.  */\n\t    new_nranges = 2 * mbcset->nranges + 1;\n\t    /* Use realloc since mbcset->range_starts and mbcset->range_ends\n\t       are NULL if *range_alloc == 0.  */\n\t    new_array_start = re_realloc (mbcset->range_starts, wchar_t,\n\t\t\t\t\t  new_nranges);\n\t    new_array_end = re_realloc (mbcset->range_ends, wchar_t,\n\t\t\t\t\tnew_nranges);\n\n\t    if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t      return REG_ESPACE;\n\n\t    mbcset->range_starts = new_array_start;\n\t    mbcset->range_ends = new_array_end;\n\t    *range_alloc = new_nranges;\n\t  }\n\n\tmbcset->range_starts[mbcset->nranges] = start_wc;\n\tmbcset->range_ends[mbcset->nranges++] = end_wc;\n      }\n\n    /* Build the table for single byte characters.  */\n    for (wc = 0; wc < SBC_MAX; ++wc)\n      {\n\tif (start_wc <= wc && wc <= end_wc)\n\t  bitset_set (sbcset, wc);\n      }\n  }\n# else /* not RE_ENABLE_I18N */\n  {\n    unsigned int ch;\n    start_ch = ((start_elem->type == SB_CHAR ) ? start_elem->opr.ch\n\t\t: ((start_elem->type == COLL_SYM) ? start_elem->opr.name[0]\n\t\t   : 0));\n    end_ch = ((end_elem->type == SB_CHAR ) ? end_elem->opr.ch\n\t      : ((end_elem->type == COLL_SYM) ? end_elem->opr.name[0]\n\t\t : 0));\n    if (start_ch > end_ch)\n      return REG_ERANGE;\n    /* Build the table for single byte characters.  */\n    for (ch = 0; ch < SBC_MAX; ++ch)\n      if (start_ch <= ch  && ch <= end_ch)\n\tbitset_set (sbcset, ch);\n  }\n# endif /* not RE_ENABLE_I18N */\n  return REG_NOERROR;\n}",
      "lines": 100,
      "depth": 16,
      "decorators": null
    },
    "parse_bracket_exp": {
      "start_point": [
        2828,
        0
      ],
      "end_point": [
        3371,
        1
      ],
      "content": "static bin_tree_t *\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)\n{\n#ifdef _LIBC\n  const unsigned char *collseqmb;\n  const char *collseqwc;\n  uint32_t nrules;\n  int32_t table_size;\n  const int32_t *symb_table;\n  const unsigned char *extra;\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Seek the collating symbol entry corresponding to NAME.\n     Return the index of the symbol in the SYMB_TABLE,\n     or -1 if not found.  */\n\n  auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Look up the collation sequence value of BR_ELEM.\n     Return the value if succeeded, UINT_MAX otherwise.  */\n\n  auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the range expression which starts from START_ELEM, and ends\n     at END_ELEM.  The result are written to MBCSET and SBCSET.\n     RANGE_ALLOC is the allocated size of mbcset->range_starts, and\n     mbcset->range_ends, is a pointer argument since we may\n     update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }\n\n  /* Local function for parse_bracket_exp used in _LIBC environment.\n     Build the collating element which is represented by NAME.\n     The result are written to MBCSET and SBCSET.\n     COLL_SYM_ALLOC is the allocated size of mbcset->coll_sym, is a\n     pointer argument since we may update it.  */\n\n  auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }\n#endif\n\n  re_token_t br_token;\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx coll_sym_alloc = 0, range_alloc = 0, mbchar_alloc = 0;\n  Idx equiv_class_alloc = 0, char_class_alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  bool non_match = false;\n  bin_tree_t *work_tree;\n  int token_len;\n  bool first_round = true;\n#ifdef _LIBC\n  collseqmb = (const unsigned char *)\n    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n  nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules)\n    {\n      /*\n      if (MB_CUR_MAX > 1)\n      */\n      collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n      table_size = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_SYMB_HASH_SIZEMB);\n      symb_table = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t  _NL_COLLATE_SYMB_TABLEMB);\n      extra = (const unsigned char *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t   _NL_COLLATE_SYMB_EXTRAMB);\n    }\n#endif\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else\n  if (BE (sbcset == NULL, 0))\n#endif /* RE_ENABLE_I18N */\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      re_free (mbcset);\n#endif\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  token_len = peek_token_bracket (token, regexp, syntax);\n  if (BE (token->type == END_OF_RE, 0))\n    {\n      *err = REG_BADPAT;\n      goto parse_bracket_exp_free_return;\n    }\n  if (token->type == OP_NON_MATCH_LIST)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n      non_match = true;\n      if (syntax & RE_HAT_LISTS_NOT_NEWLINE)\n\tbitset_set (sbcset, '\\n');\n      re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_BADPAT;\n\t  goto parse_bracket_exp_free_return;\n\t}\n    }\n\n  /* We treat the first ']' as a normal character.  */\n  if (token->type == OP_CLOSE_BRACKET)\n    token->type = CHARACTER;\n\n  while (1)\n    {\n      bracket_elem_t start_elem, end_elem;\n      unsigned char start_name_buf[BRACKET_NAME_BUF_SIZE];\n      unsigned char end_name_buf[BRACKET_NAME_BUF_SIZE];\n      reg_errcode_t ret;\n      int token_len2 = 0;\n      bool is_range_exp = false;\n      re_token_t token2;\n\n      start_elem.opr.name = start_name_buf;\n      ret = parse_bracket_element (&start_elem, regexp, token, token_len, dfa,\n\t\t\t\t   syntax, first_round);\n      if (BE (ret != REG_NOERROR, 0))\n\t{\n\t  *err = ret;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      first_round = false;\n\n      /* Get information about the next token.  We need it in any case.  */\n      token_len = peek_token_bracket (token, regexp, syntax);\n\n      /* Do not check for ranges if we know they are not allowed.  */\n      if (start_elem.type != CHAR_CLASS && start_elem.type != EQUIV_CLASS)\n\t{\n\t  if (BE (token->type == END_OF_RE, 0))\n\t    {\n\t      *err = REG_EBRACK;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\t  if (token->type == OP_CHARSET_RANGE)\n\t    {\n\t      re_string_skip_bytes (regexp, token_len); /* Skip '-'.  */\n\t      token_len2 = peek_token_bracket (&token2, regexp, syntax);\n\t      if (BE (token2.type == END_OF_RE, 0))\n\t\t{\n\t\t  *err = REG_EBRACK;\n\t\t  goto parse_bracket_exp_free_return;\n\t\t}\n\t      if (token2.type == OP_CLOSE_BRACKET)\n\t\t{\n\t\t  /* We treat the last '-' as a normal character.  */\n\t\t  re_string_skip_bytes (regexp, -token_len);\n\t\t  token->type = CHARACTER;\n\t\t}\n\t      else\n\t\tis_range_exp = true;\n\t    }\n\t}\n\n      if (is_range_exp == true)\n\t{\n\t  end_elem.opr.name = end_name_buf;\n\t  ret = parse_bracket_element (&end_elem, regexp, &token2, token_len2,\n\t\t\t\t       dfa, syntax, true);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    {\n\t      *err = ret;\n\t      goto parse_bracket_exp_free_return;\n\t    }\n\n\t  token_len = peek_token_bracket (token, regexp, syntax);\n\n#ifdef _LIBC\n\t  *err = build_range_exp (sbcset, mbcset, &range_alloc,\n\t\t\t\t  &start_elem, &end_elem);\n#else\n# ifdef RE_ENABLE_I18N\n\t  *err = build_range_exp (syntax, sbcset,\n\t\t\t\t  dfa->mb_cur_max > 1 ? mbcset : NULL,\n\t\t\t\t  &range_alloc, &start_elem, &end_elem);\n# else\n\t  *err = build_range_exp (syntax, sbcset, &start_elem, &end_elem);\n# endif\n#endif /* RE_ENABLE_I18N */\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    goto parse_bracket_exp_free_return;\n\t}\n      else\n\t{\n\t  switch (start_elem.type)\n\t    {\n\t    case SB_CHAR:\n\t      bitset_set (sbcset, start_elem.opr.ch);\n\t      break;\n#ifdef RE_ENABLE_I18N\n\t    case MB_CHAR:\n\t      /* Check whether the array has enough space.  */\n\t      if (BE (mbchar_alloc == mbcset->nmbchars, 0))\n\t\t{\n\t\t  wchar_t *new_mbchars;\n\t\t  /* Not enough, realloc it.  */\n\t\t  /* +1 in case of mbcset->nmbchars is 0.  */\n\t\t  mbchar_alloc = 2 * mbcset->nmbchars + 1;\n\t\t  /* Use realloc since array is NULL if *alloc == 0.  */\n\t\t  new_mbchars = re_realloc (mbcset->mbchars, wchar_t,\n\t\t\t\t\t    mbchar_alloc);\n\t\t  if (BE (new_mbchars == NULL, 0))\n\t\t    goto parse_bracket_exp_espace;\n\t\t  mbcset->mbchars = new_mbchars;\n\t\t}\n\t      mbcset->mbchars[mbcset->nmbchars++] = start_elem.opr.wch;\n\t      break;\n#endif /* RE_ENABLE_I18N */\n\t    case EQUIV_CLASS:\n\t      *err = build_equiv_class (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\tmbcset, &equiv_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\tstart_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case COLL_SYM:\n\t      *err = build_collating_symbol (sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t\t     mbcset, &coll_sym_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t\t     start_elem.opr.name);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t\tgoto parse_bracket_exp_free_return;\n\t      break;\n\t    case CHAR_CLASS:\n\t      *err = build_charclass (regexp->trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t\t      mbcset, &char_class_alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t\t      (const char *) start_elem.opr.name,\n\t\t\t\t      syntax);\n\t      if (BE (*err != REG_NOERROR, 0))\n\t       goto parse_bracket_exp_free_return;\n\t      break;\n\t    default:\n\t      assert (0);\n\t      break;\n\t    }\n\t}\n      if (BE (token->type == END_OF_RE, 0))\n\t{\n\t  *err = REG_EBRACK;\n\t  goto parse_bracket_exp_free_return;\n\t}\n      if (token->type == OP_CLOSE_BRACKET)\n\tbreak;\n    }\n\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n\n  if (mbcset->nmbchars || mbcset->ncoll_syms || mbcset->nequiv_classes\n      || mbcset->nranges || (dfa->mb_cur_max > 1 && (mbcset->nchar_classes\n\t\t\t\t\t\t     || mbcset->non_match)))\n    {\n      bin_tree_t *mbc_tree;\n      int sbc_idx;\n      /* Build a tree for complex bracket.  */\n      dfa->has_mb_node = 1;\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n      for (sbc_idx = 0; sbc_idx < BITSET_WORDS; ++sbc_idx)\n\tif (sbcset[sbc_idx])\n\t  break;\n      /* If there are no bits set in sbcset, there is no point\n\t of having both SIMPLE_BRACKET and COMPLEX_BRACKET.  */\n      if (sbc_idx < BITSET_WORDS)\n\t{\n\t  /* Build a tree for simple bracket.  */\n\t  br_token.type = SIMPLE_BRACKET;\n\t  br_token.opr.sbcset = sbcset;\n\t  work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\n\t  /* Then join them by ALT node.  */\n\t  work_tree = create_tree (dfa, work_tree, mbc_tree, OP_ALT);\n\t  if (BE (work_tree == NULL, 0))\n\t    goto parse_bracket_exp_espace;\n\t}\n      else\n\t{\n\t  re_free (sbcset);\n\t  work_tree = mbc_tree;\n\t}\n    }\n  else\n#endif /* not RE_ENABLE_I18N */\n    {\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif\n      /* Build a tree for simple bracket.  */\n      br_token.type = SIMPLE_BRACKET;\n      br_token.opr.sbcset = sbcset;\n      work_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (work_tree == NULL, 0))\n\tgoto parse_bracket_exp_espace;\n    }\n  return work_tree;\n\n parse_bracket_exp_espace:\n  *err = REG_ESPACE;\n parse_bracket_exp_free_return:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  return NULL;\n}",
      "lines": 544,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nparse_bracket_exp (re_string_t *regexp, re_dfa_t *dfa, re_token_t *token,\n\t\t   reg_syntax_t syntax, reg_errcode_t *err)",
        "*"
      ]
    },
    "seek_collating_symbol_entry": {
      "start_point": [
        2845,
        2
      ],
      "end_point": [
        2865,
        5
      ],
      "content": "auto inline int32_t\n  __attribute__ ((always_inline))\n  seek_collating_symbol_entry (const unsigned char *name, size_t name_len)\n    {\n      int32_t elem;\n\n      for (elem = 0; elem < table_size; elem++)\n\tif (symb_table[2 * elem] != 0)\n\t  {\n\t    int32_t idx = symb_table[2 * elem + 1];\n\t    /* Skip the name of collating element name.  */\n\t    idx += 1 + extra[idx];\n\t    if (/* Compare the length of the name.  */\n\t\tname_len == extra[idx]\n\t\t/* Compare the name.  */\n\t\t&& memcmp (name, &extra[idx + 1], name_len) == 0)\n\t      /* Yep, this is the entry.  */\n\t      return elem;\n\t  }\n      return -1;\n    }",
      "lines": 21,
      "depth": 15,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "int32_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "lookup_collation_sequence_value": {
      "start_point": [
        2871,
        2
      ],
      "end_point": [
        2930,
        5
      ],
      "content": "auto inline unsigned int\n  __attribute__ ((always_inline))\n  lookup_collation_sequence_value (bracket_elem_t *br_elem)\n    {\n      if (br_elem->type == SB_CHAR)\n\t{\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    return collseqmb[br_elem->opr.ch];\n\t  else\n\t    {\n\t      wint_t wc = __btowc (br_elem->opr.ch);\n\t      return __collseq_table_lookup (collseqwc, wc);\n\t    }\n\t}\n      else if (br_elem->type == MB_CHAR)\n\t{\n\t  if (nrules != 0)\n\t    return __collseq_table_lookup (collseqwc, br_elem->opr.wch);\n\t}\n      else if (br_elem->type == COLL_SYM)\n\t{\n\t  size_t sym_name_len = strlen ((char *) br_elem->opr.name);\n\t  if (nrules != 0)\n\t    {\n\t      int32_t elem, idx;\n\t      elem = seek_collating_symbol_entry (br_elem->opr.name,\n\t\t\t\t\t\t  sym_name_len);\n\t      if (elem != -1)\n\t\t{\n\t\t  /* We found the entry.  */\n\t\t  idx = symb_table[2 * elem + 1];\n\t\t  /* Skip the name of collating element name.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Skip the byte sequence of the collating element.  */\n\t\t  idx += 1 + extra[idx];\n\t\t  /* Adjust for the alignment.  */\n\t\t  idx = (idx + 3) & ~3;\n\t\t  /* Skip the multibyte collation sequence value.  */\n\t\t  idx += sizeof (unsigned int);\n\t\t  /* Skip the wide char sequence of the collating element.  */\n\t\t  idx += sizeof (unsigned int) *\n\t\t    (1 + *(unsigned int *) (extra + idx));\n\t\t  /* Return the collation sequence value.  */\n\t\t  return *(unsigned int *) (extra + idx);\n\t\t}\n\t      else if (sym_name_len == 1)\n\t\t{\n\t\t  /* No valid character.  Match it as a single byte\n\t\t     character.  */\n\t\t  return collseqmb[br_elem->opr.name[0]];\n\t\t}\n\t    }\n\t  else if (sym_name_len == 1)\n\t    return collseqmb[br_elem->opr.name[0]];\n\t}\n      return UINT_MAX;\n    }",
      "lines": 60,
      "depth": 22,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "unsigned int",
        "unsigned",
        "int",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_range_exp": {
      "start_point": [
        2939,
        2
      ],
      "end_point": [
        3012,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_range_exp (bitset_t sbcset, re_charset_t *mbcset, int *range_alloc,\n\t\t   bracket_elem_t *start_elem, bracket_elem_t *end_elem)\n    {\n      unsigned int ch;\n      uint32_t start_collseq;\n      uint32_t end_collseq;\n\n      /* Equivalence Classes and Character Classes can't be a range\n\t start/end.  */\n      if (BE (start_elem->type == EQUIV_CLASS || start_elem->type == CHAR_CLASS\n\t      || end_elem->type == EQUIV_CLASS || end_elem->type == CHAR_CLASS,\n\t      0))\n\treturn REG_ERANGE;\n\n      /* FIXME: Implement rational ranges here, too.  */\n      start_collseq = lookup_collation_sequence_value (start_elem);\n      end_collseq = lookup_collation_sequence_value (end_elem);\n      /* Check start/end collation sequence values.  */\n      if (BE (start_collseq == UINT_MAX || end_collseq == UINT_MAX, 0))\n\treturn REG_ECOLLATE;\n      if (BE ((syntax & RE_NO_EMPTY_RANGES) && start_collseq > end_collseq, 0))\n\treturn REG_ERANGE;\n\n      /* Got valid collation sequence values, add them as a new entry.\n\t However, if we have no collation elements, and the character set\n\t is single byte, the single byte character set that we\n\t build below suffices. */\n      if (nrules > 0 || dfa->mb_cur_max > 1)\n\t{\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*range_alloc == mbcset->nranges, 0))\n\t    {\n\t      /* There is not enough space, need realloc.  */\n\t      uint32_t *new_array_start;\n\t      uint32_t *new_array_end;\n\t      Idx new_nranges;\n\n\t      /* +1 in case of mbcset->nranges is 0.  */\n\t      new_nranges = 2 * mbcset->nranges + 1;\n\t      new_array_start = re_realloc (mbcset->range_starts, uint32_t,\n\t\t\t\t\t    new_nranges);\n\t      new_array_end = re_realloc (mbcset->range_ends, uint32_t,\n\t\t\t\t\t  new_nranges);\n\n\t      if (BE (new_array_start == NULL || new_array_end == NULL, 0))\n\t\treturn REG_ESPACE;\n\n\t      mbcset->range_starts = new_array_start;\n\t      mbcset->range_ends = new_array_end;\n\t      *range_alloc = new_nranges;\n\t    }\n\n\t  mbcset->range_starts[mbcset->nranges] = start_collseq;\n\t  mbcset->range_ends[mbcset->nranges++] = end_collseq;\n\t}\n\n      /* Build the table for single byte characters.  */\n      for (ch = 0; ch < SBC_MAX; ch++)\n\t{\n\t  uint32_t ch_collseq;\n\t  /*\n\t  if (MB_CUR_MAX == 1)\n\t  */\n\t  if (nrules == 0)\n\t    ch_collseq = collseqmb[ch];\n\t  else\n\t    ch_collseq = __collseq_table_lookup (collseqwc, __btowc (ch));\n\t  if (start_collseq <= ch_collseq && ch_collseq <= end_collseq)\n\t    bitset_set (sbcset, ch);\n\t}\n      return REG_NOERROR;\n    }",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "build_collating_symbol": {
      "start_point": [
        3020,
        2
      ],
      "end_point": [
        3076,
        5
      ],
      "content": "auto inline reg_errcode_t\n  __attribute__ ((always_inline))\n  build_collating_symbol (bitset_t sbcset, re_charset_t *mbcset,\n\t\t\t  Idx *coll_sym_alloc, const unsigned char *name)\n    {\n      int32_t elem, idx;\n      size_t name_len = strlen ((const char *) name);\n      if (nrules != 0)\n\t{\n\t  elem = seek_collating_symbol_entry (name, name_len);\n\t  if (elem != -1)\n\t    {\n\t      /* We found the entry.  */\n\t      idx = symb_table[2 * elem + 1];\n\t      /* Skip the name of collating element name.  */\n\t      idx += 1 + extra[idx];\n\t    }\n\t  else if (name_len == 1)\n\t    {\n\t      /* No valid character, treat it as a normal\n\t\t character.  */\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t  else\n\t    return REG_ECOLLATE;\n\n\t  /* Got valid collation sequence, add it as a new entry.  */\n\t  /* Check the space of the arrays.  */\n\t  if (BE (*coll_sym_alloc == mbcset->ncoll_syms, 0))\n\t    {\n\t      /* Not enough, realloc it.  */\n\t      /* +1 in case of mbcset->ncoll_syms is 0.  */\n\t      Idx new_coll_sym_alloc = 2 * mbcset->ncoll_syms + 1;\n\t      /* Use realloc since mbcset->coll_syms is NULL\n\t\t if *alloc == 0.  */\n\t      int32_t *new_coll_syms = re_realloc (mbcset->coll_syms, int32_t,\n\t\t\t\t\t\t   new_coll_sym_alloc);\n\t      if (BE (new_coll_syms == NULL, 0))\n\t\treturn REG_ESPACE;\n\t      mbcset->coll_syms = new_coll_syms;\n\t      *coll_sym_alloc = new_coll_sym_alloc;\n\t    }\n\t  mbcset->coll_syms[mbcset->ncoll_syms++] = idx;\n\t  return REG_NOERROR;\n\t}\n      else\n\t{\n\t  if (BE (name_len != 1, 0))\n\t    return REG_ECOLLATE;\n\t  else\n\t    {\n\t      bitset_set (sbcset, name[0]);\n\t      return REG_NOERROR;\n\t    }\n\t}\n    }",
      "lines": 57,
      "depth": 12,
      "decorators": [
        "auto",
        "auto",
        "inline",
        "inline",
        "reg_errcode_t",
        "__attribute__ ((always_inline))",
        "__attribute__",
        "(",
        "(always_inline)",
        "(",
        "always_inline",
        ")",
        ")"
      ]
    },
    "parse_bracket_element": {
      "start_point": [
        3375,
        0
      ],
      "end_point": [
        3409,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_element (bracket_elem_t *elem, re_string_t *regexp,\n\t\t       re_token_t *token, int token_len, re_dfa_t *dfa,\n\t\t       reg_syntax_t syntax, bool accept_hyphen)\n{\n#ifdef RE_ENABLE_I18N\n  int cur_char_size;\n  cur_char_size = re_string_char_size_at (regexp, re_string_cur_idx (regexp));\n  if (cur_char_size > 1)\n    {\n      elem->type = MB_CHAR;\n      elem->opr.wch = re_string_wchar_at (regexp, re_string_cur_idx (regexp));\n      re_string_skip_bytes (regexp, cur_char_size);\n      return REG_NOERROR;\n    }\n#endif /* RE_ENABLE_I18N */\n  re_string_skip_bytes (regexp, token_len); /* Skip a token.  */\n  if (token->type == OP_OPEN_COLL_ELEM || token->type == OP_OPEN_CHAR_CLASS\n      || token->type == OP_OPEN_EQUIV_CLASS)\n    return parse_bracket_symbol (elem, regexp, token);\n  if (BE (token->type == OP_CHARSET_RANGE, 0) && !accept_hyphen)\n    {\n      /* A '-' must only appear as anything but a range indicator before\n\t the closing bracket.  Everything else is an error.  */\n      re_token_t token2;\n      (void) peek_token_bracket (&token2, regexp, syntax);\n      if (token2.type != OP_CLOSE_BRACKET)\n\t/* The actual error value is not standardized since this whole\n\t   case is undefined.  But ERANGE makes good sense.  */\n\treturn REG_ERANGE;\n    }\n  elem->type = SB_CHAR;\n  elem->opr.ch = token->opr.c;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "parse_bracket_symbol": {
      "start_point": [
        3415,
        0
      ],
      "end_point": [
        3454,
        1
      ],
      "content": "static reg_errcode_t\nparse_bracket_symbol (bracket_elem_t *elem, re_string_t *regexp,\n\t\t      re_token_t *token)\n{\n  unsigned char ch, delim = token->opr.c;\n  int i = 0;\n  if (re_string_eoi(regexp))\n    return REG_EBRACK;\n  for (;; ++i)\n    {\n      if (i >= BRACKET_NAME_BUF_SIZE)\n\treturn REG_EBRACK;\n      if (token->type == OP_OPEN_CHAR_CLASS)\n\tch = re_string_fetch_byte_case (regexp);\n      else\n\tch = re_string_fetch_byte (regexp);\n      if (re_string_eoi(regexp))\n\treturn REG_EBRACK;\n      if (ch == delim && re_string_peek_byte (regexp, 0) == ']')\n\tbreak;\n      elem->opr.name[i] = ch;\n    }\n  re_string_skip_bytes (regexp, 1);\n  elem->opr.name[i] = '\\0';\n  switch (token->type)\n    {\n    case OP_OPEN_COLL_ELEM:\n      elem->type = COLL_SYM;\n      break;\n    case OP_OPEN_EQUIV_CLASS:\n      elem->type = EQUIV_CLASS;\n      break;\n    case OP_OPEN_CHAR_CLASS:\n      elem->type = CHAR_CLASS;\n      break;\n    default:\n      break;\n    }\n  return REG_NOERROR;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "build_charclass": {
      "start_point": [
        3564,
        9
      ],
      "end_point": [
        3638,
        1
      ],
      "content": "char *class_name, reg_syntax_t syntax)\n#endif /* not RE_ENABLE_I18N */\n{\n  int i;\n  const char *name = class_name;\n\n  /* In case of REG_ICASE \"upper\" and \"lower\" match the both of\n     upper and lower cases.  */\n  if ((syntax & RE_ICASE)\n      && (strcmp (name, \"upper\") == 0 || strcmp (name, \"lower\") == 0))\n    name = \"alpha\";\n\n#ifdef RE_ENABLE_I18N\n  /* Check the space of the arrays.  */\n  if (BE (*char_class_alloc == mbcset->nchar_classes, 0))\n    {\n      /* Not enough, realloc it.  */\n      /* +1 in case of mbcset->nchar_classes is 0.  */\n      Idx new_char_class_alloc = 2 * mbcset->nchar_classes + 1;\n      /* Use realloc since array is NULL if *alloc == 0.  */\n      wctype_t *new_char_classes = re_realloc (mbcset->char_classes, wctype_t,\n\t\t\t\t\t       new_char_class_alloc);\n      if (BE (new_char_classes == NULL, 0))\n\treturn REG_ESPACE;\n      mbcset->char_classes = new_char_classes;\n      *char_class_alloc = new_char_class_alloc;\n    }\n  mbcset->char_classes[mbcset->nchar_classes++] = __wctype (name);\n#endif /* RE_ENABLE_I18N */\n\n#define BUILD_CHARCLASS_LOOP(ctype_func)\t\\\n  do {\t\t\t\t\t\t\\\n    if (BE (trans != NULL, 0))\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, trans[i]);\t\\\n      }\t\t\t\t\t\t\\\n    else\t\t\t\t\t\\\n      {\t\t\t\t\t\t\\\n\tfor (i = 0; i < SBC_MAX; ++i)\t\t\\\n\t  if (ctype_func (i))\t\t\t\\\n\t    bitset_set (sbcset, i);\t\t\\\n      }\t\t\t\t\t\t\\\n  } while (0)\n\n  if (strcmp (name, \"alnum\") == 0)\n    BUILD_CHARCLASS_LOOP (isalnum);\n  else if (strcmp (name, \"cntrl\") == 0)\n    BUILD_CHARCLASS_LOOP (iscntrl);\n  else if (strcmp (name, \"lower\") == 0)\n    BUILD_CHARCLASS_LOOP (islower);\n  else if (strcmp (name, \"space\") == 0)\n    BUILD_CHARCLASS_LOOP (isspace);\n  else if (strcmp (name, \"alpha\") == 0)\n    BUILD_CHARCLASS_LOOP (isalpha);\n  else if (strcmp (name, \"digit\") == 0)\n    BUILD_CHARCLASS_LOOP (isdigit);\n  else if (strcmp (name, \"print\") == 0)\n    BUILD_CHARCLASS_LOOP (isprint);\n  else if (strcmp (name, \"upper\") == 0)\n    BUILD_CHARCLASS_LOOP (isupper);\n  else if (strcmp (name, \"blank\") == 0)\n    BUILD_CHARCLASS_LOOP (isblank);\n  else if (strcmp (name, \"graph\") == 0)\n    BUILD_CHARCLASS_LOOP (isgraph);\n  else if (strcmp (name, \"punct\") == 0)\n    BUILD_CHARCLASS_LOOP (ispunct);\n  else if (strcmp (name, \"xdigit\") == 0)\n    BUILD_CHARCLASS_LOOP (isxdigit);\n  else\n    return REG_ECTYPE;\n\n  return REG_NOERROR;\n}",
      "lines": 75,
      "depth": 20,
      "decorators": null
    },
    "build_charclass_op": {
      "start_point": [
        3640,
        0
      ],
      "end_point": [
        3746,
        1
      ],
      "content": "static bin_tree_t *\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)\n{\n  re_bitset_ptr_t sbcset;\n#ifdef RE_ENABLE_I18N\n  re_charset_t *mbcset;\n  Idx alloc = 0;\n#endif /* not RE_ENABLE_I18N */\n  reg_errcode_t ret;\n  re_token_t br_token;\n  bin_tree_t *tree;\n\n  sbcset = (re_bitset_ptr_t) calloc (sizeof (bitset_t), 1);\n#ifdef RE_ENABLE_I18N\n  mbcset = (re_charset_t *) calloc (sizeof (re_charset_t), 1);\n#endif /* RE_ENABLE_I18N */\n\n#ifdef RE_ENABLE_I18N\n  if (BE (sbcset == NULL || mbcset == NULL, 0))\n#else /* not RE_ENABLE_I18N */\n  if (BE (sbcset == NULL, 0))\n#endif /* not RE_ENABLE_I18N */\n    {\n      *err = REG_ESPACE;\n      return NULL;\n    }\n\n  if (non_match)\n    {\n#ifdef RE_ENABLE_I18N\n      mbcset->non_match = 1;\n#endif /* not RE_ENABLE_I18N */\n    }\n\n  /* We don't care the syntax in this case.  */\n  ret = build_charclass (trans, sbcset,\n#ifdef RE_ENABLE_I18N\n\t\t\t mbcset, &alloc,\n#endif /* RE_ENABLE_I18N */\n\t\t\t class_name, 0);\n\n  if (BE (ret != REG_NOERROR, 0))\n    {\n      re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n      free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n      *err = ret;\n      return NULL;\n    }\n  /* \\w match '_' also.  */\n  for (; *extra; extra++)\n    bitset_set (sbcset, *extra);\n\n  /* If it is non-matching list.  */\n  if (non_match)\n    bitset_not (sbcset);\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure only single byte characters are set.  */\n  if (dfa->mb_cur_max > 1)\n    bitset_mask (sbcset, dfa->sb_char);\n#endif\n\n  /* Build a tree for simple bracket.  */\n  br_token.type = SIMPLE_BRACKET;\n  br_token.opr.sbcset = sbcset;\n  tree = create_token_tree (dfa, NULL, NULL, &br_token);\n  if (BE (tree == NULL, 0))\n    goto build_word_op_espace;\n\n#ifdef RE_ENABLE_I18N\n  if (dfa->mb_cur_max > 1)\n    {\n      bin_tree_t *mbc_tree;\n      /* Build a tree for complex bracket.  */\n      br_token.type = COMPLEX_BRACKET;\n      br_token.opr.mbcset = mbcset;\n      dfa->has_mb_node = 1;\n      mbc_tree = create_token_tree (dfa, NULL, NULL, &br_token);\n      if (BE (mbc_tree == NULL, 0))\n\tgoto build_word_op_espace;\n      /* Then join them by ALT node.  */\n      tree = create_tree (dfa, tree, mbc_tree, OP_ALT);\n      if (BE (mbc_tree != NULL, 1))\n\treturn tree;\n    }\n  else\n    {\n      free_charset (mbcset);\n      return tree;\n    }\n#else /* not RE_ENABLE_I18N */\n  return tree;\n#endif /* not RE_ENABLE_I18N */\n\n build_word_op_espace:\n  re_free (sbcset);\n#ifdef RE_ENABLE_I18N\n  free_charset (mbcset);\n#endif /* RE_ENABLE_I18N */\n  *err = REG_ESPACE;\n  return NULL;\n}",
      "lines": 107,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nbuild_charclass_op (re_dfa_t *dfa, RE_TRANSLATE_TYPE trans,\n\t\t    const char *class_name,\n\t\t    const char *extra, bool non_match,\n\t\t    reg_errcode_t *err)",
        "*"
      ]
    },
    "fetch_number": {
      "start_point": [
        3754,
        0
      ],
      "end_point": [
        3775,
        1
      ],
      "content": "static Idx\nfetch_number (re_string_t *input, re_token_t *token, reg_syntax_t syntax)\n{\n  Idx num = REG_MISSING;\n  unsigned char c;\n  while (1)\n    {\n      fetch_token (token, input, syntax);\n      c = token->opr.c;\n      if (BE (token->type == END_OF_RE, 0))\n\treturn REG_ERROR;\n      if (token->type == OP_CLOSE_DUP_NUM || c == ',')\n\tbreak;\n      num = ((token->type != CHARACTER || c < '0' || '9' < c\n\t      || num == REG_ERROR)\n\t     ? REG_ERROR\n\t     : num == REG_MISSING\n\t     ? c - '0'\n\t     : MIN (RE_DUP_MAX + 1, num * 10 + c - '0'));\n    }\n  return num;\n}",
      "lines": 22,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx"
      ]
    },
    "free_charset": {
      "start_point": [
        3778,
        0
      ],
      "end_point": [
        3790,
        1
      ],
      "content": "static void\nfree_charset (re_charset_t *cset)\n{\n  re_free (cset->mbchars);\n# ifdef _LIBC\n  re_free (cset->coll_syms);\n  re_free (cset->equiv_classes);\n  re_free (cset->range_starts);\n  re_free (cset->range_ends);\n# endif\n  re_free (cset->char_classes);\n  re_free (cset);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_tree": {
      "start_point": [
        3797,
        0
      ],
      "end_point": [
        3804,
        1
      ],
      "content": "static bin_tree_t *\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)\n{\n  re_token_t t;\n  t.type = type;\n  return create_token_tree (dfa, left, right, &t);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t     re_token_type_t type)",
        "*"
      ]
    },
    "create_token_tree": {
      "start_point": [
        3806,
        0
      ],
      "end_point": [
        3838,
        1
      ],
      "content": "static bin_tree_t *\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)\n{\n  bin_tree_t *tree;\n  if (BE (dfa->str_tree_storage_idx == BIN_TREE_STORAGE_SIZE, 0))\n    {\n      bin_tree_storage_t *storage = re_malloc (bin_tree_storage_t, 1);\n\n      if (storage == NULL)\n\treturn NULL;\n      storage->next = dfa->str_tree_storage;\n      dfa->str_tree_storage = storage;\n      dfa->str_tree_storage_idx = 0;\n    }\n  tree = &dfa->str_tree_storage->data[dfa->str_tree_storage_idx++];\n\n  tree->parent = NULL;\n  tree->left = left;\n  tree->right = right;\n  tree->token = *token;\n  tree->token.duplicated = 0;\n  tree->token.opt_subexp = 0;\n  tree->first = NULL;\n  tree->next = NULL;\n  tree->node_idx = REG_MISSING;\n\n  if (left != NULL)\n    left->parent = tree;\n  if (right != NULL)\n    right->parent = tree;\n  return tree;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\ncreate_token_tree (re_dfa_t *dfa, bin_tree_t *left, bin_tree_t *right,\n\t\t   const re_token_t *token)",
        "*"
      ]
    },
    "mark_opt_subexp": {
      "start_point": [
        3843,
        0
      ],
      "end_point": [
        3851,
        1
      ],
      "content": "static reg_errcode_t\nmark_opt_subexp (void *extra, bin_tree_t *node)\n{\n  Idx idx = (uintptr_t) extra;\n  if (node->token.type == SUBEXP && node->token.opr.idx == idx)\n    node->token.opt_subexp = 1;\n\n  return REG_NOERROR;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "free_token": {
      "start_point": [
        3855,
        0
      ],
      "end_point": [
        3865,
        1
      ],
      "content": "static void\nfree_token (re_token_t *node)\n{\n#ifdef RE_ENABLE_I18N\n  if (node->type == COMPLEX_BRACKET && node->duplicated == 0)\n    free_charset (node->opr.mbcset);\n  else\n#endif /* RE_ENABLE_I18N */\n    if (node->type == SIMPLE_BRACKET && node->duplicated == 0)\n      re_free (node->opr.sbcset);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "free_tree": {
      "start_point": [
        3870,
        0
      ],
      "end_point": [
        3875,
        1
      ],
      "content": "static reg_errcode_t\nfree_tree (void *extra, bin_tree_t *node)\n{\n  free_token (&node->token);\n  return REG_NOERROR;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t"
      ]
    },
    "duplicate_tree": {
      "start_point": [
        3883,
        0
      ],
      "end_point": [
        3921,
        1
      ],
      "content": "static bin_tree_t *\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)\n{\n  const bin_tree_t *node;\n  bin_tree_t *dup_root;\n  bin_tree_t **p_new = &dup_root, *dup_node = root->parent;\n\n  for (node = root; ; )\n    {\n      /* Create a new tree and link it back to the current parent.  */\n      *p_new = create_token_tree (dfa, NULL, NULL, &node->token);\n      if (*p_new == NULL)\n\treturn NULL;\n      (*p_new)->parent = dup_node;\n      (*p_new)->token.duplicated = 1;\n      dup_node = *p_new;\n\n      /* Go to the left node, or up and to the right.  */\n      if (node->left)\n\t{\n\t  node = node->left;\n\t  p_new = &dup_node->left;\n\t}\n      else\n\t{\n\t  const bin_tree_t *prev = NULL;\n\t  while (node->right == prev || node->right == NULL)\n\t    {\n\t      prev = node;\n\t      node = node->parent;\n\t      dup_node = dup_node->parent;\n\t      if (!node)\n\t\treturn dup_root;\n\t    }\n\t  node = node->right;\n\t  p_new = &dup_node->right;\n\t}\n    }\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bin_tree_t",
        "*\nduplicate_tree (const bin_tree_t *root, re_dfa_t *dfa)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/regex.c": {},
  "recutils/recutils-1.7/lib/regex.h": {},
  "recutils/recutils-1.7/lib/regexec.c": {
    "__compat_regexec": {
      "start_point": [
        264,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "int\nattribute_compat_text_section\n__compat_regexec (const regex_t *_Restrict_ preg,\n\t\t  const char *_Restrict_ string, size_t nmatch,\n\t\t  regmatch_t pmatch[], int eflags)\n{\n  return regexec (preg, string, nmatch, pmatch,\n\t\t  eflags & (REG_NOTBOL | REG_NOTEOL));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int",
        "attribute_compat_text_section",
        "attribute_compat_text_section"
      ]
    },
    "re_search_2_stub": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "static regoff_t\nre_search_2_stub (struct re_pattern_buffer *bufp,\n\t\t  const char *string1, Idx length1,\n\t\t  const char *string2, Idx length2,\n\t\t  Idx start, regoff_t range, struct re_registers *regs,\n\t\t  Idx stop, bool ret_len)\n{\n  const char *str;\n  regoff_t rval;\n  Idx len = length1 + length2;\n  char *s = NULL;\n\n  if (BE (length1 < 0 || length2 < 0 || stop < 0 || len < length1, 0))\n    return -2;\n\n  /* Concatenate the strings.  */\n  if (length2 > 0)\n    if (length1 > 0)\n      {\n\ts = re_malloc (char, len);\n\n\tif (BE (s == NULL, 0))\n\t  return -2;\n#ifdef _LIBC\n\tmemcpy (__mempcpy (s, string1, length1), string2, length2);\n#else\n\tmemcpy (s, string1, length1);\n\tmemcpy (s + length1, string2, length2);\n#endif\n\tstr = s;\n      }\n    else\n      str = string2;\n  else\n    str = string1;\n\n  rval = re_search_stub (bufp, str, len, start, range, stop, regs,\n\t\t\t ret_len);\n  re_free (s);\n  return rval;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_search_stub": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        498,
        1
      ],
      "content": "static regoff_t\nre_search_stub (struct re_pattern_buffer *bufp,\n\t\tconst char *string, Idx length,\n\t\tIdx start, regoff_t range, Idx stop, struct re_registers *regs,\n\t\tbool ret_len)\n{\n  reg_errcode_t result;\n  regmatch_t *pmatch;\n  Idx nregs;\n  regoff_t rval;\n  int eflags = 0;\n  re_dfa_t *dfa = bufp->buffer;\n  Idx last_start = start + range;\n\n  /* Check for out-of-range.  */\n  if (BE (start < 0 || start > length, 0))\n    return -1;\n  if (BE (length < last_start || (0 <= range && last_start < start), 0))\n    last_start = length;\n  else if (BE (last_start < 0 || (range < 0 && start <= last_start), 0))\n    last_start = 0;\n\n  lock_lock (dfa->lock);\n\n  eflags |= (bufp->not_bol) ? REG_NOTBOL : 0;\n  eflags |= (bufp->not_eol) ? REG_NOTEOL : 0;\n\n  /* Compile fastmap if we haven't yet.  */\n  if (start < last_start && bufp->fastmap != NULL && !bufp->fastmap_accurate)\n    re_compile_fastmap (bufp);\n\n  if (BE (bufp->no_sub, 0))\n    regs = NULL;\n\n  /* We need at least 1 register.  */\n  if (regs == NULL)\n    nregs = 1;\n  else if (BE (bufp->regs_allocated == REGS_FIXED\n\t       && regs->num_regs <= bufp->re_nsub, 0))\n    {\n      nregs = regs->num_regs;\n      if (BE (nregs < 1, 0))\n\t{\n\t  /* Nothing can be copied to regs.  */\n\t  regs = NULL;\n\t  nregs = 1;\n\t}\n    }\n  else\n    nregs = bufp->re_nsub + 1;\n  pmatch = re_malloc (regmatch_t, nregs);\n  if (BE (pmatch == NULL, 0))\n    {\n      rval = -2;\n      goto out;\n    }\n\n  result = re_search_internal (bufp, string, length, start, last_start, stop,\n\t\t\t       nregs, pmatch, eflags);\n\n  rval = 0;\n\n  /* I hope we needn't fill their regs with -1's when no match was found.  */\n  if (result != REG_NOERROR)\n    rval = result == REG_NOMATCH ? -1 : -2;\n  else if (regs != NULL)\n    {\n      /* If caller wants register contents data back, copy them.  */\n      bufp->regs_allocated = re_copy_regs (regs, pmatch, nregs,\n\t\t\t\t\t   bufp->regs_allocated);\n      if (BE (bufp->regs_allocated == REGS_UNALLOCATED, 0))\n\trval = -2;\n    }\n\n  if (BE (rval == 0, 1))\n    {\n      if (ret_len)\n\t{\n\t  assert (pmatch[0].rm_so == start);\n\t  rval = pmatch[0].rm_eo - start;\n\t}\n      else\n\trval = pmatch[0].rm_so;\n    }\n  re_free (pmatch);\n out:\n  lock_unlock (dfa->lock);\n  return rval;\n}",
      "lines": 89,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "regoff_t"
      ]
    },
    "re_copy_regs": {
      "start_point": [
        500,
        0
      ],
      "end_point": [
        563,
        1
      ],
      "content": "static unsigned\nre_copy_regs (struct re_registers *regs, regmatch_t *pmatch, Idx nregs,\n\t      int regs_allocated)\n{\n  int rval = REGS_REALLOCATE;\n  Idx i;\n  Idx need_regs = nregs + 1;\n  /* We need one extra element beyond 'num_regs' for the '-1' marker GNU code\n     uses.  */\n\n  /* Have the register data arrays been allocated?  */\n  if (regs_allocated == REGS_UNALLOCATED)\n    { /* No.  So allocate them with malloc.  */\n      regs->start = re_malloc (regoff_t, need_regs);\n      if (BE (regs->start == NULL, 0))\n\treturn REGS_UNALLOCATED;\n      regs->end = re_malloc (regoff_t, need_regs);\n      if (BE (regs->end == NULL, 0))\n\t{\n\t  re_free (regs->start);\n\t  return REGS_UNALLOCATED;\n\t}\n      regs->num_regs = need_regs;\n    }\n  else if (regs_allocated == REGS_REALLOCATE)\n    { /* Yes.  If we need more elements than were already\n\t allocated, reallocate them.  If we need fewer, just\n\t leave it alone.  */\n      if (BE (need_regs > regs->num_regs, 0))\n\t{\n\t  regoff_t *new_start = re_realloc (regs->start, regoff_t, need_regs);\n\t  regoff_t *new_end;\n\t  if (BE (new_start == NULL, 0))\n\t    return REGS_UNALLOCATED;\n\t  new_end = re_realloc (regs->end, regoff_t, need_regs);\n\t  if (BE (new_end == NULL, 0))\n\t    {\n\t      re_free (new_start);\n\t      return REGS_UNALLOCATED;\n\t    }\n\t  regs->start = new_start;\n\t  regs->end = new_end;\n\t  regs->num_regs = need_regs;\n\t}\n    }\n  else\n    {\n      assert (regs_allocated == REGS_FIXED);\n      /* This function may not be called with REGS_FIXED and nregs too big.  */\n      assert (regs->num_regs >= nregs);\n      rval = REGS_FIXED;\n    }\n\n  /* Copy the regs.  */\n  for (i = 0; i < nregs; ++i)\n    {\n      regs->start[i] = pmatch[i].rm_so;\n      regs->end[i] = pmatch[i].rm_eo;\n    }\n  for ( ; i < regs->num_regs; ++i)\n    regs->start[i] = regs->end[i] = -1;\n\n  return rval;\n}",
      "lines": 64,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "re_search_internal": {
      "start_point": [
        629,
        0
      ],
      "end_point": [
        963,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nre_search_internal (const regex_t *preg,\n\t\t    const char *string, Idx length,\n\t\t    Idx start, Idx last_start, Idx stop,\n\t\t    size_t nmatch, regmatch_t pmatch[],\n\t\t    int eflags)\n{\n  reg_errcode_t err;\n  const re_dfa_t *dfa = preg->buffer;\n  Idx left_lim, right_lim;\n  int incr;\n  bool fl_longest_match;\n  int match_kind;\n  Idx match_first;\n  Idx match_last = REG_MISSING;\n  Idx extra_nmatch;\n  bool sb;\n  int ch;\n#if defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)\n  re_match_context_t mctx = { .dfa = dfa };\n#else\n  re_match_context_t mctx;\n#endif\n  char *fastmap = ((preg->fastmap != NULL && preg->fastmap_accurate\n\t\t    && start != last_start && !preg->can_be_null)\n\t\t   ? preg->fastmap : NULL);\n  RE_TRANSLATE_TYPE t = preg->translate;\n\n#if !(defined _LIBC || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L))\n  memset (&mctx, '\\0', sizeof (re_match_context_t));\n  mctx.dfa = dfa;\n#endif\n\n  extra_nmatch = (nmatch > preg->re_nsub) ? nmatch - (preg->re_nsub + 1) : 0;\n  nmatch -= extra_nmatch;\n\n  /* Check if the DFA haven't been compiled.  */\n  if (BE (preg->used == 0 || dfa->init_state == NULL\n\t  || dfa->init_state_word == NULL || dfa->init_state_nl == NULL\n\t  || dfa->init_state_begbuf == NULL, 0))\n    return REG_NOMATCH;\n\n#ifdef DEBUG\n  /* We assume front-end functions already check them.  */\n  assert (0 <= last_start && last_start <= length);\n#endif\n\n  /* If initial states with non-begbuf contexts have no elements,\n     the regex must be anchored.  If preg->newline_anchor is set,\n     we'll never use init_state_nl, so do not check it.  */\n  if (dfa->init_state->nodes.nelem == 0\n      && dfa->init_state_word->nodes.nelem == 0\n      && (dfa->init_state_nl->nodes.nelem == 0\n\t  || !preg->newline_anchor))\n    {\n      if (start != 0 && last_start != 0)\n        return REG_NOMATCH;\n      start = last_start = 0;\n    }\n\n  /* We must check the longest matching, if nmatch > 0.  */\n  fl_longest_match = (nmatch != 0 || dfa->nbackref);\n\n  err = re_string_allocate (&mctx.input, string, length, dfa->nodes_len + 1,\n\t\t\t    preg->translate, (preg->syntax & RE_ICASE) != 0,\n\t\t\t    dfa);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n  mctx.input.stop = stop;\n  mctx.input.raw_stop = stop;\n  mctx.input.newline_anchor = preg->newline_anchor;\n\n  err = match_ctx_init (&mctx, eflags, dfa->nbackref * 2);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* We will log all the DFA states through which the dfa pass,\n     if nmatch > 1, or this dfa has \"multibyte node\", which is a\n     back-reference or a node which can accept multibyte character or\n     multi character collating element.  */\n  if (nmatch > 1 || dfa->has_mb_node)\n    {\n      /* Avoid overflow.  */\n      if (BE ((MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *))\n               <= mctx.input.bufs_len), 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n\n      mctx.state_log = re_malloc (re_dfastate_t *, mctx.input.bufs_len + 1);\n      if (BE (mctx.state_log == NULL, 0))\n\t{\n\t  err = REG_ESPACE;\n\t  goto free_return;\n\t}\n    }\n  else\n    mctx.state_log = NULL;\n\n  match_first = start;\n  mctx.input.tip_context = (eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF;\n\n  /* Check incrementally whether the input string matches.  */\n  incr = (last_start < start) ? -1 : 1;\n  left_lim = (last_start < start) ? last_start : start;\n  right_lim = (last_start < start) ? start : last_start;\n  sb = dfa->mb_cur_max == 1;\n  match_kind =\n    (fastmap\n     ? ((sb || !(preg->syntax & RE_ICASE || t) ? 4 : 0)\n\t| (start <= last_start ? 2 : 0)\n\t| (t != NULL ? 1 : 0))\n     : 8);\n\n  for (;; match_first += incr)\n    {\n      err = REG_NOMATCH;\n      if (match_first < left_lim || right_lim < match_first)\n\tgoto free_return;\n\n      /* Advance as rapidly as possible through the string, until we\n\t find a plausible place to start matching.  This may be done\n\t with varying efficiency, so there are various possibilities:\n\t only the most common of them are specialized, in order to\n\t save on code size.  We use a switch statement for speed.  */\n      switch (match_kind)\n\t{\n\tcase 8:\n\t  /* No fastmap.  */\n\t  break;\n\n\tcase 7:\n\t  /* Fastmap with single-byte translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[t[(unsigned char) string[match_first]]])\n\t    ++match_first;\n\t  goto forward_match_found_start_or_reached_end;\n\n\tcase 6:\n\t  /* Fastmap without translation, match forward.  */\n\t  while (BE (match_first < right_lim, 1)\n\t\t && !fastmap[(unsigned char) string[match_first]])\n\t    ++match_first;\n\n\tforward_match_found_start_or_reached_end:\n\t  if (BE (match_first == right_lim, 0))\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (!fastmap[t ? t[ch] : ch])\n\t\tgoto free_return;\n\t    }\n\t  break;\n\n\tcase 4:\n\tcase 5:\n\t  /* Fastmap without multi-byte translation, match backwards.  */\n\t  while (match_first >= left_lim)\n\t    {\n\t      ch = match_first >= length\n\t\t       ? 0 : (unsigned char) string[match_first];\n\t      if (fastmap[t ? t[ch] : ch])\n\t\tbreak;\n\t      --match_first;\n\t    }\n\t  if (match_first < left_lim)\n\t    goto free_return;\n\t  break;\n\n\tdefault:\n\t  /* In this case, we can't determine easily the current byte,\n\t     since it might be a component byte of a multibyte\n\t     character.  Then we use the constructed buffer instead.  */\n\t  for (;;)\n\t    {\n\t      /* If MATCH_FIRST is out of the valid range, reconstruct the\n\t\t buffers.  */\n\t      __re_size_t offset = match_first - mctx.input.raw_mbs_idx;\n\t      if (BE (offset >= (__re_size_t) mctx.input.valid_raw_len, 0))\n\t\t{\n\t\t  err = re_string_reconstruct (&mctx.input, match_first,\n\t\t\t\t\t       eflags);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    goto free_return;\n\n\t\t  offset = match_first - mctx.input.raw_mbs_idx;\n\t\t}\n\t      /* If MATCH_FIRST is out of the buffer, leave it as '\\0'.\n\t\t Note that MATCH_FIRST must not be smaller than 0.  */\n\t      ch = (match_first >= length\n\t\t    ? 0 : re_string_byte_at (&mctx.input, offset));\n\t      if (fastmap[ch])\n\t\tbreak;\n\t      match_first += incr;\n\t      if (match_first < left_lim || match_first > right_lim)\n\t\t{\n\t\t  err = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    }\n\t  break;\n\t}\n\n      /* Reconstruct the buffers so that the matcher can assume that\n\t the matching starts from the beginning of the buffer.  */\n      err = re_string_reconstruct (&mctx.input, match_first, eflags);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n#ifdef RE_ENABLE_I18N\n     /* Don't consider this char as a possible match start if it part,\n\tyet isn't the head, of a multibyte character.  */\n      if (!sb && !re_string_first_byte (&mctx.input, 0))\n\tcontinue;\n#endif\n\n      /* It seems to be appropriate one, then use the matcher.  */\n      /* We assume that the matching starts from 0.  */\n      mctx.state_log_top = mctx.nbkref_ents = mctx.max_mb_elem_len = 0;\n      match_last = check_matching (&mctx, fl_longest_match,\n\t\t\t\t   start <= last_start ? &match_first : NULL);\n      if (match_last != REG_MISSING)\n\t{\n\t  if (BE (match_last == REG_ERROR, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  else\n\t    {\n\t      mctx.match_last = match_last;\n\t      if ((!preg->no_sub && nmatch > 1) || dfa->nbackref)\n\t\t{\n\t\t  re_dfastate_t *pstate = mctx.state_log[match_last];\n\t\t  mctx.last_node = check_halt_state_context (&mctx, pstate,\n\t\t\t\t\t\t\t     match_last);\n\t\t}\n\t      if ((!preg->no_sub && nmatch > 1 && dfa->has_plural_match)\n\t\t  || dfa->nbackref)\n\t\t{\n\t\t  err = prune_impossible_nodes (&mctx);\n\t\t  if (err == REG_NOERROR)\n\t\t    break;\n\t\t  if (BE (err != REG_NOMATCH, 0))\n\t\t    goto free_return;\n\t\t  match_last = REG_MISSING;\n\t\t}\n\t      else\n\t\tbreak; /* We found a match.  */\n\t    }\n\t}\n\n      match_ctx_clean (&mctx);\n    }\n\n#ifdef DEBUG\n  assert (match_last != REG_MISSING);\n  assert (err == REG_NOERROR);\n#endif\n\n  /* Set pmatch[] if we need.  */\n  if (nmatch > 0)\n    {\n      Idx reg_idx;\n\n      /* Initialize registers.  */\n      for (reg_idx = 1; reg_idx < nmatch; ++reg_idx)\n\tpmatch[reg_idx].rm_so = pmatch[reg_idx].rm_eo = -1;\n\n      /* Set the points where matching start/end.  */\n      pmatch[0].rm_so = 0;\n      pmatch[0].rm_eo = mctx.match_last;\n      /* FIXME: This function should fail if mctx.match_last exceeds\n\t the maximum possible regoff_t value.  We need a new error\n\t code REG_OVERFLOW.  */\n\n      if (!preg->no_sub && nmatch > 1)\n\t{\n\t  err = set_regs (preg, &mctx, nmatch, pmatch,\n\t\t\t  dfa->has_plural_match && dfa->nbackref > 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* At last, add the offset to each register, since we slid\n\t the buffers so that we could assume that the matching starts\n\t from 0.  */\n      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\tif (pmatch[reg_idx].rm_so != -1)\n\t  {\n#ifdef RE_ENABLE_I18N\n\t    if (BE (mctx.input.offsets_needed != 0, 0))\n\t      {\n\t\tpmatch[reg_idx].rm_so =\n\t\t  (pmatch[reg_idx].rm_so == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_so]);\n\t\tpmatch[reg_idx].rm_eo =\n\t\t  (pmatch[reg_idx].rm_eo == mctx.input.valid_len\n\t\t   ? mctx.input.valid_raw_len\n\t\t   : mctx.input.offsets[pmatch[reg_idx].rm_eo]);\n\t      }\n#else\n\t    assert (mctx.input.offsets_needed == 0);\n#endif\n\t    pmatch[reg_idx].rm_so += match_first;\n\t    pmatch[reg_idx].rm_eo += match_first;\n\t  }\n      for (reg_idx = 0; reg_idx < extra_nmatch; ++reg_idx)\n\t{\n\t  pmatch[nmatch + reg_idx].rm_so = -1;\n\t  pmatch[nmatch + reg_idx].rm_eo = -1;\n\t}\n\n      if (dfa->subexp_map)\n\tfor (reg_idx = 0; reg_idx + 1 < nmatch; reg_idx++)\n\t  if (dfa->subexp_map[reg_idx] != reg_idx)\n\t    {\n\t      pmatch[reg_idx + 1].rm_so\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_so;\n\t      pmatch[reg_idx + 1].rm_eo\n\t\t= pmatch[dfa->subexp_map[reg_idx] + 1].rm_eo;\n\t    }\n    }\n\n free_return:\n  re_free (mctx.state_log);\n  if (dfa->nbackref)\n    match_ctx_free (&mctx);\n  re_string_destruct (&mctx.input);\n  return err;\n}",
      "lines": 335,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "prune_impossible_nodes": {
      "start_point": [
        965,
        0
      ],
      "end_point": [
        1055,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nprune_impossible_nodes (re_match_context_t *mctx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx halt_node, match_last;\n  reg_errcode_t ret;\n  re_dfastate_t **sifted_states;\n  re_dfastate_t **lim_states = NULL;\n  re_sift_context_t sctx;\n#ifdef DEBUG\n  assert (mctx->state_log != NULL);\n#endif\n  match_last = mctx->match_last;\n  halt_node = mctx->last_node;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) <= match_last, 0))\n    return REG_ESPACE;\n\n  sifted_states = re_malloc (re_dfastate_t *, match_last + 1);\n  if (BE (sifted_states == NULL, 0))\n    {\n      ret = REG_ESPACE;\n      goto free_return;\n    }\n  if (dfa->nbackref)\n    {\n      lim_states = re_malloc (re_dfastate_t *, match_last + 1);\n      if (BE (lim_states == NULL, 0))\n\t{\n\t  ret = REG_ESPACE;\n\t  goto free_return;\n\t}\n      while (1)\n\t{\n\t  memset (lim_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * (match_last + 1));\n\t  sift_ctx_init (&sctx, sifted_states, lim_states, halt_node,\n\t\t\t match_last);\n\t  ret = sift_states_backward (mctx, &sctx);\n\t  re_node_set_free (&sctx.limits);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t      goto free_return;\n\t  if (sifted_states[0] != NULL || lim_states[0] != NULL)\n\t    break;\n\t  do\n\t    {\n\t      --match_last;\n\t      if (! REG_VALID_INDEX (match_last))\n\t\t{\n\t\t  ret = REG_NOMATCH;\n\t\t  goto free_return;\n\t\t}\n\t    } while (mctx->state_log[match_last] == NULL\n\t\t     || !mctx->state_log[match_last]->halt);\n\t  halt_node = check_halt_state_context (mctx,\n\t\t\t\t\t\tmctx->state_log[match_last],\n\t\t\t\t\t\tmatch_last);\n\t}\n      ret = merge_state_array (dfa, sifted_states, lim_states,\n\t\t\t       match_last + 1);\n      re_free (lim_states);\n      lim_states = NULL;\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  else\n    {\n      sift_ctx_init (&sctx, sifted_states, lim_states, halt_node, match_last);\n      ret = sift_states_backward (mctx, &sctx);\n      re_node_set_free (&sctx.limits);\n      if (BE (ret != REG_NOERROR, 0))\n\tgoto free_return;\n      if (sifted_states[0] == NULL)\n\t{\n\t  ret = REG_NOMATCH;\n\t  goto free_return;\n\t}\n    }\n  re_free (mctx->state_log);\n  mctx->state_log = sifted_states;\n  sifted_states = NULL;\n  mctx->last_node = halt_node;\n  mctx->match_last = match_last;\n  ret = REG_NOERROR;\n free_return:\n  re_free (sifted_states);\n  re_free (lim_states);\n  return ret;\n}",
      "lines": 91,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "acquire_init_state_context": {
      "start_point": [
        1062,
        32
      ],
      "end_point": [
        1092,
        1
      ],
      "content": "internal_function\nacquire_init_state_context (reg_errcode_t *err, const re_match_context_t *mctx,\n\t\t\t    Idx idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  if (dfa->init_state->has_constraint)\n    {\n      unsigned int context;\n      context = re_string_context_at (&mctx->input, idx - 1, mctx->eflags);\n      if (IS_WORD_CONTEXT (context))\n\treturn dfa->init_state_word;\n      else if (IS_ORDINARY_CONTEXT (context))\n\treturn dfa->init_state;\n      else if (IS_BEGBUF_CONTEXT (context) && IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_begbuf;\n      else if (IS_NEWLINE_CONTEXT (context))\n\treturn dfa->init_state_nl;\n      else if (IS_BEGBUF_CONTEXT (context))\n\t{\n\t  /* It is relatively rare case, then calculate on demand.  */\n\t  return re_acquire_state_context (err, dfa,\n\t\t\t\t\t   dfa->init_state->entrance_nodes,\n\t\t\t\t\t   context);\n\t}\n      else\n\t/* Must not happen?  */\n\treturn dfa->init_state;\n    }\n  else\n    return dfa->init_state;\n}",
      "lines": 31,
      "depth": 16,
      "decorators": [
        "internal_function"
      ]
    },
    "check_matching": {
      "start_point": [
        1104,
        18
      ],
      "end_point": [
        1232,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_matching (re_match_context_t *mctx, bool fl_longest_match,\n\t\tIdx *p_match_first)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx match = 0;\n  Idx match_last = REG_MISSING;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n  re_dfastate_t *cur_state;\n  bool at_init_state = p_match_first != NULL;\n  Idx next_start_idx = cur_str_idx;\n\n  err = REG_NOERROR;\n  cur_state = acquire_init_state_context (&err, mctx, cur_str_idx);\n  /* An initial state must not be NULL (invalid).  */\n  if (BE (cur_state == NULL, 0))\n    {\n      assert (err == REG_ESPACE);\n      return REG_ERROR;\n    }\n\n  if (mctx->state_log != NULL)\n    {\n      mctx->state_log[cur_str_idx] = cur_state;\n\n      /* Check OP_OPEN_SUBEXP in the initial state in case that we use them\n\t later.  E.g. Processing back references.  */\n      if (BE (dfa->nbackref, 0))\n\t{\n\t  at_init_state = false;\n\t  err = check_subexp_matching_top (mctx, &cur_state->nodes, 0);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  if (cur_state->has_backref)\n\t    {\n\t      err = transit_state_bkref (mctx, &cur_state->nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n    }\n\n  /* If the RE accepts NULL string.  */\n  if (BE (cur_state->halt, 0))\n    {\n      if (!cur_state->has_constraint\n\t  || check_halt_state_context (mctx, cur_state, cur_str_idx))\n\t{\n\t  if (!fl_longest_match)\n\t    return cur_str_idx;\n\t  else\n\t    {\n\t      match_last = cur_str_idx;\n\t      match = 1;\n\t    }\n\t}\n    }\n\n  while (!re_string_eoi (&mctx->input))\n    {\n      re_dfastate_t *old_state = cur_state;\n      Idx next_char_idx = re_string_cur_idx (&mctx->input) + 1;\n\n      if ((BE (next_char_idx >= mctx->input.bufs_len, 0)\n\t   && mctx->input.bufs_len < mctx->input.len)\n\t  || (BE (next_char_idx >= mctx->input.valid_len, 0)\n\t      && mctx->input.valid_len < mctx->input.len))\n\t{\n\t  err = extend_buffers (mctx, next_char_idx + 1);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      assert (err == REG_ESPACE);\n\t      return REG_ERROR;\n\t    }\n\t}\n\n      cur_state = transit_state (&err, mctx, cur_state);\n      if (mctx->state_log != NULL)\n\tcur_state = merge_state_with_log (&err, mctx, cur_state);\n\n      if (cur_state == NULL)\n\t{\n\t  /* Reached the invalid state or an error.  Try to recover a valid\n\t     state using the state log, if available and if we have not\n\t     already found a valid (even if not the longest) match.  */\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ERROR;\n\n\t  if (mctx->state_log == NULL\n\t      || (match && !fl_longest_match)\n\t      || (cur_state = find_recover_state (&err, mctx)) == NULL)\n\t    break;\n\t}\n\n      if (BE (at_init_state, 0))\n\t{\n\t  if (old_state == cur_state)\n\t    next_start_idx = next_char_idx;\n\t  else\n\t    at_init_state = false;\n\t}\n\n      if (cur_state->halt)\n\t{\n\t  /* Reached a halt state.\n\t     Check the halt state can satisfy the current context.  */\n\t  if (!cur_state->has_constraint\n\t      || check_halt_state_context (mctx, cur_state,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input)))\n\t    {\n\t      /* We found an appropriate halt state.  */\n\t      match_last = re_string_cur_idx (&mctx->input);\n\t      match = 1;\n\n\t      /* We found a match, do not modify match_first below.  */\n\t      p_match_first = NULL;\n\t      if (!fl_longest_match)\n\t\tbreak;\n\t    }\n\t}\n    }\n\n  if (p_match_first)\n    *p_match_first += next_start_idx;\n\n  return match_last;\n}",
      "lines": 129,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_halt_node_context": {
      "start_point": [
        1236,
        0
      ],
      "end_point": [
        1249,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_halt_node_context (const re_dfa_t *dfa, Idx node, unsigned int context)\n{\n  re_token_type_t type = dfa->nodes[node].type;\n  unsigned int constraint = dfa->nodes[node].constraint;\n  if (type != END_OF_RE)\n    return false;\n  if (!constraint)\n    return true;\n  if (NOT_SATISFY_NEXT_CONSTRAINT (constraint, context))\n    return false;\n  return true;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_halt_state_context": {
      "start_point": [
        1255,
        0
      ],
      "end_point": [
        1270,
        1
      ],
      "content": "static Idx\ninternal_function\ncheck_halt_state_context (const re_match_context_t *mctx,\n\t\t\t  const re_dfastate_t *state, Idx idx)\n{\n  Idx i;\n  unsigned int context;\n#ifdef DEBUG\n  assert (state->halt);\n#endif\n  context = re_string_context_at (&mctx->input, idx, mctx->eflags);\n  for (i = 0; i < state->nodes.nelem; ++i)\n    if (check_halt_node_context (mctx->dfa, state->nodes.elems[i], context))\n      return state->nodes.elems[i];\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "proceed_next_node": {
      "start_point": [
        1277,
        0
      ],
      "end_point": [
        1377,
        1
      ],
      "content": "static Idx\ninternal_function\nproceed_next_node (const re_match_context_t *mctx, Idx nregs, regmatch_t *regs,\n\t\t   Idx *pidx, Idx node, re_node_set *eps_via_nodes,\n\t\t   struct re_fail_stack_t *fs)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx i;\n  bool ok;\n  if (IS_EPSILON_NODE (dfa->nodes[node].type))\n    {\n      re_node_set *cur_nodes = &mctx->state_log[*pidx]->nodes;\n      re_node_set *edests = &dfa->edests[node];\n      Idx dest_node;\n      ok = re_node_set_insert (eps_via_nodes, node);\n      if (BE (! ok, 0))\n\treturn REG_ERROR;\n      /* Pick up a valid destination, or return REG_MISSING if none\n\t is found.  */\n      for (dest_node = REG_MISSING, i = 0; i < edests->nelem; ++i)\n\t{\n\t  Idx candidate = edests->elems[i];\n\t  if (!re_node_set_contains (cur_nodes, candidate))\n\t    continue;\n          if (dest_node == REG_MISSING)\n\t    dest_node = candidate;\n\n\t  else\n\t    {\n\t      /* In order to avoid infinite loop like \"(a*)*\", return the second\n\t\t epsilon-transition if the first was already considered.  */\n\t      if (re_node_set_contains (eps_via_nodes, dest_node))\n\t\treturn candidate;\n\n\t      /* Otherwise, push the second epsilon-transition on the fail stack.  */\n\t      else if (fs != NULL\n\t\t       && push_fail_stack (fs, *pidx, candidate, nregs, regs,\n\t\t\t\t\t   eps_via_nodes))\n\t\treturn REG_ERROR;\n\n\t      /* We know we are going to exit.  */\n\t      break;\n\t    }\n\t}\n      return dest_node;\n    }\n  else\n    {\n      Idx naccepted = 0;\n      re_token_type_t type = dfa->nodes[node].type;\n\n#ifdef RE_ENABLE_I18N\n      if (dfa->nodes[node].accept_mb)\n\tnaccepted = check_node_accept_bytes (dfa, node, &mctx->input, *pidx);\n      else\n#endif /* RE_ENABLE_I18N */\n      if (type == OP_BACK_REF)\n\t{\n\t  Idx subexp_idx = dfa->nodes[node].opr.idx + 1;\n\t  naccepted = regs[subexp_idx].rm_eo - regs[subexp_idx].rm_so;\n\t  if (fs != NULL)\n\t    {\n\t      if (regs[subexp_idx].rm_so == -1 || regs[subexp_idx].rm_eo == -1)\n\t\treturn REG_MISSING;\n\t      else if (naccepted)\n\t\t{\n\t\t  char *buf = (char *) re_string_get_buffer (&mctx->input);\n\t\t  if (memcmp (buf + regs[subexp_idx].rm_so, buf + *pidx,\n\t\t\t      naccepted) != 0)\n\t\t    return REG_MISSING;\n\t\t}\n\t    }\n\n\t  if (naccepted == 0)\n\t    {\n\t      Idx dest_node;\n\t      ok = re_node_set_insert (eps_via_nodes, node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ERROR;\n\t      dest_node = dfa->edests[node].elems[0];\n\t      if (re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\tdest_node))\n\t\treturn dest_node;\n\t    }\n\t}\n\n      if (naccepted != 0\n\t  || check_node_accept (mctx, dfa->nodes + node, *pidx))\n\t{\n\t  Idx dest_node = dfa->nexts[node];\n\t  *pidx = (naccepted == 0) ? *pidx + 1 : *pidx + naccepted;\n\t  if (fs && (*pidx > mctx->match_last || mctx->state_log[*pidx] == NULL\n\t\t     || !re_node_set_contains (&mctx->state_log[*pidx]->nodes,\n\t\t\t\t\t       dest_node)))\n\t    return REG_MISSING;\n\t  re_node_set_empty (eps_via_nodes);\n\t  return dest_node;\n\t}\n    }\n  return REG_MISSING;\n}",
      "lines": 101,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "push_fail_stack": {
      "start_point": [
        1380,
        18
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "__attribute_warn_unused_result__\npush_fail_stack (struct re_fail_stack_t *fs, Idx str_idx, Idx dest_node,\n\t\t Idx nregs, regmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  reg_errcode_t err;\n  Idx num = fs->num++;\n  if (fs->num == fs->alloc)\n    {\n      struct re_fail_stack_ent_t *new_array;\n      new_array = realloc (fs->stack, (sizeof (struct re_fail_stack_ent_t)\n\t\t\t\t       * fs->alloc * 2));\n      if (new_array == NULL)\n\treturn REG_ESPACE;\n      fs->alloc *= 2;\n      fs->stack = new_array;\n    }\n  fs->stack[num].idx = str_idx;\n  fs->stack[num].node = dest_node;\n  fs->stack[num].regs = re_malloc (regmatch_t, nregs);\n  if (fs->stack[num].regs == NULL)\n    return REG_ESPACE;\n  memcpy (fs->stack[num].regs, regs, sizeof (regmatch_t) * nregs);\n  err = re_node_set_init_copy (&fs->stack[num].eps_via_nodes, eps_via_nodes);\n  return err;\n}",
      "lines": 25,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pop_fail_stack": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1419,
        1
      ],
      "content": "static Idx\ninternal_function\npop_fail_stack (struct re_fail_stack_t *fs, Idx *pidx, Idx nregs,\n\t\tregmatch_t *regs, re_node_set *eps_via_nodes)\n{\n  Idx num = --fs->num;\n  assert (REG_VALID_INDEX (num));\n  *pidx = fs->stack[num].idx;\n  memcpy (regs, fs->stack[num].regs, sizeof (regmatch_t) * nregs);\n  re_node_set_free (eps_via_nodes);\n  re_free (fs->stack[num].regs);\n  *eps_via_nodes = fs->stack[num].eps_via_nodes;\n  return fs->stack[num].node;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "set_regs": {
      "start_point": [
        1427,
        18
      ],
      "end_point": [
        1531,
        1
      ],
      "content": "__attribute_warn_unused_result__\nset_regs (const regex_t *preg, const re_match_context_t *mctx, size_t nmatch,\n\t  regmatch_t *pmatch, bool fl_backtrack)\n{\n  const re_dfa_t *dfa = preg->buffer;\n  Idx idx, cur_node;\n  re_node_set eps_via_nodes;\n  struct re_fail_stack_t *fs;\n  struct re_fail_stack_t fs_body = { 0, 2, NULL };\n  regmatch_t *prev_idx_match;\n  bool prev_idx_match_malloced = false;\n\n#ifdef DEBUG\n  assert (nmatch > 1);\n  assert (mctx->state_log != NULL);\n#endif\n  if (fl_backtrack)\n    {\n      fs = &fs_body;\n      fs->stack = re_malloc (struct re_fail_stack_ent_t, fs->alloc);\n      if (fs->stack == NULL)\n\treturn REG_ESPACE;\n    }\n  else\n    fs = NULL;\n\n  cur_node = dfa->init_node;\n  re_node_set_init_empty (&eps_via_nodes);\n\n  if (__libc_use_alloca (nmatch * sizeof (regmatch_t)))\n    prev_idx_match = (regmatch_t *) alloca (nmatch * sizeof (regmatch_t));\n  else\n    {\n      prev_idx_match = re_malloc (regmatch_t, nmatch);\n      if (prev_idx_match == NULL)\n\t{\n\t  free_fail_stack_return (fs);\n\t  return REG_ESPACE;\n\t}\n      prev_idx_match_malloced = true;\n    }\n  memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\n  for (idx = pmatch[0].rm_so; idx <= pmatch[0].rm_eo ;)\n    {\n      update_regs (dfa, pmatch, prev_idx_match, cur_node, idx, nmatch);\n\n      if (idx == pmatch[0].rm_eo && cur_node == mctx->last_node)\n\t{\n\t  Idx reg_idx;\n\t  if (fs)\n\t    {\n\t      for (reg_idx = 0; reg_idx < nmatch; ++reg_idx)\n\t\tif (pmatch[reg_idx].rm_so > -1 && pmatch[reg_idx].rm_eo == -1)\n\t\t  break;\n\t      if (reg_idx == nmatch)\n\t\t{\n\t\t  re_node_set_free (&eps_via_nodes);\n\t\t  if (prev_idx_match_malloced)\n\t\t    re_free (prev_idx_match);\n\t\t  return free_fail_stack_return (fs);\n\t\t}\n\t      cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t\t &eps_via_nodes);\n\t    }\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOERROR;\n\t    }\n\t}\n\n      /* Proceed to next node.  */\n      cur_node = proceed_next_node (mctx, nmatch, pmatch, &idx, cur_node,\n\t\t\t\t    &eps_via_nodes, fs);\n\n      if (BE (! REG_VALID_INDEX (cur_node), 0))\n\t{\n\t  if (BE (cur_node == REG_ERROR, 0))\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      free_fail_stack_return (fs);\n\t      return REG_ESPACE;\n\t    }\n\t  if (fs)\n\t    cur_node = pop_fail_stack (fs, &idx, nmatch, pmatch,\n\t\t\t\t       &eps_via_nodes);\n\t  else\n\t    {\n\t      re_node_set_free (&eps_via_nodes);\n\t      if (prev_idx_match_malloced)\n\t\tre_free (prev_idx_match);\n\t      return REG_NOMATCH;\n\t    }\n\t}\n    }\n  re_node_set_free (&eps_via_nodes);\n  if (prev_idx_match_malloced)\n    re_free (prev_idx_match);\n  return free_fail_stack_return (fs);\n}",
      "lines": 105,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "free_fail_stack_return": {
      "start_point": [
        1533,
        0
      ],
      "end_point": [
        1548,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nfree_fail_stack_return (struct re_fail_stack_t *fs)\n{\n  if (fs)\n    {\n      Idx fs_idx;\n      for (fs_idx = 0; fs_idx < fs->num; ++fs_idx)\n\t{\n\t  re_node_set_free (&fs->stack[fs_idx].eps_via_nodes);\n\t  re_free (fs->stack[fs_idx].regs);\n\t}\n      re_free (fs->stack);\n    }\n  return REG_NOERROR;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_regs": {
      "start_point": [
        1550,
        0
      ],
      "end_point": [
        1597,
        1
      ],
      "content": "static void\ninternal_function\nupdate_regs (const re_dfa_t *dfa, regmatch_t *pmatch,\n\t     regmatch_t *prev_idx_match, Idx cur_node, Idx cur_idx, Idx nmatch)\n{\n  int type = dfa->nodes[cur_node].type;\n  if (type == OP_OPEN_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n\n      /* We are at the first node of this sub expression.  */\n      if (reg_num < nmatch)\n\t{\n\t  pmatch[reg_num].rm_so = cur_idx;\n\t  pmatch[reg_num].rm_eo = -1;\n\t}\n    }\n  else if (type == OP_CLOSE_SUBEXP)\n    {\n      Idx reg_num = dfa->nodes[cur_node].opr.idx + 1;\n      if (reg_num < nmatch)\n\t{\n\t  /* We are at the last node of this sub expression.  */\n\t  if (pmatch[reg_num].rm_so < cur_idx)\n\t    {\n\t      pmatch[reg_num].rm_eo = cur_idx;\n\t      /* This is a non-empty match or we are not inside an optional\n\t\t subexpression.  Accept this right away.  */\n\t      memcpy (prev_idx_match, pmatch, sizeof (regmatch_t) * nmatch);\n\t    }\n\t  else\n\t    {\n\t      if (dfa->nodes[cur_node].opt_subexp\n\t\t  && prev_idx_match[reg_num].rm_so != -1)\n\t\t/* We transited through an empty match for an optional\n\t\t   subexpression, like (a?)*, and this is not the subexp's\n\t\t   first match.  Copy back the old content of the registers\n\t\t   so that matches of an inner subexpression are undone as\n\t\t   well, like in ((a?))*.  */\n\t\tmemcpy (pmatch, prev_idx_match, sizeof (regmatch_t) * nmatch);\n\t      else\n\t\t/* We completed a subexpression, but it may be part of\n\t\t   an optional one, so do not update PREV_IDX_MATCH.  */\n\t\tpmatch[reg_num].rm_eo = cur_idx;\n\t    }\n\t}\n    }\n}",
      "lines": 48,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_backward": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1678,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsift_states_backward (const re_match_context_t *mctx, re_sift_context_t *sctx)\n{\n  reg_errcode_t err;\n  int null_cnt = 0;\n  Idx str_idx = sctx->last_str_idx;\n  re_node_set cur_dest;\n\n#ifdef DEBUG\n  assert (mctx->state_log != NULL && mctx->state_log[str_idx] != NULL);\n#endif\n\n  /* Build sifted state_log[str_idx].  It has the nodes which can epsilon\n     transit to the last_node and the last_node itself.  */\n  err = re_node_set_init_1 (&cur_dest, sctx->last_node);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n  if (BE (err != REG_NOERROR, 0))\n    goto free_return;\n\n  /* Then check each states in the state_log.  */\n  while (str_idx > 0)\n    {\n      /* Update counters.  */\n      null_cnt = (sctx->sifted_states[str_idx] == NULL) ? null_cnt + 1 : 0;\n      if (null_cnt > mctx->max_mb_elem_len)\n\t{\n\t  memset (sctx->sifted_states, '\\0',\n\t\t  sizeof (re_dfastate_t *) * str_idx);\n\t  re_node_set_free (&cur_dest);\n\t  return REG_NOERROR;\n\t}\n      re_node_set_empty (&cur_dest);\n      --str_idx;\n\n      if (mctx->state_log[str_idx])\n\t{\n\t  err = build_sifted_states (mctx, sctx, str_idx, &cur_dest);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t}\n\n      /* Add all the nodes which satisfy the following conditions:\n\t - It can epsilon transit to a node in CUR_DEST.\n\t - It is in CUR_SRC.\n\t And update state_log.  */\n      err = update_cur_sifted_state (mctx, sctx, str_idx, &cur_dest);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n    }\n  err = REG_NOERROR;\n free_return:\n  re_node_set_free (&cur_dest);\n  return err;\n}",
      "lines": 57,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "build_sifted_states": {
      "start_point": [
        1681,
        18
      ],
      "end_point": [
        1738,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_sifted_states (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx str_idx, re_node_set *cur_dest)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *cur_src = &mctx->state_log[str_idx]->non_eps_nodes;\n  Idx i;\n\n  /* Then build the next sifted state.\n     We build the next sifted state on 'cur_dest', and update\n     'sifted_states[str_idx]' with 'cur_dest'.\n     Note:\n     'cur_dest' is the sifted state from 'state_log[str_idx + 1]'.\n     'cur_src' points the node_set of the old 'state_log[str_idx]'\n     (with the epsilon nodes pre-filtered out).  */\n  for (i = 0; i < cur_src->nelem; i++)\n    {\n      Idx prev_node = cur_src->elems[i];\n      int naccepted = 0;\n      bool ok;\n\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[prev_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[prev_node].accept_mb)\n\tnaccepted = sift_states_iter_mb (mctx, sctx, prev_node,\n\t\t\t\t\t str_idx, sctx->last_str_idx);\n#endif /* RE_ENABLE_I18N */\n\n      /* We don't check backreferences here.\n\t See update_cur_sifted_state().  */\n      if (!naccepted\n\t  && check_node_accept (mctx, dfa->nodes + prev_node, str_idx)\n\t  && STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + 1],\n\t\t\t\t  dfa->nexts[prev_node]))\n\tnaccepted = 1;\n\n      if (naccepted == 0)\n\tcontinue;\n\n      if (sctx->limits.nelem)\n\t{\n\t  Idx to_idx = str_idx + naccepted;\n\t  if (check_dst_limits (mctx, &sctx->limits,\n\t\t\t\tdfa->nexts[prev_node], to_idx,\n\t\t\t\tprev_node, str_idx))\n\t    continue;\n\t}\n      ok = re_node_set_insert (cur_dest, prev_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "clean_state_log_if_needed": {
      "start_point": [
        1742,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nclean_state_log_if_needed (re_match_context_t *mctx, Idx next_state_log_idx)\n{\n  Idx top = mctx->state_log_top;\n\n  if ((next_state_log_idx >= mctx->input.bufs_len\n       && mctx->input.bufs_len < mctx->input.len)\n      || (next_state_log_idx >= mctx->input.valid_len\n\t  && mctx->input.valid_len < mctx->input.len))\n    {\n      reg_errcode_t err;\n      err = extend_buffers (mctx, next_state_log_idx + 1);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (top < next_state_log_idx)\n    {\n      memset (mctx->state_log + top + 1, '\\0',\n\t      sizeof (re_dfastate_t *) * (next_state_log_idx - top));\n      mctx->state_log_top = next_state_log_idx;\n    }\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "merge_state_array": {
      "start_point": [
        1768,
        0
      ],
      "end_point": [
        1793,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nmerge_state_array (const re_dfa_t *dfa, re_dfastate_t **dst,\n\t\t   re_dfastate_t **src, Idx num)\n{\n  Idx st_idx;\n  reg_errcode_t err;\n  for (st_idx = 0; st_idx < num; ++st_idx)\n    {\n      if (dst[st_idx] == NULL)\n\tdst[st_idx] = src[st_idx];\n      else if (src[st_idx] != NULL)\n\t{\n\t  re_node_set merged_set;\n\t  err = re_node_set_init_union (&merged_set, &dst[st_idx]->nodes,\n\t\t\t\t\t&src[st_idx]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t  dst[st_idx] = re_acquire_state (&err, dfa, &merged_set);\n\t  re_node_set_free (&merged_set);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "update_cur_sifted_state": {
      "start_point": [
        1795,
        0
      ],
      "end_point": [
        1841,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nupdate_cur_sifted_state (const re_match_context_t *mctx,\n\t\t\t re_sift_context_t *sctx, Idx str_idx,\n\t\t\t re_node_set *dest_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  const re_node_set *candidates;\n  candidates = ((mctx->state_log[str_idx] == NULL) ? NULL\n\t\t: &mctx->state_log[str_idx]->nodes);\n\n  if (dest_nodes->nelem == 0)\n    sctx->sifted_states[str_idx] = NULL;\n  else\n    {\n      if (candidates)\n\t{\n\t  /* At first, add the nodes which can epsilon transit to a node in\n\t     DEST_NODE.  */\n\t  err = add_epsilon_src_nodes (dfa, dest_nodes, candidates);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\n\t  /* Then, check the limitations in the current sift_context.  */\n\t  if (sctx->limits.nelem)\n\t    {\n\t      err = check_subexp_limits (dfa, dest_nodes, candidates, &sctx->limits,\n\t\t\t\t\t mctx->bkref_ents, str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t}\n\n      sctx->sifted_states[str_idx] = re_acquire_state (&err, dfa, dest_nodes);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n\n  if (candidates && mctx->state_log[str_idx]->has_backref)\n    {\n      err = sift_states_bkref (mctx, sctx, str_idx, candidates);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 47,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "add_epsilon_src_nodes": {
      "start_point": [
        1844,
        18
      ],
      "end_point": [
        1870,
        1
      ],
      "content": "__attribute_warn_unused_result__\nadd_epsilon_src_nodes (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n  reg_errcode_t err = REG_NOERROR;\n  Idx i;\n\n  re_dfastate_t *state = re_acquire_state (&err, dfa, dest_nodes);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n\n  if (!state->inveclosure.alloc)\n    {\n      err = re_node_set_alloc (&state->inveclosure, dest_nodes->nelem);\n      if (BE (err != REG_NOERROR, 0))\n\treturn REG_ESPACE;\n      for (i = 0; i < dest_nodes->nelem; i++)\n\t{\n\t  err = re_node_set_merge (&state->inveclosure,\n\t\t\t\t   dfa->inveclosures + dest_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return REG_ESPACE;\n\t}\n    }\n  return re_node_set_add_intersect (dest_nodes, candidates,\n\t\t\t\t    &state->inveclosure);\n}",
      "lines": 27,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sub_epsilon_src_nodes": {
      "start_point": [
        1872,
        0
      ],
      "end_point": [
        1919,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nsub_epsilon_src_nodes (const re_dfa_t *dfa, Idx node, re_node_set *dest_nodes,\n\t\t       const re_node_set *candidates)\n{\n    Idx ecl_idx;\n    reg_errcode_t err;\n    re_node_set *inv_eclosure = dfa->inveclosures + node;\n    re_node_set except_nodes;\n    re_node_set_init_empty (&except_nodes);\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (cur_node == node)\n\t  continue;\n\tif (IS_EPSILON_NODE (dfa->nodes[cur_node].type))\n\t  {\n\t    Idx edst1 = dfa->edests[cur_node].elems[0];\n\t    Idx edst2 = ((dfa->edests[cur_node].nelem > 1)\n\t\t\t ? dfa->edests[cur_node].elems[1] : REG_MISSING);\n\t    if ((!re_node_set_contains (inv_eclosure, edst1)\n\t\t && re_node_set_contains (dest_nodes, edst1))\n\t\t|| (REG_VALID_NONZERO_INDEX (edst2)\n\t\t    && !re_node_set_contains (inv_eclosure, edst2)\n\t\t    && re_node_set_contains (dest_nodes, edst2)))\n\t      {\n\t\terr = re_node_set_add_intersect (&except_nodes, candidates,\n\t\t\t\t\t\t dfa->inveclosures + cur_node);\n\t\tif (BE (err != REG_NOERROR, 0))\n\t\t  {\n\t\t    re_node_set_free (&except_nodes);\n\t\t    return err;\n\t\t  }\n\t      }\n\t  }\n      }\n    for (ecl_idx = 0; ecl_idx < inv_eclosure->nelem; ++ecl_idx)\n      {\n\tIdx cur_node = inv_eclosure->elems[ecl_idx];\n\tif (!re_node_set_contains (&except_nodes, cur_node))\n\t  {\n\t    Idx idx = re_node_set_contains (dest_nodes, cur_node) - 1;\n\t    re_node_set_remove_at (dest_nodes, idx);\n\t  }\n      }\n    re_node_set_free (&except_nodes);\n    return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits": {
      "start_point": [
        1921,
        0
      ],
      "end_point": [
        1955,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_dst_limits (const re_match_context_t *mctx, const re_node_set *limits,\n\t\t  Idx dst_node, Idx dst_idx, Idx src_node, Idx src_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx lim_idx, src_pos, dst_pos;\n\n  Idx dst_bkref_idx = search_cur_bkref_entry (mctx, dst_idx);\n  Idx src_bkref_idx = search_cur_bkref_entry (mctx, src_idx);\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = mctx->bkref_ents + limits->elems[lim_idx];\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n\n      dst_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, dst_node, dst_idx,\n\t\t\t\t\t   dst_bkref_idx);\n      src_pos = check_dst_limits_calc_pos (mctx, limits->elems[lim_idx],\n\t\t\t\t\t   subexp_idx, src_node, src_idx,\n\t\t\t\t\t   src_bkref_idx);\n\n      /* In case of:\n\t <src> <dst> ( <subexp> )\n\t ( <subexp> ) <src> <dst>\n\t ( <subexp1> <src> <subexp2> <dst> <subexp3> )  */\n      if (src_pos == dst_pos)\n\tcontinue; /* This is unrelated limitation.  */\n      else\n\treturn true;\n    }\n  return false;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos_1": {
      "start_point": [
        1957,
        0
      ],
      "end_point": [
        2037,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos_1 (const re_match_context_t *mctx, int boundaries,\n\t\t\t     Idx subexp_idx, Idx from_node, Idx bkref_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  const re_node_set *eclosures = dfa->eclosures + from_node;\n  Idx node_idx;\n\n  /* Else, we are on the boundary: examine the nodes on the epsilon\n     closure.  */\n  for (node_idx = 0; node_idx < eclosures->nelem; ++node_idx)\n    {\n      Idx node = eclosures->elems[node_idx];\n      switch (dfa->nodes[node].type)\n\t{\n\tcase OP_BACK_REF:\n\t  if (bkref_idx != REG_MISSING)\n\t    {\n\t      struct re_backref_cache_entry *ent = mctx->bkref_ents + bkref_idx;\n\t      do\n\t\t{\n\t\t  Idx dst;\n\t\t  int cpos;\n\n\t\t  if (ent->node != node)\n\t\t    continue;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS\n\t\t      && !(ent->eps_reachable_subexps_map\n\t\t\t   & ((bitset_word_t) 1 << subexp_idx)))\n\t\t    continue;\n\n\t\t  /* Recurse trying to reach the OP_OPEN_SUBEXP and\n\t\t     OP_CLOSE_SUBEXP cases below.  But, if the\n\t\t     destination node is the same node as the source\n\t\t     node, don't recurse because it would cause an\n\t\t     infinite loop: a regex that exhibits this behavior\n\t\t     is ()\\1*\\1*  */\n\t\t  dst = dfa->edests[node].elems[0];\n\t\t  if (dst == from_node)\n\t\t    {\n\t\t      if (boundaries & 1)\n\t\t\treturn -1;\n\t\t      else /* if (boundaries & 2) */\n\t\t\treturn 0;\n\t\t    }\n\n\t\t  cpos =\n\t\t    check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t\t\t dst, bkref_idx);\n\t\t  if (cpos == -1 /* && (boundaries & 1) */)\n\t\t    return -1;\n\t\t  if (cpos == 0 && (boundaries & 2))\n\t\t    return 0;\n\n\t\t  if (subexp_idx < BITSET_WORD_BITS)\n\t\t    ent->eps_reachable_subexps_map\n\t\t      &= ~((bitset_word_t) 1 << subexp_idx);\n\t\t}\n\t      while (ent++->more);\n\t    }\n\t  break;\n\n\tcase OP_OPEN_SUBEXP:\n\t  if ((boundaries & 1) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return -1;\n\t  break;\n\n\tcase OP_CLOSE_SUBEXP:\n\t  if ((boundaries & 2) && subexp_idx == dfa->nodes[node].opr.idx)\n\t    return 0;\n\t  break;\n\n\tdefault:\n\t    break;\n\t}\n    }\n\n  return (boundaries & 2) ? 1 : 0;\n}",
      "lines": 81,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_dst_limits_calc_pos": {
      "start_point": [
        2039,
        0
      ],
      "end_point": [
        2064,
        1
      ],
      "content": "static int\ninternal_function\ncheck_dst_limits_calc_pos (const re_match_context_t *mctx, Idx limit,\n\t\t\t   Idx subexp_idx, Idx from_node, Idx str_idx,\n\t\t\t   Idx bkref_idx)\n{\n  struct re_backref_cache_entry *lim = mctx->bkref_ents + limit;\n  int boundaries;\n\n  /* If we are outside the range of the subexpression, return -1 or 1.  */\n  if (str_idx < lim->subexp_from)\n    return -1;\n\n  if (lim->subexp_to < str_idx)\n    return 1;\n\n  /* If we are within the subexpression, return 0.  */\n  boundaries = (str_idx == lim->subexp_from);\n  boundaries |= (str_idx == lim->subexp_to) << 1;\n  if (boundaries == 0)\n    return 0;\n\n  /* Else, examine epsilon closure.  */\n  return check_dst_limits_calc_pos_1 (mctx, boundaries, subexp_idx,\n\t\t\t\t      from_node, bkref_idx);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_limits": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2155,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_limits (const re_dfa_t *dfa, re_node_set *dest_nodes,\n\t\t     const re_node_set *candidates, re_node_set *limits,\n\t\t     struct re_backref_cache_entry *bkref_ents, Idx str_idx)\n{\n  reg_errcode_t err;\n  Idx node_idx, lim_idx;\n\n  for (lim_idx = 0; lim_idx < limits->nelem; ++lim_idx)\n    {\n      Idx subexp_idx;\n      struct re_backref_cache_entry *ent;\n      ent = bkref_ents + limits->elems[lim_idx];\n\n      if (str_idx <= ent->subexp_from || ent->str_idx < str_idx)\n\tcontinue; /* This is unrelated limitation.  */\n\n      subexp_idx = dfa->nodes[ent->node].opr.idx;\n      if (ent->subexp_to == str_idx)\n\t{\n\t  Idx ops_node = REG_MISSING;\n\t  Idx cls_node = REG_MISSING;\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_OPEN_SUBEXP\n\t\t  && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tops_node = node;\n\t      else if (type == OP_CLOSE_SUBEXP\n\t\t       && subexp_idx == dfa->nodes[node].opr.idx)\n\t\tcls_node = node;\n\t    }\n\n\t  /* Check the limitation of the open subexpression.  */\n\t  /* Note that (ent->subexp_to = str_idx != ent->subexp_from).  */\n\t  if (REG_VALID_INDEX (ops_node))\n\t    {\n\t      err = sub_epsilon_src_nodes (dfa, ops_node, dest_nodes,\n\t\t\t\t\t   candidates);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\n\t  /* Check the limitation of the close subexpression.  */\n\t  if (REG_VALID_INDEX (cls_node))\n\t    for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t      {\n\t\tIdx node = dest_nodes->elems[node_idx];\n\t\tif (!re_node_set_contains (dfa->inveclosures + node,\n\t\t\t\t\t   cls_node)\n\t\t    && !re_node_set_contains (dfa->eclosures + node,\n\t\t\t\t\t      cls_node))\n\t\t  {\n\t\t    /* It is against this limitation.\n\t\t       Remove it form the current sifted state.  */\n\t\t    err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t\t candidates);\n\t\t    if (BE (err != REG_NOERROR, 0))\n\t\t      return err;\n\t\t    --node_idx;\n\t\t  }\n\t      }\n\t}\n      else /* (ent->subexp_to != str_idx)  */\n\t{\n\t  for (node_idx = 0; node_idx < dest_nodes->nelem; ++node_idx)\n\t    {\n\t      Idx node = dest_nodes->elems[node_idx];\n\t      re_token_type_t type = dfa->nodes[node].type;\n\t      if (type == OP_CLOSE_SUBEXP || type == OP_OPEN_SUBEXP)\n\t\t{\n\t\t  if (subexp_idx != dfa->nodes[node].opr.idx)\n\t\t    continue;\n\t\t  /* It is against this limitation.\n\t\t     Remove it form the current sifted state.  */\n\t\t  err = sub_epsilon_src_nodes (dfa, node, dest_nodes,\n\t\t\t\t\t       candidates);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t}\n\t    }\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 87,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_states_bkref": {
      "start_point": [
        2158,
        18
      ],
      "end_point": [
        2253,
        1
      ],
      "content": "__attribute_warn_unused_result__\nsift_states_bkref (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t   Idx str_idx, const re_node_set *candidates)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx node_idx, node;\n  re_sift_context_t local_sctx;\n  Idx first_idx = search_cur_bkref_entry (mctx, str_idx);\n\n  if (first_idx == REG_MISSING)\n    return REG_NOERROR;\n\n  local_sctx.sifted_states = NULL; /* Mark that it hasn't been initialized.  */\n\n  for (node_idx = 0; node_idx < candidates->nelem; ++node_idx)\n    {\n      Idx enabled_idx;\n      re_token_type_t type;\n      struct re_backref_cache_entry *entry;\n      node = candidates->elems[node_idx];\n      type = dfa->nodes[node].type;\n      /* Avoid infinite loop for the REs like \"()\\1+\".  */\n      if (node == sctx->last_node && str_idx == sctx->last_str_idx)\n\tcontinue;\n      if (type != OP_BACK_REF)\n\tcontinue;\n\n      entry = mctx->bkref_ents + first_idx;\n      enabled_idx = first_idx;\n      do\n\t{\n\t  Idx subexp_len;\n\t  Idx to_idx;\n\t  Idx dst_node;\n\t  bool ok;\n\t  re_dfastate_t *cur_state;\n\n\t  if (entry->node != node)\n\t    continue;\n\t  subexp_len = entry->subexp_to - entry->subexp_from;\n\t  to_idx = str_idx + subexp_len;\n\t  dst_node = (subexp_len ? dfa->nexts[node]\n\t\t      : dfa->edests[node].elems[0]);\n\n\t  if (to_idx > sctx->last_str_idx\n\t      || sctx->sifted_states[to_idx] == NULL\n\t      || !STATE_NODE_CONTAINS (sctx->sifted_states[to_idx], dst_node)\n\t      || check_dst_limits (mctx, &sctx->limits, node,\n\t\t\t\t   str_idx, dst_node, to_idx))\n\t    continue;\n\n\t  if (local_sctx.sifted_states == NULL)\n\t    {\n\t      local_sctx = *sctx;\n\t      err = re_node_set_init_copy (&local_sctx.limits, &sctx->limits);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.last_node = node;\n\t  local_sctx.last_str_idx = str_idx;\n\t  ok = re_node_set_insert (&local_sctx.limits, enabled_idx);\n\t  if (BE (! ok, 0))\n\t    {\n\t      err = REG_ESPACE;\n\t      goto free_return;\n\t    }\n\t  cur_state = local_sctx.sifted_states[str_idx];\n\t  err = sift_states_backward (mctx, &local_sctx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto free_return;\n\t  if (sctx->limited_states != NULL)\n\t    {\n\t      err = merge_state_array (dfa, sctx->limited_states,\n\t\t\t\t       local_sctx.sifted_states,\n\t\t\t\t       str_idx + 1);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  local_sctx.sifted_states[str_idx] = cur_state;\n\t  re_node_set_remove (&local_sctx.limits, enabled_idx);\n\n\t  /* mctx->bkref_ents may have changed, reload the pointer.  */\n\t  entry = mctx->bkref_ents + enabled_idx;\n\t}\n      while (enabled_idx++, entry++->more);\n    }\n  err = REG_NOERROR;\n free_return:\n  if (local_sctx.sifted_states != NULL)\n    {\n      re_node_set_free (&local_sctx.limits);\n    }\n\n  return err;\n}",
      "lines": 96,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "sift_states_iter_mb": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2276,
        1
      ],
      "content": "static int\ninternal_function\nsift_states_iter_mb (const re_match_context_t *mctx, re_sift_context_t *sctx,\n\t\t     Idx node_idx, Idx str_idx, Idx max_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  int naccepted;\n  /* Check the node can accept \"multi byte\".  */\n  naccepted = check_node_accept_bytes (dfa, node_idx, &mctx->input, str_idx);\n  if (naccepted > 0 && str_idx + naccepted <= max_str_idx &&\n      !STATE_NODE_CONTAINS (sctx->sifted_states[str_idx + naccepted],\n\t\t\t    dfa->nexts[node_idx]))\n    /* The node can't accept the \"multi byte\", or the\n       destination was already thrown away, then the node\n       could't accept the current input \"multi byte\".   */\n    naccepted = 0;\n  /* Otherwise, it is sure that the node could accept\n     'naccepted' bytes input.  */\n  return naccepted;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state": {
      "start_point": [
        2288,
        18
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "__attribute_warn_unused_result__\ntransit_state (reg_errcode_t *err, re_match_context_t *mctx,\n\t       re_dfastate_t *state)\n{\n  re_dfastate_t **trtable;\n  unsigned char ch;\n\n#ifdef RE_ENABLE_I18N\n  /* If the current state can accept multibyte.  */\n  if (BE (state->accept_mb, 0))\n    {\n      *err = transit_state_mb (mctx, state);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n    }\n#endif /* RE_ENABLE_I18N */\n\n  /* Then decide the next state with the single byte.  */\n#if 0\n  if (0)\n    /* don't use transition table  */\n    return transit_state_sb (err, mctx, state);\n#endif\n\n  /* Use transition table  */\n  ch = re_string_fetch_byte (&mctx->input);\n  for (;;)\n    {\n      trtable = state->trtable;\n      if (BE (trtable != NULL, 1))\n\treturn trtable[ch];\n\n      trtable = state->word_trtable;\n      if (BE (trtable != NULL, 1))\n\t{\n\t  unsigned int context;\n\t  context\n\t    = re_string_context_at (&mctx->input,\n\t\t\t\t    re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t    mctx->eflags);\n\t  if (IS_WORD_CONTEXT (context))\n\t    return trtable[ch + SBC_MAX];\n\t  else\n\t    return trtable[ch];\n\t}\n\n      if (!build_trtable (mctx->dfa, state))\n\t{\n\t  *err = REG_ESPACE;\n\t  return NULL;\n\t}\n\n      /* Retry, we now have a transition table.  */\n    }\n}",
      "lines": 55,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "merge_state_with_log": {
      "start_point": [
        2345,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx cur_idx = re_string_cur_idx (&mctx->input);\n\n  if (cur_idx > mctx->state_log_top)\n    {\n      mctx->state_log[cur_idx] = next_state;\n      mctx->state_log_top = cur_idx;\n    }\n  else if (mctx->state_log[cur_idx] == 0)\n    {\n      mctx->state_log[cur_idx] = next_state;\n    }\n  else\n    {\n      re_dfastate_t *pstate;\n      unsigned int context;\n      re_node_set next_nodes, *log_nodes, *table_nodes = NULL;\n      /* If (state_log[cur_idx] != 0), it implies that cur_idx is\n\t the destination of a multibyte char/collating element/\n\t back reference.  Then the next state is the union set of\n\t these destinations and the results of the transition table.  */\n      pstate = mctx->state_log[cur_idx];\n      log_nodes = pstate->entrance_nodes;\n      if (next_state != NULL)\n\t{\n\t  table_nodes = next_state->entrance_nodes;\n\t  *err = re_node_set_init_union (&next_nodes, table_nodes,\n\t\t\t\t\t     log_nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t}\n      else\n\tnext_nodes = *log_nodes;\n      /* Note: We already add the nodes of the initial state,\n\t then we don't need to add them here.  */\n\n      context = re_string_context_at (&mctx->input,\n\t\t\t\t      re_string_cur_idx (&mctx->input) - 1,\n\t\t\t\t      mctx->eflags);\n      next_state = mctx->state_log[cur_idx]\n\t= re_acquire_state_context (err, dfa, &next_nodes, context);\n      /* We don't need to check errors here, since the return value of\n\t this function is next_state and ERR is already set.  */\n\n      if (table_nodes != NULL)\n\tre_node_set_free (&next_nodes);\n    }\n\n  if (BE (dfa->nbackref, 0) && next_state != NULL)\n    {\n      /* Check OP_OPEN_SUBEXP in the current state in case that we use them\n\t later.  We must check them here, since the back references in the\n\t next state might use them.  */\n      *err = check_subexp_matching_top (mctx, &next_state->nodes,\n\t\t\t\t\tcur_idx);\n      if (BE (*err != REG_NOERROR, 0))\n\treturn NULL;\n\n      /* If the next state has back references.  */\n      if (next_state->has_backref)\n\t{\n\t  *err = transit_state_bkref (mctx, &next_state->nodes);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    return NULL;\n\t  next_state = mctx->state_log[cur_idx];\n\t}\n    }\n\n  return next_state;\n}",
      "lines": 75,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nmerge_state_with_log (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t      re_dfastate_t *next_state)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "find_recover_state": {
      "start_point": [
        2424,
        0
      ],
      "end_point": [
        2446,
        1
      ],
      "content": "static re_dfastate_t *\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)\n{\n  re_dfastate_t *cur_state;\n  do\n    {\n      Idx max = mctx->state_log_top;\n      Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n      do\n\t{\n\t  if (++cur_str_idx > max)\n\t    return NULL;\n\t  re_string_skip_bytes (&mctx->input, 1);\n\t}\n      while (mctx->state_log[cur_str_idx] == NULL);\n\n      cur_state = merge_state_with_log (err, mctx, NULL);\n    }\n  while (*err == REG_NOERROR && cur_state == NULL);\n  return cur_state;\n}",
      "lines": 23,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ninternal_function\nfind_recover_state (reg_errcode_t *err, re_match_context_t *mctx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "check_subexp_matching_top": {
      "start_point": [
        2455,
        0
      ],
      "end_point": [
        2483,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_subexp_matching_top (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t\t   Idx str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx node_idx;\n  reg_errcode_t err;\n\n  /* TODO: This isn't efficient.\n\t   Because there might be more than one nodes whose types are\n\t   OP_OPEN_SUBEXP and whose index is SUBEXP_IDX, we must check all\n\t   nodes.\n\t   E.g. RE: (a){2}  */\n  for (node_idx = 0; node_idx < cur_nodes->nelem; ++node_idx)\n    {\n      Idx node = cur_nodes->elems[node_idx];\n      if (dfa->nodes[node].type == OP_OPEN_SUBEXP\n\t  && dfa->nodes[node].opr.idx < BITSET_WORD_BITS\n\t  && (dfa->used_bkref_map\n\t      & ((bitset_word_t) 1 << dfa->nodes[node].opr.idx)))\n\t{\n\t  err = match_ctx_add_subtop (mctx, node, str_idx);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_sb": {
      "start_point": [
        2489,
        0
      ],
      "end_point": [
        2524,
        1
      ],
      "content": "static re_dfastate_t *\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  re_node_set next_nodes;\n  re_dfastate_t *next_state;\n  Idx node_cnt, cur_str_idx = re_string_cur_idx (&mctx->input);\n  unsigned int context;\n\n  *err = re_node_set_alloc (&next_nodes, state->nodes.nelem + 1);\n  if (BE (*err != REG_NOERROR, 0))\n    return NULL;\n  for (node_cnt = 0; node_cnt < state->nodes.nelem; ++node_cnt)\n    {\n      Idx cur_node = state->nodes.elems[node_cnt];\n      if (check_node_accept (mctx, dfa->nodes + cur_node, cur_str_idx))\n\t{\n\t  *err = re_node_set_merge (&next_nodes,\n\t\t\t\t    dfa->eclosures + dfa->nexts[cur_node]);\n\t  if (BE (*err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return NULL;\n\t    }\n\t}\n    }\n  context = re_string_context_at (&mctx->input, cur_str_idx, mctx->eflags);\n  next_state = re_acquire_state_context (err, dfa, &next_nodes, context);\n  /* We don't need to check errors here, since the return value of\n     this function is next_state and ERR is already set.  */\n\n  re_node_set_free (&next_nodes);\n  re_string_skip_bytes (&mctx->input, 1);\n  return next_state;\n}",
      "lines": 36,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "re_dfastate_t",
        "*\ntransit_state_sb (reg_errcode_t *err, re_match_context_t *mctx,\n\t\t  re_dfastate_t *state)",
        "*"
      ]
    },
    "transit_state_mb": {
      "start_point": [
        2528,
        0
      ],
      "end_point": [
        2596,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_mb (re_match_context_t *mctx, re_dfastate_t *pstate)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n\n  for (i = 0; i < pstate->nodes.nelem; ++i)\n    {\n      re_node_set dest_nodes, *new_nodes;\n      Idx cur_node_idx = pstate->nodes.elems[i];\n      int naccepted;\n      Idx dest_idx;\n      unsigned int context;\n      re_dfastate_t *dest_state;\n\n      if (!dfa->nodes[cur_node_idx].accept_mb)\n\tcontinue;\n\n      if (dfa->nodes[cur_node_idx].constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input,\n\t\t\t\t\t  re_string_cur_idx (&mctx->input),\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (dfa->nodes[cur_node_idx].constraint,\n\t\t\t\t\t   context))\n\t    continue;\n\t}\n\n      /* How many bytes the node can accept?  */\n      naccepted = check_node_accept_bytes (dfa, cur_node_idx, &mctx->input,\n\t\t\t\t\t   re_string_cur_idx (&mctx->input));\n      if (naccepted == 0)\n\tcontinue;\n\n      /* The node can accepts 'naccepted' bytes.  */\n      dest_idx = re_string_cur_idx (&mctx->input) + naccepted;\n      mctx->max_mb_elem_len = ((mctx->max_mb_elem_len < naccepted) ? naccepted\n\t\t\t       : mctx->max_mb_elem_len);\n      err = clean_state_log_if_needed (mctx, dest_idx);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n#ifdef DEBUG\n      assert (dfa->nexts[cur_node_idx] != REG_MISSING);\n#endif\n      new_nodes = dfa->eclosures + dfa->nexts[cur_node_idx];\n\n      dest_state = mctx->state_log[dest_idx];\n      if (dest_state == NULL)\n\tdest_nodes = *new_nodes;\n      else\n\t{\n\t  err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\tdest_state->entrance_nodes, new_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      context = re_string_context_at (&mctx->input, dest_idx - 1,\n\t\t\t\t      mctx->eflags);\n      mctx->state_log[dest_idx]\n\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n      if (dest_state != NULL)\n\tre_node_set_free (&dest_nodes);\n      if (BE (mctx->state_log[dest_idx] == NULL && err != REG_NOERROR, 0))\n\treturn err;\n    }\n  return REG_NOERROR;\n}",
      "lines": 69,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "transit_state_bkref": {
      "start_point": [
        2599,
        0
      ],
      "end_point": [
        2705,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ntransit_state_bkref (re_match_context_t *mctx, const re_node_set *nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx i;\n  Idx cur_str_idx = re_string_cur_idx (&mctx->input);\n\n  for (i = 0; i < nodes->nelem; ++i)\n    {\n      Idx dest_str_idx, prev_nelem, bkc_idx;\n      Idx node_idx = nodes->elems[i];\n      unsigned int context;\n      const re_token_t *node = dfa->nodes + node_idx;\n      re_node_set *new_dest_nodes;\n\n      /* Check whether 'node' is a backreference or not.  */\n      if (node->type != OP_BACK_REF)\n\tcontinue;\n\n      if (node->constraint)\n\t{\n\t  context = re_string_context_at (&mctx->input, cur_str_idx,\n\t\t\t\t\t  mctx->eflags);\n\t  if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\t    continue;\n\t}\n\n      /* 'node' is a backreference.\n\t Check the substring which the substring matched.  */\n      bkc_idx = mctx->nbkref_ents;\n      err = get_subexp (mctx, node_idx, cur_str_idx);\n      if (BE (err != REG_NOERROR, 0))\n\tgoto free_return;\n\n      /* And add the epsilon closures (which is 'new_dest_nodes') of\n\t the backreference to appropriate state_log.  */\n#ifdef DEBUG\n      assert (dfa->nexts[node_idx] != REG_MISSING);\n#endif\n      for (; bkc_idx < mctx->nbkref_ents; ++bkc_idx)\n\t{\n\t  Idx subexp_len;\n\t  re_dfastate_t *dest_state;\n\t  struct re_backref_cache_entry *bkref_ent;\n\t  bkref_ent = mctx->bkref_ents + bkc_idx;\n\t  if (bkref_ent->node != node_idx || bkref_ent->str_idx != cur_str_idx)\n\t    continue;\n\t  subexp_len = bkref_ent->subexp_to - bkref_ent->subexp_from;\n\t  new_dest_nodes = (subexp_len == 0\n\t\t\t    ? dfa->eclosures + dfa->edests[node_idx].elems[0]\n\t\t\t    : dfa->eclosures + dfa->nexts[node_idx]);\n\t  dest_str_idx = (cur_str_idx + bkref_ent->subexp_to\n\t\t\t  - bkref_ent->subexp_from);\n\t  context = re_string_context_at (&mctx->input, dest_str_idx - 1,\n\t\t\t\t\t  mctx->eflags);\n\t  dest_state = mctx->state_log[dest_str_idx];\n\t  prev_nelem = ((mctx->state_log[cur_str_idx] == NULL) ? 0\n\t\t\t: mctx->state_log[cur_str_idx]->nodes.nelem);\n\t  /* Add 'new_dest_node' to state_log.  */\n\t  if (dest_state == NULL)\n\t    {\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, new_dest_nodes,\n\t\t\t\t\t    context);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  else\n\t    {\n\t      re_node_set dest_nodes;\n\t      err = re_node_set_init_union (&dest_nodes,\n\t\t\t\t\t    dest_state->entrance_nodes,\n\t\t\t\t\t    new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&dest_nodes);\n\t\t  goto free_return;\n\t\t}\n\t      mctx->state_log[dest_str_idx]\n\t\t= re_acquire_state_context (&err, dfa, &dest_nodes, context);\n\t      re_node_set_free (&dest_nodes);\n\t      if (BE (mctx->state_log[dest_str_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t  /* We need to check recursively if the backreference can epsilon\n\t     transit.  */\n\t  if (subexp_len == 0\n\t      && mctx->state_log[cur_str_idx]->nodes.nelem > prev_nelem)\n\t    {\n\t      err = check_subexp_matching_top (mctx, new_dest_nodes,\n\t\t\t\t\t       cur_str_idx);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t      err = transit_state_bkref (mctx, new_dest_nodes);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto free_return;\n\t    }\n\t}\n    }\n  err = REG_NOERROR;\n free_return:\n  return err;\n}",
      "lines": 107,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "get_subexp": {
      "start_point": [
        2714,
        18
      ],
      "end_point": [
        2855,
        1
      ],
      "content": "__attribute_warn_unused_result__\nget_subexp (re_match_context_t *mctx, Idx bkref_node, Idx bkref_str_idx)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  Idx subexp_num, sub_top_idx;\n  const char *buf = (const char *) re_string_get_buffer (&mctx->input);\n  /* Return if we have already checked BKREF_NODE at BKREF_STR_IDX.  */\n  Idx cache_idx = search_cur_bkref_entry (mctx, bkref_str_idx);\n  if (cache_idx != REG_MISSING)\n    {\n      const struct re_backref_cache_entry *entry\n\t= mctx->bkref_ents + cache_idx;\n      do\n\tif (entry->node == bkref_node)\n\t  return REG_NOERROR; /* We already checked it.  */\n      while (entry++->more);\n    }\n\n  subexp_num = dfa->nodes[bkref_node].opr.idx;\n\n  /* For each sub expression  */\n  for (sub_top_idx = 0; sub_top_idx < mctx->nsub_tops; ++sub_top_idx)\n    {\n      reg_errcode_t err;\n      re_sub_match_top_t *sub_top = mctx->sub_tops[sub_top_idx];\n      re_sub_match_last_t *sub_last;\n      Idx sub_last_idx, sl_str, bkref_str_off;\n\n      if (dfa->nodes[sub_top->node].opr.idx != subexp_num)\n\tcontinue; /* It isn't related.  */\n\n      sl_str = sub_top->str_idx;\n      bkref_str_off = bkref_str_idx;\n      /* At first, check the last node of sub expressions we already\n\t evaluated.  */\n      for (sub_last_idx = 0; sub_last_idx < sub_top->nlasts; ++sub_last_idx)\n\t{\n\t  regoff_t sl_str_diff;\n\t  sub_last = sub_top->lasts[sub_last_idx];\n\t  sl_str_diff = sub_last->str_idx - sl_str;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_diff > 0)\n\t    {\n\t      if (BE (bkref_str_off + sl_str_diff > mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* Not enough chars for a successful match.  */\n\t\t  if (bkref_str_off + sl_str_diff > mctx->input.len)\n\t\t    break;\n\n\t\t  err = clean_state_log_if_needed (mctx,\n\t\t\t\t\t\t   bkref_str_off\n\t\t\t\t\t\t   + sl_str_diff);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (memcmp (buf + bkref_str_off, buf + sl_str, sl_str_diff) != 0)\n\t\t/* We don't need to search this sub expression any more.  */\n\t\tbreak;\n\t    }\n\t  bkref_str_off += sl_str_diff;\n\t  sl_str += sl_str_diff;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\n\t  /* Reload buf, since the preceding call might have reallocated\n\t     the buffer.  */\n\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n\n      if (sub_last_idx < sub_top->nlasts)\n\tcontinue;\n      if (sub_last_idx > 0)\n\t++sl_str;\n      /* Then, search for the other last nodes of the sub expression.  */\n      for (; sl_str <= bkref_str_idx; ++sl_str)\n\t{\n\t  Idx cls_node;\n\t  regoff_t sl_str_off;\n\t  const re_node_set *nodes;\n\t  sl_str_off = sl_str - sub_top->str_idx;\n\t  /* The matched string by the sub expression match with the substring\n\t     at the back reference?  */\n\t  if (sl_str_off > 0)\n\t    {\n\t      if (BE (bkref_str_off >= mctx->input.valid_len, 0))\n\t\t{\n\t\t  /* If we are at the end of the input, we cannot match.  */\n\t\t  if (bkref_str_off >= mctx->input.len)\n\t\t    break;\n\n\t\t  err = extend_buffers (mctx, bkref_str_off + 1);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    return err;\n\n\t\t  buf = (const char *) re_string_get_buffer (&mctx->input);\n\t\t}\n\t      if (buf [bkref_str_off++] != buf[sl_str - 1])\n\t\tbreak; /* We don't need to search this sub expression\n\t\t\t  any more.  */\n\t    }\n\t  if (mctx->state_log[sl_str] == NULL)\n\t    continue;\n\t  /* Does this state have a ')' of the sub expression?  */\n\t  nodes = &mctx->state_log[sl_str]->nodes;\n\t  cls_node = find_subexp_node (dfa, nodes, subexp_num,\n\t\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (cls_node == REG_MISSING)\n\t    continue; /* No.  */\n\t  if (sub_top->path == NULL)\n\t    {\n\t      sub_top->path = calloc (sizeof (state_array_t),\n\t\t\t\t      sl_str - sub_top->str_idx + 1);\n\t      if (sub_top->path == NULL)\n\t\treturn REG_ESPACE;\n\t    }\n\t  /* Can the OP_OPEN_SUBEXP node arrive the OP_CLOSE_SUBEXP node\n\t     in the current context?  */\n\t  err = check_arrival (mctx, sub_top->path, sub_top->node,\n\t\t\t       sub_top->str_idx, cls_node, sl_str,\n\t\t\t       OP_CLOSE_SUBEXP);\n\t  if (err == REG_NOMATCH)\n\t      continue;\n\t  if (BE (err != REG_NOERROR, 0))\n\t      return err;\n\t  sub_last = match_ctx_add_sublast (sub_top, cls_node, sl_str);\n\t  if (BE (sub_last == NULL, 0))\n\t    return REG_ESPACE;\n\t  err = get_subexp_sub (mctx, sub_top, sub_last, bkref_node,\n\t\t\t\tbkref_str_idx);\n\t  if (err == REG_NOMATCH)\n\t    continue;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 142,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "get_subexp_sub": {
      "start_point": [
        2863,
        0
      ],
      "end_point": [
        2882,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\nget_subexp_sub (re_match_context_t *mctx, const re_sub_match_top_t *sub_top,\n\t\tre_sub_match_last_t *sub_last, Idx bkref_node, Idx bkref_str)\n{\n  reg_errcode_t err;\n  Idx to_idx;\n  /* Can the subexpression arrive the back reference?  */\n  err = check_arrival (mctx, &sub_last->path, sub_last->node,\n\t\t       sub_last->str_idx, bkref_node, bkref_str,\n\t\t       OP_OPEN_SUBEXP);\n  if (err != REG_NOERROR)\n    return err;\n  err = match_ctx_add_entry (mctx, bkref_node, bkref_str, sub_top->str_idx,\n\t\t\t     sub_last->str_idx);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  to_idx = bkref_str + sub_last->str_idx - sub_top->str_idx;\n  return clean_state_log_if_needed (mctx, to_idx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "find_subexp_node": {
      "start_point": [
        2892,
        0
      ],
      "end_point": [
        2907,
        1
      ],
      "content": "static Idx\ninternal_function\nfind_subexp_node (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t  Idx subexp_idx, int type)\n{\n  Idx cls_idx;\n  for (cls_idx = 0; cls_idx < nodes->nelem; ++cls_idx)\n    {\n      Idx cls_node = nodes->elems[cls_idx];\n      const re_token_t *node = dfa->nodes + cls_node;\n      if (node->type == type\n\t  && node->opr.idx == subexp_idx)\n\treturn cls_node;\n    }\n  return REG_MISSING;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival": {
      "start_point": [
        2915,
        18
      ],
      "end_point": [
        3069,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival (re_match_context_t *mctx, state_array_t *path, Idx top_node,\n\t       Idx top_str, Idx last_node, Idx last_str, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err = REG_NOERROR;\n  Idx subexp_num, backup_cur_idx, str_idx, null_cnt;\n  re_dfastate_t *cur_state = NULL;\n  re_node_set *cur_nodes, next_nodes;\n  re_dfastate_t **backup_state_log;\n  unsigned int context;\n\n  subexp_num = dfa->nodes[top_node].opr.idx;\n  /* Extend the buffer if we need.  */\n  if (BE (path->alloc < last_str + mctx->max_mb_elem_len + 1, 0))\n    {\n      re_dfastate_t **new_array;\n      Idx old_alloc = path->alloc;\n      Idx incr_alloc = last_str + mctx->max_mb_elem_len + 1;\n      Idx new_alloc;\n      if (BE (IDX_MAX - old_alloc < incr_alloc, 0))\n\treturn REG_ESPACE;\n      new_alloc = old_alloc + incr_alloc;\n      if (BE (SIZE_MAX / sizeof (re_dfastate_t *) < new_alloc, 0))\n\treturn REG_ESPACE;\n      new_array = re_realloc (path->array, re_dfastate_t *, new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      path->array = new_array;\n      path->alloc = new_alloc;\n      memset (new_array + old_alloc, '\\0',\n\t      sizeof (re_dfastate_t *) * (path->alloc - old_alloc));\n    }\n\n  str_idx = path->next_idx ? path->next_idx : top_str;\n\n  /* Temporary modify MCTX.  */\n  backup_state_log = mctx->state_log;\n  backup_cur_idx = mctx->input.cur_idx;\n  mctx->state_log = path->array;\n  mctx->input.cur_idx = str_idx;\n\n  /* Setup initial node set.  */\n  context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n  if (str_idx == top_str)\n    {\n      err = re_node_set_init_1 (&next_nodes, top_node);\n      if (BE (err != REG_NOERROR, 0))\n\treturn err;\n      err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n      if (BE (err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n    }\n  else\n    {\n      cur_state = mctx->state_log[str_idx];\n      if (cur_state && cur_state->has_backref)\n\t{\n\t  err = re_node_set_init_copy (&next_nodes, &cur_state->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      else\n\tre_node_set_init_empty (&next_nodes);\n    }\n  if (str_idx == top_str || (cur_state && cur_state->has_backref))\n    {\n      if (next_nodes.nelem)\n\t{\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n    }\n\n  for (null_cnt = 0; str_idx < last_str && null_cnt <= mctx->max_mb_elem_len;)\n    {\n      re_node_set_empty (&next_nodes);\n      if (mctx->state_log[str_idx + 1])\n\t{\n\t  err = re_node_set_merge (&next_nodes,\n\t\t\t\t   &mctx->state_log[str_idx + 1]->nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      if (cur_state)\n\t{\n\t  err = check_arrival_add_next_nodes (mctx, str_idx,\n\t\t\t\t\t      &cur_state->non_eps_nodes,\n\t\t\t\t\t      &next_nodes);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      ++str_idx;\n      if (next_nodes.nelem)\n\t{\n\t  err = check_arrival_expand_ecl (dfa, &next_nodes, subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t  err = expand_bkref_cache (mctx, &next_nodes, str_idx,\n\t\t\t\t    subexp_num, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&next_nodes);\n\t      return err;\n\t    }\n\t}\n      context = re_string_context_at (&mctx->input, str_idx - 1, mctx->eflags);\n      cur_state = re_acquire_state_context (&err, dfa, &next_nodes, context);\n      if (BE (cur_state == NULL && err != REG_NOERROR, 0))\n\t{\n\t  re_node_set_free (&next_nodes);\n\t  return err;\n\t}\n      mctx->state_log[str_idx] = cur_state;\n      null_cnt = cur_state == NULL ? null_cnt + 1 : 0;\n    }\n  re_node_set_free (&next_nodes);\n  cur_nodes = (mctx->state_log[last_str] == NULL ? NULL\n\t       : &mctx->state_log[last_str]->nodes);\n  path->next_idx = str_idx;\n\n  /* Fix MCTX.  */\n  mctx->state_log = backup_state_log;\n  mctx->input.cur_idx = backup_cur_idx;\n\n  /* Then check the current node set has the node LAST_NODE.  */\n  if (cur_nodes != NULL && re_node_set_contains (cur_nodes, last_node))\n    return REG_NOERROR;\n\n  return REG_NOMATCH;\n}",
      "lines": 155,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_add_next_nodes": {
      "start_point": [
        3080,
        18
      ],
      "end_point": [
        3152,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_add_next_nodes (re_match_context_t *mctx, Idx str_idx,\n\t\t\t      re_node_set *cur_nodes, re_node_set *next_nodes)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  bool ok;\n  Idx cur_idx;\n#ifdef RE_ENABLE_I18N\n  reg_errcode_t err = REG_NOERROR;\n#endif\n  re_node_set union_set;\n  re_node_set_init_empty (&union_set);\n  for (cur_idx = 0; cur_idx < cur_nodes->nelem; ++cur_idx)\n    {\n      int naccepted = 0;\n      Idx cur_node = cur_nodes->elems[cur_idx];\n#ifdef DEBUG\n      re_token_type_t type = dfa->nodes[cur_node].type;\n      assert (!IS_EPSILON_NODE (type));\n#endif\n#ifdef RE_ENABLE_I18N\n      /* If the node may accept \"multi byte\".  */\n      if (dfa->nodes[cur_node].accept_mb)\n\t{\n\t  naccepted = check_node_accept_bytes (dfa, cur_node, &mctx->input,\n\t\t\t\t\t       str_idx);\n\t  if (naccepted > 1)\n\t    {\n\t      re_dfastate_t *dest_state;\n\t      Idx next_node = dfa->nexts[cur_node];\n\t      Idx next_idx = str_idx + naccepted;\n\t      dest_state = mctx->state_log[next_idx];\n\t      re_node_set_empty (&union_set);\n\t      if (dest_state)\n\t\t{\n\t\t  err = re_node_set_merge (&union_set, &dest_state->nodes);\n\t\t  if (BE (err != REG_NOERROR, 0))\n\t\t    {\n\t\t      re_node_set_free (&union_set);\n\t\t      return err;\n\t\t    }\n\t\t}\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return REG_ESPACE;\n\t\t}\n\t      mctx->state_log[next_idx] = re_acquire_state (&err, dfa,\n\t\t\t\t\t\t\t    &union_set);\n\t      if (BE (mctx->state_log[next_idx] == NULL\n\t\t      && err != REG_NOERROR, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  return err;\n\t\t}\n\t    }\n\t}\n#endif /* RE_ENABLE_I18N */\n      if (naccepted\n\t  || check_node_accept (mctx, dfa->nodes + cur_node, str_idx))\n\t{\n\t  ok = re_node_set_insert (next_nodes, dfa->nexts[cur_node]);\n\t  if (BE (! ok, 0))\n\t    {\n\t      re_node_set_free (&union_set);\n\t      return REG_ESPACE;\n\t    }\n\t}\n    }\n  re_node_set_free (&union_set);\n  return REG_NOERROR;\n}",
      "lines": 73,
      "depth": 18,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "check_arrival_expand_ecl": {
      "start_point": [
        3160,
        0
      ],
      "end_point": [
        3207,
        1
      ],
      "content": "static reg_errcode_t\ninternal_function\ncheck_arrival_expand_ecl (const re_dfa_t *dfa, re_node_set *cur_nodes,\n\t\t\t  Idx ex_subexp, int type)\n{\n  reg_errcode_t err;\n  Idx idx, outside_node;\n  re_node_set new_nodes;\n#ifdef DEBUG\n  assert (cur_nodes->nelem);\n#endif\n  err = re_node_set_alloc (&new_nodes, cur_nodes->nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return err;\n  /* Create a new node set NEW_NODES with the nodes which are epsilon\n     closures of the node in CUR_NODES.  */\n\n  for (idx = 0; idx < cur_nodes->nelem; ++idx)\n    {\n      Idx cur_node = cur_nodes->elems[idx];\n      const re_node_set *eclosure = dfa->eclosures + cur_node;\n      outside_node = find_subexp_node (dfa, eclosure, ex_subexp, type);\n      if (outside_node == REG_MISSING)\n\t{\n\t  /* There are no problematic nodes, just merge them.  */\n\t  err = re_node_set_merge (&new_nodes, eclosure);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n      else\n\t{\n\t  /* There are problematic nodes, re-calculate incrementally.  */\n\t  err = check_arrival_expand_ecl_sub (dfa, &new_nodes, cur_node,\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    {\n\t      re_node_set_free (&new_nodes);\n\t      return err;\n\t    }\n\t}\n    }\n  re_node_set_free (cur_nodes);\n  *cur_nodes = new_nodes;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "internal_function",
        "internal_function"
      ]
    },
    "check_arrival_expand_ecl_sub": {
      "start_point": [
        3214,
        18
      ],
      "end_point": [
        3251,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncheck_arrival_expand_ecl_sub (const re_dfa_t *dfa, re_node_set *dst_nodes,\n\t\t\t      Idx target, Idx ex_subexp, int type)\n{\n  Idx cur_node;\n  for (cur_node = target; !re_node_set_contains (dst_nodes, cur_node);)\n    {\n      bool ok;\n\n      if (dfa->nodes[cur_node].type == type\n\t  && dfa->nodes[cur_node].opr.idx == ex_subexp)\n\t{\n\t  if (type == OP_CLOSE_SUBEXP)\n\t    {\n\t      ok = re_node_set_insert (dst_nodes, cur_node);\n\t      if (BE (! ok, 0))\n\t\treturn REG_ESPACE;\n\t    }\n\t  break;\n\t}\n      ok = re_node_set_insert (dst_nodes, cur_node);\n      if (BE (! ok, 0))\n\treturn REG_ESPACE;\n      if (dfa->edests[cur_node].nelem == 0)\n\tbreak;\n      if (dfa->edests[cur_node].nelem == 2)\n\t{\n\t  reg_errcode_t err;\n\t  err = check_arrival_expand_ecl_sub (dfa, dst_nodes,\n\t\t\t\t\t      dfa->edests[cur_node].elems[1],\n\t\t\t\t\t      ex_subexp, type);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    return err;\n\t}\n      cur_node = dfa->edests[cur_node].elems[0];\n    }\n  return REG_NOERROR;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "expand_bkref_cache": {
      "start_point": [
        3259,
        18
      ],
      "end_point": [
        3342,
        1
      ],
      "content": "__attribute_warn_unused_result__\nexpand_bkref_cache (re_match_context_t *mctx, re_node_set *cur_nodes,\n\t\t    Idx cur_str, Idx subexp_num, int type)\n{\n  const re_dfa_t *const dfa = mctx->dfa;\n  reg_errcode_t err;\n  Idx cache_idx_start = search_cur_bkref_entry (mctx, cur_str);\n  struct re_backref_cache_entry *ent;\n\n  if (cache_idx_start == REG_MISSING)\n    return REG_NOERROR;\n\n restart:\n  ent = mctx->bkref_ents + cache_idx_start;\n  do\n    {\n      Idx to_idx, next_node;\n\n      /* Is this entry ENT is appropriate?  */\n      if (!re_node_set_contains (cur_nodes, ent->node))\n\tcontinue; /* No.  */\n\n      to_idx = cur_str + ent->subexp_to - ent->subexp_from;\n      /* Calculate the destination of the back reference, and append it\n\t to MCTX->STATE_LOG.  */\n      if (to_idx == cur_str)\n\t{\n\t  /* The backreference did epsilon transit, we must re-check all the\n\t     node in the current state.  */\n\t  re_node_set new_dests;\n\t  reg_errcode_t err2, err3;\n\t  next_node = dfa->edests[ent->node].elems[0];\n\t  if (re_node_set_contains (cur_nodes, next_node))\n\t    continue;\n\t  err = re_node_set_init_1 (&new_dests, next_node);\n\t  err2 = check_arrival_expand_ecl (dfa, &new_dests, subexp_num, type);\n\t  err3 = re_node_set_merge (cur_nodes, &new_dests);\n\t  re_node_set_free (&new_dests);\n\t  if (BE (err != REG_NOERROR || err2 != REG_NOERROR\n\t\t  || err3 != REG_NOERROR, 0))\n\t    {\n\t      err = (err != REG_NOERROR ? err\n\t\t     : (err2 != REG_NOERROR ? err2 : err3));\n\t      return err;\n\t    }\n\t  /* TODO: It is still inefficient...  */\n\t  goto restart;\n\t}\n      else\n\t{\n\t  re_node_set union_set;\n\t  next_node = dfa->nexts[ent->node];\n\t  if (mctx->state_log[to_idx])\n\t    {\n\t      bool ok;\n\t      if (re_node_set_contains (&mctx->state_log[to_idx]->nodes,\n\t\t\t\t\tnext_node))\n\t\tcontinue;\n\t      err = re_node_set_init_copy (&union_set,\n\t\t\t\t\t   &mctx->state_log[to_idx]->nodes);\n\t      ok = re_node_set_insert (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR || ! ok, 0))\n\t\t{\n\t\t  re_node_set_free (&union_set);\n\t\t  err = err != REG_NOERROR ? err : REG_ESPACE;\n\t\t  return err;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      err = re_node_set_init_1 (&union_set, next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\treturn err;\n\t    }\n\t  mctx->state_log[to_idx] = re_acquire_state (&err, dfa, &union_set);\n\t  re_node_set_free (&union_set);\n\t  if (BE (mctx->state_log[to_idx] == NULL\n\t\t  && err != REG_NOERROR, 0))\n\t    return err;\n\t}\n    }\n  while (ent++->more);\n  return REG_NOERROR;\n}",
      "lines": 84,
      "depth": 17,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "build_trtable": {
      "start_point": [
        3347,
        0
      ],
      "end_point": [
        3578,
        1
      ],
      "content": "static bool\ninternal_function\nbuild_trtable (const re_dfa_t *dfa, re_dfastate_t *state)\n{\n  reg_errcode_t err;\n  Idx i, j;\n  int ch;\n  bool need_word_trtable = false;\n  bitset_word_t elem, mask;\n  bool dests_node_malloced = false;\n  bool dest_states_malloced = false;\n  Idx ndests; /* Number of the destination states from 'state'.  */\n  re_dfastate_t **trtable;\n  re_dfastate_t **dest_states = NULL, **dest_states_word, **dest_states_nl;\n  re_node_set follows, *dests_node;\n  bitset_t *dests_ch;\n  bitset_t acceptable;\n\n  struct dests_alloc\n  {\n    re_node_set dests_node[SBC_MAX];\n    bitset_t dests_ch[SBC_MAX];\n  } *dests_alloc;\n\n  /* We build DFA states which corresponds to the destination nodes\n     from 'state'.  'dests_node[i]' represents the nodes which i-th\n     destination state contains, and 'dests_ch[i]' represents the\n     characters which i-th destination state accepts.  */\n  if (__libc_use_alloca (sizeof (struct dests_alloc)))\n    dests_alloc = (struct dests_alloc *) alloca (sizeof (struct dests_alloc));\n  else\n    {\n      dests_alloc = re_malloc (struct dests_alloc, 1);\n      if (BE (dests_alloc == NULL, 0))\n\treturn false;\n      dests_node_malloced = true;\n    }\n  dests_node = dests_alloc->dests_node;\n  dests_ch = dests_alloc->dests_ch;\n\n  /* Initialize transition table.  */\n  state->word_trtable = state->trtable = NULL;\n\n  /* At first, group all nodes belonging to 'state' into several\n     destinations.  */\n  ndests = group_nodes_into_DFAstates (dfa, state, dests_node, dests_ch);\n  if (BE (! REG_VALID_NONZERO_INDEX (ndests), 0))\n    {\n      if (dests_node_malloced)\n\tfree (dests_alloc);\n      /* Return false in case of an error, true otherwise.  */\n      if (ndests == 0)\n\t{\n\t  state->trtable = (re_dfastate_t **)\n\t    calloc (sizeof (re_dfastate_t *), SBC_MAX);\n          if (BE (state->trtable == NULL, 0))\n            return false;\n\t  return true;\n\t}\n      return false;\n    }\n\n  err = re_node_set_alloc (&follows, ndests + 1);\n  if (BE (err != REG_NOERROR, 0))\n    goto out_free;\n\n  /* Avoid arithmetic overflow in size calculation.  */\n  if (BE ((((SIZE_MAX - (sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX)\n\t    / (3 * sizeof (re_dfastate_t *)))\n\t   < ndests),\n\t  0))\n    goto out_free;\n\n  if (__libc_use_alloca ((sizeof (re_node_set) + sizeof (bitset_t)) * SBC_MAX\n\t\t\t + ndests * 3 * sizeof (re_dfastate_t *)))\n    dest_states = (re_dfastate_t **)\n      alloca (ndests * 3 * sizeof (re_dfastate_t *));\n  else\n    {\n      dest_states = (re_dfastate_t **)\n\tmalloc (ndests * 3 * sizeof (re_dfastate_t *));\n      if (BE (dest_states == NULL, 0))\n\t{\nout_free:\n\t  if (dest_states_malloced)\n\t    free (dest_states);\n\t  re_node_set_free (&follows);\n\t  for (i = 0; i < ndests; ++i)\n\t    re_node_set_free (dests_node + i);\n\t  if (dests_node_malloced)\n\t    free (dests_alloc);\n\t  return false;\n\t}\n      dest_states_malloced = true;\n    }\n  dest_states_word = dest_states + ndests;\n  dest_states_nl = dest_states_word + ndests;\n  bitset_empty (acceptable);\n\n  /* Then build the states for all destinations.  */\n  for (i = 0; i < ndests; ++i)\n    {\n      Idx next_node;\n      re_node_set_empty (&follows);\n      /* Merge the follows of this destination states.  */\n      for (j = 0; j < dests_node[i].nelem; ++j)\n\t{\n\t  next_node = dfa->nexts[dests_node[i].elems[j]];\n\t  if (next_node != REG_MISSING)\n\t    {\n\t      err = re_node_set_merge (&follows, dfa->eclosures + next_node);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto out_free;\n\t    }\n\t}\n      dest_states[i] = re_acquire_state_context (&err, dfa, &follows, 0);\n      if (BE (dest_states[i] == NULL && err != REG_NOERROR, 0))\n\tgoto out_free;\n      /* If the new state has context constraint,\n\t build appropriate states for these contexts.  */\n      if (dest_states[i]->has_constraint)\n\t{\n\t  dest_states_word[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\t  CONTEXT_WORD);\n\t  if (BE (dest_states_word[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\n\t  if (dest_states[i] != dest_states_word[i] && dfa->mb_cur_max > 1)\n\t    need_word_trtable = true;\n\n\t  dest_states_nl[i] = re_acquire_state_context (&err, dfa, &follows,\n\t\t\t\t\t\t\tCONTEXT_NEWLINE);\n\t  if (BE (dest_states_nl[i] == NULL && err != REG_NOERROR, 0))\n\t    goto out_free;\n\t}\n      else\n\t{\n\t  dest_states_word[i] = dest_states[i];\n\t  dest_states_nl[i] = dest_states[i];\n\t}\n      bitset_merge (acceptable, dests_ch[i]);\n    }\n\n  if (!BE (need_word_trtable, 0))\n    {\n      /* We don't care about whether the following character is a word\n\t character, or we are in a single-byte character set so we can\n\t discern by looking at the character code: allocate a\n\t 256-entry transition table.  */\n      trtable = state->trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      if (dfa->word_char[i] & mask)\n\t\ttrtable[ch] = dest_states_word[j];\n\t      else\n\t\ttrtable[ch] = dest_states[j];\n\t    }\n    }\n  else\n    {\n      /* We care about whether the following character is a word\n\t character, and we are in a multi-byte character set: discern\n\t by looking at the character code: build two 256-entry\n\t transition tables, one starting at trtable[0] and one\n\t starting at trtable[SBC_MAX].  */\n      trtable = state->word_trtable =\n\t(re_dfastate_t **) calloc (sizeof (re_dfastate_t *), 2 * SBC_MAX);\n      if (BE (trtable == NULL, 0))\n\tgoto out_free;\n\n      /* For all characters ch...:  */\n      for (i = 0; i < BITSET_WORDS; ++i)\n\tfor (ch = i * BITSET_WORD_BITS, elem = acceptable[i], mask = 1;\n\t     elem;\n\t     mask <<= 1, elem >>= 1, ++ch)\n\t  if (BE (elem & 1, 0))\n\t    {\n\t      /* There must be exactly one destination which accepts\n\t\t character ch.  See group_nodes_into_DFAstates.  */\n\t      for (j = 0; (dests_ch[j][i] & mask) == 0; ++j)\n\t\t;\n\n\t      /* j-th destination accepts the word character ch.  */\n\t      trtable[ch] = dest_states[j];\n\t      trtable[ch + SBC_MAX] = dest_states_word[j];\n\t    }\n    }\n\n  /* new line */\n  if (bitset_contain (acceptable, NEWLINE_CHAR))\n    {\n      /* The current state accepts newline character.  */\n      for (j = 0; j < ndests; ++j)\n\tif (bitset_contain (dests_ch[j], NEWLINE_CHAR))\n\t  {\n\t    /* k-th destination accepts newline character.  */\n\t    trtable[NEWLINE_CHAR] = dest_states_nl[j];\n\t    if (need_word_trtable)\n\t      trtable[NEWLINE_CHAR + SBC_MAX] = dest_states_nl[j];\n\t    /* There must be only one destination which accepts\n\t       newline.  See group_nodes_into_DFAstates.  */\n\t    break;\n\t  }\n    }\n\n  if (dest_states_malloced)\n    free (dest_states);\n\n  re_node_set_free (&follows);\n  for (i = 0; i < ndests; ++i)\n    re_node_set_free (dests_node + i);\n\n  if (dests_node_malloced)\n    free (dests_alloc);\n\n  return true;\n}",
      "lines": 232,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "group_nodes_into_DFAstates": {
      "start_point": [
        3585,
        0
      ],
      "end_point": [
        3767,
        1
      ],
      "content": "static Idx\ninternal_function\ngroup_nodes_into_DFAstates (const re_dfa_t *dfa, const re_dfastate_t *state,\n\t\t\t    re_node_set *dests_node, bitset_t *dests_ch)\n{\n  reg_errcode_t err;\n  bool ok;\n  Idx i, j, k;\n  Idx ndests; /* Number of the destinations from 'state'.  */\n  bitset_t accepts; /* Characters a node can accept.  */\n  const re_node_set *cur_nodes = &state->nodes;\n  bitset_empty (accepts);\n  ndests = 0;\n\n  /* For all the nodes belonging to 'state',  */\n  for (i = 0; i < cur_nodes->nelem; ++i)\n    {\n      re_token_t *node = &dfa->nodes[cur_nodes->elems[i]];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      /* Enumerate all single byte character this node can accept.  */\n      if (type == CHARACTER)\n\tbitset_set (accepts, node->opr.c);\n      else if (type == SIMPLE_BRACKET)\n\t{\n\t  bitset_merge (accepts, node->opr.sbcset);\n\t}\n      else if (type == OP_PERIOD)\n\t{\n#ifdef RE_ENABLE_I18N\n\t  if (dfa->mb_cur_max > 1)\n\t    bitset_merge (accepts, dfa->sb_char);\n\t  else\n#endif\n\t    bitset_set_all (accepts);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#ifdef RE_ENABLE_I18N\n      else if (type == OP_UTF8_PERIOD)\n\t{\n\t  if (ASCII_CHARS % BITSET_WORD_BITS == 0)\n\t    memset (accepts, -1, ASCII_CHARS / CHAR_BIT);\n\t  else\n\t    bitset_merge (accepts, utf8_sb_map);\n\t  if (!(dfa->syntax & RE_DOT_NEWLINE))\n\t    bitset_clear (accepts, '\\n');\n\t  if (dfa->syntax & RE_DOT_NOT_NULL)\n\t    bitset_clear (accepts, '\\0');\n\t}\n#endif\n      else\n\tcontinue;\n\n      /* Check the 'accepts' and sift the characters which are not\n\t match it the context.  */\n      if (constraint)\n\t{\n\t  if (constraint & NEXT_NEWLINE_CONSTRAINT)\n\t    {\n\t      bool accepts_newline = bitset_contain (accepts, NEWLINE_CHAR);\n\t      bitset_empty (accepts);\n\t      if (accepts_newline)\n\t\tbitset_set (accepts, NEWLINE_CHAR);\n\t      else\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_ENDBUF_CONSTRAINT)\n\t    {\n\t      bitset_empty (accepts);\n\t      continue;\n\t    }\n\n\t  if (constraint & NEXT_WORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && !node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= (dfa->word_char[j] | ~dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t  if (constraint & NEXT_NOTWORD_CONSTRAINT)\n\t    {\n\t      bitset_word_t any_set = 0;\n\t      if (type == CHARACTER && node->word_char)\n\t\t{\n\t\t  bitset_empty (accepts);\n\t\t  continue;\n\t\t}\n#ifdef RE_ENABLE_I18N\n\t      if (dfa->mb_cur_max > 1)\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~(dfa->word_char[j] & dfa->sb_char[j]));\n\t      else\n#endif\n\t\tfor (j = 0; j < BITSET_WORDS; ++j)\n\t\t  any_set |= (accepts[j] &= ~dfa->word_char[j]);\n\t      if (!any_set)\n\t\tcontinue;\n\t    }\n\t}\n\n      /* Then divide 'accepts' into DFA states, or create a new\n\t state.  Above, we make sure that accepts is not empty.  */\n      for (j = 0; j < ndests; ++j)\n\t{\n\t  bitset_t intersec; /* Intersection sets, see below.  */\n\t  bitset_t remains;\n\t  /* Flags, see below.  */\n\t  bitset_word_t has_intersec, not_subset, not_consumed;\n\n\t  /* Optimization, skip if this state doesn't accept the character.  */\n\t  if (type == CHARACTER && !bitset_contain (dests_ch[j], node->opr.c))\n\t    continue;\n\n\t  /* Enumerate the intersection set of this state and 'accepts'.  */\n\t  has_intersec = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    has_intersec |= intersec[k] = accepts[k] & dests_ch[j][k];\n\t  /* And skip if the intersection set is empty.  */\n\t  if (!has_intersec)\n\t    continue;\n\n\t  /* Then check if this state is a subset of 'accepts'.  */\n\t  not_subset = not_consumed = 0;\n\t  for (k = 0; k < BITSET_WORDS; ++k)\n\t    {\n\t      not_subset |= remains[k] = ~accepts[k] & dests_ch[j][k];\n\t      not_consumed |= accepts[k] = accepts[k] & ~dests_ch[j][k];\n\t    }\n\n\t  /* If this state isn't a subset of 'accepts', create a\n\t     new group state, which has the 'remains'. */\n\t  if (not_subset)\n\t    {\n\t      bitset_copy (dests_ch[ndests], remains);\n\t      bitset_copy (dests_ch[j], intersec);\n\t      err = re_node_set_init_copy (dests_node + ndests, &dests_node[j]);\n\t      if (BE (err != REG_NOERROR, 0))\n\t\tgoto error_return;\n\t      ++ndests;\n\t    }\n\n\t  /* Put the position in the current group. */\n\t  ok = re_node_set_insert (&dests_node[j], cur_nodes->elems[i]);\n\t  if (BE (! ok, 0))\n\t    goto error_return;\n\n\t  /* If all characters are consumed, go to next node. */\n\t  if (!not_consumed)\n\t    break;\n\t}\n      /* Some characters remain, create a new group. */\n      if (j == ndests)\n\t{\n\t  bitset_copy (dests_ch[ndests], accepts);\n\t  err = re_node_set_init_1 (dests_node + ndests, cur_nodes->elems[i]);\n\t  if (BE (err != REG_NOERROR, 0))\n\t    goto error_return;\n\t  ++ndests;\n\t  bitset_empty (accepts);\n\t}\n    }\n  return ndests;\n error_return:\n  for (j = 0; j < ndests; ++j)\n    re_node_set_free (dests_node + j);\n  return REG_MISSING;\n}",
      "lines": 183,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept_bytes": {
      "start_point": [
        3778,
        0
      ],
      "end_point": [
        4007,
        1
      ],
      "content": "static int\ninternal_function\ncheck_node_accept_bytes (const re_dfa_t *dfa, Idx node_idx,\n\t\t\t const re_string_t *input, Idx str_idx)\n{\n  const re_token_t *node = dfa->nodes + node_idx;\n  int char_len, elem_len;\n  Idx i;\n\n  if (BE (node->type == OP_UTF8_PERIOD, 0))\n    {\n      unsigned char c = re_string_byte_at (input, str_idx), d;\n      if (BE (c < 0xc2, 1))\n\treturn 0;\n\n      if (str_idx + 2 > input->len)\n\treturn 0;\n\n      d = re_string_byte_at (input, str_idx + 1);\n      if (c < 0xe0)\n\treturn (d < 0x80 || d > 0xbf) ? 0 : 2;\n      else if (c < 0xf0)\n\t{\n\t  char_len = 3;\n\t  if (c == 0xe0 && d < 0xa0)\n\t    return 0;\n\t}\n      else if (c < 0xf8)\n\t{\n\t  char_len = 4;\n\t  if (c == 0xf0 && d < 0x90)\n\t    return 0;\n\t}\n      else if (c < 0xfc)\n\t{\n\t  char_len = 5;\n\t  if (c == 0xf8 && d < 0x88)\n\t    return 0;\n\t}\n      else if (c < 0xfe)\n\t{\n\t  char_len = 6;\n\t  if (c == 0xfc && d < 0x84)\n\t    return 0;\n\t}\n      else\n\treturn 0;\n\n      if (str_idx + char_len > input->len)\n\treturn 0;\n\n      for (i = 1; i < char_len; ++i)\n\t{\n\t  d = re_string_byte_at (input, str_idx + i);\n\t  if (d < 0x80 || d > 0xbf)\n\t    return 0;\n\t}\n      return char_len;\n    }\n\n  char_len = re_string_char_size_at (input, str_idx);\n  if (node->type == OP_PERIOD)\n    {\n      if (char_len <= 1)\n\treturn 0;\n      /* FIXME: I don't think this if is needed, as both '\\n'\n\t and '\\0' are char_len == 1.  */\n      /* '.' accepts any one character except the following two cases.  */\n      if ((!(dfa->syntax & RE_DOT_NEWLINE) &&\n\t   re_string_byte_at (input, str_idx) == '\\n') ||\n\t  ((dfa->syntax & RE_DOT_NOT_NULL) &&\n\t   re_string_byte_at (input, str_idx) == '\\0'))\n\treturn 0;\n      return char_len;\n    }\n\n  elem_len = re_string_elem_size_at (input, str_idx);\n  if ((elem_len <= 1 && char_len <= 1) || char_len == 0)\n    return 0;\n\n  if (node->type == COMPLEX_BRACKET)\n    {\n      const re_charset_t *cset = node->opr.mbcset;\n# ifdef _LIBC\n      const unsigned char *pin\n\t= ((const unsigned char *) re_string_get_buffer (input) + str_idx);\n      Idx j;\n      uint32_t nrules;\n# endif /* _LIBC */\n      int match_len = 0;\n      wchar_t wc = ((cset->nranges || cset->nchar_classes || cset->nmbchars)\n\t\t    ? re_string_wchar_at (input, str_idx) : 0);\n\n      /* match with multibyte character?  */\n      for (i = 0; i < cset->nmbchars; ++i)\n\tif (wc == cset->mbchars[i])\n\t  {\n\t    match_len = char_len;\n\t    goto check_node_accept_bytes_match;\n\t  }\n      /* match with character_class?  */\n      for (i = 0; i < cset->nchar_classes; ++i)\n\t{\n\t  wctype_t wt = cset->char_classes[i];\n\t  if (__iswctype (wc, wt))\n\t    {\n\t      match_len = char_len;\n\t      goto check_node_accept_bytes_match;\n\t    }\n\t}\n\n# ifdef _LIBC\n      nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n      if (nrules != 0)\n\t{\n\t  unsigned int in_collseq = 0;\n\t  const int32_t *table, *indirect;\n\t  const unsigned char *weights, *extra;\n\t  const char *collseqwc;\n\t  /* This #include defines a local function!  */\n#  include <locale/weight.h>\n\n\t  /* match with collating_symbol?  */\n\t  if (cset->ncoll_syms)\n\t    extra = (const unsigned char *)\n\t      _NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n\t  for (i = 0; i < cset->ncoll_syms; ++i)\n\t    {\n\t      const unsigned char *coll_sym = extra + cset->coll_syms[i];\n\t      /* Compare the length of input collating element and\n\t\t the length of current collating element.  */\n\t      if (*coll_sym != elem_len)\n\t\tcontinue;\n\t      /* Compare each bytes.  */\n\t      for (j = 0; j < *coll_sym; j++)\n\t\tif (pin[j] != coll_sym[1 + j])\n\t\t  break;\n\t      if (j == *coll_sym)\n\t\t{\n\t\t  /* Match if every bytes is equal.  */\n\t\t  match_len = j;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\n\t  if (cset->nranges)\n\t    {\n\t      if (elem_len <= char_len)\n\t\t{\n\t\t  collseqwc = _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQWC);\n\t\t  in_collseq = __collseq_table_lookup (collseqwc, wc);\n\t\t}\n\t      else\n\t\tin_collseq = find_collation_sequence_value (pin, elem_len);\n\t    }\n\t  /* match with range expression?  */\n\t  /* FIXME: Implement rational ranges here, too.  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    if (cset->range_starts[i] <= in_collseq\n\t\t&& in_collseq <= cset->range_ends[i])\n\t      {\n\t\tmatch_len = elem_len;\n\t\tgoto check_node_accept_bytes_match;\n\t      }\n\n\t  /* match with equivalence_class?  */\n\t  if (cset->nequiv_classes)\n\t    {\n\t      const unsigned char *cp = pin;\n\t      table = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n\t      weights = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_WEIGHTMB);\n\t      extra = (const unsigned char *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n\t      indirect = (const int32_t *)\n\t\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_INDIRECTMB);\n\t      int32_t idx = findidx (&cp, elem_len);\n\t      if (idx > 0)\n\t\tfor (i = 0; i < cset->nequiv_classes; ++i)\n\t\t  {\n\t\t    int32_t equiv_class_idx = cset->equiv_classes[i];\n\t\t    size_t weight_len = weights[idx & 0xffffff];\n\t\t    if (weight_len == weights[equiv_class_idx & 0xffffff]\n\t\t\t&& (idx >> 24) == (equiv_class_idx >> 24))\n\t\t      {\n\t\t\tIdx cnt = 0;\n\n\t\t\tidx &= 0xffffff;\n\t\t\tequiv_class_idx &= 0xffffff;\n\n\t\t\twhile (cnt <= weight_len\n\t\t\t       && (weights[equiv_class_idx + 1 + cnt]\n\t\t\t\t   == weights[idx + 1 + cnt]))\n\t\t\t  ++cnt;\n\t\t\tif (cnt > weight_len)\n\t\t\t  {\n\t\t\t    match_len = elem_len;\n\t\t\t    goto check_node_accept_bytes_match;\n\t\t\t  }\n\t\t      }\n\t\t  }\n\t    }\n\t}\n      else\n# endif /* _LIBC */\n\t{\n\t  /* match with range expression?  */\n\t  for (i = 0; i < cset->nranges; ++i)\n\t    {\n\t      if (cset->range_starts[i] <= wc && wc <= cset->range_ends[i])\n\t\t{\n\t\t  match_len = char_len;\n\t\t  goto check_node_accept_bytes_match;\n\t\t}\n\t    }\n\t}\n    check_node_accept_bytes_match:\n      if (!cset->non_match)\n\treturn match_len;\n      else\n\t{\n\t  if (match_len > 0)\n\t    return 0;\n\t  else\n\t    return (elem_len > char_len) ? elem_len : char_len;\n\t}\n    }\n  return 0;\n}",
      "lines": 230,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "find_collation_sequence_value": {
      "start_point": [
        4010,
        0
      ],
      "end_point": [
        4067,
        1
      ],
      "content": "static unsigned int\ninternal_function\nfind_collation_sequence_value (const unsigned char *mbs, size_t mbs_len)\n{\n  uint32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n  if (nrules == 0)\n    {\n      if (mbs_len == 1)\n\t{\n\t  /* No valid character.  Match it as a single byte character.  */\n\t  const unsigned char *collseq = (const unsigned char *)\n\t    _NL_CURRENT (LC_COLLATE, _NL_COLLATE_COLLSEQMB);\n\t  return collseq[mbs[0]];\n\t}\n      return UINT_MAX;\n    }\n  else\n    {\n      int32_t idx;\n      const unsigned char *extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB);\n      int32_t extrasize = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_SYMB_EXTRAMB + 1) - extra;\n\n      for (idx = 0; idx < extrasize;)\n\t{\n\t  int mbs_cnt;\n\t  bool found = false;\n\t  int32_t elem_mbs_len;\n\t  /* Skip the name of collating element name.  */\n\t  idx = idx + extra[idx] + 1;\n\t  elem_mbs_len = extra[idx++];\n\t  if (mbs_len == elem_mbs_len)\n\t    {\n\t      for (mbs_cnt = 0; mbs_cnt < elem_mbs_len; ++mbs_cnt)\n\t\tif (extra[idx + mbs_cnt] != mbs[mbs_cnt])\n\t\t  break;\n\t      if (mbs_cnt == elem_mbs_len)\n\t\t/* Found the entry.  */\n\t\tfound = true;\n\t    }\n\t  /* Skip the byte sequence of the collating element.  */\n\t  idx += elem_mbs_len;\n\t  /* Adjust for the alignment.  */\n\t  idx = (idx + 3) & ~3;\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t  /* Skip the wide char sequence of the collating element.  */\n\t  idx = idx + sizeof (uint32_t) * (*(int32_t *) (extra + idx) + 1);\n\t  /* If we found the entry, return the sequence value.  */\n\t  if (found)\n\t    return *(uint32_t *) (extra + idx);\n\t  /* Skip the collation sequence value.  */\n\t  idx += sizeof (uint32_t);\n\t}\n      return UINT_MAX;\n    }\n}",
      "lines": 58,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "check_node_accept": {
      "start_point": [
        4074,
        0
      ],
      "end_point": [
        4120,
        1
      ],
      "content": "static bool\ninternal_function\ncheck_node_accept (const re_match_context_t *mctx, const re_token_t *node,\n\t\t   Idx idx)\n{\n  unsigned char ch;\n  ch = re_string_byte_at (&mctx->input, idx);\n  switch (node->type)\n    {\n    case CHARACTER:\n      if (node->opr.c != ch)\n        return false;\n      break;\n\n    case SIMPLE_BRACKET:\n      if (!bitset_contain (node->opr.sbcset, ch))\n        return false;\n      break;\n\n#ifdef RE_ENABLE_I18N\n    case OP_UTF8_PERIOD:\n      if (ch >= ASCII_CHARS)\n        return false;\n      /* FALLTHROUGH */\n#endif\n    case OP_PERIOD:\n      if ((ch == '\\n' && !(mctx->dfa->syntax & RE_DOT_NEWLINE))\n\t  || (ch == '\\0' && (mctx->dfa->syntax & RE_DOT_NOT_NULL)))\n\treturn false;\n      break;\n\n    default:\n      return false;\n    }\n\n  if (node->constraint)\n    {\n      /* The node has constraints.  Check whether the current context\n\t satisfies the constraints.  */\n      unsigned int context = re_string_context_at (&mctx->input, idx,\n\t\t\t\t\t\t   mctx->eflags);\n      if (NOT_SATISFY_NEXT_CONSTRAINT (node->constraint, context))\n\treturn false;\n    }\n\n  return true;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool",
        "internal_function",
        "internal_function"
      ]
    },
    "extend_buffers": {
      "start_point": [
        4125,
        18
      ],
      "end_point": [
        4183,
        1
      ],
      "content": "__attribute_warn_unused_result__\nextend_buffers (re_match_context_t *mctx, int min_len)\n{\n  reg_errcode_t ret;\n  re_string_t *pstr = &mctx->input;\n\n  /* Avoid overflow.  */\n  if (BE (MIN (IDX_MAX, SIZE_MAX / sizeof (re_dfastate_t *)) / 2\n          <= pstr->bufs_len, 0))\n    return REG_ESPACE;\n\n  /* Double the lengths of the buffers, but allocate at least MIN_LEN.  */\n  ret = re_string_realloc_buffers (pstr,\n\t\t\t\t   MAX (min_len,\n\t\t\t\t\tMIN (pstr->len, pstr->bufs_len * 2)));\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  if (mctx->state_log != NULL)\n    {\n      /* And double the length of state_log.  */\n      /* XXX We have no indication of the size of this buffer.  If this\n\t allocation fail we have no indication that the state_log array\n\t does not have the right size.  */\n      re_dfastate_t **new_array = re_realloc (mctx->state_log, re_dfastate_t *,\n\t\t\t\t\t      pstr->bufs_len + 1);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->state_log = new_array;\n    }\n\n  /* Then reconstruct the buffers.  */\n  if (pstr->icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\t{\n\t  ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (pstr->trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_init": {
      "start_point": [
        4191,
        18
      ],
      "end_point": [
        4219,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_init (re_match_context_t *mctx, int eflags, Idx n)\n{\n  mctx->eflags = eflags;\n  mctx->match_last = REG_MISSING;\n  if (n > 0)\n    {\n      /* Avoid overflow.  */\n      size_t max_object_size =\n\tMAX (sizeof (struct re_backref_cache_entry),\n\t     sizeof (re_sub_match_top_t *));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < n, 0))\n\treturn REG_ESPACE;\n\n      mctx->bkref_ents = re_malloc (struct re_backref_cache_entry, n);\n      mctx->sub_tops = re_malloc (re_sub_match_top_t *, n);\n      if (BE (mctx->bkref_ents == NULL || mctx->sub_tops == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  /* Already zero-ed by the caller.\n     else\n       mctx->bkref_ents = NULL;\n     mctx->nbkref_ents = 0;\n     mctx->nsub_tops = 0;  */\n  mctx->abkref_ents = n;\n  mctx->max_mb_elem_len = 1;\n  mctx->asub_tops = n;\n  return REG_NOERROR;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_clean": {
      "start_point": [
        4225,
        0
      ],
      "end_point": [
        4251,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_clean (re_match_context_t *mctx)\n{\n  Idx st_idx;\n  for (st_idx = 0; st_idx < mctx->nsub_tops; ++st_idx)\n    {\n      Idx sl_idx;\n      re_sub_match_top_t *top = mctx->sub_tops[st_idx];\n      for (sl_idx = 0; sl_idx < top->nlasts; ++sl_idx)\n\t{\n\t  re_sub_match_last_t *last = top->lasts[sl_idx];\n\t  re_free (last->path.array);\n\t  re_free (last);\n\t}\n      re_free (top->lasts);\n      if (top->path)\n\t{\n\t  re_free (top->path->array);\n\t  re_free (top->path);\n\t}\n      free (top);\n    }\n\n  mctx->nsub_tops = 0;\n  mctx->nbkref_ents = 0;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_free": {
      "start_point": [
        4255,
        0
      ],
      "end_point": [
        4263,
        1
      ],
      "content": "static void\ninternal_function\nmatch_ctx_free (re_match_context_t *mctx)\n{\n  /* First, free all the memory associated with MCTX->SUB_TOPS.  */\n  match_ctx_clean (mctx);\n  re_free (mctx->sub_tops);\n  re_free (mctx->bkref_ents);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_entry": {
      "start_point": [
        4271,
        18
      ],
      "end_point": [
        4314,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_entry (re_match_context_t *mctx, Idx node, Idx str_idx, Idx from,\n\t\t     Idx to)\n{\n  if (mctx->nbkref_ents >= mctx->abkref_ents)\n    {\n      struct re_backref_cache_entry* new_entry;\n      new_entry = re_realloc (mctx->bkref_ents, struct re_backref_cache_entry,\n\t\t\t      mctx->abkref_ents * 2);\n      if (BE (new_entry == NULL, 0))\n\t{\n\t  re_free (mctx->bkref_ents);\n\t  return REG_ESPACE;\n\t}\n      mctx->bkref_ents = new_entry;\n      memset (mctx->bkref_ents + mctx->nbkref_ents, '\\0',\n\t      sizeof (struct re_backref_cache_entry) * mctx->abkref_ents);\n      mctx->abkref_ents *= 2;\n    }\n  if (mctx->nbkref_ents > 0\n      && mctx->bkref_ents[mctx->nbkref_ents - 1].str_idx == str_idx)\n    mctx->bkref_ents[mctx->nbkref_ents - 1].more = 1;\n\n  mctx->bkref_ents[mctx->nbkref_ents].node = node;\n  mctx->bkref_ents[mctx->nbkref_ents].str_idx = str_idx;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_from = from;\n  mctx->bkref_ents[mctx->nbkref_ents].subexp_to = to;\n\n  /* This is a cache that saves negative results of check_dst_limits_calc_pos.\n     If bit N is clear, means that this entry won't epsilon-transition to\n     an OP_OPEN_SUBEXP or OP_CLOSE_SUBEXP for the N+1-th subexpression.  If\n     it is set, check_dst_limits_calc_pos_1 will recurse and try to find one\n     such node.\n\n     A backreference does not epsilon-transition unless it is empty, so set\n     to all zeros if FROM != TO.  */\n  mctx->bkref_ents[mctx->nbkref_ents].eps_reachable_subexps_map\n    = (from == to ? -1 : 0);\n\n  mctx->bkref_ents[mctx->nbkref_ents++].more = 0;\n  if (mctx->max_mb_elem_len < to - from)\n    mctx->max_mb_elem_len = to - from;\n  return REG_NOERROR;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "search_cur_bkref_entry": {
      "start_point": [
        4319,
        0
      ],
      "end_point": [
        4337,
        1
      ],
      "content": "static Idx\ninternal_function\nsearch_cur_bkref_entry (const re_match_context_t *mctx, Idx str_idx)\n{\n  Idx left, right, mid, last;\n  last = right = mctx->nbkref_ents;\n  for (left = 0; left < right;)\n    {\n      mid = (left + right) / 2;\n      if (mctx->bkref_ents[mid].str_idx < str_idx)\n\tleft = mid + 1;\n      else\n\tright = mid;\n    }\n  if (left < last && mctx->bkref_ents[left].str_idx == str_idx)\n    return left;\n  else\n    return REG_MISSING;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "match_ctx_add_subtop": {
      "start_point": [
        4343,
        18
      ],
      "end_point": [
        4367,
        1
      ],
      "content": "__attribute_warn_unused_result__\nmatch_ctx_add_subtop (re_match_context_t *mctx, Idx node, Idx str_idx)\n{\n#ifdef DEBUG\n  assert (mctx->sub_tops != NULL);\n  assert (mctx->asub_tops > 0);\n#endif\n  if (BE (mctx->nsub_tops == mctx->asub_tops, 0))\n    {\n      Idx new_asub_tops = mctx->asub_tops * 2;\n      re_sub_match_top_t **new_array = re_realloc (mctx->sub_tops,\n\t\t\t\t\t\t   re_sub_match_top_t *,\n\t\t\t\t\t\t   new_asub_tops);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      mctx->sub_tops = new_array;\n      mctx->asub_tops = new_asub_tops;\n    }\n  mctx->sub_tops[mctx->nsub_tops] = calloc (1, sizeof (re_sub_match_top_t));\n  if (BE (mctx->sub_tops[mctx->nsub_tops] == NULL, 0))\n    return REG_ESPACE;\n  mctx->sub_tops[mctx->nsub_tops]->node = node;\n  mctx->sub_tops[mctx->nsub_tops++]->str_idx = str_idx;\n  return REG_NOERROR;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "match_ctx_add_sublast": {
      "start_point": [
        4372,
        0
      ],
      "end_point": [
        4397,
        1
      ],
      "content": "static re_sub_match_last_t *\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)\n{\n  re_sub_match_last_t *new_entry;\n  if (BE (subtop->nlasts == subtop->alasts, 0))\n    {\n      Idx new_alasts = 2 * subtop->alasts + 1;\n      re_sub_match_last_t **new_array = re_realloc (subtop->lasts,\n\t\t\t\t\t\t    re_sub_match_last_t *,\n\t\t\t\t\t\t    new_alasts);\n      if (BE (new_array == NULL, 0))\n\treturn NULL;\n      subtop->lasts = new_array;\n      subtop->alasts = new_alasts;\n    }\n  new_entry = calloc (1, sizeof (re_sub_match_last_t));\n  if (BE (new_entry != NULL, 1))\n    {\n      subtop->lasts[subtop->nlasts] = new_entry;\n      new_entry->node = node;\n      new_entry->str_idx = str_idx;\n      ++subtop->nlasts;\n    }\n  return new_entry;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "re_sub_match_last_t",
        "*\ninternal_function\nmatch_ctx_add_sublast (re_sub_match_top_t *subtop, Idx node, Idx str_idx)",
        "*",
        "internal_function",
        "internal_function"
      ]
    },
    "sift_ctx_init": {
      "start_point": [
        4399,
        0
      ],
      "end_point": [
        4409,
        1
      ],
      "content": "static void\ninternal_function\nsift_ctx_init (re_sift_context_t *sctx, re_dfastate_t **sifted_sts,\n\t       re_dfastate_t **limited_sts, Idx last_node, Idx last_str_idx)\n{\n  sctx->sifted_states = sifted_sts;\n  sctx->limited_states = limited_sts;\n  sctx->last_node = last_node;\n  sctx->last_str_idx = last_str_idx;\n  re_node_set_init_empty (&sctx->limits);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "recutils/recutils-1.7/lib/regex_internal.c": {
    "re_string_allocate": {
      "start_point": [
        37,
        18
      ],
      "end_point": [
        60,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_allocate (re_string_t *pstr, const char *str, Idx len, Idx init_len,\n\t\t    RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  Idx init_buf_len;\n\n  /* Ensure at least one character fits into the buffers.  */\n  if (init_len < dfa->mb_cur_max)\n    init_len = dfa->mb_cur_max;\n  init_buf_len = (len + 1 < init_len) ? len + 1: init_len;\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  ret = re_string_realloc_buffers (pstr, init_buf_len);\n  if (BE (ret != REG_NOERROR, 0))\n    return ret;\n\n  pstr->word_char = dfa->word_char;\n  pstr->word_ops_used = dfa->word_ops_used;\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n  pstr->valid_len = (pstr->mbs_allocated || dfa->mb_cur_max > 1) ? 0 : len;\n  pstr->valid_raw_len = pstr->valid_len;\n  return REG_NOERROR;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct": {
      "start_point": [
        65,
        18
      ],
      "end_point": [
        123,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_construct (re_string_t *pstr, const char *str, Idx len,\n\t\t     RE_TRANSLATE_TYPE trans, bool icase, const re_dfa_t *dfa)\n{\n  reg_errcode_t ret;\n  memset (pstr, '\\0', sizeof (re_string_t));\n  re_string_construct_common (str, len, pstr, trans, icase, dfa);\n\n  if (len > 0)\n    {\n      ret = re_string_realloc_buffers (pstr, len + 1);\n      if (BE (ret != REG_NOERROR, 0))\n\treturn ret;\n    }\n  pstr->mbs = pstr->mbs_allocated ? pstr->mbs : (unsigned char *) str;\n\n  if (icase)\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\t{\n\t  while (1)\n\t    {\n\t      ret = build_wcs_upper_buffer (pstr);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t      if (pstr->valid_raw_len >= len)\n\t\tbreak;\n\t      if (pstr->bufs_len > pstr->valid_len + dfa->mb_cur_max)\n\t\tbreak;\n\t      ret = re_string_realloc_buffers (pstr, pstr->bufs_len * 2);\n\t      if (BE (ret != REG_NOERROR, 0))\n\t\treturn ret;\n\t    }\n\t}\n      else\n#endif /* RE_ENABLE_I18N  */\n\tbuild_upper_buffer (pstr);\n    }\n  else\n    {\n#ifdef RE_ENABLE_I18N\n      if (dfa->mb_cur_max > 1)\n\tbuild_wcs_buffer (pstr);\n      else\n#endif /* RE_ENABLE_I18N  */\n\t{\n\t  if (trans != NULL)\n\t    re_string_translate_buffer (pstr);\n\t  else\n\t    {\n\t      pstr->valid_len = pstr->bufs_len;\n\t      pstr->valid_raw_len = pstr->bufs_len;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 59,
      "depth": 16,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_realloc_buffers": {
      "start_point": [
        128,
        18
      ],
      "end_point": [
        164,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_realloc_buffers (re_string_t *pstr, Idx new_buf_len)\n{\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      wint_t *new_wcs;\n\n      /* Avoid overflow in realloc.  */\n      const size_t max_object_size = MAX (sizeof (wint_t), sizeof (Idx));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_buf_len, 0))\n\treturn REG_ESPACE;\n\n      new_wcs = re_realloc (pstr->wcs, wint_t, new_buf_len);\n      if (BE (new_wcs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->wcs = new_wcs;\n      if (pstr->offsets != NULL)\n\t{\n\t  Idx *new_offsets = re_realloc (pstr->offsets, Idx, new_buf_len);\n\t  if (BE (new_offsets == NULL, 0))\n\t    return REG_ESPACE;\n\t  pstr->offsets = new_offsets;\n\t}\n    }\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    {\n      unsigned char *new_mbs = re_realloc (pstr->mbs, unsigned char,\n\t\t\t\t\t   new_buf_len);\n      if (BE (new_mbs == NULL, 0))\n\treturn REG_ESPACE;\n      pstr->mbs = new_mbs;\n    }\n  pstr->bufs_len = new_buf_len;\n  return REG_NOERROR;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_construct_common": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static void\ninternal_function\nre_string_construct_common (const char *str, Idx len, re_string_t *pstr,\n\t\t\t    RE_TRANSLATE_TYPE trans, bool icase,\n\t\t\t    const re_dfa_t *dfa)\n{\n  pstr->raw_mbs = (const unsigned char *) str;\n  pstr->len = len;\n  pstr->raw_len = len;\n  pstr->trans = trans;\n  pstr->icase = icase;\n  pstr->mbs_allocated = (trans != NULL || icase);\n  pstr->mb_cur_max = dfa->mb_cur_max;\n  pstr->is_utf8 = dfa->is_utf8;\n  pstr->map_notascii = dfa->map_notascii;\n  pstr->stop = pstr->len;\n  pstr->raw_stop = pstr->stop;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_buffer": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static void\ninternal_function\nbuild_wcs_buffer (re_string_t *pstr)\n{\n#ifdef _LIBC\n  unsigned char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  unsigned char buf[64];\n#endif\n  mbstate_t prev_st;\n  Idx byte_idx, end_idx, remain_len;\n  size_t mbclen;\n\n  /* Build the buffers from pstr->valid_len to either pstr->len or\n     pstr->bufs_len.  */\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n  for (byte_idx = pstr->valid_len; byte_idx < end_idx;)\n    {\n      wchar_t wc;\n      const char *p;\n\n      remain_len = end_idx - byte_idx;\n      prev_st = pstr->cur_state;\n      /* Apply the translation if we need.  */\n      if (BE (pstr->trans != NULL, 0))\n\t{\n\t  int i, ch;\n\n\t  for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t    {\n\t      ch = pstr->raw_mbs [pstr->raw_mbs_idx + byte_idx + i];\n\t      buf[i] = pstr->mbs[byte_idx + i] = pstr->trans[ch];\n\t    }\n\t  p = (const char *) buf;\n\t}\n      else\n\tp = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + byte_idx;\n      mbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -1 || mbclen == 0\n\t      || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len), 0))\n\t{\n\t  /* We treat these cases as a singlebyte character.  */\n\t  mbclen = 1;\n\t  wc = (wchar_t) pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t  if (BE (pstr->trans != NULL, 0))\n\t    wc = pstr->trans[wc];\n\t  pstr->cur_state = prev_st;\n\t}\n      else if (BE (mbclen == (size_t) -2, 0))\n\t{\n\t  /* The buffer doesn't have enough space, finish to build.  */\n\t  pstr->cur_state = prev_st;\n\t  break;\n\t}\n\n      /* Write wide character and padding.  */\n      pstr->wcs[byte_idx++] = wc;\n      /* Write paddings.  */\n      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\tpstr->wcs[byte_idx++] = WEOF;\n    }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = byte_idx;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "build_wcs_upper_buffer": {
      "start_point": [
        269,
        18
      ],
      "end_point": [
        480,
        1
      ],
      "content": "__attribute_warn_unused_result__\nbuild_wcs_upper_buffer (re_string_t *pstr)\n{\n  mbstate_t prev_st;\n  Idx src_idx, byte_idx, end_idx, remain_len;\n  size_t mbclen;\n#ifdef _LIBC\n  char buf[MB_LEN_MAX];\n  assert (MB_LEN_MAX >= pstr->mb_cur_max);\n#else\n  char buf[64];\n#endif\n\n  byte_idx = pstr->valid_len;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  /* The following optimization assumes that ASCII characters can be\n     mapped to wide characters with a simple cast.  */\n  if (! pstr->map_notascii && pstr->trans == NULL && !pstr->offsets_needed)\n    {\n      while (byte_idx < end_idx)\n\t{\n\t  wchar_t wc;\n\n\t  if (isascii (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx])\n\t      && mbsinit (&pstr->cur_state))\n\t    {\n\t      /* In case of a singlebyte character.  */\n\t      pstr->mbs[byte_idx]\n\t\t= toupper (pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx]);\n\t      /* The next step uses the assumption that wchar_t is encoded\n\t\t ASCII-safe: all ASCII values can be converted like this.  */\n\t      pstr->wcs[byte_idx] = (wchar_t) pstr->mbs[byte_idx];\n\t      ++byte_idx;\n\t      continue;\n\t    }\n\n\t  remain_len = end_idx - byte_idx;\n\t  prev_st = pstr->cur_state;\n\t  mbclen = __mbrtowc (&wc,\n\t\t\t      ((const char *) pstr->raw_mbs + pstr->raw_mbs_idx\n\t\t\t       + byte_idx), remain_len, &pstr->cur_state);\n\t  if (BE (mbclen < (size_t) -2, 1))\n\t    {\n\t      wchar_t wcu = towupper (wc);\n\t      if (wcu != wc)\n\t\t{\n\t\t  size_t mbcdlen;\n\n\t\t  mbcdlen = wcrtomb (buf, wcu, &prev_st);\n\t\t  if (BE (mbclen == mbcdlen, 1))\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\t  else\n\t\t    {\n\t\t      src_idx = byte_idx;\n\t\t      goto offsets_needed;\n\t\t    }\n\t\t}\n\t      else\n\t\tmemcpy (pstr->mbs + byte_idx,\n\t\t\tpstr->raw_mbs + pstr->raw_mbs_idx + byte_idx, mbclen);\n\t      pstr->wcs[byte_idx++] = wcu;\n\t      /* Write paddings.  */\n\t      for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t\tpstr->wcs[byte_idx++] = WEOF;\n\t    }\n\t  else if (mbclen == (size_t) -1 || mbclen == 0\n\t\t   || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t    {\n\t      /* It is an invalid character, an incomplete character\n\t\t at the end of the string, or '\\0'.  Just use the byte.  */\n\t      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + byte_idx];\n\t      pstr->mbs[byte_idx] = ch;\n\t      /* And also cast it to wide char.  */\n\t      pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t      if (BE (mbclen == (size_t) -1, 0))\n\t\tpstr->cur_state = prev_st;\n\t    }\n\t  else\n\t    {\n\t      /* The buffer doesn't have enough space, finish to build.  */\n\t      pstr->cur_state = prev_st;\n\t      break;\n\t    }\n\t}\n      pstr->valid_len = byte_idx;\n      pstr->valid_raw_len = byte_idx;\n      return REG_NOERROR;\n    }\n  else\n    for (src_idx = pstr->valid_raw_len; byte_idx < end_idx;)\n      {\n\twchar_t wc;\n\tconst char *p;\n      offsets_needed:\n\tremain_len = end_idx - byte_idx;\n\tprev_st = pstr->cur_state;\n\tif (BE (pstr->trans != NULL, 0))\n\t  {\n\t    int i, ch;\n\n\t    for (i = 0; i < pstr->mb_cur_max && i < remain_len; ++i)\n\t      {\n\t\tch = pstr->raw_mbs [pstr->raw_mbs_idx + src_idx + i];\n\t\tbuf[i] = pstr->trans[ch];\n\t      }\n\t    p = (const char *) buf;\n\t  }\n\telse\n\t  p = (const char *) pstr->raw_mbs + pstr->raw_mbs_idx + src_idx;\n\tmbclen = __mbrtowc (&wc, p, remain_len, &pstr->cur_state);\n\tif (BE (mbclen < (size_t) -2, 1))\n\t  {\n\t    wchar_t wcu = towupper (wc);\n\t    if (wcu != wc)\n\t      {\n\t\tsize_t mbcdlen;\n\n\t\tmbcdlen = wcrtomb ((char *) buf, wcu, &prev_st);\n\t\tif (BE (mbclen == mbcdlen, 1))\n\t\t  memcpy (pstr->mbs + byte_idx, buf, mbclen);\n\t\telse if (mbcdlen != (size_t) -1)\n\t\t  {\n\t\t    size_t i;\n\n\t\t    if (byte_idx + mbcdlen > pstr->bufs_len)\n\t\t      {\n\t\t\tpstr->cur_state = prev_st;\n\t\t\tbreak;\n\t\t      }\n\n\t\t    if (pstr->offsets == NULL)\n\t\t      {\n\t\t\tpstr->offsets = re_malloc (Idx, pstr->bufs_len);\n\n\t\t\tif (pstr->offsets == NULL)\n\t\t\t  return REG_ESPACE;\n\t\t      }\n\t\t    if (!pstr->offsets_needed)\n\t\t      {\n\t\t\tfor (i = 0; i < (size_t) byte_idx; ++i)\n\t\t\t  pstr->offsets[i] = i;\n\t\t\tpstr->offsets_needed = 1;\n\t\t      }\n\n\t\t    memcpy (pstr->mbs + byte_idx, buf, mbcdlen);\n\t\t    pstr->wcs[byte_idx] = wcu;\n\t\t    pstr->offsets[byte_idx] = src_idx;\n\t\t    for (i = 1; i < mbcdlen; ++i)\n\t\t      {\n\t\t\tpstr->offsets[byte_idx + i]\n\t\t\t  = src_idx + (i < mbclen ? i : mbclen - 1);\n\t\t\tpstr->wcs[byte_idx + i] = WEOF;\n\t\t      }\n\t\t    pstr->len += mbcdlen - mbclen;\n\t\t    if (pstr->raw_stop > src_idx)\n\t\t      pstr->stop += mbcdlen - mbclen;\n\t\t    end_idx = (pstr->bufs_len > pstr->len)\n\t\t\t      ? pstr->len : pstr->bufs_len;\n\t\t    byte_idx += mbcdlen;\n\t\t    src_idx += mbclen;\n\t\t    continue;\n\t\t  }\n\t\telse\n\t\t  memcpy (pstr->mbs + byte_idx, p, mbclen);\n\t      }\n\t    else\n\t      memcpy (pstr->mbs + byte_idx, p, mbclen);\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      {\n\t\tsize_t i;\n\t\tfor (i = 0; i < mbclen; ++i)\n\t\t  pstr->offsets[byte_idx + i] = src_idx + i;\n\t      }\n\t    src_idx += mbclen;\n\n\t    pstr->wcs[byte_idx++] = wcu;\n\t    /* Write paddings.  */\n\t    for (remain_len = byte_idx + mbclen - 1; byte_idx < remain_len ;)\n\t      pstr->wcs[byte_idx++] = WEOF;\n\t  }\n\telse if (mbclen == (size_t) -1 || mbclen == 0\n\t\t || (mbclen == (size_t) -2 && pstr->bufs_len >= pstr->len))\n\t  {\n\t    /* It is an invalid character or '\\0'.  Just use the byte.  */\n\t    int ch = pstr->raw_mbs[pstr->raw_mbs_idx + src_idx];\n\n\t    if (BE (pstr->trans != NULL, 0))\n\t      ch = pstr->trans [ch];\n\t    pstr->mbs[byte_idx] = ch;\n\n\t    if (BE (pstr->offsets_needed != 0, 0))\n\t      pstr->offsets[byte_idx] = src_idx;\n\t    ++src_idx;\n\n\t    /* And also cast it to wide char.  */\n\t    pstr->wcs[byte_idx++] = (wchar_t) ch;\n\t    if (BE (mbclen == (size_t) -1, 0))\n\t      pstr->cur_state = prev_st;\n\t  }\n\telse\n\t  {\n\t    /* The buffer doesn't have enough space, finish to build.  */\n\t    pstr->cur_state = prev_st;\n\t    break;\n\t  }\n      }\n  pstr->valid_len = byte_idx;\n  pstr->valid_raw_len = src_idx;\n  return REG_NOERROR;\n}",
      "lines": 212,
      "depth": 21,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_string_skip_chars": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static Idx\ninternal_function\nre_string_skip_chars (re_string_t *pstr, Idx new_raw_idx, wint_t *last_wc)\n{\n  mbstate_t prev_st;\n  Idx rawbuf_idx;\n  size_t mbclen;\n  wint_t wc = WEOF;\n\n  /* Skip the characters which are not necessary to check.  */\n  for (rawbuf_idx = pstr->raw_mbs_idx + pstr->valid_raw_len;\n       rawbuf_idx < new_raw_idx;)\n    {\n      wchar_t wc2;\n      Idx remain_len = pstr->raw_len - rawbuf_idx;\n      prev_st = pstr->cur_state;\n      mbclen = __mbrtowc (&wc2, (const char *) pstr->raw_mbs + rawbuf_idx,\n\t\t\t  remain_len, &pstr->cur_state);\n      if (BE (mbclen == (size_t) -2 || mbclen == (size_t) -1 || mbclen == 0, 0))\n\t{\n\t  /* We treat these cases as a single byte character.  */\n\t  if (mbclen == 0 || remain_len == 0)\n\t    wc = L'\\0';\n\t  else\n\t    wc = *(unsigned char *) (pstr->raw_mbs + rawbuf_idx);\n\t  mbclen = 1;\n\t  pstr->cur_state = prev_st;\n\t}\n      else\n\twc = wc2;\n      /* Then proceed the next character.  */\n      rawbuf_idx += mbclen;\n    }\n  *last_wc = wc;\n  return rawbuf_idx;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "build_upper_buffer": {
      "start_point": [
        526,
        0
      ],
      "end_point": [
        542,
        1
      ],
      "content": "static void\ninternal_function\nbuild_upper_buffer (re_string_t *pstr)\n{\n  Idx char_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (char_idx = pstr->valid_len; char_idx < end_idx; ++char_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + char_idx];\n      if (BE (pstr->trans != NULL, 0))\n\tch = pstr->trans[ch];\n      pstr->mbs[char_idx] = toupper (ch);\n    }\n  pstr->valid_len = char_idx;\n  pstr->valid_raw_len = char_idx;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_translate_buffer": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        561,
        1
      ],
      "content": "static void\ninternal_function\nre_string_translate_buffer (re_string_t *pstr)\n{\n  Idx buf_idx, end_idx;\n  end_idx = (pstr->bufs_len > pstr->len) ? pstr->len : pstr->bufs_len;\n\n  for (buf_idx = pstr->valid_len; buf_idx < end_idx; ++buf_idx)\n    {\n      int ch = pstr->raw_mbs[pstr->raw_mbs_idx + buf_idx];\n      pstr->mbs[buf_idx] = pstr->trans[ch];\n    }\n\n  pstr->valid_len = buf_idx;\n  pstr->valid_raw_len = buf_idx;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_reconstruct": {
      "start_point": [
        568,
        18
      ],
      "end_point": [
        828,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_string_reconstruct (re_string_t *pstr, Idx idx, int eflags)\n{\n  Idx offset;\n\n  if (BE (pstr->raw_mbs_idx <= idx, 0))\n    offset = idx - pstr->raw_mbs_idx;\n  else\n    {\n      /* Reset buffer.  */\n#ifdef RE_ENABLE_I18N\n      if (pstr->mb_cur_max > 1)\n\tmemset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n#endif /* RE_ENABLE_I18N */\n      pstr->len = pstr->raw_len;\n      pstr->stop = pstr->raw_stop;\n      pstr->valid_len = 0;\n      pstr->raw_mbs_idx = 0;\n      pstr->valid_raw_len = 0;\n      pstr->offsets_needed = 0;\n      pstr->tip_context = ((eflags & REG_NOTBOL) ? CONTEXT_BEGBUF\n\t\t\t   : CONTEXT_NEWLINE | CONTEXT_BEGBUF);\n      if (!pstr->mbs_allocated)\n\tpstr->mbs = (unsigned char *) pstr->raw_mbs;\n      offset = idx;\n    }\n\n  if (BE (offset != 0, 1))\n    {\n      /* Should the already checked characters be kept?  */\n      if (BE (offset < pstr->valid_raw_len, 1))\n\t{\n\t  /* Yes, move them to the front of the buffer.  */\n#ifdef RE_ENABLE_I18N\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      Idx low = 0, high = pstr->valid_len, mid;\n\t      do\n\t\t{\n\t\t  mid = (high + low) / 2;\n\t\t  if (pstr->offsets[mid] > offset)\n\t\t    high = mid;\n\t\t  else if (pstr->offsets[mid] < offset)\n\t\t    low = mid + 1;\n\t\t  else\n\t\t    break;\n\t\t}\n\t      while (low < high);\n\t      if (pstr->offsets[mid] < offset)\n\t\t++mid;\n\t      pstr->tip_context = re_string_context_at (pstr, mid - 1,\n\t\t\t\t\t\t\teflags);\n\t      /* This can be quite complicated, so handle specially\n\t\t only the common and easy case where the character with\n\t\t different length representation of lower and upper\n\t\t case is present at or after offset.  */\n\t      if (pstr->valid_len > offset\n\t\t  && mid == offset && pstr->offsets[mid] == offset)\n\t\t{\n\t\t  memmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t   (pstr->valid_len - offset) * sizeof (wint_t));\n\t\t  memmove (pstr->mbs, pstr->mbs + offset, pstr->valid_len - offset);\n\t\t  pstr->valid_len -= offset;\n\t\t  pstr->valid_raw_len -= offset;\n\t\t  for (low = 0; low < pstr->valid_len; low++)\n\t\t    pstr->offsets[low] = pstr->offsets[low + offset] - offset;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Otherwise, just find out how long the partial multibyte\n\t\t     character at offset is and fill it with WEOF/255.  */\n\t\t  pstr->len = pstr->raw_len - idx + offset;\n\t\t  pstr->stop = pstr->raw_stop - idx + offset;\n\t\t  pstr->offsets_needed = 0;\n\t\t  while (mid > 0 && pstr->offsets[mid - 1] == offset)\n\t\t    --mid;\n\t\t  while (mid < pstr->valid_len)\n\t\t    if (pstr->wcs[mid] != WEOF)\n\t\t      break;\n\t\t    else\n\t\t      ++mid;\n\t\t  if (mid == pstr->valid_len)\n\t\t    pstr->valid_len = 0;\n\t\t  else\n\t\t    {\n\t\t      pstr->valid_len = pstr->offsets[mid] - offset;\n\t\t      if (pstr->valid_len)\n\t\t\t{\n\t\t\t  for (low = 0; low < pstr->valid_len; ++low)\n\t\t\t    pstr->wcs[low] = WEOF;\n\t\t\t  memset (pstr->mbs, 255, pstr->valid_len);\n\t\t\t}\n\t\t    }\n\t\t  pstr->valid_raw_len = pstr->valid_len;\n\t\t}\n\t    }\n\t  else\n#endif\n\t    {\n\t      pstr->tip_context = re_string_context_at (pstr, offset - 1,\n\t\t\t\t\t\t\teflags);\n#ifdef RE_ENABLE_I18N\n\t      if (pstr->mb_cur_max > 1)\n\t\tmemmove (pstr->wcs, pstr->wcs + offset,\n\t\t\t (pstr->valid_len - offset) * sizeof (wint_t));\n#endif /* RE_ENABLE_I18N */\n\t      if (BE (pstr->mbs_allocated, 0))\n\t\tmemmove (pstr->mbs, pstr->mbs + offset,\n\t\t\t pstr->valid_len - offset);\n\t      pstr->valid_len -= offset;\n\t      pstr->valid_raw_len -= offset;\n#if DEBUG\n\t      assert (pstr->valid_len > 0);\n#endif\n\t    }\n\t}\n      else\n\t{\n#ifdef RE_ENABLE_I18N\n\t  /* No, skip all characters until IDX.  */\n\t  Idx prev_valid_len = pstr->valid_len;\n\n\t  if (BE (pstr->offsets_needed, 0))\n\t    {\n\t      pstr->len = pstr->raw_len - idx + offset;\n\t      pstr->stop = pstr->raw_stop - idx + offset;\n\t      pstr->offsets_needed = 0;\n\t    }\n#endif\n\t  pstr->valid_len = 0;\n#ifdef RE_ENABLE_I18N\n\t  if (pstr->mb_cur_max > 1)\n\t    {\n\t      Idx wcs_idx;\n\t      wint_t wc = WEOF;\n\n\t      if (pstr->is_utf8)\n\t\t{\n\t\t  const unsigned char *raw, *p, *end;\n\n\t\t  /* Special case UTF-8.  Multi-byte chars start with any\n\t\t     byte other than 0x80 - 0xbf.  */\n\t\t  raw = pstr->raw_mbs + pstr->raw_mbs_idx;\n\t\t  end = raw + (offset - pstr->mb_cur_max);\n\t\t  if (end < pstr->raw_mbs)\n\t\t    end = pstr->raw_mbs;\n\t\t  p = raw + offset - 1;\n#ifdef _LIBC\n\t\t  /* We know the wchar_t encoding is UCS4, so for the simple\n\t\t     case, ASCII characters, skip the conversion step.  */\n\t\t  if (isascii (*p) && BE (pstr->trans == NULL, 1))\n\t\t    {\n\t\t      memset (&pstr->cur_state, '\\0', sizeof (mbstate_t));\n\t\t      /* pstr->valid_len = 0; */\n\t\t      wc = (wchar_t) *p;\n\t\t    }\n\t\t  else\n#endif\n\t\t    for (; p >= end; --p)\n\t\t      if ((*p & 0xc0) != 0x80)\n\t\t\t{\n\t\t\t  mbstate_t cur_state;\n\t\t\t  wchar_t wc2;\n\t\t\t  Idx mlen = raw + pstr->len - p;\n\t\t\t  unsigned char buf[6];\n\t\t\t  size_t mbclen;\n\n\t\t\t  const unsigned char *pp = p;\n\t\t\t  if (BE (pstr->trans != NULL, 0))\n\t\t\t    {\n\t\t\t      int i = mlen < 6 ? mlen : 6;\n\t\t\t      while (--i >= 0)\n\t\t\t\tbuf[i] = pstr->trans[p[i]];\n\t\t\t      pp = buf;\n\t\t\t    }\n\t\t\t  /* XXX Don't use mbrtowc, we know which conversion\n\t\t\t     to use (UTF-8 -> UCS4).  */\n\t\t\t  memset (&cur_state, 0, sizeof (cur_state));\n\t\t\t  mbclen = __mbrtowc (&wc2, (const char *) pp, mlen,\n\t\t\t\t\t      &cur_state);\n\t\t\t  if (raw + offset - p <= mbclen\n\t\t\t      && mbclen < (size_t) -2)\n\t\t\t    {\n\t\t\t      memset (&pstr->cur_state, '\\0',\n\t\t\t\t      sizeof (mbstate_t));\n\t\t\t      pstr->valid_len = mbclen - (raw + offset - p);\n\t\t\t      wc = wc2;\n\t\t\t    }\n\t\t\t  break;\n\t\t\t}\n\t\t}\n\n\t      if (wc == WEOF)\n\t\tpstr->valid_len = re_string_skip_chars (pstr, idx, &wc) - idx;\n\t      if (wc == WEOF)\n\t\tpstr->tip_context\n\t\t  = re_string_context_at (pstr, prev_valid_len - 1, eflags);\n\t      else\n\t\tpstr->tip_context = ((BE (pstr->word_ops_used != 0, 0)\n\t\t\t\t      && IS_WIDE_WORD_CHAR (wc))\n\t\t\t\t     ? CONTEXT_WORD\n\t\t\t\t     : ((IS_WIDE_NEWLINE (wc)\n\t\t\t\t\t && pstr->newline_anchor)\n\t\t\t\t\t? CONTEXT_NEWLINE : 0));\n\t      if (BE (pstr->valid_len, 0))\n\t\t{\n\t\t  for (wcs_idx = 0; wcs_idx < pstr->valid_len; ++wcs_idx)\n\t\t    pstr->wcs[wcs_idx] = WEOF;\n\t\t  if (pstr->mbs_allocated)\n\t\t    memset (pstr->mbs, 255, pstr->valid_len);\n\t\t}\n\t      pstr->valid_raw_len = pstr->valid_len;\n\t    }\n\t  else\n#endif /* RE_ENABLE_I18N */\n\t    {\n\t      int c = pstr->raw_mbs[pstr->raw_mbs_idx + offset - 1];\n\t      pstr->valid_raw_len = 0;\n\t      if (pstr->trans)\n\t\tc = pstr->trans[c];\n\t      pstr->tip_context = (bitset_contain (pstr->word_char, c)\n\t\t\t\t   ? CONTEXT_WORD\n\t\t\t\t   : ((IS_NEWLINE (c) && pstr->newline_anchor)\n\t\t\t\t      ? CONTEXT_NEWLINE : 0));\n\t    }\n\t}\n      if (!BE (pstr->mbs_allocated, 0))\n\tpstr->mbs += offset;\n    }\n  pstr->raw_mbs_idx = idx;\n  pstr->len -= offset;\n  pstr->stop -= offset;\n\n  /* Then build the buffers.  */\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1)\n    {\n      if (pstr->icase)\n\t{\n\t  reg_errcode_t ret = build_wcs_upper_buffer (pstr);\n\t  if (BE (ret != REG_NOERROR, 0))\n\t    return ret;\n\t}\n      else\n\tbuild_wcs_buffer (pstr);\n    }\n  else\n#endif /* RE_ENABLE_I18N */\n    if (BE (pstr->mbs_allocated, 0))\n      {\n\tif (pstr->icase)\n\t  build_upper_buffer (pstr);\n\telse if (pstr->trans != NULL)\n\t  re_string_translate_buffer (pstr);\n      }\n    else\n      pstr->valid_len = pstr->len;\n\n  pstr->cur_idx = 0;\n  return REG_NOERROR;\n}",
      "lines": 261,
      "depth": 23,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "internal_function": {
      "start_point": [
        831,
        18
      ],
      "end_point": [
        865,
        1
      ],
      "content": "__attribute__ ((pure))\nre_string_peek_byte_case (const re_string_t *pstr, Idx idx)\n{\n  int ch;\n  Idx off;\n\n  /* Handle the common (easiest) cases first.  */\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_peek_byte (pstr, idx);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->mb_cur_max > 1\n      && ! re_string_is_single_byte_char (pstr, pstr->cur_idx + idx))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  off = pstr->cur_idx + idx;\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    off = pstr->offsets[off];\n#endif\n\n  ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n#ifdef RE_ENABLE_I18N\n  /* Ensure that e.g. for tr_TR.UTF-8 BACKSLASH DOTLESS SMALL LETTER I\n     this function returns CAPITAL LETTER I instead of first byte of\n     DOTLESS SMALL LETTER I.  The latter would confuse the parser,\n     since peek_byte_case doesn't advance cur_idx in any way.  */\n  if (pstr->offsets_needed && !isascii (ch))\n    return re_string_peek_byte (pstr, idx);\n#endif\n\n  return ch;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": null
    },
    "re_string_fetch_byte_case": {
      "start_point": [
        867,
        0
      ],
      "end_point": [
        903,
        1
      ],
      "content": "static unsigned char\ninternal_function\nre_string_fetch_byte_case (re_string_t *pstr)\n{\n  if (BE (!pstr->mbs_allocated, 1))\n    return re_string_fetch_byte (pstr);\n\n#ifdef RE_ENABLE_I18N\n  if (pstr->offsets_needed)\n    {\n      Idx off;\n      int ch;\n\n      /* For tr_TR.UTF-8 [[:islower:]] there is\n\t [[: CAPITAL LETTER I WITH DOT lower:]] in mbs.  Skip\n\t in that case the whole multi-byte character and return\n\t the original letter.  On the other side, with\n\t [[: DOTLESS SMALL LETTER I return [[:I, as doing\n\t anything else would complicate things too much.  */\n\n      if (!re_string_first_byte (pstr, pstr->cur_idx))\n\treturn re_string_fetch_byte (pstr);\n\n      off = pstr->offsets[pstr->cur_idx];\n      ch = pstr->raw_mbs[pstr->raw_mbs_idx + off];\n\n      if (! isascii (ch))\n\treturn re_string_fetch_byte (pstr);\n\n      re_string_skip_bytes (pstr,\n\t\t\t    re_string_char_size_at (pstr, pstr->cur_idx));\n      return ch;\n    }\n#endif\n\n  return pstr->raw_mbs[pstr->raw_mbs_idx + pstr->cur_idx++];\n}",
      "lines": 37,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_destruct": {
      "start_point": [
        905,
        0
      ],
      "end_point": [
        915,
        1
      ],
      "content": "static void\ninternal_function\nre_string_destruct (re_string_t *pstr)\n{\n#ifdef RE_ENABLE_I18N\n  re_free (pstr->wcs);\n  re_free (pstr->offsets);\n#endif /* RE_ENABLE_I18N  */\n  if (pstr->mbs_allocated)\n    re_free (pstr->mbs);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_string_context_at": {
      "start_point": [
        919,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "static unsigned int\ninternal_function\nre_string_context_at (const re_string_t *input, Idx idx, int eflags)\n{\n  int c;\n  if (BE (! REG_VALID_INDEX (idx), 0))\n    /* In this case, we use the value stored in input->tip_context,\n       since we can't know the character in input->mbs[-1] here.  */\n    return input->tip_context;\n  if (BE (idx == input->len, 0))\n    return ((eflags & REG_NOTEOL) ? CONTEXT_ENDBUF\n\t    : CONTEXT_NEWLINE | CONTEXT_ENDBUF);\n#ifdef RE_ENABLE_I18N\n  if (input->mb_cur_max > 1)\n    {\n      wint_t wc;\n      Idx wc_idx = idx;\n      while(input->wcs[wc_idx] == WEOF)\n\t{\n#ifdef DEBUG\n\t  /* It must not happen.  */\n\t  assert (REG_VALID_INDEX (wc_idx));\n#endif\n\t  --wc_idx;\n\t  if (! REG_VALID_INDEX (wc_idx))\n\t    return input->tip_context;\n\t}\n      wc = input->wcs[wc_idx];\n      if (BE (input->word_ops_used != 0, 0) && IS_WIDE_WORD_CHAR (wc))\n\treturn CONTEXT_WORD;\n      return (IS_WIDE_NEWLINE (wc) && input->newline_anchor\n\t      ? CONTEXT_NEWLINE : 0);\n    }\n  else\n#endif\n    {\n      c = re_string_byte_at (input, idx);\n      if (bitset_contain (input->word_char, c))\n\treturn CONTEXT_WORD;\n      return IS_NEWLINE (c) && input->newline_anchor ? CONTEXT_NEWLINE : 0;\n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "unsigned int",
        "unsigned",
        "int",
        "internal_function",
        "internal_function"
      ]
    },
    "re_node_set_alloc": {
      "start_point": [
        965,
        18
      ],
      "end_point": [
        974,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_alloc (re_node_set *set, Idx size)\n{\n  set->alloc = size;\n  set->nelem = 0;\n  set->elems = re_malloc (Idx, size);\n  if (BE (set->elems == NULL, 0) && (MALLOC_0_IS_NONNULL || size != 0))\n    return REG_ESPACE;\n  return REG_NOERROR;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_1": {
      "start_point": [
        977,
        18
      ],
      "end_point": [
        990,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_1 (re_node_set *set, Idx elem)\n{\n  set->alloc = 1;\n  set->nelem = 1;\n  set->elems = re_malloc (Idx, 1);\n  if (BE (set->elems == NULL, 0))\n    {\n      set->alloc = set->nelem = 0;\n      return REG_ESPACE;\n    }\n  set->elems[0] = elem;\n  return REG_NOERROR;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_2": {
      "start_point": [
        993,
        18
      ],
      "end_point": [
        1020,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_2 (re_node_set *set, Idx elem1, Idx elem2)\n{\n  set->alloc = 2;\n  set->elems = re_malloc (Idx, 2);\n  if (BE (set->elems == NULL, 0))\n    return REG_ESPACE;\n  if (elem1 == elem2)\n    {\n      set->nelem = 1;\n      set->elems[0] = elem1;\n    }\n  else\n    {\n      set->nelem = 2;\n      if (elem1 < elem2)\n\t{\n\t  set->elems[0] = elem1;\n\t  set->elems[1] = elem2;\n\t}\n      else\n\t{\n\t  set->elems[0] = elem2;\n\t  set->elems[1] = elem1;\n\t}\n    }\n  return REG_NOERROR;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_copy": {
      "start_point": [
        1023,
        18
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_copy (re_node_set *dest, const re_node_set *src)\n{\n  dest->nelem = src->nelem;\n  if (src->nelem > 0)\n    {\n      dest->alloc = dest->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\t{\n\t  dest->alloc = dest->nelem = 0;\n\t  return REG_ESPACE;\n\t}\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n    }\n  else\n    re_node_set_init_empty (dest);\n  return REG_NOERROR;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_add_intersect": {
      "start_point": [
        1048,
        18
      ],
      "end_point": [
        1133,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_add_intersect (re_node_set *dest, const re_node_set *src1,\n\t\t\t   const re_node_set *src2)\n{\n  Idx i1, i2, is, id, delta, sbase;\n  if (src1->nelem == 0 || src2->nelem == 0)\n    return REG_NOERROR;\n\n  /* We need dest->nelem + 2 * elems_in_intersection; this is a\n     conservative estimate.  */\n  if (src1->nelem + src2->nelem + dest->nelem > dest->alloc)\n    {\n      Idx new_alloc = src1->nelem + src2->nelem + dest->alloc;\n      Idx *new_elems = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_elems;\n      dest->alloc = new_alloc;\n    }\n\n  /* Find the items in the intersection of SRC1 and SRC2, and copy\n     into the top of DEST those that are not already in DEST itself.  */\n  sbase = dest->nelem + src1->nelem + src2->nelem;\n  i1 = src1->nelem - 1;\n  i2 = src2->nelem - 1;\n  id = dest->nelem - 1;\n  for (;;)\n    {\n      if (src1->elems[i1] == src2->elems[i2])\n\t{\n\t  /* Try to find the item in DEST.  Maybe we could binary search?  */\n\t  while (REG_VALID_INDEX (id) && dest->elems[id] > src1->elems[i1])\n\t    --id;\n\n          if (! REG_VALID_INDEX (id) || dest->elems[id] != src1->elems[i1])\n            dest->elems[--sbase] = src1->elems[i1];\n\n\t  if (! REG_VALID_INDEX (--i1) || ! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n\n      /* Lower the highest of the two items.  */\n      else if (src1->elems[i1] < src2->elems[i2])\n\t{\n\t  if (! REG_VALID_INDEX (--i2))\n\t    break;\n\t}\n      else\n\t{\n\t  if (! REG_VALID_INDEX (--i1))\n\t    break;\n\t}\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + src1->nelem + src2->nelem - 1;\n  delta = is - sbase + 1;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place; this is more or\n     less the same loop that is in re_node_set_merge.  */\n  dest->nelem += delta;\n  if (delta > 0 && REG_VALID_INDEX (id))\n    for (;;)\n      {\n\tif (dest->elems[is] > dest->elems[id])\n\t  {\n\t    /* Copy from the top.  */\n\t    dest->elems[id + delta--] = dest->elems[is--];\n\t    if (delta == 0)\n\t      break;\n\t  }\n\telse\n\t  {\n\t    /* Slide from the bottom.  */\n\t    dest->elems[id + delta] = dest->elems[id];\n\t    if (! REG_VALID_INDEX (--id))\n\t      break;\n\t  }\n      }\n\n  /* Copy remaining SRC elements.  */\n  memcpy (dest->elems, dest->elems + sbase, delta * sizeof (Idx));\n\n  return REG_NOERROR;\n}",
      "lines": 86,
      "depth": 14,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_init_union": {
      "start_point": [
        1139,
        18
      ],
      "end_point": [
        1186,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_init_union (re_node_set *dest, const re_node_set *src1,\n\t\t\tconst re_node_set *src2)\n{\n  Idx i1, i2, id;\n  if (src1 != NULL && src1->nelem > 0 && src2 != NULL && src2->nelem > 0)\n    {\n      dest->alloc = src1->nelem + src2->nelem;\n      dest->elems = re_malloc (Idx, dest->alloc);\n      if (BE (dest->elems == NULL, 0))\n\treturn REG_ESPACE;\n    }\n  else\n    {\n      if (src1 != NULL && src1->nelem > 0)\n\treturn re_node_set_init_copy (dest, src1);\n      else if (src2 != NULL && src2->nelem > 0)\n\treturn re_node_set_init_copy (dest, src2);\n      else\n\tre_node_set_init_empty (dest);\n      return REG_NOERROR;\n    }\n  for (i1 = i2 = id = 0 ; i1 < src1->nelem && i2 < src2->nelem ;)\n    {\n      if (src1->elems[i1] > src2->elems[i2])\n\t{\n\t  dest->elems[id++] = src2->elems[i2++];\n\t  continue;\n\t}\n      if (src1->elems[i1] == src2->elems[i2])\n\t++i2;\n      dest->elems[id++] = src1->elems[i1++];\n    }\n  if (i1 < src1->nelem)\n    {\n      memcpy (dest->elems + id, src1->elems + i1,\n\t     (src1->nelem - i1) * sizeof (Idx));\n      id += src1->nelem - i1;\n    }\n  else if (i2 < src2->nelem)\n    {\n      memcpy (dest->elems + id, src2->elems + i2,\n\t     (src2->nelem - i2) * sizeof (Idx));\n      id += src2->nelem - i2;\n    }\n  dest->nelem = id;\n  return REG_NOERROR;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_merge": {
      "start_point": [
        1192,
        18
      ],
      "end_point": [
        1269,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_merge (re_node_set *dest, const re_node_set *src)\n{\n  Idx is, id, sbase, delta;\n  if (src == NULL || src->nelem == 0)\n    return REG_NOERROR;\n  if (dest->alloc < 2 * src->nelem + dest->nelem)\n    {\n      Idx new_alloc = 2 * (src->nelem + dest->alloc);\n      Idx *new_buffer = re_realloc (dest->elems, Idx, new_alloc);\n      if (BE (new_buffer == NULL, 0))\n\treturn REG_ESPACE;\n      dest->elems = new_buffer;\n      dest->alloc = new_alloc;\n    }\n\n  if (BE (dest->nelem == 0, 0))\n    {\n      dest->nelem = src->nelem;\n      memcpy (dest->elems, src->elems, src->nelem * sizeof (Idx));\n      return REG_NOERROR;\n    }\n\n  /* Copy into the top of DEST the items of SRC that are not\n     found in DEST.  Maybe we could binary search in DEST?  */\n  for (sbase = dest->nelem + 2 * src->nelem,\n       is = src->nelem - 1, id = dest->nelem - 1;\n       REG_VALID_INDEX (is) && REG_VALID_INDEX (id); )\n    {\n      if (dest->elems[id] == src->elems[is])\n\tis--, id--;\n      else if (dest->elems[id] < src->elems[is])\n\tdest->elems[--sbase] = src->elems[is--];\n      else /* if (dest->elems[id] > src->elems[is]) */\n\t--id;\n    }\n\n  if (REG_VALID_INDEX (is))\n    {\n      /* If DEST is exhausted, the remaining items of SRC must be unique.  */\n      sbase -= is + 1;\n      memcpy (dest->elems + sbase, src->elems, (is + 1) * sizeof (Idx));\n    }\n\n  id = dest->nelem - 1;\n  is = dest->nelem + 2 * src->nelem - 1;\n  delta = is - sbase + 1;\n  if (delta == 0)\n    return REG_NOERROR;\n\n  /* Now copy.  When DELTA becomes zero, the remaining\n     DEST elements are already in place.  */\n  dest->nelem += delta;\n  for (;;)\n    {\n      if (dest->elems[is] > dest->elems[id])\n\t{\n\t  /* Copy from the top.  */\n\t  dest->elems[id + delta--] = dest->elems[is--];\n\t  if (delta == 0)\n\t    break;\n\t}\n      else\n\t{\n\t  /* Slide from the bottom.  */\n\t  dest->elems[id + delta] = dest->elems[id];\n\t  if (! REG_VALID_INDEX (--id))\n\t    {\n\t      /* Copy remaining SRC elements.  */\n\t      memcpy (dest->elems, dest->elems + sbase,\n\t\t      delta * sizeof (Idx));\n\t      break;\n\t    }\n\t}\n    }\n\n  return REG_NOERROR;\n}",
      "lines": 78,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert": {
      "start_point": [
        1276,
        18
      ],
      "end_point": [
        1321,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert (re_node_set *set, Idx elem)\n{\n  Idx idx;\n  /* In case the set is empty.  */\n  if (set->alloc == 0)\n    return BE (re_node_set_init_1 (set, elem) == REG_NOERROR, 1);\n\n  if (BE (set->nelem, 0) == 0)\n    {\n      /* We already guaranteed above that set->alloc != 0.  */\n      set->elems[0] = elem;\n      ++set->nelem;\n      return true;\n    }\n\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = set->alloc * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Move the elements which follows the new element.  Test the\n     first element separately to skip a check in the inner loop.  */\n  if (elem < set->elems[0])\n    {\n      idx = 0;\n      for (idx = set->nelem; idx > 0; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n  else\n    {\n      for (idx = set->nelem; set->elems[idx - 1] > elem; idx--)\n\tset->elems[idx] = set->elems[idx - 1];\n    }\n\n  /* Insert the new element.  */\n  set->elems[idx] = elem;\n  ++set->nelem;\n  return true;\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_node_set_insert_last": {
      "start_point": [
        1328,
        18
      ],
      "end_point": [
        1345,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_node_set_insert_last (re_node_set *set, Idx elem)\n{\n  /* Realloc if we need.  */\n  if (set->alloc == set->nelem)\n    {\n      Idx *new_elems;\n      set->alloc = (set->alloc + 1) * 2;\n      new_elems = re_realloc (set->elems, Idx, set->alloc);\n      if (BE (new_elems == NULL, 0))\n\treturn false;\n      set->elems = new_elems;\n    }\n\n  /* Insert the new element.  */\n  set->elems[set->nelem++] = elem;\n  return true;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "pure": {
      "start_point": [
        1352,
        52
      ],
      "end_point": [
        1361,
        1
      ],
      "content": "re_node_set *set2)\n{\n  Idx i;\n  if (set1 == NULL || set2 == NULL || set1->nelem != set2->nelem)\n    return false;\n  for (i = set1->nelem ; REG_VALID_INDEX (--i) ; )\n    if (set1->elems[i] != set2->elems[i])\n      return false;\n  return true;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "re_node_set_remove_at": {
      "start_point": [
        1387,
        0
      ],
      "end_point": [
        1396,
        1
      ],
      "content": "static void\ninternal_function\nre_node_set_remove_at (re_node_set *set, Idx idx)\n{\n  if (idx < 0 || idx >= set->nelem)\n    return;\n  --set->nelem;\n  for (; idx < set->nelem; idx++)\n    set->elems[idx] = set->elems[idx + 1];\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    },
    "re_dfa_add_node": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1448,
        1
      ],
      "content": "static Idx\ninternal_function\nre_dfa_add_node (re_dfa_t *dfa, re_token_t token)\n{\n  if (BE (dfa->nodes_len >= dfa->nodes_alloc, 0))\n    {\n      size_t new_nodes_alloc = dfa->nodes_alloc * 2;\n      Idx *new_nexts, *new_indices;\n      re_node_set *new_edests, *new_eclosures;\n      re_token_t *new_nodes;\n\n      /* Avoid overflows in realloc.  */\n      const size_t max_object_size = MAX (sizeof (re_token_t),\n\t\t\t\t\t  MAX (sizeof (re_node_set),\n\t\t\t\t\t       sizeof (Idx)));\n      if (BE (MIN (IDX_MAX, SIZE_MAX / max_object_size) < new_nodes_alloc, 0))\n\treturn REG_MISSING;\n\n      new_nodes = re_realloc (dfa->nodes, re_token_t, new_nodes_alloc);\n      if (BE (new_nodes == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nodes = new_nodes;\n      new_nexts = re_realloc (dfa->nexts, Idx, new_nodes_alloc);\n      new_indices = re_realloc (dfa->org_indices, Idx, new_nodes_alloc);\n      new_edests = re_realloc (dfa->edests, re_node_set, new_nodes_alloc);\n      new_eclosures = re_realloc (dfa->eclosures, re_node_set, new_nodes_alloc);\n      if (BE (new_nexts == NULL || new_indices == NULL\n\t      || new_edests == NULL || new_eclosures == NULL, 0))\n\treturn REG_MISSING;\n      dfa->nexts = new_nexts;\n      dfa->org_indices = new_indices;\n      dfa->edests = new_edests;\n      dfa->eclosures = new_eclosures;\n      dfa->nodes_alloc = new_nodes_alloc;\n    }\n  dfa->nodes[dfa->nodes_len] = token;\n  dfa->nodes[dfa->nodes_len].constraint = 0;\n#ifdef RE_ENABLE_I18N\n  dfa->nodes[dfa->nodes_len].accept_mb =\n    ((token.type == OP_PERIOD && dfa->mb_cur_max > 1)\n     || token.type == COMPLEX_BRACKET);\n#endif\n  dfa->nexts[dfa->nodes_len] = REG_MISSING;\n  re_node_set_init_empty (dfa->edests + dfa->nodes_len);\n  re_node_set_init_empty (dfa->eclosures + dfa->nodes_len);\n  return dfa->nodes_len++;\n}",
      "lines": 47,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "Idx",
        "internal_function",
        "internal_function"
      ]
    },
    "calc_state_hash": {
      "start_point": [
        1450,
        0
      ],
      "end_point": [
        1459,
        1
      ],
      "content": "static re_hashval_t\ninternal_function\ncalc_state_hash (const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash = nodes->nelem + context;\n  Idx i;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    hash += nodes->elems[i];\n  return hash;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "re_hashval_t",
        "internal_function",
        "internal_function"
      ]
    },
    "re_acquire_state": {
      "start_point": [
        1471,
        18
      ],
      "end_point": [
        1506,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t  const re_node_set *nodes)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (BE (nodes->nelem == 0, 0))\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, 0);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (hash != state->hash)\n\tcontinue;\n      if (re_node_set_compare (&state->nodes, nodes))\n\treturn state;\n    }\n\n  /* There are no appropriate state in the dfa, create the new one.  */\n  new_state = create_ci_newstate (dfa, nodes, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "re_acquire_state_context": {
      "start_point": [
        1519,
        18
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "__attribute_warn_unused_result__\nre_acquire_state_context (reg_errcode_t *err, const re_dfa_t *dfa,\n\t\t\t  const re_node_set *nodes, unsigned int context)\n{\n  re_hashval_t hash;\n  re_dfastate_t *new_state;\n  struct re_state_table_entry *spot;\n  Idx i;\n#ifdef lint\n  /* Suppress bogus uninitialized-variable warnings.  */\n  *err = REG_NOERROR;\n#endif\n  if (nodes->nelem == 0)\n    {\n      *err = REG_NOERROR;\n      return NULL;\n    }\n  hash = calc_state_hash (nodes, context);\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n\n  for (i = 0 ; i < spot->num ; i++)\n    {\n      re_dfastate_t *state = spot->array[i];\n      if (state->hash == hash\n\t  && state->context == context\n\t  && re_node_set_compare (state->entrance_nodes, nodes))\n\treturn state;\n    }\n  /* There are no appropriate state in 'dfa', create the new one.  */\n  new_state = create_cd_newstate (dfa, nodes, context, hash);\n  if (BE (new_state == NULL, 0))\n    *err = REG_ESPACE;\n\n  return new_state;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "register_state": {
      "start_point": [
        1559,
        0
      ],
      "end_point": [
        1593,
        1
      ],
      "content": "static reg_errcode_t\n__attribute_warn_unused_result__\nregister_state (const re_dfa_t *dfa, re_dfastate_t *newstate,\n\t\tre_hashval_t hash)\n{\n  struct re_state_table_entry *spot;\n  reg_errcode_t err;\n  Idx i;\n\n  newstate->hash = hash;\n  err = re_node_set_alloc (&newstate->non_eps_nodes, newstate->nodes.nelem);\n  if (BE (err != REG_NOERROR, 0))\n    return REG_ESPACE;\n  for (i = 0; i < newstate->nodes.nelem; i++)\n    {\n      Idx elem = newstate->nodes.elems[i];\n      if (!IS_EPSILON_NODE (dfa->nodes[elem].type))\n\tif (! re_node_set_insert_last (&newstate->non_eps_nodes, elem))\n\t  return REG_ESPACE;\n    }\n\n  spot = dfa->state_table + (hash & dfa->state_hash_mask);\n  if (BE (spot->alloc <= spot->num, 0))\n    {\n      Idx new_alloc = 2 * spot->num + 2;\n      re_dfastate_t **new_array = re_realloc (spot->array, re_dfastate_t *,\n\t\t\t\t\t      new_alloc);\n      if (BE (new_array == NULL, 0))\n\treturn REG_ESPACE;\n      spot->array = new_array;\n      spot->alloc = new_alloc;\n    }\n  spot->array[spot->num++] = newstate;\n  return REG_NOERROR;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "reg_errcode_t",
        "__attribute_warn_unused_result__",
        "__attribute_warn_unused_result__"
      ]
    },
    "free_state": {
      "start_point": [
        1595,
        0
      ],
      "end_point": [
        1609,
        1
      ],
      "content": "static void\nfree_state (re_dfastate_t *state)\n{\n  re_node_set_free (&state->non_eps_nodes);\n  re_node_set_free (&state->inveclosure);\n  if (state->entrance_nodes != &state->nodes)\n    {\n      re_node_set_free (state->entrance_nodes);\n      re_free (state->entrance_nodes);\n    }\n  re_node_set_free (&state->nodes);\n  re_free (state->word_trtable);\n  re_free (state->trtable);\n  re_free (state);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_ci_newstate": {
      "start_point": [
        1615,
        18
      ],
      "end_point": [
        1659,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_ci_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    re_hashval_t hash)\n{\n  Idx i;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->entrance_nodes = &newstate->nodes;\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      if (type == CHARACTER && !node->constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n      else if (type == ANCHOR || node->constraint)\n\tnewstate->has_constraint = 1;\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return newstate;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    },
    "create_cd_newstate": {
      "start_point": [
        1665,
        18
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "__attribute_warn_unused_result__\ncreate_cd_newstate (const re_dfa_t *dfa, const re_node_set *nodes,\n\t\t    unsigned int context, re_hashval_t hash)\n{\n  Idx i, nctx_nodes = 0;\n  reg_errcode_t err;\n  re_dfastate_t *newstate;\n\n  newstate = (re_dfastate_t *) calloc (sizeof (re_dfastate_t), 1);\n  if (BE (newstate == NULL, 0))\n    return NULL;\n  err = re_node_set_init_copy (&newstate->nodes, nodes);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      re_free (newstate);\n      return NULL;\n    }\n\n  newstate->context = context;\n  newstate->entrance_nodes = &newstate->nodes;\n\n  for (i = 0 ; i < nodes->nelem ; i++)\n    {\n      re_token_t *node = dfa->nodes + nodes->elems[i];\n      re_token_type_t type = node->type;\n      unsigned int constraint = node->constraint;\n\n      if (type == CHARACTER && !constraint)\n\tcontinue;\n#ifdef RE_ENABLE_I18N\n      newstate->accept_mb |= node->accept_mb;\n#endif /* RE_ENABLE_I18N */\n\n      /* If the state has the halt node, the state is a halt state.  */\n      if (type == END_OF_RE)\n\tnewstate->halt = 1;\n      else if (type == OP_BACK_REF)\n\tnewstate->has_backref = 1;\n\n      if (constraint)\n\t{\n\t  if (newstate->entrance_nodes == &newstate->nodes)\n\t    {\n\t      newstate->entrance_nodes = re_malloc (re_node_set, 1);\n\t      if (BE (newstate->entrance_nodes == NULL, 0))\n\t\t{\n\t\t  free_state (newstate);\n\t\t  return NULL;\n\t\t}\n\t      if (re_node_set_init_copy (newstate->entrance_nodes, nodes)\n\t\t  != REG_NOERROR)\n\t\treturn NULL;\n\t      nctx_nodes = 0;\n\t      newstate->has_constraint = 1;\n\t    }\n\n\t  if (NOT_SATISFY_PREV_CONSTRAINT (constraint,context))\n\t    {\n\t      re_node_set_remove_at (&newstate->nodes, i - nctx_nodes);\n\t      ++nctx_nodes;\n\t    }\n\t}\n    }\n  err = register_state (dfa, newstate, hash);\n  if (BE (err != REG_NOERROR, 0))\n    {\n      free_state (newstate);\n      newstate = NULL;\n    }\n  return  newstate;\n}",
      "lines": 71,
      "depth": 15,
      "decorators": [
        "__attribute_warn_unused_result__"
      ]
    }
  },
  "recutils/recutils-1.7/lib/regex_internal.h": {
    "bitset_set": {
      "start_point": [
        771,
        0
      ],
      "end_point": [
        775,
        1
      ],
      "content": "static void\nbitset_set (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] |= (bitset_word_t) 1 << i % BITSET_WORD_BITS;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_clear": {
      "start_point": [
        777,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "static void\nbitset_clear (bitset_t set, Idx i)\n{\n  set[i / BITSET_WORD_BITS] &= ~ ((bitset_word_t) 1 << i % BITSET_WORD_BITS);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_contain": {
      "start_point": [
        783,
        0
      ],
      "end_point": [
        787,
        1
      ],
      "content": "static bool\nbitset_contain (const bitset_t set, Idx i)\n{\n  return (set[i / BITSET_WORD_BITS] >> i % BITSET_WORD_BITS) & 1;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "bitset_empty": {
      "start_point": [
        789,
        0
      ],
      "end_point": [
        793,
        1
      ],
      "content": "static void\nbitset_empty (bitset_t set)\n{\n  memset (set, '\\0', sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_set_all": {
      "start_point": [
        795,
        0
      ],
      "end_point": [
        802,
        1
      ],
      "content": "static void\nbitset_set_all (bitset_t set)\n{\n  memset (set, -1, sizeof (bitset_word_t) * (SBC_MAX / BITSET_WORD_BITS));\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_copy": {
      "start_point": [
        804,
        0
      ],
      "end_point": [
        808,
        1
      ],
      "content": "static void\nbitset_copy (bitset_t dest, const bitset_t src)\n{\n  memcpy (dest, src, sizeof (bitset_t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bitset_not": {
      "start_point": [
        810,
        0
      ],
      "end_point": [
        820,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_not (bitset_t set)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < SBC_MAX / BITSET_WORD_BITS; ++bitset_i)\n    set[bitset_i] = ~set[bitset_i];\n  if (SBC_MAX % BITSET_WORD_BITS != 0)\n    set[BITSET_WORDS - 1] =\n      ((((bitset_word_t) 1 << SBC_MAX % BITSET_WORD_BITS) - 1)\n       & ~set[BITSET_WORDS - 1]);\n}",
      "lines": 11,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_merge": {
      "start_point": [
        822,
        0
      ],
      "end_point": [
        828,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_merge (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] |= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "bitset_mask": {
      "start_point": [
        830,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void __attribute__ ((unused))\nbitset_mask (bitset_t dest, const bitset_t src)\n{\n  int bitset_i;\n  for (bitset_i = 0; bitset_i < BITSET_WORDS; ++bitset_i)\n    dest[bitset_i] &= src[bitset_i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "__attribute__ ((unused))",
        "__attribute__",
        "(",
        "(unused)",
        "(",
        "unused",
        ")",
        ")"
      ]
    },
    "internal_function": [
      {
        "start_point": [
          841,
          18
        ],
        "end_point": [
          851,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_char_size_at (const re_string_t *pstr, Idx idx)\n{\n  int byte_idx;\n  if (pstr->mb_cur_max == 1)\n    return 1;\n  for (byte_idx = 1; idx + byte_idx < pstr->valid_len; ++byte_idx)\n    if (pstr->wcs[idx + byte_idx] != WEOF)\n      break;\n  return byte_idx;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          854,
          18
        ],
        "end_point": [
          860,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_wchar_at (const re_string_t *pstr, Idx idx)\n{\n  if (pstr->mb_cur_max == 1)\n    return (wint_t) pstr->mbs[idx];\n  return (wint_t) pstr->wcs[idx];\n}",
        "lines": 7,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          864,
          18
        ],
        "end_point": [
          887,
          1
        ],
        "content": "__attribute__ ((pure, unused))\nre_string_elem_size_at (const re_string_t *pstr, Idx idx)\n{\n#  ifdef _LIBC\n  const unsigned char *p, *extra;\n  const int32_t *table, *indirect;\n#   include <locale/weight.h>\n  uint_fast32_t nrules = _NL_CURRENT_WORD (LC_COLLATE, _NL_COLLATE_NRULES);\n\n  if (nrules != 0)\n    {\n      table = (const int32_t *) _NL_CURRENT (LC_COLLATE, _NL_COLLATE_TABLEMB);\n      extra = (const unsigned char *)\n\t_NL_CURRENT (LC_COLLATE, _NL_COLLATE_EXTRAMB);\n      indirect = (const int32_t *) _NL_CURRENT (LC_COLLATE,\n\t\t\t\t\t\t_NL_COLLATE_INDIRECTMB);\n      p = pstr->mbs + idx;\n      findidx (&p, pstr->len - idx);\n      return p - pstr->mbs - idx;\n    }\n  else\n#  endif /* _LIBC */\n    return 1;\n}",
        "lines": 24,
        "depth": 11,
        "decorators": null
      }
    ]
  },
  "recutils/recutils-1.7/lib/rename.c": {
    "rpl_rename": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          262,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  int error;\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_base = last_component (src);\n  char *dst_base = last_component (dst);\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  struct stat src_st;\n  struct stat dst_st;\n\n  /* Filter out dot as last component.  */\n  if (!src_len || !dst_len)\n    {\n      errno = ENOENT;\n      return -1;\n    }\n  if (*src_base == '.')\n    {\n      size_t len = base_len (src_base);\n      if (len == 1 || (len == 2 && src_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n  if (*dst_base == '.')\n    {\n      size_t len = base_len (dst_base);\n      if (len == 1 || (len == 2 && dst_base[1] == '.'))\n        {\n          errno = EINVAL;\n          return -1;\n        }\n    }\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  There are no symlinks on mingw, so stat\n     works instead of lstat.  */\n  src_slash = ISSLASH (src[src_len - 1]);\n  dst_slash = ISSLASH (dst[dst_len - 1]);\n  if (stat (src, &src_st))\n    return -1;\n  if (stat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n      dst_exists = true;\n    }\n\n  /* There are no symlinks, so if a file existed with a trailing\n     slash, it must be a directory, and we don't have to worry about\n     stripping strip trailing slash.  However, mingw refuses to\n     replace an existing empty directory, so we have to help it out.\n     And canonicalize_file_name is not yet ported to mingw; however,\n     for directories, getcwd works as a viable alternative.  Ensure\n     that we can get back to where we started before using it; later\n     attempts to return are fatal.  Note that we can end up losing a\n     directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      char *cwd = getcwd (NULL, 0);\n      char *src_temp;\n      char *dst_temp;\n      if (!cwd || chdir (cwd))\n        return -1;\n      if (IS_ABSOLUTE_FILE_NAME (src))\n        {\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n        }\n      else\n        {\n          src_temp = chdir (src) ? NULL : getcwd (NULL, 0);\n          if (!IS_ABSOLUTE_FILE_NAME (dst) && chdir (cwd))\n            abort ();\n          dst_temp = chdir (dst) ? NULL : getcwd (NULL, 0);\n        }\n      if (chdir (cwd))\n        abort ();\n      free (cwd);\n      if (!src_temp || !dst_temp)\n        {\n          free (src_temp);\n          free (dst_temp);\n          errno = ENOMEM;\n          return -1;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && (ISSLASH (dst_temp[src_len]) || dst_temp[src_len] == '\\0'))\n        {\n          error = dst_temp[src_len];\n          free (src_temp);\n          free (dst_temp);\n          if (error)\n            {\n              errno = EINVAL;\n              return -1;\n            }\n          return 0;\n        }\n      if (rmdir (dst))\n        {\n          error = errno;\n          free (src_temp);\n          free (dst_temp);\n          errno = error;\n          return -1;\n        }\n      free (src_temp);\n      free (dst_temp);\n    }\n\n  /* MoveFileEx works if SRC is a directory without any flags, but\n     fails with MOVEFILE_REPLACE_EXISTING, so try without flags first.\n     Thankfully, MoveFileEx handles hard links correctly, even though\n     rename() does not.  */\n  if (MoveFileEx (src, dst, 0))\n    return 0;\n\n  /* Retry with MOVEFILE_REPLACE_EXISTING if the move failed\n     due to the destination already existing.  */\n  error = GetLastError ();\n  if (error == ERROR_FILE_EXISTS || error == ERROR_ALREADY_EXISTS)\n    {\n      if (MoveFileEx (src, dst, MOVEFILE_REPLACE_EXISTING))\n        return 0;\n\n      error = GetLastError ();\n    }\n\n  switch (error)\n    {\n    case ERROR_FILE_NOT_FOUND:\n    case ERROR_PATH_NOT_FOUND:\n    case ERROR_BAD_PATHNAME:\n    case ERROR_DIRECTORY:\n      errno = ENOENT;\n      break;\n\n    case ERROR_ACCESS_DENIED:\n    case ERROR_SHARING_VIOLATION:\n      errno = EACCES;\n      break;\n\n    case ERROR_OUTOFMEMORY:\n      errno = ENOMEM;\n      break;\n\n    case ERROR_CURRENT_DIRECTORY:\n      errno = EBUSY;\n      break;\n\n    case ERROR_NOT_SAME_DEVICE:\n      errno = EXDEV;\n      break;\n\n    case ERROR_WRITE_PROTECT:\n      errno = EROFS;\n      break;\n\n    case ERROR_WRITE_FAULT:\n    case ERROR_READ_FAULT:\n    case ERROR_GEN_FAILURE:\n      errno = EIO;\n      break;\n\n    case ERROR_HANDLE_DISK_FULL:\n    case ERROR_DISK_FULL:\n    case ERROR_DISK_TOO_FRAGMENTED:\n      errno = ENOSPC;\n      break;\n\n    case ERROR_FILE_EXISTS:\n    case ERROR_ALREADY_EXISTS:\n      errno = EEXIST;\n      break;\n\n    case ERROR_BUFFER_OVERFLOW:\n    case ERROR_FILENAME_EXCED_RANGE:\n      errno = ENAMETOOLONG;\n      break;\n\n    case ERROR_INVALID_NAME:\n    case ERROR_DELETE_PENDING:\n      errno = EPERM;        /* ? */\n      break;\n\n# ifndef ERROR_FILE_TOO_LARGE\n/* This value is documented but not defined in all versions of windows.h.  */\n#  define ERROR_FILE_TOO_LARGE 223\n# endif\n    case ERROR_FILE_TOO_LARGE:\n      errno = EFBIG;\n      break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return -1;\n}",
        "lines": 219,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          278,
          0
        ],
        "end_point": [
          471,
          1
        ],
        "content": "int\nrpl_rename (char const *src, char const *dst)\n{\n  size_t src_len = strlen (src);\n  size_t dst_len = strlen (dst);\n  char *src_temp = (char *) src;\n  char *dst_temp = (char *) dst;\n  bool src_slash;\n  bool dst_slash;\n  bool dst_exists;\n  int ret_val = -1;\n  int rename_errno = ENOTDIR;\n  struct stat src_st;\n  struct stat dst_st;\n\n  if (!src_len || !dst_len)\n    return rename (src, dst); /* Let strace see the ENOENT failure.  */\n\n# if RENAME_DEST_EXISTS_BUG\n  {\n    char *src_base = last_component (src);\n    char *dst_base = last_component (dst);\n    if (*src_base == '.')\n      {\n        size_t len = base_len (src_base);\n        if (len == 1 || (len == 2 && src_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n    if (*dst_base == '.')\n      {\n        size_t len = base_len (dst_base);\n        if (len == 1 || (len == 2 && dst_base[1] == '.'))\n          {\n            errno = EINVAL;\n            return -1;\n          }\n      }\n  }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  src_slash = src[src_len - 1] == '/';\n  dst_slash = dst[dst_len - 1] == '/';\n\n# if !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG\n  /* If there are no trailing slashes, then trust the native\n     implementation unless we also suspect issues with hard link\n     detection or file/directory conflicts.  */\n  if (!src_slash && !dst_slash)\n    return rename (src, dst);\n# endif /* !RENAME_HARD_LINK_BUG && !RENAME_DEST_EXISTS_BUG */\n\n  /* Presence of a trailing slash requires directory semantics.  If\n     the source does not exist, or if the destination cannot be turned\n     into a directory, give up now.  Otherwise, strip trailing slashes\n     before calling rename.  */\n  if (lstat (src, &src_st))\n    return -1;\n  if (lstat (dst, &dst_st))\n    {\n      if (errno != ENOENT || (!S_ISDIR (src_st.st_mode) && dst_slash))\n        return -1;\n      dst_exists = false;\n    }\n  else\n    {\n      if (S_ISDIR (dst_st.st_mode) != S_ISDIR (src_st.st_mode))\n        {\n          errno = S_ISDIR (dst_st.st_mode) ? EISDIR : ENOTDIR;\n          return -1;\n        }\n# if RENAME_HARD_LINK_BUG\n      if (SAME_INODE (src_st, dst_st))\n        return 0;\n# endif /* RENAME_HARD_LINK_BUG */\n      dst_exists = true;\n    }\n\n# if (RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG        \\\n      || RENAME_HARD_LINK_BUG)\n  /* If the only bug was that a trailing slash was allowed on a\n     non-existing file destination, as in Solaris 10, then we've\n     already covered that situation.  But if there is any problem with\n     a trailing slash on an existing source or destination, as in\n     Solaris 9, or if a directory can overwrite a symlink, as on\n     Cygwin 1.5, or if directories cannot be created with trailing\n     slash, as on NetBSD 1.6, then we must strip the offending slash\n     and check that we have not encountered a symlink instead of a\n     directory.\n\n     Stripping a trailing slash interferes with POSIX semantics, where\n     rename behavior on a symlink with a trailing slash operates on\n     the corresponding target directory.  We prefer the GNU semantics\n     of rejecting any use of a symlink with trailing slash, but do not\n     enforce them, since Solaris 10 is able to obey POSIX semantics\n     and there might be clients expecting it, as counter-intuitive as\n     those semantics are.\n\n     Technically, we could also follow the POSIX behavior by chasing a\n     readlink trail, but that is harder to implement.  */\n  if (src_slash)\n    {\n      src_temp = strdup (src);\n      if (!src_temp)\n        {\n          /* Rather than rely on strdup-posix, we set errno ourselves.  */\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (src_temp);\n      if (lstat (src_temp, &src_st))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n      if (S_ISLNK (src_st.st_mode))\n        goto out;\n    }\n  if (dst_slash)\n    {\n      dst_temp = strdup (dst);\n      if (!dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      strip_trailing_slashes (dst_temp);\n      if (lstat (dst_temp, &dst_st))\n        {\n          if (errno != ENOENT)\n            {\n              rename_errno = errno;\n              goto out;\n            }\n        }\n      else if (S_ISLNK (dst_st.st_mode))\n        goto out;\n    }\n# endif /* RENAME_TRAILING_SLASH_SOURCE_BUG || RENAME_DEST_EXISTS_BUG\n           || RENAME_HARD_LINK_BUG */\n\n# if RENAME_DEST_EXISTS_BUG\n  /* Cygwin 1.5 sometimes behaves oddly when moving a non-empty\n     directory on top of an empty one (the old directory name can\n     reappear if the new directory tree is removed).  Work around this\n     by removing the target first, but don't remove the target if it\n     is a subdirectory of the source.  Note that we can end up losing\n     a directory if rename then fails, but it was empty, so not much\n     damage was done.  */\n  if (dst_exists && S_ISDIR (dst_st.st_mode))\n    {\n      if (src_st.st_dev != dst_st.st_dev)\n        {\n          rename_errno = EXDEV;\n          goto out;\n        }\n      if (src_temp != src)\n        free (src_temp);\n      src_temp = canonicalize_file_name (src);\n      if (dst_temp != dst)\n        free (dst_temp);\n      dst_temp = canonicalize_file_name (dst);\n      if (!src_temp || !dst_temp)\n        {\n          rename_errno = ENOMEM;\n          goto out;\n        }\n      src_len = strlen (src_temp);\n      if (strncmp (src_temp, dst_temp, src_len) == 0\n          && dst_temp[src_len] == '/')\n        {\n          rename_errno = EINVAL;\n          goto out;\n        }\n      if (rmdir (dst))\n        {\n          rename_errno = errno;\n          goto out;\n        }\n    }\n# endif /* RENAME_DEST_EXISTS_BUG */\n\n  ret_val = rename (src_temp, dst_temp);\n  rename_errno = errno;\n out:\n  if (src_temp != src)\n    free (src_temp);\n  if (dst_temp != dst)\n    free (dst_temp);\n  errno = rename_errno;\n  return ret_val;\n}",
        "lines": 194,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/lib/rmdir.c": {
    "rpl_rmdir": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "int\nrpl_rmdir (char const *dir)\n{\n  /* Work around cygwin 1.5.x bug where rmdir(\"dir/./\") succeeds.  */\n  size_t len = strlen (dir);\n  int result;\n  while (len && ISSLASH (dir[len - 1]))\n    len--;\n  if (len && dir[len - 1] == '.' && (1 == len || ISSLASH (dir[len - 2])))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  result = rmdir (dir);\n  /* Work around mingw bug, where rmdir(\"file/\") fails with EINVAL\n     instead of ENOTDIR.  We've already filtered out trailing ., the\n     only reason allowed by POSIX for EINVAL.  */\n  if (result == -1 && errno == EINVAL)\n    errno = ENOTDIR;\n  return result;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/root-uid.h": {},
  "recutils/recutils-1.7/lib/same-inode.h": {},
  "recutils/recutils-1.7/lib/sched.in.h": {},
  "recutils/recutils-1.7/lib/se-context.c": {},
  "recutils/recutils-1.7/lib/se-context.in.h": {
    "context_new": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        17,
        32
      ],
      "content": "SE_CONTEXT_INLINE context_t context_new (char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "context_t",
        "context_t"
      ]
    },
    "context_str": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        19,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_str (context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_str (context_t con _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_free": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        20,
        73
      ],
      "content": "SE_CONTEXT_INLINE void context_free (context_t c _GL_UNUSED_PARAMETER) {}",
      "lines": 1,
      "depth": 6,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "void",
        "void"
      ]
    },
    "context_user_set": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        24,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_user_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_role_set": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        27,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_role_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_range_set": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        30,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_range_set (context_t sc _GL_UNUSED_PARAMETER,\n                                         char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_set": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        33,
        33
      ],
      "content": "SE_CONTEXT_INLINE int context_type_set (context_t sc _GL_UNUSED_PARAMETER,\n                                        char const *s _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "int",
        "int"
      ]
    },
    "context_type_get": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        35,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_type_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_type_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_range_get": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        37,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_range_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_range_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_role_get": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        39,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_role_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_role_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    },
    "context_user_get": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        41,
        41
      ],
      "content": "SE_CONTEXT_INLINE char *context_user_get (context_t sc _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return (void *) 0; }",
      "lines": 2,
      "depth": 7,
      "decorators": [
        "SE_CONTEXT_INLINE",
        "char",
        "char",
        "*context_user_get (context_t sc _GL_UNUSED_PARAMETER)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/se-selinux.c": {},
  "recutils/recutils-1.7/lib/se-selinux.in.h": {
    "getcon": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        51,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetcon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "freecon": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        53,
        56
      ],
      "content": "SE_SELINUX_INLINE void\nfreecon (security_context_t con _GL_UNUSED_PARAMETER) {}",
      "lines": 2,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "void",
        "void"
      ]
    },
    "getfscreatecon": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        57,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfscreatecon (security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfscreatecon": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        60,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfscreatecon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "matchpathcon": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon (char const *file _GL_UNUSED_PARAMETER,\n              mode_t m _GL_UNUSED_PARAMETER,\n  security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "getfilecon": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        69,
        33
      ],
      "content": "SE_SELINUX_INLINE int\ngetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lgetfilecon": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        73,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlgetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fgetfilecon": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        76,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfgetfilecon (int fd, security_context_t *con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setfilecon": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        80,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n            security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "lsetfilecon": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        84,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nlsetfilecon (char const *file _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "fsetfilecon": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        88,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nfsetfilecon (int fd _GL_UNUSED_PARAMETER,\n             security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        92,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_check_context_raw": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        95,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_check_context_raw (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "setexeccon": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        98,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsetexeccon (security_context_t con _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "security_compute_create": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        104,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nsecurity_compute_create (security_context_t scon _GL_UNUSED_PARAMETER,\n                         security_context_t tcon _GL_UNUSED_PARAMETER,\n                         security_class_t tclass _GL_UNUSED_PARAMETER,\n                         security_context_t *newcon _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    },
    "string_to_security_class": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        107,
        32
      ],
      "content": "SE_SELINUX_INLINE security_class_t\nstring_to_security_class (char const *name)\n  { errno = ENOTSUP; return 0; }",
      "lines": 3,
      "depth": 6,
      "decorators": [
        "SE_SELINUX_INLINE",
        "security_class_t",
        "security_class_t"
      ]
    },
    "matchpathcon_init_prefix": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        111,
        33
      ],
      "content": "SE_SELINUX_INLINE int\nmatchpathcon_init_prefix (char const *path _GL_UNUSED_PARAMETER,\n                          char const *prefix _GL_UNUSED_PARAMETER)\n  { errno = ENOTSUP; return -1; }",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "SE_SELINUX_INLINE",
        "int",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/secure_getenv.c": {
    "secure_getenv": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "char *\nsecure_getenv (char const *name)\n{\n#if HAVE___SECURE_GETENV\n  return __secure_getenv (name);\n#else\n  if (issetugid ())\n    return 0;\n  return getenv (name);\n#endif\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsecure_getenv (char const *name)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/set-acl.c": {
    "set_acl": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nset_acl (char const *name, int desc, mode_t mode)\n{\n  int ret = qset_acl (name, desc, mode);\n  if (ret != 0)\n    error (0, errno, _(\"setting permissions for %s\"), quote (name));\n  return ret;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/setenv.c": {
    "__add_to_environ": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\n__add_to_environ (const char *name, const char *value, const char *combined,\n                  int replace)\n{\n  char **ep;\n  size_t size;\n  const size_t namelen = strlen (name);\n  const size_t vallen = value != NULL ? strlen (value) + 1 : 0;\n\n  LOCK;\n\n  /* We have to get the pointer now that we have the lock and not earlier\n     since another thread might have created a new environment.  */\n  ep = __environ;\n\n  size = 0;\n  if (ep != NULL)\n    {\n      for (; *ep != NULL; ++ep)\n        if (!strncmp (*ep, name, namelen) && (*ep)[namelen] == '=')\n          break;\n        else\n          ++size;\n    }\n\n  if (ep == NULL || *ep == NULL)\n    {\n      char **new_environ;\n#ifdef USE_TSEARCH\n      char *new_value;\n#endif\n\n      /* We allocated this space; we can extend it.  */\n      new_environ =\n        (char **) (last_environ == NULL\n                   ? malloc ((size + 2) * sizeof (char *))\n                   : realloc (last_environ, (size + 2) * sizeof (char *)));\n      if (new_environ == NULL)\n        {\n          /* It's easier to set errno to ENOMEM than to rely on the\n             'malloc-posix' and 'realloc-posix' gnulib modules.  */\n          __set_errno (ENOMEM);\n          UNLOCK;\n          return -1;\n        }\n\n      /* If the whole entry is given add it.  */\n      if (combined != NULL)\n        /* We must not add the string to the search tree since it belongs\n           to the user.  */\n        new_environ[size] = (char *) combined;\n      else\n        {\n          /* See whether the value is already known.  */\n#ifdef USE_TSEARCH\n# ifdef _LIBC\n          new_value = (char *) alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = (char *) malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          new_environ[size] = KNOWN_VALUE (new_value);\n          if (new_environ[size] == NULL)\n#endif\n            {\n              new_environ[size] = (char *) malloc (namelen + 1 + vallen);\n              if (new_environ[size] == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (new_environ[size], new_value, namelen + 1 + vallen);\n#else\n              memcpy (new_environ[size], name, namelen);\n              new_environ[size][namelen] = '=';\n              memcpy (&new_environ[size][namelen + 1], value, vallen);\n#endif\n              /* And save the value now.  We cannot do this when we remove\n                 the string since then we cannot decide whether it is a\n                 user string or not.  */\n              STORE_VALUE (new_environ[size]);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      if (__environ != last_environ)\n        memcpy ((char *) new_environ, (char *) __environ,\n                size * sizeof (char *));\n\n      new_environ[size + 1] = NULL;\n\n      last_environ = __environ = new_environ;\n    }\n  else if (replace)\n    {\n      char *np;\n\n      /* Use the user string if given.  */\n      if (combined != NULL)\n        np = (char *) combined;\n      else\n        {\n#ifdef USE_TSEARCH\n          char *new_value;\n# ifdef _LIBC\n          new_value = alloca (namelen + 1 + vallen);\n          __mempcpy (__mempcpy (__mempcpy (new_value, name, namelen), \"=\", 1),\n                     value, vallen);\n# else\n          new_value = malloca (namelen + 1 + vallen);\n          if (new_value == NULL)\n            {\n              __set_errno (ENOMEM);\n              UNLOCK;\n              return -1;\n            }\n          memcpy (new_value, name, namelen);\n          new_value[namelen] = '=';\n          memcpy (&new_value[namelen + 1], value, vallen);\n# endif\n\n          np = KNOWN_VALUE (new_value);\n          if (np == NULL)\n#endif\n            {\n              np = (char *) malloc (namelen + 1 + vallen);\n              if (np == NULL)\n                {\n#if defined USE_TSEARCH && !defined _LIBC\n                  freea (new_value);\n#endif\n                  __set_errno (ENOMEM);\n                  UNLOCK;\n                  return -1;\n                }\n\n#ifdef USE_TSEARCH\n              memcpy (np, new_value, namelen + 1 + vallen);\n#else\n              memcpy (np, name, namelen);\n              np[namelen] = '=';\n              memcpy (&np[namelen + 1], value, vallen);\n#endif\n              /* And remember the value.  */\n              STORE_VALUE (np);\n            }\n#if defined USE_TSEARCH && !defined _LIBC\n          freea (new_value);\n#endif\n        }\n\n      *ep = np;\n    }\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 177,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "setenv": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\nsetenv (const char *name, const char *value, int replace)\n{\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "clearenv": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "int\nclearenv (void)\n{\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "free_mem": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "static void\nfree_mem (void)\n{\n  /* Remove all traces.  */\n  clearenv ();\n\n  /* Now remove the search tree.  */\n  __tdestroy (known_values, free);\n  known_values = NULL;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rpl_setenv": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "int\nrpl_setenv (const char *name, const char *value, int replace)\n{\n  int result;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  /* Call the real setenv even if replace is 0, in case implementation\n     has underlying data to update, such as when environ changes.  */\n  result = setenv (name, value, replace);\n  if (result == 0 && replace && *value == '=')\n    {\n      char *tmp = getenv (name);\n      if (!STREQ (tmp, value))\n        {\n          int saved_errno;\n          size_t len = strlen (value);\n          tmp = malloca (len + 2);\n          /* Since leading '=' is eaten, double it up.  */\n          *tmp = '=';\n          memcpy (tmp + 1, value, len + 1);\n          result = setenv (name, tmp, replace);\n          saved_errno = errno;\n          freea (tmp);\n          errno = saved_errno;\n        }\n    }\n  return result;\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/sig-handler.c": {},
  "recutils/recutils-1.7/lib/sig-handler.h": {
    "get_handler": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "SIG_HANDLER_INLINE sa_handler_t\nget_handler (struct sigaction const *a)\n{\n#ifdef SA_SIGINFO\n  /* POSIX says that special values like SIG_IGN can only occur when\n     action.sa_flags does not contain SA_SIGINFO.  But in Linux 2.4,\n     for example, sa_sigaction and sa_handler are aliases and a signal\n     is ignored if sa_sigaction (after casting) equals SIG_IGN.  So\n     use (and cast) sa_sigaction in that case.  */\n  if (a->sa_flags & SA_SIGINFO)\n    return (sa_handler_t) a->sa_sigaction;\n#endif\n  return a->sa_handler;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "SIG_HANDLER_INLINE",
        "sa_handler_t",
        "sa_handler_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/sigaction.c": {
    "sigaction_handler": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "static void\nsigaction_handler (int sig)\n{\n  handler_t handler;\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno = errno;\n  if (sig < 0 || NSIG <= sig || !action_array[sig].sa_handler)\n    {\n      /* Unexpected situation; be careful to avoid recursive abort.  */\n      if (sig == SIGABRT)\n        signal (SIGABRT, SIG_DFL);\n      abort ();\n    }\n\n  /* Reinstall the signal handler when required; otherwise update the\n     bookkeeping so that the user's handler may call sigaction and get\n     accurate results.  We know the signal isn't currently blocked, or\n     we wouldn't be in its handler, therefore we know that we are not\n     interrupting a sigaction() call.  There is a race where any\n     asynchronous instance of the same signal occurring before we\n     reinstall the handler will trigger the default handler; oh\n     well.  */\n  handler = action_array[sig].sa_handler;\n  if ((action_array[sig].sa_flags & SA_RESETHAND) == 0)\n    signal (sig, sigaction_handler);\n  else\n    action_array[sig].sa_handler = NULL;\n\n  /* Block appropriate signals.  */\n  mask = action_array[sig].sa_mask;\n  if ((action_array[sig].sa_flags & SA_NODEFER) == 0)\n    sigaddset (&mask, sig);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n\n  /* Invoke the user's handler, then restore prior mask.  */\n  errno = saved_errno;\n  handler (sig);\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n}",
      "lines": 42,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigaction": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        203,
        1
      ],
      "content": "int\nsigaction (int sig, const struct sigaction *restrict act,\n           struct sigaction *restrict oact)\n{\n  sigset_t mask;\n  sigset_t oldmask;\n  int saved_errno;\n\n  if (sig < 0 || NSIG <= sig || sig == SIGKILL || sig == SIGSTOP\n      || (act && act->sa_handler == SIG_ERR))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n#ifdef SIGABRT_COMPAT\n  if (sig == SIGABRT_COMPAT)\n    sig = SIGABRT;\n#endif\n\n  /* POSIX requires sigaction() to be async-signal-safe.  In other\n     words, if an asynchronous signal can occur while we are anywhere\n     inside this function, the user's handler could then call\n     sigaction() recursively and expect consistent results.  We meet\n     this rule by using sigprocmask to block all signals before\n     modifying any data structure that could be read from a signal\n     handler; this works since we know that the gnulib sigprocmask\n     replacement does not try to use sigaction() from its handler.  */\n  if (!act && !oact)\n    return 0;\n  sigfillset (&mask);\n  sigprocmask (SIG_BLOCK, &mask, &oldmask);\n  if (oact)\n    {\n      if (action_array[sig].sa_handler)\n        *oact = action_array[sig];\n      else\n        {\n          /* Safe to change the handler at will here, since all\n             signals are currently blocked.  */\n          oact->sa_handler = signal (sig, SIG_DFL);\n          if (oact->sa_handler == SIG_ERR)\n            goto failure;\n          signal (sig, oact->sa_handler);\n          oact->sa_flags = SA_RESETHAND | SA_NODEFER;\n          sigemptyset (&oact->sa_mask);\n        }\n    }\n\n  if (act)\n    {\n      /* Safe to install the handler before updating action_array,\n         since all signals are currently blocked.  */\n      if (act->sa_handler == SIG_DFL || act->sa_handler == SIG_IGN)\n        {\n          if (signal (sig, act->sa_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig].sa_handler = NULL;\n        }\n      else\n        {\n          if (signal (sig, sigaction_handler) == SIG_ERR)\n            goto failure;\n          action_array[sig] = *act;\n        }\n    }\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  return 0;\n\n failure:\n  saved_errno = errno;\n  sigprocmask (SIG_SETMASK, &oldmask, NULL);\n  errno = saved_errno;\n  return -1;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/signal.in.h": {},
  "recutils/recutils-1.7/lib/signbitd.c": {
    "gl_signbitd": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitd (double arg)\n{\n#if defined DBL_SIGNBIT_WORD && defined DBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[DBL_SIGNBIT_WORD] >> DBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGN_IN_LIBC\n  return copysign (1.0, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnand (arg))\n    return 0;\n  if (arg < 0.0)\n    return 1;\n  else if (arg == 0.0)\n    {\n      /* Distinguish 0.0 and -0.0.  */\n      static double plus_zero = 0.0;\n      double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_DBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/signbitf.c": {
    "gl_signbitf": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitf (float arg)\n{\n#if defined FLT_SIGNBIT_WORD && defined FLT_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (float) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { float value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[FLT_SIGNBIT_WORD] >> FLT_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNF_IN_LIBC\n  return copysignf (1.0f, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanf (arg))\n    return 0;\n  if (arg < 0.0f)\n    return 1;\n  else if (arg == 0.0f)\n    {\n      /* Distinguish 0.0f and -0.0f.  */\n      static float plus_zero = 0.0f;\n      float arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_FLT) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/signbitl.c": {
    "gl_signbitl": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\ngl_signbitl (long double arg)\n{\n#if defined LDBL_SIGNBIT_WORD && defined LDBL_SIGNBIT_BIT\n  /* The use of a union to extract the bits of the representation of a\n     'long double' is safe in practice, despite of the \"aliasing rules\" of\n     C99, because the GCC docs say\n       \"Even with '-fstrict-aliasing', type-punning is allowed, provided the\n        memory is accessed through the union type.\"\n     and similarly for other compilers.  */\n# define NWORDS \\\n    ((sizeof (long double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n  union { long double value; unsigned int word[NWORDS]; } m;\n  m.value = arg;\n  return (m.word[LDBL_SIGNBIT_WORD] >> LDBL_SIGNBIT_BIT) & 1;\n#elif HAVE_COPYSIGNL_IN_LIBC\n  return copysignl (1.0L, arg) < 0;\n#else\n  /* This does not do the right thing for NaN, but this is irrelevant for\n     most use cases.  */\n  if (isnanl (arg))\n    return 0;\n  if (arg < 0.0L)\n    return 1;\n  else if (arg == 0.0L)\n    {\n      /* Distinguish 0.0L and -0.0L.  */\n      static long double plus_zero = 0.0L;\n      long double arg_mem = arg;\n      return (memcmp (&plus_zero, &arg_mem, SIZEOF_LDBL) != 0);\n    }\n  else\n    return 0;\n#endif\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/sigprocmask.c": {
    "signal_nothrow": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        73,
        5
      ],
      "content": "static handler_t\nsignal_nothrow (int sig, handler_t handler)\n{\n  handler_t result;\n\n  TRY_MSVC_INVAL\n    {\n      result = signal (sig, handler);\n    }",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "ext_signal": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static handler_t\next_signal (int sig, handler_t handler)\n{\n  switch (sig)\n    {\n    case SIGPIPE:\n      {\n        handler_t old_handler = SIGPIPE_handler;\n        SIGPIPE_handler = handler;\n        return old_handler;\n      }\n    default: /* System defined signal */\n      return signal (sig, handler);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "handler_t"
      ]
    },
    "sigismember": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nsigismember (const sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      return (*set >> sig) & 1;\n    }\n  else\n    return 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigemptyset": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nsigemptyset (sigset_t *set)\n{\n  *set = 0;\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sigaddset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nsigaddset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set |= 1U << sig;\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sigdelset": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "int\nsigdelset (sigset_t *set, int sig)\n{\n  if (sig >= 0 && sig < NSIG)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      *set &= ~(1U << sig);\n      return 0;\n    }\n  else\n    {\n      errno = EINVAL;\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sigfillset": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "int\nsigfillset (sigset_t *set)\n{\n  *set = ((2U << (NSIG - 1)) - 1) & ~ SIGABRT_COMPAT_MASK;\n  return 0;\n}",
      "lines": 6,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "blocked_handler": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nblocked_handler (int sig)\n{\n  /* Reinstall the handler, in case the signal occurs multiple times\n     while blocked.  There is an inherent race where an asynchronous\n     signal in between when the kernel uninstalled the handler and\n     when we reinstall it will trigger the default handler; oh\n     well.  */\n  signal (sig, blocked_handler);\n  if (sig >= 0 && sig < NSIG)\n    pending_array[sig] = 1;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sigpending": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "int\nsigpending (sigset_t *set)\n{\n  sigset_t pending = 0;\n  int sig;\n\n  for (sig = 0; sig < NSIG; sig++)\n    if (pending_array[sig])\n      pending |= 1U << sig;\n  *set = pending;\n  return 0;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sigprocmask": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nsigprocmask (int operation, const sigset_t *set, sigset_t *old_set)\n{\n  if (old_set != NULL)\n    *old_set = blocked_set;\n\n  if (set != NULL)\n    {\n      sigset_t new_blocked_set;\n      sigset_t to_unblock;\n      sigset_t to_block;\n\n      switch (operation)\n        {\n        case SIG_BLOCK:\n          new_blocked_set = blocked_set | *set;\n          break;\n        case SIG_SETMASK:\n          new_blocked_set = *set;\n          break;\n        case SIG_UNBLOCK:\n          new_blocked_set = blocked_set & ~*set;\n          break;\n        default:\n          errno = EINVAL;\n          return -1;\n        }\n      to_unblock = blocked_set & ~new_blocked_set;\n      to_block = new_blocked_set & ~blocked_set;\n\n      if (to_block != 0)\n        {\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_block >> sig) & 1)\n              {\n                pending_array[sig] = 0;\n                if ((old_handlers[sig] = signal (sig, blocked_handler)) != SIG_ERR)\n                  blocked_set |= 1U << sig;\n              }\n        }\n\n      if (to_unblock != 0)\n        {\n          sig_atomic_t received[NSIG];\n          int sig;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if ((to_unblock >> sig) & 1)\n              {\n                if (signal (sig, old_handlers[sig]) != blocked_handler)\n                  /* The application changed a signal handler while the signal\n                     was blocked, bypassing our rpl_signal replacement.\n                     We don't support this.  */\n                  abort ();\n                received[sig] = pending_array[sig];\n                blocked_set &= ~(1U << sig);\n                pending_array[sig] = 0;\n              }\n            else\n              received[sig] = 0;\n\n          for (sig = 0; sig < NSIG; sig++)\n            if (received[sig])\n              raise (sig);\n        }\n    }\n  return 0;\n}",
      "lines": 70,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "rpl_signal": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "handler_t\nrpl_signal (int sig, handler_t handler)\n{\n  /* We must provide a wrapper, so that a user can query what handler\n     they installed even if that signal is currently blocked.  */\n  if (sig >= 0 && sig < NSIG && sig != SIGKILL && sig != SIGSTOP\n      && handler != SIG_ERR)\n    {\n      #ifdef SIGABRT_COMPAT\n      if (sig == SIGABRT_COMPAT)\n        sig = SIGABRT;\n      #endif\n\n      if (blocked_set & (1U << sig))\n        {\n          /* POSIX states that sigprocmask and signal are both\n             async-signal-safe.  This is not true of our\n             implementation - there is a slight data race where an\n             asynchronous interrupt on signal A can occur after we\n             install blocked_handler but before we have updated\n             old_handlers for signal B, such that handler A can see\n             stale information if it calls signal(B).  Oh well -\n             signal handlers really shouldn't try to manipulate the\n             installed handlers of unrelated signals.  */\n          handler_t result = old_handlers[sig];\n          old_handlers[sig] = handler;\n          return result;\n        }\n      else\n        return signal (sig, handler);\n    }\n  else\n    {\n      errno = EINVAL;\n      return SIG_ERR;\n    }\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "handler_t"
      ]
    },
    "_gl_raise_SIGPIPE": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "int\n_gl_raise_SIGPIPE (void)\n{\n  if (blocked_set & (1U << SIGPIPE))\n    pending_array[SIGPIPE] = 1;\n  else\n    {\n      handler_t handler = SIGPIPE_handler;\n      if (handler == SIG_DFL)\n        exit (128 + SIGPIPE);\n      else if (handler != SIG_IGN)\n        (*handler) (SIGPIPE);\n    }\n  return 0;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/size_max.h": {},
  "recutils/recutils-1.7/lib/spawn.in.h": {},
  "recutils/recutils-1.7/lib/spawnattr_destroy.c": {
    "posix_spawnattr_destroy": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "int\nposix_spawnattr_destroy (posix_spawnattr_t *attr)\n{\n  /* Nothing to do in the moment.  */\n  return 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawnattr_init.c": {
    "posix_spawnattr_init": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_init (posix_spawnattr_t *attr)\n{\n  /* All elements have to be initialized to the default values which\n     is generally zero.  */\n  memset (attr, '\\0', sizeof (*attr));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawnattr_setflags.c": {
    "posix_spawnattr_setflags": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "int\nposix_spawnattr_setflags (posix_spawnattr_t *attr, short int flags)\n{\n  /* Check no invalid bits are set.  */\n  if (flags & ~ALL_FLAGS)\n    return EINVAL;\n\n  /* Store the flag word.  */\n  attr->_flags = flags;\n\n  return 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawnattr_setsigmask.c": {
    "posix_spawnattr_setsigmask": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnattr_setsigmask (posix_spawnattr_t *attr,\n                            const sigset_t *sigmask)\n{\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (&attr->_ss, sigmask, sizeof (sigset_t));\n\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawni.c": {
    "__spawni": [
      {
        "start_point": [
          94,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  /* Not yet implemented.  */\n  return ENOSYS;\n}",
        "lines": 9,
        "depth": 7,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          137,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\n__spawni (pid_t *pid, const char *file,\n          const posix_spawn_file_actions_t *file_actions,\n          const posix_spawnattr_t *attrp, char *const argv[],\n          char *const envp[], int use_path)\n{\n  pid_t new_pid;\n  char *path, *p, *name;\n  size_t len;\n  size_t pathlen;\n\n  /* Do this once.  */\n  short int flags = attrp == NULL ? 0 : attrp->_flags;\n\n  /* Avoid gcc warning\n       \"variable 'flags' might be clobbered by 'longjmp' or 'vfork'\"  */\n  (void) &flags;\n\n  /* Generate the new process.  */\n#if HAVE_VFORK\n  if ((flags & POSIX_SPAWN_USEVFORK) != 0\n      /* If no major work is done, allow using vfork.  Note that we\n         might perform the path searching.  But this would be done by\n         a call to execvp(), too, and such a call must be OK according\n         to POSIX.  */\n      || ((flags & (POSIX_SPAWN_SETSIGMASK | POSIX_SPAWN_SETSIGDEF\n                    | POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER\n                    | POSIX_SPAWN_SETPGROUP | POSIX_SPAWN_RESETIDS)) == 0\n          && file_actions == NULL))\n    new_pid = vfork ();\n  else\n#endif\n    new_pid = fork ();\n\n  if (new_pid != 0)\n    {\n      if (new_pid < 0)\n        return errno;\n\n      /* The call was successful.  Store the PID if necessary.  */\n      if (pid != NULL)\n        *pid = new_pid;\n\n      return 0;\n    }\n\n  /* Set signal mask.  */\n  if ((flags & POSIX_SPAWN_SETSIGMASK) != 0\n      && sigprocmask (SIG_SETMASK, &attrp->_ss, NULL) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set signal default action.  */\n  if ((flags & POSIX_SPAWN_SETSIGDEF) != 0)\n    {\n      /* We have to iterate over all signals.  This could possibly be\n         done better but it requires system specific solutions since\n         the sigset_t data type can be very different on different\n         architectures.  */\n      int sig;\n      struct sigaction sa;\n\n      memset (&sa, '\\0', sizeof (sa));\n      sa.sa_handler = SIG_DFL;\n\n      for (sig = 1; sig <= NSIG; ++sig)\n        if (sigismember (&attrp->_sd, sig) != 0\n            && sigaction (sig, &sa, NULL) != 0)\n          _exit (SPAWN_ERROR);\n\n    }\n\n#if (_LIBC ? defined _POSIX_PRIORITY_SCHEDULING : HAVE_SCHED_SETPARAM && HAVE_SCHED_SETSCHEDULER)\n  /* Set the scheduling algorithm and parameters.  */\n  if ((flags & (POSIX_SPAWN_SETSCHEDPARAM | POSIX_SPAWN_SETSCHEDULER))\n      == POSIX_SPAWN_SETSCHEDPARAM)\n    {\n      if (sched_setparam (0, &attrp->_sp) == -1)\n        _exit (SPAWN_ERROR);\n    }\n  else if ((flags & POSIX_SPAWN_SETSCHEDULER) != 0)\n    {\n      if (sched_setscheduler (0, attrp->_policy,\n                              (flags & POSIX_SPAWN_SETSCHEDPARAM) != 0\n                              ? &attrp->_sp : NULL) == -1)\n        _exit (SPAWN_ERROR);\n    }\n#endif\n\n  /* Set the process group ID.  */\n  if ((flags & POSIX_SPAWN_SETPGROUP) != 0\n      && setpgid (0, attrp->_pgrp) != 0)\n    _exit (SPAWN_ERROR);\n\n  /* Set the effective user and group IDs.  */\n  if ((flags & POSIX_SPAWN_RESETIDS) != 0\n      && (local_seteuid (getuid ()) != 0\n          || local_setegid (getgid ()) != 0))\n    _exit (SPAWN_ERROR);\n\n  /* Execute the file actions.  */\n  if (file_actions != NULL)\n    {\n      int cnt;\n\n      for (cnt = 0; cnt < file_actions->_used; ++cnt)\n        {\n          struct __spawn_action *action = &file_actions->_actions[cnt];\n\n          switch (action->tag)\n            {\n            case spawn_do_close:\n              if (close_not_cancel (action->action.close_action.fd) != 0)\n                /* Signal the error.  */\n                _exit (SPAWN_ERROR);\n              break;\n\n            case spawn_do_open:\n              {\n                int new_fd = open_not_cancel (action->action.open_action.path,\n                                              action->action.open_action.oflag\n                                              | O_LARGEFILE,\n                                              action->action.open_action.mode);\n\n                if (new_fd == -1)\n                  /* The 'open' call failed.  */\n                  _exit (SPAWN_ERROR);\n\n                /* Make sure the desired file descriptor is used.  */\n                if (new_fd != action->action.open_action.fd)\n                  {\n                    if (dup2 (new_fd, action->action.open_action.fd)\n                        != action->action.open_action.fd)\n                      /* The 'dup2' call failed.  */\n                      _exit (SPAWN_ERROR);\n\n                    if (close_not_cancel (new_fd) != 0)\n                      /* The 'close' call failed.  */\n                      _exit (SPAWN_ERROR);\n                  }\n              }\n              break;\n\n            case spawn_do_dup2:\n              if (dup2 (action->action.dup2_action.fd,\n                        action->action.dup2_action.newfd)\n                  != action->action.dup2_action.newfd)\n                /* The 'dup2' call failed.  */\n                _exit (SPAWN_ERROR);\n              break;\n            }\n        }\n    }\n\n  if (! use_path || strchr (file, '/') != NULL)\n    {\n      /* The FILE parameter is actually a path.  */\n      execve (file, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (file, argv, envp);\n\n      /* Oh, oh.  'execve' returns.  This is bad.  */\n      _exit (SPAWN_ERROR);\n    }\n\n  /* We have to search for FILE on the path.  */\n  path = getenv (\"PATH\");\n  if (path == NULL)\n    {\n#if HAVE_CONFSTR\n      /* There is no 'PATH' in the environment.\n         The default search path is the current directory\n         followed by the path 'confstr' returns for '_CS_PATH'.  */\n      len = confstr (_CS_PATH, (char *) NULL, 0);\n      path = (char *) alloca (1 + len);\n      path[0] = ':';\n      (void) confstr (_CS_PATH, path + 1, len);\n#else\n      /* Pretend that the PATH contains only the current directory.  */\n      path = \"\";\n#endif\n    }\n\n  len = strlen (file) + 1;\n  pathlen = strlen (path);\n  name = alloca (pathlen + len + 1);\n  /* Copy the file name at the top.  */\n  name = (char *) memcpy (name + pathlen + 1, file, len);\n  /* And add the slash.  */\n  *--name = '/';\n\n  p = path;\n  do\n    {\n      char *startp;\n\n      path = p;\n      p = strchrnul (path, ':');\n\n      if (p == path)\n        /* Two adjacent colons, or a colon at the beginning or the end\n           of 'PATH' means to search the current directory.  */\n        startp = name + 1;\n      else\n        startp = (char *) memcpy (name - (p - path), path, p - path);\n\n      /* Try to execute this name.  If it works, execv will not return.  */\n      execve (startp, argv, envp);\n\n      if (errno == ENOEXEC)\n        script_execute (startp, argv, envp);\n\n      switch (errno)\n        {\n        case EACCES:\n        case ENOENT:\n        case ESTALE:\n        case ENOTDIR:\n          /* Those errors indicate the file is missing or not executable\n             by us, in which case we want to just try the next path\n             directory.  */\n          break;\n\n        default:\n          /* Some other error means we found an executable file, but\n             something went wrong executing it; return the error to our\n             caller.  */\n          _exit (SPAWN_ERROR);\n        }\n    }\n  while (*p++ != '\\0');\n\n  /* Return with an error.  */\n  _exit (SPAWN_ERROR);\n}",
        "lines": 235,
        "depth": 21,
        "decorators": [
          "int"
        ]
      }
    ],
    "script_execute": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\ninternal_function\nscript_execute (const char *file, char *const argv[], char *const envp[])\n{\n  /* Count the arguments.  */\n  int argc = 0;\n  while (argv[argc++])\n    ;\n\n  /* Construct an argument list for the shell.  */\n  {\n    char **new_argv = (char **) alloca ((argc + 1) * sizeof (char *));\n    new_argv[0] = (char *) _PATH_BSHELL;\n    new_argv[1] = (char *) file;\n    while (argc > 1)\n      {\n        new_argv[argc] = argv[argc - 1];\n        --argc;\n      }\n\n    /* Execute the shell.  */\n    execve (new_argv[0], new_argv, envp);\n  }\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "internal_function",
        "internal_function"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawnp.c": {
    "posix_spawnp": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "int\nposix_spawnp (pid_t *pid, const char *file,\n              const posix_spawn_file_actions_t *file_actions,\n              const posix_spawnattr_t *attrp, char *const argv[],\n              char *const envp[])\n{\n  return __spawni (pid, file, file_actions, attrp, argv, envp, 1);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawn_faction_addopen.c": {},
  "recutils/recutils-1.7/lib/spawn_faction_destroy.c": {
    "posix_spawn_file_actions_destroy": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "int\nposix_spawn_file_actions_destroy (posix_spawn_file_actions_t *file_actions)\n{\n  /* Free the memory allocated.  */\n  free (file_actions->_actions);\n  return 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawn_faction_init.c": {
    "__posix_spawn_file_actions_realloc": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int\n__posix_spawn_file_actions_realloc (posix_spawn_file_actions_t *file_actions)\n{\n  int newalloc = file_actions->_allocated + 8;\n  void *newmem = realloc (file_actions->_actions,\n                          newalloc * sizeof (struct __spawn_action));\n\n  if (newmem == NULL)\n    /* Not enough memory.  */\n    return ENOMEM;\n\n  file_actions->_actions = (struct __spawn_action *) newmem;\n  file_actions->_allocated = newalloc;\n\n  return 0;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "posix_spawn_file_actions_init": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nposix_spawn_file_actions_init (posix_spawn_file_actions_t *file_actions)\n{\n  /* Simply clear all the elements.  */\n  memset (file_actions, '\\0', sizeof (*file_actions));\n  return 0;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/spawn_int.h": {},
  "recutils/recutils-1.7/lib/stat-macros.h": {},
  "recutils/recutils-1.7/lib/stat.c": {
    "orig_stat": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static int\norig_stat (const char *filename, struct stat *buf)\n{\n  return stat (filename, buf);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rpl_stat": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nrpl_stat (char const *name, struct stat *st)\n{\n  int result = orig_stat (name, st);\n#if REPLACE_FUNC_STAT_FILE\n  /* Solaris 9 mistakenly succeeds when given a non-directory with a\n     trailing slash.  */\n  if (result == 0 && !S_ISDIR (st->st_mode))\n    {\n      size_t len = strlen (name);\n      if (ISSLASH (name[len - 1]))\n        {\n          errno = ENOTDIR;\n          return -1;\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_FILE */\n#if REPLACE_FUNC_STAT_DIR\n\n  if (result == -1 && errno == ENOENT)\n    {\n      /* Due to mingw's oddities, there are some directories (like\n         c:\\) where stat() only succeeds with a trailing slash, and\n         other directories (like c:\\windows) where stat() only\n         succeeds without a trailing slash.  But we want the two to be\n         synonymous, since chdir() manages either style.  Likewise, Mingw also\n         reports ENOENT for names longer than PATH_MAX, when we want\n         ENAMETOOLONG, and for stat(\"file/\"), when we want ENOTDIR.\n         Fortunately, mingw PATH_MAX is small enough for stack\n         allocation.  */\n      char fixed_name[PATH_MAX + 1] = {0};\n      size_t len = strlen (name);\n      bool check_dir = false;\n      verify (PATH_MAX <= 4096);\n      if (PATH_MAX <= len)\n        errno = ENAMETOOLONG;\n      else if (len)\n        {\n          strcpy (fixed_name, name);\n          if (ISSLASH (fixed_name[len - 1]))\n            {\n              check_dir = true;\n              while (len && ISSLASH (fixed_name[len - 1]))\n                fixed_name[--len] = '\\0';\n              if (!len)\n                fixed_name[0] = '/';\n            }\n          else\n            fixed_name[len++] = '/';\n          result = orig_stat (fixed_name, st);\n          if (result == 0 && check_dir && !S_ISDIR (st->st_mode))\n            {\n              result = -1;\n              errno = ENOTDIR;\n            }\n        }\n    }\n#endif /* REPLACE_FUNC_STAT_DIR */\n  return result;\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/stdarg.in.h": {},
  "recutils/recutils-1.7/lib/stdbool.in.h": {},
  "recutils/recutils-1.7/lib/stddef.in.h": {},
  "recutils/recutils-1.7/lib/stdint.in.h": {},
  "recutils/recutils-1.7/lib/stdio-impl.h": {},
  "recutils/recutils-1.7/lib/stdio.in.h": {},
  "recutils/recutils-1.7/lib/stdlib.in.h": {},
  "recutils/recutils-1.7/lib/str-two-way.h": {
    "critical_factorization": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\ncritical_factorization (const unsigned char *needle, size_t needle_len,\n                        size_t *period)\n{\n  /* Index of last byte of left half, or SIZE_MAX.  */\n  size_t max_suffix, max_suffix_rev;\n  size_t j; /* Index into NEEDLE for current candidate suffix.  */\n  size_t k; /* Offset into current period.  */\n  size_t p; /* Intermediate period.  */\n  unsigned char a, b; /* Current comparison bytes.  */\n\n  /* Special case NEEDLE_LEN of 1 or 2 (all callers already filtered\n     out 0-length needles.  */\n  if (needle_len < 3)\n    {\n      *period = 1;\n      return needle_len - 1;\n    }\n\n  /* Invariants:\n     0 <= j < NEEDLE_LEN - 1\n     -1 <= max_suffix{,_rev} < j (treating SIZE_MAX as if it were signed)\n     min(max_suffix, max_suffix_rev) < global period of NEEDLE\n     1 <= p <= global period of NEEDLE\n     p == global period of the substring NEEDLE[max_suffix{,_rev}+1...j]\n     1 <= k <= p\n  */\n\n  /* Perform lexicographic search.  */\n  max_suffix = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix + k]);\n      if (a < b)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* b < a */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix = j++;\n          k = p = 1;\n        }\n    }\n  *period = p;\n\n  /* Perform reverse lexicographic search.  */\n  max_suffix_rev = SIZE_MAX;\n  j = 0;\n  k = p = 1;\n  while (j + k < needle_len)\n    {\n      a = CANON_ELEMENT (needle[j + k]);\n      b = CANON_ELEMENT (needle[max_suffix_rev + k]);\n      if (b < a)\n        {\n          /* Suffix is smaller, period is entire prefix so far.  */\n          j += k;\n          k = 1;\n          p = j - max_suffix_rev;\n        }\n      else if (a == b)\n        {\n          /* Advance through repetition of the current period.  */\n          if (k != p)\n            ++k;\n          else\n            {\n              j += p;\n              k = 1;\n            }\n        }\n      else /* a < b */\n        {\n          /* Suffix is larger, start over from current location.  */\n          max_suffix_rev = j++;\n          k = p = 1;\n        }\n    }\n\n  /* Choose the shorter suffix.  Return the index of the first byte of\n     the right half, rather than the last byte of the left half.\n\n     For some examples, 'banana' has two critical factorizations, both\n     exposed by the two lexicographic extreme suffixes of 'anana' and\n     'nana', where both suffixes have a period of 2.  On the other\n     hand, with 'aab' and 'bba', both strings have a single critical\n     factorization of the last byte, with the suffix having a period\n     of 1.  While the maximal lexicographic suffix of 'aab' is 'b',\n     the maximal lexicographic suffix of 'bba' is 'ba', which is not a\n     critical factorization.  Conversely, the maximal reverse\n     lexicographic suffix of 'a' works for 'bba', but not 'ab' for\n     'aab'.  The shorter suffix of the two will always be a critical\n     factorization.  */\n  if (max_suffix_rev + 1 < max_suffix + 1)\n    return max_suffix + 1;\n  *period = p;\n  return max_suffix_rev + 1;\n}",
      "lines": 116,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "two_way_short_needle": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_short_needle (const unsigned char *haystack, size_t haystack_len,\n                      const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Scan for matches in right half.  */\n          i = suffix;\n          while (i < needle_len && (CANON_ELEMENT (needle[i])\n                                    == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 81,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    },
    "two_way_long_needle": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "static RETURN_TYPE\ntwo_way_long_needle (const unsigned char *haystack, size_t haystack_len,\n                     const unsigned char *needle, size_t needle_len)\n{\n  size_t i; /* Index into current byte of NEEDLE.  */\n  size_t j; /* Index into current window of HAYSTACK.  */\n  size_t period; /* The period of the right half of needle.  */\n  size_t suffix; /* The index of the right half of needle.  */\n  size_t shift_table[1U << CHAR_BIT]; /* See below.  */\n\n  /* Factor the needle into two halves, such that the left half is\n     smaller than the global period, and the right half is\n     periodic (with a period as large as NEEDLE_LEN - suffix).  */\n  suffix = critical_factorization (needle, needle_len, &period);\n\n  /* Populate shift_table.  For each possible byte value c,\n     shift_table[c] is the distance from the last occurrence of c to\n     the end of NEEDLE, or NEEDLE_LEN if c is absent from the NEEDLE.\n     shift_table[NEEDLE[NEEDLE_LEN - 1]] contains the only 0.  */\n  for (i = 0; i < 1U << CHAR_BIT; i++)\n    shift_table[i] = needle_len;\n  for (i = 0; i < needle_len; i++)\n    shift_table[CANON_ELEMENT (needle[i])] = needle_len - i - 1;\n\n  /* Perform the search.  Each iteration compares the right half\n     first.  */\n  if (CMP_FUNC (needle, needle + period, suffix) == 0)\n    {\n      /* Entire needle is periodic; a mismatch in the left half can\n         only advance by the period, so use memory to avoid rescanning\n         known occurrences of the period in the right half.  */\n      size_t memory = 0;\n      size_t shift;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              if (memory && shift < period)\n                {\n                  /* Since needle is periodic, but the last period has\n                     a byte out of place, there can be no match until\n                     after the mismatch.  */\n                  shift = needle_len - period;\n                }\n              memory = 0;\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = MAX (suffix, memory);\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (memory < i + 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i + 1 < memory + 1)\n                return (RETURN_TYPE) (haystack + j);\n              /* No match, so remember how many repetitions of period\n                 on the right half were scanned.  */\n              j += period;\n              memory = needle_len - period;\n            }\n          else\n            {\n              j += i - suffix + 1;\n              memory = 0;\n            }\n        }\n    }\n  else\n    {\n      /* The two halves of needle are distinct; no extra memory is\n         required, and any mismatch results in a maximal shift.  */\n      size_t shift;\n      period = MAX (suffix, needle_len - suffix) + 1;\n      j = 0;\n      while (AVAILABLE (haystack, haystack_len, j, needle_len))\n        {\n          /* Check the last byte first; if it does not match, then\n             shift to the next possible match location.  */\n          shift = shift_table[CANON_ELEMENT (haystack[j + needle_len - 1])];\n          if (0 < shift)\n            {\n              j += shift;\n              continue;\n            }\n          /* Scan for matches in right half.  The last byte has\n             already been matched, by virtue of the shift table.  */\n          i = suffix;\n          while (i < needle_len - 1 && (CANON_ELEMENT (needle[i])\n                                        == CANON_ELEMENT (haystack[i + j])))\n            ++i;\n          if (needle_len - 1 <= i)\n            {\n              /* Scan for matches in left half.  */\n              i = suffix - 1;\n              while (i != SIZE_MAX && (CANON_ELEMENT (needle[i])\n                                       == CANON_ELEMENT (haystack[i + j])))\n                --i;\n              if (i == SIZE_MAX)\n                return (RETURN_TYPE) (haystack + j);\n              j += period;\n            }\n          else\n            j += i - suffix + 1;\n        }\n    }\n  return NULL;\n}",
      "lines": 119,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "RETURN_TYPE"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strcasecmp.c": {
    "strcasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrcasecmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strcasestr.c": {
    "strcasestr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "char *\nstrcasestr (const char *haystack_start, const char *needle_start)\n{\n  const char *haystack = haystack_start;\n  const char *needle = needle_start;\n  size_t needle_len; /* Length of NEEDLE.  */\n  size_t haystack_len; /* Known minimum length of HAYSTACK.  */\n  bool ok = true; /* True if NEEDLE is prefix of HAYSTACK.  */\n\n  /* Determine length of NEEDLE, and in the process, make sure\n     HAYSTACK is at least as long (no point processing all of a long\n     NEEDLE if HAYSTACK is too short).  */\n  while (*haystack && *needle)\n    {\n      ok &= (TOLOWER ((unsigned char) *haystack)\n             == TOLOWER ((unsigned char) *needle));\n      haystack++;\n      needle++;\n    }\n  if (*needle)\n    return NULL;\n  if (ok)\n    return (char *) haystack_start;\n  needle_len = needle - needle_start;\n  haystack = haystack_start + 1;\n  haystack_len = needle_len - 1;\n\n  /* Perform the search.  Abstract memory is considered to be an array\n     of 'unsigned char' values, not an array of 'char' values.  See\n     ISO C 99 section 6.2.6.1.  */\n  if (needle_len < LONG_NEEDLE_THRESHOLD)\n    return two_way_short_needle ((const unsigned char *) haystack,\n                                 haystack_len,\n                                 (const unsigned char *) needle_start,\n                                 needle_len);\n  return two_way_long_needle ((const unsigned char *) haystack, haystack_len,\n                              (const unsigned char *) needle_start,\n                              needle_len);\n}",
      "lines": 39,
      "depth": 14,
      "decorators": [
        "char",
        "*\nstrcasestr (const char *haystack_start, const char *needle_start)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strchrnul.c": {
    "strchrnul": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "char *\nstrchrnul (const char *s, int c_in)\n{\n  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned\n     long instead of a 64-bit uintmax_t tends to give better\n     performance.  On 64-bit hardware, unsigned long is generally 64\n     bits already.  Change this typedef to experiment with\n     performance.  */\n  typedef unsigned long int longword;\n\n  const unsigned char *char_ptr;\n  const longword *longword_ptr;\n  longword repeated_one;\n  longword repeated_c;\n  unsigned char c;\n\n  c = (unsigned char) c_in;\n  if (!c)\n    return rawmemchr (s, 0);\n\n  /* Handle the first few bytes by reading one byte at a time.\n     Do this until CHAR_PTR is aligned on a longword boundary.  */\n  for (char_ptr = (const unsigned char *) s;\n       (size_t) char_ptr % sizeof (longword) != 0;\n       ++char_ptr)\n    if (!*char_ptr || *char_ptr == c)\n      return (char *) char_ptr;\n\n  longword_ptr = (const longword *) char_ptr;\n\n  /* All these elucidatory comments refer to 4-byte longwords,\n     but the theory applies equally well to any size longwords.  */\n\n  /* Compute auxiliary longword values:\n     repeated_one is a value which has a 1 in every byte.\n     repeated_c has c in every byte.  */\n  repeated_one = 0x01010101;\n  repeated_c = c | (c << 8);\n  repeated_c |= repeated_c << 16;\n  if (0xffffffffU < (longword) -1)\n    {\n      repeated_one |= repeated_one << 31 << 1;\n      repeated_c |= repeated_c << 31 << 1;\n      if (8 < sizeof (longword))\n        {\n          size_t i;\n\n          for (i = 64; i < sizeof (longword) * 8; i *= 2)\n            {\n              repeated_one |= repeated_one << i;\n              repeated_c |= repeated_c << i;\n            }\n        }\n    }\n\n  /* Instead of the traditional loop which tests each byte, we will\n     test a longword at a time.  The tricky part is testing if *any of\n     the four* bytes in the longword in question are equal to NUL or\n     c.  We first use an xor with repeated_c.  This reduces the task\n     to testing whether *any of the four* bytes in longword1 or\n     longword2 is zero.\n\n     Let's consider longword1.  We compute tmp =\n       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).\n     That is, we perform the following operations:\n       1. Subtract repeated_one.\n       2. & ~longword1.\n       3. & a mask consisting of 0x80 in every byte.\n     Consider what happens in each byte:\n       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,\n         and step 3 transforms it into 0x80.  A carry can also be propagated\n         to more significant bytes.\n       - If a byte of longword1 is nonzero, let its lowest 1 bit be at\n         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,\n         the byte ends in a single bit of value 0 and k bits of value 1.\n         After step 2, the result is just k bits of value 1: 2^k - 1.  After\n         step 3, the result is 0.  And no carry is produced.\n     So, if longword1 has only non-zero bytes, tmp is zero.\n     Whereas if longword1 has a zero byte, call j the position of the least\n     significant zero byte.  Then the result has a zero at positions 0, ...,\n     j-1 and a 0x80 at position j.  We cannot predict the result at the more\n     significant bytes (positions j+1..3), but it does not matter since we\n     already have a non-zero bit at position 8*j+7.\n\n     The test whether any byte in longword1 or longword2 is zero is equivalent\n     to testing whether tmp1 is nonzero or tmp2 is nonzero.  We can combine\n     this into a single test, whether (tmp1 | tmp2) is nonzero.\n\n     This test can read more than one byte beyond the end of a string,\n     depending on where the terminating NUL is encountered.  However,\n     this is considered safe since the initialization phase ensured\n     that the read will be aligned, therefore, the read will not cross\n     page boundaries and will not cause a fault.  */\n\n  while (1)\n    {\n      longword longword1 = *longword_ptr ^ repeated_c;\n      longword longword2 = *longword_ptr;\n\n      if (((((longword1 - repeated_one) & ~longword1)\n            | ((longword2 - repeated_one) & ~longword2))\n           & (repeated_one << 7)) != 0)\n        break;\n      longword_ptr++;\n    }\n\n  char_ptr = (const unsigned char *) longword_ptr;\n\n  /* At this point, we know that one of the sizeof (longword) bytes\n     starting at char_ptr is == 0 or == c.  On little-endian machines,\n     we could determine the first such byte without any further memory\n     accesses, just by looking at the tmp result from the last loop\n     iteration.  But this does not work on big-endian machines.\n     Choose code that works in both cases.  */\n\n  char_ptr = (unsigned char *) longword_ptr;\n  while (*char_ptr && (*char_ptr != c))\n    char_ptr++;\n  return (char *) char_ptr;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "char",
        "*\nstrchrnul (const char *s, int c_in)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/streq.h": {
    "streq9": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static inline int\nstreq9 (const char *s1, const char *s2)\n{\n  return strcmp (s1 + 9, s2 + 9) == 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq8": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static inline int\nstreq8 (const char *s1, const char *s2, char s28)\n{\n  if (s1[8] == s28)\n    {\n      if (s28 == 0)\n        return 1;\n      else\n        return streq9 (s1, s2);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq7": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static inline int\nstreq7 (const char *s1, const char *s2, char s27, char s28)\n{\n  if (s1[7] == s27)\n    {\n      if (s27 == 0)\n        return 1;\n      else\n        return streq8 (s1, s2, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq6": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static inline int\nstreq6 (const char *s1, const char *s2, char s26, char s27, char s28)\n{\n  if (s1[6] == s26)\n    {\n      if (s26 == 0)\n        return 1;\n      else\n        return streq7 (s1, s2, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq5": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static inline int\nstreq5 (const char *s1, const char *s2, char s25, char s26, char s27, char s28)\n{\n  if (s1[5] == s25)\n    {\n      if (s25 == 0)\n        return 1;\n      else\n        return streq6 (s1, s2, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq4": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static inline int\nstreq4 (const char *s1, const char *s2, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[4] == s24)\n    {\n      if (s24 == 0)\n        return 1;\n      else\n        return streq5 (s1, s2, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq3": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static inline int\nstreq3 (const char *s1, const char *s2, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[3] == s23)\n    {\n      if (s23 == 0)\n        return 1;\n      else\n        return streq4 (s1, s2, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq2": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static inline int\nstreq2 (const char *s1, const char *s2, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[2] == s22)\n    {\n      if (s22 == 0)\n        return 1;\n      else\n        return streq3 (s1, s2, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq1": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static inline int\nstreq1 (const char *s1, const char *s2, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[1] == s21)\n    {\n      if (s21 == 0)\n        return 1;\n      else\n        return streq2 (s1, s2, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "streq0": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "static inline int\nstreq0 (const char *s1, const char *s2, char s20, char s21, char s22, char s23, char s24, char s25, char s26, char s27, char s28)\n{\n  if (s1[0] == s20)\n    {\n      if (s20 == 0)\n        return 1;\n      else\n        return streq1 (s1, s2, s21, s22, s23, s24, s25, s26, s27, s28);\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strerror-override.c": {
    "strerror_override": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "const char *\nstrerror_override (int errnum)\n{\n  /* These error messages are taken from glibc/sysdeps/gnu/errlist.c.  */\n  switch (errnum)\n    {\n#if REPLACE_STRERROR_0\n    case 0:\n      return \"Success\";\n#endif\n\n#if GNULIB_defined_ESOCK /* native Windows platforms with older <errno.h> */\n    case EINPROGRESS:\n      return \"Operation now in progress\";\n    case EALREADY:\n      return \"Operation already in progress\";\n    case ENOTSOCK:\n      return \"Socket operation on non-socket\";\n    case EDESTADDRREQ:\n      return \"Destination address required\";\n    case EMSGSIZE:\n      return \"Message too long\";\n    case EPROTOTYPE:\n      return \"Protocol wrong type for socket\";\n    case ENOPROTOOPT:\n      return \"Protocol not available\";\n    case EPROTONOSUPPORT:\n      return \"Protocol not supported\";\n    case EOPNOTSUPP:\n      return \"Operation not supported\";\n    case EAFNOSUPPORT:\n      return \"Address family not supported by protocol\";\n    case EADDRINUSE:\n      return \"Address already in use\";\n    case EADDRNOTAVAIL:\n      return \"Cannot assign requested address\";\n    case ENETDOWN:\n      return \"Network is down\";\n    case ENETUNREACH:\n      return \"Network is unreachable\";\n    case ECONNRESET:\n      return \"Connection reset by peer\";\n    case ENOBUFS:\n      return \"No buffer space available\";\n    case EISCONN:\n      return \"Transport endpoint is already connected\";\n    case ENOTCONN:\n      return \"Transport endpoint is not connected\";\n    case ETIMEDOUT:\n      return \"Connection timed out\";\n    case ECONNREFUSED:\n      return \"Connection refused\";\n    case ELOOP:\n      return \"Too many levels of symbolic links\";\n    case EHOSTUNREACH:\n      return \"No route to host\";\n    case EWOULDBLOCK:\n      return \"Operation would block\";\n#endif\n#if GNULIB_defined_ESTREAMS /* native Windows platforms with older <errno.h> */\n    case ETXTBSY:\n      return \"Text file busy\";\n    case ENODATA:\n      return \"No data available\";\n    case ENOSR:\n      return \"Out of streams resources\";\n    case ENOSTR:\n      return \"Device not a stream\";\n    case ETIME:\n      return \"Timer expired\";\n    case EOTHER:\n      return \"Other error\";\n#endif\n#if GNULIB_defined_EWINSOCK /* native Windows platforms */\n    case ESOCKTNOSUPPORT:\n      return \"Socket type not supported\";\n    case EPFNOSUPPORT:\n      return \"Protocol family not supported\";\n    case ESHUTDOWN:\n      return \"Cannot send after transport endpoint shutdown\";\n    case ETOOMANYREFS:\n      return \"Too many references: cannot splice\";\n    case EHOSTDOWN:\n      return \"Host is down\";\n    case EPROCLIM:\n      return \"Too many processes\";\n    case EUSERS:\n      return \"Too many users\";\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n    case ESTALE:\n      return \"Stale NFS file handle\";\n    case EREMOTE:\n      return \"Object is remote\";\n# if HAVE_WINSOCK2_H\n      /* WSA_INVALID_HANDLE maps to EBADF */\n      /* WSA_NOT_ENOUGH_MEMORY maps to ENOMEM */\n      /* WSA_INVALID_PARAMETER maps to EINVAL */\n    case WSA_OPERATION_ABORTED:\n      return \"Overlapped operation aborted\";\n    case WSA_IO_INCOMPLETE:\n      return \"Overlapped I/O event object not in signaled state\";\n    case WSA_IO_PENDING:\n      return \"Overlapped operations will complete later\";\n      /* WSAEINTR maps to EINTR */\n      /* WSAEBADF maps to EBADF */\n      /* WSAEACCES maps to EACCES */\n      /* WSAEFAULT maps to EFAULT */\n      /* WSAEINVAL maps to EINVAL */\n      /* WSAEMFILE maps to EMFILE */\n      /* WSAEWOULDBLOCK maps to EWOULDBLOCK */\n      /* WSAEINPROGRESS maps to EINPROGRESS */\n      /* WSAEALREADY maps to EALREADY */\n      /* WSAENOTSOCK maps to ENOTSOCK */\n      /* WSAEDESTADDRREQ maps to EDESTADDRREQ */\n      /* WSAEMSGSIZE maps to EMSGSIZE */\n      /* WSAEPROTOTYPE maps to EPROTOTYPE */\n      /* WSAENOPROTOOPT maps to ENOPROTOOPT */\n      /* WSAEPROTONOSUPPORT maps to EPROTONOSUPPORT */\n      /* WSAESOCKTNOSUPPORT is ESOCKTNOSUPPORT */\n      /* WSAEOPNOTSUPP maps to EOPNOTSUPP */\n      /* WSAEPFNOSUPPORT is EPFNOSUPPORT */\n      /* WSAEAFNOSUPPORT maps to EAFNOSUPPORT */\n      /* WSAEADDRINUSE maps to EADDRINUSE */\n      /* WSAEADDRNOTAVAIL maps to EADDRNOTAVAIL */\n      /* WSAENETDOWN maps to ENETDOWN */\n      /* WSAENETUNREACH maps to ENETUNREACH */\n      /* WSAENETRESET maps to ENETRESET */\n      /* WSAECONNABORTED maps to ECONNABORTED */\n      /* WSAECONNRESET maps to ECONNRESET */\n      /* WSAENOBUFS maps to ENOBUFS */\n      /* WSAEISCONN maps to EISCONN */\n      /* WSAENOTCONN maps to ENOTCONN */\n      /* WSAESHUTDOWN is ESHUTDOWN */\n      /* WSAETOOMANYREFS is ETOOMANYREFS */\n      /* WSAETIMEDOUT maps to ETIMEDOUT */\n      /* WSAECONNREFUSED maps to ECONNREFUSED */\n      /* WSAELOOP maps to ELOOP */\n      /* WSAENAMETOOLONG maps to ENAMETOOLONG */\n      /* WSAEHOSTDOWN is EHOSTDOWN */\n      /* WSAEHOSTUNREACH maps to EHOSTUNREACH */\n      /* WSAENOTEMPTY maps to ENOTEMPTY */\n      /* WSAEPROCLIM is EPROCLIM */\n      /* WSAEUSERS is EUSERS */\n      /* WSAEDQUOT is EDQUOT */\n      /* WSAESTALE is ESTALE */\n      /* WSAEREMOTE is EREMOTE */\n    case WSASYSNOTREADY:\n      return \"Network subsystem is unavailable\";\n    case WSAVERNOTSUPPORTED:\n      return \"Winsock.dll version out of range\";\n    case WSANOTINITIALISED:\n      return \"Successful WSAStartup not yet performed\";\n    case WSAEDISCON:\n      return \"Graceful shutdown in progress\";\n    case WSAENOMORE: case WSA_E_NO_MORE:\n      return \"No more results\";\n    case WSAECANCELLED: case WSA_E_CANCELLED:\n      return \"Call was canceled\";\n    case WSAEINVALIDPROCTABLE:\n      return \"Procedure call table is invalid\";\n    case WSAEINVALIDPROVIDER:\n      return \"Service provider is invalid\";\n    case WSAEPROVIDERFAILEDINIT:\n      return \"Service provider failed to initialize\";\n    case WSASYSCALLFAILURE:\n      return \"System call failure\";\n    case WSASERVICE_NOT_FOUND:\n      return \"Service not found\";\n    case WSATYPE_NOT_FOUND:\n      return \"Class type not found\";\n    case WSAEREFUSED:\n      return \"Database query was refused\";\n    case WSAHOST_NOT_FOUND:\n      return \"Host not found\";\n    case WSATRY_AGAIN:\n      return \"Nonauthoritative host not found\";\n    case WSANO_RECOVERY:\n      return \"Nonrecoverable error\";\n    case WSANO_DATA:\n      return \"Valid name, no data record of requested type\";\n      /* WSA_QOS_* omitted */\n# endif\n#endif\n\n#if GNULIB_defined_ENOMSG\n    case ENOMSG:\n      return \"No message of desired type\";\n#endif\n\n#if GNULIB_defined_EIDRM\n    case EIDRM:\n      return \"Identifier removed\";\n#endif\n\n#if GNULIB_defined_ENOLINK\n    case ENOLINK:\n      return \"Link has been severed\";\n#endif\n\n#if GNULIB_defined_EPROTO\n    case EPROTO:\n      return \"Protocol error\";\n#endif\n\n#if GNULIB_defined_EMULTIHOP\n    case EMULTIHOP:\n      return \"Multihop attempted\";\n#endif\n\n#if GNULIB_defined_EBADMSG\n    case EBADMSG:\n      return \"Bad message\";\n#endif\n\n#if GNULIB_defined_EOVERFLOW\n    case EOVERFLOW:\n      return \"Value too large for defined data type\";\n#endif\n\n#if GNULIB_defined_ENOTSUP\n    case ENOTSUP:\n      return \"Not supported\";\n#endif\n\n#if GNULIB_defined_ENETRESET\n    case ENETRESET:\n      return \"Network dropped connection on reset\";\n#endif\n\n#if GNULIB_defined_ECONNABORTED\n    case ECONNABORTED:\n      return \"Software caused connection abort\";\n#endif\n\n#if GNULIB_defined_ESTALE\n    case ESTALE:\n      return \"Stale NFS file handle\";\n#endif\n\n#if GNULIB_defined_EDQUOT\n    case EDQUOT:\n      return \"Disk quota exceeded\";\n#endif\n\n#if GNULIB_defined_ECANCELED\n    case ECANCELED:\n      return \"Operation canceled\";\n#endif\n\n#if GNULIB_defined_EOWNERDEAD\n    case EOWNERDEAD:\n      return \"Owner died\";\n#endif\n\n#if GNULIB_defined_ENOTRECOVERABLE\n    case ENOTRECOVERABLE:\n      return \"State not recoverable\";\n#endif\n\n#if GNULIB_defined_EILSEQ\n    case EILSEQ:\n      return \"Invalid or incomplete multibyte or wide character\";\n#endif\n\n    default:\n      return NULL;\n    }\n}",
      "lines": 269,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nstrerror_override (int errnum)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strerror-override.h": {},
  "recutils/recutils-1.7/lib/strerror.c": {},
  "recutils/recutils-1.7/lib/string.in.h": {},
  "recutils/recutils-1.7/lib/strings.in.h": {},
  "recutils/recutils-1.7/lib/stripslash.c": {
    "strip_trailing_slashes": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "bool\nstrip_trailing_slashes (char *file)\n{\n  char *base = last_component (file);\n  char *base_lim;\n  bool had_slash;\n\n  /* last_component returns \"\" for file system roots, but we need to turn\n     \"///\" into \"/\".  */\n  if (! *base)\n    base = file;\n  base_lim = base + base_len (base);\n  had_slash = (*base_lim != '\\0');\n  *base_lim = '\\0';\n  return had_slash;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strncasecmp.c": {
    "strncasecmp": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nstrncasecmp (const char *s1, const char *s2, size_t n)\n{\n  register const unsigned char *p1 = (const unsigned char *) s1;\n  register const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n\n  if (p1 == p2 || n == 0)\n    return 0;\n\n  do\n    {\n      c1 = TOLOWER (*p1);\n      c2 = TOLOWER (*p2);\n\n      if (--n == 0 || c1 == '\\0')\n        break;\n\n      ++p1;\n      ++p2;\n    }\n  while (c1 == c2);\n\n  if (UCHAR_MAX <= INT_MAX)\n    return c1 - c2;\n  else\n    /* On machines where 'char' and 'int' are types of the same size, the\n       difference of two 'unsigned char' values - including the sign bit -\n       doesn't fit in an 'int'.  */\n    return (c1 > c2 ? 1 : c1 < c2 ? -1 : 0);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strsep.c": {
    "strsep": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "char *\nstrsep (char **stringp, const char *delim)\n{\n  char *start = *stringp;\n  char *ptr;\n\n  if (start == NULL)\n    return NULL;\n\n  /* Optimize the case of no delimiters.  */\n  if (delim[0] == '\\0')\n    {\n      *stringp = NULL;\n      return start;\n    }\n\n  /* Optimize the case of one delimiter.  */\n  if (delim[1] == '\\0')\n    ptr = strchr (start, delim[0]);\n  else\n    /* The general case.  */\n    ptr = strpbrk (start, delim);\n  if (ptr == NULL)\n    {\n      *stringp = NULL;\n      return start;\n    }\n\n  *ptr = '\\0';\n  *stringp = ptr + 1;\n\n  return start;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "char",
        "*\nstrsep (char **stringp, const char *delim)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/strverscmp.c": {
    "__strverscmp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "int\n__strverscmp (const char *s1, const char *s2)\n{\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  unsigned char c1, c2;\n  int state;\n  int diff;\n\n  /* Symbol(s)    0       [1-9]   others  (padding)\n     Transition   (10) 0  (01) d  (00) x  (11) -   */\n  static const unsigned int next_state[] =\n  {\n      /* state    x    d    0    - */\n      /* S_N */  S_N, S_I, S_Z, S_N,\n      /* S_I */  S_N, S_I, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z, S_Z\n  };\n\n  static const int result_type[] =\n  {\n      /* state   x/x  x/d  x/0  x/-  d/x  d/d  d/0  d/-\n                 0/x  0/d  0/0  0/-  -/x  -/d  -/0  -/- */\n\n      /* S_N */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  CMP,  1,  LEN, LEN, CMP,\n                  1,  LEN, LEN, CMP, CMP, CMP, CMP, CMP,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, LEN, CMP, CMP,\n                 CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP,  1,   1,  CMP, -1,  CMP, CMP, CMP,\n                 -1,  CMP, CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  c1 = *p1++;\n  c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  state = S_N | ((c1 == '0') + (ISDIGIT (c1) != 0));\n\n  while ((diff = c1 - c2) == 0 && c1 != '\\0')\n    {\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state |= (c1 == '0') + (ISDIGIT (c1) != 0);\n    }\n\n  state = result_type[state << 2 | ((c2 == '0') + (ISDIGIT (c2) != 0))];\n\n  switch (state)\n    {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (ISDIGIT (*p1++))\n        if (!ISDIGIT (*p2++))\n          return 1;\n\n      return ISDIGIT (*p2) ? -1 : diff;\n\n    default:\n      return state;\n    }\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/sys_file.in.h": {},
  "recutils/recutils-1.7/lib/sys_stat.in.h": {
    "rpl_mkdir": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nrpl_mkdir (char const *name, mode_t mode)\n{\n  return _mkdir (name);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/sys_time.in.h": {},
  "recutils/recutils-1.7/lib/sys_types.in.h": {},
  "recutils/recutils-1.7/lib/sys_wait.in.h": {},
  "recutils/recutils-1.7/lib/tempname.c": {
    "direxists": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static int\ndirexists (const char *dir)\n{\n  struct_stat64 buf;\n  return __xstat64 (_STAT_VER, dir, &buf) == 0 && S_ISDIR (buf.st_mode);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "__path_search": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\n__path_search (char *tmpl, size_t tmpl_len, const char *dir, const char *pfx,\n               int try_tmpdir)\n{\n  const char *d;\n  size_t dlen, plen;\n\n  if (!pfx || !pfx[0])\n    {\n      pfx = \"file\";\n      plen = 4;\n    }\n  else\n    {\n      plen = strlen (pfx);\n      if (plen > 5)\n        plen = 5;\n    }\n\n  if (try_tmpdir)\n    {\n      d = __secure_getenv (\"TMPDIR\");\n      if (d != NULL && direxists (d))\n        dir = d;\n      else if (dir != NULL && direxists (dir))\n        /* nothing */ ;\n      else\n        dir = NULL;\n    }\n  if (dir == NULL)\n    {\n      if (direxists (P_tmpdir))\n        dir = P_tmpdir;\n      else if (strcmp (P_tmpdir, \"/tmp\") != 0 && direxists (\"/tmp\"))\n        dir = \"/tmp\";\n      else\n        {\n          __set_errno (ENOENT);\n          return -1;\n        }\n    }\n\n  dlen = strlen (dir);\n  while (dlen > 1 && dir[dlen - 1] == '/')\n    dlen--;                     /* remove trailing slashes */\n\n  /* check we have room for \"${dir}/${pfx}XXXXXX\\0\" */\n  if (tmpl_len < dlen + 1 + plen + 6 + 1)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  sprintf (tmpl, \"%.*s/%.*sXXXXXX\", (int) dlen, dir, (int) plen, pfx);\n  return 0;\n}",
      "lines": 56,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "__gen_tempname": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\n__gen_tempname (char *tmpl, int suffixlen, int flags, int kind)\n{\n  int len;\n  char *XXXXXX;\n  static uint64_t value;\n  uint64_t random_time_bits;\n  unsigned int count;\n  int fd = -1;\n  int save_errno = errno;\n  struct_stat64 st;\n\n  /* A lower bound on the number of temporary files to attempt to\n     generate.  The maximum total number of temporary file names that\n     can exist for a given template is 62**6.  It should never be\n     necessary to try all of these combinations.  Instead if a reasonable\n     number of names is tried (we define reasonable as 62**3) fail to\n     give the system administrator the chance to remove the problems.  */\n#define ATTEMPTS_MIN (62 * 62 * 62)\n\n  /* The number of times to attempt to generate a temporary file.  To\n     conform to POSIX, this must be no smaller than TMP_MAX.  */\n#if ATTEMPTS_MIN < TMP_MAX\n  unsigned int attempts = TMP_MAX;\n#else\n  unsigned int attempts = ATTEMPTS_MIN;\n#endif\n\n  len = strlen (tmpl);\n  if (len < 6 + suffixlen || memcmp (&tmpl[len - 6 - suffixlen], \"XXXXXX\", 6))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  /* This is where the Xs start.  */\n  XXXXXX = &tmpl[len - 6 - suffixlen];\n\n  /* Get some more or less random data.  */\n#ifdef RANDOM_BITS\n  RANDOM_BITS (random_time_bits);\n#else\n  {\n    struct timeval tv;\n    __gettimeofday (&tv, NULL);\n    random_time_bits = ((uint64_t) tv.tv_usec << 16) ^ tv.tv_sec;\n  }\n#endif\n  value += random_time_bits ^ __getpid ();\n\n  for (count = 0; count < attempts; value += 7777, ++count)\n    {\n      uint64_t v = value;\n\n      /* Fill in the random bits.  */\n      XXXXXX[0] = letters[v % 62];\n      v /= 62;\n      XXXXXX[1] = letters[v % 62];\n      v /= 62;\n      XXXXXX[2] = letters[v % 62];\n      v /= 62;\n      XXXXXX[3] = letters[v % 62];\n      v /= 62;\n      XXXXXX[4] = letters[v % 62];\n      v /= 62;\n      XXXXXX[5] = letters[v % 62];\n\n      switch (kind)\n        {\n        case __GT_FILE:\n          fd = __open (tmpl,\n                       (flags & ~O_ACCMODE)\n                       | O_RDWR | O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);\n          break;\n\n        case __GT_DIR:\n          fd = __mkdir (tmpl, S_IRUSR | S_IWUSR | S_IXUSR);\n          break;\n\n        case __GT_NOCREATE:\n          /* This case is backward from the other three.  __gen_tempname\n             succeeds if __xstat fails because the name does not exist.\n             Note the continue to bypass the common logic at the bottom\n             of the loop.  */\n          if (__lxstat64 (_STAT_VER, tmpl, &st) < 0)\n            {\n              if (errno == ENOENT)\n                {\n                  __set_errno (save_errno);\n                  return 0;\n                }\n              else\n                /* Give up now. */\n                return -1;\n            }\n          continue;\n\n        default:\n          assert (! \"invalid KIND in __gen_tempname\");\n          abort ();\n        }\n\n      if (fd >= 0)\n        {\n          __set_errno (save_errno);\n          return fd;\n        }\n      else if (errno != EEXIST)\n        return -1;\n    }\n\n  /* We got out of the loop because we ran out of combinations to try.  */\n  __set_errno (EEXIST);\n  return -1;\n}",
      "lines": 115,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/tempname.h": {},
  "recutils/recutils-1.7/lib/time.in.h": {},
  "recutils/recutils-1.7/lib/timespec.c": {},
  "recutils/recutils-1.7/lib/timespec.h": {
    "make_timespec": {
      "start_point": [
        39,
        27
      ],
      "end_point": [
        46,
        1
      ],
      "content": "timespec\nmake_timespec (time_t s, long int ns)\n{\n  struct timespec r;\n  r.tv_sec = s;\n  r.tv_nsec = ns;\n  return r;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "timespec"
      ]
    },
    "timespec_cmp": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE int\ntimespec_cmp (struct timespec a, struct timespec b)\n{\n  return (a.tv_sec < b.tv_sec ? -1\n          : a.tv_sec > b.tv_sec ? 1\n          : (int) (a.tv_nsec - b.tv_nsec));\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "int",
        "int"
      ]
    },
    "timespec_sign": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE int\ntimespec_sign (struct timespec a)\n{\n  return a.tv_sec < 0 ? -1 : a.tv_sec || a.tv_nsec;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "int",
        "int"
      ]
    },
    "timespectod": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "_GL_TIMESPEC_INLINE double\ntimespectod (struct timespec a)\n{\n  return a.tv_sec + a.tv_nsec / 1e9;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "_GL_TIMESPEC_INLINE",
        "double",
        "double"
      ]
    }
  },
  "recutils/recutils-1.7/lib/time_r.c": {
    "copy_tm_result": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static struct tm *\ncopy_tm_result (struct tm *dest, struct tm const *src)\n{\n  if (! src)\n    return 0;\n  *dest = *src;\n  return dest;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "struct tm",
        "struct",
        "tm",
        "*\ncopy_tm_result (struct tm *dest, struct tm const *src)",
        "*"
      ]
    },
    "gmtime_r": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "struct tm *\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, gmtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\ngmtime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    },
    "localtime_r": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "struct tm *\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)\n{\n  return copy_tm_result (tp, localtime (t));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "struct tm",
        "struct",
        "tm",
        "*\nlocaltime_r (time_t const * restrict t, struct tm * restrict tp)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/unistd.c": {},
  "recutils/recutils-1.7/lib/unistd.in.h": {
    "rpl_environ": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "_GL_UNISTD_INLINE char ***\nrpl_environ (void)\n{\n  return &environ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "char",
        "char",
        "***\nrpl_environ (void)",
        "*",
        "**\nrpl_environ (void)",
        "*",
        "*\nrpl_environ (void)",
        "*"
      ]
    },
    "getpagesize": {
      "start_point": [
        884,
        0
      ],
      "end_point": [
        888,
        1
      ],
      "content": "_GL_UNISTD_INLINE int\ngetpagesize ()\n{\n  return _gl_getpagesize ();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "_GL_UNISTD_INLINE",
        "int",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/unlocked-io.h": {},
  "recutils/recutils-1.7/lib/unsetenv.c": {
    "unsetenv": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\nunsetenv (const char *name)\n{\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  while (*ep != NULL)\n    if (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n      {\n        /* Found it.  Remove this pointer by moving later ones back.  */\n        char **dp = ep;\n\n        do\n          dp[0] = dp[1];\n        while (*dp++);\n        /* Continue the loop in case NAME appears again.  */\n      }\n    else\n      ++ep;\n\n  UNLOCK;\n\n  return 0;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rpl_unsetenv": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nrpl_unsetenv (const char *name)\n{\n  int result = 0;\n  if (!name || !*name || strchr (name, '='))\n    {\n      errno = EINVAL;\n      return -1;\n    }\n  while (getenv (name))\n# if !VOID_UNSETENV\n    result =\n# endif\n      unsetenv (name);\n  return result;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/vasnprintf.c": {
    "local_strnlen": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static size_t\nlocal_strnlen (const char *string, size_t maxlen)\n{\n  const char *end = memchr (string, '\\0', maxlen);\n  return end ? (size_t) (end - string) : maxlen;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcslen": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static size_t\nlocal_wcslen (const wchar_t *s)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; *ptr != (wchar_t) 0; ptr++)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "local_wcsnlen": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "static size_t\nlocal_wcsnlen (const wchar_t *s, size_t maxlen)\n{\n  const wchar_t *ptr;\n\n  for (ptr = s; maxlen > 0 && *ptr != (wchar_t) 0; ptr++, maxlen--)\n    ;\n  return ptr - s;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "decimal_point_char": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "static char\ndecimal_point_char (void)\n{\n  const char *point;\n  /* Determine it in a multithread-safe way.  We know nl_langinfo is\n     multithread-safe on glibc systems and Mac OS X systems, but is not required\n     to be multithread-safe by POSIX.  sprintf(), however, is multithread-safe.\n     localeconv() is rarely multithread-safe.  */\n#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))\n  point = nl_langinfo (RADIXCHAR);\n#  elif 1\n  char pointbuf[5];\n  sprintf (pointbuf, \"%#.0f\", 1.0);\n  point = &pointbuf[1];\n#  else\n  point = localeconv () -> decimal_point;\n#  endif\n  /* The decimal point is always a single byte: either '.' or ','.  */\n  return (point[0] != '\\0' ? point[0] : '.');\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "char"
      ]
    },
    "is_infinite_or_zero": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "static int\nis_infinite_or_zero (double x)\n{\n  return isnand (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_infinite_or_zerol": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static int\nis_infinite_or_zerol (long double x)\n{\n  return isnanl (x) || x + x == x;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiply": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "static void *\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)\n{\n  const mp_limb_t *p1;\n  const mp_limb_t *p2;\n  size_t len1;\n  size_t len2;\n\n  if (src1.nlimbs <= src2.nlimbs)\n    {\n      len1 = src1.nlimbs;\n      p1 = src1.limbs;\n      len2 = src2.nlimbs;\n      p2 = src2.limbs;\n    }\n  else\n    {\n      len1 = src2.nlimbs;\n      p1 = src2.limbs;\n      len2 = src1.nlimbs;\n      p2 = src1.limbs;\n    }\n  /* Now 0 <= len1 <= len2.  */\n  if (len1 == 0)\n    {\n      /* src1 or src2 is zero.  */\n      dest->nlimbs = 0;\n      dest->limbs = (mp_limb_t *) malloc (1);\n    }\n  else\n    {\n      /* Here 1 <= len1 <= len2.  */\n      size_t dlen;\n      mp_limb_t *dp;\n      size_t k, i, j;\n\n      dlen = len1 + len2;\n      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));\n      if (dp == NULL)\n        return NULL;\n      for (k = len2; k > 0; )\n        dp[--k] = 0;\n      for (i = 0; i < len1; i++)\n        {\n          mp_limb_t digit1 = p1[i];\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < len2; j++)\n            {\n              mp_limb_t digit2 = p2[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              carry += dp[i + j];\n              dp[i + j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          dp[i + len2] = (mp_limb_t) carry;\n        }\n      /* Normalise.  */\n      while (dlen > 0 && dp[dlen - 1] == 0)\n        dlen--;\n      dest->nlimbs = dlen;\n      dest->limbs = dp;\n    }\n  return dest->limbs;\n}",
      "lines": 64,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nmultiply (mpn_t src1, mpn_t src2, mpn_t *dest)",
        "*"
      ]
    },
    "divide": {
      "start_point": [
        413,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static void *\ndivide (mpn_t a, mpn_t b, mpn_t *q)\n{\n  /* Algorithm:\n     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]\n     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).\n     If m<n, then q:=0 and r:=a.\n     If m>=n=1, perform a single-precision division:\n       r:=0, j:=m,\n       while j>0 do\n         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =\n               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}\n         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].\n       Normalise [q[m-1],...,q[0]], yields q.\n     If m>=n>1, perform a multiple-precision division:\n       We have a/b < beta^(m-n+1).\n       s:=intDsize-1-(highest bit in b[n-1]), 0<=s<intDsize.\n       Shift a and b left by s bits, copying them. r:=a.\n       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.\n       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}\n         Compute q* :\n           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).\n           In case of overflow (q* >= beta) set q* := beta-1.\n           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]\n           and c3 := b[n-2] * q*.\n           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow\n            occurred.  Furthermore 0 <= c3 < beta^2.\n            If there was overflow and\n            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,\n            the next test can be skipped.}\n           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}\n             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].\n           If q* > 0:\n             Put r := r - b * q* * beta^j. In detail:\n               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].\n               hence: u:=0, for i:=0 to n-1 do\n                              u := u + q* * b[i],\n                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),\n                              u:=u div beta (+ 1, if carry in subtraction)\n                      r[n+j]:=r[n+j]-u.\n               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1\n                               < q* + 1 <= beta,\n                the carry u does not overflow.}\n             If a negative carry occurs, put q* := q* - 1\n               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].\n         Set q[j] := q*.\n       Normalise [q[m-n],..,q[0]]; this yields the quotient q.\n       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the\n       rest r.\n       The room for q[j] can be allocated at the memory location of r[n+j].\n     Finally, round-to-even:\n       Shift r left by 1 bit.\n       If r > b or if r = b and q[0] is odd, q := q+1.\n   */\n  const mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  const mp_limb_t *b_ptr = b.limbs;\n  size_t b_len = b.nlimbs;\n  mp_limb_t *roomptr;\n  mp_limb_t *tmp_roomptr = NULL;\n  mp_limb_t *q_ptr;\n  size_t q_len;\n  mp_limb_t *r_ptr;\n  size_t r_len;\n\n  /* Allocate room for a_len+2 digits.\n     (Need a_len+1 digits for the real division and 1 more digit for the\n     final rounding of q.)  */\n  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));\n  if (roomptr == NULL)\n    return NULL;\n\n  /* Normalise a.  */\n  while (a_len > 0 && a_ptr[a_len - 1] == 0)\n    a_len--;\n\n  /* Normalise b.  */\n  for (;;)\n    {\n      if (b_len == 0)\n        /* Division by zero.  */\n        abort ();\n      if (b_ptr[b_len - 1] == 0)\n        b_len--;\n      else\n        break;\n    }\n\n  /* Here m = a_len >= 0 and n = b_len > 0.  */\n\n  if (a_len < b_len)\n    {\n      /* m<n: trivial case.  q=0, r := copy of a.  */\n      r_ptr = roomptr;\n      r_len = a_len;\n      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n      q_ptr = roomptr + a_len;\n      q_len = 0;\n    }\n  else if (b_len == 1)\n    {\n      /* n=1: single precision division.\n         beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */\n      r_ptr = roomptr;\n      q_ptr = roomptr + 1;\n      {\n        mp_limb_t den = b_ptr[0];\n        mp_limb_t remainder = 0;\n        const mp_limb_t *sourceptr = a_ptr + a_len;\n        mp_limb_t *destptr = q_ptr + a_len;\n        size_t count;\n        for (count = a_len; count > 0; count--)\n          {\n            mp_twolimb_t num =\n              ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;\n            *--destptr = num / den;\n            remainder = num % den;\n          }\n        /* Normalise and store r.  */\n        if (remainder > 0)\n          {\n            r_ptr[0] = remainder;\n            r_len = 1;\n          }\n        else\n          r_len = 0;\n        /* Normalise q.  */\n        q_len = a_len;\n        if (q_ptr[q_len - 1] == 0)\n          q_len--;\n      }\n    }\n  else\n    {\n      /* n>1: multiple precision division.\n         beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>\n         beta^(m-n-1) <= a/b < beta^(m-n+1).  */\n      /* Determine s.  */\n      size_t s;\n      {\n        mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */\n        /* Determine s = GMP_LIMB_BITS - integer_length (msd).\n           Code copied from gnulib's integer_length.c.  */\n# if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n        s = __builtin_clz (msd);\n# else\n#  if defined DBL_EXPBIT0_WORD && defined DBL_EXPBIT0_BIT\n        if (GMP_LIMB_BITS <= DBL_MANT_BIT)\n          {\n            /* Use 'double' operations.\n               Assumes an IEEE 754 'double' implementation.  */\n#   define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)\n#   define DBL_EXP_BIAS (DBL_EXP_MASK / 2 - 1)\n#   define NWORDS \\\n     ((sizeof (double) + sizeof (unsigned int) - 1) / sizeof (unsigned int))\n            union { double value; unsigned int word[NWORDS]; } m;\n\n            /* Use a single integer to floating-point conversion.  */\n            m.value = msd;\n\n            s = GMP_LIMB_BITS\n                - (((m.word[DBL_EXPBIT0_WORD] >> DBL_EXPBIT0_BIT) & DBL_EXP_MASK)\n                   - DBL_EXP_BIAS);\n          }\n        else\n#   undef NWORDS\n#  endif\n          {\n            s = 31;\n            if (msd >= 0x10000)\n              {\n                msd = msd >> 16;\n                s -= 16;\n              }\n            if (msd >= 0x100)\n              {\n                msd = msd >> 8;\n                s -= 8;\n              }\n            if (msd >= 0x10)\n              {\n                msd = msd >> 4;\n                s -= 4;\n              }\n            if (msd >= 0x4)\n              {\n                msd = msd >> 2;\n                s -= 2;\n              }\n            if (msd >= 0x2)\n              {\n                msd = msd >> 1;\n                s -= 1;\n              }\n          }\n# endif\n      }\n      /* 0 <= s < GMP_LIMB_BITS.\n         Copy b, shifting it left by s bits.  */\n      if (s > 0)\n        {\n          tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));\n          if (tmp_roomptr == NULL)\n            {\n              free (roomptr);\n              return NULL;\n            }\n          {\n            const mp_limb_t *sourceptr = b_ptr;\n            mp_limb_t *destptr = tmp_roomptr;\n            mp_twolimb_t accu = 0;\n            size_t count;\n            for (count = b_len; count > 0; count--)\n              {\n                accu += (mp_twolimb_t) *sourceptr++ << s;\n                *destptr++ = (mp_limb_t) accu;\n                accu = accu >> GMP_LIMB_BITS;\n              }\n            /* accu must be zero, since that was how s was determined.  */\n            if (accu != 0)\n              abort ();\n          }\n          b_ptr = tmp_roomptr;\n        }\n      /* Copy a, shifting it left by s bits, yields r.\n         Memory layout:\n         At the beginning: r = roomptr[0..a_len],\n         at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */\n      r_ptr = roomptr;\n      if (s == 0)\n        {\n          memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));\n          r_ptr[a_len] = 0;\n        }\n      else\n        {\n          const mp_limb_t *sourceptr = a_ptr;\n          mp_limb_t *destptr = r_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *sourceptr++ << s;\n              *destptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          *destptr++ = (mp_limb_t) accu;\n        }\n      q_ptr = roomptr + b_len;\n      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */\n      {\n        size_t j = a_len - b_len; /* m-n */\n        mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */\n        mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */\n        mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */\n          ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;\n        /* Division loop, traversed m-n+1 times.\n           j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */\n        for (;;)\n          {\n            mp_limb_t q_star;\n            mp_limb_t c1;\n            if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */\n              {\n                /* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */\n                mp_twolimb_t num =\n                  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)\n                  | r_ptr[j + b_len - 1];\n                q_star = num / b_msd;\n                c1 = num % b_msd;\n              }\n            else\n              {\n                /* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */\n                q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */\n                /* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta\n                   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta\n                   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)\n                        {<= beta !}.\n                   If yes, jump directly to the subtraction loop.\n                   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta\n                    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */\n                if (r_ptr[j + b_len] > b_msd\n                    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)\n                  /* r[j+n] >= b[n-1]+1 or\n                     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a\n                     carry.  */\n                  goto subtract;\n              }\n            /* q_star = q*,\n               c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */\n            {\n              mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */\n                ((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];\n              mp_twolimb_t c3 = /* b[n-2] * q* */\n                (mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;\n              /* While c2 < c3, increase c2 and decrease c3.\n                 Consider c3-c2.  While it is > 0, decrease it by\n                 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2\n                 this can happen only twice.  */\n              if (c3 > c2)\n                {\n                  q_star = q_star - 1; /* q* := q* - 1 */\n                  if (c3 - c2 > b_msdd)\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                }\n            }\n            if (q_star > 0)\n              subtract:\n              {\n                /* Subtract r := r - b * q* * beta^j.  */\n                mp_limb_t cr;\n                {\n                  const mp_limb_t *sourceptr = b_ptr;\n                  mp_limb_t *destptr = r_ptr + j;\n                  mp_twolimb_t carry = 0;\n                  size_t count;\n                  for (count = b_len; count > 0; count--)\n                    {\n                      /* Here 0 <= carry <= q*.  */\n                      carry =\n                        carry\n                        + (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++\n                        + (mp_limb_t) ~(*destptr);\n                      /* Here 0 <= carry <= beta*q* + beta-1.  */\n                      *destptr++ = ~(mp_limb_t) carry;\n                      carry = carry >> GMP_LIMB_BITS; /* <= q* */\n                    }\n                  cr = (mp_limb_t) carry;\n                }\n                /* Subtract cr from r_ptr[j + b_len], then forget about\n                   r_ptr[j + b_len].  */\n                if (cr > r_ptr[j + b_len])\n                  {\n                    /* Subtraction gave a carry.  */\n                    q_star = q_star - 1; /* q* := q* - 1 */\n                    /* Add b back.  */\n                    {\n                      const mp_limb_t *sourceptr = b_ptr;\n                      mp_limb_t *destptr = r_ptr + j;\n                      mp_limb_t carry = 0;\n                      size_t count;\n                      for (count = b_len; count > 0; count--)\n                        {\n                          mp_limb_t source1 = *sourceptr++;\n                          mp_limb_t source2 = *destptr;\n                          *destptr++ = source1 + source2 + carry;\n                          carry =\n                            (carry\n                             ? source1 >= (mp_limb_t) ~source2\n                             : source1 > (mp_limb_t) ~source2);\n                        }\n                    }\n                    /* Forget about the carry and about r[j+n].  */\n                  }\n              }\n            /* q* is determined.  Store it as q[j].  */\n            q_ptr[j] = q_star;\n            if (j == 0)\n              break;\n            j--;\n          }\n      }\n      r_len = b_len;\n      /* Normalise q.  */\n      if (q_ptr[q_len - 1] == 0)\n        q_len--;\n# if 0 /* Not needed here, since we need r only to compare it with b/2, and\n          b is shifted left by s bits.  */\n      /* Shift r right by s bits.  */\n      if (s > 0)\n        {\n          mp_limb_t ptr = r_ptr + r_len;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = r_len; count > 0; count--)\n            {\n              accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;\n              accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);\n              *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);\n            }\n        }\n# endif\n      /* Normalise r.  */\n      while (r_len > 0 && r_ptr[r_len - 1] == 0)\n        r_len--;\n    }\n  /* Compare r << 1 with b.  */\n  if (r_len > b_len)\n    goto increment_q;\n  {\n    size_t i;\n    for (i = b_len;;)\n      {\n        mp_limb_t r_i =\n          (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)\n          | (i < r_len ? r_ptr[i] << 1 : 0);\n        mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);\n        if (r_i > b_i)\n          goto increment_q;\n        if (r_i < b_i)\n          goto keep_q;\n        if (i == 0)\n          break;\n        i--;\n      }\n  }\n  if (q_len > 0 && ((q_ptr[0] & 1) != 0))\n    /* q is odd.  */\n    increment_q:\n    {\n      size_t i;\n      for (i = 0; i < q_len; i++)\n        if (++(q_ptr[i]) != 0)\n          goto keep_q;\n      q_ptr[q_len++] = 1;\n    }\n  keep_q:\n  if (tmp_roomptr != NULL)\n    free (tmp_roomptr);\n  q->limbs = q_ptr;\n  q->nlimbs = q_len;\n  return roomptr;\n}",
      "lines": 424,
      "depth": 24,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndivide (mpn_t a, mpn_t b, mpn_t *q)",
        "*"
      ]
    },
    "convert_to_decimal": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        890,
        1
      ],
      "content": "static char *\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)\n{\n  mp_limb_t *a_ptr = a.limbs;\n  size_t a_len = a.nlimbs;\n  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */\n  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);\n  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));\n  if (c_ptr != NULL)\n    {\n      char *d_ptr = c_ptr;\n      for (; extra_zeroes > 0; extra_zeroes--)\n        *d_ptr++ = '0';\n      while (a_len > 0)\n        {\n          /* Divide a by 10^9, in-place.  */\n          mp_limb_t remainder = 0;\n          mp_limb_t *ptr = a_ptr + a_len;\n          size_t count;\n          for (count = a_len; count > 0; count--)\n            {\n              mp_twolimb_t num =\n                ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;\n              *ptr = num / 1000000000;\n              remainder = num % 1000000000;\n            }\n          /* Store the remainder as 9 decimal digits.  */\n          for (count = 9; count > 0; count--)\n            {\n              *d_ptr++ = '0' + (remainder % 10);\n              remainder = remainder / 10;\n            }\n          /* Normalize a.  */\n          if (a_ptr[a_len - 1] == 0)\n            a_len--;\n        }\n      /* Remove leading zeroes.  */\n      while (d_ptr > c_ptr && d_ptr[-1] == '0')\n        d_ptr--;\n      /* But keep at least one zero.  */\n      if (d_ptr == c_ptr)\n        *d_ptr++ = '0';\n      /* Terminate the string.  */\n      *d_ptr = '\\0';\n    }\n  return c_ptr;\n}",
      "lines": 47,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nconvert_to_decimal (mpn_t a, size_t extra_zeroes)",
        "*"
      ]
    },
    "decode_long_double": {
      "start_point": [
        898,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static void *\ndecode_long_double (long double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  long double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * 2^LDBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^LDBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'long double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0L && y < 1.0L))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#  if 0 /* On FreeBSD 6.1/x86, 'long double' numbers sometimes have excess\n           precision.  */\n  if (!(y == 0.0L))\n    abort ();\n#  endif\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - LDBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_long_double (long double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "decode_double": {
      "start_point": [
        986,
        0
      ],
      "end_point": [
        1061,
        1
      ],
      "content": "static void *\ndecode_double (double x, int *ep, mpn_t *mp)\n{\n  mpn_t m;\n  int exp;\n  double y;\n  size_t i;\n\n  /* Allocate memory for result.  */\n  m.nlimbs = (DBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));\n  if (m.limbs == NULL)\n    return NULL;\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  /* x = 2^exp * y = 2^(exp - DBL_MANT_BIT) * (y * 2^DBL_MANT_BIT), and the\n     latter is an integer.  */\n  /* Convert the mantissa (y * 2^DBL_MANT_BIT) to a sequence of limbs.\n     I'm not sure whether it's safe to cast a 'double' value between\n     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only\n     'double' values between 0 and 2^16 (to 'unsigned int' or 'int',\n     doesn't matter).  */\n#  if (DBL_MANT_BIT % GMP_LIMB_BITS) != 0\n#   if (DBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % (GMP_LIMB_BITS / 2));\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n#   else\n    {\n      mp_limb_t d;\n      y *= (mp_limb_t) 1 << (DBL_MANT_BIT % GMP_LIMB_BITS);\n      d = (int) y;\n      y -= d;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[DBL_MANT_BIT / GMP_LIMB_BITS] = d;\n    }\n#   endif\n#  endif\n  for (i = DBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )\n    {\n      mp_limb_t hi, lo;\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      hi = (int) y;\n      y -= hi;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);\n      lo = (int) y;\n      y -= lo;\n      if (!(y >= 0.0 && y < 1.0))\n        abort ();\n      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;\n    }\n  if (!(y == 0.0))\n    abort ();\n  /* Normalise.  */\n  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)\n    m.nlimbs--;\n  *mp = m;\n  *ep = exp - DBL_MANT_BIT;\n  return m.limbs;\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndecode_double (double x, int *ep, mpn_t *mp)",
        "*"
      ]
    },
    "scale10_round_decimal_decoded": {
      "start_point": [
        1070,
        0
      ],
      "end_point": [
        1283,
        1
      ],
      "content": "static char *\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)\n{\n  int s;\n  size_t extra_zeroes;\n  unsigned int abs_n;\n  unsigned int abs_s;\n  mp_limb_t *pow5_ptr;\n  size_t pow5_len;\n  unsigned int s_limbs;\n  unsigned int s_bits;\n  mpn_t pow5;\n  mpn_t z;\n  void *z_memory;\n  char *digits;\n\n  if (memory == NULL)\n    return NULL;\n  /* x = 2^e * m, hence\n     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)\n       = round (2^s * 5^n * m).  */\n  s = e + n;\n  extra_zeroes = 0;\n  /* Factor out a common power of 10 if possible.  */\n  if (s > 0 && n > 0)\n    {\n      extra_zeroes = (s < n ? s : n);\n      s -= extra_zeroes;\n      n -= extra_zeroes;\n    }\n  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.\n     Before converting to decimal, we need to compute\n     z = round (2^s * 5^n * m).  */\n  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same\n     sign.  2.322 is slightly larger than log(5)/log(2).  */\n  abs_n = (n >= 0 ? n : -n);\n  abs_s = (s >= 0 ? s : -s);\n  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1\n                                    + abs_s / GMP_LIMB_BITS + 1)\n                                   * sizeof (mp_limb_t));\n  if (pow5_ptr == NULL)\n    {\n      free (memory);\n      return NULL;\n    }\n  /* Initialize with 1.  */\n  pow5_ptr[0] = 1;\n  pow5_len = 1;\n  /* Multiply with 5^|n|.  */\n  if (abs_n > 0)\n    {\n      static mp_limb_t const small_pow5[13 + 1] =\n        {\n          1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,\n          48828125, 244140625, 1220703125\n        };\n      unsigned int n13;\n      for (n13 = 0; n13 <= abs_n; n13 += 13)\n        {\n          mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];\n          size_t j;\n          mp_twolimb_t carry = 0;\n          for (j = 0; j < pow5_len; j++)\n            {\n              mp_limb_t digit2 = pow5_ptr[j];\n              carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;\n              pow5_ptr[j] = (mp_limb_t) carry;\n              carry = carry >> GMP_LIMB_BITS;\n            }\n          if (carry > 0)\n            pow5_ptr[pow5_len++] = (mp_limb_t) carry;\n        }\n    }\n  s_limbs = abs_s / GMP_LIMB_BITS;\n  s_bits = abs_s % GMP_LIMB_BITS;\n  if (n >= 0 ? s >= 0 : s <= 0)\n    {\n      /* Multiply with 2^|s|.  */\n      if (s_bits > 0)\n        {\n          mp_limb_t *ptr = pow5_ptr;\n          mp_twolimb_t accu = 0;\n          size_t count;\n          for (count = pow5_len; count > 0; count--)\n            {\n              accu += (mp_twolimb_t) *ptr << s_bits;\n              *ptr++ = (mp_limb_t) accu;\n              accu = accu >> GMP_LIMB_BITS;\n            }\n          if (accu > 0)\n            {\n              *ptr = (mp_limb_t) accu;\n              pow5_len++;\n            }\n        }\n      if (s_limbs > 0)\n        {\n          size_t count;\n          for (count = pow5_len; count > 0;)\n            {\n              count--;\n              pow5_ptr[s_limbs + count] = pow5_ptr[count];\n            }\n          for (count = s_limbs; count > 0;)\n            {\n              count--;\n              pow5_ptr[count] = 0;\n            }\n          pow5_len += s_limbs;\n        }\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* Multiply m with pow5.  No division needed.  */\n          z_memory = multiply (m, pow5, &z);\n        }\n      else\n        {\n          /* Divide m by pow5 and round.  */\n          z_memory = divide (m, pow5, &z);\n        }\n    }\n  else\n    {\n      pow5.limbs = pow5_ptr;\n      pow5.nlimbs = pow5_len;\n      if (n >= 0)\n        {\n          /* n >= 0, s < 0.\n             Multiply m with pow5, then divide by 2^|s|.  */\n          mpn_t numerator;\n          mpn_t denominator;\n          void *tmp_memory;\n          tmp_memory = multiply (m, pow5, &numerator);\n          if (tmp_memory == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          /* Construct 2^|s|.  */\n          {\n            mp_limb_t *ptr = pow5_ptr + pow5_len;\n            size_t i;\n            for (i = 0; i < s_limbs; i++)\n              ptr[i] = 0;\n            ptr[s_limbs] = (mp_limb_t) 1 << s_bits;\n            denominator.limbs = ptr;\n            denominator.nlimbs = s_limbs + 1;\n          }\n          z_memory = divide (numerator, denominator, &z);\n          free (tmp_memory);\n        }\n      else\n        {\n          /* n < 0, s > 0.\n             Multiply m with 2^s, then divide by pow5.  */\n          mpn_t numerator;\n          mp_limb_t *num_ptr;\n          num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)\n                                          * sizeof (mp_limb_t));\n          if (num_ptr == NULL)\n            {\n              free (pow5_ptr);\n              free (memory);\n              return NULL;\n            }\n          {\n            mp_limb_t *destptr = num_ptr;\n            {\n              size_t i;\n              for (i = 0; i < s_limbs; i++)\n                *destptr++ = 0;\n            }\n            if (s_bits > 0)\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                mp_twolimb_t accu = 0;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  {\n                    accu += (mp_twolimb_t) *sourceptr++ << s_bits;\n                    *destptr++ = (mp_limb_t) accu;\n                    accu = accu >> GMP_LIMB_BITS;\n                  }\n                if (accu > 0)\n                  *destptr++ = (mp_limb_t) accu;\n              }\n            else\n              {\n                const mp_limb_t *sourceptr = m.limbs;\n                size_t count;\n                for (count = m.nlimbs; count > 0; count--)\n                  *destptr++ = *sourceptr++;\n              }\n            numerator.limbs = num_ptr;\n            numerator.nlimbs = destptr - num_ptr;\n          }\n          z_memory = divide (numerator, pow5, &z);\n          free (num_ptr);\n        }\n    }\n  free (pow5_ptr);\n  free (memory);\n\n  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */\n\n  if (z_memory == NULL)\n    return NULL;\n  digits = convert_to_decimal (z, extra_zeroes);\n  free (z_memory);\n  return digits;\n}",
      "lines": 214,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_decoded (int e, mpn_t m, void *memory, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_long_double": {
      "start_point": [
        1292,
        0
      ],
      "end_point": [
        1299,
        1
      ],
      "content": "static char *\nscale10_round_decimal_long_double (long double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_long_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_long_double (long double x, int n)",
        "*"
      ]
    },
    "scale10_round_decimal_double": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1317,
        1
      ],
      "content": "static char *\nscale10_round_decimal_double (double x, int n)\n{\n  int e IF_LINT(= 0);\n  mpn_t m;\n  void *memory = decode_double (x, &e, &m);\n  return scale10_round_decimal_decoded (e, m, memory, n);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nscale10_round_decimal_double (double x, int n)",
        "*"
      ]
    },
    "floorlog10l": {
      "start_point": [
        1326,
        0
      ],
      "end_point": [
        1408,
        1
      ],
      "content": "static int\nfloorlog10l (long double x)\n{\n  int exp;\n  long double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexpl (x, &exp);\n  if (!(y >= 0.0L && y < 1.0L))\n    abort ();\n  if (y == 0.0L)\n    return INT_MIN;\n  if (y < 0.5L)\n    {\n      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0L / (1 << 16)))\n        {\n          y *= 1.0L * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0L / (1 << 8)))\n        {\n          y *= 1.0L * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0L / (1 << 4)))\n        {\n          y *= 1.0L * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0L / (1 << 2)))\n        {\n          y *= 1.0L * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0L / (1 << 1)))\n        {\n          y *= 1.0L * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5L && y < 1.0L))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "floorlog10": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1499,
        1
      ],
      "content": "static int\nfloorlog10 (double x)\n{\n  int exp;\n  double y;\n  double z;\n  double l;\n\n  /* Split into exponential part and mantissa.  */\n  y = frexp (x, &exp);\n  if (!(y >= 0.0 && y < 1.0))\n    abort ();\n  if (y == 0.0)\n    return INT_MIN;\n  if (y < 0.5)\n    {\n      while (y < (1.0 / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))\n        {\n          y *= 1.0 * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));\n          exp -= GMP_LIMB_BITS;\n        }\n      if (y < (1.0 / (1 << 16)))\n        {\n          y *= 1.0 * (1 << 16);\n          exp -= 16;\n        }\n      if (y < (1.0 / (1 << 8)))\n        {\n          y *= 1.0 * (1 << 8);\n          exp -= 8;\n        }\n      if (y < (1.0 / (1 << 4)))\n        {\n          y *= 1.0 * (1 << 4);\n          exp -= 4;\n        }\n      if (y < (1.0 / (1 << 2)))\n        {\n          y *= 1.0 * (1 << 2);\n          exp -= 2;\n        }\n      if (y < (1.0 / (1 << 1)))\n        {\n          y *= 1.0 * (1 << 1);\n          exp -= 1;\n        }\n    }\n  if (!(y >= 0.5 && y < 1.0))\n    abort ();\n  /* Compute an approximation for l = log2(x) = exp + log2(y).  */\n  l = exp;\n  z = y;\n  if (z < 0.70710678118654752444)\n    {\n      z *= 1.4142135623730950488;\n      l -= 0.5;\n    }\n  if (z < 0.8408964152537145431)\n    {\n      z *= 1.1892071150027210667;\n      l -= 0.25;\n    }\n  if (z < 0.91700404320467123175)\n    {\n      z *= 1.0905077326652576592;\n      l -= 0.125;\n    }\n  if (z < 0.9576032806985736469)\n    {\n      z *= 1.0442737824274138403;\n      l -= 0.0625;\n    }\n  /* Now 0.95 <= z <= 1.01.  */\n  z = 1 - z;\n  /* log2(1-z) = 1/log(2) * (- z - z^2/2 - z^3/3 - z^4/4 - ...)\n     Four terms are enough to get an approximation with error < 10^-7.  */\n  l -= 1.4426950408889634074 * z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));\n  /* Finally multiply with log(2)/log(10), yields an approximation for\n     log10(x).  */\n  l *= 0.30102999566398119523;\n  /* Round down to the next integer.  */\n  return (int) l + (l < 0 ? -1 : 0);\n}",
      "lines": 83,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_borderline": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1515,
        1
      ],
      "content": "static int\nis_borderline (const char *digits, size_t precision)\n{\n  for (; precision > 0; precision--, digits++)\n    if (*digits != '0')\n      return 0;\n  if (*digits != '1')\n    return 0;\n  digits++;\n  return *digits == '\\0';\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "MAX_ROOM_NEEDED": {
      "start_point": [
        1532,
        0
      ],
      "end_point": [
        1767,
        1
      ],
      "content": "static size_t\nMAX_ROOM_NEEDED (const arguments *ap, size_t arg_index, FCHAR_T conversion,\n                 arg_type type, int flags, size_t width, int has_precision,\n                 size_t precision, int pad_ourselves)\n{\n  size_t tmp_length;\n\n  switch (conversion)\n    {\n    case 'd': case 'i': case 'u':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.30103 /* binary -> decimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Multiply by 2, as an estimate for FLAG_GROUP.  */\n      tmp_length = xsum (tmp_length, tmp_length);\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'o':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.333334 /* binary -> octal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 1, to account for a leading sign.  */\n      tmp_length = xsum (tmp_length, 1);\n      break;\n\n    case 'x': case 'X':\n# if HAVE_LONG_LONG_INT\n      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n# endif\n      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)\n        tmp_length =\n          (unsigned int) (sizeof (unsigned long) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (sizeof (unsigned int) * CHAR_BIT\n                          * 0.25 /* binary -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Add 2, to account for a leading sign or alternate form.  */\n      tmp_length = xsum (tmp_length, 2);\n      break;\n\n    case 'f': case 'F':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      else\n        tmp_length =\n          (unsigned int) (DBL_MAX_EXP\n                          * 0.30103 /* binary -> decimal */\n                          * 2 /* estimate for FLAG_GROUP */\n                         )\n          + 1 /* turn floor into ceil */\n          + 10; /* sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'e': case 'E': case 'g': case 'G':\n      tmp_length =\n        12; /* sign, decimal point, exponent etc. */\n      tmp_length = xsum (tmp_length, precision);\n      break;\n\n    case 'a': case 'A':\n      if (type == TYPE_LONGDOUBLE)\n        tmp_length =\n          (unsigned int) (LDBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      else\n        tmp_length =\n          (unsigned int) (DBL_DIG\n                          * 0.831 /* decimal -> hexadecimal */\n                         )\n          + 1; /* turn floor into ceil */\n      if (tmp_length < precision)\n        tmp_length = precision;\n      /* Account for sign, decimal point etc. */\n      tmp_length = xsum (tmp_length, 12);\n      break;\n\n    case 'c':\n# if HAVE_WINT_T && !WIDE_CHAR_VERSION\n      if (type == TYPE_WIDE_CHAR)\n        tmp_length = MB_CUR_MAX;\n      else\n# endif\n        tmp_length = 1;\n      break;\n\n    case 's':\n# if HAVE_WCHAR_T\n      if (type == TYPE_WIDE_STRING)\n        {\n#  if WIDE_CHAR_VERSION\n          /* ISO C says about %ls in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the array, the array shall contain a null wide character.\"\n             So if there is a precision, we must not use wcslen.  */\n          const wchar_t *arg = ap->arg[arg_index].a.a_wide_string;\n\n          if (has_precision)\n            tmp_length = local_wcsnlen (arg, precision);\n          else\n            tmp_length = local_wcslen (arg);\n#  else\n          /* ISO C says about %ls in fprintf:\n               \"If a precision is specified, no more than that many bytes are\n                written (including shift sequences, if any), and the array\n                shall contain a null wide character if, to equal the multibyte\n                character sequence length given by the precision, the function\n                would need to access a wide character one past the end of the\n                array.\"\n             So if there is a precision, we must not use wcslen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n#  endif\n        }\n      else\n# endif\n        {\n# if WIDE_CHAR_VERSION\n          /* ISO C says about %s in fwprintf:\n               \"If the precision is not specified or is greater than the size\n                of the converted array, the converted array shall contain a\n                null wide character.\"\n             So if there is a precision, we must not use strlen.  */\n          /* This case has already been handled separately in VASNPRINTF.  */\n          abort ();\n# else\n          /* ISO C says about %s in fprintf:\n               \"If the precision is not specified or greater than the size of\n                the array, the array shall contain a null character.\"\n             So if there is a precision, we must not use strlen.  */\n          const char *arg = ap->arg[arg_index].a.a_string;\n\n          if (has_precision)\n            tmp_length = local_strnlen (arg, precision);\n          else\n            tmp_length = strlen (arg);\n# endif\n        }\n      break;\n\n    case 'p':\n      tmp_length =\n        (unsigned int) (sizeof (void *) * CHAR_BIT\n                        * 0.25 /* binary -> hexadecimal */\n                       )\n          + 1 /* turn floor into ceil */\n          + 2; /* account for leading 0x */\n      break;\n\n    default:\n      abort ();\n    }\n\n  if (!pad_ourselves)\n    {\n# if ENABLE_UNISTDIO\n      /* Padding considers the number of characters, therefore the number of\n         elements after padding may be\n           > max (tmp_length, width)\n         but is certainly\n           <= tmp_length + width.  */\n      tmp_length = xsum (tmp_length, width);\n# else\n      /* Padding considers the number of elements, says POSIX.  */\n      if (tmp_length < width)\n        tmp_length = width;\n# endif\n    }\n\n  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */\n\n  return tmp_length;\n}",
      "lines": 236,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "xsum": {
      "start_point": [
        4629,
        16
      ],
      "end_point": [
        5542,
        15
      ],
      "content": "int prefixes[2] IF_LINT (= { 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
      "lines": 914,
      "depth": 24,
      "decorators": [
        "int",
        "prefixes[2]",
        "prefixes",
        "[",
        "2",
        "]",
        "IF_LINT (=",
        "IF_LINT",
        "(",
        "=",
        "{ 0 });\n                int orig_errno;\n#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif\n\n#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif\n\n                /* Decide whether to handle the precision ourselves.  */\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif\n\n                /* Decide whether to perform the padding ourselves.  */\n#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif\n\n#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif\n\n                /* Construct the format string for calling snprintf or\n                   sprintf.  */\n                fbp = buf;\n                *fbp++ = '%';\n#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif\n                if (flags & FLAG_LEFT)\n                  *fbp++ = '-';\n                if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';\n                if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';\n                if (flags & FLAG_ALT)\n                  *fbp++ = '#';\n#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif\n                if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n                if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }\n\n                switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }\n#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif\n                  *fbp = dp->conversion;\n#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif\n\n                /* Construct the arguments for calling snprintf or sprintf.  */\n                prefix_count = 0;\n                if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }\n                if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }\n\n#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif\n\n                orig_errno = errno;\n\n                for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }\n                errno = orig_errno;\n#undef pad_ourselves\n#undef prec_ourselves\n              }",
        "{",
        "0 });",
        "0",
        "})",
        "}",
        ")",
        ";",
        "int orig_errno;",
        "int",
        "orig_errno",
        ";",
        "#if !USE_SNPRINTF\n                size_t tmp_length;\n                TCHAR_T tmpbuf[700];\n                TCHAR_T *tmp;\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "size_t tmp_length;",
        "size_t",
        "tmp_length",
        ";",
        "TCHAR_T tmpbuf[700];",
        "TCHAR_T",
        "tmpbuf[700]",
        "tmpbuf",
        "[",
        "700",
        "]",
        ";",
        "TCHAR_T *tmp;",
        "TCHAR_T",
        "*tmp",
        "*",
        "tmp",
        ";",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_width = 0;\n                width = 0;\n                if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || !DCHAR_IS_TCHAR",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_width = 0;",
        "has_width = 0",
        "has_width",
        "=",
        "0",
        ";",
        "width = 0;",
        "width = 0",
        "width",
        "=",
        "0",
        ";",
        "if (dp->width_start != dp->width_end)\n                  {\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                    if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }\n                    has_width = 1;\n                  }",
        "{",
        "if (dp->width_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "if",
        "(dp->width_arg_index != ARG_NONE)",
        "(",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->width_arg_index].a.a_int;\n                        if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->width_arg_index].a.a_int;",
        "arg = a.arg[dp->width_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "if (arg < 0)\n                          {\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }\n                        else\n                          width = arg;",
        "if",
        "(arg < 0)",
        "(",
        "arg < 0",
        "arg",
        "<",
        "0",
        ")",
        "{\n                            /* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */\n                            flags |= FLAG_LEFT;\n                            width = (unsigned int) (-arg);\n                          }",
        "{",
        "/* \"A negative field width is taken as a '-' flag\n                                followed by a positive field width.\"  */",
        "flags |= FLAG_LEFT;",
        "flags |= FLAG_LEFT",
        "flags",
        "|=",
        "FLAG_LEFT",
        ";",
        "width = (unsigned int) (-arg);",
        "width = (unsigned int) (-arg)",
        "width",
        "=",
        "(unsigned int) (-arg)",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "(-arg)",
        "(",
        "-arg",
        "-",
        "arg",
        ")",
        ";",
        "}",
        "else",
        "width = arg;",
        "width = arg",
        "width",
        "=",
        "arg",
        ";",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->width_start;\n\n                        do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->width_start",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                          width = xsum (xtimes (width, 10), *digitp++ - '0');\n                        while (digitp != dp->width_end);",
        "do",
        "width = xsum (xtimes (width, 10), *digitp++ - '0');",
        "width = xsum (xtimes (width, 10), *digitp++ - '0')",
        "width",
        "=",
        "xsum (xtimes (width, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (width, 10), *digitp++ - '0')",
        "(",
        "xtimes (width, 10)",
        "xtimes",
        "(width, 10)",
        "(",
        "width",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "while",
        "(digitp != dp->width_end)",
        "(",
        "digitp != dp->width_end",
        "digitp",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        ";",
        "}",
        "has_width = 1;",
        "has_width = 1",
        "has_width",
        "=",
        "1",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION\n                has_precision = 0;\n                precision = 6;\n                if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99 || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!USE_SNPRINTF || !HAVE_SNPRINTF_RETVAL_C99",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "||",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "has_precision = 0;",
        "has_precision = 0",
        "has_precision",
        "=",
        "0",
        ";",
        "precision = 6;",
        "precision = 6",
        "precision",
        "=",
        "6",
        ";",
        "if (dp->precision_start != dp->precision_end)\n                  {\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                    if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }\n                  }",
        "{",
        "if (dp->precision_arg_index != ARG_NONE)\n                      {\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }\n                    else\n                      {\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "if",
        "(dp->precision_arg_index != ARG_NONE)",
        "(",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                        int arg;\n\n                        if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();\n                        arg = a.arg[dp->precision_arg_index].a.a_int;\n                        /* \"A negative precision is taken as if the precision\n                            were omitted.\"  */\n                        if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }\n                      }",
        "{",
        "int arg;",
        "int",
        "arg",
        ";",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                          abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "arg = a.arg[dp->precision_arg_index].a.a_int;",
        "arg = a.arg[dp->precision_arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "/* \"A negative precision is taken as if the precision\n                            were omitted.\"  */",
        "if (arg >= 0)\n                          {\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "if",
        "(arg >= 0)",
        "(",
        "arg >= 0",
        "arg",
        ">=",
        "0",
        ")",
        "{\n                            precision = arg;\n                            has_precision = 1;\n                          }",
        "{",
        "precision = arg;",
        "precision = arg",
        "precision",
        "=",
        "arg",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "else",
        "{\n                        const FCHAR_T *digitp = dp->precision_start + 1;\n\n                        precision = 0;\n                        while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');\n                        has_precision = 1;\n                      }",
        "{",
        "const FCHAR_T *digitp = dp->precision_start + 1;",
        "const",
        "const",
        "FCHAR_T",
        "*digitp = dp->precision_start + 1",
        "*digitp",
        "*",
        "digitp",
        "=",
        "dp->precision_start + 1",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "+",
        "1",
        ";",
        "precision = 0;",
        "precision = 0",
        "precision",
        "=",
        "0",
        ";",
        "while (digitp != dp->precision_end)\n                          precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "while",
        "(digitp != dp->precision_end)",
        "(",
        "digitp != dp->precision_end",
        "digitp",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0');",
        "precision = xsum (xtimes (precision, 10), *digitp++ - '0')",
        "precision",
        "=",
        "xsum (xtimes (precision, 10), *digitp++ - '0')",
        "xsum",
        "(xtimes (precision, 10), *digitp++ - '0')",
        "(",
        "xtimes (precision, 10)",
        "xtimes",
        "(precision, 10)",
        "(",
        "precision",
        ",",
        "10",
        ")",
        ",",
        "*digitp++ - '0'",
        "*digitp++",
        "*",
        "digitp++",
        "digitp",
        "++",
        "-",
        "'0'",
        "'",
        "'",
        ")",
        ";",
        "has_precision = 1;",
        "has_precision = 1",
        "has_precision",
        "=",
        "1",
        ";",
        "}",
        "}",
        "#endif",
        "/* Decide whether to handle the precision ourselves.  */",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "switch (dp->conversion)\n                  {\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n                  case 'd': case 'i': case 'u':\n                  case 'o':\n                  case 'x': case 'X': case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;\n                  default:\n                    prec_ourselves = 0;\n                    break;\n                  }",
        "{",
        "case 'd':",
        "case",
        "'d'",
        "'",
        "'",
        ":",
        "case 'i':",
        "case",
        "'i'",
        "'",
        "'",
        ":",
        "case 'u':",
        "case",
        "'u'",
        "'",
        "'",
        ":",
        "case 'o':",
        "case",
        "'o'",
        "'",
        "'",
        ":",
        "case 'x':",
        "case",
        "'x'",
        "'",
        "'",
        ":",
        "case 'X':",
        "case",
        "'X'",
        "'",
        "'",
        ":",
        "case 'p':\n                    prec_ourselves = has_precision && (precision > 0);\n                    break;",
        "case",
        "'p'",
        "'",
        "'",
        ":",
        "prec_ourselves = has_precision && (precision > 0);",
        "prec_ourselves = has_precision && (precision > 0)",
        "prec_ourselves",
        "=",
        "has_precision && (precision > 0)",
        "has_precision",
        "&&",
        "(precision > 0)",
        "(",
        "precision > 0",
        "precision",
        ">",
        "0",
        ")",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    prec_ourselves = 0;\n                    break;",
        "default",
        ":",
        "prec_ourselves = 0;",
        "prec_ourselves = 0",
        "prec_ourselves",
        "=",
        "0",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "/* Decide whether to perform the padding ourselves.  */",
        "#if !NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)\n                switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }\n#endif",
        "#if",
        "!NEED_PRINTF_FLAG_LEFTADJUST && (!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "!NEED_PRINTF_FLAG_LEFTADJUST",
        "!",
        "NEED_PRINTF_FLAG_LEFTADJUST",
        "&&",
        "(!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION)",
        "(",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "||",
        "NEED_PRINTF_FLAG_ZERO",
        "||",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        ")",
        "\n",
        "switch (dp->conversion)\n                  {\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "switch",
        "(dp->conversion)",
        "(",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ")",
        "{\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif\n# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif\n                    pad_ourselves = 1;\n                    break;\n                  default:\n                    pad_ourselves = prec_ourselves;\n                    break;\n                  }",
        "{",
        "# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */\n                  case 'c': case 's':\n# endif",
        "# if",
        "!DCHAR_IS_TCHAR || ENABLE_UNISTDIO",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "||",
        "ENABLE_UNISTDIO",
        "\n",
        "/* If we need conversion from TCHAR_T[] to DCHAR_T[], we need\n                     to perform the padding after this conversion.  Functions\n                     with unistdio extensions perform the padding based on\n                     character count rather than element count.  */",
        "case 'c':",
        "case",
        "'c'",
        "'",
        "'",
        ":",
        "case 's':",
        "case",
        "'s'",
        "'",
        "'",
        ":",
        "# endif",
        "# if NEED_PRINTF_FLAG_ZERO\n                  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':\n                  case 'a': case 'A':\n# endif",
        "# if",
        "NEED_PRINTF_FLAG_ZERO",
        "\n",
        "case 'f':",
        "case",
        "'f'",
        "'",
        "'",
        ":",
        "case 'F':",
        "case",
        "'F'",
        "'",
        "'",
        ":",
        "case 'e':",
        "case",
        "'e'",
        "'",
        "'",
        ":",
        "case 'E':",
        "case",
        "'E'",
        "'",
        "'",
        ":",
        "case 'g':",
        "case",
        "'g'",
        "'",
        "'",
        ":",
        "case 'G':",
        "case",
        "'G'",
        "'",
        "'",
        ":",
        "case 'a':",
        "case",
        "'a'",
        "'",
        "'",
        ":",
        "case 'A':",
        "case",
        "'A'",
        "'",
        "'",
        ":",
        "# endif",
        "pad_ourselves = 1;",
        "pad_ourselves = 1",
        "pad_ourselves",
        "=",
        "1",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    pad_ourselves = prec_ourselves;\n                    break;",
        "default",
        ":",
        "pad_ourselves = prec_ourselves;",
        "pad_ourselves = prec_ourselves",
        "pad_ourselves",
        "=",
        "prec_ourselves",
        ";",
        "break;",
        "break",
        ";",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                /* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */\n                tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);\n\n                if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "/* Allocate a temporary buffer of sufficient size for calling\n                   sprintf.  */",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves);",
        "tmp_length =\n                  MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index, dp->conversion, type,\n                                   flags, width, has_precision, precision,\n                                   pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "width",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))\n                  tmp = tmpbuf;\n                else\n                  {\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "if",
        "(tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))",
        "(",
        "tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "tmp_length",
        "<=",
        "sizeof (tmpbuf) / sizeof (TCHAR_T)",
        "sizeof (tmpbuf)",
        "sizeof",
        "(",
        "tmpbuf",
        "tmpbuf",
        ")",
        "/",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "tmp = tmpbuf;",
        "tmp = tmpbuf",
        "tmp",
        "=",
        "tmpbuf",
        ";",
        "else",
        "{\n                    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));\n\n                    if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;\n                    tmp = (TCHAR_T *) malloc (tmp_memsize);\n                    if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;\n                  }",
        "{",
        "size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));",
        "size_t",
        "tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T))",
        "tmp_memsize",
        "=",
        "xtimes (tmp_length, sizeof (TCHAR_T))",
        "xtimes",
        "(tmp_length, sizeof (TCHAR_T))",
        "(",
        "tmp_length",
        ",",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "if (size_overflow_p (tmp_memsize))\n                      /* Overflow, would lead to out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(size_overflow_p (tmp_memsize))",
        "(",
        "size_overflow_p (tmp_memsize)",
        "size_overflow_p",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ")",
        "/* Overflow, would lead to out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "tmp = (TCHAR_T *) malloc (tmp_memsize);",
        "tmp = (TCHAR_T *) malloc (tmp_memsize)",
        "tmp",
        "=",
        "(TCHAR_T *) malloc (tmp_memsize)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "malloc (tmp_memsize)",
        "malloc",
        "(tmp_memsize)",
        "(",
        "tmp_memsize",
        ")",
        ";",
        "if (tmp == NULL)\n                      /* Out of memory.  */\n                      goto out_of_memory;",
        "if",
        "(tmp == NULL)",
        "(",
        "tmp == NULL",
        "tmp",
        "==",
        "NULL",
        ")",
        "/* Out of memory.  */",
        "goto out_of_memory;",
        "goto",
        "out_of_memory",
        ";",
        "}",
        "#endif",
        "/* Construct the format string for calling snprintf or\n                   sprintf.  */",
        "fbp = buf;",
        "fbp = buf",
        "fbp",
        "=",
        "buf",
        ";",
        "*fbp++ = '%';",
        "*fbp++ = '%'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "#if NEED_PRINTF_FLAG_GROUPING\n                /* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */\n#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';\n#endif",
        "#if",
        "NEED_PRINTF_FLAG_GROUPING",
        "\n",
        "/* The underlying implementation doesn't support the ' flag.\n                   Produce no grouping characters in this case; this is\n                   acceptable because the grouping is locale dependent.  */",
        "#else\n                if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "#else",
        "if (flags & FLAG_GROUP)\n                  *fbp++ = '\\'';",
        "if",
        "(flags & FLAG_GROUP)",
        "(",
        "flags & FLAG_GROUP",
        "flags",
        "&",
        "FLAG_GROUP",
        ")",
        "*fbp++ = '\\'';",
        "*fbp++ = '\\''",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'\\''",
        "'",
        "\\'",
        "'",
        ";",
        "#endif",
        "if (flags & FLAG_LEFT)\n                  *fbp++ = '-';",
        "if",
        "(flags & FLAG_LEFT)",
        "(",
        "flags & FLAG_LEFT",
        "flags",
        "&",
        "FLAG_LEFT",
        ")",
        "*fbp++ = '-';",
        "*fbp++ = '-'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'-'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SHOWSIGN)\n                  *fbp++ = '+';",
        "if",
        "(flags & FLAG_SHOWSIGN)",
        "(",
        "flags & FLAG_SHOWSIGN",
        "flags",
        "&",
        "FLAG_SHOWSIGN",
        ")",
        "*fbp++ = '+';",
        "*fbp++ = '+'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'+'",
        "'",
        "'",
        ";",
        "if (flags & FLAG_SPACE)\n                  *fbp++ = ' ';",
        "if",
        "(flags & FLAG_SPACE)",
        "(",
        "flags & FLAG_SPACE",
        "flags",
        "&",
        "FLAG_SPACE",
        ")",
        "*fbp++ = ' ';",
        "*fbp++ = ' '",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "' '",
        "'",
        "'",
        ";",
        "if (flags & FLAG_ALT)\n                  *fbp++ = '#';",
        "if",
        "(flags & FLAG_ALT)",
        "(",
        "flags & FLAG_ALT",
        "flags",
        "&",
        "FLAG_ALT",
        ")",
        "*fbp++ = '#';",
        "*fbp++ = '#'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'#'",
        "'",
        "'",
        ";",
        "#if __GLIBC__ >= 2 && !defined __UCLIBC__\n                if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';\n#endif",
        "#if",
        "__GLIBC__ >= 2 && !defined __UCLIBC__",
        "__GLIBC__ >= 2",
        "__GLIBC__",
        ">=",
        "2",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        "\n",
        "if (flags & FLAG_LOCALIZED)\n                  *fbp++ = 'I';",
        "if",
        "(flags & FLAG_LOCALIZED)",
        "(",
        "flags & FLAG_LOCALIZED",
        "flags",
        "&",
        "FLAG_LOCALIZED",
        ")",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "#endif",
        "if (!pad_ourselves)\n                  {\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!pad_ourselves)",
        "(",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        ")",
        "{\n                    if (flags & FLAG_ZERO)\n                      *fbp++ = '0';\n                    if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (flags & FLAG_ZERO)\n                      *fbp++ = '0';",
        "if",
        "(flags & FLAG_ZERO)",
        "(",
        "flags & FLAG_ZERO",
        "flags",
        "&",
        "FLAG_ZERO",
        ")",
        "*fbp++ = '0';",
        "*fbp++ = '0'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "if (dp->width_start != dp->width_end)\n                      {\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->width_start != dp->width_end)",
        "(",
        "dp->width_start != dp->width_end",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        "!=",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        ")",
        "{\n                        size_t n = dp->width_end - dp->width_start;\n                        /* The width specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->width_end - dp->width_start;",
        "size_t",
        "n = dp->width_end - dp->width_start",
        "n",
        "=",
        "dp->width_end - dp->width_start",
        "dp->width_end",
        "dp",
        "->",
        "width_end",
        "-",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "/* The width specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->width_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->width_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->width_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->width_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->width_start",
        "dp",
        "->",
        "width_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "if (!prec_ourselves)\n                  {\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "if",
        "(!prec_ourselves)",
        "(",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        ")",
        "{\n                    if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }\n                  }",
        "{",
        "if (dp->precision_start != dp->precision_end)\n                      {\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "if",
        "(dp->precision_start != dp->precision_end)",
        "(",
        "dp->precision_start != dp->precision_end",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        "!=",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        ")",
        "{\n                        size_t n = dp->precision_end - dp->precision_start;\n                        /* The precision specification is known to consist only\n                           of standard ASCII characters.  */\n                        if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }\n                      }",
        "{",
        "size_t n = dp->precision_end - dp->precision_start;",
        "size_t",
        "n = dp->precision_end - dp->precision_start",
        "n",
        "=",
        "dp->precision_end - dp->precision_start",
        "dp->precision_end",
        "dp",
        "->",
        "precision_end",
        "-",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "/* The precision specification is known to consist only\n                           of standard ASCII characters.  */",
        "if (sizeof (FCHAR_T) == sizeof (TCHAR_T))\n                          {\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }\n                        else\n                          {\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "if",
        "(sizeof (FCHAR_T) == sizeof (TCHAR_T))",
        "(",
        "sizeof (FCHAR_T) == sizeof (TCHAR_T)",
        "sizeof (FCHAR_T)",
        "sizeof",
        "(FCHAR_T)",
        "(",
        "FCHAR_T",
        ")",
        "==",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "{\n                            memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));\n                            fbp += n;\n                          }",
        "{",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));",
        "memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "memcpy",
        "(fbp, dp->precision_start, n * sizeof (TCHAR_T))",
        "(",
        "fbp",
        ",",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ",",
        "n * sizeof (TCHAR_T)",
        "n",
        "*",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        ";",
        "fbp += n;",
        "fbp += n",
        "fbp",
        "+=",
        "n",
        ";",
        "}",
        "else",
        "{\n                            const FCHAR_T *mp = dp->precision_start;\n                            do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);\n                          }",
        "{",
        "const FCHAR_T *mp = dp->precision_start;",
        "const",
        "const",
        "FCHAR_T",
        "*mp = dp->precision_start",
        "*mp",
        "*",
        "mp",
        "=",
        "dp->precision_start",
        "dp",
        "->",
        "precision_start",
        ";",
        "do\n                              *fbp++ = (unsigned char) *mp++;\n                            while (--n > 0);",
        "do",
        "*fbp++ = (unsigned char) *mp++;",
        "*fbp++ = (unsigned char) *mp++",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "(unsigned char) *mp++",
        "(",
        "unsigned char",
        "unsigned char",
        "unsigned",
        "char",
        ")",
        "*mp++",
        "*",
        "mp++",
        "mp",
        "++",
        ";",
        "while",
        "(--n > 0)",
        "(",
        "--n > 0",
        "--n",
        "--",
        "n",
        ">",
        "0",
        ")",
        ";",
        "}",
        "}",
        "}",
        "switch (type)\n                  {\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif\n                  case TYPE_LONGINT:\n                  case TYPE_ULONGINT:\n#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif\n#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif\n                    *fbp++ = 'l';\n                    break;\n                  case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;\n                  default:\n                    break;\n                  }",
        "{",
        "#if HAVE_LONG_LONG_INT\n                  case TYPE_LONGLONGINT:\n                  case TYPE_ULONGLONGINT:\n# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "case TYPE_ULONGLONGINT:",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__\n                    *fbp++ = 'I';\n                    *fbp++ = '6';\n                    *fbp++ = '4';\n                    break;\n# else\n                    *fbp++ = 'l';\n                    /*FALLTHROUGH*/\n# endif",
        "# if",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        "\n",
        "*fbp++ = 'I';",
        "*fbp++ = 'I'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'I'",
        "'",
        "'",
        ";",
        "*fbp++ = '6';",
        "*fbp++ = '6'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'6'",
        "'",
        "'",
        ";",
        "*fbp++ = '4';",
        "*fbp++ = '4'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'4'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "# else\n                    *fbp++ = 'l';",
        "# else",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "/*FALLTHROUGH*/",
        "# endif",
        "#endif",
        "case TYPE_LONGINT:",
        "case",
        "TYPE_LONGINT",
        ":",
        "case TYPE_ULONGINT:",
        "case",
        "TYPE_ULONGINT",
        ":",
        "#if HAVE_WINT_T\n                  case TYPE_WIDE_CHAR:\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "#endif",
        "#if HAVE_WCHAR_T\n                  case TYPE_WIDE_STRING:\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "#endif",
        "*fbp++ = 'l';",
        "*fbp++ = 'l'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'l'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                    *fbp++ = 'L';\n                    break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "*fbp++ = 'L';",
        "*fbp++ = 'L'",
        "*fbp++",
        "*",
        "fbp++",
        "fbp",
        "++",
        "=",
        "'L'",
        "'",
        "'",
        ";",
        "break;",
        "break",
        ";",
        "default:\n                    break;",
        "default",
        ":",
        "break;",
        "break",
        ";",
        "}",
        "#if NEED_PRINTF_DIRECTIVE_F\n                if (dp->conversion == 'F')\n                  *fbp = 'f';\n                else\n#endif",
        "#if",
        "NEED_PRINTF_DIRECTIVE_F",
        "\n",
        "if (dp->conversion == 'F')\n                  *fbp = 'f';",
        "if",
        "(dp->conversion == 'F')",
        "(",
        "dp->conversion == 'F'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'F'",
        "'",
        "'",
        ")",
        "*fbp = 'f';",
        "*fbp = 'f'",
        "*fbp",
        "*",
        "fbp",
        "=",
        "'f'",
        "'",
        "'",
        ";",
        "else",
        "else",
        "#endif",
        "*fbp = dp->conversion;",
        "*fbp = dp->conversion",
        "*fbp",
        "*",
        "fbp",
        "=",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ";",
        "#if USE_SNPRINTF\n# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif\n#else\n                fbp[1] = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "# if !(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))\n                fbp[1] = '%';\n                fbp[2] = 'n';\n                fbp[3] = '\\0';\n# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';\n# endif",
        "# if",
        "!(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "!",
        "(((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__))",
        "(",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__) || ((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "((__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__)",
        "(",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)) && !defined __UCLIBC__",
        "(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))",
        "(",
        "__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "__GLIBC__ > 2",
        "__GLIBC__",
        ">",
        "2",
        "||",
        "(__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3)",
        "(",
        "__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3",
        "__GLIBC__ == 2",
        "__GLIBC__",
        "==",
        "2",
        "&&",
        "__GLIBC_MINOR__ >= 3",
        "__GLIBC_MINOR__",
        ">=",
        "3",
        ")",
        ")",
        "&&",
        "!defined __UCLIBC__",
        "!",
        "defined __UCLIBC__",
        "defined",
        "__UCLIBC__",
        ")",
        "||",
        "((defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__)",
        "(",
        "(defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__",
        "(defined _WIN32 || defined __WIN32__)",
        "(",
        "defined _WIN32 || defined __WIN32__",
        "defined _WIN32",
        "defined",
        "_WIN32",
        "||",
        "defined __WIN32__",
        "defined",
        "__WIN32__",
        ")",
        "&&",
        "! defined __CYGWIN__",
        "!",
        "defined __CYGWIN__",
        "defined",
        "__CYGWIN__",
        ")",
        ")",
        "\n",
        "fbp[1] = '%';",
        "fbp[1] = '%'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'%'",
        "'",
        "'",
        ";",
        "fbp[2] = 'n';",
        "fbp[2] = 'n'",
        "fbp[2]",
        "fbp",
        "[",
        "2",
        "]",
        "=",
        "'n'",
        "'",
        "'",
        ";",
        "fbp[3] = '\\0';",
        "fbp[3] = '\\0'",
        "fbp[3]",
        "fbp",
        "[",
        "3",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# else\n                /* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */\n                /* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */\n                fbp[1] = '\\0';",
        "# else",
        "/* On glibc2 systems from glibc >= 2.3 - probably also older\n                   ones - we know that snprintf's return value conforms to\n                   ISO C 99: the tests gl_SNPRINTF_RETVAL_C99 and\n                   gl_SNPRINTF_TRUNCATION_C99 pass.\n                   Therefore we can avoid using %n in this situation.\n                   On glibc2 systems from 2004-10-18 or newer, the use of %n\n                   in format strings in writable memory may crash the program\n                   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it\n                   in this situation.  */",
        "/* On native Windows systems (such as mingw), we can avoid using\n                   %n because:\n                     - Although the gl_SNPRINTF_TRUNCATION_C99 test fails,\n                       snprintf does not write more than the specified number\n                       of bytes. (snprintf (buf, 3, \"%d %d\", 4567, 89) writes\n                       '4', '5', '6' into buf, not '4', '5', '\\0'.)\n                     - Although the gl_SNPRINTF_RETVAL_C99 test fails, snprintf\n                       allows us to recognize the case of an insufficient\n                       buffer size: it returns -1 in this case.\n                   On native Windows systems (such as mingw) where the OS is\n                   Windows Vista, the use of %n in format strings by default\n                   crashes the program. See\n                     <http://gcc.gnu.org/ml/gcc/2007-06/msg00122.html> and\n                     <http://msdn2.microsoft.com/en-us/library/ms175782(VS.80).aspx>\n                   So we should avoid %n in this situation.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "# endif",
        "#else\n                fbp[1] = '\\0';",
        "#else",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "/* Construct the arguments for calling snprintf or sprintf.  */",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "if (!pad_ourselves && dp->width_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "if",
        "(!pad_ourselves && dp->width_arg_index != ARG_NONE)",
        "(",
        "!pad_ourselves && dp->width_arg_index != ARG_NONE",
        "!pad_ourselves",
        "!",
        "pad_ourselves",
        "&&",
        "dp->width_arg_index != ARG_NONE",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->width_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->width_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->width_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->width_arg_index].type == TYPE_INT",
        "a.arg[dp->width_arg_index].type",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->width_arg_index].a.a_int",
        "a.arg[dp->width_arg_index].a",
        "a.arg[dp->width_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->width_arg_index",
        "dp",
        "->",
        "width_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "if (!prec_ourselves && dp->precision_arg_index != ARG_NONE)\n                  {\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "if",
        "(!prec_ourselves && dp->precision_arg_index != ARG_NONE)",
        "(",
        "!prec_ourselves && dp->precision_arg_index != ARG_NONE",
        "!prec_ourselves",
        "!",
        "prec_ourselves",
        "&&",
        "dp->precision_arg_index != ARG_NONE",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "!=",
        "ARG_NONE",
        ")",
        "{\n                    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();\n                    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;\n                  }",
        "{",
        "if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))\n                      abort ();",
        "if",
        "(!(a.arg[dp->precision_arg_index].type == TYPE_INT))",
        "(",
        "!(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "!",
        "(a.arg[dp->precision_arg_index].type == TYPE_INT)",
        "(",
        "a.arg[dp->precision_arg_index].type == TYPE_INT",
        "a.arg[dp->precision_arg_index].type",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "type",
        "==",
        "TYPE_INT",
        ")",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;",
        "prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int",
        "prefixes[prefix_count++]",
        "prefixes",
        "[",
        "prefix_count++",
        "prefix_count",
        "++",
        "]",
        "=",
        "a.arg[dp->precision_arg_index].a.a_int",
        "a.arg[dp->precision_arg_index].a",
        "a.arg[dp->precision_arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->precision_arg_index",
        "dp",
        "->",
        "precision_arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "}",
        "#if USE_SNPRINTF\n                /* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */\n# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n                /* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */\n                ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));\n                /* Prepare checking whether snprintf returns the count\n                   via %n.  */\n                *(TCHAR_T *) (result + length) = '\\0';\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* The SNPRINTF result is appended after result[0..length].\n                   The latter is an array of DCHAR_T; SNPRINTF appends an\n                   array of TCHAR_T to it.  This is possible because\n                   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and\n                   alignof (TCHAR_T) <= alignof (DCHAR_T).  */",
        "# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))\n",
        "# define",
        "TCHARS_PER_DCHAR",
        " (sizeof (DCHAR_T) / sizeof (TCHAR_T))",
        "\n",
        "/* Ensure that maxlen below will be >= 2.  Needed on BeOS,\n                   where an snprintf() with maxlen==1 acts like sprintf().  */",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR));",
        "ENSURE_ALLOCATION (xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "ENSURE_ALLOCATION",
        "(xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR))",
        "(",
        "xsum (length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                         (2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(2 + TCHARS_PER_DCHAR - 1)\n                                         / TCHARS_PER_DCHAR",
        "(2 + TCHARS_PER_DCHAR - 1)",
        "(",
        "2 + TCHARS_PER_DCHAR - 1",
        "2 + TCHARS_PER_DCHAR",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ")",
        ";",
        "/* Prepare checking whether snprintf returns the count\n                   via %n.  */",
        "*(TCHAR_T *) (result + length) = '\\0';",
        "*(TCHAR_T *) (result + length) = '\\0'",
        "*(TCHAR_T *) (result + length)",
        "*",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "#endif",
        "orig_errno = errno;",
        "orig_errno = errno",
        "orig_errno",
        "=",
        "errno",
        ";",
        "for (;;)\n                  {\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "for",
        "(",
        ";",
        ";",
        ")",
        "{\n                    int count = -1;\n\n#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif\n\n                    errno = 0;\n                    switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }\n\n#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif\n\n                    /* Attempt to handle failure.  */\n                    if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }\n\n#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif\n\n#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif\n\n#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif\n\n#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif\n\n#if DCHAR_IS_TCHAR && !USE_SNPRINTF\n                    /* Make room for the result.  */\n                    if (count > allocated - length)\n                      {\n                        /* Need at least count elements.  But allocate\n                           proportionally.  */\n                        size_t n =\n                          xmax (xsum (length, count), xtimes (allocated, 2));\n\n                        ENSURE_ALLOCATION (n);\n                      }\n#endif\n\n                    /* Here count <= allocated - length.  */\n\n                    /* Perform padding.  */\n#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_LEFTADJUST || NEED_PRINTF_FLAG_ZERO || NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (pad_ourselves && has_width)\n                      {\n                        size_t w;\n# if ENABLE_UNISTDIO\n                        /* Outside POSIX, it's preferable to compare the width\n                           against the number of _characters_ of the converted\n                           value.  */\n                        w = DCHAR_MBSNLEN (result + length, count);\n# else\n                        /* The width is compared against the number of _bytes_\n                           of the converted value, says POSIX.  */\n                        w = count;\n# endif\n                        if (w < width)\n                          {\n                            size_t pad = width - w;\n\n                            /* Make room for the result.  */\n                            if (xsum (count, pad) > allocated - length)\n                              {\n                                /* Need at least count + pad elements.  But\n                                   allocate proportionally.  */\n                                size_t n =\n                                  xmax (xsum3 (length, count, pad),\n                                        xtimes (allocated, 2));\n\n# if USE_SNPRINTF\n                                length += count;\n                                ENSURE_ALLOCATION (n);\n                                length -= count;\n# else\n                                ENSURE_ALLOCATION (n);\n# endif\n                              }\n                            /* Here count + pad <= allocated - length.  */\n\n                            {\n# if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                              DCHAR_T * const rp = result + length;\n# else\n                              DCHAR_T * const rp = tmp;\n# endif\n                              DCHAR_T *p = rp + count;\n                              DCHAR_T *end = p + pad;\n                              DCHAR_T *pad_ptr;\n# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO\n                              if (dp->conversion == 'c'\n                                  || dp->conversion == 's')\n                                /* No zero-padding for string directives.  */\n                                pad_ptr = NULL;\n                              else\n# endif\n                                {\n                                  pad_ptr = (*rp == '-' ? rp + 1 : rp);\n                                  /* No zero-padding of \"inf\" and \"nan\".  */\n                                  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')\n                                      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))\n                                    pad_ptr = NULL;\n                                }\n                              /* The generated string now extends from rp to p,\n                                 with the zero padding insertion point being at\n                                 pad_ptr.  */\n\n                              count = count + pad; /* = end - rp */\n\n                              if (flags & FLAG_LEFT)\n                                {\n                                  /* Pad with spaces on the right.  */\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                              else if ((flags & FLAG_ZERO) && pad_ptr != NULL)\n                                {\n                                  /* Pad with zeroes.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > pad_ptr)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = '0';\n                                }\n                              else\n                                {\n                                  /* Pad with spaces on the left.  */\n                                  DCHAR_T *q = end;\n\n                                  while (p > rp)\n                                    *--q = *--p;\n                                  for (; pad > 0; pad--)\n                                    *p++ = ' ';\n                                }\n                            }\n                          }\n                      }\n#endif\n\n                    /* Here still count <= allocated - length.  */\n\n#if !DCHAR_IS_TCHAR || USE_SNPRINTF\n                    /* The snprintf() result did fit.  */\n#else\n                    /* Append the sprintf() result.  */\n                    memcpy (result + length, tmp, count * sizeof (DCHAR_T));\n#endif\n#if !USE_SNPRINTF\n                    if (tmp != tmpbuf)\n                      free (tmp);\n#endif\n\n#if NEED_PRINTF_DIRECTIVE_F\n                    if (dp->conversion == 'F')\n                      {\n                        /* Convert the %f result to upper case for %F.  */\n                        DCHAR_T *rp = result + length;\n                        size_t rc;\n                        for (rc = count; rc > 0; rc--, rp++)\n                          if (*rp >= 'a' && *rp <= 'z')\n                            *rp = *rp - 'a' + 'A';\n                      }\n#endif\n\n                    length += count;\n                    break;\n                  }",
        "{",
        "int count = -1;",
        "int",
        "count = -1",
        "count",
        "=",
        "-1",
        ";",
        "#if USE_SNPRINTF\n                    int retcount = 0;\n                    size_t maxlen = allocated - length;\n                    /* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */\n                    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;\n                    maxlen = maxlen * TCHARS_PER_DCHAR;\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "int retcount = 0;",
        "int",
        "retcount = 0",
        "retcount",
        "=",
        "0",
        ";",
        "size_t maxlen = allocated - length;",
        "size_t",
        "maxlen = allocated - length",
        "maxlen",
        "=",
        "allocated - length",
        "allocated",
        "-",
        "length",
        ";",
        "/* SNPRINTF can fail if its second argument is\n                       > INT_MAX.  */",
        "if (maxlen > INT_MAX / TCHARS_PER_DCHAR)\n                      maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "if",
        "(maxlen > INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen > INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        ">",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR;",
        "maxlen = INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "maxlen = maxlen * TCHARS_PER_DCHAR;",
        "maxlen = maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "=",
        "maxlen * TCHARS_PER_DCHAR",
        "maxlen",
        "*",
        "TCHARS_PER_DCHAR",
        ";",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             arg, &count);                  \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], arg, &count);     \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        retcount = SNPRINTF ((TCHAR_T *) (result + length), \\\n                                             maxlen, buf,                   \\\n                                             prefixes[0], prefixes[1], arg, \\\n                                             &count);                       \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#else\n# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "#else",
        "# define SNPRINTF_BUF(arg) \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }\n",
        "# define",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        " \\\n                    switch (prefix_count)                                   \\\n                      {                                                     \\\n                      case 0:                                               \\\n                        count = sprintf (tmp, buf, arg);                    \\\n                        break;                                              \\\n                      case 1:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], arg);       \\\n                        break;                                              \\\n                      case 2:                                               \\\n                        count = sprintf (tmp, buf, prefixes[0], prefixes[1],\\\n                                         arg);                              \\\n                        break;                                              \\\n                      default:                                              \\\n                        abort ();                                           \\\n                      }",
        "\n",
        "#endif",
        "errno = 0;",
        "errno = 0",
        "errno",
        "=",
        "0",
        ";",
        "switch (type)\n                      {\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "switch",
        "(type)",
        "(",
        "type",
        ")",
        "{\n                      case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif\n                      case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      default:\n                        abort ();\n                      }",
        "{",
        "case TYPE_SCHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SCHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_schar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_schar;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_schar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_schar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_schar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UCHAR:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UCHAR",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uchar;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uchar;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uchar",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uchar",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uchar",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_SHORT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_SHORT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_short;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_short;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_short",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_short",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_short",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_USHORT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_USHORT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_ushort;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_ushort;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ushort",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ushort",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ushort",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_INT:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_INT",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_int;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_int;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_int",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_int",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_int",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_UINT:\n                        {\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_UINT",
        ":",
        "{\n                          unsigned int arg = a.arg[dp->arg_index].a.a_uint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned int arg = a.arg[dp->arg_index].a.a_uint;",
        "unsigned int",
        "unsigned",
        "int",
        "arg = a.arg[dp->arg_index].a.a_uint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_uint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_uint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGINT:\n                        {\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGINT",
        ":",
        "{\n                          long int arg = a.arg[dp->arg_index].a.a_longint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long int arg = a.arg[dp->arg_index].a.a_longint;",
        "long int",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGINT:\n                        {\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGINT",
        ":",
        "{\n                          unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;",
        "unsigned long int",
        "unsigned",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_LONG_LONG_INT\n                      case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n                      case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_LONG_LONG_INT",
        "\n",
        "case TYPE_LONGLONGINT:\n                        {\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGLONGINT",
        ":",
        "{\n                          long long int arg = a.arg[dp->arg_index].a.a_longlongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long long int arg = a.arg[dp->arg_index].a.a_longlongint;",
        "long long int",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_longlongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longlongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longlongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_ULONGLONGINT:\n                        {\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_ULONGLONGINT",
        ":",
        "{\n                          unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;",
        "unsigned long long int",
        "unsigned",
        "long",
        "long",
        "int",
        "arg = a.arg[dp->arg_index].a.a_ulonglongint",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_ulonglongint",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_ulonglongint",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_DOUBLE:\n                        {\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_DOUBLE",
        ":",
        "{\n                          double arg = a.arg[dp->arg_index].a.a_double;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "double arg = a.arg[dp->arg_index].a.a_double;",
        "double",
        "arg = a.arg[dp->arg_index].a.a_double",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_double",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_double",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_LONGDOUBLE:\n                        {\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_LONGDOUBLE",
        ":",
        "{\n                          long double arg = a.arg[dp->arg_index].a.a_longdouble;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "long double arg = a.arg[dp->arg_index].a.a_longdouble;",
        "long double",
        "long",
        "double",
        "arg = a.arg[dp->arg_index].a.a_longdouble",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_longdouble",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_longdouble",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "case TYPE_CHAR:\n                        {\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_CHAR",
        ":",
        "{\n                          int arg = a.arg[dp->arg_index].a.a_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "int arg = a.arg[dp->arg_index].a.a_char;",
        "int",
        "arg = a.arg[dp->arg_index].a.a_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WINT_T\n                      case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WINT_T",
        "\n",
        "case TYPE_WIDE_CHAR:\n                        {\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_CHAR",
        ":",
        "{\n                          wint_t arg = a.arg[dp->arg_index].a.a_wide_char;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "wint_t arg = a.arg[dp->arg_index].a.a_wide_char;",
        "wint_t",
        "arg = a.arg[dp->arg_index].a.a_wide_char",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_char",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_char",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_STRING:\n                        {\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_STRING",
        ":",
        "{\n                          const char *arg = a.arg[dp->arg_index].a.a_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const char *arg = a.arg[dp->arg_index].a.a_string;",
        "const",
        "const",
        "char",
        "*arg = a.arg[dp->arg_index].a.a_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#if HAVE_WCHAR_T\n                      case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;\n#endif",
        "#if",
        "HAVE_WCHAR_T",
        "\n",
        "case TYPE_WIDE_STRING:\n                        {\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_WIDE_STRING",
        ":",
        "{\n                          const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;",
        "const",
        "const",
        "wchar_t",
        "*arg = a.arg[dp->arg_index].a.a_wide_string",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_wide_string",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_wide_string",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "#endif",
        "case TYPE_POINTER:\n                        {\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }\n                        break;",
        "case",
        "TYPE_POINTER",
        ":",
        "{\n                          void *arg = a.arg[dp->arg_index].a.a_pointer;\n                          SNPRINTF_BUF (arg);\n                        }",
        "{",
        "void *arg = a.arg[dp->arg_index].a.a_pointer;",
        "void",
        "*arg = a.arg[dp->arg_index].a.a_pointer",
        "*arg",
        "*",
        "arg",
        "=",
        "a.arg[dp->arg_index].a.a_pointer",
        "a.arg[dp->arg_index].a",
        "a.arg[dp->arg_index]",
        "a.arg",
        "a",
        ".",
        "arg",
        "[",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        "]",
        ".",
        "a",
        ".",
        "a_pointer",
        ";",
        "SNPRINTF_BUF (arg);",
        "SNPRINTF_BUF (arg)",
        "SNPRINTF_BUF",
        "(arg)",
        "(",
        "arg",
        ")",
        ";",
        "}",
        "break;",
        "break",
        ";",
        "default:\n                        abort ();",
        "default",
        ":",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */\n                    if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Portability: Not all implementations of snprintf()\n                       are ISO C 99 compliant.  Determine the number of\n                       bytes that snprintf() has produced or would have\n                       produced.  */",
        "if (count >= 0)\n                      {\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }\n                    else\n                      {\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "if",
        "(count >= 0)",
        "(",
        "count >= 0",
        "count",
        ">=",
        "0",
        ")",
        "{\n                        /* Verify that snprintf() has NUL-terminated its\n                           result.  */\n                        if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();\n                        /* Portability hack.  */\n                        if (retcount > count)\n                          count = retcount;\n                      }",
        "{",
        "/* Verify that snprintf() has NUL-terminated its\n                           result.  */",
        "if (count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')\n                          abort ();",
        "if",
        "(count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0')",
        "(",
        "count < maxlen\n                            && ((TCHAR_T *) (result + length)) [count] != '\\0'",
        "count < maxlen",
        "count",
        "<",
        "maxlen",
        "&&",
        "((TCHAR_T *) (result + length)) [count] != '\\0'",
        "((TCHAR_T *) (result + length)) [count]",
        "((TCHAR_T *) (result + length))",
        "(",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ")",
        "[",
        "count",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "/* Portability hack.  */",
        "if (retcount > count)\n                          count = retcount;",
        "if",
        "(retcount > count)",
        "(",
        "retcount > count",
        "retcount",
        ">",
        "count",
        ")",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "else",
        "{\n                        /* snprintf() doesn't understand the '%n'\n                           directive.  */\n                        if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }\n                      }",
        "{",
        "/* snprintf() doesn't understand the '%n'\n                           directive.  */",
        "if (fbp[1] != '\\0')\n                          {\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }\n                        else\n                          {\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "if",
        "(fbp[1] != '\\0')",
        "(",
        "fbp[1] != '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "!=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ")",
        "{\n                            /* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */\n                            fbp[1] = '\\0';\n                            continue;\n                          }",
        "{",
        "/* Don't use the '%n' directive; instead, look\n                               at the snprintf() return value.  */",
        "fbp[1] = '\\0';",
        "fbp[1] = '\\0'",
        "fbp[1]",
        "fbp",
        "[",
        "1",
        "]",
        "=",
        "'\\0'",
        "'",
        "\\0",
        "'",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "else",
        "{\n                            /* Look at the snprintf() return value.  */\n                            if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;\n                          }",
        "{",
        "/* Look at the snprintf() return value.  */",
        "if (retcount < 0)\n                              {\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }\n                            else\n                              count = retcount;",
        "if",
        "(retcount < 0)",
        "(",
        "retcount < 0",
        "retcount",
        "<",
        "0",
        ")",
        "{\n# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif\n                              }",
        "{",
        "# if !HAVE_SNPRINTF_RETVAL_C99\n                                /* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */\n                                size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);\n\n                                if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }\n# endif",
        "# if",
        "!HAVE_SNPRINTF_RETVAL_C99",
        "!",
        "HAVE_SNPRINTF_RETVAL_C99",
        "\n",
        "/* HP-UX 10.20 snprintf() is doubly deficient:\n                                   It doesn't understand the '%n' directive,\n                                   *and* it returns -1 (rather than the length\n                                   that would have been required) when the\n                                   buffer is too small.\n                                   But a failure at this point can also come\n                                   from other reasons than a too small buffer,\n                                   such as an invalid wide string argument to\n                                   the %ls directive, or possibly an invalid\n                                   floating-point argument.  */",
        "size_t tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves);",
        "size_t",
        "tmp_length =\n                                  MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "tmp_length",
        "=",
        "MAX_ROOM_NEEDED (&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "MAX_ROOM_NEEDED",
        "(&a, dp->arg_index,\n                                                   dp->conversion, type, flags,\n                                                   has_width ? width : 0,\n                                                   has_precision,\n                                                   precision, pad_ourselves)",
        "(",
        "&a",
        "&",
        "a",
        ",",
        "dp->arg_index",
        "dp",
        "->",
        "arg_index",
        ",",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        ",",
        "type",
        ",",
        "flags",
        ",",
        "has_width ? width : 0",
        "has_width",
        "?",
        "width",
        ":",
        "0",
        ",",
        "has_precision",
        ",",
        "precision",
        ",",
        "pad_ourselves",
        ")",
        ";",
        "if (maxlen < tmp_length)\n                                  {\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "if",
        "(maxlen < tmp_length)",
        "(",
        "maxlen < tmp_length",
        "maxlen",
        "<",
        "tmp_length",
        ")",
        "{\n                                    /* Make more room.  But try to do through\n                                       this reallocation only once.  */\n                                    size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);\n                                    /* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */\n                                    size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);\n                                    if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;\n                                    ENSURE_ALLOCATION (bigger_need);\n                                    continue;\n                                  }",
        "{",
        "/* Make more room.  But try to do through\n                                       this reallocation only once.  */",
        "size_t bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR);",
        "size_t",
        "bigger_need =\n                                      xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "bigger_need",
        "=",
        "xsum (length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                            xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)\n                                            / TCHARS_PER_DCHAR",
        "xsum (tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "xsum",
        "(tmp_length,\n                                                  TCHARS_PER_DCHAR - 1)",
        "(",
        "tmp_length",
        ",",
        "TCHARS_PER_DCHAR - 1",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "/* And always grow proportionally.\n                                       (There may be several arguments, each\n                                       needing a little more room than the\n                                       previous one.)  */",
        "size_t bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12);",
        "size_t",
        "bigger_need2 =\n                                      xsum (xtimes (allocated, 2), 12)",
        "bigger_need2",
        "=",
        "xsum (xtimes (allocated, 2), 12)",
        "xsum",
        "(xtimes (allocated, 2), 12)",
        "(",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ",",
        "12",
        ")",
        ";",
        "if (bigger_need < bigger_need2)\n                                      bigger_need = bigger_need2;",
        "if",
        "(bigger_need < bigger_need2)",
        "(",
        "bigger_need < bigger_need2",
        "bigger_need",
        "<",
        "bigger_need2",
        ")",
        "bigger_need = bigger_need2;",
        "bigger_need = bigger_need2",
        "bigger_need",
        "=",
        "bigger_need2",
        ";",
        "ENSURE_ALLOCATION (bigger_need);",
        "ENSURE_ALLOCATION (bigger_need)",
        "ENSURE_ALLOCATION",
        "(bigger_need)",
        "(",
        "bigger_need",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "# endif",
        "}",
        "else",
        "count = retcount;",
        "count = retcount",
        "count",
        "=",
        "retcount",
        ";",
        "}",
        "}",
        "#endif",
        "/* Attempt to handle failure.  */",
        "if (count < 0)\n                      {\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "if",
        "(count < 0)",
        "(",
        "count < 0",
        "count",
        "<",
        "0",
        ")",
        "{\n                        /* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */\n                        int saved_errno = errno;\n\n                        if (!(result == resultbuf || result == NULL))\n                          free (result);\n                        if (buf_malloced != NULL)\n                          free (buf_malloced);\n                        CLEANUP ();\n                        errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));\n                        return NULL;\n                      }",
        "{",
        "/* SNPRINTF or sprintf failed.  Save and use the errno\n                           that it has set, if any.  */",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                          free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                          free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL));",
        "errno =\n                          (saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "errno",
        "=",
        "(saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL))",
        "(",
        "saved_errno != 0\n                           ? saved_errno\n                           : (dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "saved_errno != 0",
        "saved_errno",
        "!=",
        "0",
        "?",
        "saved_errno",
        ":",
        "(dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL)",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'\n                              ? EILSEQ\n                              : EINVAL",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        "?",
        "EILSEQ",
        ":",
        "EINVAL",
        ")",
        ")",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "#if USE_SNPRINTF\n                    /* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */\n                    if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }\n#endif",
        "#if",
        "USE_SNPRINTF",
        "\n",
        "/* Handle overflow of the allocated buffer.\n                       If such an overflow occurs, a C99 compliant snprintf()\n                       returns a count >= maxlen.  However, a non-compliant\n                       snprintf() function returns only count = maxlen - 1.  To\n                       cover both cases, test whether count >= maxlen - 1.  */",
        "if ((unsigned int) count + 1 >= maxlen)\n                      {\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "if",
        "((unsigned int) count + 1 >= maxlen)",
        "(",
        "(unsigned int) count + 1 >= maxlen",
        "(unsigned int) count + 1",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "1",
        ">=",
        "maxlen",
        ")",
        "{\n                        /* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */\n                        if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }\n                      }",
        "{",
        "/* If maxlen already has attained its allowed maximum,\n                           allocating more memory will not increase maxlen.\n                           Instead of looping, bail out.  */",
        "if (maxlen == INT_MAX / TCHARS_PER_DCHAR)\n                          goto overflow;\n                        else\n                          {\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "if",
        "(maxlen == INT_MAX / TCHARS_PER_DCHAR)",
        "(",
        "maxlen == INT_MAX / TCHARS_PER_DCHAR",
        "maxlen",
        "==",
        "INT_MAX / TCHARS_PER_DCHAR",
        "INT_MAX",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        "goto overflow;",
        "goto",
        "overflow",
        ";",
        "else",
        "{\n                            /* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */\n                            size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));\n\n                            ENSURE_ALLOCATION (n);\n                            continue;\n                          }",
        "{",
        "/* Need at least (count + 1) * sizeof (TCHAR_T)\n                               bytes.  (The +1 is for the trailing NUL.)\n                               But ask for (count + 2) * sizeof (TCHAR_T)\n                               bytes, so that in the next round, we likely get\n                                 maxlen > (unsigned int) count + 1\n                               and so we don't get here again.\n                               And allocate proportionally, to avoid looping\n                               eternally if snprintf() reports a too small\n                               count.  */",
        "size_t n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2));",
        "size_t",
        "n =\n                              xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "n",
        "=",
        "xmax (xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "xmax",
        "(xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR),\n                                    xtimes (allocated, 2))",
        "(",
        "xsum (length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                          ((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)\n                                          / TCHARS_PER_DCHAR",
        "((unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1)",
        "(",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR - 1",
        "(unsigned int) count + 2\n                                           + TCHARS_PER_DCHAR",
        "(unsigned int) count + 2",
        "(unsigned int) count",
        "(",
        "unsigned int",
        "unsigned int",
        "unsigned",
        "int",
        ")",
        "count",
        "+",
        "2",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ",",
        "xtimes (allocated, 2)",
        "xtimes",
        "(allocated, 2)",
        "(",
        "allocated",
        ",",
        "2",
        ")",
        ")",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "continue;",
        "continue",
        ";",
        "}",
        "}",
        "#endif",
        "#if NEED_PRINTF_UNBOUNDED_PRECISION\n                    if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }\n#endif",
        "#if",
        "NEED_PRINTF_UNBOUNDED_PRECISION",
        "\n",
        "if (prec_ourselves)\n                      {\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "if",
        "(prec_ourselves)",
        "(",
        "prec_ourselves",
        ")",
        "{\n                        /* Handle the precision.  */\n                        TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);\n# else\n                          tmp;\n# endif\n                        size_t prefix_count;\n                        size_t move;\n\n                        prefix_count = 0;\n                        /* Put the additional zeroes after the sign.  */\n                        if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;\n\n                        move = count - prefix_count;\n                        if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }\n                      }",
        "{",
        "/* Handle the precision.  */",
        "TCHAR_T *prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length);",
        "TCHAR_T",
        "*prec_ptr =\n# if USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "=",
        "# if",
        "# if",
        "USE_SNPRINTF\n                          (TCHAR_T *) (result + length)",
        "USE_SNPRINTF\n                          (TCHAR_T *)",
        "USE_SNPRINTF",
        "(TCHAR_T *)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                          tmp;\n",
        "# else",
        "\n                          tmp;",
        "\n",
        "# endif\n                        size_t prefix_count;\n",
        "# endif",
        "\n                        size_t prefix_count;",
        "\n",
        "size_t move;",
        "size_t",
        "move",
        ";",
        "prefix_count = 0;",
        "prefix_count = 0",
        "prefix_count",
        "=",
        "0",
        ";",
        "/* Put the additional zeroes after the sign.  */",
        "if (count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))\n                          prefix_count = 1;\n                        /* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */\n                        else if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '))",
        "(",
        "count >= 1\n                            && (*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "count >= 1",
        "count",
        ">=",
        "1",
        "&&",
        "(*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' ')",
        "(",
        "*prec_ptr == '-' || *prec_ptr == '+'\n                                || *prec_ptr == ' '",
        "*prec_ptr == '-' || *prec_ptr == '+'",
        "*prec_ptr == '-'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'-'",
        "'",
        "'",
        "||",
        "*prec_ptr == '+'",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "'+'",
        "'",
        "'",
        "||",
        "*prec_ptr == ' '",
        "*prec_ptr",
        "*",
        "prec_ptr",
        "==",
        "' '",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 1;",
        "prefix_count = 1",
        "prefix_count",
        "=",
        "1",
        ";",
        "/* Put the additional zeroes after the 0x prefix if\n                           (flags & FLAG_ALT) || (dp->conversion == 'p').  */",
        "else",
        "if (count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))\n                          prefix_count = 2;",
        "if",
        "(count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X'))",
        "(",
        "count >= 2\n                                 && prec_ptr[0] == '0'\n                                 && (prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "count >= 2\n                                 && prec_ptr[0] == '0'",
        "count >= 2",
        "count",
        ">=",
        "2",
        "&&",
        "prec_ptr[0] == '0'",
        "prec_ptr[0]",
        "prec_ptr",
        "[",
        "0",
        "]",
        "==",
        "'0'",
        "'",
        "'",
        "&&",
        "(prec_ptr[1] == 'x' || prec_ptr[1] == 'X')",
        "(",
        "prec_ptr[1] == 'x' || prec_ptr[1] == 'X'",
        "prec_ptr[1] == 'x'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'x'",
        "'",
        "'",
        "||",
        "prec_ptr[1] == 'X'",
        "prec_ptr[1]",
        "prec_ptr",
        "[",
        "1",
        "]",
        "==",
        "'X'",
        "'",
        "'",
        ")",
        ")",
        "prefix_count = 2;",
        "prefix_count = 2",
        "prefix_count",
        "=",
        "2",
        ";",
        "move = count - prefix_count;",
        "move = count - prefix_count",
        "move",
        "=",
        "count - prefix_count",
        "count",
        "-",
        "prefix_count",
        ";",
        "if (precision > move)\n                          {\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "if",
        "(precision > move)",
        "(",
        "precision > move",
        "precision",
        ">",
        "move",
        ")",
        "{\n                            /* Insert zeroes.  */\n                            size_t insert = precision - move;\n                            TCHAR_T *prec_end;\n\n# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif\n\n                            prec_end = prec_ptr + count;\n                            prec_ptr += prefix_count;\n\n                            while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }\n\n                            prec_end += insert;\n                            do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);\n\n                            count += insert;\n                          }",
        "{",
        "/* Insert zeroes.  */",
        "size_t insert = precision - move;",
        "size_t",
        "insert = precision - move",
        "insert",
        "=",
        "precision - move",
        "precision",
        "-",
        "move",
        ";",
        "TCHAR_T *prec_end;",
        "TCHAR_T",
        "*prec_end",
        "*",
        "prec_end",
        ";",
        "# if USE_SNPRINTF\n                            size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);\n                            length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            ENSURE_ALLOCATION (n);\n                            length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;\n                            prec_ptr = (TCHAR_T *) (result + length);\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "size_t n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR);",
        "size_t",
        "n =\n                              xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "n",
        "=",
        "xsum (length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "xsum",
        "(length,\n                                    (count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR)",
        "(",
        "length",
        ",",
        "(count + insert + TCHARS_PER_DCHAR - 1)\n                                    / TCHARS_PER_DCHAR",
        "(count + insert + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + insert + TCHARS_PER_DCHAR - 1",
        "count + insert + TCHARS_PER_DCHAR",
        "count + insert",
        "count",
        "+",
        "insert",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ")",
        ";",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length += (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "+=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "ENSURE_ALLOCATION (n);",
        "ENSURE_ALLOCATION (n)",
        "ENSURE_ALLOCATION",
        "(n)",
        "(",
        "n",
        ")",
        ";",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR;",
        "length -= (count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "length",
        "-=",
        "(count + TCHARS_PER_DCHAR - 1) / TCHARS_PER_DCHAR",
        "(count + TCHARS_PER_DCHAR - 1)",
        "(",
        "count + TCHARS_PER_DCHAR - 1",
        "count + TCHARS_PER_DCHAR",
        "count",
        "+",
        "TCHARS_PER_DCHAR",
        "-",
        "1",
        ")",
        "/",
        "TCHARS_PER_DCHAR",
        ";",
        "prec_ptr = (TCHAR_T *) (result + length);",
        "prec_ptr = (TCHAR_T *) (result + length)",
        "prec_ptr",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# endif",
        "prec_end = prec_ptr + count;",
        "prec_end = prec_ptr + count",
        "prec_end",
        "=",
        "prec_ptr + count",
        "prec_ptr",
        "+",
        "count",
        ";",
        "prec_ptr += prefix_count;",
        "prec_ptr += prefix_count",
        "prec_ptr",
        "+=",
        "prefix_count",
        ";",
        "while (prec_end > prec_ptr)\n                              {\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        "{\n                                prec_end--;\n                                prec_end[insert] = prec_end[0];\n                              }",
        "{",
        "prec_end--;",
        "prec_end--",
        "prec_end",
        "--",
        ";",
        "prec_end[insert] = prec_end[0];",
        "prec_end[insert] = prec_end[0]",
        "prec_end[insert]",
        "prec_end",
        "[",
        "insert",
        "]",
        "=",
        "prec_end[0]",
        "prec_end",
        "[",
        "0",
        "]",
        ";",
        "}",
        "prec_end += insert;",
        "prec_end += insert",
        "prec_end",
        "+=",
        "insert",
        ";",
        "do\n                              *--prec_end = '0';\n                            while (prec_end > prec_ptr);",
        "do",
        "*--prec_end = '0';",
        "*--prec_end = '0'",
        "*--prec_end",
        "*",
        "--prec_end",
        "--",
        "prec_end",
        "=",
        "'0'",
        "'",
        "'",
        ";",
        "while",
        "(prec_end > prec_ptr)",
        "(",
        "prec_end > prec_ptr",
        "prec_end",
        ">",
        "prec_ptr",
        ")",
        ";",
        "count += insert;",
        "count += insert",
        "count",
        "+=",
        "insert",
        ";",
        "}",
        "}",
        "#endif",
        "#if !USE_SNPRINTF\n                    if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();\n#endif",
        "#if",
        "!USE_SNPRINTF",
        "!",
        "USE_SNPRINTF",
        "\n",
        "if (count >= tmp_length)\n                      /* tmp_length was incorrectly calculated - fix the\n                         code above!  */\n                      abort ();",
        "if",
        "(count >= tmp_length)",
        "(",
        "count >= tmp_length",
        "count",
        ">=",
        "tmp_length",
        ")",
        "/* tmp_length was incorrectly calculated - fix the\n                         code above!  */",
        "abort ();",
        "abort ()",
        "abort",
        "()",
        "(",
        ")",
        ";",
        "#endif",
        "#if !DCHAR_IS_TCHAR\n                    /* Convert from TCHAR_T[] to DCHAR_T[].  */\n                    if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }\n#endif",
        "#if",
        "!DCHAR_IS_TCHAR",
        "!",
        "DCHAR_IS_TCHAR",
        "\n",
        "/* Convert from TCHAR_T[] to DCHAR_T[].  */",
        "if (dp->conversion == 'c' || dp->conversion == 's')\n                      {\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }\n                    else\n                      {\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "if",
        "(dp->conversion == 'c' || dp->conversion == 's')",
        "(",
        "dp->conversion == 'c' || dp->conversion == 's'",
        "dp->conversion == 'c'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'c'",
        "'",
        "'",
        "||",
        "dp->conversion == 's'",
        "dp->conversion",
        "dp",
        "->",
        "conversion",
        "==",
        "'s'",
        "'",
        "'",
        ")",
        "{\n                        /* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */\n                        const TCHAR_T *tmpsrc;\n                        DCHAR_T *tmpdst;\n                        size_t tmpdst_len;\n                        /* This code assumes that TCHAR_T is 'char'.  */\n                        verify (sizeof (TCHAR_T) == 1);\n# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif\n                        tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);\n                        if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }\n                        ENSURE_ALLOCATION (xsum (length, tmpdst_len));\n                        DCHAR_CPY (result + length, tmpdst, tmpdst_len);\n                        free (tmpdst);\n                        count = tmpdst_len;\n                      }",
        "{",
        "/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING\n                           TYPE_WIDE_STRING.\n                           The result string is not certainly ASCII.  */",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t tmpdst_len;",
        "size_t",
        "tmpdst_len",
        ";",
        "/* This code assumes that TCHAR_T is 'char'.  */",
        "verify (sizeof (TCHAR_T) == 1);",
        "verify (sizeof (TCHAR_T) == 1)",
        "verify",
        "(sizeof (TCHAR_T) == 1)",
        "(",
        "sizeof (TCHAR_T) == 1",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        "==",
        "1",
        ")",
        ";",
        "# if USE_SNPRINTF\n                        tmpsrc = (TCHAR_T *) (result + length);\n# else\n                        tmpsrc = tmp;\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "# else\n                        tmpsrc = tmp;",
        "# else",
        "tmpsrc = tmp;",
        "tmpsrc = tmp",
        "tmpsrc",
        "=",
        "tmp",
        ";",
        "# endif",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len);",
        "tmpdst =\n                          DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "tmpdst",
        "=",
        "DCHAR_CONV_FROM_ENCODING (locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "DCHAR_CONV_FROM_ENCODING",
        "(locale_charset (),\n                                                    iconveh_question_mark,\n                                                    tmpsrc, count,\n                                                    NULL,\n                                                    NULL, &tmpdst_len)",
        "(",
        "locale_charset ()",
        "locale_charset",
        "()",
        "(",
        ")",
        ",",
        "iconveh_question_mark",
        ",",
        "tmpsrc",
        ",",
        "count",
        ",",
        "NULL",
        ",",
        "NULL",
        ",",
        "&tmpdst_len",
        "&",
        "tmpdst_len",
        ")",
        ";",
        "if (tmpdst == NULL)\n                          {\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "if",
        "(tmpdst == NULL)",
        "(",
        "tmpdst == NULL",
        "tmpdst",
        "==",
        "NULL",
        ")",
        "{\n                            int saved_errno = errno;\n                            if (!(result == resultbuf || result == NULL))\n                              free (result);\n                            if (buf_malloced != NULL)\n                              free (buf_malloced);\n                            CLEANUP ();\n                            errno = saved_errno;\n                            return NULL;\n                          }",
        "{",
        "int saved_errno = errno;",
        "int",
        "saved_errno = errno",
        "saved_errno",
        "=",
        "errno",
        ";",
        "if (!(result == resultbuf || result == NULL))\n                              free (result);",
        "if",
        "(!(result == resultbuf || result == NULL))",
        "(",
        "!(result == resultbuf || result == NULL)",
        "!",
        "(result == resultbuf || result == NULL)",
        "(",
        "result == resultbuf || result == NULL",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        "||",
        "result == NULL",
        "result",
        "==",
        "NULL",
        ")",
        ")",
        "free (result);",
        "free (result)",
        "free",
        "(result)",
        "(",
        "result",
        ")",
        ";",
        "if (buf_malloced != NULL)\n                              free (buf_malloced);",
        "if",
        "(buf_malloced != NULL)",
        "(",
        "buf_malloced != NULL",
        "buf_malloced",
        "!=",
        "NULL",
        ")",
        "free (buf_malloced);",
        "free (buf_malloced)",
        "free",
        "(buf_malloced)",
        "(",
        "buf_malloced",
        ")",
        ";",
        "CLEANUP ();",
        "CLEANUP ()",
        "CLEANUP",
        "()",
        "(",
        ")",
        ";",
        "errno = saved_errno;",
        "errno = saved_errno",
        "errno",
        "=",
        "saved_errno",
        ";",
        "return NULL;",
        "return",
        "NULL",
        ";",
        "}",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len));",
        "ENSURE_ALLOCATION (xsum (length, tmpdst_len))",
        "ENSURE_ALLOCATION",
        "(xsum (length, tmpdst_len))",
        "(",
        "xsum (length, tmpdst_len)",
        "xsum",
        "(length, tmpdst_len)",
        "(",
        "length",
        ",",
        "tmpdst_len",
        ")",
        ")",
        ";",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len);",
        "DCHAR_CPY (result + length, tmpdst, tmpdst_len)",
        "DCHAR_CPY",
        "(result + length, tmpdst, tmpdst_len)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ",",
        "tmpdst",
        ",",
        "tmpdst_len",
        ")",
        ";",
        "free (tmpdst);",
        "free (tmpdst)",
        "free",
        "(tmpdst)",
        "(",
        "tmpdst",
        ")",
        ";",
        "count = tmpdst_len;",
        "count = tmpdst_len",
        "count",
        "=",
        "tmpdst_len",
        ";",
        "}",
        "else",
        "{\n                        /* The result string is ASCII.\n                           Simple 1:1 conversion.  */\n# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif\n                          {\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }\n                      }",
        "{",
        "/* The result string is ASCII.\n                           Simple 1:1 conversion.  */",
        "# if USE_SNPRINTF\n                        /* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */\n                        if (sizeof (DCHAR_T) != sizeof (TCHAR_T))\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a\n                           no-op conversion, in-place on the array starting\n                           at (result + length).  */",
        "if (sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "if",
        "(sizeof (DCHAR_T) != sizeof (TCHAR_T))",
        "(",
        "sizeof (DCHAR_T) != sizeof (TCHAR_T)",
        "sizeof (DCHAR_T)",
        "sizeof",
        "(DCHAR_T)",
        "(",
        "DCHAR_T",
        ")",
        "!=",
        "sizeof (TCHAR_T)",
        "sizeof",
        "(TCHAR_T)",
        "(",
        "TCHAR_T",
        ")",
        ")",
        "",
        "",
        "# endif",
        "{\n                            const TCHAR_T *tmpsrc;\n                            DCHAR_T *tmpdst;\n                            size_t n;\n\n# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif\n                            tmpdst = result + length;\n                            /* Copy backwards, because of overlapping.  */\n                            tmpsrc += count;\n                            tmpdst += count;\n                            for (n = count; n > 0; n--)\n                              *--tmpdst = (unsigned char) *--tmpsrc;\n                          }",
        "{",
        "const TCHAR_T *tmpsrc;",
        "const",
        "const",
        "TCHAR_T",
        "*tmpsrc",
        "*",
        "tmpsrc",
        ";",
        "DCHAR_T *tmpdst;",
        "DCHAR_T",
        "*tmpdst",
        "*",
        "tmpdst",
        ";",
        "size_t n;",
        "size_t",
        "n",
        ";",
        "# if USE_SNPRINTF\n                            if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }\n# else\n                            tmpsrc = tmp;\n                            ENSURE_ALLOCATION (xsum (length, count));\n# endif",
        "# if",
        "USE_SNPRINTF",
        "\n",
        "if (result == resultbuf)\n                              {\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }\n                            else\n                              {\n                                /* ENSURE_ALLOCATION will move the array\n                                   (because it uses realloc().  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                                tmpsrc = (TCHAR_T *) (result + length);\n                              }",
        "if",
        "(result == resultbuf)",
        "(",
        "result == resultbuf",
        "result",
        "==",
        "resultbuf",
        ")",
        "{\n                                tmpsrc = (TCHAR_T *) (result + length);\n                                /* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */\n                                ENSURE_ALLOCATION (xsum (length, count));\n                              }",
        "{",
        "tmpsrc = (TCHAR_T *) (result + length);",
        "tmpsrc = (TCHAR_T *) (result + length)",
        "tmpsrc",
        "=",
        "(TCHAR_T *) (result + length)",
        "(",
        "TCHAR_T *",
        "TCHAR_T",
        "*",
        "*",
        ")",
        "(result + length)",
        "(",
        "result + length",
        "result",
        "+",
        "length",
        ")",
        ";",
        "/* ENSURE_ALLOCATION will not move tmpsrc\n                                   (because it's part of resultbuf).  */",
        "ENSURE_ALLOCATION (xsum (length, count));",
        "ENSURE_ALLOCATION",
        "(xsum (length, count))",
        "("
      ]
    }
  },
  "recutils/recutils-1.7/lib/vasnprintf.h": {},
  "recutils/recutils-1.7/lib/vasprintf.c": {
    "vasprintf": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\nvasprintf (char **resultp, const char *format, va_list args)\n{\n  size_t length;\n  char *result = vasnprintf (NULL, &length, format, args);\n  if (result == NULL)\n    return -1;\n\n  if (length > INT_MAX)\n    {\n      free (result);\n      errno = EOVERFLOW;\n      return -1;\n    }\n\n  *resultp = result;\n  /* Return the number of resulting bytes, excluding the trailing NUL.  */\n  return length;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/verify.h": {},
  "recutils/recutils-1.7/lib/version-etc-fsf.c": {},
  "recutils/recutils-1.7/lib/version-etc.c": {
    "version_etc_arn": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nversion_etc_arn (FILE *stream,\n                 const char *command_name, const char *package,\n                 const char *version,\n                 const char * const * authors, size_t n_authors)\n{\n  if (command_name)\n    fprintf (stream, \"%s (%s) %s\\n\", command_name, package, version);\n  else\n    fprintf (stream, \"%s %s\\n\", package, version);\n\n#ifdef PACKAGE_PACKAGER\n# ifdef PACKAGE_PACKAGER_VERSION\n  fprintf (stream, _(\"Packaged by %s (%s)\\n\"), PACKAGE_PACKAGER,\n           PACKAGE_PACKAGER_VERSION);\n# else\n  fprintf (stream, _(\"Packaged by %s\\n\"), PACKAGE_PACKAGER);\n# endif\n#endif\n\n  /* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n     (C-in-a-circle), if this symbol is available in the user's\n     locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n  fprintf (stream, version_etc_copyright, _(\"(C)\"), COPYRIGHT_YEAR);\n\n  fputs (_(\"\\\n\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\\\n\\n\\\n\"),\n         stream);\n\n  switch (n_authors)\n    {\n    case 0:\n      /* The caller must provide at least one author name.  */\n      abort ();\n    case 1:\n      /* TRANSLATORS: %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s.\\n\"), authors[0]);\n      break;\n    case 2:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s and %s.\\n\"), authors[0], authors[1]);\n      break;\n    case 3:\n      /* TRANSLATORS: Each %s denotes an author name.  */\n      fprintf (stream, _(\"Written by %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2]);\n      break;\n    case 4:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\nand %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3]);\n      break;\n    case 5:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4]);\n      break;\n    case 6:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5]);\n      break;\n    case 7:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"Written by %s, %s, %s,\\n%s, %s, %s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6]);\n      break;\n    case 8:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\nand %s.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7]);\n      break;\n    case 9:\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, and %s.\\n\"),\n               authors[0], authors[1], authors[2], authors[3], authors[4],\n               authors[5], authors[6], authors[7], authors[8]);\n      break;\n    default:\n      /* 10 or more authors.  Use an abbreviation, since the human reader\n         will probably not want to read the entire list anyway.  */\n      /* TRANSLATORS: Each %s denotes an author name.\n         You can use line breaks, estimating that each author name occupies\n         ca. 16 screen columns and that a screen line has ca. 80 columns.  */\n      fprintf (stream, _(\"\\\nWritten by %s, %s, %s,\\n%s, %s, %s, %s,\\n%s, %s, and others.\\n\"),\n                authors[0], authors[1], authors[2], authors[3], authors[4],\n                authors[5], authors[6], authors[7], authors[8]);\n      break;\n    }\n}",
      "lines": 113,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "version_etc_ar": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nversion_etc_ar (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, const char * const * authors)\n{\n  size_t n_authors;\n\n  for (n_authors = 0; authors[n_authors]; n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version, authors, n_authors);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "version_etc_va": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\nversion_etc_va (FILE *stream,\n                const char *command_name, const char *package,\n                const char *version, va_list authors)\n{\n  size_t n_authors;\n  const char *authtab[10];\n\n  for (n_authors = 0;\n       n_authors < 10\n         && (authtab[n_authors] = va_arg (authors, const char *)) != NULL;\n       n_authors++)\n    ;\n  version_etc_arn (stream, command_name, package, version,\n                   authtab, n_authors);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "version_etc": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nversion_etc (FILE *stream,\n             const char *command_name, const char *package,\n             const char *version, /* const char *author1, ...*/ ...)\n{\n  va_list authors;\n\n  va_start (authors, version);\n  version_etc_va (stream, command_name, package, version, authors);\n  va_end (authors);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emit_bug_reporting_address": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "void\nemit_bug_reporting_address (void)\n{\n  /* TRANSLATORS: The placeholder indicates the bug-reporting address\n     for this package.  Please add _another line_ saying\n     \"Report translation bugs to <...>\\n\" with the address for translation\n     bugs (typically your translation team's web or email address).  */\n  printf (_(\"\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/%s/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/version-etc.h": {},
  "recutils/recutils-1.7/lib/vfprintf.c": {
    "vfprintf": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\nvfprintf (FILE *fp, const char *format, va_list args)\n{\n  char buf[2000];\n  char *output;\n  size_t len;\n  size_t lenbuf = sizeof (buf);\n\n  output = vasnprintf (buf, &lenbuf, format, args);\n  len = lenbuf;\n\n  if (!output)\n    {\n      fseterr (fp);\n      return -1;\n    }\n\n  if (fwrite (output, 1, len, fp) < len)\n    {\n      if (output != buf)\n        {\n          int saved_errno = errno;\n          free (output);\n          errno = saved_errno;\n        }\n      return -1;\n    }\n\n  if (output != buf)\n    free (output);\n\n  if (len > INT_MAX)\n    {\n      errno = EOVERFLOW;\n      fseterr (fp);\n      return -1;\n    }\n\n  return len;\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/w32spawn.h": {
    "dup_noinherit": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int\ndup_noinherit (int fd)\n{\n  fd = dup_cloexec (fd);\n  if (fd < 0 && errno == EMFILE)\n    error (EXIT_FAILURE, errno, _(\"_open_osfhandle failed\"));\n\n  return fd;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "fd_safer_noinherit": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nfd_safer_noinherit (int fd)\n{\n  if (STDIN_FILENO <= fd && fd <= STDERR_FILENO)\n    {\n      /* The recursion depth is at most 3.  */\n      int nfd = fd_safer_noinherit (dup_noinherit (fd));\n      int saved_errno = errno;\n      close (fd);\n      errno = saved_errno;\n      return nfd;\n    }\n  return fd;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dup_safer_noinherit": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\ndup_safer_noinherit (int fd)\n{\n  return fd_safer_noinherit (dup_noinherit (fd));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "undup_safer_noinherit": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nundup_safer_noinherit (int tempfd, int origfd)\n{\n  if (tempfd >= 0)\n    {\n      if (dup2 (tempfd, origfd) < 0)\n        error (EXIT_FAILURE, errno, _(\"cannot restore fd %d: dup2 failed\"),\n               origfd);\n      close (tempfd);\n    }\n  else\n    {\n      /* origfd was closed or open to no handle at all.  Set it to a closed\n         state.  This is (nearly) equivalent to the original state.  */\n      close (origfd);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prepare_spawn": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static char **\nprepare_spawn (char **argv)\n{\n  size_t argc;\n  char **new_argv;\n  size_t i;\n\n  /* Count number of arguments.  */\n  for (argc = 0; argv[argc] != NULL; argc++)\n    ;\n\n  /* Allocate new argument vector.  */\n  new_argv = XNMALLOC (1 + argc + 1, char *);\n\n  /* Add an element upfront that can be used when argv[0] turns out to be a\n     script, not a program.\n     On Unix, this would be \"/bin/sh\". On native Windows, \"sh\" is actually\n     \"sh.exe\".  We have to omit the directory part and rely on the search in\n     PATH, because the mingw \"mount points\" are not visible inside Windows\n     CreateProcess().  */\n  *new_argv++ = \"sh.exe\";\n\n  /* Put quoted arguments into the new argument vector.  */\n  for (i = 0; i < argc; i++)\n    {\n      const char *string = argv[i];\n\n      if (string[0] == '\\0')\n        new_argv[i] = xstrdup (\"\\\"\\\"\");\n      else if (strpbrk (string, SHELL_SPECIAL_CHARS) != NULL)\n        {\n          bool quote_around = (strpbrk (string, SHELL_SPACE_CHARS) != NULL);\n          size_t length;\n          unsigned int backslashes;\n          const char *s;\n          char *quoted_string;\n          char *p;\n\n          length = 0;\n          backslashes = 0;\n          if (quote_around)\n            length++;\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                length += backslashes + 1;\n              length++;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            length += backslashes + 1;\n\n          quoted_string = (char *) xmalloc (length + 1);\n\n          p = quoted_string;\n          backslashes = 0;\n          if (quote_around)\n            *p++ = '\"';\n          for (s = string; *s != '\\0'; s++)\n            {\n              char c = *s;\n              if (c == '\"')\n                {\n                  unsigned int j;\n                  for (j = backslashes + 1; j > 0; j--)\n                    *p++ = '\\\\';\n                }\n              *p++ = c;\n              if (c == '\\\\')\n                backslashes++;\n              else\n                backslashes = 0;\n            }\n          if (quote_around)\n            {\n              unsigned int j;\n              for (j = backslashes; j > 0; j--)\n                *p++ = '\\\\';\n              *p++ = '\"';\n            }\n          *p = '\\0';\n\n          new_argv[i] = quoted_string;\n        }\n      else\n        new_argv[i] = (char *) string;\n    }\n  new_argv[argc] = NULL;\n\n  return new_argv;\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nprepare_spawn (char **argv)",
        "*",
        "*\nprepare_spawn (char **argv)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wait-process.c": {
    "cleanup_slaves": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\ncleanup_slaves (void)\n{\n  for (;;)\n    {\n      /* Get the last registered slave.  */\n      size_t n = slaves_count;\n      if (n == 0)\n        break;\n      n--;\n      slaves_count = n;\n      /* Skip unused entries in the slaves array.  */\n      if (slaves[n].used)\n        {\n          pid_t slave = slaves[n].child;\n\n          /* Kill the slave.  */\n          kill (slave, TERMINATOR);\n        }\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "register_slave_subprocess": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nregister_slave_subprocess (pid_t child)\n{\n  static bool cleanup_slaves_registered = false;\n  if (!cleanup_slaves_registered)\n    {\n      atexit (cleanup_slaves);\n      at_fatal_signal (cleanup_slaves);\n      cleanup_slaves_registered = true;\n    }\n\n  /* Try to store the new slave in an unused entry of the slaves array.  */\n  {\n    slaves_entry_t *s = slaves;\n    slaves_entry_t *s_end = s + slaves_count;\n\n    for (; s < s_end; s++)\n      if (!s->used)\n        {\n          /* The two uses of 'volatile' in the slaves_entry_t type above\n             (and ISO C 99 section 5.1.2.3.(5)) ensure that we mark the\n             entry as used only after the child pid has been written to the\n             memory location s->child.  */\n          s->child = child;\n          s->used = 1;\n          return;\n        }\n  }\n\n  if (slaves_count == slaves_allocated)\n    {\n      /* Extend the slaves array.  Note that we cannot use xrealloc(),\n         because then the cleanup_slaves() function could access an already\n         deallocated array.  */\n      slaves_entry_t *old_slaves = slaves;\n      size_t new_slaves_allocated = 2 * slaves_allocated;\n      slaves_entry_t *new_slaves =\n        (slaves_entry_t *)\n        malloc (new_slaves_allocated * sizeof (slaves_entry_t));\n      if (new_slaves == NULL)\n        {\n          /* xalloc_die() will call exit() which will invoke cleanup_slaves().\n             Additionally we need to kill child, because it's not yet among\n             the slaves list.  */\n          kill (child, TERMINATOR);\n          xalloc_die ();\n        }\n      memcpy (new_slaves, old_slaves,\n              slaves_allocated * sizeof (slaves_entry_t));\n      slaves = new_slaves;\n      slaves_allocated = new_slaves_allocated;\n      /* Now we can free the old slaves array.  */\n      if (old_slaves != static_slaves)\n        free (old_slaves);\n    }\n  /* The three uses of 'volatile' in the types above (and ISO C 99 section\n     5.1.2.3.(5)) ensure that we increment the slaves_count only after the\n     new slave and its 'used' bit have been written to the memory locations\n     that make up slaves[slaves_count].  */\n  slaves[slaves_count].child = child;\n  slaves[slaves_count].used = 1;\n  slaves_count++;\n}",
      "lines": 63,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "unregister_slave_subprocess": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nunregister_slave_subprocess (pid_t child)\n{\n  /* The easiest way to remove an entry from a list that can be used by\n     an asynchronous signal handler is just to mark it as unused.  For this,\n     we rely on sig_atomic_t.  */\n  slaves_entry_t *s = slaves;\n  slaves_entry_t *s_end = s + slaves_count;\n\n  for (; s < s_end; s++)\n    if (s->used && s->child == child)\n      s->used = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wait_subprocess": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "int\nwait_subprocess (pid_t child, const char *progname,\n                 bool ignore_sigpipe, bool null_stderr,\n                 bool slave_process, bool exit_on_error,\n                 int *termsigp)\n{\n#if HAVE_WAITID && defined WNOWAIT && 0\n  /* Commented out because waitid() without WEXITED and with WNOWAIT doesn't\n     work: On Solaris 7 and OSF/1 4.0, it returns -1 and sets errno = ECHILD,\n     and on HP-UX 10.20 it just hangs.  */\n  /* Use of waitid() with WNOWAIT avoids a race condition: If slave_process is\n     true, and this process sleeps a very long time between the return from\n     waitpid() and the execution of unregister_slave_subprocess(), and\n     meanwhile another process acquires the same PID as child, and then - still\n     before unregister_slave_subprocess() - this process gets a fatal signal,\n     it would kill the other totally unrelated process.  */\n  siginfo_t info;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  for (;;)\n    {\n      if (waitid (P_PID, child, &info, WEXITED | (slave_process ? WNOWAIT : 0))\n          < 0)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* info.si_code is set to one of CLD_EXITED, CLD_KILLED, CLD_DUMPED,\n         CLD_TRAPPED, CLD_STOPPED, CLD_CONTINUED.  Loop until the program\n         terminates.  */\n      if (info.si_code == CLD_EXITED\n          || info.si_code == CLD_KILLED || info.si_code == CLD_DUMPED)\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    {\n      /* Unregister the child from the list of slave subprocesses, so that\n         later, when we exit, we don't kill a totally unrelated process which\n         may have acquired the same pid.  */\n      unregister_slave_subprocess (child);\n\n      /* Now remove the zombie from the process list.  */\n      for (;;)\n        {\n          if (waitid (P_PID, child, &info, WEXITED) < 0)\n            {\n# ifdef EINTR\n              if (errno == EINTR)\n                continue;\n# endif\n              if (exit_on_error || !null_stderr)\n                error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                       _(\"%s subprocess\"), progname);\n              return 127;\n            }\n          break;\n        }\n    }\n\n  switch (info.si_code)\n    {\n    case CLD_KILLED:\n    case CLD_DUMPED:\n      if (termsigp != NULL)\n        *termsigp = info.si_status; /* TODO: or info.si_signo? */\n# ifdef SIGPIPE\n      if (info.si_status == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, info.si_status);\n      return 127;\n    case CLD_EXITED:\n      if (info.si_status == 127)\n        {\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, 0,\n                   _(\"%s subprocess failed\"), progname);\n          return 127;\n        }\n      return info.si_status;\n    default:\n      abort ();\n    }\n#else\n  /* waitpid() is just as portable as wait() nowadays.  */\n  int status;\n\n  if (termsigp != NULL)\n    *termsigp = 0;\n  status = 0;\n  for (;;)\n    {\n      int result = waitpid (child, &status, 0);\n\n      if (result != child)\n        {\n# ifdef EINTR\n          if (errno == EINTR)\n            continue;\n# endif\n# if 0 /* defined ECHILD */\n          if (errno == ECHILD)\n            {\n              /* Child process nonexistent?! Assume it terminated\n                 successfully.  */\n              status = 0;\n              break;\n            }\n# endif\n          if (exit_on_error || !null_stderr)\n            error (exit_on_error ? EXIT_FAILURE : 0, errno,\n                   _(\"%s subprocess\"), progname);\n          return 127;\n        }\n\n      /* One of WIFSIGNALED (status), WIFEXITED (status), WIFSTOPPED (status)\n         must always be true, since we did not specify WCONTINUED in the\n         waitpid() call.  Loop until the program terminates.  */\n      if (!WIFSTOPPED (status))\n        break;\n    }\n\n  /* The child process has exited or was signalled.  */\n\n  if (slave_process)\n    /* Unregister the child from the list of slave subprocesses, so that\n       later, when we exit, we don't kill a totally unrelated process which\n       may have acquired the same pid.  */\n    unregister_slave_subprocess (child);\n\n  if (WIFSIGNALED (status))\n    {\n      if (termsigp != NULL)\n        *termsigp = WTERMSIG (status);\n# ifdef SIGPIPE\n      if (WTERMSIG (status) == SIGPIPE && ignore_sigpipe)\n        return 0;\n# endif\n      if (exit_on_error || (!null_stderr && termsigp == NULL))\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess got fatal signal %d\"),\n               progname, (int) WTERMSIG (status));\n      return 127;\n    }\n  if (!WIFEXITED (status))\n    abort ();\n  if (WEXITSTATUS (status) == 127)\n    {\n      if (exit_on_error || !null_stderr)\n        error (exit_on_error ? EXIT_FAILURE : 0, 0,\n               _(\"%s subprocess failed\"), progname);\n      return 127;\n    }\n  return WEXITSTATUS (status);\n#endif\n}",
      "lines": 170,
      "depth": 17,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wait-process.h": {},
  "recutils/recutils-1.7/lib/waitpid.c": {
    "waitpid": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "pid_t\nwaitpid (pid_t pid, int *statusp, int options)\n{\n  return _cwait (statusp, pid, WAIT_CHILD);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "pid_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wchar.in.h": {},
  "recutils/recutils-1.7/lib/wcrtomb.c": {
    "wcrtomb": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "size_t\nwcrtomb (char *s, wchar_t wc, mbstate_t *ps)\n{\n  /* This implementation of wcrtomb on top of wctomb() supports only\n     stateless encodings.  ps must be in the initial state.  */\n  if (ps != NULL && !mbsinit (ps))\n    {\n      errno = EINVAL;\n      return (size_t)(-1);\n    }\n\n  if (s == NULL)\n    /* We know the NUL wide character corresponds to the NUL character.  */\n    return 1;\n  else\n    {\n      int ret = wctomb (s, wc);\n\n      if (ret >= 0)\n        return ret;\n      else\n        {\n          errno = EILSEQ;\n          return (size_t)(-1);\n        }\n    }\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wctob.c": {
    "wctob": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "int\nwctob (wint_t wc)\n{\n  char buf[64];\n\n  if (!(MB_CUR_MAX <= sizeof (buf)))\n    abort ();\n  /* Handle the case where WEOF is a value that does not fit in a wchar_t.  */\n  if (wc == (wchar_t)wc)\n    if (wctomb (buf, (wchar_t)wc) == 1)\n      return (unsigned char) buf[0];\n  return EOF;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wctomb-impl.h": {
    "wctomb": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "int\nwctomb (char *s, wchar_t wc)\n{\n  if (s == NULL)\n    return 0;\n  else\n    {\n      mbstate_t state;\n      size_t result;\n\n      memset (&state, 0, sizeof (mbstate_t));\n      result = wcrtomb (s, wc, &state);\n      if (result == (size_t)-1)\n        return -1;\n      return result;\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/lib/wctomb.c": {},
  "recutils/recutils-1.7/lib/wctype-h.c": {},
  "recutils/recutils-1.7/lib/wctype.in.h": {
    "rpl_towlower": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        357,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towlower (wint_t wc)\n{\n  return (wint_t) (wchar_t) towlower (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    },
    "rpl_towupper": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "_GL_WCTYPE_INLINE wint_t\nrpl_towupper (wint_t wc)\n{\n  return (wint_t) (wchar_t) towupper (wc);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "_GL_WCTYPE_INLINE",
        "wint_t",
        "wint_t"
      ]
    }
  },
  "recutils/recutils-1.7/lib/xalloc-die.c": {
    "xalloc_die": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\nxalloc_die (void)\n{\n  error (exit_failure, 0, \"%s\", _(\"memory exhausted\"));\n\n  /* _Noreturn cannot be given to error, since it may return if\n     its first argument is 0.  To help compilers understand the\n     xalloc_die does not return, call abort.  Also, the abort is a\n     safety feature if exit_failure is 0 (which shouldn't happen).  */\n  abort ();\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/xalloc-oversized.h": {},
  "recutils/recutils-1.7/lib/xalloc.h": {
    "xnmalloc": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "XALLOC_INLINE void *\nxnmalloc (size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xmalloc (n * s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "XALLOC_INLINE",
        "void",
        "void",
        "*\nxnmalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xnrealloc": [
      {
        "start_point": [
          114,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "XALLOC_INLINE void *\nxnrealloc (void *p, size_t n, size_t s)\n{\n  if (xalloc_oversized (n, s))\n    xalloc_die ();\n  return xrealloc (p, n * s);\n}",
        "lines": 7,
        "depth": 7,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nxnrealloc (void *p, size_t n, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          235,
          29
        ],
        "end_point": [
          239,
          1
        ],
        "content": "T *\nxnrealloc (T *p, size_t n, size_t s)\n{\n  return (T *) xnrealloc ((void *) p, n, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nxnrealloc (T *p, size_t n, size_t s)",
          "*"
        ]
      }
    ],
    "x2nrealloc": [
      {
        "start_point": [
          177,
          0
        ],
        "end_point": [
          209,
          1
        ],
        "content": "XALLOC_INLINE void *\nx2nrealloc (void *p, size_t *pn, size_t s)\n{\n  size_t n = *pn;\n\n  if (! p)\n    {\n      if (! n)\n        {\n          /* The approximate size to use for initial small allocation\n             requests, when the invoking code specifies an old size of\n             zero.  This is the largest \"small\" request for the GNU C\n             library malloc.  */\n          enum { DEFAULT_MXFAST = 64 * sizeof (size_t) / 4 };\n\n          n = DEFAULT_MXFAST / s;\n          n += !n;\n        }\n    }\n  else\n    {\n      /* Set N = ceil (1.5 * N) so that progress is made if N == 1.\n         Check for overflow, so that N * S stays in size_t range.\n         The check is slightly conservative, but an exact check isn't\n         worth the trouble.  */\n      if ((size_t) -1 / 3 * 2 / s <= n)\n        xalloc_die ();\n      n += (n + 1) / 2;\n    }\n\n  *pn = n;\n  return xrealloc (p, n * s);\n}",
        "lines": 33,
        "depth": 14,
        "decorators": [
          "XALLOC_INLINE",
          "void",
          "void",
          "*\nx2nrealloc (void *p, size_t *pn, size_t s)",
          "*"
        ]
      },
      {
        "start_point": [
          247,
          29
        ],
        "end_point": [
          251,
          1
        ],
        "content": "T *\nx2nrealloc (T *p, size_t *pn, size_t s)\n{\n  return (T *) x2nrealloc ((void *) p, pn, s);\n}",
        "lines": 5,
        "depth": 10,
        "decorators": [
          "T",
          "*\nx2nrealloc (T *p, size_t *pn, size_t s)",
          "*"
        ]
      }
    ],
    "xcharalloc": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "XALLOC_INLINE char *\nxcharalloc (size_t n)\n{\n  return XNMALLOC (n, char);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "XALLOC_INLINE",
        "char",
        "char",
        "*\nxcharalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        229,
        29
      ],
      "end_point": [
        233,
        1
      ],
      "content": "T *\nxrealloc (T *p, size_t s)\n{\n  return (T *) xrealloc ((void *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxrealloc (T *p, size_t s)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        241,
        29
      ],
      "end_point": [
        245,
        1
      ],
      "content": "T *\nx2realloc (T *p, size_t *pn)\n{\n  return (T *) x2realloc ((void *) p, pn);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nx2realloc (T *p, size_t *pn)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        253,
        29
      ],
      "end_point": [
        257,
        1
      ],
      "content": "T *\nxmemdup (T const *p, size_t s)\n{\n  return (T *) xmemdup ((void const *) p, s);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "T",
        "*\nxmemdup (T const *p, size_t s)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/xmalloc.c": {
    "xmalloc": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void *\nxmalloc (size_t n)\n{\n  void *p = malloc (n);\n  if (!p && n != 0)\n    xalloc_die ();\n  return p;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\nxmalloc (size_t n)",
        "*"
      ]
    },
    "xrealloc": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void *\nxrealloc (void *p, size_t n)\n{\n  if (!n && p)\n    {\n      /* The GNU and C99 realloc behaviors disagree here.  Act like\n         GNU, even if the underlying realloc is C99.  */\n      free (p);\n      return NULL;\n    }\n\n  p = realloc (p, n);\n  if (!p && n)\n    xalloc_die ();\n  return p;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxrealloc (void *p, size_t n)",
        "*"
      ]
    },
    "x2realloc": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void *\nx2realloc (void *p, size_t *pn)\n{\n  return x2nrealloc (p, pn, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\nx2realloc (void *p, size_t *pn)",
        "*"
      ]
    },
    "xzalloc": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void *\nxzalloc (size_t s)\n{\n  return memset (xmalloc (s), 0, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxzalloc (size_t s)",
        "*"
      ]
    },
    "xcalloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void *\nxcalloc (size_t n, size_t s)\n{\n  void *p;\n  /* Test for overflow, since some calloc implementations don't have\n     proper overflow checks.  But omit overflow and size-zero tests if\n     HAVE_GNU_CALLOC, since GNU calloc catches overflow and never\n     returns NULL if successful.  */\n  if ((! HAVE_GNU_CALLOC && xalloc_oversized (n, s))\n      || (! (p = calloc (n, s)) && (HAVE_GNU_CALLOC || n != 0)))\n    xalloc_die ();\n  return p;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "void",
        "*\nxcalloc (size_t n, size_t s)",
        "*"
      ]
    },
    "xmemdup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void *\nxmemdup (void const *p, size_t s)\n{\n  return memcpy (xmalloc (s), p, s);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nxmemdup (void const *p, size_t s)",
        "*"
      ]
    },
    "xstrdup": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "char *\nxstrdup (char const *string)\n{\n  return xmemdup (string, strlen (string) + 1);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "char",
        "*\nxstrdup (char const *string)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/lib/xsize.c": {},
  "recutils/recutils-1.7/lib/xsize.h": {
    "size_t": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxsum (size_t size1, size_t size2)\n{\n  size_t sum = size1 + size2;\n  return (sum >= size1 ? sum : SIZE_MAX);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": null
    },
    "__pure__": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "__attribute__ ((__pure__))\n#endif\nxmax (size_t size1, size_t size2)\n{\n  /* No explicit check is needed here, because for any n:\n     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */\n  return (size1 >= size2 ? size1 : size2);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    }
  },
  "recutils/recutils-1.7/lib/glthread/lock.c": {
    "glthread_rwlock_init_multithreaded": [
      {
        "start_point": [
          36,
          0
        ],
        "end_point": [
          46,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_rwlock_init (&lock->rwlock, NULL);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 11,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          126,
          0
        ],
        "end_point": [
          143,
          1
        ],
        "content": "int\nglthread_rwlock_init_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->lock, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_readers, NULL);\n  if (err != 0)\n    return err;\n  err = pthread_cond_init (&lock->waiting_writers, NULL);\n  if (err != 0)\n    return err;\n  lock->waiting_writers_count = 0;\n  lock->runcount = 0;\n  return 0;\n}",
        "lines": 18,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_rdlock_multithreaded": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          72,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_rdlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          145,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "int\nglthread_rwlock_rdlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  /* POSIX says: \"It is implementation-defined whether the calling thread\n     acquires the lock when a writer does not hold the lock and there are\n     writers blocked on the lock.\"  Let's say, no: give the writers a higher\n     priority.  */\n  while (!(lock->runcount + 1 > 0 && lock->waiting_writers_count == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      err = pthread_cond_wait (&lock->waiting_readers, &lock->lock);\n      if (err != 0)\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n    }\n  lock->runcount++;\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 28,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_wrlock_multithreaded": [
      {
        "start_point": [
          74,
          0
        ],
        "end_point": [
          98,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_rwlock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_rwlock_wrlock (&lock->rwlock);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          174,
          0
        ],
        "end_point": [
          199,
          1
        ],
        "content": "int\nglthread_rwlock_wrlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  /* Test whether no readers or writers are currently running.  */\n  while (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      lock->waiting_writers_count++;\n      err = pthread_cond_wait (&lock->waiting_writers, &lock->lock);\n      if (err != 0)\n        {\n          lock->waiting_writers_count--;\n          pthread_mutex_unlock (&lock->lock);\n          return err;\n        }\n      lock->waiting_writers_count--;\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 26,
        "depth": 12,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_unlock_multithreaded": [
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_rwlock_unlock (&lock->rwlock);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          201,
          0
        ],
        "end_point": [
          255,
          1
        ],
        "content": "int\nglthread_rwlock_unlock_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_lock (&lock->lock);\n  if (err != 0)\n    return err;\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          pthread_mutex_unlock (&lock->lock);\n          return EINVAL;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers_count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          err = pthread_cond_signal (&lock->waiting_writers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          err = pthread_cond_broadcast (&lock->waiting_readers);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->lock);\n              return err;\n            }\n        }\n    }\n  return pthread_mutex_unlock (&lock->lock);\n}",
        "lines": 55,
        "depth": 14,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_rwlock_destroy_multithreaded": [
      {
        "start_point": [
          108,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_rwlock_destroy (&lock->rwlock);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          257,
          0
        ],
        "end_point": [
          272,
          1
        ],
        "content": "int\nglthread_rwlock_destroy_multithreaded (gl_rwlock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_destroy (&lock->lock);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_readers);\n  if (err != 0)\n    return err;\n  err = pthread_cond_destroy (&lock->waiting_writers);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 16,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_init_multithreaded": [
      {
        "start_point": [
          282,
          0
        ],
        "end_point": [
          307,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (lock, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  return 0;\n}",
        "lines": 26,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          311,
          0
        ],
        "end_point": [
          337,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_mutexattr_t attributes;\n  int err;\n\n  err = pthread_mutexattr_init (&attributes);\n  if (err != 0)\n    return err;\n  err = pthread_mutexattr_settype (&attributes, PTHREAD_MUTEX_RECURSIVE);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutex_init (&lock->recmutex, &attributes);\n  if (err != 0)\n    {\n      pthread_mutexattr_destroy (&attributes);\n      return err;\n    }\n  err = pthread_mutexattr_destroy (&attributes);\n  if (err != 0)\n    return err;\n  lock->initialized = 1;\n  return 0;\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          391,
          0
        ],
        "end_point": [
          402,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = pthread_mutex_init (&lock->mutex, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (pthread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          530,
          0
        ],
        "end_point": [
          541,
          1
        ],
        "content": "int\nglthread_recursive_lock_init_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  err = mutex_init (&lock->mutex, USYNC_THREAD, NULL);\n  if (err != 0)\n    return err;\n  lock->owner = (thread_t) 0;\n  lock->depth = 0;\n  return 0;\n}",
        "lines": 12,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_lock_multithreaded": [
      {
        "start_point": [
          339,
          0
        ],
        "end_point": [
          363,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->guard);\n      if (err != 0)\n        return err;\n      if (!lock->initialized)\n        {\n          err = glthread_recursive_lock_init_multithreaded (lock);\n          if (err != 0)\n            {\n              pthread_mutex_unlock (&lock->guard);\n              return err;\n            }\n        }\n      err = pthread_mutex_unlock (&lock->guard);\n      if (err != 0)\n        return err;\n    }\n  return pthread_mutex_lock (&lock->recmutex);\n}",
        "lines": 25,
        "depth": 14,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          404,
          0
        ],
        "end_point": [
          423,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  pthread_t self = pthread_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = pthread_mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          543,
          0
        ],
        "end_point": [
          562,
          1
        ],
        "content": "int\nglthread_recursive_lock_lock_multithreaded (gl_recursive_lock_t *lock)\n{\n  thread_t self = thr_self ();\n  if (lock->owner != self)\n    {\n      int err;\n\n      err = mutex_lock (&lock->mutex);\n      if (err != 0)\n        return err;\n      lock->owner = self;\n    }\n  if (++(lock->depth) == 0) /* wraparound? */\n    {\n      lock->depth--;\n      return EAGAIN;\n    }\n  return 0;\n}",
        "lines": 20,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_unlock_multithreaded": [
      {
        "start_point": [
          365,
          0
        ],
        "end_point": [
          371,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (!lock->initialized)\n    return EINVAL;\n  return pthread_mutex_unlock (&lock->recmutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          425,
          0
        ],
        "end_point": [
          439,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != pthread_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (pthread_t) 0;\n      return pthread_mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          564,
          0
        ],
        "end_point": [
          578,
          1
        ],
        "content": "int\nglthread_recursive_lock_unlock_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != thr_self ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = (thread_t) 0;\n      return mutex_unlock (&lock->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_recursive_lock_destroy_multithreaded": [
      {
        "start_point": [
          373,
          0
        ],
        "end_point": [
          385,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  int err;\n\n  if (!lock->initialized)\n    return EINVAL;\n  err = pthread_mutex_destroy (&lock->recmutex);\n  if (err != 0)\n    return err;\n  lock->initialized = 0;\n  return 0;\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          441,
          0
        ],
        "end_point": [
          447,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (pthread_t) 0)\n    return EBUSY;\n  return pthread_mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          580,
          0
        ],
        "end_point": [
          586,
          1
        ],
        "content": "int\nglthread_recursive_lock_destroy_multithreaded (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != (thread_t) 0)\n    return EBUSY;\n  return mutex_destroy (&lock->mutex);\n}",
        "lines": 7,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_singlethreaded": [
      {
        "start_point": [
          455,
          0
        ],
        "end_point": [
          469,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pthread_once_t *once_control)\n{\n  /* We don't know whether pthread_once_t is an integer type, a floating-point\n     type, a pointer type, or a structure type.  */\n  char *firstbyte = (char *)once_control;\n  if (*firstbyte == *(const char *)&fresh_once)\n    {\n      /* First time use of once_control.  Invert the first byte.  */\n      *firstbyte = ~ *(const char *)&fresh_once;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 15,
        "depth": 12,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          502,
          0
        ],
        "end_point": [
          514,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (pth_once_t *once_control)\n{\n  /* We know that pth_once_t is an integer type.  */\n  if (*once_control == PTH_ONCE_INIT)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      *once_control = ~ PTH_ONCE_INIT;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          613,
          0
        ],
        "end_point": [
          625,
          1
        ],
        "content": "int\nglthread_once_singlethreaded (gl_once_t *once_control)\n{\n  /* We know that gl_once_t contains an integer type.  */\n  if (!once_control->inited)\n    {\n      /* First time use of once_control.  Invert the marker.  */\n      once_control->inited = ~ 0;\n      return 1;\n    }\n  else\n    return 0;\n}",
        "lines": 13,
        "depth": 8,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_once_call": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "static void\nglthread_once_call (void *arg)\n{\n  void (**gl_once_temp_addr) (void) = (void (**) (void)) arg;\n  void (*initfunction) (void) = *gl_once_temp_addr;\n  initfunction ();\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_once_multithreaded": [
      {
        "start_point": [
          495,
          0
        ],
        "end_point": [
          500,
          1
        ],
        "content": "int\nglthread_once_multithreaded (pth_once_t *once_control, void (*initfunction) (void))\n{\n  void (*temp) (void) = initfunction;\n  return (!pth_once (once_control, glthread_once_call, &temp) ? errno : 0);\n}",
        "lines": 6,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          590,
          0
        ],
        "end_point": [
          611,
          1
        ],
        "content": "int\nglthread_once_multithreaded (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (!once_control->inited)\n    {\n      int err;\n\n      /* Use the mutex to guarantee that if another thread is already calling\n         the initfunction, this thread waits until it's finished.  */\n      err = mutex_lock (&once_control->mutex);\n      if (err != 0)\n        return err;\n      if (!once_control->inited)\n        {\n          once_control->inited = 1;\n          initfunction ();\n        }\n      return mutex_unlock (&once_control->mutex);\n    }\n  else\n    return 0;\n}",
        "lines": 22,
        "depth": 11,
        "decorators": [
          "int"
        ]
      }
    ],
    "glthread_lock_init_func": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        640,
        1
      ],
      "content": "void\nglthread_lock_init_func (gl_lock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_lock_lock_func": {
      "start_point": [
        642,
        0
      ],
      "end_point": [
        658,
        1
      ],
      "content": "int\nglthread_lock_lock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_unlock_func": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        667,
        1
      ],
      "content": "int\nglthread_lock_unlock_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_lock_destroy_func": {
      "start_point": [
        669,
        0
      ],
      "end_point": [
        677,
        1
      ],
      "content": "int\nglthread_lock_destroy_func (gl_lock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "gl_waitqueue_init": {
      "start_point": [
        684,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static void\ngl_waitqueue_init (gl_waitqueue_t *wq)\n{\n  wq->array = NULL;\n  wq->count = 0;\n  wq->alloc = 0;\n  wq->offset = 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_add": {
      "start_point": [
        695,
        0
      ],
      "end_point": [
        742,
        1
      ],
      "content": "static HANDLE\ngl_waitqueue_add (gl_waitqueue_t *wq)\n{\n  HANDLE event;\n  unsigned int index;\n\n  if (wq->count == wq->alloc)\n    {\n      unsigned int new_alloc = 2 * wq->alloc + 1;\n      HANDLE *new_array =\n        (HANDLE *) realloc (wq->array, new_alloc * sizeof (HANDLE));\n      if (new_array == NULL)\n        /* No more memory.  */\n        return INVALID_HANDLE_VALUE;\n      /* Now is a good opportunity to rotate the array so that its contents\n         starts at offset 0.  */\n      if (wq->offset > 0)\n        {\n          unsigned int old_count = wq->count;\n          unsigned int old_alloc = wq->alloc;\n          unsigned int old_offset = wq->offset;\n          unsigned int i;\n          if (old_offset + old_count > old_alloc)\n            {\n              unsigned int limit = old_offset + old_count - old_alloc;\n              for (i = 0; i < limit; i++)\n                new_array[old_alloc + i] = new_array[i];\n            }\n          for (i = 0; i < old_count; i++)\n            new_array[i] = new_array[old_offset + i];\n          wq->offset = 0;\n        }\n      wq->array = new_array;\n      wq->alloc = new_alloc;\n    }\n  /* Whether the created event is a manual-reset one or an auto-reset one,\n     does not matter, since we will wait on it only once.  */\n  event = CreateEvent (NULL, TRUE, FALSE, NULL);\n  if (event == INVALID_HANDLE_VALUE)\n    /* No way to allocate an event.  */\n    return INVALID_HANDLE_VALUE;\n  index = wq->offset + wq->count;\n  if (index >= wq->alloc)\n    index -= wq->alloc;\n  wq->array[index] = event;\n  wq->count++;\n  return event;\n}",
      "lines": 48,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "HANDLE"
      ]
    },
    "gl_waitqueue_notify_first": {
      "start_point": [
        745,
        0
      ],
      "end_point": [
        753,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_first (gl_waitqueue_t *wq)\n{\n  SetEvent (wq->array[wq->offset + 0]);\n  wq->offset++;\n  wq->count--;\n  if (wq->count == 0 || wq->offset == wq->alloc)\n    wq->offset = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gl_waitqueue_notify_all": {
      "start_point": [
        756,
        0
      ],
      "end_point": [
        770,
        1
      ],
      "content": "static void\ngl_waitqueue_notify_all (gl_waitqueue_t *wq)\n{\n  unsigned int i;\n\n  for (i = 0; i < wq->count; i++)\n    {\n      unsigned int index = wq->offset + i;\n      if (index >= wq->alloc)\n        index -= wq->alloc;\n      SetEvent (wq->array[index]);\n    }\n  wq->count = 0;\n  wq->offset = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "glthread_rwlock_init_func": {
      "start_point": [
        772,
        0
      ],
      "end_point": [
        780,
        1
      ],
      "content": "void\nglthread_rwlock_init_func (gl_rwlock_t *lock)\n{\n  InitializeCriticalSection (&lock->lock);\n  gl_waitqueue_init (&lock->waiting_readers);\n  gl_waitqueue_init (&lock->waiting_writers);\n  lock->runcount = 0;\n  lock->guard.done = 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_rwlock_rdlock_func": {
      "start_point": [
        782,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "int\nglthread_rwlock_rdlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether only readers are currently running, and whether the runcount\n     field will not overflow.  */\n  if (!(lock->runcount + 1 > 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_readers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_readers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_readers, incremented lock->runcount.  */\n          if (!(lock->runcount > 0))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount + 1 > 0));\n        }\n    }\n  lock->runcount++;\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_wrlock_func": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "int\nglthread_rwlock_wrlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_rwlock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  EnterCriticalSection (&lock->lock);\n  /* Test whether no readers or writers are currently running.  */\n  if (!(lock->runcount == 0))\n    {\n      /* This thread has to wait for a while.  Enqueue it among the\n         waiting_writers.  */\n      HANDLE event = gl_waitqueue_add (&lock->waiting_writers);\n      if (event != INVALID_HANDLE_VALUE)\n        {\n          DWORD result;\n          LeaveCriticalSection (&lock->lock);\n          /* Wait until another thread signals this event.  */\n          result = WaitForSingleObject (event, INFINITE);\n          if (result == WAIT_FAILED || result == WAIT_TIMEOUT)\n            abort ();\n          CloseHandle (event);\n          /* The thread which signalled the event already did the bookkeeping:\n             removed us from the waiting_writers, set lock->runcount = -1.  */\n          if (!(lock->runcount == -1))\n            abort ();\n          return 0;\n        }\n      else\n        {\n          /* Allocation failure.  Weird.  */\n          do\n            {\n              LeaveCriticalSection (&lock->lock);\n              Sleep (1);\n              EnterCriticalSection (&lock->lock);\n            }\n          while (!(lock->runcount == 0));\n        }\n    }\n  lock->runcount--; /* runcount becomes -1 */\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 52,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_unlock_func": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        931,
        1
      ],
      "content": "int\nglthread_rwlock_unlock_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  EnterCriticalSection (&lock->lock);\n  if (lock->runcount < 0)\n    {\n      /* Drop a writer lock.  */\n      if (!(lock->runcount == -1))\n        abort ();\n      lock->runcount = 0;\n    }\n  else\n    {\n      /* Drop a reader lock.  */\n      if (!(lock->runcount > 0))\n        {\n          LeaveCriticalSection (&lock->lock);\n          return EPERM;\n        }\n      lock->runcount--;\n    }\n  if (lock->runcount == 0)\n    {\n      /* POSIX recommends that \"write locks shall take precedence over read\n         locks\", to avoid \"writer starvation\".  */\n      if (lock->waiting_writers.count > 0)\n        {\n          /* Wake up one of the waiting writers.  */\n          lock->runcount--;\n          gl_waitqueue_notify_first (&lock->waiting_writers);\n        }\n      else\n        {\n          /* Wake up all waiting readers.  */\n          lock->runcount += lock->waiting_readers.count;\n          gl_waitqueue_notify_all (&lock->waiting_readers);\n        }\n    }\n  LeaveCriticalSection (&lock->lock);\n  return 0;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "glthread_rwlock_destroy_func": {
      "start_point": [
        933,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nglthread_rwlock_destroy_func (gl_rwlock_t *lock)\n{\n  if (!lock->guard.done)\n    return EINVAL;\n  if (lock->runcount != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  if (lock->waiting_readers.array != NULL)\n    free (lock->waiting_readers.array);\n  if (lock->waiting_writers.array != NULL)\n    free (lock->waiting_writers.array);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_init_func": {
      "start_point": [
        951,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "void\nglthread_recursive_lock_init_func (gl_recursive_lock_t *lock)\n{\n  lock->owner = 0;\n  lock->depth = 0;\n  InitializeCriticalSection (&lock->lock);\n  lock->guard.done = 1;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "glthread_recursive_lock_lock_func": {
      "start_point": [
        960,
        0
      ],
      "end_point": [
        988,
        1
      ],
      "content": "int\nglthread_recursive_lock_lock_func (gl_recursive_lock_t *lock)\n{\n  if (!lock->guard.done)\n    {\n      if (InterlockedIncrement (&lock->guard.started) == 0)\n        /* This thread is the first one to need this lock.  Initialize it.  */\n        glthread_recursive_lock_init (lock);\n      else\n        /* Yield the CPU while waiting for another thread to finish\n           initializing this lock.  */\n        while (!lock->guard.done)\n          Sleep (0);\n    }\n  {\n    DWORD self = GetCurrentThreadId ();\n    if (lock->owner != self)\n      {\n        EnterCriticalSection (&lock->lock);\n        lock->owner = self;\n      }\n    if (++(lock->depth) == 0) /* wraparound? */\n      {\n        lock->depth--;\n        return EAGAIN;\n      }\n  }\n  return 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_unlock_func": {
      "start_point": [
        990,
        0
      ],
      "end_point": [
        1003,
        1
      ],
      "content": "int\nglthread_recursive_lock_unlock_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != GetCurrentThreadId ())\n    return EPERM;\n  if (lock->depth == 0)\n    return EINVAL;\n  if (--(lock->depth) == 0)\n    {\n      lock->owner = 0;\n      LeaveCriticalSection (&lock->lock);\n    }\n  return 0;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "glthread_recursive_lock_destroy_func": {
      "start_point": [
        1005,
        0
      ],
      "end_point": [
        1013,
        1
      ],
      "content": "int\nglthread_recursive_lock_destroy_func (gl_recursive_lock_t *lock)\n{\n  if (lock->owner != 0)\n    return EBUSY;\n  DeleteCriticalSection (&lock->lock);\n  lock->guard.done = 0;\n  return 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "glthread_once_func": {
      "start_point": [
        1017,
        0
      ],
      "end_point": [
        1052,
        1
      ],
      "content": "void\nglthread_once_func (gl_once_t *once_control, void (*initfunction) (void))\n{\n  if (once_control->inited <= 0)\n    {\n      if (InterlockedIncrement (&once_control->started) == 0)\n        {\n          /* This thread is the first one to come to this once_control.  */\n          InitializeCriticalSection (&once_control->lock);\n          EnterCriticalSection (&once_control->lock);\n          once_control->inited = 0;\n          initfunction ();\n          once_control->inited = 1;\n          LeaveCriticalSection (&once_control->lock);\n        }\n      else\n        {\n          /* Undo last operation.  */\n          InterlockedDecrement (&once_control->started);\n          /* Some other thread has already started the initialization.\n             Yield the CPU while waiting for the other thread to finish\n             initializing and taking the lock.  */\n          while (once_control->inited < 0)\n            Sleep (0);\n          if (once_control->inited <= 0)\n            {\n              /* Take the lock.  This blocks until the other thread has\n                 finished calling the initfunction.  */\n              EnterCriticalSection (&once_control->lock);\n              LeaveCriticalSection (&once_control->lock);\n              if (!(once_control->inited > 0))\n                abort ();\n            }\n        }\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/lib/glthread/lock.h": {},
  "recutils/recutils-1.7/lib/glthread/threadlib.c": {
    "dummy_thread_func": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void *\ndummy_thread_func (void *arg)\n{\n  return arg;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndummy_thread_func (void *arg)",
        "*"
      ]
    },
    "glthread_in_use": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\nglthread_in_use (void)\n{\n  static int tested;\n  static int result; /* 1: linked with -lpthread, 0: only with libc */\n\n  if (!tested)\n    {\n      pthread_t thread;\n\n      if (pthread_create (&thread, NULL, dummy_thread_func, NULL) != 0)\n        /* Thread creation failed.  */\n        result = 0;\n      else\n        {\n          /* Thread creation works.  */\n          void *retval;\n          if (pthread_join (thread, &retval) != 0)\n            abort ();\n          result = 1;\n        }\n      tested = 1;\n    }\n  return result;\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/libcsv/csv.h": {},
  "recutils/recutils-1.7/libcsv/libcsv.c": {
    "csv_error": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "int\ncsv_error(struct csv_parser *p)\n{\n  /* Return the current status of the parser */\n  return p->status;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "csv_strerror": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "char *\ncsv_strerror(int status)\n{\n  /* Return a textual description of status */\n  if (status >= CSV_EINVALID || status < 0)\n    return csv_errors[CSV_EINVALID];\n  else\n    return csv_errors[status];\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "char",
        "*\ncsv_strerror(int status)",
        "*"
      ]
    },
    "csv_get_opts": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\ncsv_get_opts(struct csv_parser *p)\n{\n  /* Return the currently set options of parser */\n  if (p == NULL)\n    return -1;\n\n  return p->options;\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "csv_set_opts": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "int\ncsv_set_opts(struct csv_parser *p, unsigned char options)\n{\n  /* Set the options */\n  if (p == NULL)\n    return -1;\n\n  p->options = options;\n  return 0;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "csv_init": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "int\ncsv_init(struct csv_parser *p, unsigned char options)\n{\n  /* Initialize a csv_parser object returns 0 on success, -1 on error */\n  if (p == NULL)\n    return -1;\n\n  p->entry_buf = NULL;\n  p->pstate = ROW_NOT_BEGUN;\n  p->quoted = 0;\n  p->spaces = 0;\n  p->entry_pos = 0;\n  p->entry_size = 0;\n  p->status = 0;\n  p->options = options;\n  p->quote_char = CSV_QUOTE;\n  p->delim_char = CSV_COMMA;\n  p->is_space = NULL;\n  p->is_term = NULL;\n  p->blk_size = MEM_BLK_SIZE;\n  p->malloc_func = NULL;\n  p->realloc_func = realloc;\n  p->free_func = free;\n\n  return 0;\n}",
      "lines": 26,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "csv_free": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ncsv_free(struct csv_parser *p)\n{\n  /* Free the entry_buffer of csv_parser object */\n  if (p == NULL)\n    return;\n\n  if (p->entry_buf)\n    p->free_func(p->entry_buf);\n\n  p->entry_buf = NULL;\n  p->entry_size = 0;\n\n  return;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "csv_fini": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\ncsv_fini(struct csv_parser *p, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)\n{\n  /* Finalize parsing.  Needed, for example, when file does not end in a newline */\n  int quoted = p->quoted;\n  int pstate = p->pstate;\n  size_t spaces = p->spaces;\n  size_t entry_pos = p->entry_pos;\n\n  if (p == NULL)\n    return -1;\n\n\n  if (p->pstate == FIELD_BEGUN && p->quoted && p->options & CSV_STRICT && p->options & CSV_STRICT_FINI) {\n    /* Current field is quoted, no end-quote was seen, and CSV_STRICT_FINI is set */\n    p->status = CSV_EPARSE;\n    return -1;\n  }\n\n  switch (p->pstate) {\n    case FIELD_MIGHT_HAVE_ENDED:\n      p->entry_pos -= p->spaces + 1;  /* get rid of spaces and original quote */\n      /* Fall-through */\n    case FIELD_NOT_BEGUN:\n    case FIELD_BEGUN:\n      quoted = p->quoted, pstate = p->pstate;\n      spaces = p->spaces, entry_pos = p->entry_pos;\n      SUBMIT_FIELD(p);\n      SUBMIT_ROW(p, -1);\n    case ROW_NOT_BEGUN: /* Already ended properly */\n      ;\n  }\n\n  /* Reset parser */\n  p->spaces = p->quoted = p->entry_pos = p->status = 0;\n  p->pstate = ROW_NOT_BEGUN;\n\n  return 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "csv_set_delim": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\ncsv_set_delim(struct csv_parser *p, unsigned char c)\n{\n  /* Set the delimiter */\n  if (p) p->delim_char = c;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "csv_set_quote": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "void\ncsv_set_quote(struct csv_parser *p, unsigned char c)\n{\n  /* Set the quote character */\n  if (p) p->quote_char = c;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "csv_get_delim": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "unsigned char\ncsv_get_delim(struct csv_parser *p)\n{\n  /* Get the delimiter */\n  return p->delim_char;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "csv_get_quote": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "unsigned char\ncsv_get_quote(struct csv_parser *p)\n{\n  /* Get the quote character */\n  return p->quote_char;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "csv_set_space_func": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\ncsv_set_space_func(struct csv_parser *p, int (*f)(unsigned char))\n{\n  /* Set the space function */\n  if (p) p->is_space = f;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "csv_set_term_func": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "void\ncsv_set_term_func(struct csv_parser *p, int (*f)(unsigned char))\n{\n  /* Set the term function */\n  if (p) p->is_term = f;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "csv_set_realloc_func": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\ncsv_set_realloc_func(struct csv_parser *p, void *(*f)(void *, size_t))\n{\n  /* Set the realloc function used to increase buffer size */\n  if (p && f) p->realloc_func = f;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "csv_set_free_func": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void\ncsv_set_free_func(struct csv_parser *p, void (*f)(void *))\n{\n  /* Set the free function used to free the buffer */\n  if (p && f) p->free_func = f;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "csv_set_blk_size": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "void\ncsv_set_blk_size(struct csv_parser *p, size_t size)\n{\n  /* Set the block size used to increment buffer size */\n  if (p) p->blk_size = size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "csv_get_buffer_size": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "size_t\ncsv_get_buffer_size(struct csv_parser *p)\n{\n  /* Get the size of the entry buffer */\n  if (p)\n    return p->entry_size;\n  return 0;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "csv_increase_buffer": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static int\ncsv_increase_buffer(struct csv_parser *p)\n{\n  /* Increase the size of the entry buffer.  Attempt to increase size by \n   * p->blk_size, if this is larger than SIZE_MAX try to increase current\n   * buffer size to SIZE_MAX.  If allocation fails, try to allocate halve \n   * the size and try again until successful or increment size is zero.\n   */\n\n  size_t to_add = p->blk_size;\n  void *vp;\n\n  if ( p->entry_size >= SIZE_MAX - to_add )\n    to_add = SIZE_MAX - p->entry_size;\n\n  if (!to_add) {\n    p->status = CSV_ETOOBIG;\n    return -1;\n  }\n\n  while ((vp = p->realloc_func(p->entry_buf, p->entry_size + to_add)) == NULL) {\n    to_add /= 2;\n    if (!to_add) {\n      p->status = CSV_ENOMEM;\n      return -1;\n    }\n  }\n\n  /* Update entry buffer pointer and entry_size if successful */\n  p->entry_buf = vp;\n  p->entry_size += to_add;\n  return 0;\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "csv_parse": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "size_t\ncsv_parse(struct csv_parser *p, const void *s, size_t len, void (*cb1)(void *, size_t, void *), void (*cb2)(int c, void *), void *data)\n{\n  unsigned const char *us = s;  /* Access input data as array of unsigned char */\n  unsigned char c;              /* The character we are currently processing */\n  size_t pos = 0;               /* The number of characters we have processed in this call */\n\n  /* Store key fields into local variables for performance */\n  unsigned char delim = p->delim_char;\n  unsigned char quote = p->quote_char;\n  int (*is_space)(unsigned char) = p->is_space;\n  int (*is_term)(unsigned char) = p->is_term;\n  int quoted = p->quoted;\n  int pstate = p->pstate;\n  size_t spaces = p->spaces;\n  size_t entry_pos = p->entry_pos;\n\n\n  if (!p->entry_buf && pos < len) {\n    /* Buffer hasn't been allocated yet and len > 0 */\n    if (csv_increase_buffer(p) != 0) { \n      p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n      return pos;\n    }\n  }\n\n  while (pos < len) {\n    /* Check memory usage, increase buffer if neccessary */\n    if (entry_pos == ((p->options & CSV_APPEND_NULL) ? p->entry_size - 1 : p->entry_size) ) {\n      if (csv_increase_buffer(p) != 0) {\n        p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n        return pos;\n      }\n    }\n\n    c = us[pos++];\n\n    switch (pstate) {\n      case ROW_NOT_BEGUN:\n      case FIELD_NOT_BEGUN:\n        if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) { /* Space or Tab */\n          continue;\n        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) { /* Carriage Return or Line Feed */\n          if (pstate == FIELD_NOT_BEGUN) {\n            SUBMIT_FIELD(p);\n            SUBMIT_ROW(p, (unsigned char)c); \n          } else {  /* ROW_NOT_BEGUN */\n            /* Don't submit empty rows by default */\n            if (p->options & CSV_REPALL_NL) {\n              SUBMIT_ROW(p, (unsigned char)c);\n            }\n          }\n          continue;\n        } else if (c == delim) { /* Comma */\n          SUBMIT_FIELD(p);\n          break;\n        } else if (c == quote) { /* Quote */\n          pstate = FIELD_BEGUN;\n          quoted = 1;\n        } else {               /* Anything else */\n          pstate = FIELD_BEGUN;\n          quoted = 0;\n          SUBMIT_CHAR(p, c);\n        }\n        break;\n      case FIELD_BEGUN:\n        if (c == quote) {         /* Quote */\n          if (quoted) {\n            SUBMIT_CHAR(p, c);\n            pstate = FIELD_MIGHT_HAVE_ENDED;\n          } else {\n            /* STRICT ERROR - double quote inside non-quoted field */\n            if (p->options & CSV_STRICT) {\n              p->status = CSV_EPARSE;\n              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n              return pos-1;\n            }\n            SUBMIT_CHAR(p, c);\n            spaces = 0;\n          }\n        } else if (c == delim) {  /* Comma */\n          if (quoted) {\n            SUBMIT_CHAR(p, c);\n          } else {\n            SUBMIT_FIELD(p);\n          }\n        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */\n          if (!quoted) {\n            SUBMIT_FIELD(p);\n            SUBMIT_ROW(p, (unsigned char)c);\n          } else {\n            SUBMIT_CHAR(p, c);\n          }\n        } else if (!quoted && (is_space? is_space(c) : c == CSV_SPACE || c == CSV_TAB)) { /* Tab or space for non-quoted field */\n            SUBMIT_CHAR(p, c);\n            spaces++;\n        } else {  /* Anything else */\n          SUBMIT_CHAR(p, c);\n          spaces = 0;\n        }\n        break;\n      case FIELD_MIGHT_HAVE_ENDED:\n        /* This only happens when a quote character is encountered in a quoted field */\n        if (c == delim) {  /* Comma */\n          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */\n          SUBMIT_FIELD(p);\n        } else if (is_term ? is_term(c) : c == CSV_CR || c == CSV_LF) {  /* Carriage Return or Line Feed */\n          entry_pos -= spaces + 1;  /* get rid of spaces and original quote */\n          SUBMIT_FIELD(p);\n          SUBMIT_ROW(p, (unsigned char)c);\n        } else if (is_space ? is_space(c) : c == CSV_SPACE || c == CSV_TAB) {  /* Space or Tab */\n          SUBMIT_CHAR(p, c);\n          spaces++;\n        } else if (c == quote) {  /* Quote */\n          if (spaces) {\n            /* STRICT ERROR - unescaped double quote */\n            if (p->options & CSV_STRICT) {\n              p->status = CSV_EPARSE;\n              p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n              return pos-1;\n            }\n            spaces = 0;\n            SUBMIT_CHAR(p, c);\n          } else {\n            /* Two quotes in a row */\n            pstate = FIELD_BEGUN;\n          }\n        } else {  /* Anything else */\n          /* STRICT ERROR - unescaped double quote */\n          if (p->options & CSV_STRICT) {\n            p->status = CSV_EPARSE;\n            p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n            return pos-1;\n          }\n          pstate = FIELD_BEGUN;\n          spaces = 0;\n          SUBMIT_CHAR(p, c);\n        }\n        break;\n     default:\n       break;\n    }\n  }\n  p->quoted = quoted, p->pstate = pstate, p->spaces = spaces, p->entry_pos = entry_pos;\n  return pos;\n}",
      "lines": 146,
      "depth": 23,
      "decorators": [
        "size_t"
      ]
    },
    "csv_write": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "size_t\ncsv_write (void *dest, size_t dest_size, const void *src, size_t src_size)\n{\n  unsigned char *cdest = dest;\n  const unsigned char *csrc = src;\n  size_t chars = 0;\n\n  if (src == NULL)\n    return 0;\n\n  if (cdest == NULL)\n    dest_size = 0;\n\n  if (dest_size > 0)\n    *cdest++ = '\"';\n  chars++;\n\n  while (src_size) {\n    if (*csrc == '\"') {\n      if (dest_size > chars)\n        *cdest++ = '\"';\n      if (chars < SIZE_MAX) chars++;\n    }\n    if (dest_size > chars)\n      *cdest++ = *csrc;\n    if (chars < SIZE_MAX) chars++;\n    src_size--;\n    csrc++;\n  }\n\n  if (dest_size > chars)\n    *cdest = '\"';\n  if (chars < SIZE_MAX) chars++;\n\n  return chars;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "csv_fwrite": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        517,
        1
      ],
      "content": "int\ncsv_fwrite (FILE *fp, const void *src, size_t src_size)\n{\n  const unsigned char *csrc = src;\n\n  if (fp == NULL || src == NULL)\n    return 0;\n\n  if (fputc('\"', fp) == EOF)\n    return EOF;\n\n  while (src_size) {\n    if (*csrc == '\"') {\n      if (fputc('\"', fp) == EOF)\n        return EOF;\n    }\n    if (fputc(*csrc, fp) == EOF)\n      return EOF;\n    src_size--;\n    csrc++;\n  }\n\n  if (fputc('\"', fp) == EOF) {\n    return EOF;\n  }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "csv_write2": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "size_t\ncsv_write2 (void *dest, size_t dest_size, const void *src, size_t src_size, unsigned char quote)\n{\n  unsigned char *cdest = dest;\n  const unsigned char *csrc = src;\n  size_t chars = 0;\n\n  if (src == NULL)\n    return 0;\n\n  if (dest == NULL)\n    dest_size = 0;\n\n  if (dest_size > 0)\n    *cdest++ = quote;\n  chars++;\n\n  while (src_size) {\n    if (*csrc == quote) {\n      if (dest_size > chars)\n        *cdest++ = quote;\n      if (chars < SIZE_MAX) chars++;\n    }\n    if (dest_size > chars)\n      *cdest++ = *csrc;\n    if (chars < SIZE_MAX) chars++;\n    src_size--;\n    csrc++;\n  }\n\n  if (dest_size > chars)\n    *cdest = quote;\n  if (chars < SIZE_MAX) chars++;\n\n  return chars;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "size_t"
      ]
    },
    "csv_fwrite2": {
      "start_point": [
        556,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "int\ncsv_fwrite2 (FILE *fp, const void *src, size_t src_size, unsigned char quote)\n{\n  const unsigned char *csrc = src;\n\n  if (fp == NULL || src == NULL)\n    return 0;\n\n  if (fputc(quote, fp) == EOF)\n    return EOF;\n\n  while (src_size) {\n    if (*csrc == quote) {\n      if (fputc(quote, fp) == EOF)\n        return EOF;\n    }\n    if (fputc(*csrc, fp) == EOF)\n      return EOF;\n    src_size--;\n    csrc++;\n  }\n\n  if (fputc(quote, fp) == EOF) {\n    return EOF;\n  }\n\n  return 0;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-aggregate.c": {
    "rec_aggregate_reg_new": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "rec_aggregate_reg_t\nrec_aggregate_reg_new (void)\n{\n  rec_aggregate_reg_t new;\n\n  new = malloc (sizeof (struct rec_aggregate_reg_s));\n  if (new)\n    {\n      new->num_functions = 0;\n    }\n\n  return new;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "rec_aggregate_reg_t"
      ]
    },
    "rec_aggregate_reg_destroy": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nrec_aggregate_reg_destroy (rec_aggregate_reg_t func_reg)\n{\n  if (func_reg)\n    {\n      size_t i = 0;\n      for (i = 0; i < func_reg->num_functions; i++)\n        {\n          free (func_reg->functions[i].name);\n        }\n\n      free (func_reg);\n    }\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_aggregate_reg_add": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "bool\nrec_aggregate_reg_add (rec_aggregate_reg_t func_reg,\n                       const char *name,\n                       rec_aggregate_t function)\n{\n  bool function_replaced = false;\n  size_t i = 0;\n\n  for (i = 0; i < func_reg->num_functions; i++)\n    {\n      if (strcmp (name, func_reg->functions[i].name) == 0)\n        {\n          /* Replace the existing function.  */\n          func_reg->functions[i].function = function;\n          function_replaced = true;\n          break;\n        }\n    }\n\n  if (!function_replaced)\n    {\n      /* Insert the function into a new entry in the registry.  */\n\n      if (func_reg->num_functions == MAX_FUNCTIONS)\n        {\n          /* FIXME: this is crappy as hell.  */\n          return false;\n        }\n\n      func_reg->functions[func_reg->num_functions].name = strdup (name);\n      func_reg->functions[func_reg->num_functions].function = function;\n      func_reg->num_functions++;\n    }\n\n  return true;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "rec_aggregate_reg_get": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "rec_aggregate_t\nrec_aggregate_reg_get (rec_aggregate_reg_t func_reg,\n                       const char *name)\n{\n  size_t i = 0;\n  rec_aggregate_t res = NULL;\n\n  for (i = 0; i < func_reg->num_functions; i++)\n    {\n      if (strcasecmp (func_reg->functions[i].name, name) == 0)\n        {\n          res = func_reg->functions[i].function;\n          break;\n        }\n    }\n\n  return res;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "rec_aggregate_t"
      ]
    },
    "rec_aggregate_reg_add_standard": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\nrec_aggregate_reg_add_standard (rec_aggregate_reg_t func_reg)\n{\n  size_t i = 0;\n\n  for (i = 0; i < NUM_STD_AGGREGATES; i++)\n    {\n      rec_aggregate_reg_add (func_reg, std_aggregates[i].name, std_aggregates[i].func);\n    }\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_aggregate_std_p": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "bool\nrec_aggregate_std_p (const char *name)\n{\n  bool found = false;\n  size_t i   = 0;\n\n  for (i = 0; i < NUM_STD_AGGREGATES; i++)\n    {\n      if (strcasecmp (name, std_aggregates[i].name) == 0)\n        {\n          found = true;\n          break;\n        }\n    }\n\n  return found;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_aggregate_std_count": {
      "start_point": [
        229,
        0
      ],
      "end_point": [
        258,
        1
      ],
      "content": "static char *\nrec_aggregate_std_count (rec_rset_t rset,\n                         rec_record_t record,\n                         const char *field_name)\n{\n  char *result = NULL;\n  size_t count = 0;\n\n  if (record)\n    {\n      count = rec_record_get_num_fields_by_name (record, field_name);\n    }\n  else if (rset)\n    {\n      rec_record_t rec = NULL;\n      rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (void *) &rec, NULL))\n        {\n          count = count + rec_record_get_num_fields_by_name (rec, field_name);\n        }\n      rec_mset_iterator_free (&iter);\n    }\n\n  /* Return the count as a string.  Note that if NULL is returned it\n     will be returned by this function below to signal the\n     end-of-memory condition.  */\n      \n  asprintf (&result, \"%zu\", count);\n  return result;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrec_aggregate_std_count (rec_rset_t rset,\n                         rec_record_t record,\n                         const char *field_name)",
        "*"
      ]
    },
    "rec_aggregate_std_avg": {
      "start_point": [
        260,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static char *\nrec_aggregate_std_avg (rec_rset_t rset,\n                       rec_record_t record,\n                       const char *field_name)\n{\n  char *result = NULL;\n  double avg = 0;\n\n  if (record)\n    {\n      avg = rec_aggregate_std_avg_record (record, field_name);\n    }\n  else if (rset)\n    {\n      size_t num_records = 0;\n      rec_record_t rec = NULL;\n      rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (void *) &rec, NULL))\n        {\n          avg = avg + rec_aggregate_std_avg_record (rec, field_name);\n          num_records++;\n        }\n      rec_mset_iterator_free (&iter);\n\n      if (num_records != 0)\n        {\n          avg = avg / num_records;\n        }\n    }\n\n  /* Return the average as a string.  Note that if NULL is returned it\n     will be returned by this function below to signal the\n     end-of-memory condition.  */\n      \n  if (avg == floor (avg))\n    {\n      asprintf (&result, \"%zu\", (size_t) avg);\n    }\n  else\n    {\n      asprintf (&result, \"%f\", avg);\n    }\n\n  return result;\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrec_aggregate_std_avg (rec_rset_t rset,\n                       rec_record_t record,\n                       const char *field_name)",
        "*"
      ]
    },
    "rec_aggregate_std_avg_record": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "static double\nrec_aggregate_std_avg_record (rec_record_t record,\n                              const char *field_name)\n{\n  double avg = 0;\n  rec_field_t field;\n  size_t num_fields = 0;\n  rec_mset_iterator_t iter = rec_mset_iterator (rec_record_mset (record));\n\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (void *) &field, NULL))\n    {\n      double field_value_double = 0;\n      const char *field_value = rec_field_value (field);\n\n      if (rec_field_name_equal_p (rec_field_name (field), field_name)\n          && rec_atod (field_value, &field_value_double))\n        {\n          avg = avg + field_value_double;\n          num_fields++;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  if (num_fields != 0)\n    {\n      avg = avg / num_fields;\n    }\n\n  return avg;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "op_sum": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "static inline double\nop_sum (double op1, double op2)\n{\n  return op1 + op2;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "double"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-buf.c": {
    "rec_buf_new": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "rec_buf_t\nrec_buf_new (char **data, size_t *size)\n{\n  rec_buf_t new;\n\n  new = malloc (sizeof (struct rec_buf_s));\n  if (new)\n    {\n      new->data_pointer = data;\n      new->size_pointer = size;\n\n      new->data = malloc (REC_BUF_STEP);\n      new->size = REC_BUF_STEP;\n      new->used = 0;\n\n      if (!new->data)\n        {\n          free (new);\n          new = NULL;\n        }\n    }\n\n  return new;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "rec_buf_t"
      ]
    },
    "rec_buf_close": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nrec_buf_close (rec_buf_t buf)\n{\n  /* Adjust the buffer.  */\n  if (buf->used > 0)\n    {\n      buf->data = realloc (buf->data, buf->used + 1);\n    }\n  buf->data[buf->used] = '\\0';\n\n  /* Update the user-provided buffer and size.  */\n  *(buf->data_pointer) = buf->data;\n  *(buf->size_pointer) = buf->used;\n\n  /* Don't deallocate buf->data */\n  free (buf);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_buf_rewind": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nrec_buf_rewind (rec_buf_t buf, int n)\n{\n  if ((buf->used - n) >= 0)\n    {\n      buf->used = buf->used - n;\n    }\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_buf_putc": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "int\nrec_buf_putc (int c, rec_buf_t buf)\n{\n  unsigned int ret;\n\n  if (c == EOF)\n    {\n      return EOF;\n    }\n\n  ret = (unsigned int) c;\n  if ((buf->used + 1) > buf->size)\n    {\n      /* Allocate a new block */\n      buf->size = buf->size + REC_BUF_STEP;\n      buf->data = realloc (buf->data, buf->size);\n\n      if (!buf->data)\n        {\n          /* Not enough memory.\n           * REC_BUF_STEP should not be 0. */\n          ret = EOF;\n        }\n    }\n\n  if (ret != EOF)\n    {\n      /* Add the character */\n      buf->data[buf->used++] = (char) c;\n    }\n\n  return ret;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rec_buf_puts": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "int\nrec_buf_puts (const char *str, rec_buf_t buf)\n{\n  int ret;\n  const char *p;\n\n  ret = 0;\n  p = str;\n  while (*p != '\\0')\n    {\n      if (rec_buf_putc (*p, buf) == EOF)\n        {\n          /* Error.  */\n          ret = -1;\n          break;\n        }\n\n      ret++;\n      p++;\n    }\n\n  return ret;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-comment.c": {
    "rec_comment_new": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "rec_comment_t\nrec_comment_new (char *text)\n{\n  if (!text)\n    {\n      return NULL;\n    }\n\n  return strdup (text);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "rec_comment_t"
      ]
    },
    "rec_comment_destroy": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nrec_comment_destroy (rec_comment_t comment)\n{\n  free (comment);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_comment_dup": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "rec_comment_t\nrec_comment_dup (rec_comment_t comment)\n{\n  return strdup (comment);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "rec_comment_t"
      ]
    },
    "rec_comment_text": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "char *\nrec_comment_text (rec_comment_t comment)\n{\n  return comment;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "*\nrec_comment_text (rec_comment_t comment)",
        "*"
      ]
    },
    "rec_comment_set_text": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nrec_comment_set_text (rec_comment_t *comment,\n                      char *text)\n{\n  free (*comment);\n  *comment = strdup (text);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_comment_equal_p": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "bool\nrec_comment_equal_p (rec_comment_t comment1,\n                     rec_comment_t comment2)\n{\n  return (strcmp (comment1, comment2) == 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-crypt-dummy.c": {
    "rec_encrypt": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "bool\nrec_encrypt (char   *in,\n             size_t  in_size,\n             const char   *password,\n             char  **out,\n             size_t *out_size)\n{\n  return false;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "bool\nrec_decrypt (char   *in,\n             size_t  in_size,\n             const char   *password,\n             char  **out,\n             size_t *out_size)\n{\n  return false;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_encrypt_record": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "bool\nrec_encrypt_record (rec_rset_t rset,\n                    rec_record_t record,\n                    const char *password)\n{\n  return false;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_encrypt_field": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "bool\nrec_encrypt_field (rec_field_t field,\n                   const char *password)\n{\n  return false;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt_field": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "bool\nrec_decrypt_field (rec_field_t field,\n                   const char *password)\n{\n  return false;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt_record": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "bool\nrec_decrypt_record (rec_rset_t rset,\n                    rec_record_t record,\n                    const char *password)\n{\n  return false;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-crypt.c": {
    "rec_field_encrypted_p": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static bool\nrec_field_encrypted_p (rec_field_t field)\n{\n  return ((strlen (rec_field_value (field)) > strlen (REC_ENCRYPTED_PREFIX))\n          && (strncmp (rec_field_value (field), REC_ENCRYPTED_PREFIX,\n                       strlen (REC_ENCRYPTED_PREFIX)) == 0));\n}",
      "lines": 7,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_encrypt": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "bool\nrec_encrypt (char   *in,\n             size_t  in_size,\n             const char   *password,\n             char  **out,\n             size_t *out_size)\n{\n  gcry_cipher_hd_t handler;\n  size_t i;\n  size_t password_size;\n  char key[AESV2_KEYSIZE];\n  char iv[AESV2_BLKSIZE];\n  size_t padding;\n  uint32_t crc;\n  char *real_in;\n  size_t real_in_size;\n\n  /* Append four bytes to the input buffer, containing the CRC of its\n     contents.  This will be used as a control token to determine\n     whether the correct key is used in decryption.\n  \n     We store the integer always in little-endian. */\n  \n  crc = crc32 (in, in_size);\n  \n#if defined WORDS_BIGENDIAN\n  crc = rec_endian_swap (crc);\n#endif\n\n  real_in_size = in_size + 4;\n  real_in = malloc (real_in_size + 4);\n  memcpy (real_in, in, real_in_size);\n  memcpy (real_in + real_in_size - 4, &crc, 4);\n\n  /* The size of the input buffer must be bigger than AESV2_BLKSIZE,\n     and must contain an entire number of blocks.  We assure that by\n     padding the buffer with \\0 characters.  */\n\n  if ((real_in_size % AESV2_BLKSIZE) != 0)\n    {\n      padding = AESV2_BLKSIZE - (real_in_size % AESV2_BLKSIZE);\n    }\n  else\n    {\n      padding = 0;\n    }\n\n  if (padding != 0)\n    {\n      real_in_size = real_in_size + padding;\n      real_in = realloc (real_in, real_in_size);\n\n      for (i = 0; i < padding; i++)\n        {\n          real_in[real_in_size - i - 1] = '\\0';\n        }\n    }  \n\n  /* Create the handler.  */\n  if (gcry_cipher_open (&handler,\n                        GCRY_CIPHER_AES128,\n                        GCRY_CIPHER_MODE_CBC,\n                        0) != GPG_ERR_NO_ERROR)\n    {\n      return false;\n    }\n\n  /* Set the key of the cypher.  */\n  password_size = strlen (password);\n  for (i = 0; i < AESV2_KEYSIZE; i++)\n    {\n      key[i] = password[i % password_size];\n    }\n\n  /* Set both the key and the IV vector.  */\n  if (gcry_cipher_setkey (handler, key, AESV2_KEYSIZE)\n      != GPG_ERR_NO_ERROR)\n    {\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  gcry_create_nonce (iv, SALT_SIZE);\n  for (i = SALT_SIZE; i < AESV2_BLKSIZE; i++)\n    {\n      iv[i] = i;\n    }\n  if (gcry_cipher_setiv (handler, iv, AESV2_BLKSIZE)\n      != GPG_ERR_NO_ERROR)\n    {\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  *out_size = real_in_size + SALT_SIZE;\n  *out = malloc (*out_size);\n\n  /* Append salt at the end of the output.  */\n  memcpy (*out + real_in_size, iv, SALT_SIZE);\n\n  /* Encrypt the data.  */\n  if (gcry_cipher_encrypt (handler,\n                           *out,\n                           real_in_size,\n                           real_in,\n                           real_in_size) != 0)\n    {\n      /* Error.  */\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  /* Close the handler.  */\n  gcry_cipher_close (handler);\n\n  return true;\n}",
      "lines": 117,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "bool\nrec_decrypt (char   *in,\n             size_t  in_size,\n             const char   *password,\n             char  **out,\n             size_t *out_size)\n{\n  gcry_cipher_hd_t handler;\n  size_t i;\n  size_t password_size;\n  char key[AESV2_KEYSIZE];\n  char iv[AESV2_BLKSIZE];\n  size_t salt_size = 0;\n\n  if (((in_size - SALT_SIZE) % AESV2_BLKSIZE) == 0)\n    {\n      salt_size = SALT_SIZE;\n    }\n  else if ((in_size % AESV2_BLKSIZE) != 0)\n    {\n      return false;\n    }\n\n  /* Create the handler.  */\n  if (gcry_cipher_open (&handler,\n                        GCRY_CIPHER_AES128,\n                        GCRY_CIPHER_MODE_CBC,\n                        0) != GPG_ERR_NO_ERROR)\n    {\n      return false;\n    }\n\n  /* Set the key of the cypher.  */\n  password_size = strlen (password);\n  for (i = 0; i < AESV2_KEYSIZE; i++)\n    {\n      key[i] = password[i % password_size];\n    }\n\n  /* Set both the key and the IV vector.  */\n  if (gcry_cipher_setkey (handler, key, AESV2_KEYSIZE)\n      != GPG_ERR_NO_ERROR)\n    {\n      printf (\"error setting key\\n\");\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  /* Extract salt at the end of the output.  */\n  memcpy (iv, in + in_size - salt_size, salt_size);\n  for (i = salt_size; i < AESV2_BLKSIZE; i++)\n    {\n      iv[i] = i;\n    }\n  if (gcry_cipher_setiv (handler, iv, AESV2_BLKSIZE)\n      != GPG_ERR_NO_ERROR)\n    {\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  /* Decrypt the data.  */\n  *out_size = in_size - salt_size;\n  *out = malloc (*out_size);\n  if (gcry_cipher_decrypt (handler,\n                           *out,\n                           *out_size,\n                           in,\n                           in_size - salt_size) != 0)\n    {\n      /* Error.  */\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  /* Make sure the decrypted data is ok by checking the CRC at the end\n     of the sequence.  */\n\n  if (strlen(*out) > 4)\n    {\n      uint32_t crc = 0;\n      \n      memcpy (&crc, *out + strlen(*out) - 4, 4);\n#if defined WORDS_BIGENDIAN\n      crc = rec_endian_swap (crc);\n#endif\n\n      if (crc32 (*out, strlen(*out) - 4) != crc)\n        {\n          gcry_cipher_close (handler);\n          return false;\n        }\n\n      (*out)[strlen(*out) - 4] = '\\0';\n    }\n  else\n    {\n      gcry_cipher_close (handler);\n      return false;\n    }\n\n  /* Close the handler.  */\n  gcry_cipher_close (handler);\n\n  return true;\n}",
      "lines": 106,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "rec_encrypt_record": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "bool\nrec_encrypt_record (rec_rset_t rset,\n                    rec_record_t record,\n                    const char *password)\n{\n  rec_field_t field;\n  bool res;\n  const char *field_name;\n  rec_fex_t confidential_fields;\n  size_t i, k, num_fields;\n\n  res = true;\n\n  if (rset)\n    {\n      confidential_fields = rec_rset_confidential (rset);\n      for (i = 0; i < rec_fex_size (confidential_fields); i++)\n        {\n          field_name = rec_fex_elem_field_name (rec_fex_get (confidential_fields, i));\n\n          num_fields = rec_record_get_num_fields_by_name (record, field_name);\n          for (k = 0; k < num_fields; k++)\n            {\n              field = rec_record_get_field_by_name (record, field_name, k);\n              if (field)\n                {\n                  res = rec_encrypt_field (field, password);\n                  if (!res)\n                    break;\n                }\n            }\n        }\n    }\n\n  return res;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_encrypt_field": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "bool\nrec_encrypt_field (rec_field_t field,\n                   const char *password)\n{\n  char *field_value;\n  char *field_value_encrypted;\n  char *field_value_base64;\n  size_t out_size, base64_size;\n  char *aux;\n\n  field_value = strdup (rec_field_value (field));\n  if (!field_value)\n    {\n      return false;\n    }\n\n  /* Make sure the field is not already encrypted.  */\n  if ((strlen (rec_field_value (field)) >= strlen (REC_ENCRYPTED_PREFIX))\n      && (strncmp (rec_field_value (field), REC_ENCRYPTED_PREFIX,\n                   strlen (REC_ENCRYPTED_PREFIX)) == 0))\n    return true;\n\n  if (!rec_encrypt (field_value,\n                    strlen (field_value),\n                    password,\n                    &field_value_encrypted,\n                    &out_size))\n    {\n      return false;\n    }\n  \n  /* Encode the encrypted value into base64.  */\n\n  base64_size = base64_encode_alloc (field_value_encrypted,\n                                     out_size,\n                                     &field_value_base64);\n  base64_encode (field_value_encrypted,\n                 out_size,\n                 field_value_base64,\n                 base64_size);\n\n  /* Prepennd \"encrypted-\".  */\n  aux = malloc (strlen (field_value_base64)\n                + strlen (REC_ENCRYPTED_PREFIX) + 1);\n  memcpy (aux,\n          REC_ENCRYPTED_PREFIX,\n          strlen (REC_ENCRYPTED_PREFIX));\n  memcpy (aux + strlen (REC_ENCRYPTED_PREFIX),\n          field_value_base64,\n          strlen (field_value_base64));\n  aux[strlen (field_value_base64)\n      + strlen (REC_ENCRYPTED_PREFIX)] = '\\0';\n  free (field_value_base64);\n  field_value_base64 = aux;\n  \n  /* Replace the value of the field.  */\n  rec_field_set_value (field, field_value_base64);\n  \n  /* Free resources.  */\n  free (field_value);\n  free (field_value_encrypted);\n  free (field_value_base64);\n\n  return true;\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt_field": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "bool\nrec_decrypt_field (rec_field_t field,\n                   const char *password)\n{\n  const char *field_value;\n  char *base64_decoded;\n  size_t base64_decoded_size;\n  char *decrypted_value;\n  size_t decrypted_value_size;\n\n  /* Make sure the field is encrypted.  */\n  if ((strlen (rec_field_value (field)) < strlen (REC_ENCRYPTED_PREFIX))\n      || (strncmp (rec_field_value (field), REC_ENCRYPTED_PREFIX,\n                   strlen (REC_ENCRYPTED_PREFIX)) != 0))\n    return true;\n\n  /* Skip the \"encrypted-\" prefix.  */\n  field_value = rec_field_value (field) + strlen (REC_ENCRYPTED_PREFIX);\n\n  /* Decode the Base64.  */\n\n  if (base64_decode_alloc (field_value,\n                           strlen(field_value),\n                           &base64_decoded,\n                           &base64_decoded_size))\n    {\n      base64_decode (field_value,\n                     strlen(field_value),\n                     base64_decoded,\n                     &base64_decoded_size);\n      \n      /* Decrypt.  */\n\n      if (rec_decrypt (base64_decoded,\n                       base64_decoded_size,\n                       password,\n                       &decrypted_value,\n                       &decrypted_value_size))\n        {\n          rec_field_set_value (field, decrypted_value);\n        }\n\n      /* Free resources.  */\n      free (base64_decoded);\n    }\n\n  return true;\n}",
      "lines": 48,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_decrypt_record": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        459,
        1
      ],
      "content": "bool\nrec_decrypt_record (rec_rset_t rset,\n                    rec_record_t record,\n                    const char *password)\n{\n  bool res = true;\n  size_t i, num_fields, k;\n  rec_field_t field;\n  const char *field_name;\n  rec_fex_t confidential_fields;\n\n  if (rset)\n    {\n      confidential_fields = rec_rset_confidential (rset);\n      for (i = 0; i < rec_fex_size (confidential_fields); i++)\n        {\n          field_name = rec_fex_elem_field_name (rec_fex_get (confidential_fields, i));\n\n          num_fields = rec_record_get_num_fields_by_name (record, field_name);\n          for (k = 0; k < num_fields; k++)\n            {\n              field = rec_record_get_field_by_name (record, field_name, k);\n              if (field)\n                {\n                  res = rec_decrypt_field (field, password);\n                  if (!res)\n                    break;\n                }\n            }\n        }\n    }\n\n  return res;\n}",
      "lines": 34,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-db.c": {
    "rec_db_new": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "rec_db_t\nrec_db_new (void)\n{\n  rec_db_t new;\n\n  new = malloc (sizeof (struct rec_db_s));\n  if (new)\n    {\n      new->size = 0;\n      new->rset_list = gl_list_nx_create_empty (GL_ARRAY_LIST,\n                                                rec_db_rset_equals_fn,\n                                                NULL,\n                                                rec_db_rset_dispose_fn,\n                                                true);\n      \n      if (new->rset_list == NULL)\n        {\n          /* Out of memory.  */\n          free (new);\n          new = NULL;\n        }\n\n      /* Add the standard field functions to the registry in the\n         database.  */\n\n      new->aggregates = rec_aggregate_reg_new ();\n      if (!new->aggregates)\n        {\n          /* Out of memory.  */\n          free (new);\n          return NULL;\n        }\n      rec_aggregate_reg_add_standard (new->aggregates);\n    }\n\n  return new;\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "rec_db_t"
      ]
    },
    "rec_db_destroy": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\nrec_db_destroy (rec_db_t db)\n{\n  if (db)\n    {\n      rec_aggregate_reg_destroy (db->aggregates);\n      gl_list_free (db->rset_list);\n      free (db);\n    }\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_db_size": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "size_t\nrec_db_size (rec_db_t db)\n{\n  return db->size;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_db_get_rset": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "rec_rset_t\nrec_db_get_rset (rec_db_t db,\n                 size_t position)\n{\n  rec_rset_t rset;\n\n  rset = NULL;\n\n  if (db->size > 0)\n    {\n      if (position >= db->size)\n        {\n          position = db->size - 1;\n        }\n\n      rset = (rec_rset_t) gl_list_get_at (db->rset_list, position);\n    }\n\n  return rset;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_db_insert_rset": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "bool\nrec_db_insert_rset (rec_db_t db,\n                    rec_rset_t rset,\n                    size_t position)\n{\n  gl_list_node_t node;\n\n  node = NULL;\n\n  if (position == 0)\n    {\n      node = gl_list_nx_add_first (db->rset_list,\n                                   (void *) rset);\n    }\n  else if (position >= db->size)\n    {\n      node = gl_list_nx_add_last (db->rset_list,\n                                  (void *) rset);\n    }\n  else\n    {\n      node = gl_list_nx_add_at (db->rset_list,\n                                position,\n                                (void *) rset);\n    }\n\n  if (node != NULL)\n    {\n      db->size++;\n      return true;\n    }\n\n  return false;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_remove_rset": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "bool\nrec_db_remove_rset (rec_db_t db, size_t position)\n{\n  bool removed;\n\n  removed = false;\n  \n  if (db->size > 0)\n    {\n      if (position >= db->size)\n        {\n          position = db->size - 1;\n        }\n      \n      if (gl_list_remove_at (db->rset_list,\n                             position))\n        {\n          db->size--;\n          removed = true;\n        }\n    }\n  \n  return removed;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_type_p": {
      "start_point": [
        216,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "bool\nrec_db_type_p (rec_db_t db,\n               const char *type)\n{\n  return (rec_db_get_rset_by_type (db, type) != NULL);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_get_rset_by_type": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        263,
        1
      ],
      "content": "rec_rset_t\nrec_db_get_rset_by_type (rec_db_t db,\n                         const char *type)\n{\n  int i;\n  rec_rset_t rset;\n  bool found;\n  char *rtype;\n\n  found = false;\n  for (i = 0; i < rec_db_size (db); i++)\n    {\n      rset = rec_db_get_rset (db, i);\n      rtype = rec_rset_type (rset);\n      if (rtype == NULL)\n        {\n          if (type == NULL)\n            {\n              /* Return the default rset.  */\n              found = true;\n              break;\n            }\n        }\n      else\n        { \n          if ((type != NULL)\n              && (strcmp (rtype, type) == 0))\n            {\n              found = true;\n              break;\n            }\n        }\n    }\n\n  if (!found)\n    {\n      rset = NULL;\n    }\n  \n  return rset;\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_db_query": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "rec_rset_t\nrec_db_query (rec_db_t     db,\n              const char  *type,\n              const char  *join,\n              size_t       *index,\n              rec_sex_t    sex,\n              const char  *fast_string,\n              size_t       random,\n              rec_fex_t    fex,\n              const char  *password,\n              rec_fex_t    group_by,\n              rec_fex_t    sort_by,\n              int          flags)\n{\n  rec_rset_t res = NULL;\n  rec_rset_t rset = NULL;\n\n  /* Create a new, empty, record set, that will contain the contents\n     of the selection.  */\n\n  res = rec_rset_new ();\n  if (!res)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n\n  /* Search for the rset containing records of the requested type.  If\n     type equals to NULL then the default record set is used.  If JOIN\n     is not NULL then the record set must be the join of the involved\n     record sets.  */\n\n  rset = rec_db_get_rset_by_type (db, type);\n  if (!rset)\n    {\n      /* If the default record set was selected, it was not found, and\n         the database contains only one record set, then it is\n         selected.  */\n\n      if (!type && (rec_db_size (db) == 1))\n        {\n          rset = rec_db_get_rset (db, 0);\n        }\n      else\n        {\n          /* Type not found, so return an empty record set.  */\n          return res;\n        }\n    }\n  else\n    {\n      if (join)\n        {\n          /* A join was requested.  The steps to proceed are:\n             \n             - Make sure that the requested field join is declared of\n               type 'rec' in the record set.\n             - Retrieve the referred record set from the database.\n             - Calculate the join and store it in 'rset'.\n          */\n\n          rec_type_t ref_type = rec_rset_get_field_type (rset, join);\n          if (ref_type && (rec_type_kind (ref_type) == REC_TYPE_REC))\n            {\n              const char *referred_type = rec_type_rec (ref_type);\n\n              if (rec_db_get_rset_by_type (db, referred_type))\n                {\n                  rset = rec_db_join (db, type, join, referred_type);\n                  if (!rset)\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                }\n            }\n        }\n    }\n\n  /* If a descriptor is requested then get a copy of the descriptor of\n     the referred record set, which exists only if it is not the\n     default.  */\n\n  if (flags & REC_F_DESCRIPTOR)\n    {\n      rec_record_t descriptor = rec_rset_descriptor (rset);\n      if (descriptor)\n        {\n          descriptor = rec_record_dup (descriptor);\n          if (!descriptor)\n            {\n              /* Out of memory.  */\n              free (res);\n              return NULL;\n            }\n        }\n\n      rec_rset_set_descriptor (res, descriptor);\n    }\n  \n  /* Generate a list of random indexes here if requested.  The\n     generated random indexes are added to the indexes list, which\n     must be NULL if random > 0 (mutually exclusive arguments).  */\n\n  if (random > 0)\n    {\n      rec_db_add_random_indexes (&index, random, rec_rset_num_records (rset));\n      if (!index)\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n    }\n\n  if (fex && !group_by && rec_fex_all_calls_p (fex))\n    {\n      /* This query is a request for the value of several aggregates,\n         with no grouping.  This means that the resulting rset will\n         contain one record containing the evaluation of the\n         aggregates.  This is peformed by invoking rec_db_process_fex\n         with a NULL record.  */\n\n      rec_record_t record = rec_db_process_fex (db, rset, NULL, fex);\n      if (record)\n        {\n          rec_record_set_container (record, res);\n          if (!rec_mset_append (rec_rset_mset (res),\n                                MSET_RECORD,\n                                (void *) record,\n                                MSET_RECORD))\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n        }\n    }\n  else\n    {\n      /* Process this record set.  This means that every record of this\n         record set which is selected by some of the selection arguments\n         (a sex, an index, a random selection or a \"fast string\") will\n         be duplicated and added to the 'res' record set.  */\n\n      rec_record_t record = NULL;\n      size_t num_rec = -1;\n\n      if (group_by)\n        {\n          if (!rec_rset_sort (rset, group_by))\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n\n          if (!rec_rset_group (rset, group_by))\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n        }\n\n      if (!rec_rset_sort (rset, sort_by))\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n\n      rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, NULL))\n        {\n          rec_record_t res_record;\n          num_rec++;\n        \n          /* Determine whether we must skip this record.  */\n        \n          if (!rec_db_record_selected_p (num_rec,\n                                         record,\n                                         index,\n                                         sex,\n                                         fast_string,\n                                         flags & REC_F_ICASE))\n            {\n              continue;\n            }\n              \n          /* Process this record.  */\n\n          /* Transform the record through the field expression and add\n             it to the result record set.  */\n      \n          res_record\n            = rec_db_process_fex (db, rset, record, fex);\n\n          if (!res_record)\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n\n          /* Do not add empty records to the result record set.  */\n\n          if (rec_record_num_elems (res_record) == 0)\n            {\n              continue;\n            }\n\n#if defined REC_CRYPT_SUPPORT\n\n          /* Decrypt the confidential fields in the record if some\n             of the fields are declared as \"confidential\", but only\n             do that if the user provided a password.  Note that we\n             use 'rset' instead of 'res' to cover cases where (flags\n             & REC_F_DESCRIPTOR) == 0.  */\n        \n          if (password)\n            {\n              if (!rec_decrypt_record (rset, res_record, password))\n                {\n                  /* Out of memory.  */\n                  return NULL;\n                }\n            }\n#endif\n\n          /* Remove duplicated fields if requested by the user.  */\n        \n          if (flags & REC_F_UNIQ)\n            {\n              rec_record_uniq (res_record);\n            }\n        \n          /* Append.  */\n\n          rec_record_set_container (res_record, res);\n          if (!rec_mset_append (rec_rset_mset (res),\n                                MSET_RECORD,\n                                (void *) res_record,\n                                MSET_RECORD))\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n        \n        }\n      rec_mset_iterator_free (&iter);\n    }\n\n  return res;\n}",
      "lines": 249,
      "depth": 15,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_db_insert": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        722,
        1
      ],
      "content": "bool\nrec_db_insert (rec_db_t db,\n               const char *type,\n               size_t *index,\n               rec_sex_t sex,\n               const char *fast_string,\n               size_t random,\n               const char *password,\n               rec_record_t record,\n               int flags)\n{\n  /* Discard NULL or empty records.  */\n  \n  if (!record || (rec_record_num_fields (record) == 0))\n    {\n      return true;\n    }\n\n  /* Insert the record in the database.  */\n\n  if (index || sex || fast_string || (random > 0))\n    {\n      /* Replace matching records with copies of RECORD.  */\n\n      rec_rset_t rset = rec_db_get_rset_by_type (db, type);\n      if (rset)\n        {\n          size_t num_rec = -1;\n\n          /* If the user requested to replace random records,\n             calculate them now for this record set.  */\n\n          if (random > 0)\n            {\n              rec_db_add_random_indexes (&index, random, rec_rset_num_records (rset));\n              if (!index)\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n            }\n\n          /* Add auto generated fields unless the user disabled\n             it.  */\n\n          if (!(flags & REC_F_NOAUTO))\n            {\n              if (!rec_rset_add_auto_fields (rset, record))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n            }\n\n#if defined REC_CRYPT_SUPPORT\n\n          /* Encrypt confidential fields if a password was provided by\n             the user.  */\n\n          if (password)\n            {\n              if (!rec_encrypt_record (rset, record, password))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n            }\n#endif\n\n          /* Iterate on the record set, replacing matching records\n             with copies of the provided record.  */\n\n          {\n            rec_record_t rset_record = NULL;\n            rec_mset_elem_t elem;\n            rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n\n            while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &rset_record, &elem))\n              {\n                num_rec++;\n\n                /* Shall we skip this record?  */\n\n                if (!rec_db_record_selected_p (num_rec,\n                                               rset_record,\n                                               index,\n                                               sex,\n                                               fast_string,\n                                               flags & REC_F_ICASE))\n                  {\n                    continue;\n                  }\n\n                /* Replace the record.  */\n\n                rec_record_set_container (record, rset);\n                rec_mset_elem_set_data (elem, (void *) rec_record_dup (record));\n                \n              }\n            rec_mset_iterator_free (&iter);\n          }\n        }\n    }\n  else\n    {\n      /* Append the record in the proper record set.  */\n      \n      rec_rset_t rset = rec_db_get_rset_by_type (db, type);\n\n      if (rset)\n        {\n          rec_record_set_container (record, rset);\n\n          /* Add auto-set fields required by this record set, unless\n             the addition of auto-fields is disabled by the user.  */\n\n          if (!(flags & REC_F_NOAUTO))\n            {\n              if (!rec_rset_add_auto_fields (rset, record))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n            }\n\n#if defined REC_CRYPT_SUPPORT\n          /* Encrypt confidential fields if a password was\n             provided.  */\n\n          if (password)\n            {\n              if (!rec_encrypt_record (rset, record, password))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n            }\n#endif\n\n          if (rec_rset_num_records (rset) == 0)\n            {\n              /* The rset is empty => Insert the new record just after\n                 the relative position of the record descriptor.  */\n\n              rec_mset_insert_at (rec_rset_mset (rset),\n                                  MSET_RECORD,\n                                  (void *) record,\n                                  rec_rset_descriptor_pos (rset));\n            }\n          else\n            {\n              /* Insert the new record after the last record in the\n                 set.  */\n\n              rec_mset_t mset = rec_rset_mset (rset);\n              rec_record_t last_record =\n                (rec_record_t) rec_mset_get_at (mset,\n                                                MSET_RECORD,\n                                                rec_rset_num_records (rset) - 1);\n\n              if (!rec_mset_insert_after (mset,\n                                          MSET_RECORD,\n                                          (void *) record,\n                                          rec_mset_search (mset, (void *) last_record)))\n                {\n                  /* Out of memory.  */\n                  return NULL;\n                }\n            }\n        }\n      else\n        {\n          /* Create a new type and insert the record there.  */\n\n          rset = rec_rset_new ();\n          if (!rset)\n            {\n              /* Out of memory.  */\n              return false;\n            }\n\n          rec_rset_set_type (rset, type);\n          rec_record_set_container (record, rset);\n          if (!rec_mset_append (rec_rset_mset (rset),\n                                MSET_RECORD,\n                                (void *) record,\n                                MSET_ANY))\n            {\n              /* Out of memory.  */\n              return false;\n            }\n\n          if (type)\n            {\n              rec_db_insert_rset (db, rset, rec_db_size (db));\n            }\n          else\n            {\n              /* The default rset should always be placed in the\n                 beginning of the db.  */\n\n              rec_db_insert_rset (db, rset, 0);\n            }\n        }\n    }\n\n  return true;\n}",
      "lines": 208,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_delete": {
      "start_point": [
        724,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "bool\nrec_db_delete (rec_db_t     db,\n               const char  *type,\n               size_t      *index,\n               rec_sex_t    sex,\n               const char  *fast_string,\n               size_t       random,\n               int          flags)\n{\n  /* Get the selected record set.  If the user did not specify a type,\n     the default record set does not exist, and the database contains\n     only one record set, then select it.  */\n\n  rec_rset_t rset = rec_db_get_rset_by_type (db, type);\n  if (!type && !rset && (rec_db_size (db) == 1))\n    {\n      rset = rec_db_get_rset (db, 0);\n    }\n\n  /* Don't process empty record sets.  */\n\n  if (rec_rset_num_records (rset) == 0)\n    {\n      return true;\n    }\n\n  /* If the user requested to delete random records then calculate\n     them now for this record set.  */\n\n  if (random > 0)\n    {\n      rec_db_add_random_indexes (&index, random, rec_rset_num_records (rset));\n      if (!index)\n        {\n          /* Out of memory.  */\n          return false;\n        }\n    }\n\n  /* Iterate on the records, deleting or commenting out the selected\n       ones.  */\n\n  {\n    rec_record_t record = NULL;\n    rec_mset_elem_t elem;\n    size_t num_rec = -1;\n    rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n\n    while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, &elem))\n      {\n        num_rec++;\n\n        if (!rec_db_record_selected_p (num_rec,\n                                       record,\n                                       index,\n                                       sex,\n                                       fast_string,\n                                       flags & REC_F_ICASE))\n          {\n            continue;\n          }\n\n        if (flags & REC_F_COMMENT_OUT)\n          {\n            /* Replace the record with a comment in the current\n               element.  */\n\n            rec_comment_t comment = rec_record_to_comment (record);\n            if (!comment)\n              {\n                /* Out of memory.  */\n                return false;\n              }\n\n            rec_record_destroy (record);\n            rec_mset_elem_set_data (elem, (void *) comment);\n            rec_mset_elem_set_type (elem, MSET_COMMENT);\n          }\n        else\n          {\n            /* Remove the physical record from the record set and\n               dispose it.  */\n\n            rec_mset_remove_elem (rec_rset_mset (rset), elem);\n          }\n      }\n    rec_mset_iterator_free (&iter);\n  }\n\n  return true;\n}",
      "lines": 91,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_set": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        959,
        1
      ],
      "content": "bool rec_db_set (rec_db_t    db,\n                 const char *type,\n                 size_t     *index,\n                 rec_sex_t   sex,\n                 const char *fast_string,\n                 size_t      random,\n                 rec_fex_t   fex,\n                 int         action,\n                 const char *action_arg,\n                 int         flags)\n{\n  /* Get the selected record set.  If the user did not specify a type,\n     the default record set does not exist, and the database contains\n     only one record set, then select it.  */\n\n  rec_rset_t rset = rec_db_get_rset_by_type (db, type);\n  if (!type && !rset && (rec_db_size (db) == 1))\n    {\n      rset = rec_db_get_rset (db, 0);\n    }\n\n  /* Don't process empty record sets.  */\n\n  if (rec_rset_num_records (rset) == 0)\n    {\n      return true;\n    }\n\n  /* If the user requested to manipulate random records then calculate\n     them now for this record set.  */\n\n  if (random > 0)\n    {\n      rec_db_add_random_indexes (&index, random, rec_rset_num_records (rset));\n      if (!index)\n        {\n          /* Out of memory.  */\n          return false;\n        }\n    }\n    \n  /* Iterate on the records, operating on the selected ones.  */\n\n  {\n    rec_record_t record = NULL;\n    size_t num_rec = -1;\n    rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n    bool descriptor_renamed = false;\n\n    while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, NULL))\n      {\n        num_rec++;\n\n        if (!rec_db_record_selected_p (num_rec,\n                                       record,\n                                       index,\n                                       sex,\n                                       fast_string,\n                                       flags & REC_F_ICASE))\n          {\n            continue;\n          }\n\n        switch (action)\n          {\n          case REC_SET_ACT_RENAME:\n            {\n              /* If the operation is applied to all records of a given\n                 type (or default) then change the record descriptor\n                 as well.  But make sure to do it just once!  */\n\n              bool rename_descriptor = false;\n              if (!descriptor_renamed\n                  && (sex == NULL) && (index == NULL) && (random == 0) && (fast_string == NULL))\n                {\n                  rename_descriptor = true;\n                  descriptor_renamed = true;\n                }\n\n              if (!rec_db_set_act_rename (rset, record, fex, rename_descriptor, action_arg))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n\n              break;\n            }\n          case REC_SET_ACT_SET:\n            {\n              if (!rec_db_set_act_set (rset, record, fex, false, action_arg))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n              break;\n            }\n          case REC_SET_ACT_ADD:\n            {\n              if (!rec_db_set_act_add (rset, record, fex, action_arg))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n              break;\n            }\n          case REC_SET_ACT_SETADD:\n            {\n              if (!rec_db_set_act_set (rset, record, fex, true, action_arg))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n              break;\n            }\n          case REC_SET_ACT_DELETE:\n            {\n              if (!rec_db_set_act_delete (rset, record, fex, false))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n              break;\n            }\n          case REC_SET_ACT_COMMENT:\n            {\n              if (!rec_db_set_act_delete (rset, record, fex, true))\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n              break;\n            }\n          default:\n            {\n              /* Ignore an invalid action.  */\n              return true;\n            }\n          }\n      }\n    rec_mset_iterator_free (&iter);\n  }\n\n  return true;\n}",
      "lines": 144,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "rec_db_aggregates": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        965,
        1
      ],
      "content": "rec_aggregate_reg_t\nrec_db_aggregates (rec_db_t db)\n{\n  return db->aggregates;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_aggregate_reg_t"
      ]
    },
    "rec_db_merge_records": {
      "start_point": [
        971,
        0
      ],
      "end_point": [
        1035,
        1
      ],
      "content": "static rec_record_t\nrec_db_merge_records (rec_record_t record1,\n                      rec_record_t record2,\n                      const char *prefix)\n{\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n  rec_record_t merge = NULL;\n\n  merge = rec_record_dup (record1);\n  if (!merge)\n    {\n      return NULL;\n    }\n\n  /* Add all the fields from record2 to record1, prepending PREFIX_ to\n     the field name.  It is the responsability of the user to provide\n     a PREFIX whose application results in a unique field.  */\n\n  iter = rec_mset_iterator (rec_record_mset (record2));\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      rec_field_t new_field = rec_field_dup (field);\n      if (!new_field)\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n\n      /* Apply the prefix.  */\n      {\n        const char *field_name = rec_field_name (new_field);\n        char *new_name = malloc (strlen (field_name) + strlen(prefix) + 2);\n        if (!new_name)\n          {\n            /* Out of memory.  */\n            return NULL;\n          }\n\n        memcpy (new_name, prefix, strlen (prefix));\n        new_name[strlen (prefix)] = '_';\n        memcpy (new_name + strlen (prefix) + 1, field_name, strlen (field_name) + 1);\n\n        if (!rec_field_set_name (new_field, new_name))\n          {\n            /* Out of memory.  */\n            return NULL;\n          }\n\n        free (new_name);\n      }\n\n      if (!rec_mset_append (rec_record_mset (merge),\n                            MSET_FIELD,\n                            (void *) new_field,\n                            MSET_ANY))\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n  \n  return merge;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "rec_record_t"
      ]
    },
    "rec_db_join": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1200,
        1
      ],
      "content": "static rec_rset_t\nrec_db_join (rec_db_t db,\n             const char *type1,\n             const char *field,\n             const char *type2)\n{\n  /* Note that this function is inefficient like hell.  */\n\n  /* Perform the join of the specified record sets, using TYPE1.Field\n     = TYPE2.Key as the join criteria.  If some of the specified\n     record sets don't exist as named rset in the specified database\n     then return NULL.  */\n\n  const char *key  = NULL;\n  rec_rset_t join  = NULL;\n  rec_rset_t rset1 = rec_db_get_rset_by_type (db, type1);\n  rec_rset_t rset2 = rec_db_get_rset_by_type (db, type2);\n  \n\n  if (!rset1 || !rset2)\n    {\n      return NULL;\n    }\n\n  /* Determine the key field of the second record set.  */\n  key = rec_rset_key (rset2);\n  if (!key)\n    {\n      return NULL;\n    }\n\n  /* Do the join.  */\n\n  join = rec_rset_new ();\n  if (!join)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n  else\n    {\n      rec_record_t record1 = NULL;\n      rec_mset_iterator_t iter1 = rec_mset_iterator (rec_rset_mset (rset1));\n      while (rec_mset_iterator_next (&iter1, MSET_RECORD, (const void **) &record1, NULL))\n        {\n          /* For each field record1.key in this record we scan the\n             second record set for record1.field == record2.key\n             instances.  */\n\n          size_t num_foreign_keys = rec_record_get_num_fields_by_name (record1, field);\n          size_t num_foreign_key = 0;\n\n          for (num_foreign_key = 0; num_foreign_key < num_foreign_keys; num_foreign_key++)\n            {\n              rec_record_t record2 = NULL;\n              rec_mset_iterator_t iter2 = rec_mset_iterator (rec_rset_mset (rset2));\n\n              while (rec_mset_iterator_next (&iter2, MSET_RECORD, (const void **) &record2, NULL))\n                {\n\n                  /* Continue only if there is a field in record1 such as:\n                     record1.field == record2.key.  */\n                  \n                  bool found = false;\n                  size_t i = 0;\n                  \n                  rec_field_t key_field = rec_record_get_field_by_name (record2, key, num_foreign_key);\n                  if (!key_field)\n                    {\n                      /* A record without a key is an integrity error, but\n                         none of our business, so just skip it.  */\n                      break;\n                    }\n                  \n                  found = false;\n                  for (i = 0; i < rec_record_get_num_fields_by_name (record1, field); i++)\n                    {\n                      if (strcmp (rec_field_value (key_field),\n                                  rec_field_value (rec_record_get_field_by_name (record1, field, i))) == 0)\n                        {\n                          found = true;\n                          break;\n                        }\n                    }\n                  \n                  if (!found)\n                    {\n                      /* Skip this combination record.  */\n                      continue;\n                    }\n                  \n                  /* Merge record1 and record2 into a new record.  */\n                  \n                  rec_record_t record = rec_db_merge_records (record1, record2, field);\n                  if (!record)\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                  \n                  /* Remove all the occurrences of the 'field' from\n                     record1, which were substituted in the merge.  */\n                  \n                  while (rec_record_get_num_fields_by_name (record, field) > 0)\n                    {\n                      rec_record_remove_field_by_name (record, field, 0);\n                    }\n                  \n                  /* Add it into the join result.  */\n                  \n                  rec_record_set_container (record, join);\n                  if (!rec_mset_append (rec_rset_mset (join), MSET_RECORD, (void *) record, MSET_ANY))\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                }\n              rec_mset_iterator_free (&iter2);\n            }\n        }\n      rec_mset_iterator_free (&iter1);\n    }\n\n  /* The descriptor of the new record set will define records of type\n     TYPE_FIELD, where FIELD is the name specified to trigger the\n     operation.  The contents of the descriptor will be just the\n     %rec entry. */\n\n  {\n    rec_record_t new_descriptor = rec_record_new ();\n    if (!new_descriptor)\n      {\n        /* Out of memory.  */\n        return NULL;\n      }\n\n    /* Set the type of the joined record set.  */\n\n    {\n      rec_field_t new_field = NULL;\n      char *new_rset_type = rec_concat_strings (type1, \"_\", field);\n      if (!new_rset_type)\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n\n      new_field = rec_field_new (rec_std_field_name (REC_FIELD_REC),\n                                 new_rset_type);\n      if (!rec_mset_append (rec_record_mset (new_descriptor),\n                            MSET_FIELD,\n                            (void *) new_field,\n                            MSET_ANY))\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n    }\n\n    rec_rset_set_descriptor (join, new_descriptor);\n  }\n\n  return join;\n}",
      "lines": 164,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "rec_rset_t"
      ]
    },
    "rec_db_set_act_rename": {
      "start_point": [
        1202,
        0
      ],
      "end_point": [
        1263,
        1
      ],
      "content": "static bool\nrec_db_set_act_rename (rec_rset_t rset,\n                       rec_record_t record,\n                       rec_fex_t fex,\n                       bool rename_descriptor,\n                       const char *arg)\n{\n  size_t j, min, max, renamed;\n  size_t num_fields;\n  rec_fex_elem_t fex_elem;\n  rec_field_t field;\n  const char *field_name;\n\n  /* Rename the selected fields.  The size of the FEX is guaranteed to\n     be 1 at this point.  */\n \n  fex_elem = rec_fex_get (fex, 0);\n  field_name = rec_fex_elem_field_name (fex_elem);\n  min = rec_fex_elem_min (fex_elem);\n  max = rec_fex_elem_max (fex_elem);\n\n  num_fields =\n    rec_record_get_num_fields_by_name (record, field_name);\n  if (min == -1)\n    {\n      /* Process all the fields with the given name.  */\n      min = 0;\n      max = num_fields - 1;\n    }\n  if (max == -1)\n    {\n      max = min;\n    }\n\n  renamed = 0;\n  for (j = 0; j < num_fields; j++)\n    {\n      if ((j >= min) && (j <= max))\n        {\n          /* Set the name of the Jth field\n             named FIELD_NAME, if it exists.*/\n          field = rec_record_get_field_by_name (record,\n                                                field_name,\n                                                j - renamed);\n          if (field)\n            {\n              rec_field_set_name (field, arg);\n              renamed++;\n            }\n\n          if (rename_descriptor)\n            {\n              \n              rec_rset_rename_field (rset,\n                                     field_name,\n                                     arg);\n            }\n        }\n    }\n\n  return true;\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_set_act_set": {
      "start_point": [
        1266,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static bool\nrec_db_set_act_set (rec_rset_t rset,\n                    rec_record_t record,\n                    rec_fex_t fex,\n                    bool add_p,\n                    const char *arg)\n{\n  size_t i, j, min, max;\n  size_t num_fields;\n  rec_fex_elem_t fex_elem;\n  rec_field_t field;\n  const char *field_name;\n\n  for (i = 0; i < rec_fex_size (fex); i++)\n    {\n      fex_elem = rec_fex_get (fex, i);\n      field_name = rec_fex_elem_field_name (fex_elem);\n      min = rec_fex_elem_min (fex_elem);\n      max = rec_fex_elem_max (fex_elem);\n      \n      num_fields =\n        rec_record_get_num_fields_by_name (record, field_name);\n      if (min == -1)\n        {\n          /* Process all the fields with the given name.  */\n          min = 0;\n          max = num_fields - 1;\n        }\n      if (max == -1)\n        {\n          max = min;\n        }\n      \n      for (j = 0; j < num_fields; j++)\n        {\n          if ((j >= min) && (j <= max))\n            {\n              /* Set the value of the Jth field\n                 named FIELD_NAME, if it exists.*/\n              field = rec_record_get_field_by_name (record,\n                                                    field_name,\n                                                    j);\n              if (field)\n                {\n                  rec_field_set_value (field, arg);\n                }\n            }\n        }\n\n      if (add_p && (num_fields == 0))\n        {\n          /* Add a field with this name and value.  */\n          field = rec_field_new (field_name, arg);\n          if (!rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY))\n            {\n              /* Out of memory.  */\n              return false;\n            }\n        }\n    }\n\n  return true;\n}",
      "lines": 63,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_set_act_add": {
      "start_point": [
        1330,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "static bool\nrec_db_set_act_add (rec_rset_t rset,\n                    rec_record_t record,\n                    rec_fex_t fex,\n                    const char *arg)\n{\n  size_t i;\n\n  /* Create new fields from the FEX and add them to the record.  */\n  for (i = 0; i < rec_fex_size (fex); i++)\n    {\n      rec_fex_elem_t fex_elem = rec_fex_get (fex, i);\n      const char *field_name = rec_fex_elem_field_name (fex_elem);\n      rec_field_t field = rec_field_new (field_name, arg);\n      if (!field)\n        {\n          /* Out of memory.  */\n          return false;\n        }\n\n      if (!rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY))\n        {\n          /* Out of memory.  */\n          return false;\n        }\n    }\n\n  return true;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_set_act_delete": {
      "start_point": [
        1360,
        0
      ],
      "end_point": [
        1456,
        1
      ],
      "content": "static bool\nrec_db_set_act_delete (rec_rset_t rset,\n                       rec_record_t record,\n                       rec_fex_t fex,\n                       bool comment_out)\n{\n  size_t i, j;\n  size_t num_fields;\n  bool *deletion_mask;\n  rec_field_t field;\n  rec_mset_iterator_t iter;\n  rec_mset_elem_t elem;\n\n  /* Initialize the deletion mask.  */\n  deletion_mask = malloc (sizeof (bool) * rec_record_num_fields (record));\n  if (!deletion_mask)\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  for (i = 0; i < rec_record_num_fields (record); i++)\n    {\n      deletion_mask[i] = false;\n    }\n                    \n  /* Mark fields that will be deleted from the record.  */\n  for (i = 0; i < rec_fex_size (fex); i++)\n    {\n      rec_fex_elem_t fex_elem = rec_fex_get (fex, i);\n      const char *field_name = rec_fex_elem_field_name (fex_elem);\n      size_t min = rec_fex_elem_min (fex_elem);\n      size_t max = rec_fex_elem_max (fex_elem);\n\n      num_fields =\n        rec_record_get_num_fields_by_name (record, field_name);\n      if (min == -1)\n        {\n          /* Delete all the fields with the given name.  */\n          min = 0;\n          max = num_fields - 1;\n        }\n      if (max == -1)\n        {\n          max = min;\n        }\n\n      for (j = 0; j < num_fields; j++)\n        {\n          if ((j >= min) && (j <= max))\n            {\n              /* Mark this field for deletion.  */\n              field = rec_record_get_field_by_name (record,\n                                                    rec_fex_elem_field_name (fex_elem),\n                                                    j);\n              deletion_mask[rec_record_get_field_index (record, field)] = true;\n            }\n        }\n    }\n                    \n  /* Delete the marked fields.  */\n  i = 0;\n\n  iter = rec_mset_iterator (rec_record_mset (record));\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, &elem))\n    {\n      if (deletion_mask[i])\n        {\n          if (comment_out)\n            {\n              /* Turn the field into a comment.  */\n\n              rec_comment_t comment = rec_field_to_comment (field);\n              if (!comment)\n                {\n                  /* Out of memory.  */\n                  return false;\n                }\n\n              rec_field_destroy (field);\n              rec_mset_elem_set_data (elem, (void *) comment);\n              rec_mset_elem_set_type (elem, MSET_COMMENT);\n            }\n          else\n            {\n              /* Remove the field from the list and dispose it.  */\n              \n              rec_mset_remove_elem (rec_record_mset (record), elem);\n            }\n        }\n\n      i++;\n    }\n  rec_mset_iterator_free (&iter);\n\n  return true;\n}",
      "lines": 97,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_index_p": {
      "start_point": [
        1458,
        0
      ],
      "end_point": [
        1486,
        1
      ],
      "content": "static bool\nrec_db_index_p (size_t *index,\n                size_t num)\n{\n  while ((index[0] != REC_Q_NOINDEX) || (index[1] != REC_Q_NOINDEX))\n    {\n      bool found = false;\n      size_t min = index[0];\n      size_t max = index[1];\n      \n      if (max == REC_Q_NOINDEX)\n        {\n          found = (num == min);\n        }\n      else\n        {\n          found = ((num >= min) && (num <= max));\n        }\n      \n      if (found)\n        {\n          return true;\n        }\n      \n      index = index + 2;\n    }\n\n  return false;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_add_random_indexes": {
      "start_point": [
        1488,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "static void\nrec_db_add_random_indexes (size_t **index,\n                           size_t num,\n                           size_t limit)\n{\n  /* Create NUM different random numbers in the [0..limit-1] range,\n     without repetition, and store them in a buffer pointed by\n     INDEX.  */\n\n  size_t i;\n  char random_state[128];\n  struct random_data random_data;\n\n  *index = malloc (sizeof(size_t) * ((num + 1) * 2));\n  if (*index == NULL)\n    {\n      /* Out of memory.  */\n      return;\n    }\n  \n  for (i = 0; i < ((num + 1) * 2); i++)\n    {\n      (*index)[i]   = REC_Q_NOINDEX;\n    }\n\n  /* Insert the random indexes.  */\n\n  memset (&random_data, 0, sizeof (random_data));\n  initstate_r (time(NULL), (char *) &random_state, 128, &random_data);\n  for (i = 0; i < (num * 2); i = i + 2)\n    {\n      size_t random_value = 0;\n      \n      random_r (&random_data, (int32_t *) &random_value); /* Can't fail.  */\n      random_value = random_value % limit;\n\n      /* Avoid having repeated random indexes.  */\n      \n      if (rec_db_index_p (*index, random_value))\n        {\n          /* Pick the first available number.  */\n\n          size_t i;\n          for (i = 0; i < limit; i++)\n            {\n              if (!rec_db_index_p (*index, i))\n                {\n                  random_value = i;\n                  break;\n                }\n            }\n        }\n\n      (*index)[i]   = random_value;  /* Min.  */\n      (*index)[i+1] = REC_Q_NOINDEX; /* Max.  */\n    }\n}",
      "lines": 57,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_db_record_selected_p": {
      "start_point": [
        1546,
        0
      ],
      "end_point": [
        1589,
        1
      ],
      "content": "static bool\nrec_db_record_selected_p (size_t num_record,\n                          rec_record_t record,\n                          size_t *index,\n                          rec_sex_t sex,\n                          const char *fast_string,\n                          bool case_insensitive_p)\n{\n  /* Note that the logic in this function assumes that SEX and\n     FAST_STRING are mutually exclusive.  If they are not then\n     FAST_STRING takes precedence.  */\n\n  /* The record is searched for instances of the \"fast string\", which\n     can appear as a substring.  */\n\n  if (fast_string)\n    {\n      return rec_record_contains_value (record,\n                                        fast_string,\n                                        case_insensitive_p);\n    }\n\n  /* The selected expression is evaluated in the record.  If there is\n     an error evaluating the expression, or if the expression does not\n     evaluate to 'true', then 'false' is returned.  */\n\n  if (sex)\n    {\n      bool eval_status;\n      return rec_sex_eval (sex, record, &eval_status);\n    }\n\n  /* The memory pointed by INDEX contains pairs of indexes Min,Max.\n     The final pair is always REC_Q_NOINDEX,REC_Q_NOINDEX.  Select the\n     current record only if its position is into some of the defined\n     intervals.  */\n  \n  if (index)\n    {\n      return rec_db_index_p (index, num_record);\n    }\n\n  return true;\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_process_fex": {
      "start_point": [
        1591,
        0
      ],
      "end_point": [
        1772,
        1
      ],
      "content": "static rec_record_t\nrec_db_process_fex (rec_db_t db,\n                    rec_rset_t rset,\n                    rec_record_t record,\n                    rec_fex_t fex)\n{\n  rec_record_t res = NULL;\n  size_t fex_size, i, j = 0;\n\n  /* If fex is NULL then just return a copy of RECORD.  Otherwise\n     create an empty result record.  */\n  \n  if (!fex)\n    {\n      return rec_record_dup (record);\n    }\n\n  res = rec_record_new ();\n  if (!res)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n\n  /* Iterate on the elements of the FEX, picking and transforming the\n     fields of RECORD that must be copied and inserted into RES.  If a\n     function call is found in the fex then invoke the corresponding\n     function and add the fields returned by that function into the\n     record.  */\n\n  fex_size = rec_fex_size (fex);\n  for (i = 0; i < fex_size; i++)\n    {\n      rec_fex_elem_t elem = rec_fex_get (fex, i);\n      const char *field_name = rec_fex_elem_field_name (elem);\n      const char *alias = rec_fex_elem_rewrite_to (elem);\n      const char *function_name = rec_fex_elem_function_name (elem);\n      size_t min = rec_fex_elem_min (elem);\n      size_t max = rec_fex_elem_max (elem);\n\n      if (function_name)\n        {\n          /* Get a handler for the aggregate function and invoke it on\n             the rset or record, passing the field_name argument and\n             the indexes.  The value returned by the funciton is then\n             appended into the current record in a new field, named\n             after the name of the aggregate and the name of the\n             argument field.  Non-existing aggregates are simply\n             ignored.  */\n\n          rec_aggregate_t func = rec_aggregate_reg_get (rec_db_aggregates (db), function_name);\n          if (func)\n            {\n              char *func_res = (func) (rset, record, field_name);\n              if (func_res)\n                {\n                  /* Add a new field with the result of the aggregate\n                     as its value.  */\n\n                  rec_field_t agg_field = NULL;\n                  char *agg_field_name = NULL;\n                  char *agg_field_value = func_res;\n\n                  /* The name of the new field is a composition of the\n                     name of the invoked function and the name of the\n                     field to which the function is applied.  Unless\n                     an alias is used, of course.  */\n\n                  if (alias)\n                    {\n                      agg_field_name = strdup (alias);\n                      if (!agg_field_name)\n                        {\n                          /* Out of memory.  */\n                          return NULL;\n                        }\n                    }\n                  else\n                    {\n                      agg_field_name = malloc (strlen(function_name) + 1 /* _ */ + strlen (field_name) + 1);\n                      if (!agg_field_name)\n                        {\n                          /* Out of memory.  */\n                          return NULL;\n                        }\n                      \n                      memcpy (agg_field_name, function_name, strlen (function_name) + 1);\n                      strcat (agg_field_name, \"_\");\n                      strcat (agg_field_name, field_name);\n                    }\n\n                  agg_field = rec_field_new (agg_field_name, agg_field_value);\n                  if (!agg_field)\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                  \n                  if (!rec_mset_append (rec_record_mset (res),\n                                        MSET_FIELD,\n                                        (void *) agg_field,\n                                        MSET_FIELD))\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n\n                  free (agg_field_name);\n                  free (func_res);\n                }\n            }\n        }\n      else\n        {\n          if ((min == -1) && (max == -1))\n            {\n              /* Add all the fields with that name.  */\n              min = 0;\n              max = rec_record_get_num_fields_by_name (record, field_name);\n            }\n          else if (max == -1)\n            {\n              /* Add just one field: Field[min].  */\n              max = min + 1;\n            }\n          else\n            {\n              /* Add the interval min..max, max inclusive.  */\n              max++;\n            }\n\n          /* Add the selected fields to the result record.  */\n\n          for (j = min; j < max; j++)\n            {\n              rec_field_t res_field = NULL;\n              rec_field_t field =\n                rec_record_get_field_by_name (record, field_name, j);\n\n              if (!field)\n                {\n                  continue;\n                }\n\n              /* Duplicate the field and append it into 'res'.  If there\n                 is a rewrite rule defined in this fex entry then use it\n                 instead of the original name of the field.  */\n\n              res_field = rec_field_dup (field);\n              if (alias)\n                {\n                  if (!rec_field_set_name (res_field, alias))\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                }\n\n              if (!rec_mset_append (rec_record_mset (res),\n                                    MSET_FIELD,\n                                    (void *) res_field,\n                                    MSET_FIELD))\n                {\n                  /* Out of memory.  */\n                  return NULL;\n                }\n            }\n        }\n    }\n\n  /* At this point RES is a record containing all the selected fields\n     of the original record, but we must also copy the location\n     information.  */\n\n  if (record)\n    {\n      rec_record_set_location (res, rec_record_location (record));\n      rec_record_set_char_location (res, rec_record_char_location (record));\n    }\n\n  return res;\n}",
      "lines": 182,
      "depth": 22,
      "decorators": [
        "static",
        "static",
        "rec_record_t"
      ]
    },
    "rec_db_rset_equals_fn": {
      "start_point": [
        1774,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "static bool\nrec_db_rset_equals_fn (const void *elt1,\n                       const void *elt2)\n{\n  return false;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_db_rset_dispose_fn": {
      "start_point": [
        1781,
        0
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "static void\nrec_db_rset_dispose_fn (const void *elt)\n{\n  rec_rset_t rset;\n\n  rset = (rec_rset_t) elt;\n  rec_rset_destroy (rset);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-fex.c": {
    "rec_fex_new": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "rec_fex_t\nrec_fex_new (const char *str,\n             enum rec_fex_kind_e kind)\n{\n  rec_fex_t new;\n  int i;\n\n  new = malloc (sizeof (struct rec_fex_s));\n  if (new)\n    {\n      rec_fex_init (new);\n\n      new->num_elems = 0;\n      new->str = NULL;\n      for (i = 0; i < REC_FEX_MAX_ELEMS; i++)\n        {\n          new->elems[i] = 0;\n        }\n\n      if (str != NULL)\n        {\n          /* Parse the string, using the proper parsing routine\n             depending on the kind of field expression requested by\n             the user.  */\n\n          if (kind == REC_FEX_SUBSCRIPTS)\n            {\n              if (!rec_fex_parse_str_subscripts (new, str))\n                {\n                  /* Out of memory or parse error.  */\n                  free (new);\n                  return NULL;\n                }\n            }\n          else if (kind == REC_FEX_SIMPLE)\n            {\n              if (!rec_fex_parse_str_simple (new, str, \" \\t\\n\"))\n                {\n                  /* Out of memory or parse error.  */\n                  free (new);\n                  return NULL;\n                }\n            }\n          else /* REC_FEX_CSV */\n            {\n              if (!rec_fex_parse_str_simple (new, str, \",\"))\n                {\n                  /* Out of memory or parse error.  */\n                  free (new);\n                  return NULL;\n                }\n            }\n        }\n    }\n  \n  return new;\n}",
      "lines": 57,
      "depth": 16,
      "decorators": [
        "rec_fex_t"
      ]
    },
    "rec_fex_destroy": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\nrec_fex_destroy (rec_fex_t fex)\n{\n  int i;\n  \n  if (fex)\n    {\n      for (i = 0; i < fex->num_elems; i++)\n        {\n          free (fex->elems[i]->rewrite_to);\n          free (fex->elems[i]->field_name);\n          free (fex->elems[i]->str);\n          free (fex->elems[i]);\n        }\n      \n      free (fex->str);\n      free (fex);\n    }\n}",
      "lines": 19,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_fex_dup": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "rec_fex_t\nrec_fex_dup (rec_fex_t fex)\n{\n  rec_fex_t copy = NULL;\n  size_t i = 0;\n\n  copy = malloc (sizeof (struct rec_fex_s));\n  if (copy)\n    {\n      rec_fex_init (copy);\n  \n      copy->num_elems = fex->num_elems;\n      copy->str = strdup (fex->str);\n      if (!copy->str)\n        {\n          /* Out of memory.  */\n          rec_fex_destroy (copy);\n          return NULL;\n        }\n\n      for (i = 0; i < fex->num_elems; i++)\n        {\n          if (fex->elems[i] == NULL)\n            {\n              copy->elems[i] = NULL;\n              continue;\n            }\n\n          copy->elems[i] = malloc (sizeof (struct rec_fex_elem_s));\n          if (!copy->elems[i])\n            {\n              /* Out of memory.  */\n              rec_fex_destroy (copy);\n              return NULL;\n            }\n\n          copy->elems[i]->max = fex->elems[i]->max;\n          copy->elems[i]->min = fex->elems[i]->min;\n\n#define REC_COPY_STR_MAYBE_RETURN(FNAME)                                \\\n          do                                                            \\\n            {                                                           \\\n               if (!fex->elems[i]->FNAME)                               \\\n                 {                                                      \\\n                   copy->elems[i]->FNAME = NULL;                        \\\n                 }                                                      \\\n               else                                                     \\\n                 {                                                      \\\n                   copy->elems[i]->FNAME = strdup (fex->elems[i]->FNAME); \\\n                   if (!copy->elems[i]->FNAME)                          \\\n                     {                                                  \\\n                       /* Out of memory.  */                            \\\n                       rec_fex_destroy (copy);                          \\\n                       return NULL;                                     \\\n                     }                                                  \\\n                 }                                                      \\\n            } while (0)\n\n          REC_COPY_STR_MAYBE_RETURN (str);\n          REC_COPY_STR_MAYBE_RETURN (field_name);\n          REC_COPY_STR_MAYBE_RETURN (rewrite_to);\n          REC_COPY_STR_MAYBE_RETURN (function_name);\n        }\n    }\n\n  return copy;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "rec_fex_t"
      ]
    },
    "rec_fex_check": {
      "start_point": [
        221,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "bool\nrec_fex_check (const char *str, enum rec_fex_kind_e kind)\n{\n  char *regexp_str;\n\n  switch (kind)\n    {\n    case REC_FEX_SIMPLE:\n      {\n        regexp_str = \"^\" REC_FNAME_LIST_RE \"$\";\n        break;\n      }\n    case REC_FEX_CSV:\n      {\n        regexp_str = \"^\" REC_FNAME_LIST_CS_RE \"$\";\n        break;\n      }\n    case REC_FEX_SUBSCRIPTS:\n      {\n        regexp_str = \"^\" REC_FNAME_LIST_SUB_RE \"$\";\n        break;\n      }\n    default:\n      {\n        regexp_str = NULL;\n        break;\n      }\n    }\n\n  return rec_match (str, regexp_str);\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_fex_size": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "size_t\nrec_fex_size (rec_fex_t fex)\n{\n  return fex->num_elems;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_fex_get": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "rec_fex_elem_t\nrec_fex_get (rec_fex_t fex,\n             size_t position)\n{\n  if ((position < 0) || (position >= fex->num_elems))\n    {\n      return NULL;\n    }\n\n  return fex->elems[position];\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "rec_fex_elem_t"
      ]
    },
    "rec_fex_elem_field_name": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "const char *\nrec_fex_elem_field_name (rec_fex_elem_t elem)\n{\n  return elem->field_name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_fex_elem_field_name (rec_fex_elem_t elem)",
        "*"
      ]
    },
    "rec_fex_elem_set_field_name": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "bool\nrec_fex_elem_set_field_name (rec_fex_elem_t elem,\n                             const char *fname)\n{\n  free (elem->field_name);\n  elem->field_name = strdup (fname);\n  return (elem->field_name != NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_fex_elem_min": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "int\nrec_fex_elem_min (rec_fex_elem_t elem)\n{\n  return elem->min;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_fex_elem_max": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "int\nrec_fex_elem_max (rec_fex_elem_t elem)\n{\n  return elem->max;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_fex_elem_rewrite_to": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        302,
        1
      ],
      "content": "const char *\nrec_fex_elem_rewrite_to (rec_fex_elem_t elem)\n{\n  return elem->rewrite_to;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_fex_elem_rewrite_to (rec_fex_elem_t elem)",
        "*"
      ]
    },
    "rec_fex_sort": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "void\nrec_fex_sort (rec_fex_t fex)\n{\n  bool done;\n  rec_fex_elem_t aux;\n  int i, j;\n\n  /* XXX: this code only works when 'max' is not specified.  */\n\n  for (i = 1; i < fex->num_elems; i++)\n    {\n      aux = fex->elems[i];\n      j = i - 1;\n      done = false;\n\n      while (!done)\n       {\n         /* If elems[j] > aux  */\n         if ((fex->elems[j]->min == -1) || (fex->elems[j]->min > aux->min))\n           {\n             fex->elems[j + 1] = fex->elems[j];\n             j = j - 1;\n             if (j < 0)\n               {\n                 done = true;\n               }\n           }\n         else\n           {\n             done = true;\n           }\n       }\n\n      fex->elems[j + 1] = aux;\n    }\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "rec_fex_str": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "char *\nrec_fex_str (rec_fex_t fex,\n             enum rec_fex_kind_e kind)\n{\n  char *result;\n  size_t result_size;\n  rec_buf_t buf;\n  size_t i;\n  char *tmp;\n\n  result = NULL;\n  buf = rec_buf_new (&result, &result_size);\n  if (buf)\n    {\n      char *field_str = NULL;\n\n      for (i = 0; i < fex->num_elems; i++)\n        {\n          if (i != 0)\n            {\n              if (kind == REC_FEX_SIMPLE)\n                {\n                  rec_buf_putc (' ', buf);\n                }\n              else\n                {\n                  rec_buf_putc (',', buf);\n                }\n            }\n          \n          field_str = strdup (fex->elems[i]->field_name);\n          if (!field_str)\n            {\n              rec_buf_close (buf);\n              free (result);\n              return NULL;\n            }\n\n          rec_buf_puts (field_str, buf);\n          free (field_str);\n\n          if (kind == REC_FEX_SUBSCRIPTS)\n            {\n              if ((fex->elems[i]->min != -1)\n                  || (fex->elems[i]->max != -1))\n                {\n                  rec_buf_putc ('[', buf);\n                  if (fex->elems[i]->min != -1)\n                    {\n                      if (asprintf (&tmp, \"%d\", fex->elems[i]->min) != -1)\n                        {\n                          rec_buf_puts (tmp, buf);\n                          free (tmp);\n                        }\n                    }\n                  if (fex->elems[i]->max != -1)\n                    {\n                      if (asprintf (&tmp, \"-%d\", fex->elems[i]->max) != -1)\n                        {\n                          rec_buf_puts (tmp, buf);\n                          free (tmp);\n                        }\n                    }\n\n                  rec_buf_putc (']', buf);\n                }\n            }\n        }\n    }\n\n  rec_buf_close (buf);\n\n  return result;\n}",
      "lines": 74,
      "depth": 21,
      "decorators": [
        "char",
        "*\nrec_fex_str (rec_fex_t fex,\n             enum rec_fex_kind_e kind)",
        "*"
      ]
    },
    "rec_fex_member_p": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "bool\nrec_fex_member_p (rec_fex_t fex,\n                  const char *fname,\n                  int min,\n                  int max)\n{\n  bool res = false;\n  int i;\n  \n  for (i = 0; i < fex->num_elems; i++)\n    {\n      if (rec_field_name_equal_p (fname,\n                                  fex->elems[i]->field_name)\n          && ((min == -1) || (fex->elems[i]->min == min))\n          && ((max == -1) || (fex->elems[i]->max == max)))\n        {\n          res = true;\n          break;\n        }\n    }\n\n  return res;\n}",
      "lines": 23,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "rec_fex_append": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "rec_fex_elem_t\nrec_fex_append (rec_fex_t fex,\n                const char *fname,\n                int min,\n                int max)\n{\n  rec_fex_elem_t new_elem;\n\n  if (fex->num_elems >= REC_FEX_MAX_ELEMS)\n    {\n      fprintf (stderr, _(\"internal error: REC_FEX_MAX_ELEMS exceeded.  Please report this.\\n\"));\n      return NULL;\n    }\n\n  new_elem = malloc (sizeof (struct rec_fex_elem_s));\n  if (new_elem)\n    {\n      memset (new_elem, 0, sizeof (*new_elem));\n      new_elem->field_name = strdup (fname);\n      if (!new_elem->field_name)\n        {\n          /* Out of memory.  */\n          free (new_elem);\n          return NULL;\n        }\n\n      new_elem->str = strdup (fname);\n      if (!new_elem->str)\n        {\n          /* Out of memory.  */\n          free (new_elem->field_name);\n          free (new_elem);\n          return NULL;\n        }\n\n      new_elem->min = min;\n      new_elem->max = max;\n      fex->elems[fex->num_elems++] = new_elem;\n    }\n\n  return new_elem;\n}",
      "lines": 42,
      "depth": 11,
      "decorators": [
        "rec_fex_elem_t"
      ]
    },
    "rec_fex_elem_function_name": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        487,
        1
      ],
      "content": "const char *\nrec_fex_elem_function_name (rec_fex_elem_t elem)\n{\n  return elem->function_name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_fex_elem_function_name (rec_fex_elem_t elem)",
        "*"
      ]
    },
    "rec_fex_elem_function_data": {
      "start_point": [
        489,
        0
      ],
      "end_point": [
        493,
        1
      ],
      "content": "void **\nrec_fex_elem_function_data (rec_fex_elem_t elem)\n{\n  return elem->function_data;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "**\nrec_fex_elem_function_data (rec_fex_elem_t elem)",
        "*",
        "*\nrec_fex_elem_function_data (rec_fex_elem_t elem)",
        "*"
      ]
    },
    "rec_fex_all_calls_p": {
      "start_point": [
        495,
        0
      ],
      "end_point": [
        511,
        1
      ],
      "content": "bool\nrec_fex_all_calls_p (rec_fex_t fex)\n{\n  bool result = true;\n  size_t i = 0;\n\n  for (i = 0; i < fex->num_elems; i++)\n    {\n      if (fex->elems[i]->function_name == NULL)\n        {\n          result = false;\n          break;\n        }\n    }\n\n  return result;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_fex_init": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "static void\nrec_fex_init (rec_fex_t fex)\n{\n  /* Initialize the field expression structure so it can be safely\n     passed to rec_fex_destroy even if its contents are not completely\n     initialized with real values.  */\n\n  memset (fex, 0 /* NULL */, sizeof (struct rec_fex_s));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_fex_parse_str_simple": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "static bool\nrec_fex_parse_str_simple (rec_fex_t new,\n                          const char *str,\n                          const char *sep)\n{\n  bool res;\n  rec_fex_elem_t elem;\n  char *fex_str, *fex_str_orig;\n  char *elem_str;\n  size_t i;\n\n  if (!str)\n    {\n      return false;\n    }\n\n  fex_str = strdup (str);\n  if (!fex_str)\n    {\n      return false;\n    }\n  fex_str_orig = fex_str;\n\n  res = true;\n\n  elem_str = strsep (&fex_str, sep);\n  do\n    {\n      if (strlen (elem_str) > 0)\n        {\n          if ((elem = malloc (sizeof (struct rec_fex_elem_s))))\n            {\n              const char *p = elem_str;\n\n              /* Get the field name.  */\n\n              if (!rec_parse_regexp (&p,\n                                     \"^\" REC_FNAME_RE,\n                                     &(elem->field_name)))\n                {\n                  /* Parse error. */\n                  free (elem);\n                  res = false;\n                  break;\n                }\n\n              /* Get the subname, if any, and modify the name\n                 accordingly.  */\n\n              if (*p == '.')\n                {\n                  char *subname = NULL;\n\n                  p++;\n                  if (!rec_parse_regexp (&p,\n                                         \"^\" REC_FNAME_RE,\n                                         &subname))\n                    {\n                      /* Parse error.  */\n                      free (elem->field_name);\n                      free (elem);\n                      res = false;\n                      break;\n                    }\n\n                  /* Concatenate the field name and the subname.  */\n                  elem->field_name = rec_concat_strings (elem->field_name, \"_\", subname);\n                }\n\n              /* Check that there are no extra stuff at the end of the\n                 string.  */\n\n              if (*p != '\\0')\n                {\n                  free (elem->field_name);\n                  free (elem);\n                  res = false;\n                  break;\n                }\n\n              /* Initialize other attributes of the fex entry.  */\n\n              elem->function_name = NULL;\n              elem->function_data = NULL;\n              elem->rewrite_to = NULL;\n              elem->str = strdup (elem_str);\n              elem->min = -1;\n              elem->max = -1;\n              new->elems[new->num_elems++] = elem;\n            }\n          else\n            {\n              res = false;\n              break;\n            }\n        }\n    }\n  while ((elem_str = strsep (&fex_str, sep)));\n\n  if (new->num_elems == 0)\n    {\n      /* No elements were recognized.  */\n      res = false;\n    }\n\n  if (res)\n    {\n      new->str = strdup (str);\n    }\n  else\n    {\n      /* Destroy parsed elements.  */\n      for (i = 0; i < new->num_elems; i++)\n        {\n          free (new->elems[i]->rewrite_to);\n          free (new->elems[i]->field_name);\n          free (new->elems[i]->str);\n          free (new->elems[i]);\n        }\n    }\n\n  free (fex_str_orig);\n  return res;\n}",
      "lines": 124,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_fex_parse_str_subscripts": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "static bool\nrec_fex_parse_str_subscripts (rec_fex_t new,\n                              const char *str)\n{\n  bool res;\n  char *elem_str;\n  char *fex_str, *fex_str_orig;\n  rec_fex_elem_t elem;\n  int i;\n\n  res = true;\n\n  fex_str = strdup (str);\n  if (!fex_str)\n    {\n      return false;\n    }\n  fex_str_orig = fex_str;\n\n  elem_str = strsep (&fex_str, \",\");\n  do\n    {\n      elem = malloc (sizeof (struct rec_fex_elem_s));\n      if (!elem)\n        {\n          /* Out of memory.  */\n          res = false;\n          break;\n        }\n\n      if (!rec_fex_parse_elem (elem, elem_str))\n        {\n          /* Parse error.  */\n          for (i = 0; i < new->num_elems; i++)\n            {\n              free (new->elems[i]->field_name);\n              free (new->elems[i]->str);\n              free (new->elems[i]);\n            }\n\n          free (elem);\n          res = false;\n          break;\n        }\n\n      /* Add the elem to the FEX.  */\n      new->elems[new->num_elems++] = elem;\n    }\n  while ((elem_str = strsep (&fex_str, \",\")));\n\n  if (res)\n    {\n      new->str = strdup (str);\n    }\n\n  free (fex_str_orig);\n  return res;\n}",
      "lines": 58,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_fex_parse_elem": {
      "start_point": [
        711,
        0
      ],
      "end_point": [
        851,
        1
      ],
      "content": "static bool\nrec_fex_parse_elem (rec_fex_elem_t elem,\n                    const char *str)\n{\n  bool ret;\n  const char *p;\n\n  ret = true;\n  p = str;\n\n  /* 'Empty' part.  */\n  elem->field_name = NULL;\n  elem->function_name = NULL;\n  elem->function_data = NULL;\n  elem->str = NULL;\n  elem->rewrite_to = NULL;\n  elem->min = -1;\n  elem->max = -1;\n\n  /* The 'str' field keeps a copy of the textual entry.  */\n\n  elem->str = strdup (str);\n\n  /* Each FEX element can be either a function call or a field name\n     with an optional subscript.  */\n\n  if (rec_match (p, \"^\" REC_FEX_CALL))\n    {\n      /* Get the function name and the field argument and store them\n         in the FEX element.  */\n\n      if (!rec_parse_regexp (&p,\n                             \"^\" REC_FEX_FUNCTION_NAME,\n                             &(elem->function_name)))\n        {\n          /* Parse error.  */\n          free (elem->str);\n          return false;\n        }\n\n      p++; /* Skip the ( */\n    }\n\n  /* Get the field name.  */\n      \n  if (!rec_parse_regexp (&p,\n                         \"^\" REC_FNAME_RE,\n                         &(elem->field_name)))\n    {\n      /* Parse error.  */\n      free (elem->str);\n      return false;\n    }\n  \n  /* Get the subname and modify the name accordingly, if it\n     exists.  */\n  \n  if (*p == '.')\n    {\n      char *subname = NULL;\n      \n      p++;\n      if (!rec_parse_regexp (&p,\n                             \"^\" REC_FNAME_RE,\n                             &subname))\n        {\n          /* Parse error.  */\n          free (elem->str);\n          return false;\n        }\n      \n      /* Concatenate the field_name and the subname.  */\n      elem->field_name = rec_concat_strings (elem->field_name, \"_\", subname);\n    }\n  \n  /* Get the subscripts if they are present.  */\n  if (*p == '[')\n    {\n      p++;\n      /* First subscript in range.  */\n      if (!rec_parse_int (&p, &(elem->min)))\n        {\n          /* Parse error.  */\n          free (elem->str);\n          free (elem->field_name);\n          return false;\n        }\n      \n      if (*p == '-')\n        {\n          p++;\n          /* Second subscript in range.  */\n          if (!rec_parse_int (&p, &(elem->max)))\n            {\n              /* Parse error.  */\n              free (elem->str);\n              free (elem->field_name);\n              return false;\n            }\n        }\n      \n      if (*p != ']')\n        {\n          /* Parse error.  */\n          free (elem->str);\n          free (elem->field_name);\n          return false;\n        }\n      p++; /* Skip the ]  */\n    }\n\n  if (elem->function_name)\n    {\n      p++; /* Skip the ) */\n    }\n      \n  /* Get the rewrite rule if it is present.  */\n  if (*p == ':')\n    {\n      p++;\n      if (!rec_parse_regexp (&p,\n                             \"^\" REC_FNAME_RE,\n                             &(elem->rewrite_to)))\n        {\n          /* Parse error.  */\n          free (elem->str);\n          free (elem->field_name);\n          return false;\n        }\n    }\n\n  if (*p != '\\0')\n    {\n      free (elem->str);\n      free (elem->field_name);\n      free (elem->rewrite_to);\n      return false;\n    }\n\n  return ret;\n}",
      "lines": 141,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-field-name.c": {
    "rec_std_field_name": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "const char *\nrec_std_field_name (enum rec_std_field_e std_field)\n{\n  return *(fnames + std_field);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_std_field_name (enum rec_std_field_e std_field)",
        "*"
      ]
    },
    "rec_field_name_p": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "bool\nrec_field_name_p (const char *str)\n{\n  return rec_match (str, \"^\" REC_FNAME_RE \"$\");\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_name_normalise": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "char *\nrec_field_name_normalise (const char *str)\n{\n  char *normalised_name;\n  int i;\n\n  normalised_name = malloc (strlen (str) + 1);\n  if (normalised_name)\n    {\n      memcpy (normalised_name, str, strlen (str));\n      normalised_name[strlen(str)] = '\\0';\n      \n      for (i = 0; i < strlen (normalised_name); i++)\n        {\n          if (!((isalnum (normalised_name[i]))\n                || (normalised_name[i] == '_')\n                || (normalised_name[i] == '-')\n                || (normalised_name[i] == '%')))\n            {\n              normalised_name[i] = '_';\n            }\n        }\n    }\n\n  /* Check that the normalisation produced a proper field name.  */\n\n  if (normalised_name)\n    {\n      if (!rec_field_name_p (normalised_name))\n        {\n          free (normalised_name);\n          normalised_name = NULL;\n        }\n    }\n\n  return normalised_name;\n}",
      "lines": 37,
      "depth": 18,
      "decorators": [
        "char",
        "*\nrec_field_name_normalise (const char *str)",
        "*"
      ]
    },
    "rec_field_name_equal_p": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "bool\nrec_field_name_equal_p (const char *name1,\n                        const char *name2)\n{\n  /* TODO: 'foo' and 'foo:' denote the same field name.  */\n  return (strcmp (name1, name2) == 0);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-field.c": {
    "rec_field_name": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "const char *\nrec_field_name (rec_field_t field)\n{\n  return field->name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_field_name (rec_field_t field)",
        "*"
      ]
    },
    "rec_field_set_name": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "bool\nrec_field_set_name (rec_field_t field, const char *name)\n{\n  free (field->name);\n  field->name = strdup (name);\n  return (field->name != NULL);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_value": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "const char *\nrec_field_value (rec_field_t field)\n{\n  return field->value;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_field_value (rec_field_t field)",
        "*"
      ]
    },
    "rec_field_set_value": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "bool\nrec_field_set_value (rec_field_t field,\n                     const char *value)\n{\n  free (field->value);\n  field->value = strdup (value);\n  return (field->value != NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_new": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "rec_field_t\nrec_field_new (const char *name,\n               const char *value)\n{\n  rec_field_t field;\n\n  field = malloc (sizeof (struct rec_field_s));\n\n  if (field != NULL)\n    {\n      rec_field_init (field);\n\n      if (!rec_field_set_name (field, name))\n        {\n          /* Out of memory.  */\n          rec_field_destroy (field);\n          return NULL;\n        }\n\n      if (!rec_field_set_value (field, value))\n        {\n          /* Out of memory.  */\n          rec_field_destroy (field);\n          return NULL;\n        }\n    }\n  \n  return field;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "rec_field_t"
      ]
    },
    "rec_field_dup": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "rec_field_t\nrec_field_dup (rec_field_t field)\n{\n  rec_field_t new_field;\n\n  new_field = rec_field_new (rec_field_name (field),\n                             rec_field_value (field));\n  if (new_field)\n    {\n      new_field->location = field->location;\n      new_field->char_location = field->char_location;\n      new_field->mark = field->mark;\n\n      if (field->source)\n        {\n          new_field->source = strdup (field->source);\n          if (!new_field->source)\n            {\n              /* Out of memory.  */\n              rec_field_destroy (new_field);\n              return NULL;\n            }\n        }\n\n      if (field->location_str)\n        {\n          new_field->location_str = strdup (field->location_str);\n          if (!new_field->location_str)\n            {\n              /* Out of memory.  */\n              rec_field_destroy (new_field);\n              return NULL;\n            }\n        }\n\n      if (field->char_location_str)\n        {\n          new_field->char_location_str = strdup (field->char_location_str);\n          if (!new_field->char_location_str)\n            {\n              /* Out of memory.  */\n              rec_field_destroy (new_field);\n              return NULL;\n            }\n        }\n    }\n\n  return new_field;\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "rec_field_t"
      ]
    },
    "rec_field_equal_p": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "bool\nrec_field_equal_p (rec_field_t field1,\n                   rec_field_t field2)\n{\n  return (strcmp (field1->name, field2->name) == 0);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_destroy": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nrec_field_destroy (rec_field_t field)\n{\n  if (field)\n    {\n      free (field->name);\n      free (field->value);\n      free (field->source);\n      free (field->location_str);\n      free (field->char_location_str);\n      free (field);\n    }\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_field_to_comment": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "rec_comment_t\nrec_field_to_comment (rec_field_t field)\n{\n  rec_comment_t res;\n  char *comment_str;\n  \n  comment_str = rec_write_field_str (field,\n                                     REC_WRITER_NORMAL);\n  if (!comment_str)\n    {\n      return NULL;\n    }\n\n  /* If the last character of the comment string is a newline, remove\n     it.  */\n\n  if (comment_str[strlen (comment_str) - 1] == '\\n')\n    {\n      comment_str[strlen (comment_str) - 1] = '\\0';\n    }\n\n  res = rec_comment_new (comment_str);\n  free (comment_str);\n  \n  return res;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "rec_comment_t"
      ]
    },
    "rec_field_source": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "const char *\nrec_field_source (rec_field_t field)\n{\n  return field->source;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_field_source (rec_field_t field)",
        "*"
      ]
    },
    "rec_field_set_source": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "bool\nrec_field_set_source (rec_field_t field,\n                      const char *source)\n{\n  free (field->source);\n  field->source = strdup (source);\n  return (field->source != NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_location": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "size_t\nrec_field_location (rec_field_t field)\n{\n  return field->location;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_field_set_location": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        253,
        1
      ],
      "content": "bool\nrec_field_set_location (rec_field_t field,\n                        size_t location)\n{\n  field->location = location;\n  free (field->location_str);\n  return (asprintf (&(field->location_str), \"%zu\", field->location)\n          != -1);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_location_str": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "const char *\nrec_field_location_str (rec_field_t field)\n{\n  char *res;\n\n  if (field->location_str)\n    {\n      res = field->location_str;\n    }\n  else\n    {\n      res = \"\";\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_field_location_str (rec_field_t field)",
        "*"
      ]
    },
    "rec_field_char_location": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        276,
        1
      ],
      "content": "size_t\nrec_field_char_location (rec_field_t field)\n{\n  return field->char_location;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_field_set_char_location": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "bool\nrec_field_set_char_location (rec_field_t field,\n                             size_t location)\n{\n  field->char_location = location;\n  free (field->char_location_str);\n  return (asprintf (&(field->char_location_str), \"%zu\", field->char_location)\n          != -1);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_field_char_location_str": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "const char *\nrec_field_char_location_str (rec_field_t field)\n{\n  char *res;\n\n  if (field->char_location_str)\n    {\n      res = field->char_location_str;\n    }\n  else\n    {\n      res = \"\";\n    }\n  \n  return res;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_field_char_location_str (rec_field_t field)",
        "*"
      ]
    },
    "rec_field_set_mark": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void\nrec_field_set_mark (rec_field_t field, int mark)\n{\n  field->mark = mark;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_field_mark": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "int\nrec_field_mark (rec_field_t field)\n{\n  return field->mark;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_field_init": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static void\nrec_field_init (rec_field_t field)\n{\n  /* Initialize the field structure so it can be safely passed to\n     rec_field_destroy even if its contents are not completely\n     initialized with real values.  */\n\n  memset (field, 0 /* NULL */, sizeof (struct rec_field_s));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-int.c": {
    "rec_int_check_db": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\nrec_int_check_db (rec_db_t db,\n                  bool check_descriptors_p,\n                  bool remote_descriptors_p,\n                  rec_buf_t errors)\n{\n  int ret;\n  size_t db_size;\n  size_t n_rset;\n  rec_rset_t rset;\n  \n  ret = 0;\n\n  db_size = rec_db_size (db);\n  for (n_rset = 0; n_rset < db_size; n_rset++)\n    {\n      rset = rec_db_get_rset (db, n_rset);\n      ret = ret + rec_int_check_rset (db,\n                                      rset,\n                                      check_descriptors_p,\n                                      remote_descriptors_p,\n                                      errors);\n    }\n\n  return ret;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rec_int_check_rset": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nrec_int_check_rset (rec_db_t db,\n                    rec_rset_t rset,\n                    bool check_descriptor_p,\n                    bool remote_descriptor_p,\n                    rec_buf_t errors)\n{\n  int res;\n  rec_mset_iterator_t iter;\n  rec_record_t record;\n  rec_record_t descriptor;\n  size_t num_records, min_records, max_records;\n\n  res = 0;\n\n  if (remote_descriptor_p\n      && (descriptor = rec_rset_descriptor (rset)))\n    {\n      /* Make a backup of the record descriptor to restore it\n         later.  */\n      descriptor = rec_record_dup (descriptor);\n\n      /* Fetch the remote descriptor, if any, and merge it with the\n         local descriptor.  If there is any error, stop and report\n         it.  */\n      res = rec_int_merge_remote (rset, errors);\n      if (res > 0)\n        {\n          return res;\n        }\n    }\n\n  if (check_descriptor_p)\n    {\n      res += rec_int_check_descriptor (rset, errors);\n    }\n\n  if (res > 0)\n    {\n      /* Stop here, since a lot of errors in the records will be\n         generated due to errors in the record descriptor.  */\n      return res;\n    }\n\n  /* Verify rset size restrictions.  */\n  num_records = rec_rset_num_records (rset);\n  min_records = rec_rset_min_records (rset);\n  max_records = rec_rset_max_records (rset);\n\n  if (min_records == max_records)\n    {\n      if (num_records != min_records)\n        {\n          ADD_ERROR (errors,\n                     _(\"%s: error: the number of records of type %s should be %zd.\\n\"),\n                     rec_rset_source (rset), rec_rset_type (rset), min_records);\n          res++;\n        }\n    }\n  else\n    {\n      if (num_records > rec_rset_max_records (rset))\n        {\n          ADD_ERROR (errors,\n                     _(\"%s: error: too many records of type %s. Maximum allowed are %zd.\\n\"),\n                     rec_rset_source (rset), rec_rset_type (rset), rec_rset_max_records (rset));\n          res++;\n        }\n      if (num_records < rec_rset_min_records (rset))\n        {\n          ADD_ERROR (errors,\n                     _(\"%s: error: too few records of type %s. Minimum allowed are %zd.\\n\"),\n                    rec_rset_source (rset), rec_rset_type (rset), rec_rset_min_records (rset));\n          res++;\n        }\n    }\n  \n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, NULL))\n    {\n      res += rec_int_check_record (db,\n                                   rset,\n                                   record, record,\n                                   errors);\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  if (remote_descriptor_p)\n    {\n      /* Restore the original descriptor in the record set.  */\n      rec_rset_set_descriptor (rset, descriptor);\n    }\n\n  return res;\n}",
      "lines": 96,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rec_int_check_record": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "int\nrec_int_check_record (rec_db_t db,\n                      rec_rset_t rset,\n                      rec_record_t orig_record,\n                      rec_record_t record,\n                      rec_buf_t errors)\n{\n  int res;\n\n  res =\n    rec_int_check_record_key (rset, orig_record, record, errors)\n    + rec_int_check_record_types     (db, rset, record, errors)\n    + rec_int_check_record_mandatory (rset, record, errors)\n    + rec_int_check_record_unique    (rset, record, errors)\n#if defined REC_CRYPT_SUPPORT\n    + rec_int_check_record_secrets   (rset, record, errors)\n#endif\n    + rec_int_check_record_prohibit  (rset, record, errors)\n    + rec_int_check_record_sex_constraints (rset, record, errors)\n    + rec_int_check_record_allowed   (rset, record, errors);\n\n  return res;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rec_int_check_field_type": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "bool\nrec_int_check_field_type (rec_db_t db,\n                          rec_rset_t rset,\n                          rec_field_t field,\n                          rec_buf_t errors)\n{\n  bool res = true;\n  rec_type_t type;\n  char *errors_str;\n\n  res = true;\n\n\n  /* Get the proper type to check 'field' with, checking with the type\n     from the type registry of 'rset', if any.  */\n\n  type = rec_rset_get_field_type (rset, rec_field_name (field));\n\n  /* Check the field with the type.  This is done by simply invoking\n     rec_type_check on the field value.  An exception to this is the\n     'rec' type.  The 'rec' type is used to implement foreign keys,\n     and its effect on the type integrity system is that the value of\n     the field must be considered to be of whatever type the primary\n     key of the referred record set is.  */\n\n  if (type)\n    {\n      if (rec_type_kind (type) == REC_TYPE_REC)\n        {\n          /* Get the name of the referred record set.  Check the type\n             if and only if:\n             \n             - The referred rset exists in DB and\n             - The referred rset has a primary key.\n             - The primary key of the referred rset has a type.\n          */\n\n          const char *rset_type = rec_type_rec (type);\n          rec_rset_t rset = rec_db_get_rset_by_type (db, rset_type);\n\n          if (rset)\n            {\n              const char *key = rec_rset_key (rset);\n              rec_type_t key_type = rec_rset_get_field_type (rset, key);\n\n              if (key_type)\n                {\n                  if (!rec_type_check (key_type, rec_field_value (field), &errors_str))\n                    {\n                      if (errors)\n                        {\n                          ADD_ERROR (errors,\n                                     \"%s:%s: error: %s\\n\",\n                                     rec_field_source (field), rec_field_location_str (field),\n                                     errors_str);\n                        }\n                      free (errors_str);\n                      res = false;\n                    }\n                }\n            }\n        }\n      else\n        {\n          if (!rec_type_check (type, rec_field_value (field), &errors_str))\n            {\n              if (errors)\n                {\n                  ADD_ERROR (errors,\n                             \"%s:%s: error: %s\\n\",\n                             rec_field_source (field), rec_field_location_str (field),\n                             errors_str);\n                }\n              free (errors_str);\n              res = false;\n            }\n        }\n    }\n\n  return res;\n}",
      "lines": 81,
      "depth": 20,
      "decorators": [
        "bool"
      ]
    },
    "rec_int_collect_field_list": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static rec_fex_t\nrec_int_collect_field_list (rec_record_t record,\n                            const char *fname)\n{\n  size_t i, j = 0;\n  size_t num_fields = rec_record_get_num_fields_by_name (record, fname);\n  rec_fex_t res = rec_fex_new (NULL, REC_FEX_SIMPLE);\n\n  if (!res)\n    return NULL; /* Out of memory.  */\n\n  for (i = 0; i < num_fields; i++)\n    {\n      rec_field_t field = rec_record_get_field_by_name (record, fname, i);\n      rec_fex_t fex = rec_fex_new (rec_field_value (field), REC_FEX_SIMPLE);\n      if (!fex)\n        /* Invalid value in the field.  Ignore it.  */\n        continue;\n\n      for (j = 0; j < rec_fex_size (fex); j++)\n        {\n          rec_fex_elem_t elem = rec_fex_get (fex, j);\n          char *field_name = strdup (rec_fex_elem_field_name (elem));\n\n          if (!field_name\n              || !rec_fex_append (res,\n                                  field_name,\n                                  rec_fex_elem_min (elem),\n                                  rec_fex_elem_max (elem)))\n            /* Not enough memory: panic and retreat!  */\n            return NULL;\n        }\n      rec_fex_destroy (fex);\n    }\n\n  return res;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "rec_fex_t"
      ]
    },
    "rec_int_check_record_types": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "static int\nrec_int_check_record_types (rec_db_t db,\n                            rec_rset_t rset,\n                            rec_record_t record,\n                            rec_buf_t errors)\n{\n  int res;\n  rec_field_t field;\n  rec_mset_iterator_t iter;\n\n  res = 0;\n\n  iter = rec_mset_iterator (rec_record_mset (record));\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      /* Check for the type.  */\n      if (!rec_int_check_field_type (db, rset, field, errors))\n        {\n          res++;\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_mandatory": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        436,
        1
      ],
      "content": "static int\nrec_int_check_record_mandatory (rec_rset_t rset,\n                                rec_record_t record,\n                                rec_buf_t errors)\n{\n  rec_fex_t fex_mandatory = NULL;\n  int res = 0;\n  size_t i;\n  \n  rec_record_t descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      fex_mandatory = rec_int_collect_field_list (descriptor, FNAME(REC_FIELD_MANDATORY));\n      if (!fex_mandatory)\n        {\n          ADD_ERROR (errors, _(\"out of memory\\n\"), \"\");\n          res = 1;\n          goto cleanup;\n        }\n\n      /* Make sure that all fields in the mandatory fields list are in\n         this record.  */\n\n      for (i = 0; i < rec_fex_size (fex_mandatory); i++)\n        {\n          const char *fname = rec_fex_elem_field_name (rec_fex_get (fex_mandatory, i));\n          if (rec_record_get_num_fields_by_name (record, fname)\n              == 0)\n            {\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: mandatory field '%s' not found in record\\n\"),\n                         rec_record_source (record),\n                         rec_record_location_str (record),\n                         fname);\n              res++;\n            }\n        }\n    }\n\n cleanup:\n\n  rec_fex_destroy (fex_mandatory);\n  return res;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_allowed": {
      "start_point": [
        438,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "static int\nrec_int_check_record_allowed (rec_rset_t rset,\n                              rec_record_t record,\n                              rec_buf_t errors)\n{\n  /* If %allowed is specified then fields with names not in the union\n     of %allowed + %mandatory + %key are not allowed in records, and\n     thus that situation is an integrity error.  */\n\n  rec_fex_t fex_allowed   = NULL;\n  rec_fex_t fex_mandatory = NULL;\n  rec_fex_t fex_key       = NULL;\n  \n  int res = 0;\n  rec_record_t descriptor = rec_rset_descriptor (rset);\n\n  if (descriptor)\n    {\n      fex_allowed = rec_int_collect_field_list (descriptor,   FNAME(REC_FIELD_ALLOWED));\n      fex_mandatory = rec_int_collect_field_list (descriptor, FNAME(REC_FIELD_MANDATORY));\n      fex_key = rec_int_collect_field_list (descriptor,       FNAME(REC_FIELD_KEY));\n\n      if (!fex_allowed || !fex_mandatory || !fex_key)\n        {\n          ADD_ERROR (errors, _(\"out of memory\\n\"), \"\");\n          res = 1;\n          goto cleanup;\n        }\n\n\n      if (rec_fex_size (fex_allowed) == 0)\n        /* Nothing to do.  */\n        goto cleanup;\n\n      /* Make sure that all the fields in RECORD are in either\n         %allowed, %mandatory or %key.  */\n          \n      rec_field_t field = NULL;\n      rec_mset_iterator_t iter = rec_mset_iterator (rec_record_mset (record));\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n        {\n          const char *field_name = rec_field_name (field);\n          if (!(rec_fex_member_p (fex_allowed, field_name, -1, -1)\n                || rec_fex_member_p (fex_mandatory, field_name, -1, -1)\n                || rec_fex_member_p (fex_key, field_name, -1, -1)))\n            {\n              /* This field is not allowed.  */\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: field '%s' not allowed in this record set\\n\"),\n                         rec_record_source (record),\n                         rec_record_location_str (record),\n                         field_name);\n              res++;\n            }\n        }\n      rec_mset_iterator_free (&iter);\n    }\n  \n cleanup:\n  \n  rec_fex_destroy (fex_allowed);\n  rec_fex_destroy (fex_mandatory);\n  rec_fex_destroy (fex_key);\n  return res;\n}",
      "lines": 65,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_unique": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "static int\nrec_int_check_record_unique (rec_rset_t rset,\n                             rec_record_t record,\n                             rec_buf_t errors)\n{\n  rec_fex_t fex_unique = NULL;\n  int res = 0;\n  size_t i;\n\n  rec_record_t descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      fex_unique = rec_int_collect_field_list (descriptor, FNAME(REC_FIELD_UNIQUE));\n      if (!fex_unique)\n        {\n          ADD_ERROR (errors, _(\"out of memory\\n\"), \"\");\n          res = 1;\n          goto cleanup;\n        }\n\n      /* Make sure that all fields in the unique fields list are\n         unique in this record.  */\n\n      for (i = 0; i < rec_fex_size (fex_unique); i++)\n        {\n          const char *fname = rec_fex_elem_field_name (rec_fex_get (fex_unique, i));\n          if (rec_record_get_num_fields_by_name (record, fname) > 1)\n            {\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: field '%s' should be unique in this record\\n\"),\n                         rec_record_source (record),\n                         rec_record_location_str (record),\n                         fname);\n              res++;\n            }\n        }\n    }\n\n cleanup:\n\n  rec_fex_destroy (fex_unique);\n  return res;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_prohibit": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "static int\nrec_int_check_record_prohibit (rec_rset_t rset,\n                               rec_record_t record,\n                               rec_buf_t errors)\n{\n  rec_fex_t fex_prohibit = NULL;\n  int res = 0;\n  size_t i;\n\n  rec_record_t descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      fex_prohibit = rec_int_collect_field_list (descriptor, FNAME(REC_FIELD_PROHIBIT));\n      if (!fex_prohibit)\n        {\n          ADD_ERROR (errors, _(\"out of memory\\n\"), \"\");\n          res = 1;\n          goto cleanup;\n        }\n\n      /* Make sure that no field in the prohibit fields list is\n         present in the record.  */\n\n      for (i = 0; i < rec_fex_size (fex_prohibit); i++)\n        {\n          const char *fname = rec_fex_elem_field_name (rec_fex_get (fex_prohibit, i));\n          if (rec_record_get_num_fields_by_name (record, fname) > 0)\n            {\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: prohibited field '%s' found in record\\n\"),\n                         rec_record_source (record),\n                         rec_record_location_str (record),\n                         fname);\n              res++;\n            }\n        }\n    }\n\n cleanup:\n\n  rec_fex_destroy (fex_prohibit);\n  return res;\n}",
      "lines": 43,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_sex_constraints": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        618,
        1
      ],
      "content": "static int\nrec_int_check_record_sex_constraints (rec_rset_t rset,\n                                      rec_record_t record,\n                                      rec_buf_t errors)\n{\n  int res = 0;\n  size_t i = 0;\n  size_t num_constraints = rec_rset_num_sex_constraints (rset);\n\n  for (i = 0; i < num_constraints; i++)\n    {\n      bool status = false;\n      rec_sex_t sex = rec_rset_sex_constraint (rset, i);\n\n      if (!rec_sex_eval (sex, record, &status))\n        {\n          ADD_ERROR (errors,\n                     _(\"%s:%s: error: %%constraint[%d] violated in record\\n\"),\n                     rec_record_source (record),\n                     rec_record_location_str (record),\n                     i);\n          res++;\n        }\n    }\n\n  return res;\n}",
      "lines": 27,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_secrets": {
      "start_point": [
        622,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "static int\nrec_int_check_record_secrets (rec_rset_t rset,\n                              rec_record_t record,\n                              rec_buf_t errors)\n{\n  int res;\n  rec_field_t field;\n  rec_mset_iterator_t iter;\n\n  res = 0;\n\n  iter = rec_mset_iterator (rec_record_mset (record));\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, NULL))\n    {\n      /* If the field is confidential it must be encrypted.  Encrypted\n         field values can be recognized by the \"encrypted-\"\n         prefix.  */\n#define REC_ENCRYPTED_PREFIX \"encrypted-\"\n      if (rec_rset_field_confidential_p (rset, rec_field_name (field))\n          && (strncmp (rec_field_value (field),\n                       REC_ENCRYPTED_PREFIX,\n                       strlen (REC_ENCRYPTED_PREFIX)) != 0))\n        {\n          ADD_ERROR (errors,\n                    _(\"%s:%s: error: confidential field is not encrypted\\n\"),\n                    rec_record_source (record),\n                     rec_record_location_str (record));\n          res++;\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 35,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_record_key": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "static int\nrec_int_check_record_key (rec_rset_t rset,\n                          rec_record_t orig_record,\n                          rec_record_t record,\n                          rec_buf_t errors)\n{\n  int res;\n  rec_record_t descriptor;\n  rec_record_t other_record;\n  rec_mset_iterator_t iter;\n  char *key_field_name;\n  rec_field_t field;\n  rec_field_t key;\n  rec_field_t other_key;\n  bool duplicated_key;\n  size_t i;\n  size_t num_fields;\n  \n  res = 0;\n\n  descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      for (i = 0; i < rec_record_get_num_fields_by_name (descriptor,\n                                                         FNAME(REC_FIELD_KEY));\n           i++)\n        {\n          field = rec_record_get_field_by_name (descriptor, FNAME(REC_FIELD_KEY), i);\n\n          /* Parse the field name from the value of %key:  */\n          key_field_name = rec_parse_field_name_str (rec_field_value (field));\n          if (key_field_name)\n            {\n              num_fields = rec_record_get_num_fields_by_name (record, key_field_name);\n\n              if (num_fields == 0)\n                {\n                  ADD_ERROR (errors,\n                            _(\"%s:%s: error: key field '%s' not found in record\\n\"),\n                             rec_record_source (record),\n                             rec_record_location_str (record),\n                             rec_field_value (field));\n                  res++;\n                }\n              else if (num_fields > 1)\n                {\n                  ADD_ERROR (errors,\n                             _(\"%s:%s: error: multiple key fields '%s' in record\\n\"),\n                             rec_record_source (record),\n                             rec_record_location_str (record),\n                             rec_field_value (field));\n                  res++;\n                }\n              else  /* num_fields == 1 */\n                {\n                  /* Check that the value specified as the key is\n                     unique in the whole record set.  */\n                  key = rec_record_get_field_by_name (record,\n                                                      key_field_name,\n                                                      0);\n                  duplicated_key = false;\n                  \n                  iter = rec_mset_iterator (rec_rset_mset (rset));\n                  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void**) &other_record, NULL))\n                    {\n                      if (other_record != orig_record)\n                        {\n                          /* XXX: Only the first key field is considered.  */\n                          other_key = rec_record_get_field_by_name (other_record,\n                                                                    key_field_name,\n                                                                    0);\n                          if (other_key)\n                            {\n                              if (strcmp (rec_field_value (other_key),\n                                          rec_field_value (key)) == 0)\n                                {\n                                  /* Found a key field with the same\n                                     value in other record.  */\n                                  duplicated_key = true;\n                                  break;\n                                }\n                            }\n                        }\n                    }\n\n                  rec_mset_iterator_free (&iter);\n\n                  if (duplicated_key)\n                    {\n                      ADD_ERROR (errors,\n                                 _(\"%s:%s: error: duplicated key value in field '%s' in record\\n\"),\n                                 rec_record_source (orig_record),\n                                 rec_record_location_str (orig_record),\n                                 rec_field_name (key));\n                      res++;\n                      break;\n                    }\n                }\n\n              free (key_field_name);\n            }\n        }                                          \n    }\n\n  return res;\n}",
      "lines": 106,
      "depth": 25,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_check_descriptor": {
      "start_point": [
        767,
        0
      ],
      "end_point": [
        1088,
        1
      ],
      "content": "static int\nrec_int_check_descriptor (rec_rset_t rset,\n                          rec_buf_t errors)\n{\n  int res;\n  rec_record_t descriptor;\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n  const char *field_name;\n  const char *field_value;\n  rec_fex_t fex;\n  const char *auto_field_name;\n  size_t i;\n  rec_type_t type;\n  char *type_name = NULL;\n  const char *p, *q = NULL;\n\n  res = 0;\n\n  descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      /* Check the type of the record set:\n\n         1. There should be one (and only one) %rec: field in the\n            record.\n         2. The value of the %rec: field shall be well-formed.\n      */\n      if (rec_record_get_num_fields_by_name (descriptor, FNAME(REC_FIELD_REC)) == 0)\n        {\n          ADD_ERROR (errors,\n                     _(\"%s:%s: error: missing %%rec field in record descriptor\\n\"),\n                     rec_record_source (descriptor),\n                     rec_record_location_str (descriptor));\n          res++;\n        }\n      else if (rec_record_get_num_fields_by_name (descriptor, FNAME(REC_FIELD_REC)) > 1)\n        {\n          ADD_ERROR (errors,\n                     _(\"%s:%s: error: too many %%rec fields in record descriptor\\n\"),\n                     rec_record_source (descriptor),\n                     rec_record_location_str (descriptor));\n          res++;\n        }\n\n      field = rec_record_get_field_by_name (descriptor, FNAME(REC_FIELD_REC), 0);\n      if (!rec_int_rec_type_p (rec_field_value (field)))\n        {\n          ADD_ERROR (errors,\n                     _(\"%s:%s: error: invalid record type %s\\n\"),\n                     rec_field_source (field),\n                     rec_field_location_str (field),\n                     rec_field_value (field));\n          res++;\n        }\n\n      /* Only one 'key:' entry is allowed, if any.  */\n      if (rec_record_get_num_fields_by_name (descriptor, FNAME(REC_FIELD_KEY)) > 1)\n        {\n          ADD_ERROR (errors,\n                     _(\"%s:%s: error: only one %%key field is allowed in a record descriptor\\n\"),\n                     rec_record_source (descriptor),\n                     rec_record_location_str (descriptor));\n          res++;\n        }\n\n      /* Only one 'size:' entry is allowed, if any.  */\n      if (rec_record_get_num_fields_by_name (descriptor, FNAME(REC_FIELD_SIZE)) > 1)\n        {\n          ADD_ERROR (errors,\n                    _(\"%s:%s: error: only one %%size field is allowed in a record descriptor\\n\"),\n                    rec_record_source (descriptor),\n                    rec_record_location_str (descriptor));\n          res++;\n        }\n\n      /* Only one 'sort:' entry is allowed, if any.  */\n      if (rec_record_get_num_fields_by_name (descriptor, FNAME(REC_FIELD_SORT)) > 1)\n        {\n          ADD_ERROR (errors,\n                    _(\"%s:%s: error: only one %%sort field is allowed in a record descriptor\\n\"),\n                    rec_record_source (descriptor),\n                    rec_record_location_str (descriptor));\n          res++;\n        }\n\n      /* Iterate on fields.  */\n\n      iter = rec_mset_iterator (rec_record_mset (descriptor));\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, NULL))\n        {\n          field_name = rec_field_name (field);\n          field_value = rec_field_value (field);\n\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_TYPE)))\n            {\n              /* Check for the list of fields.  */\n              p = field_value;\n              rec_skip_blanks (&p);\n              if (!rec_parse_regexp (&p, \"^\" REC_FNAME_RE \"(,\" REC_FNAME_RE \")*\",\n                                     NULL))\n                {\n                  ADD_ERROR (errors,\n                            _(\"%s:%s: error: expected a comma-separated list of fields \\\nbefore the type specification\\n\"),\n                            rec_field_source (field),\n                            rec_field_location_str (field));\n                  res++;\n                }\n\n              /* Check the type descriptor.  Note that it can be\n                 either a type specification or a type name.  */\n              rec_skip_blanks (&p);\n              if (!rec_type_descr_p (p))\n                {\n                  q = p;\n                  if (rec_parse_regexp (&q, \"^\" REC_TYPE_NAME_RE \"[ \\t\\n]*$\",\n                                        NULL))\n                    {\n                      /* The named type shall exist in the record set\n                         type registry.\n                      \n                         XXX: but this is probably a warning rather\n                         than an error.  */\n\n                      rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, &type_name);\n                      if (!rec_type_reg_get (rec_rset_get_type_reg (rset), type_name))\n                        {\n                          ADD_ERROR (errors,\n                                    _(\"%s:%s: error: the referred type %s \\\ndoes not exist\\n\"),\n                                    rec_field_source (field),\n                                    rec_field_location_str (field),\n                                    type_name);\n                          res++;\n                        }\n                    }\n                  else\n                    {\n                      /* XXX: make rec_type_descr_p to report more details.  */\n                      ADD_ERROR (errors,\n                                _(\"%s:%s: error: invalid type specification\\n\"),\n                                rec_field_source (field),\n                                rec_field_location_str (field));\n                      res++;\n                    }\n                }\n            }\n          else if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_TYPEDEF)))\n            {\n              /* Check for the type name.  */\n              p = field_value;\n              rec_skip_blanks (&p);\n              if (!rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, NULL))\n                {\n                  ADD_ERROR (errors,\n                            _(\"%s:%s: error: expected a type name before the type \\\nspecification\\n\"),\n                            rec_field_source (field),\n                            rec_field_location_str (field));\n                  res++;\n                }\n              \n              /* Check the type descriptor.  Note that it can be\n                 either a type specification or a type name.  */\n              rec_skip_blanks (&p);\n              if (!rec_type_descr_p (p))\n                {\n                  q = p;\n                  if (rec_parse_regexp (&q, \"^\" REC_TYPE_NAME_RE \"[ \\t\\n]*$\",\n                                        NULL))\n                    {\n                      /* The named type shall exist in the record set\n                         type registry.\n                      \n                         XXX: but this is probably a warning rather\n                         than an error.  */\n\n                      rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, &type_name);\n                      if (!rec_type_reg_get (rec_rset_get_type_reg (rset), type_name))\n                        {\n                          ADD_ERROR (errors,\n                                    _(\"%s:%s: error: the referred type %s \\\ndoes not exist\\n\"),\n                                    rec_field_source (field),\n                                    rec_field_location_str (field),\n                                    type_name);\n                          res++;\n                        }\n                    }\n                  else\n                    {\n                      /* XXX: make rec_type_descr_p to report more details.  */\n                      ADD_ERROR (errors,\n                                _(\"%s:%s: error: invalid typedef specification\\n\"),\n                                rec_field_source (field),\n                                rec_field_location_str (field));\n                      res++;\n                    }\n                }\n            }\n          else if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_CONSTRAINT)))\n            {\n              /* Check that the value of this field is a valid\n                 selection expression.  */\n              \n              rec_sex_t sex = rec_sex_new (false);\n              if (sex)\n                {\n                  if (rec_sex_compile (sex, field_value))\n                    {\n                      rec_sex_destroy (sex);\n                    }\n                  else\n                    {\n                      ADD_ERROR (errors,\n                                 _(\"%s:%s: error: value for %s[%zd] is not a valid selection expression\\n\"),\n                                 rec_record_source (descriptor),\n                                 rec_record_location_str (descriptor),\n                                 rec_field_name (field),\n                                 rec_record_get_field_index_by_name (descriptor, field));\n                      res++;\n                    }\n                }\n              else\n                {\n                  /* Out of memory.  */\n                  res++;\n                }\n            }\n          else if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_MANDATORY))\n                   || rec_field_name_equal_p (field_name, FNAME(REC_FIELD_UNIQUE))\n                   || rec_field_name_equal_p (field_name, FNAME(REC_FIELD_PROHIBIT))\n                   || rec_field_name_equal_p (field_name, FNAME(REC_FIELD_AUTO))\n                   || rec_field_name_equal_p (field_name, FNAME(REC_FIELD_SORT))\n                   || rec_field_name_equal_p (field_name, FNAME(REC_FIELD_ALLOWED)))\n            {\n              /* Check that the value of this field is a parseable\n                 list of field names.  */\n              fex = rec_fex_new (field_value, REC_FEX_SIMPLE);\n              if (fex)\n                {\n                  rec_fex_destroy (fex);\n                }\n              else\n                {\n                  ADD_ERROR (errors,\n                             _(\"%s:%s: error: value for %s[%zd] is not a list of field names\\n\"),\n                             rec_record_source (descriptor),\n                             rec_record_location_str (descriptor),\n                             rec_field_name (field),\n                             rec_record_get_field_index_by_name (descriptor, field));\n                  res++;\n                }\n            }\n          else if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_SIZE)))\n            {\n              if (!rec_match (field_value, REC_INT_SIZE_RE))\n                {\n                  ADD_ERROR (errors,\n                            _(\"%s:%s: error: value for %s should be a number optionally preceded by >, <, >= or <=.\\n\"),\n                            rec_field_source (field),\n                            rec_field_location_str (field),\n                            field_name);\n                  res++;\n                }\n            }\n#if defined REC_CRYPT_SUPPORT\n          else if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_CONFIDENTIAL)))\n            {\n              if (!rec_match (field_value,\n                              \"^\"\n                              \"[ \\n\\t]*\" REC_FNAME_RE \"([ \\n\\t]+\" REC_FNAME_RE \")*\"\n                              \"[ \\n\\t]*$\"))\n                {\n                  ADD_ERROR (errors,\n                            _(\"%s:%s: error: value for %s should be a list of field names.\\n\"),\n                            rec_field_source (field),\n                            rec_field_location_str (field),\n                            field_name);\n                  res++;\n                }\n            }\n#endif /* REC_CRYPT_SUPPORT */          \n\n          if ((rec_field_name_equal_p (field_name, FNAME(REC_FIELD_AUTO)))\n              && (fex = rec_fex_new (field_value, REC_FEX_SIMPLE)))\n            {\n              /* Check that the auto incremented fields have not been\n                 declared with a type other than 'int'. */\n              for (i = 0; i < rec_fex_size (fex); i++)\n                {\n                  auto_field_name = rec_fex_elem_field_name (rec_fex_get (fex, i));\n                  type = rec_rset_get_field_type (rset, auto_field_name);\n                  if ((!type) ||\n                      ! ((rec_type_kind (type) == REC_TYPE_INT)\n                         || (rec_type_kind (type) == REC_TYPE_RANGE)\n#if defined UUID_TYPE\n                         || (rec_type_kind (type) == REC_TYPE_UUID)\n#endif\n                         || (rec_type_kind (type) == REC_TYPE_DATE)))\n                    {\n                      ADD_ERROR (errors,\n#if defined UUID_TYPE\n                                 _(\"%s:%s: error: auto-incremented field %s should be of type int, range, uuid or date\\n\"),\n#else\n                                 _(\"%s:%s: error: auto-incremented field %s should be of type int, range or date\\n\"),\n#endif\n                                rec_record_source (descriptor),\n                                rec_record_location_str (descriptor),\n                                auto_field_name);\n                      res++;\n                    }\n                }\n            }\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n\n  return res;\n}",
      "lines": 322,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_int_merge_remote": {
      "start_point": [
        1090,
        0
      ],
      "end_point": [
        1251,
        1
      ],
      "content": "int\nrec_int_merge_remote (rec_rset_t rset,\n                      rec_buf_t errors)\n{\n  int res;\n  rec_parser_t parser;\n  rec_record_t descriptor;\n  rec_db_t remote_db;\n  rec_rset_t remote_rset;\n  rec_field_t remote_field;\n  rec_mset_iterator_t iter;\n  rec_record_t remote_descriptor;\n  rec_field_t rec_field;\n  char *rec_type;\n  char *rec_url = NULL;\n  char *rec_file = NULL;\n  char *rec_source = NULL;\n  FILE *external_file;\n  char tmpfile_name[14];\n\n  res = 0;\n\n  tmpfile_name[0] = '\\0';\n\n  /* If a remote descriptor is defined in the record descriptor of\n     RSET, fetch it and merge it with the local descriptor.  */\n\n  descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      /* Check if there is an URL in the %rec: field.  */\n      rec_field = rec_record_get_field_by_name (descriptor, FNAME(REC_FIELD_REC), 0);\n\n      if (!rec_int_rec_type_p (rec_field_value (rec_field)))\n        {\n          return 0;\n        }\n\n      rec_type = rec_extract_type (rec_field_value (rec_field));\n      rec_file = rec_extract_file (rec_field_value (rec_field));\n      rec_url  = rec_extract_url  (rec_field_value (rec_field));\n\n      if (rec_file || rec_url)\n        {\n          if (rec_url)\n            {\n#if defined REMOTE_DESCRIPTORS\n              CURL *curl;\n              int tmpfile_des;\n\n              /* Fetch the remote descriptor.  */\n              curl = curl_easy_init ();\n\n              /* Create a temporary file.  */\n              memcpy (tmpfile_name, \"recint-XXXXXX\", 13);\n              tmpfile_name[13] = '\\0';\n              tmpfile_des = gen_tempname (tmpfile_name, 0, 0, GT_FILE);\n              external_file = fdopen (tmpfile_des, \"r+\");\n              \n              /* Fetch the remote file.  */\n              curl_easy_setopt (curl, CURLOPT_URL, rec_url);\n              curl_easy_setopt (curl, CURLOPT_WRITEDATA, external_file);\n              curl_easy_setopt (curl, CURLOPT_FAILONERROR, 1);\n              if (curl_easy_perform (curl) != 0)\n                {\n                  ADD_ERROR (errors,\n                             _(\"%s:%s: error: could not fetch remote descriptor from url %s.\\n\"),\n                             rec_field_source (rec_field), rec_field_location_str (rec_field),\n                             rec_url);\n                  res++;\n                  goto exit;\n                }\n              curl_easy_cleanup (curl);\n              rec_source = rec_url;\n#else\n              goto exit;\n#endif /* REMOTE_DESCRIPTORS */\n            }\n          else\n            {\n              /* Try to open the file.  */\n              external_file = fopen (rec_file, \"r\");\n              if (!external_file)\n                {\n                  ADD_ERROR (errors,\n                             _(\"%s:%s: error: could not read external descriptor from file %s.\\n\"),\n                             rec_field_source (rec_field), rec_field_location_str (rec_field),\n                             rec_file);\n                  res++;\n                  goto exit;\n                }\n              rec_source = rec_file;\n            }              \n\n          /* Parse the contents of the external file.  */\n          fseek (external_file, 0, SEEK_SET);\n          parser = rec_parser_new (external_file, rec_source);\n          if (!rec_parse_db (parser, &remote_db))\n            {\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: %s does not contain valid rec data.\\n\"),\n                         rec_field_source (rec_field), rec_field_location_str (rec_field),\n                         rec_source);\n              res++;\n              goto exit;\n            }\n          rec_parser_destroy (parser);\n          \n          /* Get the proper external descriptor and merge it with\n             the local one.  */\n          remote_rset = rec_db_get_rset_by_type (remote_db, rec_type);\n          if (!remote_rset)\n            {\n              ADD_ERROR (errors,\n                         _(\"%s:%s: error: %s does not contain information for type %s.\\n\"),\n                         rec_field_source (rec_field), rec_field_location_str (rec_field),\n                         rec_source, rec_type);\n              res++;\n              goto exit;\n            }\n          remote_descriptor = rec_rset_descriptor (remote_rset);\n          if (!remote_descriptor)\n            {\n              /* Do nothing.  */\n              goto exit;\n            }\n          \n          iter = rec_mset_iterator (rec_record_mset (remote_descriptor));\n          while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &remote_field, NULL))\n            {\n              /* Merge the descriptors, but take care to not add a new\n                 %rec: field.  */\n\n              if (!rec_field_name_equal_p (rec_field_name (remote_field), FNAME(REC_FIELD_REC)))\n                {\n                  rec_mset_append (rec_record_mset (descriptor), MSET_FIELD, (void *) rec_field_dup (remote_field), MSET_ANY);\n                }\n            }\n\n          rec_mset_iterator_free (&iter);\n          \n          /* Update the record descriptor (triggering the creation\n             of a new type registry).  */\n          rec_rset_set_descriptor (rset, rec_record_dup (descriptor));\n          \n          rec_db_destroy (remote_db);\n          fclose (external_file);\n        }\n    }\n\n exit:\n\n  if (rec_url && (tmpfile_name[0] != '\\0'))\n    {\n      remove (tmpfile_name);\n    }\n\n  free (rec_url);\n  free (rec_file);\n\n  return res;\n}",
      "lines": 162,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "rec_int_rec_type_p": {
      "start_point": [
        1253,
        0
      ],
      "end_point": [
        1266,
        1
      ],
      "content": "static bool\nrec_int_rec_type_p (const char *str)\n{\n  return rec_match (str,\n                    \"^[ \\t]*\"\n                    REC_RECORD_TYPE_RE\n                    \"[ \\n\\t]*\"\n                    \"(\"\n                    \"(\" REC_URL_REGEXP \")\"\n                    \"|\"\n                    \"(\" REC_FILE_REGEXP \")\"\n                    \"[ \\t]*)?\"\n                    \"$\");\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-mset.c": {
    "rec_mset_new": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "rec_mset_t\nrec_mset_new (void)\n{\n  rec_mset_t new;\n  int i;\n\n  new = malloc (sizeof (struct rec_mset_s));\n  if (new)\n    {\n      rec_mset_init (new);\n\n      new->ntypes = 1;\n\n      for (i = 0; i < MAX_NTYPES; i++)\n        {\n          new->count[i] = 0;\n          new->name[i] = NULL;\n          new->equal_fn[i] = NULL;\n          new->disp_fn[i] = NULL;\n          new->dup_fn[i] = NULL;\n          new->compare_fn[i] = NULL;\n        }\n\n      new->elem_list = gl_list_nx_create_empty (GL_ARRAY_LIST,\n                                                rec_mset_elem_equal_fn,\n                                                NULL,\n                                                rec_mset_elem_dispose_fn,\n                                                true);\n\n      if (new->elem_list == NULL)\n        {\n          /* Out of memory.  */\n          rec_mset_destroy (new);\n          new = NULL;\n        }\n    }\n\n  return new;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "rec_mset_t"
      ]
    },
    "rec_mset_destroy": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\nrec_mset_destroy (rec_mset_t mset)\n{\n  if (mset)\n    {\n      int i;\n      for (i = 0; i < mset->ntypes; i++)\n        {\n          free(mset->name[i]);\n        }\n      gl_list_free (mset->elem_list);\n      free (mset);\n    }\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rec_mset_dup": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "rec_mset_t\nrec_mset_dup (rec_mset_t mset)\n{\n  rec_mset_t new;\n  rec_mset_elem_t elem;\n  gl_list_iterator_t iter;\n  int i;\n  \n  new = rec_mset_new ();\n\n  if (new)\n    {\n      /* Register the types.  */\n      new->ntypes = mset->ntypes;\n      for (i = 0; i < new->ntypes; i++)\n        {\n          new->count[i] = 0;\n          if (new->name[i])\n            {\n              new->name[i] = strdup (mset->name[i]);\n              if (!new->name[i])\n                {\n                  /* Out of memory.  */\n                  rec_mset_destroy (new);\n                  return NULL;\n                }\n            }\n          new->disp_fn[i] = mset->disp_fn[i];\n          new->equal_fn[i] = mset->equal_fn[i];\n          new->dup_fn[i] = mset->dup_fn[i];\n          new->compare_fn[i] = mset->compare_fn[i];\n        }\n\n      /* Duplicate the elements.  */\n\n      iter = gl_list_iterator (mset->elem_list);\n      while (gl_list_iterator_next (&iter, (const void **) &elem, NULL))\n        {\n          void *data = NULL;\n\n          /* Set the data.  */\n          if (new->dup_fn[elem->type])\n            {\n              data = (new->dup_fn[elem->type]) (elem->data);\n              if (!data)\n                {\n                  /* Out of memory.  */\n                  rec_mset_destroy (new);\n                  return NULL;\n                }\n            }\n          else\n            {\n              data = elem->data;\n            }\n\n          /* Append the new data into a new element.  */\n\n          rec_mset_append (new, elem->type, data, MSET_ANY);\n        }\n\n      gl_list_iterator_free (&iter);\n    }\n\n  return new;\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "rec_mset_t"
      ]
    },
    "rec_mset_sort": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "rec_mset_t\nrec_mset_sort (rec_mset_t mset)\n{\n  rec_mset_elem_t elem;\n  gl_list_iterator_t iter;\n  gl_list_t list;\n\n  /* Save a reference to the old gnulib list and create a new, empty\n     one.  */\n\n  list = mset->elem_list;\n  mset->elem_list = gl_list_nx_create_empty (GL_ARRAY_LIST,\n                                             rec_mset_elem_equal_fn,\n                                             NULL,\n                                             rec_mset_elem_dispose_fn,\n                                             true);\n  if (!mset->elem_list)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n\n  /* Iterate on the old list getting the data of the elements and\n     inserting it into the new sorted gl_list.  */\n\n  iter = gl_list_iterator (list);\n  while (gl_list_iterator_next (&iter, (const void **) &elem, NULL))\n    {\n      /* Create a new node list with the proper data and insert it\n         into the list using whatever sorting criteria is implemented\n         by compare_fn.  */\n\n      if (!rec_mset_add_sorted (mset, elem->type, elem->data))\n        {\n          /* Out of memory.  Delete the new list and restore the old\n             one.  */\n\n          gl_list_free (mset->elem_list);\n          mset->elem_list = list;\n          return NULL;\n        }\n\n      /* We don't want the memory used by the element to be disposed\n         when the old list gets destroyed.  The generic element\n         disposal function always checks if the data is NULL before\n         invoking the corresponding disp_fn callback.  */\n\n      elem->data = NULL;\n    }\n  gl_list_iterator_free (&iter);\n\n  /* Destroy the memory used by the old list, but removing the\n     dispose_fn callbacks first for the proper types in order to avoid\n     the disposal of the elements!.  */\n\n  gl_list_free (list);\n\n  return mset;\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "rec_mset_t"
      ]
    },
    "rec_mset_type_p": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "bool\nrec_mset_type_p (rec_mset_t mset,\n                 rec_mset_type_t type)\n{\n  return type < mset->ntypes;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_mset_register_type": {
      "start_point": [
        291,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "rec_mset_type_t\nrec_mset_register_type (rec_mset_t mset,\n                        char *name,\n                        rec_mset_disp_fn_t disp_fn,\n                        rec_mset_equal_fn_t equal_fn,\n                        rec_mset_dup_fn_t dup_fn,\n                        rec_mset_compare_fn_t compare_fn)\n{\n  rec_mset_type_t new_type;\n\n  new_type = mset->ntypes++;\n  mset->count[new_type] = 0;\n  mset->name[new_type] = strdup (name);\n  mset->disp_fn[new_type] = disp_fn;\n  mset->equal_fn[new_type] = equal_fn;\n  mset->dup_fn[new_type] = dup_fn;\n  mset->compare_fn[new_type] = compare_fn;\n\n  return new_type;\n}",
      "lines": 20,
      "depth": 7,
      "decorators": [
        "rec_mset_type_t"
      ]
    },
    "rec_mset_count": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "size_t\nrec_mset_count (rec_mset_t mset,\n                rec_mset_type_t type)\n{\n  return mset->count[type];\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "rec_mset_get_at": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "void *\nrec_mset_get_at (rec_mset_t mset,\n                 rec_mset_type_t type,\n                 size_t position)\n{\n  void *result;\n  rec_mset_elem_t elem;\n\n  if ((position < 0) || (position >= mset->count[type]))\n    {\n      /* Invalid position.  */\n      return NULL;\n    }\n\n  if (type == MSET_ANY)\n    {\n      /* An element of any type was requested.  Simply call the gnulib\n         list get_at function, that will use the most efficient way to\n         retrieve the element.  */\n\n      elem = (rec_mset_elem_t) gl_list_get_at (mset->elem_list,\n                                               position);\n\n    }\n  else\n    {\n      /* Iterate on the elements in the gnulib list until the\n         POSITIONth element of the specified type is found.  */\n\n      rec_mset_elem_t cur_elem;\n      gl_list_node_t node;\n      gl_list_iterator_t iter; \n      int count[MAX_NTYPES];\n      int i = 0;\n\n      elem = NULL;\n      for (i = 0; i < MAX_NTYPES; i++)\n        {\n          count[i] = 0;\n        }\n      \n      iter = gl_list_iterator (mset->elem_list);\n      while (gl_list_iterator_next (&iter, (const void **) &cur_elem, &node))\n        {\n          if ((type == MSET_ANY)\n              || ((type == cur_elem->type) && (count[cur_elem->type] == position)))\n            {\n              elem = cur_elem;\n              break;\n            }\n          else\n            {\n              count[cur_elem->type]++;\n              count[0]++;\n            }\n        }\n    }\n\n  if (elem)\n    {\n      result = elem->data;\n    }\n  else\n    {\n      result = NULL;\n    }\n\n  return result;\n}",
      "lines": 69,
      "depth": 16,
      "decorators": [
        "void",
        "*\nrec_mset_get_at (rec_mset_t mset,\n                 rec_mset_type_t type,\n                 size_t position)",
        "*"
      ]
    },
    "rec_mset_remove_at": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "bool\nrec_mset_remove_at (rec_mset_t mset,\n                    rec_mset_type_t type,\n                    size_t position)\n{\n  rec_mset_elem_t elem;\n  void *data;\n  bool removed = false;\n\n  if (mset->count[type] > 0)\n    {\n      if (position < 0)\n        {\n          position = 0;\n        }\n      if (position >= mset->count[type])\n        {\n          position = mset->count[type] - 1;\n        }\n\n      data = rec_mset_get_at (mset, type, position);\n      elem = rec_mset_search (mset, data);\n      if (rec_mset_remove_elem (mset, elem))\n        {\n          removed = true;\n        }\n    }\n\n  return removed;\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_mset_insert_at": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        476,
        1
      ],
      "content": "rec_mset_elem_t\nrec_mset_insert_at (rec_mset_t mset,\n                    rec_mset_type_t type,\n                    void *data,\n                    size_t position)\n{\n  rec_mset_elem_t elem = NULL;\n  gl_list_node_t node;\n\n  node = NULL;\n\n  /* Create the mset element to insert in the gl_list, returning NULL\n     if there is no enough memory.  */\n  \n  elem = rec_mset_elem_new (mset, type, data);\n  if (!elem)\n    {\n      return NULL;\n    }\n\n  /* Insert the element at the proper place in the list.  */\n\n  if (position < 0)\n    {\n      node = gl_list_nx_add_first (mset->elem_list,\n                                   (void *) elem);\n    }\n  else if (position >= mset->count[0])\n    {\n      node = gl_list_nx_add_last (mset->elem_list,\n                                  (void *) elem);\n    }\n  else\n    {\n      node = gl_list_nx_add_at (mset->elem_list,\n                                position,\n                                (void *) elem);\n    }\n\n  if (node == NULL)\n    {\n      rec_mset_elem_destroy (elem);\n      elem = NULL;\n    }\n  else\n    {\n      elem->list_node = node;\n\n      mset->count[0]++;\n      if (elem->type != MSET_ANY)\n        {\n          mset->count[elem->type]++;\n        }\n    }\n\n  return elem;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_append": {
      "start_point": [
        478,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "rec_mset_elem_t\nrec_mset_append (rec_mset_t mset,\n                 rec_mset_type_t elem_type,\n                 void *data,\n                 rec_mset_type_t type)\n{\n  return rec_mset_insert_at (mset,\n                             elem_type,\n                             data,\n                             rec_mset_count (mset, type));\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_remove_elem": {
      "start_point": [
        490,
        0
      ],
      "end_point": [
        508,
        1
      ],
      "content": "bool\nrec_mset_remove_elem (rec_mset_t mset,\n                      rec_mset_elem_t elem)\n{\n  rec_mset_type_t type = elem->type;\n  bool res = gl_list_remove_node (mset->elem_list, elem->list_node);\n  if (res)\n    {\n      /* Update statistics.  */\n\n      mset->count[type]--;\n      if (type != MSET_ANY)\n        {\n          mset->count[MSET_ANY]--;\n        }\n    }\n  \n  return res;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_mset_insert_after": {
      "start_point": [
        510,
        0
      ],
      "end_point": [
        567,
        1
      ],
      "content": "rec_mset_elem_t\nrec_mset_insert_after (rec_mset_t mset,\n                       rec_mset_type_t type,\n                       void *data,\n                       rec_mset_elem_t elem)\n{\n  rec_mset_elem_t new_elem;\n  gl_list_node_t node;\n\n  /* Create the mset element to insert in the gl_list, returning NULL\n     if there is no enough memory.  */\n\n  new_elem = rec_mset_elem_new (mset, type, data);\n  if (!new_elem)\n    {\n      return NULL;\n    }\n\n  /* Find the requested place where to insert the new element.  If\n     ELEM is not found in the multi-set then the new element is\n     appended to the multi-set.  */\n\n  node = gl_list_search (mset->elem_list, (void *) elem);\n  if (node)\n    {\n      node = gl_list_nx_add_after (mset->elem_list,\n                                   node,\n                                   (void *) new_elem);\n      if (!node)\n        {\n          /* Out of memory.  */\n          rec_mset_elem_destroy (new_elem);\n          return NULL;\n        }\n\n      new_elem->list_node = node;\n\n      mset->count[0]++;\n      if (new_elem->type != MSET_ANY)\n        {\n          mset->count[new_elem->type]++;\n        }\n    }\n  else\n    {\n      node = gl_list_nx_add_last (mset->elem_list, (void *) elem);\n      if (!node)\n        {\n          /* Out of memory.  */\n          rec_mset_elem_destroy (new_elem);\n          return NULL;\n        }\n\n      new_elem->list_node = node;\n    }\n\n  return new_elem;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_search": {
      "start_point": [
        569,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "rec_mset_elem_t\nrec_mset_search (rec_mset_t mset,\n                 void *data)\n{\n  rec_mset_elem_t result = NULL;\n  rec_mset_elem_t elem;\n  gl_list_iterator_t iter;\n\n  iter = gl_list_iterator (mset->elem_list);\n  while (gl_list_iterator_next (&iter, (const void **) &elem, NULL))\n    {\n      if (elem->data == data)\n        {\n          result = elem;\n          break;\n        }\n    }\n\n  gl_list_iterator_free (&iter);\n\n  return result;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_iterator": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "rec_mset_iterator_t\nrec_mset_iterator (rec_mset_t mset)\n{\n  gl_list_iterator_t  list_iter;\n  rec_mset_iterator_t mset_iter;\n\n  /* Fill the mset iterator structure.  Note that the list_iter field\n     of the mset iterator must have the same size and structure than\n     the gl_list_iterator_t structure.  */\n\n  mset_iter.mset = mset;\n\n  list_iter = gl_list_iterator (mset->elem_list);  \n  mset_iter.list_iter = rec_mset_iter_gl2mset (list_iter);\n\n  return mset_iter;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "rec_mset_iterator_t"
      ]
    },
    "rec_mset_iterator_next": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "bool\nrec_mset_iterator_next (rec_mset_iterator_t *iterator,\n                        rec_mset_type_t type,\n                        const void **data,\n                        rec_mset_elem_t *elem)\n{\n  bool found = true;\n  rec_mset_elem_t mset_elem;\n  gl_list_iterator_t list_iter;\n  gl_list_node_t list_node;\n\n  /* Extract the list iterator from the multi-set iterator.  */\n\n  list_iter = rec_mset_iter_mset2gl (iterator->list_iter);\n\n  /* Advance the list iterator until an element of the proper type is\n     found.  */\n\n  while ((found = gl_list_iterator_next (&list_iter, (const void**) &mset_elem, &list_node))\n         && (type != 0) && (mset_elem->type != type));\n\n  if (found)\n    {\n      /* Update the multi-set iterator and set both DATA and ELEM.  */\n      \n      iterator->list_iter = rec_mset_iter_gl2mset (list_iter);\n      if (data)\n        *data = mset_elem->data;\n      if (elem)\n        {\n          mset_elem->list_node = list_node;\n          *elem = mset_elem;\n        }\n    }\n\n  return found;\n}",
      "lines": 37,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_mset_iterator_free": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        659,
        1
      ],
      "content": "void\nrec_mset_iterator_free (rec_mset_iterator_t *iterator)\n{\n  gl_list_iterator_t list_iter;\n\n  /* Extract the list iterator, free it and copy it back to the mset\n     iterator.  */\n\n  list_iter = rec_mset_iter_mset2gl (iterator->list_iter);\n  gl_list_iterator_free (&list_iter);\n  iterator->list_iter = rec_mset_iter_gl2mset (list_iter);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rec_mset_elem_type": {
      "start_point": [
        661,
        0
      ],
      "end_point": [
        665,
        1
      ],
      "content": "int\nrec_mset_elem_type (rec_mset_elem_t elem)\n{\n  return elem->type;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_mset_elem_set_type": {
      "start_point": [
        667,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "void\nrec_mset_elem_set_type (rec_mset_elem_t elem,\n                        rec_mset_type_t type)\n{\n  elem->mset->count[elem->type]--;\n  elem->type = type;\n  elem->mset->count[type]++;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rec_mset_elem_data": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        680,
        1
      ],
      "content": "void *\nrec_mset_elem_data (rec_mset_elem_t elem)\n{\n  return elem->data;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void",
        "*\nrec_mset_elem_data (rec_mset_elem_t elem)",
        "*"
      ]
    },
    "rec_mset_elem_set_data": {
      "start_point": [
        682,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "void\nrec_mset_elem_set_data (rec_mset_elem_t elem,\n                        void *data)\n{\n  elem->data = data;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_mset_elem_equal_p": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "bool\nrec_mset_elem_equal_p (rec_mset_elem_t elem1,\n                       rec_mset_elem_t elem2)\n{\n  return rec_mset_elem_equal_fn ((void *) elem1,\n                                 (void *) elem2);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_mset_elem_dup_data": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "void *\nrec_mset_elem_dup_data (rec_mset_elem_t elem)\n{\n  return elem->mset->dup_fn[elem->type] (elem->data);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void",
        "*\nrec_mset_elem_dup_data (rec_mset_elem_t elem)",
        "*"
      ]
    },
    "rec_mset_dump": {
      "start_point": [
        703,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "void\nrec_mset_dump (rec_mset_t mset)\n{\n  gl_list_iterator_t iter;\n  gl_list_node_t node;\n  rec_mset_elem_t elem;\n  int i;\n  \n  printf (\"MSET:\\n\");\n  printf (\"  ntypes: %d\\n\", mset->ntypes);\n\n  for (i = 0; i < mset->ntypes; i++)\n    {\n      printf(\"  type %d:\\n\", i);\n      printf(\"    count:     %zd\\n\", mset->count[i]);\n      printf(\"    disp_fn:   %p\\n\", mset->disp_fn[i]);\n      printf(\"    equal_fn:  %p\\n\", mset->equal_fn[i]);\n      printf(\"    dup_fn:    %p\\n\", mset->dup_fn[i]);\n    }\n\n  printf(\"  nodes:\\n\");\n  iter = gl_list_iterator (mset->elem_list);\n  while (gl_list_iterator_next (&iter, (const void **) &elem, &node))\n    {\n      printf(\"    node=%p elem=%p elem->type=%d elem->data=%p contained=%p\\n\", node, elem,\n             elem->type, elem->data, elem->mset);\n      i++;\n    }\n\n  printf(\"END MSET\\n\");\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_mset_add_sorted": {
      "start_point": [
        735,
        0
      ],
      "end_point": [
        772,
        1
      ],
      "content": "rec_mset_elem_t\nrec_mset_add_sorted (rec_mset_t mset,\n                     rec_mset_type_t type,\n                     void *data)\n{\n  rec_mset_elem_t elem;\n  gl_list_node_t node;\n\n  /* Create the mset element to insert in the gl_list, returning NULL\n     if there is no enough memory.  */\n\n  elem = rec_mset_elem_new (mset, type, data);\n  if (!elem)\n    {\n      return NULL;\n    }\n\n  /* Insert the element at the proper place in the list.  */\n\n  node = gl_sortedlist_nx_add (mset->elem_list,\n                               rec_mset_elem_compare_fn,\n                               (void *) elem);\n  if (!node)\n    {\n      rec_mset_elem_destroy (elem);\n      return NULL;\n    }\n\n  elem->list_node = node;\n\n  mset->count[0]++;\n  if (elem->type != MSET_ANY)\n    {\n      mset->count[elem->type]++;\n    }\n\n  return elem;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_init": {
      "start_point": [
        778,
        0
      ],
      "end_point": [
        786,
        1
      ],
      "content": "static void\nrec_mset_init (rec_mset_t mset)\n{\n  /* Initialize the mset structure so it can be safely passed to\n     rec_mset_destroy even if its contents are not completely\n     initialized with real values.  */\n\n  memset (mset, 0 /* NULL */, sizeof (struct rec_mset_s));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_mset_elem_equal_fn": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        806,
        1
      ],
      "content": "static bool\nrec_mset_elem_equal_fn (const void *e1,\n                        const void *e2)\n{\n  rec_mset_elem_t elem1;\n  rec_mset_elem_t elem2;\n\n  elem1 = (rec_mset_elem_t) e1;\n  elem2 = (rec_mset_elem_t) e2;\n\n  if ((elem1->mset != elem2->mset)\n      || (elem1->type != elem2->type))\n    {\n      return false;\n    }\n\n  return (elem1->mset->equal_fn[elem1->type]) (elem1->data,\n                                               elem2->data);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_mset_elem_dispose_fn": {
      "start_point": [
        808,
        0
      ],
      "end_point": [
        815,
        1
      ],
      "content": "static void\nrec_mset_elem_dispose_fn (const void *e)\n{\n  rec_mset_elem_t elem;\n\n  elem = (rec_mset_elem_t) e;\n  rec_mset_elem_destroy (elem);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_mset_elem_compare_fn": {
      "start_point": [
        817,
        0
      ],
      "end_point": [
        836,
        1
      ],
      "content": "static int\nrec_mset_elem_compare_fn (const void *e1,\n                          const void *e2)\n{\n  int result = 0;\n  rec_mset_elem_t elem1;\n  rec_mset_elem_t elem2;\n\n  elem1 = (rec_mset_elem_t) e1;\n  elem2 = (rec_mset_elem_t) e2;\n\n  if (elem1->mset->compare_fn)\n    {\n      result = (elem1->mset->compare_fn[elem1->type]) (elem1->data,\n                                                       elem2->data,\n                                                       elem2->type);\n    }\n\n  return result;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_mset_iter_gl2mset": {
      "start_point": [
        838,
        0
      ],
      "end_point": [
        852,
        1
      ],
      "content": "static rec_mset_list_iter_t\nrec_mset_iter_gl2mset (gl_list_iterator_t list_iter)\n{\n  rec_mset_list_iter_t mset_iter;\n\n  mset_iter.vtable = (void *) list_iter.vtable;\n  mset_iter.list   = (void *) list_iter.list;\n  mset_iter.count  = list_iter.count;\n  mset_iter.p      = list_iter.p;\n  mset_iter.q      = list_iter.q;\n  mset_iter.i      = list_iter.i;\n  mset_iter.j      = list_iter.j;\n\n  return mset_iter;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "rec_mset_list_iter_t"
      ]
    },
    "rec_mset_iter_mset2gl": {
      "start_point": [
        854,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static gl_list_iterator_t\nrec_mset_iter_mset2gl (rec_mset_list_iter_t mset_iter)\n{\n  gl_list_iterator_t list_iter;\n\n  list_iter.vtable = (const struct gl_list_implementation *) mset_iter.vtable;\n  list_iter.list  = (gl_list_t) mset_iter.list;\n  list_iter.count = mset_iter.count;\n  list_iter.p     = mset_iter.p;\n  list_iter.q     = mset_iter.q;\n  list_iter.i     = mset_iter.i;\n  list_iter.j     = mset_iter.j;\n\n  return list_iter;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "gl_list_iterator_t"
      ]
    },
    "rec_mset_elem_new": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        892,
        1
      ],
      "content": "static rec_mset_elem_t\nrec_mset_elem_new (rec_mset_t mset,\n                   rec_mset_type_t type,\n                   void *data)\n{\n  rec_mset_elem_t new;\n\n  if (type >= mset->ntypes)\n    {\n      return NULL;\n    }\n\n  new = malloc (sizeof (struct rec_mset_elem_s));\n  if (new)\n    {\n      new->type = type;\n      new->data = data;\n      new->mset = mset;\n      new->list_node = NULL;\n    }\n\n  return new;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "rec_mset_elem_t"
      ]
    },
    "rec_mset_elem_destroy": {
      "start_point": [
        894,
        0
      ],
      "end_point": [
        910,
        1
      ],
      "content": "static void\nrec_mset_elem_destroy (rec_mset_elem_t elem)\n{\n  if (elem)\n    {\n      /* Dispose the data stored in the element if a disposal callback\n         function was configured by the user.  The callback is never\n         invoked if the stored data is NULL.  */\n      \n      if (elem->data && elem->mset->disp_fn[elem->type])\n        {\n          elem->mset->disp_fn[elem->type] (elem->data);\n        }\n      \n      free (elem);\n    }\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-parser.c": {
    "rec_parser_new": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "rec_parser_t\nrec_parser_new (FILE *in,\n                const char *source)\n{\n  rec_parser_t parser;\n\n  parser = malloc (sizeof (struct rec_parser_s));\n  if (parser != NULL)\n    {\n      parser->in_file = in;\n      parser->in_buffer = NULL;\n      parser->in_size = 0;\n\n      if (!rec_parser_init_common (parser, source))\n        {\n          free (parser);\n          parser = NULL;\n        }\n    }\n\n  return parser;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "rec_parser_t"
      ]
    },
    "rec_parser_new_str": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "rec_parser_t\nrec_parser_new_str (const char *buffer,\n                    const char *source)\n{\n  return rec_parser_new_mem (buffer, strlen (buffer), source);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "rec_parser_t"
      ]
    },
    "rec_parser_new_mem": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "rec_parser_t\nrec_parser_new_mem (const char *buffer,\n                    size_t size,\n                    const char *source)\n{\n  rec_parser_t parser;\n\n  parser = malloc (sizeof (struct rec_parser_s));\n  if (parser != NULL)\n    {\n      parser->in_buffer = buffer;\n      parser->in_size = size;\n      parser->in_file = NULL;\n\n      if (!rec_parser_init_common (parser, source))\n        {\n          free (parser);\n          parser = NULL;\n        }\n    }\n\n  return parser;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "rec_parser_t"
      ]
    },
    "rec_parser_destroy": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nrec_parser_destroy (rec_parser_t parser)\n{\n  if (parser)\n    {\n      free (parser->source);\n      free (parser);\n    }\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_parser_eof": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "bool\nrec_parser_eof (rec_parser_t parser)\n{\n  return parser->eof;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "rec_parser_error": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "bool\nrec_parser_error (rec_parser_t parser)\n{\n  return (parser->error != REC_PARSER_NOERROR);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_parser_perror": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\nrec_parser_perror (rec_parser_t parser,\n                   const char *fmt,\n                   ...)\n{\n  va_list ap;\n  char *number_str;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  fputs (\": \", stderr);\n  number_str = NULL;  /* asprintf does the allocation */\n  if (asprintf (&number_str, \"%zu\", parser->line) != -1)\n    {\n      fputs (number_str, stderr);\n      free (number_str);\n    }\n  fputs (\": error: \", stderr);\n  fputs (gettext (rec_parser_error_strings[parser->error]), stderr);\n  fputc ('\\n', stderr);\n\n  va_end (ap);\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_parse_field_name": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "bool\nrec_parse_field_name (rec_parser_t parser,\n                      char **fname)\n{\n  bool ret = true;\n  int ci;\n  size_t str_size;\n  char c;\n  rec_buf_t buf;\n\n  /* Sanity check */\n  if (rec_parser_eof (parser)\n      || rec_parser_error (parser))\n    {\n      return false;\n    }\n\n  buf = rec_buf_new (fname, &str_size);\n  if (!buf)\n    {\n      /* Out of memory */\n      parser->error = REC_PARSER_ENOMEM;\n      return false;\n    }\n\n  /* The syntax of a field name is described by the following regexp:\n   *\n   * [a-zA-Z%][a-zA-Z0-9_]*:\n   */\n\n  /* [a-zA-Z%] */\n  ci = rec_parser_getc (parser);\n  if (ci == EOF)\n    {\n      ret = false;\n    }\n  else\n    {\n      c = (char) ci;\n\n      if ((rec_parser_letter_p (c))\n          || (c == '%'))\n        {\n          if (rec_buf_putc (c, buf) == EOF)\n            {\n              /* Out of memory */\n              parser->error = REC_PARSER_ENOMEM;\n              return false;\n            }\n        }\n      else\n        {\n          /* Parse error */\n          parser->error = REC_PARSER_EFNAME;\n          ret = false;\n        }\n    }\n\n  /* [a-zA-Z0-9_]* */\n  if (ret)\n    {\n      while ((ci = rec_parser_getc (parser)) != EOF)\n        {\n          c = (char) ci;\n\n          if (rec_parser_letter_p (c)\n              || rec_parser_digit_p (c)\n              || (c == '_'))\n            {\n              if (rec_buf_putc (c, buf) == EOF)\n                {\n                  /* Out of memory */\n                  parser->error = REC_PARSER_ENOMEM;\n                  return false;\n                }\n              if (parser->error > 0)\n                {\n                  /* error was set by ADD_TO_STR */\n                  break;\n                }\n            }\n          else if (c == ':')\n            {\n              /* End of token.  Consume the ':' and report success */\n              break;\n            }\n          else\n            {\n              /* Parse error */\n              parser->error = REC_PARSER_EFNAME;\n              ret = false;\n              break;\n            }\n        }\n\n      if (parser->eof)\n        {\n          parser->error = REC_PARSER_EFNAME;\n          ret = false;\n        }\n    }\n\n  rec_buf_close (buf);\n\n  if (!ret)\n    {\n      free (*fname);\n    }\n  else\n    {\n      /* Field names ends with:\n       *\n       * - A blank character or\n       * - A tab or\n       * - A newline or\n       * - The end of the file\n       *\n       * Note that if the field name ends with a newline it is\n       * pushed back to the input stream, since (unlike a blank\n       * character) it will be part of the field value.\n       */\n\n      ci = rec_parser_getc (parser);\n      if (ci != EOF)\n        {\n          c = (char) ci;\n          if ((c == ' ') || (c == '\\t'))\n            {\n              parser->error = REC_PARSER_NOERROR;\n            }\n          else if (c == '\\n')\n            {\n              parser->error = REC_PARSER_NOERROR;\n              rec_parser_ungetc (parser, c);\n            }\n          else\n            {\n              rec_parser_ungetc (parser, c);\n            }\n        }\n    }\n  \n  return ret;\n}",
      "lines": 144,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "rec_parser_reset": {
      "start_point": [
        357,
        0
      ],
      "end_point": [
        363,
        1
      ],
      "content": "void\nrec_parser_reset (rec_parser_t parser)\n{\n  parser->eof = false;\n  parser->error = REC_PARSER_NOERROR;\n  parser->p = parser->in_buffer;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_parse_field": {
      "start_point": [
        365,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "bool\nrec_parse_field (rec_parser_t parser,\n                 rec_field_t *field)\n{\n  bool ret;\n  rec_field_t new;\n  char *field_name;\n  char *field_value;\n  size_t location;\n  size_t char_location;\n\n  /* Sanity check */\n  if (rec_parser_eof (parser)\n      || rec_parser_error (parser))\n    {\n      return false;\n    }\n\n  location = parser->line;\n  char_location = parser->character;\n  if (char_location != 0)\n    {\n      char_location++;\n    }\n\n  ret = rec_parse_field_name (parser, &field_name);\n  if (ret)\n    {\n      ret = rec_parse_field_value (parser, &field_value);\n\n      if (ret)\n        {\n          new = rec_field_new (field_name,\n                               field_value);\n\t  if (new == NULL)\n\t    return false;\n\n          rec_field_set_source (new, parser->source);\n          rec_field_set_location (new, location);\n          rec_field_set_char_location (new, char_location);\n          *field = new;\n\n          free (field_value);\n        }\n\n      free (field_name);\n    }\n\n  return ret;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_parse_record": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "bool\nrec_parse_record (rec_parser_t parser,\n                  rec_record_t *record)\n{\n  rec_record_t new;\n  rec_field_t field;\n  bool ret;\n  int ci;\n  char c;\n  rec_comment_t comment;\n  size_t char_location;\n\n  /* Sanity check */\n  if (rec_parser_eof (parser)\n      || rec_parser_error (parser))\n    {\n      return false;\n    }\n\n  new = rec_record_new ();\n  if (!new)\n    {\n      parser->error = REC_PARSER_ENOMEM;\n      return false;\n    }\n\n  /* Localize the potential record.  */\n  rec_record_set_source (new, parser->source);\n  rec_record_set_location (new, parser->line);\n  char_location = parser->character;\n  if (char_location != 0)\n    {\n      char_location++;\n    }\n  rec_record_set_char_location (new, char_location);\n\n  /* A record is a list of mixed fields and comments, containing at\n   * least one field starting it:\n   *\n   *  FIELD (FIELD|COMMENT)*\n   */\n  if (rec_parse_field (parser, &field))\n    {\n      /* Add the field to the record */\n      rec_mset_append (rec_record_mset (new), MSET_FIELD, (void *) field, MSET_ANY);\n    }\n  else\n    {\n      /* Expected a field.  */\n      parser->error = REC_PARSER_EFIELD;\n      rec_record_destroy (new);\n      *record = NULL;\n      return false;\n    }\n\n  ret = true;\n  while ((ci = rec_parser_getc (parser)) != EOF)\n    {\n      c = (char) ci;\n\n      if (c == '#')\n        {\n          rec_parser_ungetc (parser, ci);\n          if (rec_parse_comment (parser, &comment))\n            {\n              /* Add the comment to the record.  */\n              rec_mset_append (rec_record_mset (new), MSET_COMMENT, (void *) comment, MSET_ANY);\n            }\n        }\n      else if ((c == ' ') || (c == '\\t'))\n        {\n          /* A line composed just by blanks acts like an end of record\n             separator. */\n\n          while ((ci != EOF) && ((c == ' ') || (c == '\\t')))\n            {\n              ci = rec_parser_getc (parser);\n              c = (char) ci;\n            }\n\n          if ((ci == EOF) || (c == '\\n'))\n            {\n              /* End of record */\n              break;\n            }\n          else\n            {\n              /* Parse error: field expected */\n              parser->error = REC_PARSER_EFIELD;\n              ret = false;\n              break;\n            }\n        }\n      else if (c == '\\n')\n        {\n          /* End of record */\n          break;\n        }\n      else\n        {\n          /* Try to parse a field */\n          rec_parser_ungetc (parser, ci);\n          if (rec_parse_field (parser, &field))\n            {\n              /* Add the field to the record */\n              rec_mset_append (rec_record_mset (new), MSET_FIELD, (void *) field, MSET_ANY);\n            }\n          else\n            {\n              /* Parse error: field expected */\n              parser->error = REC_PARSER_EFIELD;\n              ret = false;\n              break;\n            }\n        }\n    }\n\n  if (ret)\n    {\n      *record = new;\n    }\n  else\n    {\n      rec_record_destroy (new);\n      *record = NULL;\n    }\n\n  return ret;\n}",
      "lines": 129,
      "depth": 17,
      "decorators": [
        "bool"
      ]
    },
    "rec_parse_rset": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        656,
        1
      ],
      "content": "bool\nrec_parse_rset (rec_parser_t parser,\n                rec_rset_t *rset)\n{\n  bool ret;\n  int ci;\n  char c;\n  rec_rset_t new;\n  rec_record_t record;\n  rec_comment_t comment;\n  size_t comments_added = 0;\n\n  ret = false;\n\n  if ((new = rec_rset_new ()) == NULL)\n    {\n      /* Out of memory */\n      parser->error = REC_PARSER_ENOMEM;\n      return false;\n    }\n\n  /* Set the descriptor for this record set.  */\n  rec_rset_set_descriptor (new, parser->prev_descriptor);\n  parser->prev_descriptor = NULL;\n\n  while ((ci = rec_parser_getc (parser)) != EOF)\n    {\n      c = (char) ci;\n\n      /* Skip newline characters and blanks.  */\n      if ((c == '\\n') || (c == ' ') || (c == '\\t'))\n        {\n          continue;\n        }\n      /* Skip comments */\n      else if (c == '#')\n        {\n          rec_parser_ungetc (parser, c);\n          rec_parse_comment (parser, &comment);\n\n          /* Add the comment to the record set.  */\n          rec_mset_append (rec_rset_mset (new), MSET_COMMENT, (void *) comment, MSET_ANY);\n\n          comments_added++;\n        }\n      else\n        {\n          /* Try to parse a record */\n          rec_parser_ungetc (parser, c);\n          if (rec_parse_record (parser, &record))\n            {\n              /* Check if the parsed record is a descriptor.  In that\n                 case, set it as the previous descriptor in the parser\n                 state and stop parsing.  In the special case where\n                 the previous descriptor is NULL (we did not find a\n                 descriptor yet) then record the position of the\n                 descriptor as well.\n\n                 Otherwise, add the record to the current record\n                 set. */\n              if (rec_record_field_p (record, FNAME(REC_FIELD_REC)))\n                {\n                  if ((rec_rset_num_records (new) == 0) &&\n                      (!rec_rset_descriptor (new)))\n                    {\n                      /* Special case: the first record found in the\n                         input stream is a descriptor. */\n                      rec_rset_set_descriptor (new, record);\n                      rec_rset_set_descriptor_pos (new, comments_added);\n                    }\n                  else\n                    {\n                      parser->prev_descriptor = record;\n                      ret = true;\n                      break;\n                    }\n                }\n              else\n                {\n                  rec_record_set_container (record, new);\n                  rec_mset_append (rec_rset_mset (new), MSET_RECORD, (void *) record, MSET_ANY);\n                }\n            }\n          else\n            {\n              /* Parse error */\n              parser->error = REC_PARSER_ERECORD;\n              break;\n            }\n        }\n    }\n\n  if ((parser->error == REC_PARSER_NOERROR)\n      && (rec_rset_descriptor (new)\n          || (rec_rset_num_records (new) > 0)))\n    {\n      ret = true;\n    }\n\n  if (ret)\n    {\n      *rset = new;\n    }\n  else\n    {\n      rec_rset_destroy (new);\n      *rset = NULL;\n    }\n\n  return ret;\n}",
      "lines": 111,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "rec_parse_db": {
      "start_point": [
        658,
        0
      ],
      "end_point": [
        700,
        1
      ],
      "content": "bool\nrec_parse_db (rec_parser_t parser,\n              rec_db_t *db)\n{\n  bool ret;\n  rec_rset_t rset;\n  rec_db_t new;\n\n  ret = true;\n\n  new = rec_db_new ();\n  if (!new)\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  while (rec_parse_rset (parser, &rset))\n    {\n      /* Add the rset into the database.  */\n      if (!rec_db_insert_rset (new,\n                               rset,\n                               rec_db_size (new)))\n        {\n          /* Parse error: out of memory.  */\n          parser->error = REC_PARSER_ENOMEM;\n          ret = false;\n          break;\n        }\n    }\n\n  if (!rec_parser_eof (parser))\n    {\n      ret = false;\n    }\n\n  if (ret)\n    {\n      *db = new;\n    }\n\n  return ret;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_parse_field_name_str": {
      "start_point": [
        702,
        0
      ],
      "end_point": [
        747,
        1
      ],
      "content": "char *\nrec_parse_field_name_str (const char *str)\n{\n  rec_parser_t parser;\n  char *field_name = NULL;\n  char *str2;\n  size_t str_size;\n\n  /* Make sure the input string ends with a colon character.  */\n  str_size = strlen (str);\n  str2 = malloc (str_size + 2);\n  if (!str2)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n\n  memcpy (str2, str, str_size);\n  if (str_size > 0 && str2[str_size - 1] == ':')\n    {\n      str2[str_size] = '\\0';\n    }\n  else\n    {\n      str2[str_size] = ':';\n      str2[str_size + 1] = '\\0';\n    }\n  \n  parser = rec_parser_new_str (str2, \"dummy\");\n  if (!rec_parse_field_name (parser, &field_name))\n    {\n      field_name = NULL;\n    }\n\n  if (!rec_parser_eof (parser))\n    {\n      /* There is additional stuff after the field name.  */\n      free (field_name);\n      field_name = NULL;\n    }\n\n  rec_parser_destroy (parser);\n  free (str2);\n\n  return field_name;\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "char",
        "*\nrec_parse_field_name_str (const char *str)",
        "*"
      ]
    },
    "rec_parse_record_str": {
      "start_point": [
        749,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "rec_record_t\nrec_parse_record_str (const char *str)\n{\n  rec_parser_t parser;\n  rec_record_t record;\n\n  record = NULL;\n  parser = rec_parser_new_str (str, \"dummy\");\n  if (parser)\n    {\n      if (!rec_parse_record (parser, &record))\n        {\n          record = NULL;\n        }\n      rec_parser_destroy (parser);\n    }\n\n  return record;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "rec_record_t"
      ]
    },
    "rec_parser_seek": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        799,
        1
      ],
      "content": "bool\nrec_parser_seek (rec_parser_t parser,\n                 size_t line_number,\n                 size_t position)\n{\n  if (parser->in_file)\n    {\n      if (fseek (parser->in_file, position, SEEK_SET))\n        {\n          return false;\n        }\n    }\n  else if (parser->in_buffer)\n    {\n      if (position > parser->in_size)\n        {\n          return false;\n        }\n      parser->p = parser->in_buffer + position;\n    }\n  else\n    {\n      /* This point should not be reached!  */\n      fprintf (stderr, \"rec_parser_seek: no backend in parser. This is a bug.\\\n  Please report it.\");\n      return false;\n    }\n  parser->line = line_number;\n  parser->character = position;\n  return true;\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "rec_parser_tell": {
      "start_point": [
        801,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "long\nrec_parser_tell (rec_parser_t parser)\n{\n  if (parser->in_file)\n    {\n      return ftell (parser->in_file);\n    }\n  else if (parser->in_buffer)\n    {\n      return parser->p - parser->in_buffer;\n    }\n  else\n    {\n      /* This point should not be reached!  */\n      fprintf (stderr, \"rec_parser_seek: no backend in parser. This is a bug.\\\n  Please report it.\");\n      return -1;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "long",
        "long"
      ]
    },
    "rec_parser_getc": {
      "start_point": [
        825,
        0
      ],
      "end_point": [
        872,
        1
      ],
      "content": "static int\nrec_parser_getc (rec_parser_t parser)\n{\n  int ci;\n\n  /* Get the input character depending on the backend used (memory or\n     file).  */\n  if (parser->in_file)\n    {\n      ci = getc (parser->in_file);\n    }\n  else if (parser->in_buffer)\n    {\n      if (parser->p == parser->in_buffer + parser->in_size)\n        {\n          ci = EOF;\n        }\n      else\n        {\n          ci = *(parser->p);\n          parser->p++;\n        }\n    }\n  else\n    {\n      /* This point should not be reached!  */\n      fprintf (stderr, \"rec_parser_getc: no backend in parser. This is a bug.\\\n  Please report it.\");\n      return EOF;\n    }\n\n  /* Manage EOF and update statistics.  */\n\n  if (ci == EOF)\n    {\n      parser->eof = true;\n    }\n  else \n    {\n      parser->character++;\n      if (((char) ci) == '\\n')\n        {\n          parser->line++;\n        }\n    }\n\n  return ci;\n}",
      "lines": 48,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_parser_ungetc": {
      "start_point": [
        874,
        0
      ],
      "end_point": [
        922,
        1
      ],
      "content": "int\nrec_parser_ungetc (rec_parser_t parser,\n                   int ci)\n{\n  int res;\n\n  /* Update statistics.  */\n\n  parser->character--;\n  if (((char) ci) == '\\n')\n    {\n      parser->line--;\n    }\n\n  /* Unread the character, depending on the backend used (memory or\n     file).  */\n\n  if (parser->in_file)\n    {\n      res = ungetc (ci, parser->in_file);\n      if (res != ci)\n        {\n          parser->error = REC_PARSER_EUNGETC;\n        }\n    }\n  else if (parser->in_buffer)\n    {\n      if (parser->p > parser->in_buffer)\n        {\n          res = ci; /* Emulate ungetc. */\n          parser->p--;\n        }\n      else\n        {\n          res = EOF;\n          parser->error = REC_PARSER_EUNGETC;\n        }\n    }\n  else\n    {\n\n      /* This point should not be reached!  */\n      fprintf (stderr, \"rec_parser_ungetc: no backend in parser. This is a bug.\\\n  Please report it.\");\n      return EOF;\n    }\n\n  return res;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rec_parser_digit_p": {
      "start_point": [
        924,
        0
      ],
      "end_point": [
        928,
        1
      ],
      "content": "static bool\nrec_parser_digit_p (char c)\n{\n  return ((c >= '0') && (c <= '9'));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_parser_letter_p": {
      "start_point": [
        930,
        0
      ],
      "end_point": [
        935,
        1
      ],
      "content": "static bool\nrec_parser_letter_p (char c)\n{\n  return (((c >= 'A') && (c <= 'Z'))\n          || ((c >= 'a') && (c <= 'z')));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_expect": {
      "start_point": [
        937,
        0
      ],
      "end_point": [
        976,
        1
      ],
      "content": "static bool\nrec_expect (rec_parser_t parser,\n            const char *str)\n{\n  size_t str_size;\n  size_t counter;\n  bool found;\n  int ci;\n  char c;\n\n  found = true;\n  str_size = strlen (str);\n\n  for (counter = 0;\n       counter < str_size;\n       counter++)\n    {\n      ci = rec_parser_getc (parser);\n      if (ci == EOF)\n        {\n          /* EOF */\n          found = false;\n          parser->eof = true;\n          break;\n        }\n      else\n        {\n          c = (char) ci;\n          if (c != str[counter])\n            {\n              /* Not match */\n              rec_parser_ungetc (parser, ci);\n              found = false;\n              break;\n            }\n        }\n    }\n\n  return found;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_parse_field_value": {
      "start_point": [
        978,
        0
      ],
      "end_point": [
        1164,
        1
      ],
      "content": "static bool\nrec_parse_field_value (rec_parser_t parser,\n                       char **str)\n{\n  bool ret;\n  int ci, ci2;\n  char c, c2;\n  size_t str_size;\n  bool prev_newline;\n  rec_buf_t buf;\n\n  /* Sanity check */\n  if (rec_parser_eof (parser)\n      || rec_parser_error (parser))\n    {\n      return false;\n    }\n\n  c = '\\0';\n  prev_newline = false;\n  ret = true;\n  buf = rec_buf_new (str, &str_size);\n  if (!buf)\n    {\n      /* Out of memory */\n      parser->error = REC_PARSER_ENOMEM;\n      return false;\n    }\n  \n  /* A field value is a sequence of zero or more ascii codes finished\n   * with a newline character.\n   *\n   *  \\$ is translated to nothing.\n   *  $+ ? is translated to $.\n   */\n  while ((ci = rec_parser_getc (parser)) != EOF)\n    {\n      c = (char) ci;\n\n      if ((prev_newline) && (c != '+'))\n        {\n          /* End of value */\n          rec_parser_ungetc (parser, ci);\n          rec_buf_rewind (buf, 1);\n          break;\n        }\n\n      if (c == '\\\\')\n        {\n          ci2 = rec_parser_getc (parser);\n          if (ci2 == EOF)\n            {\n              parser->eof = true;\n              ret = false;\n              break;\n            }\n          else\n            {\n              c2 = (char) ci2;\n              if (c2 == '\\n')\n                {\n                  /* Consume both $\\n chars not adding them to str =>\n                     do nothing here. */\n                }\n              else\n                {\n                  /* Add \\ and put back c2 */\n                  if (rec_buf_putc (c, buf) == EOF)\n                    {\n                      /* Out of memory */\n                      parser->error = REC_PARSER_ENOMEM;\n                      return false;\n                    }\n\n                  if (parser->error > 0)\n                    {\n                      break;\n                    }\n\n                  if (rec_parser_ungetc (parser, ci2)\n                      != ci2)\n                    {\n                      ret = false;\n                      break;\n                    }\n                }\n            }\n\n          prev_newline = false;\n        }\n      else if (c == '+')\n        {\n          if (prev_newline)\n            {\n              /* Reduce \\n+ ? to \\n by ignoring the + ? */\n              ci2 = rec_parser_getc (parser);\n              \n              if (ci2 == EOF)\n                {\n                  parser->eof = true;\n                  ret = false;\n                  break;\n                }\n              else\n                {\n                  c2 = (char) ci2;\n                  /* If the look ahead character is a blank, skip it.\n                     Otherwise put it back in the stream so it will be\n                     processed in the next iteration. */\n                  if (c2 != ' ')\n                    {\n                      if (rec_parser_ungetc (parser, ci2) != ci2)\n                        {\n                          ret = false;\n                          break;\n                        }\n                    }\n                }\n            }\n          else\n            {\n              if (rec_buf_putc (c, buf) == EOF)\n                {\n                  /* Out of memory */\n                  parser->error = REC_PARSER_ENOMEM;\n                  return false;\n                }\n\n              if (parser->error > 0)\n                {\n                  break;\n                }\n            }\n\n          prev_newline = false;\n        }\n      else if (c == '\\n')\n        {\n          if (rec_buf_putc (c, buf) == EOF)\n            {\n              /* Out of memory */\n              parser->error = REC_PARSER_ENOMEM;\n              return false;\n            }\n\n          if (parser->error > 0)\n            {\n              break;\n            }\n          prev_newline = true;\n        }\n      else\n        {\n          if (rec_buf_putc (c, buf) == EOF)\n            {\n              /* Out of memory */\n              parser->error = REC_PARSER_ENOMEM;\n              return false;\n            }\n\n          if (parser->error > 0)\n            {\n              break;\n            }\n          prev_newline = false;\n        }\n    }\n\n  if (ret)\n    {\n      if (rec_parser_eof (parser)\n          && (c == '\\n'))\n        {\n          /* Special case: field just before EOF */\n          rec_buf_rewind (buf, 1);\n        }\n    }\n\n  rec_buf_close (buf);\n\n  if (!ret)\n    {\n      free (*str);\n    }\n\n  return ret;\n}",
      "lines": 187,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_parse_comment": {
      "start_point": [
        1166,
        0
      ],
      "end_point": [
        1231,
        1
      ],
      "content": "static bool\nrec_parse_comment (rec_parser_t parser, rec_comment_t *comment)\n{\n  bool ret;\n  rec_buf_t buf;\n  char *str;\n  size_t str_size;\n  int ci;\n  char c;\n\n  ret = false;\n  buf = rec_buf_new (&str, &str_size);\n\n  /* Comments start at the beginning of line and span until the first\n   * \\n character not followed by a #, or EOF.\n   */\n  if (rec_expect (parser, \"#\"))\n    {\n      while ((ci = rec_parser_getc (parser)) != EOF)\n        {\n          c = (char) ci;\n\n          if (c == '\\n')\n            {\n              if ((ci = rec_parser_getc (parser)) == EOF)\n                {\n                  break;\n                }\n              c = (char) ci;\n\n              if (c != '#')\n                {\n                  rec_parser_ungetc (parser, ci);\n                  break;\n                }\n              else\n                {\n                  c = '\\n';\n                }\n            }\n\n          if (rec_buf_putc (c, buf) == EOF)\n            {\n              /* Out of memory */\n              parser->error = REC_PARSER_ENOMEM;\n              return false;\n            }\n        }\n      \n      ret = true;\n    }\n\n  rec_buf_close (buf);\n\n  if (ret)\n    {\n      *comment = rec_comment_new (str);\n    }\n  else\n    {\n      *comment = NULL;\n    }\n\n  free (str);\n  return ret;\n}",
      "lines": 66,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_parser_init_common": {
      "start_point": [
        1233,
        0
      ],
      "end_point": [
        1258,
        1
      ],
      "content": "static bool\nrec_parser_init_common (rec_parser_t parser,\n                        const char *source)\n{\n  if (source)\n    {\n      parser->source = strdup (source);\n      if (!parser->source)\n        {\n          return false;\n        }\n    }\n  else\n    {\n      parser->source = NULL;\n    }\n\n  parser->eof = false;\n  parser->error = REC_PARSER_NOERROR;\n  parser->line = 1;\n  parser->character = 0;\n  parser->prev_descriptor = NULL;\n  parser->p = parser->in_buffer;\n\n  return true;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-record.c": {
    "rec_record_new": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "rec_record_t\nrec_record_new (void)\n{\n  rec_record_t record;\n\n  record = malloc (sizeof (struct rec_record_s));\n\n  if (record)\n    {\n      rec_record_init (record);\n\n      /* The container pointer is initially NULL, until the client\n         uses it for something else.  */\n      record->container = NULL;\n\n      /* Localization information is not used until the user\n         explicitly sets it.  */\n\n      record->source = NULL;\n      record->location = 0;\n      record->location_str = NULL;\n      record->char_location = 0;\n      record->char_location_str = NULL;\n\n      /* Create the multi-set that will hold the elements of the\n         record.  Note that the order in which the types are\n         registered is significative.  If you change the order please\n         update the MSET_FIELD and MSET_COMMENT constants in\n         rec.h.  */\n\n      record->mset = rec_mset_new ();\n      if (record->mset)\n        {\n          record->field_type = rec_mset_register_type (record->mset,\n                                                       \"field\",\n                                                       rec_record_field_disp_fn,\n                                                       rec_record_field_equal_fn,\n                                                       rec_record_field_dup_fn,\n                                                       NULL);\n\n          record->comment_type = rec_mset_register_type (record->mset,\n                                                         \"comment\",\n                                                         rec_record_comment_disp_fn,\n                                                         rec_record_comment_equal_fn,\n                                                         rec_record_comment_dup_fn,\n                                                         NULL);\n        }\n      else\n        {\n          /* Out of memory.  */\n\n          rec_record_destroy (record);\n          record = NULL;\n        }\n    }\n\n  return record;\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "rec_record_t"
      ]
    },
    "rec_record_destroy": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nrec_record_destroy (rec_record_t record)\n{\n  if (record)\n    {\n      free (record->source);\n      free (record->location_str);\n      free (record->char_location_str);\n      rec_mset_destroy (record->mset);\n      free (record);\n    }\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_record_dup": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "rec_record_t\nrec_record_dup (rec_record_t record)\n{\n  rec_record_t new;\n\n  new = malloc (sizeof (struct rec_record_s));\n  if (new)\n    {\n      rec_record_init (new);\n\n      new->field_type = record->field_type;\n      new->comment_type = record->comment_type;\n      new->mset = rec_mset_dup (record->mset);\n      if (!new->mset)\n        {\n          rec_record_destroy (new);\n          return NULL;\n        }\n\n      new->source = NULL;\n      if (record->source)\n        {\n          new->source = strdup (record->source);\n          if (!new->source)\n            {\n              rec_record_destroy (new);\n              return NULL;\n            }\n        }\n\n      new->location = record->location;\n      new->char_location = record->char_location;\n\n      new->location_str = NULL;\n      if (record->location_str)\n        {\n          new->location_str = strdup (record->location_str);\n          if (!new->location_str)\n            {\n              rec_record_destroy (new);\n              return NULL;\n            }\n        }\n\n      new->char_location_str = NULL;\n      if (record->char_location_str)\n        {\n          new->char_location_str = strdup (record->char_location_str);\n          if (!new->char_location_str)\n            {\n              rec_record_destroy (new);\n              return NULL;\n            }\n        }\n\n      new->container = record->container;\n    }\n\n  return new;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "rec_record_t"
      ]
    },
    "rec_record_subset_p": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "bool\nrec_record_subset_p (rec_record_t record1,\n                     rec_record_t record2)\n{\n  bool result;\n  rec_mset_iterator_t iter1;\n  rec_mset_elem_t elem1;\n  const void *data;\n\n  result = true;\n\n  /* Iterate on the elements stored in record1.  For each element,\n     verify that an equal element is also stored in record2.  */\n\n  iter1 = rec_mset_iterator (record1->mset);\n  while (rec_mset_iterator_next (&iter1, MSET_ANY, &data, &elem1))\n    {\n      bool elem_found = false;\n      rec_mset_elem_t elem2;\n      rec_mset_iterator_t iter2 = rec_mset_iterator (record2->mset);\n\n      while (rec_mset_iterator_next (&iter2, MSET_ANY, &data, &elem2))\n        {\n          if (rec_mset_elem_equal_p (elem1, elem2))\n            {\n              elem_found = true;\n              break;\n            }\n        }\n\n      if (!elem_found)\n        {\n          result = false;\n          break;\n        }\n\n      rec_mset_iterator_free (&iter2);\n      \n    }\n\n  rec_mset_iterator_free (&iter1);\n  \n  return result;\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_equal_p": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "bool\nrec_record_equal_p (rec_record_t record1,\n                    rec_record_t record2)\n{\n  return ((rec_record_subset_p (record1, record2)) &&\n          (rec_record_subset_p (record2, record1)));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_mset": {
      "start_point": [
        261,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "rec_mset_t\nrec_record_mset (rec_record_t record)\n{\n  return record->mset;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_mset_t"
      ]
    },
    "rec_record_num_elems": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        271,
        1
      ],
      "content": "size_t\nrec_record_num_elems (rec_record_t record)\n{\n  return rec_mset_count (record->mset, MSET_ANY);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_num_fields": {
      "start_point": [
        273,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "size_t\nrec_record_num_fields (rec_record_t record)\n{\n  return rec_mset_count (record->mset, record->field_type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_num_comments": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "size_t\nrec_record_num_comments (rec_record_t record)\n{\n  return rec_mset_count (record->mset, record->comment_type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_get_field_index": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "size_t\nrec_record_get_field_index (rec_record_t record,\n                            rec_field_t field)\n{\n  size_t res = 0;\n  rec_mset_iterator_t iter;\n  rec_field_t list_field;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &list_field, NULL))\n    {\n      if (field == list_field)\n        {\n          break;\n        }\n\n      res++;\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_field_p": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "bool\nrec_record_field_p (rec_record_t record,\n                    const char *field_name)\n{\n  return (rec_record_get_num_fields_by_name (record, field_name) > 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_get_num_fields_by_name": {
      "start_point": [
        316,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "size_t\nrec_record_get_num_fields_by_name (rec_record_t record,\n                                   const char *field_name)\n{\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n  int num_fields = 0;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      if (rec_field_name_equal_p (rec_field_name (field), field_name))\n        {\n          num_fields++;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  return num_fields;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_get_field_by_name": {
      "start_point": [
        337,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "rec_field_t\nrec_record_get_field_by_name (rec_record_t record,\n                              const char *field_name,\n                              size_t n)\n{\n  size_t num_fields = 0;\n  rec_field_t field  = NULL;\n  rec_field_t result = NULL;\n  rec_mset_iterator_t iter;\n\n  \n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      if (rec_field_name_equal_p (rec_field_name (field), field_name))\n        {\n          if (n == num_fields)\n            {\n              result = field;\n              break;\n            }\n\n          num_fields++;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  return result;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "rec_field_t"
      ]
    },
    "rec_record_remove_field_by_name": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        391,
        1
      ],
      "content": "void\nrec_record_remove_field_by_name (rec_record_t record,\n                                 const char *field_name,\n                                 size_t n)\n{\n  rec_field_t field;\n  rec_mset_iterator_t iter;\n  rec_mset_elem_t elem;\n  int num_fields = 0;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, &elem))\n    {\n      if (rec_field_name_equal_p (rec_field_name (field), field_name))\n        {\n          if ((n == -1) || (n == num_fields))\n            {\n              rec_mset_remove_elem (record->mset, elem);\n            }\n\n          num_fields++;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_record_get_field_index_by_name": {
      "start_point": [
        393,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "size_t\nrec_record_get_field_index_by_name (rec_record_t record,\n                                    rec_field_t field)\n{\n  size_t res = 0;\n  rec_mset_iterator_t iter;\n  rec_field_t list_field;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &list_field, NULL))\n    {\n      if (field == list_field)\n        {\n          break;\n        }\n\n      if (rec_field_equal_p (field, list_field))\n        {\n          res++;\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_to_comment": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        467,
        1
      ],
      "content": "rec_comment_t\nrec_record_to_comment (rec_record_t record)\n{\n  rec_buf_t buf;\n  rec_comment_t res;\n  char *comment_str;\n  size_t comment_str_size;\n  rec_mset_iterator_t iter;\n  rec_mset_elem_t elem;\n  const void *data;\n\n  buf = rec_buf_new (&comment_str, &comment_str_size);\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_ANY, &data, &elem))\n    {\n      if (rec_mset_elem_type (elem) == MSET_FIELD)\n        {\n          rec_buf_puts (rec_write_field_str ((rec_field_t) data,\n                                             REC_WRITER_NORMAL),\n                        buf);\n          rec_buf_putc ('\\n', buf);\n        }\n      else\n        {\n          /* Comment.  */\n          rec_buf_puts (rec_write_comment_str (rec_comment_text ((rec_comment_t) data),\n                                               REC_WRITER_NORMAL),\n                        buf);\n          rec_buf_putc ('\\n', buf);\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  rec_buf_close (buf);\n\n  /* Remove a trailing newline.  */\n  if (comment_str[comment_str_size - 1] == '\\n')\n    {\n      comment_str[comment_str_size - 1] = '\\0';\n    }\n\n  res = rec_comment_new (comment_str);\n  free (comment_str);\n\n  return res;\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "rec_comment_t"
      ]
    },
    "rec_record_source": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "char *\nrec_record_source (rec_record_t record)\n{\n  char *res;\n\n  if (record->source)\n    {\n      res = record->source;\n    }\n  else\n    {\n      res = \"\";\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_record_source (rec_record_t record)",
        "*"
      ]
    },
    "rec_record_set_source": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void\nrec_record_set_source (rec_record_t record,\n                       char *source)\n{\n  if (record->source)\n    {\n      free (record->source);\n      record->source = NULL;\n    }\n\n  record->source = strdup (source);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_record_location": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "size_t\nrec_record_location (rec_record_t record)\n{\n  return record->location;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_location_str": {
      "start_point": [
        505,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "char *\nrec_record_location_str (rec_record_t record)\n{\n  char *res;\n\n  if (record->location_str)\n    {\n      res = record->location_str;\n    }\n  else\n    {\n      res = \"\";\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_record_location_str (rec_record_t record)",
        "*"
      ]
    },
    "rec_record_set_location": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "void\nrec_record_set_location (rec_record_t record,\n                         size_t location)\n{\n  record->location = location;\n\n  if (record->location_str)\n    {\n      free (record->location_str);\n      record->location_str = NULL;\n    }\n\n  asprintf (&(record->location_str), \"%zu\", record->location);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_record_char_location": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        541,
        1
      ],
      "content": "size_t\nrec_record_char_location (rec_record_t record)\n{\n  return record->char_location;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_record_char_location_str": {
      "start_point": [
        543,
        0
      ],
      "end_point": [
        558,
        1
      ],
      "content": "char *\nrec_record_char_location_str (rec_record_t record)\n{\n  char *res;\n\n  if (record->char_location_str)\n    {\n      res = record->char_location_str;\n    }\n  else\n    {\n      res = \"\";\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_record_char_location_str (rec_record_t record)",
        "*"
      ]
    },
    "rec_record_set_char_location": {
      "start_point": [
        560,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "void\nrec_record_set_char_location (rec_record_t record,\n                              size_t location)\n{\n  record->char_location = location;\n\n  if (record->char_location_str)\n    {\n      free (record->char_location_str);\n      record->char_location_str = NULL;\n    }\n  \n  asprintf (&(record->char_location_str), \"%zu\", record->char_location);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_record_contains_value": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        610,
        1
      ],
      "content": "bool\nrec_record_contains_value (rec_record_t record,\n                           const char *str,\n                           bool case_insensitive)\n{\n  bool res = false;\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n  const char *field_value;\n  char *occur;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      field_value = rec_field_value (field);\n\n      if (case_insensitive)\n        {\n          occur = strcasestr (field_value, str);\n        }\n      else\n        {\n          occur = strstr (field_value, str);\n        }\n\n      res = (occur != NULL);\n      if (res)\n        {\n          break;\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_contains_field": {
      "start_point": [
        612,
        0
      ],
      "end_point": [
        635,
        1
      ],
      "content": "bool\nrec_record_contains_field (rec_record_t record,\n                           const char *field_name,\n                           const char *field_value)\n{\n  bool res = false;\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      if (rec_field_name_equal_p (field_name,\n                                  rec_field_name (field))\n          && (strcmp (field_value, rec_field_value (field)) == 0))\n        {\n          res = true;\n          break;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  return res;\n}",
      "lines": 24,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_container": {
      "start_point": [
        637,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "void *\nrec_record_container (rec_record_t record)\n{\n  return record->container;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void",
        "*\nrec_record_container (rec_record_t record)",
        "*"
      ]
    },
    "rec_record_set_container": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        647,
        1
      ],
      "content": "void\nrec_record_set_container (rec_record_t record, void *container)\n{\n  record->container = container;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_record_uniq": {
      "start_point": [
        649,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "void\nrec_record_uniq (rec_record_t record)\n{\n  rec_mset_iterator_t iter1, iter2;\n  rec_mset_elem_t elem1;\n  rec_field_t field1, field2;\n  bool *to_remove;\n  size_t num_fields, i, j;\n\n  /* Create a map of the fields to remove and initialize all the\n     entries to false.  */\n\n  num_fields = rec_record_num_fields (record);\n  to_remove = malloc (sizeof(bool) * num_fields);\n  memset (to_remove, false, num_fields);\n\n  /* Iterate on the fields of the record an mark the fields that will\n     be removed in the removal mask.  */\n\n  i = 0;\n  iter1 = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter1, MSET_FIELD, (const void **) &field1, NULL))\n    {\n      if (!to_remove[i])\n        {\n          /* Mark any other occurrence of this field having the same\n             value for removal. */\n\n          j = 0;\n          iter2 = rec_mset_iterator (record->mset);\n          while (rec_mset_iterator_next (&iter2, MSET_FIELD, (const void **) &field2, NULL))\n            {\n              if ((j != i)\n                  && rec_field_name_equal_p (rec_field_name (field1), rec_field_name (field2))\n                  && rec_field_name_equal_p (rec_field_value (field1), rec_field_value (field2)))\n                {\n                  to_remove[j] = true;\n                }\n              \n              j++;\n            }\n          rec_mset_iterator_free (&iter2);\n        }\n\n      i++;\n    }\n  rec_mset_iterator_free (&iter1);\n\n\n  /* Remove the fields marked for removal.  */\n\n  i = 0;\n  iter1 = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter1, MSET_FIELD, (const void **) &field1, &elem1))\n    {\n      if (to_remove[i])\n        {\n          rec_mset_remove_elem (record->mset, elem1);\n        }\n\n      i++;\n    }\n\n  /* Cleanup.  */\n\n  free (to_remove);\n}",
      "lines": 67,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "rec_record_append": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "void\nrec_record_append (rec_record_t dest_record,\n                   rec_record_t src_record)\n{\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n\n  iter = rec_mset_iterator (src_record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      if (!rec_mset_append (rec_record_mset (dest_record),\n                            MSET_FIELD,\n                            (void *) rec_field_dup (field),\n                            MSET_FIELD))\n        {\n          /* Out of memory.  Just return.  */\n          return;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_record_reset_marks": {
      "start_point": [
        739,
        0
      ],
      "end_point": [
        751,
        1
      ],
      "content": "void\nrec_record_reset_marks (rec_record_t record)\n{\n  rec_mset_iterator_t iter;\n  rec_field_t field;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n    {\n      rec_field_set_mark (field, 0);\n    }\n  rec_mset_iterator_free (&iter);\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_record_mark_field": {
      "start_point": [
        753,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "bool\nrec_record_mark_field (rec_record_t record,\n                       rec_field_t field,\n                       int mark)\n{\n  rec_mset_iterator_t iter;\n  rec_field_t iter_field;\n\n  iter = rec_mset_iterator (record->mset);\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &iter_field, NULL))\n    {\n      if (field == iter_field)\n        {\n          rec_field_set_mark (field, mark);\n          rec_mset_iterator_free (&iter);\n          return true;\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  return false;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_record_field_mark": {
      "start_point": [
        776,
        0
      ],
      "end_point": [
        781,
        1
      ],
      "content": "int\nrec_record_field_mark (rec_record_t record,\n                       rec_field_t field)\n{\n  return rec_field_mark (field);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "rec_record_init": {
      "start_point": [
        787,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static void\nrec_record_init (rec_record_t record)\n{\n  /* Initialize the record structure so it can be safely passed to\n     rec_record_destroy even if its contents are not completely\n     initialized with real values.  */\n  \n  memset (record, 0 /* NULL */, sizeof (struct rec_record_s));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_record_field_disp_fn": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        801,
        1
      ],
      "content": "static void\nrec_record_field_disp_fn (void *data)\n{\n  rec_field_destroy ((rec_field_t) data);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_record_field_equal_fn": {
      "start_point": [
        803,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "static bool\nrec_record_field_equal_fn (void *data1,\n                           void *data2)\n{\n  return (data1 == data2);\n  /*  return rec_field_equal_p ((rec_field_t) data1,\n      (rec_field_t) data2);*/\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_record_field_dup_fn": {
      "start_point": [
        812,
        0
      ],
      "end_point": [
        819,
        1
      ],
      "content": "static void *\nrec_record_field_dup_fn (void *data)\n{\n  rec_field_t copy;\n\n  copy = rec_field_dup ((rec_field_t) data);\n  return (void *) copy;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrec_record_field_dup_fn (void *data)",
        "*"
      ]
    },
    "rec_record_comment_disp_fn": {
      "start_point": [
        821,
        0
      ],
      "end_point": [
        825,
        1
      ],
      "content": "static void\nrec_record_comment_disp_fn (void *data)\n{\n  rec_comment_destroy ((rec_comment_t) data);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_record_comment_equal_fn": {
      "start_point": [
        827,
        0
      ],
      "end_point": [
        834,
        1
      ],
      "content": "static bool\nrec_record_comment_equal_fn (void *data1,\n                             void *data2)\n{\n  return (data1 == data2);\n/*  return rec_comment_equal_p ((rec_comment_t) data1,\n(rec_comment_t) data2);*/\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_record_comment_dup_fn": {
      "start_point": [
        836,
        0
      ],
      "end_point": [
        843,
        1
      ],
      "content": "static void *\nrec_record_comment_dup_fn (void *data)\n{\n  rec_comment_t copy;\n  \n  copy = rec_comment_dup ((rec_comment_t) data);\n  return (void *) copy;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrec_record_comment_dup_fn (void *data)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-rset.c": {
    "rec_rset_new": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        226,
        1
      ],
      "content": "rec_rset_t\nrec_rset_new (void)\n{\n  rec_rset_t rset;\n  \n  rset = malloc (sizeof (struct rec_rset_s));\n  if (rset)\n    {\n      rec_rset_init (rset);\n\n      /* Create the mset.  */\n      rset->mset = rec_mset_new ();\n      if (rset->mset)\n        {\n          /* No descriptor, initially.  */\n          rset->descriptor = NULL;\n          rset->descriptor_pos = 0;\n          rset->min_size = 0;\n          rset->max_size = SIZE_MAX;\n          rset->constraints = NULL;\n          rset->num_constraints = 0;\n\n          /* Create an empty type registry.  */\n          rset->type_reg = rec_type_reg_new ();\n          if (!rset->type_reg)\n            {\n              /* Out of memory.  */\n              rec_rset_destroy (rset);\n              return NULL;\n            }\n\n          /* No field properties, initially.  */\n          rset->field_props = NULL;\n\n          /* No order by field, initially.  */\n          rset->order_by_fields = NULL;\n\n          /* register the types.  See rec.h for the definition of\n             MSET_COMMENT and MSET_RECORD.  */\n\n          rset->record_type = rec_mset_register_type (rset->mset,\n                                                      \"record\",\n                                                      rec_rset_record_disp_fn,\n                                                      rec_rset_record_equal_fn,\n                                                      rec_rset_record_dup_fn,\n                                                      rec_rset_record_compare_fn);\n          rset->comment_type = rec_mset_register_type (rset->mset,\n                                                       \"comment\",\n                                                       rec_rset_comment_disp_fn,\n                                                       rec_rset_comment_equal_fn,\n                                                       rec_rset_comment_dup_fn,\n                                                       rec_rset_comment_compare_fn);\n        }\n      else\n        {\n          /* Out of memory.  */\n\n          rec_rset_destroy (rset);\n          rset = NULL;\n        }\n    }\n\n  return rset;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_rset_destroy": {
      "start_point": [
        228,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "void\nrec_rset_destroy (rec_rset_t rset)\n{\n  rec_rset_fprops_t props, aux = NULL;\n  size_t i = 0;\n\n  if (rset)\n    {\n      rec_record_destroy (rset->descriptor);\n      rec_type_reg_destroy (rset->type_reg);\n\n      for (i = 0; i < rset->num_constraints; i++)\n        {\n          rec_sex_destroy (rset->constraints[i]);\n        }\n      free (rset->constraints);\n\n      props = rset->field_props;\n      while (props)\n        {\n          aux = props;\n          \n          if (aux->type)\n            {\n              rec_type_destroy (aux->type);\n            }\n          free (aux->fname);\n          free (aux->type_name);\n          props = props->next;\n          free (aux);\n        }\n\n      rec_fex_destroy (rset->order_by_fields);\n\n      rec_mset_destroy (rset->mset);\n      free (rset);\n    }\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_rset_dup": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "rec_rset_t\nrec_rset_dup (rec_rset_t rset)\n{\n  rec_rset_t new = NULL;\n\n  new = malloc (sizeof (struct rec_rset_s));\n  if (new)\n    {\n      rec_rset_init (new);\n\n      new->record_type = rset->record_type;\n      new->comment_type = rset->comment_type;\n      new->mset = NULL;\n      new->min_size = rset->min_size;\n      new->max_size = rset->max_size;\n      /* XXX: make copies of the following structures.  */\n      new->type_reg = NULL;\n      new->field_props = NULL;\n      new->constraints = NULL;\n      new->num_constraints = 0;\n\n      if (rset->order_by_fields)\n        {\n          new->order_by_fields = rec_fex_dup (rset->order_by_fields);\n          if (!new->order_by_fields)\n            {\n              /* Out of memory.  */\n              rec_rset_destroy (new);\n              return NULL;\n            }\n        }\n    }\n\n  new->mset = rec_mset_dup (rset->mset);\n  if (!new->mset)\n    {\n      /* Out of memory.  */\n      rec_rset_destroy (new);\n      return NULL;\n    }\n  \n  return new;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_rset_mset": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "rec_mset_t\nrec_rset_mset (rec_rset_t rset)\n{\n  return rset->mset;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_mset_t"
      ]
    },
    "rec_rset_num_elems": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "size_t\nrec_rset_num_elems (rec_rset_t rset)\n{\n  return rec_mset_count (rset->mset, MSET_ANY);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_num_records": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "size_t\nrec_rset_num_records (rec_rset_t rset)\n{\n  return rec_mset_count (rset->mset, rset->record_type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_num_comments": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "size_t\nrec_rset_num_comments (rec_rset_t rset)\n{\n  return rec_mset_count (rset->mset, rset->comment_type);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_descriptor": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "rec_record_t\nrec_rset_descriptor (rec_rset_t rset)\n{\n  return rset->descriptor;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_record_t"
      ]
    },
    "rec_rset_set_descriptor": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nrec_rset_set_descriptor (rec_rset_t rset, rec_record_t record)\n{\n  if (rset->descriptor)\n    {\n      rec_record_destroy (rset->descriptor);\n      rset->descriptor = NULL;\n    }\n  rset->descriptor = record;\n\n  /* Update the types registry and the auto fields.  */\n  rec_rset_update_types (rset);\n  rec_rset_update_field_props (rset);\n  rec_rset_update_size_constraints (rset);\n  rec_rset_update_sex_constraints (rset);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_rset_descriptor_pos": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "size_t\nrec_rset_descriptor_pos (rec_rset_t rset)\n{\n  return rset->descriptor_pos;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_set_descriptor_pos": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "void\nrec_rset_set_descriptor_pos (rec_rset_t rset,\n                             size_t position)\n{\n  rset->descriptor_pos = position;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_rset_set_type": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "void\nrec_rset_set_type (rec_rset_t rset,\n                   const char *type)\n{\n  rec_field_t rec_field;\n\n  if (!type)\n    {\n      /* This is a no-op for the default record set.  */\n      return;\n    }\n\n  if (!rset->descriptor)\n    {\n      /* Create a record descriptor.  */\n      rset->descriptor = rec_record_new ();\n      \n    }\n\n  rec_field = rec_record_get_field_by_name (rset->descriptor,\n                                            FNAME(REC_FIELD_REC),\n                                            0);\n\n  if (rec_field)\n    {\n      rec_field_set_value (rec_field, type);\n    }\n  else\n    {\n      rec_field = rec_field_new (FNAME(REC_FIELD_REC), type);\n      rec_mset_append (rec_record_mset (rset->descriptor), MSET_FIELD, (void *) rec_field, MSET_FIELD);\n    }\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_rset_type": {
      "start_point": [
        405,
        0
      ],
      "end_point": [
        424,
        1
      ],
      "content": "char *\nrec_rset_type (rec_rset_t rset)\n{\n  char *res;\n  rec_field_t field;\n\n  res = NULL;\n  if (rset->descriptor)\n    {\n      field = rec_record_get_field_by_name (rset->descriptor,\n                                            FNAME(REC_FIELD_REC),\n                                            0);\n      if (field)\n        {\n          res = rec_extract_type (rec_field_value (field));\n        }\n    }\n\n  return res;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "char",
        "*\nrec_rset_type (rec_rset_t rset)",
        "*"
      ]
    },
    "rec_rset_url": {
      "start_point": [
        426,
        0
      ],
      "end_point": [
        445,
        1
      ],
      "content": "char *\nrec_rset_url (rec_rset_t rset)\n{\n  char *res;\n  rec_field_t field;\n\n  res = NULL;\n  if (rset->descriptor)\n    {\n      field = rec_record_get_field_by_name (rset->descriptor,\n                                            FNAME(REC_FIELD_REC),\n                                            0);\n      if (field)\n        {\n          res = rec_extract_url (rec_field_value (field));\n        }\n    }\n\n  return res;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "char",
        "*\nrec_rset_url (rec_rset_t rset)",
        "*"
      ]
    },
    "rec_rset_get_type_reg": {
      "start_point": [
        447,
        0
      ],
      "end_point": [
        451,
        1
      ],
      "content": "rec_type_reg_t\nrec_rset_get_type_reg (rec_rset_t rset)\n{\n  return rset->type_reg;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_type_reg_t"
      ]
    },
    "rec_rset_rename_field": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "void\nrec_rset_rename_field (rec_rset_t rset,\n                       const char *field_name,\n                       const char *new_field_name)\n{\n  size_t j;\n  rec_record_t descriptor;\n  rec_fex_t fex;\n  char *fex_str;\n  char *type_str;\n  rec_buf_t buf;\n  char *result;\n  size_t result_size;\n  rec_fex_elem_t fex_elem;\n  const char *fex_fname;\n\n  descriptor = rec_rset_descriptor (rset);\n  if (descriptor)\n    {\n      rec_mset_t descriptor_mset = rec_record_mset (descriptor);\n      rec_mset_iterator_t iter = rec_mset_iterator (descriptor_mset);\n      rec_field_t field;\n\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (void *) &field, NULL))\n        {\n          if (rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_TYPE)))\n            {\n              /* Process a %type entry.  Invalid entries are\n                 skipped.  */\n              if (!rec_rset_type_field_p (rec_field_value (field)))\n                {\n                  continue;\n                }\n\n              fex = rec_rset_type_field_fex (rec_field_value (field));\n              if (fex)\n                {\n                  for (j = 0; j < rec_fex_size (fex); j++)\n                    {\n                      fex_elem = rec_fex_get (fex, j);\n                      fex_fname = rec_fex_elem_field_name (fex_elem);\n                      if (rec_field_name_equal_p (field_name, fex_fname))\n                        {\n                          /* Replace it with new_field_name.  */\n                          rec_fex_elem_set_field_name (fex_elem, new_field_name);\n                        }\n                    }\n\n                  fex_str = rec_fex_str (fex, REC_FEX_CSV);\n                  type_str = rec_rset_type_field_type (rec_field_value (field));\n                  \n                  buf = rec_buf_new (&result, &result_size);\n                  rec_buf_puts (fex_str, buf);\n                  rec_buf_putc (' ', buf);\n                  rec_buf_puts (type_str, buf);\n                  rec_buf_close (buf);\n\n                  rec_field_set_value (field, result);\n\n                  free (fex_str);\n                  free (type_str);\n                  rec_fex_destroy (fex);\n                }\n            }\n          else if (rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_KEY))\n                   || rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_MANDATORY))\n                   || rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_UNIQUE))\n                   || rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_PROHIBIT))\n#if defined REC_CRYPT_SUPPORT\n                   || rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_CONFIDENTIAL))\n#endif\n                   || rec_field_name_equal_p (rec_field_name (field), FNAME(REC_FIELD_SORT)))\n            {\n              /* Rename the field in the fex expression that is the\n                 value of the field.  Skip invalid entries.  */\n              fex = rec_fex_new (rec_field_value (field), REC_FEX_SIMPLE);\n              if (fex)\n                {\n                  for (j = 0; j < rec_fex_size (fex); j++)\n                    {\n                      fex_elem = rec_fex_get (fex, j);\n\n                      fex_fname = rec_fex_elem_field_name (fex_elem);\n                      if (rec_field_name_equal_p (field_name, fex_fname))\n                        {\n                          /* Replace it with new_field_name.  */\n                          rec_fex_elem_set_field_name (fex_elem, new_field_name);\n                        }\n                    }\n                  \n                  fex_str = rec_fex_str (fex, REC_FEX_SIMPLE);\n                  rec_field_set_value (field, fex_str);\n                  free (fex_str);\n                }\n            }          \n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n\n  /* Update the types registry.  */\n  rec_rset_update_field_props (rset);\n}",
      "lines": 103,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "rec_rset_key": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        575,
        1
      ],
      "content": "const char *\nrec_rset_key (rec_rset_t rset)\n{\n  const char *key = NULL;\n  rec_rset_fprops_t props = rset->field_props;\n\n  while (props)\n    {\n      if (props->key_p)\n        {\n          /* There must be only one field marked as key.  */\n          key = props->fname;\n          break;\n        }\n      props = props->next;\n    }\n  \n  return key;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_rset_key (rec_rset_t rset)",
        "*"
      ]
    },
    "rec_rset_auto": {
      "start_point": [
        577,
        0
      ],
      "end_point": [
        598,
        1
      ],
      "content": "rec_fex_t\nrec_rset_auto (rec_rset_t rset)\n{\n  rec_fex_t fex;\n  rec_rset_fprops_t props;\n\n  fex = rec_fex_new (NULL, REC_FEX_SIMPLE);\n\n  props = rset->field_props;\n  while (props)\n    {\n      if (props->auto_p)\n        {\n          rec_fex_append (fex,\n                          props->fname,\n                          -1, -1);\n        }\n      props = props->next;\n    }\n\n  return fex;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "rec_fex_t"
      ]
    },
    "rec_rset_field_confidential_p": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        626,
        1
      ],
      "content": "bool\nrec_rset_field_confidential_p (rec_rset_t rset,\n                               const char *field_name)\n{\n  rec_fex_t fex;\n  size_t fex_size;\n  size_t i;\n  bool result = false;\n  const char *fex_field_name;\n\n  fex = rec_rset_confidential (rset);\n  fex_size = rec_fex_size (fex);\n\n  for (i = 0; i < fex_size; i++)\n    {\n      fex_field_name = rec_fex_elem_field_name (rec_fex_get (fex, i));\n      if (rec_field_name_equal_p (field_name, fex_field_name))\n        {\n          result = true;\n          break;\n        }\n    }\n\n  return result;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_rset_confidential": {
      "start_point": [
        628,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "rec_fex_t\nrec_rset_confidential (rec_rset_t rset)\n{\n  rec_fex_t fex;\n  rec_rset_fprops_t props;\n\n  fex = rec_fex_new (NULL, REC_FEX_SIMPLE);\n\n  props = rset->field_props;\n  while (props)\n    {\n      if (props->confidential_p)\n        {\n          rec_fex_append (fex,\n                          props->fname,\n                          -1, -1);\n        }\n\n      props = props->next;\n    }\n\n  return fex;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "rec_fex_t"
      ]
    },
    "rec_rset_get_field_type": {
      "start_point": [
        654,
        0
      ],
      "end_point": [
        672,
        1
      ],
      "content": "rec_type_t\nrec_rset_get_field_type (rec_rset_t rset,\n                         const char *field_name)\n{\n  rec_type_t type = NULL;\n  rec_rset_fprops_t props = NULL;\n\n  props = rec_rset_get_props (rset, field_name, false);\n  if (props)\n    {\n      type = props->type;\n      if (!type && props->type_name)\n        {\n          type = rec_type_reg_get (rset->type_reg, props->type_name);\n        }\n    }\n  \n  return type;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "rec_type_t"
      ]
    },
    "rec_rset_min_records": {
      "start_point": [
        674,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "size_t\nrec_rset_min_records (rec_rset_t rset)\n{\n  return rset->min_size;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_max_records": {
      "start_point": [
        680,
        0
      ],
      "end_point": [
        684,
        1
      ],
      "content": "size_t\nrec_rset_max_records (rec_rset_t rset)\n{\n  return rset->max_size;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_source": {
      "start_point": [
        686,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "char *\nrec_rset_source (rec_rset_t rset)\n{\n  rec_record_t record;\n\n  /* The source of the record set is considered to be the source of\n     its first record: either the descriptor or some other record.  */\n  \n  record = rec_rset_descriptor (rset);\n  if (!record)\n    {\n      record = (rec_record_t) rec_mset_get_at (rset->mset, MSET_RECORD, 0);\n    }\n\n  return rec_record_source (record);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrec_rset_source (rec_rset_t rset)",
        "*"
      ]
    },
    "rec_rset_set_order_by_fields": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "bool\nrec_rset_set_order_by_fields (rec_rset_t rset,\n                              rec_fex_t field_names)\n{\n  rec_fex_destroy (rset->order_by_fields);\n  rset->order_by_fields = rec_fex_dup (field_names);\n  return (rset->order_by_fields != NULL);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_rset_order_by_fields": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        717,
        1
      ],
      "content": "rec_fex_t\nrec_rset_order_by_fields (rec_rset_t rset)\n{\n  return rset->order_by_fields;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_fex_t"
      ]
    },
    "rec_rset_sort": {
      "start_point": [
        719,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "rec_rset_t\nrec_rset_sort (rec_rset_t rset,\n               rec_fex_t sort_by)\n{\n  if (sort_by)\n    {\n      rec_rset_set_order_by_fields (rset, sort_by);\n    }\n\n  if (rset->order_by_fields)\n    {\n      /* Duplicate the multi-set indicating that the elements must be\n         sorted.  */\n\n      if (!rec_mset_sort (rset->mset))\n        {\n          /* Out of memory.  */\n          return NULL;\n        }\n\n      /* Update field properties, in case order_by_fields was changed\n         above.  */\n  \n      rec_rset_update_field_props (rset);\n    }\n\n  return rset;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_rset_group": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "rec_rset_t\nrec_rset_group (rec_rset_t rset,\n                rec_fex_t group_by)\n{\n  rec_mset_iterator_t iter;\n  rec_record_t record;\n  rec_mset_elem_t elem;\n  size_t map_size;\n  bool *deletion_map;\n  size_t num_record;\n\n  /* Create and initialize the deletion map.  */\n\n  map_size = sizeof(bool) * rec_rset_num_records (rset);\n  deletion_map = malloc (map_size);\n  if (!deletion_map)\n    {\n      /* Out of memory.  */\n      return NULL;\n    }\n\n  memset (deletion_map, false, map_size);\n\n  /* Iterate on the records of RSET, grouping records and marking the\n     grouped records for deletion.  */\n\n  num_record = 0;\n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **)&record, NULL))\n    {\n      if (!deletion_map[num_record])\n        {\n          size_t num_record_2 = num_record;\n          rec_mset_iterator_t iter2 = iter;\n          rec_record_t record2;\n          \n          while (rec_mset_iterator_next (&iter2, MSET_RECORD, (const void**)&record2, NULL))\n            {\n              num_record_2++;\n              \n              if (rec_rset_compare_typed_records (rset, record, record2, group_by) != 0)\n                {\n                  break;\n                }\n              else\n                {\n                  /* Insert all the elements of record2 into record,\n                     but not the group-by fields.  Also, remove any\n                     duplicated field created in record2 as the result\n                     of the operation.  */\n\n                  if (!rec_rset_merge_records (record,\n                                               record2,\n                                               group_by))\n                    {\n                      /* Out of memory.  */\n                      return NULL;\n                    }\n                  \n                  /* Mark record2 for removal.  */\n                  deletion_map[num_record_2] = true;\n                }\n            }\n        }\n\n      num_record++;\n    }\n  rec_mset_iterator_free (&iter);\n\n  /* Delete the records marked for deletion.  */\n\n  num_record = 0;\n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, &elem))\n    {\n      if (deletion_map[num_record])\n        {\n          rec_mset_remove_elem (rec_rset_mset (rset), elem);\n        }\n\n      num_record++;\n    }\n  rec_mset_iterator_free (&iter);\n\n  free (deletion_map);\n\n  return rset;\n}",
      "lines": 88,
      "depth": 16,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_rset_add_auto_fields": {
      "start_point": [
        837,
        0
      ],
      "end_point": [
        912,
        1
      ],
      "content": "rec_rset_t\nrec_rset_add_auto_fields (rec_rset_t rset,\n                          rec_record_t record)\n{\n  rec_fex_t auto_fields;\n  rec_type_t type;\n  size_t i;\n\n  if ((auto_fields = rec_rset_auto (rset)))\n    {\n      size_t num_auto_fields = rec_fex_size (auto_fields);\n\n      for (i = 0; i < num_auto_fields; i++)\n        {\n          const char *auto_field_name =\n            rec_fex_elem_field_name (rec_fex_get (auto_fields, i));\n\n          if (!rec_record_field_p (record, auto_field_name))\n            {\n              /* The auto field is not already present in record, so\n                 add one automatically.  Depending on its type the\n                 value is calculated differently.  If the record does\n                 not have a type, or the type is incorrect, ignore\n                 it.  */\n              \n              type = rec_rset_get_field_type (rset, auto_field_name);\n              if (type)\n                {\n                  switch (rec_type_kind (type))\n                    {\n                    case REC_TYPE_INT:\n                    case REC_TYPE_RANGE:\n                      {\n                        if (!rec_rset_add_auto_field_int (rset, auto_field_name, record))\n                          {\n                            /* Out of memory.  */\n                            return NULL;\n                          }\n\n                        break;\n                      }\n                    case REC_TYPE_DATE:\n                      {\n                        if (!rec_rset_add_auto_field_date (rset, auto_field_name, record))\n                          {\n                            /* Out of memory.  */\n                            return NULL;\n                          }\n\n                        break;\n                      }\n#if defined UUID_TYPE\n                    case REC_TYPE_UUID:\n                      {\n                        if (!rec_rset_add_auto_field_uuid (rset, auto_field_name, record))\n                          {\n                            /* Out of memory.  */\n                            return NULL;\n                          }\n                        \n                        break;\n                      }\n#endif /* UUID_TYPE */\n                    default:\n                      {\n                        /* Do nothing for other types.  */\n                        break;\n                      }\n                    }\n                }\n            }\n        }\n    }\n\n  return rset;\n}",
      "lines": 76,
      "depth": 21,
      "decorators": [
        "rec_rset_t"
      ]
    },
    "rec_rset_num_sex_constraints": {
      "start_point": [
        914,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "size_t\nrec_rset_num_sex_constraints (rec_rset_t rset)\n{\n  return rset->num_constraints;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "rec_rset_sex_constraint": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        925,
        1
      ],
      "content": "rec_sex_t\nrec_rset_sex_constraint (rec_rset_t rset,\n                         size_t index)\n{\n  return rset->constraints[index];\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "rec_sex_t"
      ]
    },
    "rec_rset_init": {
      "start_point": [
        931,
        0
      ],
      "end_point": [
        939,
        1
      ],
      "content": "static void\nrec_rset_init (rec_rset_t rset)\n{\n  /* Initialize the rset structure so it can be safely passed to\n     rec_rset_destroy even if its contents are not completely\n     initialized with real values.  */\n\n  memset (rset, 0 /* NULL */, sizeof (struct rec_rset_s));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_record_disp_fn": {
      "start_point": [
        941,
        0
      ],
      "end_point": [
        946,
        1
      ],
      "content": "static void\nrec_rset_record_disp_fn (void *data)\n{\n  rec_record_t record = (rec_record_t) data;\n  rec_record_destroy (record);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_record_equal_fn": {
      "start_point": [
        948,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "static bool\nrec_rset_record_equal_fn (void *data1,\n                          void *data2)\n{\n  return (data1 == data2);\n  /*  return rec_record_equal_p ((rec_record_t) data1,\n      (rec_record_t) data2); */\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_record_dup_fn": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        964,
        1
      ],
      "content": "static void *\nrec_rset_record_dup_fn (void *data)\n{\n  rec_record_t record = (rec_record_t) data;\n  rec_record_t new = rec_record_dup (record);\n\n  return (void *) new;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrec_rset_record_dup_fn (void *data)",
        "*"
      ]
    },
    "rec_rset_record_compare_fn": {
      "start_point": [
        966,
        0
      ],
      "end_point": [
        1024,
        1
      ],
      "content": "static int\nrec_rset_record_compare_fn (void *data1,\n                            void *data2,\n                            int type2)\n{\n  /* data1 is a record.  data2 can be either a record or a comment.\n\n     order_by_field can't be NULL, because this callback is invoked\n     only if rec_mset_add_sorted is used to add an element to the\n     list.\n\n     The following rules apply here:\n     \n     1. If the fields in order_by_fields are not in both record1 and\n        record2, then data1 < data2.\n \n     2. Else, perform a lexicographic comparison, i.e.\n\n        (a1, a2, ...) < (b1, b2, ...) IFF\n                      a1 < b1 OR (a1 = b2 AND a2 < b2) OR ...\n\n    Note that record1 will always be a regular record.  Never a\n    descriptor.\n  */\n\n  rec_rset_t rset                  = NULL;\n  rec_record_t record1             = NULL;\n  rec_record_t record2             = NULL;\n  int type_comparison              = 0;\n\n  /* If elem2 is a comment then elem1 > elem2.  */\n  if (type2 == MSET_COMMENT)\n    {\n      return 1;\n    }\n\n  /* Get the records and the containing rset.  */\n  record1 = (rec_record_t) data1;\n  record2 = (rec_record_t) data2;\n  rset = (rec_rset_t) rec_record_container (record1);\n\n  /* Perform a lexicographic comparison of the order_by_fields in both\n     registers.  */\n\n  type_comparison = rec_rset_compare_typed_records (rset,\n                                                    record1,\n                                                    record2,\n                                                    rset->order_by_fields);\n\n  /* If both records are equal, return -1 instead of 0 in order to\n     maintain the relative ordering between equal records.  */\n\n  if (type_comparison == 0)\n    {\n      type_comparison = -1;\n    }\n  \n  return type_comparison;\n}",
      "lines": 59,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_rset_comment_disp_fn": {
      "start_point": [
        1026,
        0
      ],
      "end_point": [
        1031,
        1
      ],
      "content": "static void\nrec_rset_comment_disp_fn (void *data)\n{\n  rec_comment_t comment = (rec_comment_t) data;\n  rec_comment_destroy (comment);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_comment_equal_fn": {
      "start_point": [
        1033,
        0
      ],
      "end_point": [
        1040,
        1
      ],
      "content": "static bool\nrec_rset_comment_equal_fn (void *data1,\n                           void *data2)\n{\n  return (data1 == data2);\n  /*  return rec_comment_equal_p ((rec_comment_t) data1,\n      (rec_comment_t) data2);*/\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_comment_dup_fn": {
      "start_point": [
        1042,
        0
      ],
      "end_point": [
        1048,
        1
      ],
      "content": "static void *\nrec_rset_comment_dup_fn (void *data)\n{\n  rec_comment_t comment = (rec_comment_t) data;\n  rec_comment_t new = rec_comment_dup (comment);\n  return (void *) new;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nrec_rset_comment_dup_fn (void *data)",
        "*"
      ]
    },
    "rec_rset_comment_compare_fn": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1059,
        1
      ],
      "content": "static int\nrec_rset_comment_compare_fn (void *data1,\n                             void *data2,\n                             int   type2)\n{\n  /* data1 is a comment, and data2 can be either a comment or a\n     record.  In any case, data1 < data2.  */\n\n  return -1;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rec_rset_update_sex_constraints": {
      "start_point": [
        1061,
        0
      ],
      "end_point": [
        1132,
        1
      ],
      "content": "static void\nrec_rset_update_sex_constraints (rec_rset_t rset)\n{\n  /* Reset the existing constraints.  */\n\n  {\n    size_t i = 0;\n\n    for (i = 0; i < rset->num_constraints; i++)\n      {\n        rec_sex_destroy (rset->constraints[i]);\n      }\n    rset->num_constraints = 0;\n  }\n\n  /* If there is not a record descriptor in the record set then simply\n     return.  */\n\n  if (!rset->descriptor)\n    {\n      return;\n    }\n\n  /* Allocate memory for the constraints memory.  In case of\n     not-enough-memory simply return.  */\n\n  {\n    size_t num_constraints =\n      rec_record_get_num_fields_by_name (rset->descriptor, FNAME(REC_FIELD_CONSTRAINT));\n    rset->constraints = malloc (num_constraints * sizeof(rec_sex_t));\n\n    if (!rset->constraints)\n      {\n        return;\n      }\n  }\n  \n  /* Scan the record descriptor for %constraint: directives, and build\n     the constraints.  Not well formed constraint entries,\n     i.e. entries not containing valid sexes, are simply ignored.  */\n\n  {\n    rec_field_t field = NULL;\n    rec_mset_iterator_t iter;\n\n    iter = rec_mset_iterator (rec_record_mset (rset->descriptor));\n    while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **)&field, NULL))\n      {\n        const char *field_name = rec_field_name (field);\n        const char *field_value = rec_field_value (field);\n\n        if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_CONSTRAINT)))\n          {\n            rec_sex_t sex = rec_sex_new (false);\n            if (!sex)\n              {\n                return;\n              }\n\n            if (rec_sex_compile (sex, field_value))\n              {\n                rset->constraints[rset->num_constraints++] = sex;\n              }\n            else\n              {\n                rec_sex_destroy (sex);\n              }\n          }\n      }\n    rec_mset_iterator_free (&iter);\n  }\n}",
      "lines": 72,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_update_size_constraints": {
      "start_point": [
        1134,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "static void\nrec_rset_update_size_constraints (rec_rset_t rset)\n{\n  rec_field_t field;\n  enum rec_size_condition_e condition;\n  size_t size = 0;\n\n  /* Reset the constraints. */\n  rset->min_size = 0;\n  rset->max_size = SIZE_MAX;\n\n  /* Scan the record descriptor for %size: directives, and build the\n     new list.  */\n  if (rset->descriptor)\n    {\n      field = rec_record_get_field_by_name (rset->descriptor,\n                                            FNAME(REC_FIELD_SIZE),\n                                            0);\n\n      if (field && rec_match (rec_field_value (field), REC_INT_SIZE_RE))\n        {\n          /* Extract 'min' and 'max' and update the constraints in the\n             rset.  */\n          condition = rec_extract_size_condition (rec_field_value (field));\n          size = rec_extract_size (rec_field_value (field));\n          \n          /* Set min_size and max_size depending on the\n             condition.  */\n          switch (condition)\n            {\n            case SIZE_COND_E:\n              {\n                rset->min_size = size;\n                rset->max_size = size;\n                break;\n              }\n            case SIZE_COND_L:\n              {\n                rset->max_size = size - 1;\n                break;\n              }\n            case SIZE_COND_LE:\n              {\n                rset->max_size = size;\n                break;\n              }\n            case SIZE_COND_G:\n              {\n                rset->min_size = size + 1;\n                break;\n              }\n            case SIZE_COND_GE:\n              {\n                rset->min_size = size;\n                break;\n              }\n            }\n        }\n    }\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_update_field_props": {
      "start_point": [
        1195,
        0
      ],
      "end_point": [
        1388,
        1
      ],
      "content": "static void\nrec_rset_update_field_props (rec_rset_t rset)\n{\n  rec_rset_fprops_t props = NULL;\n#if defined REC_CRYPT_SUPPORT\n  const char *confidential_field_name;\n#endif\n  char *type_name = NULL;\n\n  /* Reset the field properties.  */\n  props = rset->field_props;\n  while (props)\n    {\n      props->key_p = false;\n      props->auto_p = false;\n      if (props->type)\n        {\n          rec_type_destroy (props->type);\n          props->type = NULL;\n        }\n\n      props = props->next;\n    }\n\n  if (rset->descriptor)\n    {\n      /* Pass 1: scan the record descriptor for % directives, and update\n         the fields properties accordingly.  */\n\n      rec_field_t field;\n      rec_mset_iterator_t iter;\n\n      iter = rec_mset_iterator (rec_record_mset (rset->descriptor));\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, NULL))\n        {\n          const char *field_name = rec_field_name (field);\n          const char *field_value = rec_field_value (field);\n\n          /* Update field types.  Only valid %type: descriptors are\n             considered.  Invalid descriptors are ignored.  */\n\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_TYPE))\n              && rec_rset_type_field_p (field_value))\n            {\n              size_t i;\n              rec_fex_t fex = rec_rset_type_field_fex (field_value);\n\n              for (i = 0; i < rec_fex_size (fex); i++)\n                {\n                  char *field_type = rec_rset_type_field_type (field_value);\n                  rec_type_t type = rec_type_new (field_type);\n\n                  if (!type)\n                    {\n                      /* Set field_type as a field property.  Note\n                         that if the field is already associated with\n                         an anonymous type, or a type name, they are\n                         replaced.  */\n                      \n                      const char *p = field_type;\n                      rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, &type_name);\n                      props = rec_rset_get_props (rset,\n                                                  rec_fex_elem_field_name (rec_fex_get (fex, i)),\n                                                  true);\n                      if (props->type)\n                        {\n                          rec_type_destroy (props->type);\n                          props->type = NULL;\n                        }\n                      free (props->type_name);\n                      props->type_name = type_name;\n                    }\n                  else\n                    {\n                      /* Set the type as a field property.  Note that\n                         if the field is already associated with an\n                         anonymous type, or a type name, they are\n                         replaced.  */\n\n                      props = rec_rset_get_props (rset,\n                                                  rec_fex_elem_field_name (rec_fex_get (fex, i)),\n                                                  true);\n                      if (props->type)\n                        {\n                          rec_type_destroy (props->type);\n                        }\n                      free (props->type_name);\n                      props->type_name = NULL;\n                      props->type = type;\n                    }\n                  \n                  free (field_type);\n                }\n\n              rec_fex_destroy (fex);\n            }\n\n          /* Update the key field.  */\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_KEY)))\n            {\n              /* %key: fields containing incorrect data are\n                  ignored.  */\n\n              const char *field_value = rec_field_value (field);\n              char *type_name = NULL;\n\n              rec_skip_blanks (&field_value);\n              rec_parse_regexp (&field_value, \"^\" REC_RECORD_TYPE_RE, &type_name);\n              props = rec_rset_get_props (rset, type_name, true);\n              props->key_p = true;\n              free (type_name);\n            }\n\n          /* Update auto fields.  */\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_AUTO)))\n            {\n              /* %auto: fields containing incorrect data are\n                  ignored.  */\n\n              rec_fex_t fex = rec_fex_new (rec_field_value (field), REC_FEX_SIMPLE);\n              if (fex)\n                {\n                  size_t i;\n\n                  for (i = 0; i < rec_fex_size (fex); i++)\n                    {\n                      const char *auto_field_name\n                        = rec_fex_elem_field_name (rec_fex_get (fex, i));\n                      props = rec_rset_get_props (rset, auto_field_name, true);\n                      props->auto_p = true;\n                    }\n                }\n            }\n\n          /* Update sort fields.  The last field takes precedence.  */\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_SORT)))\n            {\n              /* Parse the simple fex in the field value.  Invalid\n                 entries are just ignored.  */\n              \n              const char *field_value = rec_field_value (field);\n\n              rec_fex_t fex = rec_fex_new (field_value, REC_FEX_SIMPLE);\n              if (fex)\n                {\n                  rec_fex_destroy (rset->order_by_fields);\n                  rset->order_by_fields = fex;\n                }\n            }\n\n#if defined REC_CRYPT_SUPPORT\n          /* Update confidential fields.  */\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_CONFIDENTIAL)))\n            {\n              /* Parse the field names in the field value.  Ignore\n                 invalid entries.  */\n\n              rec_fex_t fex = rec_fex_new (rec_field_value (field), REC_FEX_SIMPLE);\n              if (fex)\n                {\n                  size_t i;\n\n                  for (i = 0; i < rec_fex_size (fex); i++)\n                    {\n                      confidential_field_name =\n                        rec_fex_elem_field_name (rec_fex_get (fex, i));\n                      props = rec_rset_get_props (rset, confidential_field_name, true);\n                      props->confidential_p = true;\n                    }\n                }\n            }\n#endif /* REC_CRYPT_SUPPORT */\n\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n\n  /* Pass 2: scan the fields having properties on the record set.  */\n\n  props = rset->field_props;\n  while (props)\n    {\n      /* Auto fields not having an explicit type are implicitly\n         typed as integers.  */\n      \n      if (props->auto_p && !props->type && !props->type_name)\n        {\n          props->type = rec_type_new (\"int\");\n        }\n      \n      props = props->next;\n    }\n}",
      "lines": 194,
      "depth": 21,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_update_types": {
      "start_point": [
        1390,
        0
      ],
      "end_point": [
        1461,
        1
      ],
      "content": "static void\nrec_rset_update_types (rec_rset_t rset)\n{\n  rec_field_t field;\n  rec_mset_iterator_t iter;\n  const char *p, *q = NULL;\n  rec_type_t type;\n  char *type_name, *to_type = NULL;\n  \n\n  /* Scan the record descriptor for %typedef directives and update the\n     types registry accordingly.  */\n  if (rset->descriptor)\n    {\n      /* Purge the registry.  */\n\n      rec_type_reg_destroy (rset->type_reg);\n      rset->type_reg = rec_type_reg_new ();\n\n      /* Iterate on the fields of the descriptor.  */\n\n      iter = rec_mset_iterator (rec_record_mset (rset->descriptor));\n      while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n        {\n          const char *field_name = rec_field_name (field);\n          const char *field_value = rec_field_value (field);\n\n          if (rec_field_name_equal_p (field_name, FNAME(REC_FIELD_TYPEDEF)))\n            {\n              p = field_value;\n              rec_skip_blanks (&p);\n\n              /* Get the name of the type.  */\n              if (rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, &type_name))\n                {\n                  /* Get the type.  */\n                  type = rec_type_new (p);\n                  if (type)\n                    {\n                      /* Set the name of the type.  */\n                      rec_type_set_name (type, type_name);\n\n                      /* Create and insert the type in the type\n                         registry.  */\n                      rec_type_reg_add (rset->type_reg, type);\n                    }\n                  else\n                    {\n                      /* This could be a synonym.  Try to parse a type\n                         name and, if the operation succeeds, insert\n                         the synonym in the registry.  */\n                      rec_skip_blanks (&p);\n                      q = p;\n                      if (rec_parse_regexp (&q,\n                                            \"^\" REC_TYPE_NAME_RE \"[ \\t\\n]*\",\n                                            NULL))\n                        {\n                          rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE, &to_type);\n                          rec_type_reg_add_synonym (rset->type_reg,\n                                                    type_name,\n                                                    to_type);\n                        }\n                    }\n                  \n                  free (type_name);\n                }\n            }\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n}",
      "lines": 72,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_rset_type_field_p": {
      "start_point": [
        1463,
        0
      ],
      "end_point": [
        1483,
        1
      ],
      "content": "static bool\nrec_rset_type_field_p (const char *str)\n{\n  const char *p = str;\n\n  /* Check the fex */\n\n  rec_skip_blanks (&p);\n  if (!rec_parse_regexp (&p,\n                         \"^\" REC_FNAME_LIST_CS_RE,\n                         NULL))\n    {\n      return false;\n    }\n  rec_skip_blanks (&p);\n\n  /* Check the type description, or the name of a type.  */\n\n  return (rec_type_descr_p (p)\n          || rec_parse_regexp (&p, \"^\" REC_TYPE_NAME_RE \"[ \\t\\n]*$\", NULL));\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_type_field_fex": {
      "start_point": [
        1485,
        0
      ],
      "end_point": [
        1503,
        1
      ],
      "content": "static rec_fex_t\nrec_rset_type_field_fex (const char *str)\n{\n  rec_fex_t fex = NULL;\n  const char *p;\n  char *name;\n\n  p = str;\n\n  if (rec_parse_regexp (&p,\n                        \"^\" REC_FNAME_LIST_CS_RE,\n                        &name))\n    {\n      fex = rec_fex_new (name, REC_FEX_CSV);\n      free (name);\n    }\n\n  return fex;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "rec_fex_t"
      ]
    },
    "rec_rset_type_field_type": {
      "start_point": [
        1505,
        0
      ],
      "end_point": [
        1524,
        1
      ],
      "content": "static char*\nrec_rset_type_field_type (const char *str)\n{\n  char *result = NULL;\n  const char *p;\n\n  if (rec_rset_type_field_p (str))\n    {\n      p = str;\n\n      rec_skip_blanks (&p);\n      rec_parse_regexp (&p, \"^\" REC_FNAME_LIST_CS_RE, NULL);\n      rec_skip_blanks (&p);\n\n      /* Return the rest of the string.  */\n      result = strdup (p);\n    }\n\n  return result;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nrec_rset_type_field_type (const char *str)",
        "*"
      ]
    },
    "rec_rset_get_props": {
      "start_point": [
        1526,
        0
      ],
      "end_point": [
        1569,
        1
      ],
      "content": "static rec_rset_fprops_t\nrec_rset_get_props (rec_rset_t rset,\n                    const char *fname,\n                    bool create_p)\n{\n  rec_rset_fprops_t props = NULL;\n  \n  props = rset->field_props;\n  while (props)\n    {\n      if (rec_field_name_equal_p (fname, props->fname))\n        {\n          break;\n        }\n\n      props = props->next;\n    }\n\n  if (!props && create_p)\n    {\n      /* Create a new properties structure for this field name and\n         initialize it.  */\n      props = malloc (sizeof (struct rec_rset_fprops_s));\n      if (props)\n        {\n          props->fname = strdup (fname);\n          props->auto_p = false;\n          props->key_p = false;\n\n#if defined REC_CRYPT_SUPPORT\n          props->confidential_p = false;\n#endif\n\n          props->type = NULL;\n          props->type_name = NULL;\n          \n          /* Prepend it to the field properties list.  */\n          props->next = rset->field_props;\n          rset->field_props = props;\n        }\n    }\n\n  return props;\n}",
      "lines": 44,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "rec_rset_fprops_t"
      ]
    },
    "rec_rset_add_auto_field_int": {
      "start_point": [
        1571,
        0
      ],
      "end_point": [
        1635,
        1
      ],
      "content": "static bool\nrec_rset_add_auto_field_int (rec_rset_t rset,\n                             const char *field_name,\n                             rec_record_t record)\n{\n  rec_mset_iterator_t iter;\n  rec_record_t rec;\n  rec_field_t field;\n  size_t num_fields, i;\n  int auto_value, field_value;\n  char *end;\n  char *auto_value_str;\n\n  /* Find the auto value.  */\n\n  auto_value = 0;\n\n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &rec, NULL))\n    {\n      num_fields = rec_record_get_num_fields_by_name (rec, field_name);\n      for (i = 0; i < num_fields; i++)\n        {\n          field = rec_record_get_field_by_name (rec, field_name, i);\n          \n          /* Ignore fields that can't be converted to integer\n             values.  */\n          errno = 0;\n          field_value = strtol (rec_field_value (field), &end, 10);\n          if ((errno == 0) && (*end == '\\0'))\n            {\n              if (auto_value <= field_value)\n                {\n                  auto_value = field_value + 1;\n                }\n            }\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n       \n  /* Create and insert the auto field.  */\n\n  if (asprintf (&auto_value_str, \"%d\", auto_value) != -1)\n    {\n      field = rec_field_new (field_name, auto_value_str);\n      if (!field)\n        {\n          /* Out of memory.  */\n          free (auto_value_str);\n          return false;\n        }\n\n      if (!rec_mset_insert_at (rec_record_mset (record), MSET_FIELD, (void *) field, 0))\n        {\n          /* Out of memory.  */\n          free (auto_value_str);\n          return false;\n        }\n\n      free (auto_value_str);\n    }\n\n  return true;\n}",
      "lines": 65,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_add_auto_field_date": {
      "start_point": [
        1637,
        0
      ],
      "end_point": [
        1670,
        1
      ],
      "content": "static bool\nrec_rset_add_auto_field_date (rec_rset_t rset,\n                              const char *field_name,\n                              rec_record_t record)\n{\n  rec_field_t auto_field;\n  time_t t;\n  char outstr[200];\n  struct tm *tmp;\n\n  t = time (NULL);\n  tmp = localtime (&t);\n\n  setlocale (LC_TIME, \"C\"); /* We want english dates that can be\n                                 parsed with parse_datetime */\n  strftime (outstr, sizeof(outstr), \"%a, %d %b %Y %T %z\", tmp);\n  setlocale (LC_TIME, \"\"); /* And restore the locale from the\n                              environment. */\n\n  auto_field = rec_field_new (field_name, outstr);\n  if (!auto_field)\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  if (!rec_mset_insert_at (rec_record_mset (record), MSET_FIELD, (void *) auto_field, 0))\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  return true;\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_add_auto_field_uuid": {
      "start_point": [
        1674,
        0
      ],
      "end_point": [
        1703,
        1
      ],
      "content": "static bool\nrec_rset_add_auto_field_uuid (rec_rset_t rset,\n                              const char *field_name,\n                              rec_record_t record)\n{\n  rec_field_t auto_field;\n  uuid_t uu;\n  char uu_str[40]; /* Enough to hold any standard UUID.  */\n\n  /* Generate a new time-based UUID using the libuuid library and use\n     it for the value of the new auto field.  */\n\n  uuid_generate_time (uu);\n  uuid_unparse (uu, uu_str);\n  \n  auto_field = rec_field_new (field_name, uu_str);\n  if (!auto_field)\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  if (!rec_mset_insert_at (rec_record_mset (record), MSET_FIELD, (void *) auto_field, 0))\n    {\n      /* Out of memory.  */\n      return false;\n    }\n\n  return true;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_rset_merge_records": {
      "start_point": [
        1707,
        0
      ],
      "end_point": [
        1766,
        1
      ],
      "content": "static rec_record_t\nrec_rset_merge_records (rec_record_t to_record,\n                        rec_record_t from_record,\n                        rec_fex_t    group_by_fields)\n{\n  rec_mset_elem_t elem;\n  void *data;\n  rec_mset_iterator_t iter;\n\n  iter = rec_mset_iterator (rec_record_mset (from_record));\n  while (rec_mset_iterator_next (&iter, MSET_ANY, (const void**) &data, &elem))\n    {\n      if (rec_mset_elem_type (elem) == MSET_FIELD)\n        {\n          rec_field_t field = (rec_field_t) data;\n\n          /* Don't add the field if it is in the list of group-by\n             fields.  */\n\n          if (rec_fex_member_p (group_by_fields, rec_field_name (field), -1, -1))\n            {\n              continue;\n            }\n\n          /* Don't allow duplicated fields in the resulting record\n             generated as a result of this operation.  This is\n             commented out because it fucks up the usage of aggregated\n             functions in grouped-by record sets.  */\n\n          /*         if (rec_record_contains_field (to_record,\n                                         rec_field_name (field),\n                                         rec_field_value (field)))\n            {\n              continue;\n              } */\n\n          /* Ok, add this field.  */\n\n          if (!rec_mset_append (rec_record_mset (to_record),\n                                MSET_FIELD,\n                                (void *) rec_field_dup (field),\n                                MSET_ANY))\n            {\n              /* Out of memory.  */\n              return NULL;\n            }\n        }\n      else\n        {\n          rec_comment_t comment = (rec_comment_t) data;\n          rec_mset_append (rec_record_mset (to_record),\n                           MSET_COMMENT,\n                           (void *) rec_comment_dup (comment),\n                           MSET_ANY);\n        }\n    }\n  rec_mset_iterator_free (&iter);\n\n  return to_record;\n}",
      "lines": 60,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "rec_record_t"
      ]
    },
    "rec_rset_compare_typed_records": {
      "start_point": [
        1768,
        0
      ],
      "end_point": [
        1822,
        1
      ],
      "content": "static int\nrec_rset_compare_typed_records (rec_rset_t rset,\n                                rec_record_t record1,\n                                rec_record_t record2,\n                                rec_fex_t fields)\n{\n  int result = 0;\n  size_t i = 0;\n  size_t num_fields = rec_fex_size (fields);\n\n  for (i = 0; i < num_fields; i++)\n    {\n      rec_fex_elem_t elem       = rec_fex_get (fields, i);\n      const char    *field_name = rec_fex_elem_field_name (elem);\n      rec_field_t    field1     = rec_record_get_field_by_name (record1, field_name, 0);\n      rec_field_t    field2     = rec_record_get_field_by_name (record2, field_name, 0);\n\n      /* If any of the fields is not present in some of the records\n         then that record is considered to be smaller than the record\n         featuring the other one.  */\n\n      if (field1 && !field2)\n        {\n          result = 1; /* field1 > field2 */\n          break;\n        }\n      else if (!field1 && field2)\n        {\n          result = -1;  /* field1 < field2 */\n          break;\n        }\n      else if (!field1 && !field2)\n        {\n          result = -1;  /* field1 < field2 */\n          break;\n        }\n\n      /* A field with such a name exists in both records.  Compare the\n         field typed values.  */\n      \n      result =  rec_type_values_cmp (rec_rset_get_field_type (rset, field_name),\n                                     rec_field_value (field1),\n                                     rec_field_value (field2));\n\n      if (result != 0)\n        {\n          /* Either (a1, a2, ...) < (b1, b2, ...) or (a1, a2, ...) >\n             (b1, b2, ...) */\n          \n          break;\n        }\n    }\n\n  return result;\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-sex-ast.c": {
    "rec_sex_ast_new": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "rec_sex_ast_t\nrec_sex_ast_new ()\n{\n  rec_sex_ast_t new;\n\n  new = malloc (sizeof (struct rec_sex_ast_s));\n  if (new)\n    {\n      new->top = NULL;\n    }\n\n  return new;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "rec_sex_ast_t"
      ]
    },
    "rec_sex_ast_destroy": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nrec_sex_ast_destroy (rec_sex_ast_t ast)\n{\n  if (ast->top)\n    {\n      rec_sex_ast_node_destroy (ast->top);\n    }\n  \n  free (ast);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_new": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "rec_sex_ast_node_t\nrec_sex_ast_node_new (void)\n{\n  rec_sex_ast_node_t new;\n\n  new = malloc (sizeof(struct rec_sex_ast_node_s));\n  if (new)\n    {\n      new->type = REC_SEX_NOVAL;\n      new->num_children = 0;\n      new->index = -1;\n      new->fixed = false;\n      new->fixed_val = NULL;\n    }\n\n  return new;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "rec_sex_ast_node_t"
      ]
    },
    "rec_sex_ast_node_destroy": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\nrec_sex_ast_node_destroy (rec_sex_ast_node_t node)\n{\n  size_t i;\n\n  /* Destroy children.  */\n  for (i = 0; i < node->num_children; i++)\n    {\n      rec_sex_ast_node_destroy (node->children[i]);\n    }\n\n  /* Destroy values.  */\n  if (node->type == REC_SEX_STR)\n    {\n      free (node->val.string);\n    }\n  else if (node->type == REC_SEX_NAME)\n    {\n      free (node->val.name[0]);\n      free (node->val.name[1]);\n    }\n\n  free (node->fixed_val);\n  free (node);\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_type": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "enum rec_sex_ast_node_type_e\nrec_sex_ast_node_type (rec_sex_ast_node_t node)\n{\n  return node->type;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "enum rec_sex_ast_node_type_e",
        "enum",
        "rec_sex_ast_node_type_e"
      ]
    },
    "rec_sex_ast_node_set_type": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_type (rec_sex_ast_node_t node,\n                           enum rec_sex_ast_node_type_e type)\n{\n  node->type = type;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_int": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nrec_sex_ast_node_int (rec_sex_ast_node_t node)\n{\n  return node->val.integer;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "rec_sex_ast_node_set_int": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_int (rec_sex_ast_node_t node,\n                          int num)\n{\n  node->type = REC_SEX_INT;\n  node->val.integer = num;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_real": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "double\nrec_sex_ast_node_real (rec_sex_ast_node_t node)\n{\n  return node->val.real;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "double"
      ]
    },
    "rec_sex_ast_node_set_real": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_real (rec_sex_ast_node_t node,\n                           double num)\n{\n  node->type = REC_SEX_REAL;\n  node->val.real = num;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_str": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "char *\nrec_sex_ast_node_str (rec_sex_ast_node_t node)\n{\n  return node->val.string;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "*\nrec_sex_ast_node_str (rec_sex_ast_node_t node)",
        "*"
      ]
    },
    "rec_sex_ast_node_set_str": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_str (rec_sex_ast_node_t node,\n                          char *str)\n{\n  if (node->type == REC_SEX_STR)\n    {\n      free (node->val.string);\n    }\n\n  node->type = REC_SEX_STR;\n  node->val.string = strdup (str);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_name": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "const char *\nrec_sex_ast_node_name (rec_sex_ast_node_t node)\n{\n  return node->val.name[0];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_sex_ast_node_name (rec_sex_ast_node_t node)",
        "*"
      ]
    },
    "rec_sex_ast_node_subname": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "const char *\nrec_sex_ast_node_subname (rec_sex_ast_node_t node)\n{\n  return node->val.name[1];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_sex_ast_node_subname (rec_sex_ast_node_t node)",
        "*"
      ]
    },
    "rec_sex_ast_node_set_name": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_name (rec_sex_ast_node_t node,\n                           const char *name,\n                           const char *subname)\n{\n  if (node->type == REC_SEX_NAME)\n    {\n      free (node->val.name[0]);\n      free (node->val.name[1]);\n    }\n \n  node->type = REC_SEX_NAME;\n  node->val.name[0] = strdup (name);\n  node->val.name[1] = NULL;\n  if (subname)\n    {\n      node->val.name[1] = strdup (subname);\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_link": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        234,
        1
      ],
      "content": "void\nrec_sex_ast_node_link (rec_sex_ast_node_t parent,\n                       rec_sex_ast_node_t child)\n{\n  if (parent->num_children < REC_SEX_AST_MAX_CHILDREN)\n    {\n      parent->children[parent->num_children++] = child;\n    }\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_top": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        240,
        1
      ],
      "content": "rec_sex_ast_node_t\nrec_sex_ast_top (rec_sex_ast_t ast)\n{\n  return ast->top;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_sex_ast_node_t"
      ]
    },
    "rec_sex_ast_set_top": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "void\nrec_sex_ast_set_top (rec_sex_ast_t ast,\n                     rec_sex_ast_node_t node)\n{\n  ast->top = node;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_print_node": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "void\nrec_sex_ast_print_node (rec_sex_ast_node_t node)\n{\n  int i;\n  \n  for (i = 0; i < node->num_children; i++)\n    {\n      rec_sex_ast_print_node (node->children[i]);\n    }\n\n  printf (\"------- node\\n\");\n  printf (\"type: %d\\n\", node->type);\n  if (node->type == REC_SEX_INT)\n    {\n      printf(\"value: %d\\n\", node->val.integer);\n    }\n  if (node->type == REC_SEX_NAME)\n    {\n      printf(\"value: %s\\n\", node->val.name[0]);\n    }\n  if (node->type == REC_SEX_STR)\n    {\n      printf(\"value: %s\\n\", node->val.string);\n    }\n\n  printf(\"\\n\");\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_num_children": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int\nrec_sex_ast_node_num_children (rec_sex_ast_node_t node)\n{\n  return node->num_children;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_sex_ast_node_child": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        296,
        1
      ],
      "content": "rec_sex_ast_node_t\nrec_sex_ast_node_child (rec_sex_ast_node_t node,\n                        int n)\n{\n  rec_sex_ast_node_t res;\n\n  res = NULL;\n  if (n < node->num_children)\n    {\n      res = node->children[n];\n    }\n\n  return res;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "rec_sex_ast_node_t"
      ]
    },
    "rec_sex_ast_node_reset": {
      "start_point": [
        298,
        0
      ],
      "end_point": [
        309,
        1
      ],
      "content": "void\nrec_sex_ast_node_reset (rec_sex_ast_node_t node)\n{\n  int i;\n\n  for (i = 0; i < node->num_children; i++)\n    {\n      rec_sex_ast_node_reset (node->children[i]);\n    }\n\n  node->index = 0;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_fix": {
      "start_point": [
        311,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "void\nrec_sex_ast_node_fix (rec_sex_ast_node_t node,\n                      char *val)\n{\n  free (node->fixed_val);\n  node->fixed = true;\n  node->fixed_val = strdup (val);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_unfix": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\nrec_sex_ast_node_unfix (rec_sex_ast_node_t node)\n{\n  int i;\n\n  for (i = 0; i < node->num_children; i++)\n    {\n      rec_sex_ast_node_unfix (node->children[i]);\n    }\n\n  node->fixed = false;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_node_fixed": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "bool\nrec_sex_ast_node_fixed (rec_sex_ast_node_t node)\n{\n  return node->fixed;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_ast_node_fixed_val": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "char *\nrec_sex_ast_node_fixed_val (rec_sex_ast_node_t node)\n{\n  return node->fixed_val;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "char",
        "*\nrec_sex_ast_node_fixed_val (rec_sex_ast_node_t node)",
        "*"
      ]
    },
    "rec_sex_ast_node_index": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "int\nrec_sex_ast_node_index (rec_sex_ast_node_t node)\n{\n  return node->index;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "rec_sex_ast_node_set_index": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\nrec_sex_ast_node_set_index (rec_sex_ast_node_t node,\n                            int index)\n{\n  node->index = index;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_print": {
      "start_point": [
        358,
        0
      ],
      "end_point": [
        362,
        1
      ],
      "content": "void\nrec_sex_ast_print (rec_sex_ast_t ast)\n{\n  rec_sex_ast_print_node (ast->top);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_ast_name_p_1": {
      "start_point": [
        364,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "bool\nrec_sex_ast_name_p_1 (rec_sex_ast_node_t node,\n                      const char *name,\n                      size_t idx)\n{\n  size_t i = 0;\n\n  if (node)\n    {\n      if ((node->type == REC_SEX_NAME)\n          && ((node->index == -1) || (node->index < idx))\n          && (strcmp (name, node->val.name[0]) == 0))\n        {\n          return true;\n        }\n\n      for (i = 0; i < node->num_children; i++)\n        {\n          if (rec_sex_ast_name_p_1 (node->children[i], name, idx))\n            {\n              return true;\n            }\n        }\n    }\n\n  return false;\n}",
      "lines": 27,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_ast_name_p": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        403,
        1
      ],
      "content": "bool\nrec_sex_ast_name_p (rec_sex_ast_t ast,\n                    const char *name,\n                    size_t idx)\n{\n  /* Traverse the AST looking for any name node NAME[I] where I <\n     idx.  */\n\n  return rec_sex_ast_name_p_1 (ast->top,\n                               name,\n                               idx);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-sex-ast.h": {},
  "recutils/recutils-1.7/src/rec-sex-lex.c": {
    "yy_get_next_buffer": {
      "start_point": [
        1431,
        0
      ],
      "end_point": [
        1565,
        1
      ],
      "content": "static int yy_get_next_buffer (yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tregister char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;\n\tregister char *source = yyg->yytext_ptr;\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( yyg->yy_c_buf_p - yyg->yytext_ptr - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint yy_c_buf_p_offset =\n\t\t\t\t(int) (yyg->yy_c_buf_p - b->yy_ch_buf);\n\n\t\t\tif ( b->yy_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->yy_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->yy_buf_size += b->yy_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->yy_buf_size *= 2;\n\n\t\t\t\tb->yy_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tsexrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->yy_ch_buf = 0;\n\n\t\t\tif ( ! b->yy_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\tyyg->yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),\n\t\t\tyyg->yy_n_chars, (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tif ( yyg->yy_n_chars == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tsexrestart(yyin  ,yyscanner);\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->yy_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tyy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) sexrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );\n\t}\n\n\tyyg->yy_n_chars += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;\n\n\tyyg->yytext_ptr = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 135,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yy_get_previous_state": {
      "start_point": [
        1572,
        4
      ],
      "end_point": [
        1603,
        1
      ],
      "content": "static yy_state_type yy_get_previous_state (yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister yy_state_type yy_current_state;\n\tregister char *yy_cp;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n/* %% [15.0] code to get the start state into yy_current_state goes here */\n\tyy_current_state = yyg->yy_start;\n\n\tfor ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);\n\t\tif ( yy_accept[yy_current_state] )\n\t\t\t{\n\t\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t\t}\n\t\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t\t{\n\t\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\t\tif ( yy_current_state >= 64 )\n\t\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t\t}\n\t\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\t\t}\n\n\treturn yy_current_state;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "yy_try_NUL_trans": {
      "start_point": [
        1611,
        4
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int yy_is_jam;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */\n/* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *yy_cp = yyg->yy_c_buf_p;\n\n\tregister YY_CHAR yy_c = 1;\n\tif ( yy_accept[yy_current_state] )\n\t\t{\n\t\tyyg->yy_last_accepting_state = yy_current_state;\n\t\tyyg->yy_last_accepting_cpos = yy_cp;\n\t\t}\n\twhile ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )\n\t\t{\n\t\tyy_current_state = (int) yy_def[yy_current_state];\n\t\tif ( yy_current_state >= 64 )\n\t\t\tyy_c = yy_meta[(unsigned int) yy_c];\n\t\t}\n\tyy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];\n\tyy_is_jam = (yy_current_state == 63);\n\n\treturn yy_is_jam ? 0 : yy_current_state;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "yy_state_type"
      ]
    },
    "sexrestart": {
      "start_point": [
        1732,
        4
      ],
      "end_point": [
        1747,
        1
      ],
      "content": "void sexrestart  (FILE * input_file , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! YY_CURRENT_BUFFER ){\n        sexensure_buffer_stack (yyscanner);\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            sex_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);\n\t}\n\n\tsex_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);\n\tsex_load_buffer_state(yyscanner );\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sex_switch_to_buffer": {
      "start_point": [
        1754,
        4
      ],
      "end_point": [
        1787,
        1
      ],
      "content": "void sex_switch_to_buffer  (YY_BUFFER_STATE  new_buffer , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tsexpop_buffer_state();\n\t *\t\tsexpush_buffer_state(new_buffer);\n     */\n\tsexensure_buffer_stack (yyscanner);\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tsex_load_buffer_state(yyscanner );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (sexwrap()) processing, but the only time this flag\n\t * is looked at is after sexwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sex_load_buffer_state": {
      "start_point": [
        1790,
        0
      ],
      "end_point": [
        1800,
        1
      ],
      "content": "static void sex_load_buffer_state  (yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tyyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;\n\tyyg->yytext_ptr = yyg->yy_c_buf_p = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;\n\tyyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;\n\tyyg->yy_hold_char = *yyg->yy_c_buf_p;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sex_create_buffer": {
      "start_point": [
        1809,
        4
      ],
      "end_point": [
        1834,
        1
      ],
      "content": "YY_BUFFER_STATE sex_create_buffer  (FILE * file, int  size , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) sexalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in sex_create_buffer()\" );\n\n\tb->yy_buf_size = size;\n\n\t/* yy_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->yy_ch_buf = (char *) sexalloc(b->yy_buf_size + 2 ,yyscanner );\n\tif ( ! b->yy_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in sex_create_buffer()\" );\n\n\tb->yy_is_our_buffer = 1;\n\n\tsex_init_buffer(b,file ,yyscanner);\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "sex_delete_buffer": {
      "start_point": [
        1841,
        4
      ],
      "end_point": [
        1858,
        1
      ],
      "content": "void sex_delete_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->yy_is_our_buffer )\n\t\tsexfree((void *) b->yy_ch_buf ,yyscanner );\n\n\tsexfree((void *) b ,yyscanner );\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sex_init_buffer": {
      "start_point": [
        1876,
        4
      ],
      "end_point": [
        1907,
        1
      ],
      "content": "static void sex_init_buffer  (YY_BUFFER_STATE  b, FILE * file , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tsex_flush_buffer(b ,yyscanner);\n\n\tb->yy_input_file = file;\n\tb->yy_fill_buffer = 1;\n\n    /* If b is the current buffer, then sex_init_buffer was _probably_\n     * called from sexrestart() or through yy_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->yy_bs_lineno = 1;\n        b->yy_bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sex_flush_buffer": {
      "start_point": [
        1914,
        4
      ],
      "end_point": [
        1939,
        1
      ],
      "content": "void sex_flush_buffer (YY_BUFFER_STATE  b , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif ( ! b )\n\t\treturn;\n\n\tb->yy_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->yy_buf_pos = &b->yy_ch_buf[0];\n\n\tb->yy_at_bol = 1;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tsex_load_buffer_state(yyscanner );\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexpush_buffer_state": {
      "start_point": [
        1949,
        0
      ],
      "end_point": [
        1977,
        1
      ],
      "content": "void sexpush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (new_buffer == NULL)\n\t\treturn;\n\n\tsexensure_buffer_stack(yyscanner);\n\n\t/* This block is copied from sex_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*yyg->yy_c_buf_p = yyg->yy_hold_char;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_buf_pos = yyg->yy_c_buf_p;\n\t\tYY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\tyyg->yy_buffer_stack_top++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from sex_switch_to_buffer. */\n\tsex_load_buffer_state(yyscanner );\n\tyyg->yy_did_buffer_switch_on_eof = 1;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sexpop_buffer_state": {
      "start_point": [
        1986,
        0
      ],
      "end_point": [
        2004,
        1
      ],
      "content": "void sexpop_buffer_state (yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tsex_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif (yyg->yy_buffer_stack_top > 0)\n\t\t--yyg->yy_buffer_stack_top;\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tsex_load_buffer_state(yyscanner );\n\t\tyyg->yy_did_buffer_switch_on_eof = 1;\n\t}\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexensure_buffer_stack": {
      "start_point": [
        2012,
        0
      ],
      "end_point": [
        2057,
        1
      ],
      "content": "static void sexensure_buffer_stack (yyscan_t yyscanner)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n\tif (!yyg->yy_buffer_stack) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)sexalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in sexensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));\n\t\t\t\t\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t\tyyg->yy_buffer_stack_top = 0;\n\t\treturn;\n\t}\n\n\tif (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = yyg->yy_buffer_stack_max + grow_size;\n\t\tyyg->yy_buffer_stack = (struct yy_buffer_state**)sexrealloc\n\t\t\t\t\t\t\t\t(yyg->yy_buffer_stack,\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct yy_buffer_state*)\n\t\t\t\t\t\t\t\t, yyscanner);\n\t\tif ( ! yyg->yy_buffer_stack )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in sexensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset(yyg->yy_buffer_stack + yyg->yy_buffer_stack_max, 0, grow_size * sizeof(struct yy_buffer_state*));\n\t\tyyg->yy_buffer_stack_max = num_to_alloc;\n\t}\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sex_scan_buffer": {
      "start_point": [
        2067,
        0
      ],
      "end_point": [
        2094,
        1
      ],
      "content": "YY_BUFFER_STATE sex_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) sexalloc(sizeof( struct yy_buffer_state ) ,yyscanner );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in sex_scan_buffer()\" );\n\n\tb->yy_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->yy_buf_pos = b->yy_ch_buf = base;\n\tb->yy_is_our_buffer = 0;\n\tb->yy_input_file = 0;\n\tb->yy_n_chars = b->yy_buf_size;\n\tb->yy_is_interactive = 0;\n\tb->yy_at_bol = 1;\n\tb->yy_fill_buffer = 0;\n\tb->yy_buffer_status = YY_BUFFER_NEW;\n\n\tsex_switch_to_buffer(b ,yyscanner );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "sex_scan_string": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2110,
        1
      ],
      "content": "YY_BUFFER_STATE sex_scan_string (yyconst char * yystr , yyscan_t yyscanner)\n{\n    \n\treturn sex_scan_bytes(yystr,strlen(yystr) ,yyscanner);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "sex_scan_bytes": {
      "start_point": [
        2121,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "YY_BUFFER_STATE sex_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tyy_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _yybytes_len + 2;\n\tbuf = (char *) sexalloc(n ,yyscanner );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in sex_scan_bytes()\" );\n\n\tfor ( i = 0; i < _yybytes_len; ++i )\n\t\tbuf[i] = yybytes[i];\n\n\tbuf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = sex_scan_buffer(buf,n ,yyscanner);\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in sex_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->yy_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "yy_fatal_error": {
      "start_point": [
        2157,
        0
      ],
      "end_point": [
        2161,
        1
      ],
      "content": "static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexget_extra": {
      "start_point": [
        2191,
        0
      ],
      "end_point": [
        2195,
        1
      ],
      "content": "YY_EXTRA_TYPE sexget_extra  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyextra;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_EXTRA_TYPE"
      ]
    },
    "sexget_lineno": {
      "start_point": [
        2202,
        0
      ],
      "end_point": [
        2210,
        1
      ],
      "content": "int sexget_lineno  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yylineno;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sexget_column": {
      "start_point": [
        2215,
        0
      ],
      "end_point": [
        2223,
        1
      ],
      "content": "int sexget_column  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    \n        if (! YY_CURRENT_BUFFER)\n            return 0;\n    \n    return yycolumn;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sexget_in": {
      "start_point": [
        2228,
        0
      ],
      "end_point": [
        2232,
        1
      ],
      "content": "FILE *sexget_in  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyin;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "FILE",
        "*sexget_in  (yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexget_out": {
      "start_point": [
        2237,
        0
      ],
      "end_point": [
        2241,
        1
      ],
      "content": "FILE *sexget_out  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyout;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "FILE",
        "*sexget_out  (yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexget_leng": {
      "start_point": [
        2246,
        0
      ],
      "end_point": [
        2250,
        1
      ],
      "content": "int sexget_leng  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yyleng;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sexget_text": {
      "start_point": [
        2256,
        0
      ],
      "end_point": [
        2260,
        1
      ],
      "content": "char *sexget_text  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yytext;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "char",
        "*sexget_text  (yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexset_extra": {
      "start_point": [
        2268,
        0
      ],
      "end_point": [
        2272,
        1
      ],
      "content": "void sexset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyextra = user_defined ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexset_lineno": {
      "start_point": [
        2280,
        0
      ],
      "end_point": [
        2289,
        1
      ],
      "content": "void sexset_lineno (int  line_number , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        /* lineno is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           yy_fatal_error( \"sexset_lineno called with no buffer\" , yyscanner); \n    \n    yylineno = line_number;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexset_column": {
      "start_point": [
        2295,
        0
      ],
      "end_point": [
        2304,
        1
      ],
      "content": "void sexset_column (int  column_no , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n        /* column is only valid if an input buffer exists. */\n        if (! YY_CURRENT_BUFFER )\n           yy_fatal_error( \"sexset_column called with no buffer\" , yyscanner); \n    \n    yycolumn = column_no;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexset_in": {
      "start_point": [
        2312,
        0
      ],
      "end_point": [
        2316,
        1
      ],
      "content": "void sexset_in (FILE *  in_str , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyin = in_str ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexset_out": {
      "start_point": [
        2318,
        0
      ],
      "end_point": [
        2322,
        1
      ],
      "content": "void sexset_out (FILE *  out_str , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yyout = out_str ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexget_debug": {
      "start_point": [
        2324,
        0
      ],
      "end_point": [
        2328,
        1
      ],
      "content": "int sexget_debug  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yy_flex_debug;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "sexset_debug": {
      "start_point": [
        2330,
        0
      ],
      "end_point": [
        2334,
        1
      ],
      "content": "void sexset_debug (int  bdebug , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yy_flex_debug = bdebug ;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexget_lval": {
      "start_point": [
        2343,
        0
      ],
      "end_point": [
        2347,
        1
      ],
      "content": "YYSTYPE * sexget_lval  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    return yylval;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YYSTYPE",
        "* sexget_lval  (yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexset_lval": {
      "start_point": [
        2349,
        0
      ],
      "end_point": [
        2353,
        1
      ],
      "content": "void sexset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    yylval = yylval_param;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexlex_init": {
      "start_point": [
        2364,
        0
      ],
      "end_point": [
        2383,
        1
      ],
      "content": "int sexlex_init(yyscan_t* ptr_yy_globals)\n\n{\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\n    *ptr_yy_globals = (yyscan_t) sexalloc ( sizeof( struct yyguts_t ), NULL );\n\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n\n    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n\n    return yy_init_globals ( *ptr_yy_globals );\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sexlex_init_extra": {
      "start_point": [
        2393,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "int sexlex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )\n\n{\n    struct yyguts_t dummy_yyguts;\n\n    sexset_extra (yy_user_defined, &dummy_yyguts);\n\n    if (ptr_yy_globals == NULL){\n        errno = EINVAL;\n        return 1;\n    }\n\t\n    *ptr_yy_globals = (yyscan_t) sexalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );\n\t\n    if (*ptr_yy_globals == NULL){\n        errno = ENOMEM;\n        return 1;\n    }\n    \n    /* By setting to 0xAA, we expose bugs in\n    yy_init_globals. Leave at 0x00 for releases. */\n    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));\n    \n    sexset_extra (yy_user_defined, *ptr_yy_globals);\n    \n    return yy_init_globals ( *ptr_yy_globals );\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "yy_init_globals": {
      "start_point": [
        2424,
        0
      ],
      "end_point": [
        2455,
        1
      ],
      "content": "static int yy_init_globals (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n    /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from sexlex_destroy(), so don't allocate here.\n     */\n\n    yyg->yy_buffer_stack = 0;\n    yyg->yy_buffer_stack_top = 0;\n    yyg->yy_buffer_stack_max = 0;\n    yyg->yy_c_buf_p = (char *) 0;\n    yyg->yy_init = 0;\n    yyg->yy_start = 0;\n\n    yyg->yy_start_stack_ptr = 0;\n    yyg->yy_start_stack_depth = 0;\n    yyg->yy_start_stack =  NULL;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    yyin = stdin;\n    yyout = stdout;\n#else\n    yyin = (FILE *) 0;\n    yyout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * sexlex_init()\n     */\n    return 0;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sexlex_destroy": {
      "start_point": [
        2460,
        0
      ],
      "end_point": [
        2489,
        1
      ],
      "content": "int sexlex_destroy  (yyscan_t yyscanner)\n{\n    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;\n\n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tsex_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tsexpop_buffer_state(yyscanner);\n\t}\n\n\t/* Destroy the stack itself. */\n\tsexfree(yyg->yy_buffer_stack ,yyscanner);\n\tyyg->yy_buffer_stack = NULL;\n\n    /* Destroy the start condition stack. */\n        sexfree(yyg->yy_start_stack ,yyscanner );\n        yyg->yy_start_stack = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * sexlex() is called, initialization will occur. */\n    yy_init_globals( yyscanner);\n\n/* %if-reentrant */\n    /* Destroy the main struct (reentrant only). */\n    sexfree ( yyscanner , yyscanner );\n    yyscanner = NULL;\n/* %endif */\n    return 0;\n}",
      "lines": 30,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "yy_flex_strncpy": {
      "start_point": [
        2497,
        0
      ],
      "end_point": [
        2502,
        1
      ],
      "content": "static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yy_flex_strlen": {
      "start_point": [
        2506,
        0
      ],
      "end_point": [
        2513,
        1
      ],
      "content": "static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sexalloc": {
      "start_point": [
        2516,
        0
      ],
      "end_point": [
        2519,
        1
      ],
      "content": "void *sexalloc (yy_size_t  size , yyscan_t yyscanner)\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*sexalloc (yy_size_t  size , yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexrealloc": {
      "start_point": [
        2521,
        0
      ],
      "end_point": [
        2531,
        1
      ],
      "content": "void *sexrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*sexrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)",
        "*"
      ]
    },
    "sexfree": {
      "start_point": [
        2533,
        0
      ],
      "end_point": [
        2536,
        1
      ],
      "content": "void sexfree (void * ptr , yyscan_t yyscanner)\n{\n\tfree( (char *) ptr );\t/* see sexrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_lex_extract_name": {
      "start_point": [
        2549,
        0
      ],
      "end_point": [
        2568,
        1
      ],
      "content": "char *\nrec_sex_lex_extract_name (char *str)\n{\n  size_t size;\n  char *res;\n  char *p;\n\n  p = str;\n  while ((*p != '[') && (*p != '.') && (*p != 0))\n    {\n      p++;\n    }\n\n  size = p - str;\n  res = malloc (size + 1);\n  memcpy (res, str, size);\n  res[size] = 0;\n\n  return res;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrec_sex_lex_extract_name (char *str)",
        "*"
      ]
    },
    "rec_sex_lex_extract_subname": {
      "start_point": [
        2570,
        0
      ],
      "end_point": [
        2593,
        1
      ],
      "content": "char *\nrec_sex_lex_extract_subname (char *str)\n{\n  char *p;\n\n  /* If there is not a subname denoted in STR then this function\n     returns NULL.  */\n  \n  p = str;\n  while ((*p != '.') && (*p != '\\0'))\n    {\n      p++;\n    }\n\n  if (*p == '\\0')\n    {\n      /* There is not a second name.  */\n      return NULL;\n    }\n\n  p++;  /* Skip the dot separator.  */\n\n  return rec_sex_lex_extract_name (p);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "char",
        "*\nrec_sex_lex_extract_subname (char *str)",
        "*"
      ]
    },
    "rec_sex_lex_extract_index": {
      "start_point": [
        2595,
        0
      ],
      "end_point": [
        2637,
        1
      ],
      "content": "bool\nrec_sex_lex_extract_index (char *str,\n                           int *num)\n{\n  bool res;\n  char *p;\n  char aux[100];\n  int aux_size;\n\n  /* Note that this function assumes syntax correctness in STR if a\n     '[' is found.  */  \n\n  aux_size = 0;\n  p = str;\n  while ((*p != 0) && (*p != '['))\n    {\n      p++;\n    }\n\n  if (*p == 0)\n    {\n      res = false;\n    }\n  else\n    {\n      p++; /* Pass the [.  */\n      while (*p != ']')\n        {\n          aux[aux_size++] = *p;\n          p++;\n        }\n      aux[aux_size] = 0;\n\n      if (!rec_atoi (aux, num))\n        {\n          res = false;\n        }\n\n      res = true;\n    }\n\n  return res;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-sex-lex.l": {
    "rec_sex_lex_extract_index": [
      {
        "start_point": [
          70,
          0
        ],
        "end_point": [
          94,
          1
        ],
        "content": "NEWLINE            \\n\nBLANK              [ \\t\\n]\nDIGIT              [0-9]\nLETTER             [a-zA-Z]\nFIELD_NAME         {LETTER}[a-zA-Z0-9_]*\nSTRING             '([^']|\\\\(.|\\n))*'|\\\"([^\"]|\\\\(.|\\n))*\\\"\n\n/* Please do not touch this comment' */\n\n%%\n\n{BLANK}  { /* Ignore whitespace */ }\n\n\"-\"?{DIGIT}*\\.{DIGIT}+ {\n  /*\n   * Create a real node.\n   */\n  double real_value;\n  \n  yylval->node = rec_sex_ast_node_new ();\n  rec_atod (yytext, &real_value);\n  rec_sex_ast_node_set_real (yylval->node, real_value);\n\n  return REC_SEX_TOK_REAL;\n}",
        "lines": 25,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          222,
          0
        ],
        "end_point": [
          264,
          1
        ],
        "content": "bool\nrec_sex_lex_extract_index (char *str,\n                           int *num)\n{\n  bool res;\n  char *p;\n  char aux[100];\n  int aux_size;\n\n  /* Note that this function assumes syntax correctness in STR if a\n     '[' is found.  */  \n\n  aux_size = 0;\n  p = str;\n  while ((*p != 0) && (*p != '['))\n    {\n      p++;\n    }\n\n  if (*p == 0)\n    {\n      res = false;\n    }\n  else\n    {\n      p++; /* Pass the [.  */\n      while (*p != ']')\n        {\n          aux[aux_size++] = *p;\n          p++;\n        }\n      aux[aux_size] = 0;\n\n      if (!rec_atoi (aux, num))\n        {\n          res = false;\n        }\n\n      res = true;\n    }\n\n  return res;\n}",
        "lines": 43,
        "depth": 11,
        "decorators": [
          "bool"
        ]
      }
    ]
  },
  "recutils/recutils-1.7/src/rec-sex-parser.c": {
    "rec_sex_parser_new": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "rec_sex_parser_t\nrec_sex_parser_new (void)\n{\n  rec_sex_parser_t new;\n\n  new = malloc (sizeof (struct rec_sex_parser_s));\n  if (new)\n    {\n      new->in = NULL;\n      new->index = 0;\n      new->case_insensitive = false;\n\n      /* Initialize the sexy scanner.  */\n      sexlex_init (&(new->scanner));\n      sexset_extra (new, new->scanner);\n    }\n\n  return new;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "rec_sex_parser_t"
      ]
    },
    "rec_sex_parser_scanner": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void *\nrec_sex_parser_scanner (rec_sex_parser_t parser)\n{\n  return parser->scanner;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void",
        "*\nrec_sex_parser_scanner (rec_sex_parser_t parser)",
        "*"
      ]
    },
    "rec_sex_parser_destroy": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nrec_sex_parser_destroy (rec_sex_parser_t parser)\n{\n  if (parser->scanner)\n    {\n      sexlex_destroy (parser->scanner);\n    }\n\n  free (parser->in);\n  free (parser);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_parser_ast": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "rec_sex_ast_t\nrec_sex_parser_ast (rec_sex_parser_t parser)\n{\n  return parser->ast;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "rec_sex_ast_t"
      ]
    },
    "rec_sex_parser_set_ast": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\nrec_sex_parser_set_ast (rec_sex_parser_t parser,\n                        rec_sex_ast_t ast)\n{\n  parser->ast = ast;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_parser_case_insensitive": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "bool\nrec_sex_parser_case_insensitive (rec_sex_parser_t parser)\n{\n  return parser->case_insensitive;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_parser_set_case_insensitive": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nrec_sex_parser_set_case_insensitive (rec_sex_parser_t parser,\n                                     bool case_insensitive)\n{\n  parser->case_insensitive = case_insensitive;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_parser_set_in": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nrec_sex_parser_set_in (rec_sex_parser_t parser,\n                       const char *str)\n{\n  if (parser->in)\n    {\n      free (parser->in);\n      parser->in = NULL;\n    }\n\n  parser->in = strdup (str);\n  parser->index = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_parser_getc": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        144,
        1
      ],
      "content": "int\nrec_sex_parser_getc (rec_sex_parser_t parser)\n{\n  int res;\n\n  res = -1;\n  if ((parser->in)\n      && (parser->index < strlen (parser->in)))\n    {\n      res = parser->in[parser->index++];\n    }\n\n  return res;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "rec_sex_parser_run": {
      "start_point": [
        146,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "bool\nrec_sex_parser_run (rec_sex_parser_t parser,\n                    const char *expr)\n{\n  int res;\n\n  rec_sex_parser_set_in (parser, expr);\n  if (!sexparse (parser))\n    {\n      res = true;\n    }\n  else\n    {\n      /* Parse error.  */\n      res = false;\n    }\n\n  return res;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_parser_print_ast": {
      "start_point": [
        166,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nrec_sex_parser_print_ast (rec_sex_parser_t parser)\n{\n  rec_sex_ast_print (parser->ast);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-sex-parser.h": {},
  "recutils/recutils-1.7/src/rec-sex-tab.c": {
    "sexerror": {
      "start_point": [
        90,
        2
      ],
      "end_point": [
        93,
        3
      ],
      "content": "void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "yytnamerr": {
      "start_point": [
        1050,
        0
      ],
      "end_point": [
        1087,
        1
      ],
      "content": "static YYSIZE_T\nyytnamerr (char *yyres, const char *yystr)\n{\n  if (*yystr == '\"')\n    {\n      YYSIZE_T yyn = 0;\n      char const *yyp = yystr;\n\n      for (;;)\n\tswitch (*++yyp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++yyp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (yyres)\n\t      yyres[yyn] = *yyp;\n\t    yyn++;\n\t    break;\n\n\t  case '\"':\n\t    if (yyres)\n\t      yyres[yyn] = '\\0';\n\t    return yyn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! yyres)\n    return yystrlen (yystr);\n\n  return yystpcpy (yyres, yystr) - yyres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "yysyntax_error": {
      "start_point": [
        1098,
        0
      ],
      "end_point": [
        1224,
        1
      ],
      "content": "static int\nyysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,\n                yytype_int16 *yyssp, int yytoken)\n{\n  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);\n  YYSIZE_T yysize = yysize0;\n  YYSIZE_T yysize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *yyformat = 0;\n  /* Arguments of yyformat. */\n  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int yycount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in yychar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated yychar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (yytoken != YYEMPTY)\n    {\n      int yyn = yypact[*yyssp];\n      yyarg[yycount++] = yytname[yytoken];\n      if (!yypact_value_is_default (yyn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int yyxbegin = yyn < 0 ? -yyn : 0;\n          /* Stay within bounds of both yycheck and yytname.  */\n          int yychecklim = YYLAST - yyn + 1;\n          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;\n          int yyx;\n\n          for (yyx = yyxbegin; yyx < yyxend; ++yyx)\n            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR\n                && !yytable_value_is_error (yytable[yyx + yyn]))\n              {\n                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    yycount = 1;\n                    yysize = yysize0;\n                    break;\n                  }\n                yyarg[yycount++] = yytname[yyx];\n                yysize1 = yysize + yytnamerr (0, yytname[yyx]);\n                if (! (yysize <= yysize1\n                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                yysize = yysize1;\n              }\n        }\n    }\n\n  switch (yycount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        yyformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  yysize1 = yysize + yystrlen (yyformat);\n  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  yysize = yysize1;\n\n  if (*yymsg_alloc < yysize)\n    {\n      *yymsg_alloc = 2 * yysize;\n      if (! (yysize <= *yymsg_alloc\n             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *yyp = *yymsg;\n    int yyi = 0;\n    while ((*yyp = *yyformat) != '\\0')\n      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)\n        {\n          yyp += yytnamerr (yyp, yyarg[yyi++]);\n          yyformat += 2;\n        }\n      else\n        {\n          yyp++;\n          yyformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-sex-tab.h": {},
  "recutils/recutils-1.7/src/rec-sex-tab.y": {
    "sexerror": [
      {
        "start_point": [
          27,
          14
        ],
        "end_point": [
          133,
          43
        ],
        "content": "rec_sex_parser_t sex_parser}\n%lex-param { void *scanner }\n\n%{\n  #include <config.h>\n\n  #include <stdlib.h>\n  #include <stdio.h>\n  #include <string.h>\n  #include <regex.h>\n\n  #include <rec-sex-ast.h>\n  #include <rec-sex-parser.h>\n  #include \"rec-sex-tab.h\"\n  /*  #include \"rec-sex-lex.h\" */\n\n  void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }\n\n  #define scanner (rec_sex_parser_scanner (sex_parser))\n\n  #define CREATE_NODE_OP1(TYPE,RES,OP)                  \\\n    do                                                  \\\n      {                                                 \\\n        /* Create the node.  */                         \\\n        (RES) = rec_sex_ast_node_new ();                \\\n        rec_sex_ast_node_set_type ((RES), (TYPE));      \\\n                                                        \\\n        /* Set children. */                             \\\n        rec_sex_ast_node_link ((RES), (OP));            \\\n      }                                                 \\\n    while (0)\n\n#define CREATE_NODE_OP2(TYPE, RES, OP1, OP2)            \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n        }                                               \\\n     while (0)\n\n#define CREATE_NODE_OP3(TYPE, RES, OP1, OP2, OP3)       \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n          rec_sex_ast_node_link ((RES), (OP3));         \\\n        }                                               \\\n     while (0)\n  \n%}\n\n%union {\n  rec_sex_ast_node_t node;\n  rec_sex_ast_t ast;\n};\n\n/* Bison declarations.  */\n\n%token <node> REC_SEX_TOK_INT\n%token <node> REC_SEX_TOK_REAL\n%token <node> REC_SEX_TOK_STR\n%token <node> REC_SEX_TOK_NAM\n%token <node> REC_SEX_TOK_COLON\n%left <node> REC_SEX_TOK_QM\n%right <node> REC_SEX_TOK_IMPLIES\n%left <node> REC_SEX_TOK_AND REC_SEX_TOK_OR\n%left <node> REC_SEX_TOK_EQL REC_SEX_TOK_NEQ REC_SEX_TOK_LT REC_SEX_TOK_GT REC_SEX_TOK_LTE REC_SEX_TOK_GTE\n%left <node> REC_SEX_TOK_SAMETIME REC_SEX_TOK_AFTER REC_SEX_TOK_BEFORE\n%left <node> REC_SEX_TOK_SUB REC_SEX_TOK_ADD\n%left <node> REC_SEX_TOK_MUL REC_SEX_TOK_DIV REC_SEX_TOK_MOD REC_SEX_TOK_MAT\n%left <node> REC_SEX_TOK_AMP\n%left <node> REC_SEX_TOK_NEG  REC_SEX_TOK_MIN /* negation--unary minus */\n%right <node> REC_SEX_TOK_NOT\n%token <node> REC_SEX_TOK_BP REC_SEX_TOK_EP\n%token <node> REC_SEX_TOK_ERR\n%token <node> REC_SEX_TOK_SHARP\n\n%type <ast> input\n%type <node> exp\n\n%% /* The grammar follows.  */\n\ninput: \n     exp\n     {\n       rec_sex_ast_t ast;\n\n       ast = rec_sex_ast_new ();\n       rec_sex_ast_set_top (ast, $1);\n       rec_sex_parser_set_ast (sex_parser, ast);\n     }\n     ;\n\nexp : REC_SEX_TOK_INT          { $$ = $1; }",
        "lines": 107,
        "depth": 20,
        "decorators": [
          "rec_sex_parser_t",
          "sex_parser}\n%lex-",
          "sex_parser",
          "}",
          "%",
          "lex",
          "-",
          "param",
          "{ void *scanner }\n\n%{\n  #include <config.h>\n\n  #include <stdlib.h>\n  #include <stdio.h>\n  #include <string.h>\n  #include <regex.h>\n\n  #include <rec-sex-ast.h>\n  #include <rec-sex-parser.h>\n  #include \"rec-sex-tab.h\"\n  /*  #include \"rec-sex-lex.h\" */\n\n  void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }\n\n  #define scanner (rec_sex_parser_scanner (sex_parser))\n\n  #define CREATE_NODE_OP1(TYPE,RES,OP)                  \\\n    do                                                  \\\n      {                                                 \\\n        /* Create the node.  */                         \\\n        (RES) = rec_sex_ast_node_new ();                \\\n        rec_sex_ast_node_set_type ((RES), (TYPE));      \\\n                                                        \\\n        /* Set children. */                             \\\n        rec_sex_ast_node_link ((RES), (OP));            \\\n      }                                                 \\\n    while (0)\n\n#define CREATE_NODE_OP2(TYPE, RES, OP1, OP2)            \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n        }                                               \\\n     while (0)\n\n#define CREATE_NODE_OP3(TYPE, RES, OP1, OP2, OP3)       \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n          rec_sex_ast_node_link ((RES), (OP3));         \\\n        }                                               \\\n     while (0)\n  \n%}\n\n%union {\n  rec_sex_ast_node_t node;\n  rec_sex_ast_t ast;\n};\n\n/* Bison declarations.  */\n\n%token <node> REC_SEX_TOK_INT\n%token <node> REC_SEX_TOK_REAL\n%token <node> REC_SEX_TOK_STR\n%token <node> REC_SEX_TOK_NAM\n%token <node> REC_SEX_TOK_COLON\n%left <node> REC_SEX_TOK_QM\n%right <node> REC_SEX_TOK_IMPLIES\n%left <node> REC_SEX_TOK_AND REC_SEX_TOK_OR\n%left <node> REC_SEX_TOK_EQL REC_SEX_TOK_NEQ REC_SEX_TOK_LT REC_SEX_TOK_GT REC_SEX_TOK_LTE REC_SEX_TOK_GTE\n%left <node> REC_SEX_TOK_SAMETIME REC_SEX_TOK_AFTER REC_SEX_TOK_BEFORE\n%left <node> REC_SEX_TOK_SUB REC_SEX_TOK_ADD\n%left <node> REC_SEX_TOK_MUL REC_SEX_TOK_DIV REC_SEX_TOK_MOD REC_SEX_TOK_MAT\n%left <node> REC_SEX_TOK_AMP\n%left <node> REC_SEX_TOK_NEG  REC_SEX_TOK_MIN /* negation--unary minus */\n%right <node> REC_SEX_TOK_NOT\n%token <node> REC_SEX_TOK_BP REC_SEX_TOK_EP\n%token <node> REC_SEX_TOK_ERR\n%token <node> REC_SEX_TOK_SHARP\n\n%type <ast> input\n%type <node> exp\n\n%% /* The grammar follows.  */\n\ninput: \n     exp\n     {\n       rec_sex_ast_t ast;\n\n       ast = rec_sex_ast_new ();\n       rec_sex_ast_set_top (ast, $1);\n       rec_sex_parser_set_ast (sex_parser, ast);\n     }\n     ;\n\nexp : REC_SEX_TOK_INT          { $$ = $1; }",
          "{",
          "void",
          "*scanner",
          "*",
          "scanner",
          "}\n\n%",
          "}",
          "%",
          "{\n  #include <config.h>\n\n  #include <stdlib.h>\n  #include <stdio.h>\n  #include <string.h>\n  #include <regex.h>\n\n  #include <rec-sex-ast.h>\n  #include <rec-sex-parser.h>\n  #include \"rec-sex-tab.h\"\n  /*  #include \"rec-sex-lex.h\" */\n\n  void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }\n\n  #define scanner (rec_sex_parser_scanner (sex_parser))\n\n  #define CREATE_NODE_OP1(TYPE,RES,OP)                  \\\n    do                                                  \\\n      {                                                 \\\n        /* Create the node.  */                         \\\n        (RES) = rec_sex_ast_node_new ();                \\\n        rec_sex_ast_node_set_type ((RES), (TYPE));      \\\n                                                        \\\n        /* Set children. */                             \\\n        rec_sex_ast_node_link ((RES), (OP));            \\\n      }                                                 \\\n    while (0)\n\n#define CREATE_NODE_OP2(TYPE, RES, OP1, OP2)            \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n        }                                               \\\n     while (0)\n\n#define CREATE_NODE_OP3(TYPE, RES, OP1, OP2, OP3)       \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n          rec_sex_ast_node_link ((RES), (OP3));         \\\n        }                                               \\\n     while (0)\n  \n%}",
          "{",
          "#include <config.h>\n\n",
          "#include",
          "<config.h>",
          "\n\n",
          "#include <stdlib.h>\n",
          "#include",
          "<stdlib.h>",
          "\n",
          "#include <stdio.h>\n",
          "#include",
          "<stdio.h>",
          "\n",
          "#include <string.h>\n",
          "#include",
          "<string.h>",
          "\n",
          "#include <regex.h>\n\n",
          "#include",
          "<regex.h>",
          "\n\n",
          "#include <rec-sex-ast.h>\n",
          "#include",
          "<rec-sex-ast.h>",
          "\n",
          "#include <rec-sex-parser.h>\n",
          "#include",
          "<rec-sex-parser.h>",
          "\n",
          "#include \"rec-sex-tab.h\"\n",
          "#include",
          "\"rec-sex-tab.h\"",
          "\"",
          "\"",
          "\n",
          "/*  #include \"rec-sex-lex.h\" */",
          "void"
        ]
      },
      {
        "start_point": [
          28,
          13
        ],
        "end_point": [
          89,
          2
        ],
        "content": "void *scanner }\n\n%{\n  #include <config.h>\n\n  #include <stdlib.h>\n  #include <stdio.h>\n  #include <string.h>\n  #include <regex.h>\n\n  #include <rec-sex-ast.h>\n  #include <rec-sex-parser.h>\n  #include \"rec-sex-tab.h\"\n  /*  #include \"rec-sex-lex.h\" */\n\n  void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }\n\n  #define scanner (rec_sex_parser_scanner (sex_parser))\n\n  #define CREATE_NODE_OP1(TYPE,RES,OP)                  \\\n    do                                                  \\\n      {                                                 \\\n        /* Create the node.  */                         \\\n        (RES) = rec_sex_ast_node_new ();                \\\n        rec_sex_ast_node_set_type ((RES), (TYPE));      \\\n                                                        \\\n        /* Set children. */                             \\\n        rec_sex_ast_node_link ((RES), (OP));            \\\n      }                                                 \\\n    while (0)\n\n#define CREATE_NODE_OP2(TYPE, RES, OP1, OP2)            \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n        }                                               \\\n     while (0)\n\n#define CREATE_NODE_OP3(TYPE, RES, OP1, OP2, OP3)       \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n          rec_sex_ast_node_link ((RES), (OP3));         \\\n        }                                               \\\n     while (0)\n  \n%}",
        "lines": 62,
        "depth": 8,
        "decorators": [
          "void",
          "*scanner",
          "*",
          "scanner",
          "}\n\n%",
          "}",
          "%",
          "{\n  #include <config.h>\n\n  #include <stdlib.h>\n  #include <stdio.h>\n  #include <string.h>\n  #include <regex.h>\n\n  #include <rec-sex-ast.h>\n  #include <rec-sex-parser.h>\n  #include \"rec-sex-tab.h\"\n  /*  #include \"rec-sex-lex.h\" */\n\n  void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }\n\n  #define scanner (rec_sex_parser_scanner (sex_parser))\n\n  #define CREATE_NODE_OP1(TYPE,RES,OP)                  \\\n    do                                                  \\\n      {                                                 \\\n        /* Create the node.  */                         \\\n        (RES) = rec_sex_ast_node_new ();                \\\n        rec_sex_ast_node_set_type ((RES), (TYPE));      \\\n                                                        \\\n        /* Set children. */                             \\\n        rec_sex_ast_node_link ((RES), (OP));            \\\n      }                                                 \\\n    while (0)\n\n#define CREATE_NODE_OP2(TYPE, RES, OP1, OP2)            \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n        }                                               \\\n     while (0)\n\n#define CREATE_NODE_OP3(TYPE, RES, OP1, OP2, OP3)       \\\n      do                                                \\\n        {                                               \\\n          /* Create the node.  */                       \\\n          (RES) = rec_sex_ast_node_new ();              \\\n          rec_sex_ast_node_set_type ((RES), (TYPE));    \\\n                                                        \\\n          /* Set children. */                           \\\n          rec_sex_ast_node_link ((RES), (OP1));         \\\n          rec_sex_ast_node_link ((RES), (OP2));         \\\n          rec_sex_ast_node_link ((RES), (OP3));         \\\n        }                                               \\\n     while (0)\n  \n%}",
          "{",
          "#include <config.h>\n\n",
          "#include",
          "<config.h>",
          "\n\n",
          "#include <stdlib.h>\n",
          "#include",
          "<stdlib.h>",
          "\n",
          "#include <stdio.h>\n",
          "#include",
          "<stdio.h>",
          "\n",
          "#include <string.h>\n",
          "#include",
          "<string.h>",
          "\n",
          "#include <regex.h>\n\n",
          "#include",
          "<regex.h>",
          "\n\n",
          "#include <rec-sex-ast.h>\n",
          "#include",
          "<rec-sex-ast.h>",
          "\n",
          "#include <rec-sex-parser.h>\n",
          "#include",
          "<rec-sex-parser.h>",
          "\n",
          "#include \"rec-sex-tab.h\"\n",
          "#include",
          "\"rec-sex-tab.h\"",
          "\"",
          "\"",
          "\n",
          "/*  #include \"rec-sex-lex.h\" */",
          "void"
        ]
      },
      {
        "start_point": [
          43,
          2
        ],
        "end_point": [
          46,
          3
        ],
        "content": "void sexerror (rec_sex_parser_t context, const char *err)\n  {\n    /* Do nothing.  */\n  }",
        "lines": 4,
        "depth": 6,
        "decorators": [
          "void"
        ]
      }
    ],
    "REC_SEX_TOK_LTE": {
      "start_point": [
        107,
        34
      ],
      "end_point": [
        130,
        6
      ],
      "content": "REC_SEX_TOK_AFTER REC_SEX_TOK_BEFORE\n%left <node> REC_SEX_TOK_SUB REC_SEX_TOK_ADD\n%left <node> REC_SEX_TOK_MUL REC_SEX_TOK_DIV REC_SEX_TOK_MOD REC_SEX_TOK_MAT\n%left <node> REC_SEX_TOK_AMP\n%left <node> REC_SEX_TOK_NEG  REC_SEX_TOK_MIN /* negation--unary minus */\n%right <node> REC_SEX_TOK_NOT\n%token <node> REC_SEX_TOK_BP REC_SEX_TOK_EP\n%token <node> REC_SEX_TOK_ERR\n%token <node> REC_SEX_TOK_SHARP\n\n%type <ast> input\n%type <node> exp\n\n%% /* The grammar follows.  */\n\ninput: \n     exp\n     {\n       rec_sex_ast_t ast;\n\n       ast = rec_sex_ast_new ();\n       rec_sex_ast_set_top (ast, $1);\n       rec_sex_parser_set_ast (sex_parser, ast);\n     }",
      "lines": 24,
      "depth": 7,
      "decorators": null
    },
    "REC_SEX_TOK_QM": [
      {
        "start_point": [
          137,
          25
        ],
        "end_point": [
          138,
          85
        ],
        "content": "exp REC_SEX_TOK_COLON exp\n                               { CREATE_NODE_OP3 (REC_SEX_OP_COND, $$, $1, $3, $5); }",
        "lines": 2,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          139,
          6
        ],
        "end_point": [
          139,
          80
        ],
        "content": "exp REC_SEX_TOK_EQL exp  { CREATE_NODE_OP2 (REC_SEX_OP_EQL, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          140,
          6
        ],
        "end_point": [
          140,
          80
        ],
        "content": "exp REC_SEX_TOK_NEQ exp  { CREATE_NODE_OP2 (REC_SEX_OP_NEQ, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          141,
          6
        ],
        "end_point": [
          152,
          5
        ],
        "content": "exp REC_SEX_TOK_MAT exp  \n    {\n      if ((rec_sex_ast_node_type ($1) == REC_SEX_INT)\n          || (rec_sex_ast_node_type ($3) == REC_SEX_INT))\n        {\n           rec_sex_ast_node_destroy ($1);\n           rec_sex_ast_node_destroy ($3);\n           YYABORT;\n        }\n\n      CREATE_NODE_OP2 (REC_SEX_OP_MAT, $$, $1, $3);\n    }",
        "lines": 12,
        "depth": 8,
        "decorators": null
      },
      {
        "start_point": [
          153,
          6
        ],
        "end_point": [
          153,
          80
        ],
        "content": "exp REC_SEX_TOK_ADD exp  { CREATE_NODE_OP2 (REC_SEX_OP_ADD, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          154,
          6
        ],
        "end_point": [
          154,
          80
        ],
        "content": "exp REC_SEX_TOK_SUB exp  { CREATE_NODE_OP2 (REC_SEX_OP_SUB, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          155,
          6
        ],
        "end_point": [
          155,
          80
        ],
        "content": "exp REC_SEX_TOK_MUL exp  { CREATE_NODE_OP2 (REC_SEX_OP_MUL, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          156,
          6
        ],
        "end_point": [
          156,
          80
        ],
        "content": "exp REC_SEX_TOK_DIV exp  { CREATE_NODE_OP2 (REC_SEX_OP_DIV, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          157,
          6
        ],
        "end_point": [
          157,
          80
        ],
        "content": "exp REC_SEX_TOK_MOD exp  { CREATE_NODE_OP2 (REC_SEX_OP_MOD, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          158,
          6
        ],
        "end_point": [
          158,
          79
        ],
        "content": "exp REC_SEX_TOK_GT exp   { CREATE_NODE_OP2 (REC_SEX_OP_GT, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          159,
          6
        ],
        "end_point": [
          159,
          79
        ],
        "content": "exp REC_SEX_TOK_LT exp   { CREATE_NODE_OP2 (REC_SEX_OP_LT, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          160,
          6
        ],
        "end_point": [
          160,
          80
        ],
        "content": "exp REC_SEX_TOK_GTE exp  { CREATE_NODE_OP2 (REC_SEX_OP_GTE, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          161,
          6
        ],
        "end_point": [
          161,
          80
        ],
        "content": "exp REC_SEX_TOK_LTE exp  { CREATE_NODE_OP2 (REC_SEX_OP_LTE, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          162,
          6
        ],
        "end_point": [
          162,
          83
        ],
        "content": "exp REC_SEX_TOK_AFTER exp { CREATE_NODE_OP2 (REC_SEX_OP_AFTER, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          163,
          6
        ],
        "end_point": [
          163,
          85
        ],
        "content": "exp REC_SEX_TOK_BEFORE exp { CREATE_NODE_OP2 (REC_SEX_OP_BEFORE, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          164,
          6
        ],
        "end_point": [
          164,
          89
        ],
        "content": "exp REC_SEX_TOK_SAMETIME exp { CREATE_NODE_OP2 (REC_SEX_OP_SAMETIME, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          165,
          6
        ],
        "end_point": [
          165,
          88
        ],
        "content": "exp REC_SEX_TOK_IMPLIES exp  { CREATE_NODE_OP2 (REC_SEX_OP_IMPLIES, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          166,
          6
        ],
        "end_point": [
          166,
          76
        ],
        "content": "REC_SEX_TOK_NOT exp      { CREATE_NODE_OP1 (REC_SEX_OP_NOT, $$, $2); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          167,
          6
        ],
        "end_point": [
          167,
          80
        ],
        "content": "exp REC_SEX_TOK_AND exp  { CREATE_NODE_OP2 (REC_SEX_OP_AND, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          168,
          6
        ],
        "end_point": [
          168,
          79
        ],
        "content": "exp REC_SEX_TOK_OR exp   { CREATE_NODE_OP2 (REC_SEX_OP_OR, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          169,
          6
        ],
        "end_point": [
          169,
          83
        ],
        "content": "exp REC_SEX_TOK_AMP exp  { CREATE_NODE_OP2 (REC_SEX_OP_CONCAT, $$, $1, $3); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          170,
          6
        ],
        "end_point": [
          170,
          88
        ],
        "content": "REC_SEX_TOK_SHARP REC_SEX_TOK_NAM    { CREATE_NODE_OP1 (REC_SEX_OP_SHA, $$, $2); }",
        "lines": 1,
        "depth": 7,
        "decorators": null
      },
      {
        "start_point": [
          171,
          6
        ],
        "end_point": [
          171,
          52
        ],
        "content": "REC_SEX_TOK_BP exp REC_SEX_TOK_EP { $$ = $2; }",
        "lines": 1,
        "depth": 4,
        "decorators": null
      }
    ]
  },
  "recutils/recutils-1.7/src/rec-sex.c": {
    "rec_sex_new": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "rec_sex_t\nrec_sex_new (bool case_insensitive)\n{\n  rec_sex_t new;\n\n  new = malloc (sizeof (struct rec_sex_s));\n  if (new)\n    {\n      /* Initialize a new parser.  */\n      new->parser = rec_sex_parser_new ();\n      rec_sex_parser_set_case_insensitive (new->parser,\n                                           case_insensitive);\n\n      /* Initialize a new AST.  */\n      new->ast = NULL;\n    }\n\n  return new;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "rec_sex_t"
      ]
    },
    "rec_sex_destroy": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nrec_sex_destroy (rec_sex_t sex)\n{\n  if (sex)\n    {\n      if (sex->parser)\n        {\n          rec_sex_parser_destroy (sex->parser);\n        }\n      \n      if (sex->ast)\n        {\n          rec_sex_ast_destroy (sex->ast);\n        }\n      \n      free (sex);  /* yeah! :D */\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_compile": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "bool\nrec_sex_compile (rec_sex_t sex,\n                 const char *expr)\n{\n  bool res;\n\n  res = rec_sex_parser_run (sex->parser, expr);\n  if (res)\n    {\n      sex->ast = rec_sex_parser_ast (sex->parser);\n    }\n  return res;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_eval_str": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "char *\nrec_sex_eval_str (rec_sex_t sex,\n                  rec_record_t record)\n{\n  char *res;\n  struct rec_sex_val_s val;\n  bool status;\n\n  rec_sex_ast_node_unfix (rec_sex_ast_top (sex->ast));\n  val = rec_sex_eval_node (sex,\n                           record,\n                           rec_sex_ast_top (sex->ast),\n                           &status);\n\n  if (!status)\n    {\n      /* Error evaluating the expression.  */\n      return NULL;\n    }\n\n  res = NULL;\n  switch (val.type)\n    {\n    case REC_SEX_VAL_INT:\n      {\n        asprintf (&res, \"%d\", val.int_val);\n        break;\n      }\n    case REC_SEX_VAL_REAL:\n      {\n        asprintf (&res, \"%f\", val.real_val);\n        break;\n      }\n    case REC_SEX_VAL_STR:\n      {\n        res = strdup (val.str_val);\n        break;\n      }\n    }\n\n  return res;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrec_sex_eval_str (rec_sex_t sex,\n                  rec_record_t record)",
        "*"
      ]
    },
    "rec_sex_eval": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "bool\nrec_sex_eval (rec_sex_t sex,\n              rec_record_t record,\n              bool *status)\n{\n  bool res;\n  rec_field_t field;\n  rec_field_t wfield;\n  rec_record_t wrec;\n  rec_mset_iterator_t iter;\n  int j, nf;\n  struct rec_sex_val_s val;\n  \n  res = false;\n  wrec = NULL;\n\n  rec_sex_ast_node_unfix (rec_sex_ast_top (sex->ast));\n  EXEC_AST (record);\n  if (res)\n    {\n      goto exit;\n    }\n\n  rec_record_reset_marks (record);\n\n  iter = rec_mset_iterator (rec_record_mset (record));\n  while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void**) &field, NULL))\n    {\n      nf = rec_record_get_num_fields_by_name (record, rec_field_name (field));\n      if ((nf > 1)\n          && (rec_record_field_mark (record, field) == 0)\n          && (rec_sex_ast_name_p (sex->ast, rec_field_name (field), nf)))\n        {\n          for (j = 0; j < nf; j++)\n            {\n              wfield = rec_record_get_field_by_name (record,\n                                                     rec_field_name (field),\n                                                     j);\n              if (wrec)\n                {\n                  rec_record_destroy (wrec);\n                }\n\n              rec_record_mark_field (record, wfield, 1);\n\n              wrec = rec_record_dup (record);\n              rec_record_remove_field_by_name (wrec,\n                                               rec_field_name (field),\n                                               -1); /* Delete all.  */\n              rec_mset_append (rec_record_mset (wrec), MSET_FIELD, (void *) rec_field_dup (wfield), MSET_ANY);\n\n              EXEC_AST(wrec);\n\n              if (res)\n                {\n                  rec_record_destroy (wrec);\n                  goto exit;\n                }\n            }\n        }\n    }\n\n  rec_mset_iterator_free (&iter);\n\n exit:          \n\n  if (!*status)\n    {\n      res = false;\n    }\n\n  return res;\n}",
      "lines": 73,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_sex_print_ast": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "void\nrec_sex_print_ast (rec_sex_t sex)\n{\n  rec_sex_parser_print_ast (sex->parser);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_sex_eval_node": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        1093,
        1
      ],
      "content": "struct rec_sex_val_s\nrec_sex_eval_node (rec_sex_t sex,\n                   rec_record_t record,\n                   rec_sex_ast_node_t node,\n                   bool *status)\n{\n  struct rec_sex_val_s res = {0, 0, 0, NULL};\n  struct rec_sex_val_s child_val1 = {0, 0, 0, NULL};\n  struct rec_sex_val_s child_val2 = {0, 0, 0, NULL};\n  struct rec_sex_val_s child_val3 = {0, 0, 0, NULL};\n\n  *status = true;\n\n  switch (rec_sex_ast_node_type (node))\n    {\n    case REC_SEX_NOVAL:\n      {\n        fprintf (stderr, \"Application bug: REC_SEX_NOVAL node found.\\nPlease report this!\\n\");\n        exit (EXIT_FAILURE);\n        break;\n      }\n      /* Operations.  */\n    case REC_SEX_OP_NEG:\n    case REC_SEX_OP_ADD:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real operation.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_REAL;\n            res.real_val = op1_real + op2_real;\n          }\n        else\n          {\n            /* Integer operation.  */\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n\n            res.type = REC_SEX_VAL_INT;\n            res.int_val = op1 + op2;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_SUB:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real operation.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_REAL;\n            res.real_val = op1 - op2;\n          }\n        else\n          {\n            /* Integer operation.  */\n\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n\n            res.type = REC_SEX_VAL_INT;\n            res.int_val = op1 - op2;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_MUL:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real operation.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_REAL;\n            res.real_val = op1_real * op2_real;\n          }\n        else\n          {\n            /* Integer operation.  */\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n            \n            res.type = REC_SEX_VAL_INT;\n            res.int_val = op1 * op2;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_DIV:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real operation.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_REAL;\n            res.real_val = op1_real / op2_real;\n          }\n        else\n          {\n            /* Integer operation.  */\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n            \n            res.type = REC_SEX_VAL_INT;\n            \n            if (op2 != 0)\n              {\n                res.int_val = op1 / op2;\n              }\n            else\n              {\n                /* Error: division by zero */\n                *status = false;\n                return res;\n              }\n          }\n\n        break;\n      }\n    case REC_SEX_OP_MOD:\n      {\n        int op1;\n        int op2;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        /* Integer operation.  */\n        ATOI_VAL (op1, child_val1);\n        ATOI_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n\n        if (op2 != 0)\n          {\n            res.int_val = op1 % op2;\n          }\n        else\n          {\n            /* Error: division by zero */\n            *status = false;\n            return res;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_EQL:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if ((child_val1.type == REC_SEX_VAL_STR)\n            && (child_val2.type == REC_SEX_VAL_STR))\n          {\n            /* String comparison.  */\n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_parser_case_insensitive (sex->parser))\n              {\n                res.int_val = (strcasecmp (child_val1.str_val,\n                                           child_val2.str_val) == 0);\n              }\n            else\n              {\n                res.int_val = (strcmp (child_val1.str_val,\n                                       child_val2.str_val) == 0);\n              }\n          }\n        else\n          {\n            if (rec_sex_op_real_p (child_val1, child_val2))\n              {\n                /* Real comparison.  */\n                ATOD_VAL (op1_real, child_val1);\n                ATOD_VAL (op2_real, child_val2);\n\n                res.type = REC_SEX_VAL_INT;\n                res.int_val = op1_real == op2_real;\n              }\n            else\n              {\n                /* Integer comparison.  */\n                ATOI_VAL (op1, child_val1);\n                ATOI_VAL (op2, child_val2);\n                \n                res.type = REC_SEX_VAL_INT;\n                res.int_val = op1 == op2;\n              }\n          }\n\n        break;\n      }\n    case REC_SEX_OP_NEQ:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if ((child_val1.type == REC_SEX_VAL_STR)\n            && (child_val2.type == REC_SEX_VAL_STR))\n          {\n            /* String comparison.  */\n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_parser_case_insensitive (sex->parser))\n              {\n                res.int_val = (strcasecmp (child_val1.str_val,\n                                           child_val2.str_val) != 0);\n              }\n            else\n              {\n                res.int_val = (strcmp (child_val1.str_val,\n                                       child_val2.str_val) != 0);\n              }\n          }\n        else\n          {\n            if (rec_sex_op_real_p (child_val1, child_val2))\n              {\n                /* Real comparison.  */\n                ATOD_VAL (op1_real, child_val1);\n                ATOD_VAL (op2_real, child_val2);\n\n                res.type = REC_SEX_VAL_INT;\n                res.int_val = op1_real != op2_real;\n              }\n            else\n              {\n                /* Integer comparison.  */\n                ATOI_VAL (op1, child_val1);\n                ATOI_VAL (op2, child_val2);\n            \n                res.type = REC_SEX_VAL_INT;\n                res.int_val = op1 != op2;\n              }\n          }\n\n        break;\n      }\n    case REC_SEX_OP_MAT:\n      {\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if ((child_val1.type == REC_SEX_VAL_STR)\n            && (child_val2.type == REC_SEX_VAL_STR))\n          {\n            /* String match.  */\n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_parser_case_insensitive (sex->parser))\n              {\n                res.int_val =\n                  rec_match_insensitive (child_val1.str_val, child_val2.str_val);\n              }\n            else\n              {\n                res.int_val =\n                  rec_match (child_val1.str_val, child_val2.str_val);\n              }\n          }\n        else\n          {\n            /* Error.  */\n            *status = false;\n            return res;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_BEFORE:\n      {\n        struct timespec op1;\n        struct timespec op2;\n        struct timespec diff;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOTS_VAL (op1, child_val1);\n        ATOTS_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = rec_timespec_subtract (&diff, &op1, &op2);\n        break;\n      }\n    case REC_SEX_OP_AFTER:\n      {\n        struct timespec op1;\n        struct timespec op2;\n        struct timespec diff;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOTS_VAL (op1, child_val1);\n        ATOTS_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = (!rec_timespec_subtract (&diff, &op1, &op2)\n                       && ((diff.tv_sec != 0) || (diff.tv_nsec != 0)));\n        break;\n      }\n    case REC_SEX_OP_SAMETIME:\n      {\n        struct timespec op1;\n        struct timespec op2;\n        struct timespec diff;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOTS_VAL (op1, child_val1);\n        ATOTS_VAL (op2, child_val2);\n\n        rec_timespec_subtract (&diff, &op1, &op2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = ((diff.tv_sec == 0) && (diff.tv_nsec == 0));\n        break;\n      }\n    case REC_SEX_OP_IMPLIES:\n      {\n        int op1;\n        int op2;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOI_VAL (op1, child_val1);\n        ATOI_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = !op1 || (op1 && op2);\n\n        break;\n      }\n    case REC_SEX_OP_LT:\n    case REC_SEX_OP_LTE:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real comparison.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_ast_node_type (node) == REC_SEX_OP_LT)\n              {\n                res.int_val = op1_real < op2_real;\n              }\n            else\n              {\n                res.int_val = op1_real <= op2_real;\n              }\n          }\n        else\n          {\n            /* Integer comparison.  */\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n            \n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_ast_node_type (node) == REC_SEX_OP_LT)\n              {\n                res.int_val = op1 < op2;\n              }\n            else\n              {\n                res.int_val = op1 <= op2;\n              }\n          }\n\n        break;\n      }\n    case REC_SEX_OP_GT:\n    case REC_SEX_OP_GTE:\n      {\n        int op1;\n        int op2;\n        double op1_real;\n        double op2_real;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if (rec_sex_op_real_p (child_val1, child_val2))\n          {\n            /* Real comparison.  */\n            ATOD_VAL (op1_real, child_val1);\n            ATOD_VAL (op2_real, child_val2);\n\n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_ast_node_type (node) == REC_SEX_OP_GT)\n              {\n                res.int_val = op1_real > op2_real;\n              }\n            else\n              {\n                res.int_val = op1_real >= op2_real;\n              }\n          }\n        else\n          {\n            /* Integer comparison.  */\n            ATOI_VAL (op1, child_val1);\n            ATOI_VAL (op2, child_val2);\n            \n            res.type = REC_SEX_VAL_INT;\n\n            if (rec_sex_ast_node_type (node) == REC_SEX_OP_GT)\n              {\n                res.int_val = op1 > op2;\n              }\n            else\n              {\n                res.int_val = op1 >= op2;\n              }\n          }\n\n        break;\n      }\n    case REC_SEX_OP_AND:\n      {\n        int op1;\n        int op2;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOI_VAL (op1, child_val1);\n        ATOI_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = op1 && op2;\n\n        break;\n      }\n    case REC_SEX_OP_OR:\n      {\n        int op1;\n        int op2;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        ATOI_VAL (op1, child_val1);\n        ATOI_VAL (op2, child_val2);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = op1 || op2;\n\n        break;\n      }\n    case REC_SEX_OP_CONCAT:\n      {\n        size_t str1_size;\n        size_t str2_size;\n        \n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n\n        if ((child_val1.type == REC_SEX_VAL_STR)\n            && (child_val2.type == REC_SEX_VAL_STR))\n          {\n            str1_size = strlen (child_val1.str_val);\n            str2_size = strlen (child_val2.str_val);\n\n            res.type = REC_SEX_VAL_STR;\n            res.str_val = malloc (str1_size + str2_size + 1);\n            memcpy (res.str_val, child_val1.str_val, str1_size);\n            memcpy (res.str_val + str1_size, child_val2.str_val, str2_size);\n            res.str_val[str1_size + str2_size] = '\\0';\n          }\n        else\n          {\n            *status = false;\n            return res;\n          }\n\n        break;\n      }\n    case REC_SEX_OP_NOT:\n      {\n        int op;\n\n        GET_CHILD_VAL (child_val1, 0);\n        ATOI_VAL (op, child_val1);\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = !op;\n\n        break;\n      }\n    case REC_SEX_OP_SHA:\n      {\n        int n;\n        const char *field_name    = NULL;\n        const char *field_subname = NULL;\n        rec_sex_ast_node_t child;\n\n        /* The child should be a Name.  */\n        child = rec_sex_ast_node_child (node, 0);\n        if (rec_sex_ast_node_type (rec_sex_ast_node_child(node, 0))\n            != REC_SEX_NAME)\n          {\n            *status = false;\n            return res;\n          }\n\n        field_name = rec_sex_ast_node_name (child);\n        field_subname = rec_sex_ast_node_subname (child);\n\n        if (field_subname)\n          {\n            /* Compound a field name from the name/subname pair in the\n               AST node.  */\n            \n            char *effective_name\n              = rec_concat_strings (field_name, \"_\", field_subname);\n\n            n = rec_record_get_num_fields_by_name (record,\n                                                   effective_name);\n            free (effective_name);\n          }\n        else\n          {\n            n = rec_record_get_num_fields_by_name (record, field_name);\n          }\n\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = n;\n        break;\n      }\n    case REC_SEX_OP_COND:\n      {\n        int op1;\n\n        GET_CHILD_VAL (child_val1, 0);\n        GET_CHILD_VAL (child_val2, 1);\n        GET_CHILD_VAL (child_val3, 2);\n\n        /* Get the boolean value of the first operand.  */\n        ATOI_VAL (op1, child_val1);\n\n        /* Return the first or the second operand, depending on the\n           value of op1.  */\n        if (op1)\n          {\n            res = child_val2;\n          }\n        else\n          {\n            res = child_val3;\n          }\n\n        break;\n      }\n      /* Values.  */\n    case REC_SEX_INT:\n      {\n        res.type = REC_SEX_VAL_INT;\n        res.int_val = rec_sex_ast_node_int (node);\n        break;\n      }\n    case REC_SEX_REAL:\n      {\n        res.type = REC_SEX_VAL_REAL;\n        res.real_val = rec_sex_ast_node_real (node);\n        break;\n      }\n    case REC_SEX_STR:\n      {\n        res.type = REC_SEX_VAL_STR;\n        res.str_val = rec_sex_ast_node_str (node);\n        break;\n      }\n    case REC_SEX_NAME:\n      {\n        rec_field_t field;\n        const char *field_name;\n        const char *field_subname;\n        int index;\n        bool tofix;\n\n        if (rec_sex_ast_node_fixed (node))\n          {\n            res.type = REC_SEX_VAL_STR;\n            res.str_val = rec_sex_ast_node_fixed_val (node);\n          }\n        else\n          {\n            field_name = rec_sex_ast_node_name (node);\n            field_subname = rec_sex_ast_node_subname (node);\n            index = rec_sex_ast_node_index (node);\n            tofix = (index != -1);\n            if (index == -1)\n              {\n                index = 0;\n              }\n\n            /* If there is a subname then the effective field name is\n               the concatenation of the name and the subname separated\n               by a '_' character.  Otherwise it is just the name.  */\n\n            {\n              if (field_subname)\n                {\n                  char *effective_field_name = malloc (sizeof (char) *\n                                                       (strlen (field_name) + strlen (field_subname) + 2));\n                  memcpy (effective_field_name, field_name, strlen(field_name));\n                  effective_field_name[strlen(field_name)] = '_';\n                  memcpy (effective_field_name + strlen(field_name) + 1, field_subname, strlen(field_subname) + 1);\n\n                  field = rec_record_get_field_by_name (record, effective_field_name, index);\n                }\n              else\n                {\n                  field = rec_record_get_field_by_name (record, field_name, index);\n                }\n            }\n\n            res.type = REC_SEX_VAL_STR;\n            if (field)\n              {\n                res.str_val = strdup (rec_field_value (field));\n              }\n            else\n              {\n                /* No field => \"\"  */\n                res.str_val = \"\";\n              }\n\n            if (tofix)\n              {\n                /* Make this node fixed.  */\n                rec_sex_ast_node_fix (node, res.str_val);\n              }\n          }\n\n        break;\n      }\n    }\n\n  return res;\n}",
      "lines": 705,
      "depth": 24,
      "decorators": [
        "struct rec_sex_val_s",
        "struct",
        "rec_sex_val_s"
      ]
    },
    "rec_sex_op_real_p": {
      "start_point": [
        1095,
        0
      ],
      "end_point": [
        1168,
        1
      ],
      "content": "static bool\nrec_sex_op_real_p (struct rec_sex_val_s op1,\n                   struct rec_sex_val_s op2)\n{\n  bool ret;\n  int integer;\n  double real;\n\n  ret = true;\n\n  if ((op1.type == REC_SEX_VAL_INT)\n      || ((op1.type == REC_SEX_VAL_STR)\n          && rec_atoi (op1.str_val, &integer)))\n    {\n      /* Operand 1 is an integer.  */\n      switch (op2.type)\n        {\n        case REC_SEX_VAL_INT:\n          {\n            ret = false;\n            break;\n          }\n        case REC_SEX_VAL_REAL:\n          {\n            ret = true;\n            break;\n          }\n        case REC_SEX_VAL_STR:\n          {\n            ret = (rec_atod (op2.str_val, &real)\n                   && (!rec_atoi (op2.str_val, &integer)));\n            break;\n          }\n        default:\n          {\n            ret = false;\n            break;\n          }\n        }\n    }\n\n  if ((op1.type == REC_SEX_VAL_REAL)\n      || ((op1.type == REC_SEX_VAL_STR)\n          && rec_atod (op1.str_val, &real)\n          && (!rec_atoi (op1.str_val, &integer))))\n    {\n      /* Operand 1 is a real.  */\n      switch (op2.type)\n        {\n        case REC_SEX_VAL_INT:\n          {\n            ret = true;\n            break;\n          }\n        case REC_SEX_VAL_REAL:\n          {\n            ret = true;\n            break;\n          }\n        case REC_SEX_VAL_STR:\n          {\n            ret = rec_atod (op2.str_val, &real);\n            break;\n          }\n        default:\n          {\n            ret = false;\n            break;\n          }\n        }\n    }\n\n  return ret;\n}",
      "lines": 74,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-types.c": {
    "rec_type_descr_p": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "bool\nrec_type_descr_p (const char *str)\n{\n  bool ret;\n  rec_type_t aux_type;\n\n  ret = false;\n  \n  aux_type = rec_type_new (str);\n  if (aux_type)\n    {\n      ret = true;\n      rec_type_destroy (aux_type);\n    }\n\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "bool"
      ]
    },
    "rec_type_descr_type": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "char *\nrec_type_descr_type (char *str)\n{\n  char *result = NULL;\n  char *name;\n  const char *p;\n\n  if (rec_type_descr_p (str))\n    {\n      p = str;\n\n      /* Skip blank characters.  */\n      rec_skip_blanks (&p);\n\n      /* Skip the FEX  */\n      if (rec_parse_regexp (&p, \"^\" REC_FNAME_RE \"(,\" REC_FNAME_RE \")*\",\n                            &name))\n        {\n          free (name);\n        }\n\n      /* Skip blanks.  */\n      rec_skip_blanks (&p);\n\n      /* Return the rest of the string.  */\n      result = strdup (p);\n    }\n\n  return result;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrec_type_descr_type (char *str)",
        "*"
      ]
    },
    "rec_type_new": {
      "start_point": [
        349,
        0
      ],
      "end_point": [
        475,
        1
      ],
      "content": "rec_type_t\nrec_type_new (const char *str)\n{\n  rec_type_t new;\n  const char *p;\n  char *type_kind_str = NULL;\n\n  p = str;\n  new = malloc (sizeof (struct rec_type_s));\n  if (!new)\n    {\n      goto exit;\n    }\n  new->name = NULL; /* Newly created types are anonyous. */\n  new->size = 0;\n\n  rec_skip_blanks (&p);\n\n  /* Get the type kind.  */\n  if (!rec_parse_regexp (&p, \"^\" REC_TYPE_CLASS_RE, &type_kind_str))\n    {\n      free (new);\n      new = NULL;\n      goto exit;\n    }\n\n  /* Continue parsing depending on the kind of type.  */\n  new->kind = rec_type_parse_type_kind (type_kind_str);\n  switch (new->kind)\n    {\n    case REC_TYPE_SIZE:\n      {\n        p = rec_type_parse_size (p, new);\n        if (!p)\n          {\n            free (new);\n            new = NULL;\n          }        \n        break;\n      }\n    case REC_TYPE_ENUM:\n      {\n        p = rec_type_parse_enum (p, new);\n        if (!p)\n          {\n            free (new);\n            new = NULL;\n          }\n        break;\n      }\n    case REC_TYPE_REGEXP:\n      {\n        p = rec_type_parse_regexp_type (p, new);\n        if (!p)\n          {\n            free (new);\n            new = NULL;\n          }\n        break;\n      }\n    case REC_TYPE_RANGE:\n      {\n        p = rec_type_parse_range (p, new);\n        if (!p)\n          {\n            free (new);\n            new = NULL;\n          }\n        break;\n      }\n    case REC_TYPE_REC:\n      {\n        p = rec_type_parse_rec (p, new);\n        if (!p)\n          {\n            free (new);\n            new = NULL;\n          }\n        break;\n      }\n    case REC_TYPE_INT:\n    case REC_TYPE_BOOL:\n    case REC_TYPE_REAL:\n    case REC_TYPE_LINE:\n    case REC_TYPE_FIELD:\n    case REC_TYPE_DATE:\n    case REC_TYPE_EMAIL:\n#if defined UUID_TYPE\n    case REC_TYPE_UUID:\n#endif\n      {\n        /* We are done.  */\n        break;\n      }\n    case REC_TYPE_NONE:\n      {\n        /* This point should not be reached.  */\n        fprintf (stderr,\n                 _(\"internal error: rec-types: got REC_TYPE_NONE from rec_type_parse_type_kind() in rec_type_new().\\n\"));\n        exit (EXIT_FAILURE);\n        break;\n      }\n    }\n\n  if (new)\n    {\n      /* Check that all characters until the end of the string are\n         blank characters.  */\n      while (*p != '\\0')\n        {\n          if (!rec_blank_p (*p))\n            {\n              rec_type_destroy (new);\n              new = NULL;\n              break;\n            }\n          \n          p++;\n        }\n    }\n\n exit:\n\n  free (type_kind_str);\n\n  return new;\n}",
      "lines": 127,
      "depth": 13,
      "decorators": [
        "rec_type_t"
      ]
    },
    "rec_type_kind": {
      "start_point": [
        477,
        0
      ],
      "end_point": [
        481,
        1
      ],
      "content": "enum rec_type_kind_e\nrec_type_kind (rec_type_t type)\n{\n  return type->kind;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "enum rec_type_kind_e",
        "enum",
        "rec_type_kind_e"
      ]
    },
    "rec_type_kind_str": {
      "start_point": [
        483,
        0
      ],
      "end_point": [
        570,
        1
      ],
      "content": "char *\nrec_type_kind_str (rec_type_t type)\n{\n  char *res;\n\n  switch (type->kind)\n    {\n    case REC_TYPE_NONE:\n      {\n        res = \"\";\n        break;\n      }\n    case REC_TYPE_INT:\n      {\n        res = REC_TYPE_INT_NAME;\n        break;\n      }\n    case REC_TYPE_BOOL:\n      {\n        res = REC_TYPE_BOOL_NAME;\n        break;\n      }\n    case REC_TYPE_RANGE:\n      {\n        res = REC_TYPE_RANGE_NAME;\n        break;\n      }\n    case REC_TYPE_REAL:\n      {\n        res = REC_TYPE_REAL_NAME;\n        break;\n      }\n    case REC_TYPE_SIZE:\n      {\n        res = REC_TYPE_SIZE_NAME;\n        break;\n      }\n    case REC_TYPE_LINE:\n      {\n        res = REC_TYPE_LINE_NAME;\n        break;\n      }\n    case REC_TYPE_REGEXP:\n      {\n        res = REC_TYPE_REGEXP_NAME;\n        break;\n      }\n    case REC_TYPE_DATE:\n      {\n        res = REC_TYPE_DATE_NAME;\n        break;\n      }\n    case REC_TYPE_EMAIL:\n      {\n        res = REC_TYPE_EMAIL_NAME;\n        break;\n      }\n    case REC_TYPE_ENUM:\n      {\n        res = REC_TYPE_ENUM_NAME;\n        break;\n      }\n    case REC_TYPE_FIELD:\n      {\n        res = REC_TYPE_FIELD_NAME;\n        break;\n      }\n    case REC_TYPE_REC:\n      {\n        res = REC_TYPE_REC_NAME;\n        break;\n      }\n#if defined UUID_TYPE\n    case REC_TYPE_UUID:\n      {\n        res = REC_TYPE_UUID_NAME;\n        break;\n      }\n#endif\n    default:\n      {\n        res = REC_TYPE_NONE;\n        break;\n      }\n    }\n\n  return res;\n}",
      "lines": 88,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrec_type_kind_str (rec_type_t type)",
        "*"
      ]
    },
    "rec_type_check": {
      "start_point": [
        572,
        0
      ],
      "end_point": [
        675,
        1
      ],
      "content": "bool\nrec_type_check (rec_type_t type,\n                const char *str,\n                char **error_str)\n{\n  bool res;\n  rec_buf_t errors;\n  char *err_str;\n  size_t errors_size;\n\n  errors = rec_buf_new (&err_str, &errors_size);\n\n  res = false;\n  switch (type->kind)\n    {\n    case REC_TYPE_NONE:\n      {\n        res = true;\n        break;\n      }\n    case REC_TYPE_INT:\n      {\n        res = rec_type_check_int (type, str, errors);\n        break;\n      }\n    case REC_TYPE_BOOL:\n      {\n        res = rec_type_check_bool (type, str, errors);\n        break;\n      }\n    case REC_TYPE_RANGE:\n      {\n        res = rec_type_check_range (type, str, errors);\n        break;\n      }\n    case REC_TYPE_REAL:\n      {\n        res = rec_type_check_real (type, str, errors);\n        break;\n      }\n    case REC_TYPE_SIZE:\n      {\n        res = rec_type_check_size (type, str, errors);\n        break;\n      }\n    case REC_TYPE_LINE:\n      {\n        res = rec_type_check_line (type, str, errors);\n        break;\n      }\n    case REC_TYPE_REGEXP:\n      {\n        res = rec_type_check_regexp (type, str, errors);\n        break;\n      }\n    case REC_TYPE_DATE:\n      {\n        res = rec_type_check_date (type, str, errors);\n        break;\n      }\n    case REC_TYPE_EMAIL:\n      {\n        res = rec_type_check_email (type, str, errors);\n        break;\n      }\n    case REC_TYPE_ENUM:\n      {\n        res = rec_type_check_enum (type, str, errors);\n        break;\n      }\n    case REC_TYPE_FIELD:\n      {\n        res = rec_type_check_field (type, str, errors);\n        break;\n      }\n    case REC_TYPE_REC:\n      {\n        res = rec_type_check_rec (type, str, errors);\n        break;\n      }\n#if defined UUID_TYPE\n    case REC_TYPE_UUID:\n      {\n        res = rec_type_check_uuid (type, str, errors);\n        break;\n      }\n#endif\n    }\n\n  /* Terminate the 'errors' string.  */\n  rec_buf_close (errors);\n  /*  err_str[errors_size] = '\\0';*/\n\n  if (error_str)\n    {\n      *error_str = err_str;\n    }\n  else\n    {\n      free (err_str);\n    }\n\n  return res;\n}",
      "lines": 104,
      "depth": 12,
      "decorators": [
        "bool"
      ]
    },
    "rec_type_destroy": {
      "start_point": [
        677,
        0
      ],
      "end_point": [
        699,
        1
      ],
      "content": "void\nrec_type_destroy (rec_type_t type)\n{\n  int i;\n\n  if (type)\n    {\n      if (type->kind == REC_TYPE_ENUM)\n        {\n          for (i = 0; i < type->size; i++)\n            {\n              free (type->data.names[i]);\n            }\n        }\n      else if (type->kind == REC_TYPE_REGEXP)\n        {\n          regfree (&type->data.regexp);\n        }\n      \n      free (type->name);\n      free (type);\n    }\n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "rec_type_reg_new": {
      "start_point": [
        701,
        0
      ],
      "end_point": [
        714,
        1
      ],
      "content": "rec_type_reg_t\nrec_type_reg_new (void)\n{\n  rec_type_reg_t new;\n\n  new = malloc (sizeof (struct rec_type_reg_s));\n  if (new)\n    {\n      new->num_types = 0;\n      new->types = NULL;\n    }\n\n  return new;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "rec_type_reg_t"
      ]
    },
    "rec_type_reg_destroy": {
      "start_point": [
        716,
        0
      ],
      "end_point": [
        732,
        1
      ],
      "content": "void\nrec_type_reg_destroy (rec_type_reg_t reg)\n{\n  size_t i;\n  \n  for (i = 0; i < reg->num_types; i++)\n    {\n      if (reg->types[i].type)\n        {\n          rec_type_destroy (reg->types[i].type);\n        }\n      free (reg->types[i].type_name);\n      free (reg->types[i].to_type);\n    }\n  free (reg->types);\n  free (reg);\n}",
      "lines": 17,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "rec_type_reg_add": {
      "start_point": [
        734,
        0
      ],
      "end_point": [
        777,
        1
      ],
      "content": "void\nrec_type_reg_add (rec_type_reg_t reg,\n                  rec_type_t type)\n{\n  size_t i;\n  const char *type_name = NULL;\n\n  type_name = rec_type_name (type);\n  if (!type_name)\n    {\n      /* The registry only contains named types.  */\n      return;\n    }\n\n  for (i = 0; i < reg->num_types; i++)\n    {\n      if (strcmp (reg->types[i].type_name, type_name) == 0)\n        {\n          /* Replace this entry.  */\n          if (reg->types[i].type)\n            {\n              rec_type_destroy (reg->types[i].type);\n            }\n          free (reg->types[i].type_name);\n          free (reg->types[i].to_type);\n          break;\n        }\n    }\n\n  /* If we need to add a new entry then allocate it.  */\n\n  if (i == reg->num_types)\n    {\n      reg->types =\n        realloc (reg->types,\n                 ((i / REC_TYPE_REG_ALLOC_TYPES) + 1) * (sizeof (struct rec_type_reg_entry_s *) * REC_TYPE_REG_ALLOC_TYPES));\n      reg->num_types++;\n    }\n\n  reg->types[i].type_name = strdup (rec_type_name (type));\n  reg->types[i].type = type;\n  reg->types[i].to_type = NULL;\n  reg->types[i].visited_p = false;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "rec_type_reg_add_synonym": {
      "start_point": [
        779,
        0
      ],
      "end_point": [
        816,
        1
      ],
      "content": "void\nrec_type_reg_add_synonym (rec_type_reg_t reg,\n                          const char *type_name,\n                          const char *to_type)\n{\n  size_t i;\n\n  for (i = 0; i < reg->num_types; i++)\n    {\n      if (strcmp (reg->types[i].type_name, type_name) == 0)\n        {\n          /* Replace this entry.  */\n          if (reg->types[i].type)\n            {\n              rec_type_destroy (reg->types[i].type);\n            }\n          free (reg->types[i].type_name);\n          free (reg->types[i].to_type);\n          break;\n        }\n    }\n\n\n  /* If we need to add a new entry then allocate it.  */\n\n  if (i == reg->num_types)\n    {\n      reg->types =\n        realloc (reg->types,\n                 ((i / REC_TYPE_REG_ALLOC_TYPES) + 1) * (sizeof (struct rec_type_reg_entry_s *) * REC_TYPE_REG_ALLOC_TYPES));\n      reg->num_types++;\n    }\n\n  reg->types[i].type_name = strdup (type_name);\n  reg->types[i].to_type = strdup (to_type);\n  reg->types[i].type = NULL;\n  reg->types[i].visited_p = false;\n}",
      "lines": 38,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "rec_type_reg_get": {
      "start_point": [
        818,
        0
      ],
      "end_point": [
        857,
        1
      ],
      "content": "rec_type_t\nrec_type_reg_get (rec_type_reg_t reg,\n                  const char *type_name)\n{\n  size_t i;\n  rec_type_t type = NULL;\n\n  for (i = 0; i < reg->num_types; i++)\n    {\n      if (strcmp (reg->types[i].type_name, type_name) == 0)\n        {\n          if (reg->types[i].type)\n            {\n              /* Type found.  */\n              type = reg->types[i].type;\n              break;\n            }\n          else\n            {\n              /* Loop detection.  */\n              if (reg->types[i].visited_p)\n                {\n                  break;\n                }\n              \n              /* Mark this entry as visited and follow the name.  */\n              reg->types[i].visited_p = true;\n              type = rec_type_reg_get (reg, reg->types[i].to_type);\n            }\n        }\n    }\n\n  /* Reset the visited flags.  */\n  for (i = 0; i < reg->num_types; i++)\n    {\n      reg->types[i].visited_p = false;\n    }\n  \n  return type;\n}",
      "lines": 40,
      "depth": 16,
      "decorators": [
        "rec_type_t"
      ]
    },
    "rec_type_name": {
      "start_point": [
        859,
        0
      ],
      "end_point": [
        863,
        1
      ],
      "content": "const char *\nrec_type_name (rec_type_t type)\n{\n  return type->name;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_type_name (rec_type_t type)",
        "*"
      ]
    },
    "rec_type_set_name": {
      "start_point": [
        865,
        0
      ],
      "end_point": [
        869,
        1
      ],
      "content": "void\nrec_type_set_name (rec_type_t type, const char *name)\n{\n  type->name = strdup (name);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_type_equal_p": {
      "start_point": [
        871,
        0
      ],
      "end_point": [
        913,
        1
      ],
      "content": "bool\nrec_type_equal_p (rec_type_t type1,\n                  rec_type_t type2)\n{\n  bool ret;\n  size_t i;\n\n  ret = true;\n\n  if (type1->kind != type2->kind)\n    {\n      ret = false;\n    }\n  else\n    {\n      if (type1->kind == REC_TYPE_SIZE)\n        {\n          ret = (type1->data.max_size == type2->data.max_size);\n        }\n      else if (type1->kind == REC_TYPE_RANGE)\n        {\n          ret = ((type1->data.range[0] == type2->data.range[0])\n                 && (type1->data.range[1] == type2->data.range[1]));\n        }\n      else if (type1->kind == REC_TYPE_ENUM)\n        {\n          for (i = 0; i < type1->size; i++)\n            {\n              ret = ((i < type2->size)\n                     && (strcmp (type1->data.names[i],\n                                 type2->data.names[i]) == 0));\n            }\n        }\n      else if (type1->kind == REC_TYPE_REGEXP)\n        {\n          /* Since there is no way to determine whether two\n             regex_t variables refer to equivalent regexps.  */\n          ret = false;\n        }\n    }\n\n  return ret;\n}",
      "lines": 43,
      "depth": 22,
      "decorators": [
        "bool"
      ]
    },
    "rec_type_min": {
      "start_point": [
        915,
        0
      ],
      "end_point": [
        930,
        1
      ],
      "content": "int\nrec_type_min (rec_type_t type)\n{\n  int res;\n\n  if (type->kind != REC_TYPE_RANGE)\n    {\n      res = -1;\n    }\n  else\n    {\n      res = type->data.range[0];\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rec_type_max": {
      "start_point": [
        932,
        0
      ],
      "end_point": [
        947,
        1
      ],
      "content": "int\nrec_type_max (rec_type_t type)\n{\n  int res;\n\n  if (type->kind != REC_TYPE_RANGE)\n    {\n      res = -1;\n    }\n  else\n    {\n      res = type->data.range[1];\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rec_type_rec": {
      "start_point": [
        949,
        0
      ],
      "end_point": [
        960,
        1
      ],
      "content": "const char *\nrec_type_rec (rec_type_t type)\n{\n  const char *res = NULL;\n\n  if (type->kind == REC_TYPE_REC)\n    {\n      res = type->data.recname;\n    }\n\n  return res;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nrec_type_rec (rec_type_t type)",
        "*"
      ]
    },
    "rec_type_values_cmp": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        1096,
        1
      ],
      "content": "int\nrec_type_values_cmp (rec_type_t type,\n                     const char *val1,\n                     const char *val2)\n{\n  int type_comparison;\n  enum rec_type_kind_e kind = REC_TYPE_NONE;\n\n  if (type)\n    {\n      kind = type->kind;\n    }\n\n  switch (kind)\n    {\n    case REC_TYPE_INT:\n    case REC_TYPE_RANGE:\n      {\n        int int1, int2 = 0;\n\n        if (!rec_atoi (val1, &int1) || !rec_atoi (val2, &int2))\n          {\n            goto lexi;\n          }\n\n        if (int1 < int2)\n          {\n            type_comparison = -1;\n          }\n        else if (int1 > int2)\n          {\n            type_comparison = 1;\n          }\n        else\n          {\n            type_comparison = 0;\n          }\n\n        break;\n      }\n    case REC_TYPE_REAL:\n      {\n        double real1, real2 = 0;\n\n        if (!rec_atod (val1, &real1) || !rec_atod (val2, &real2))\n          {\n            goto lexi;\n          }\n\n        if (real1 < real2)\n          {\n            type_comparison = -1;\n          }\n        else if (real1 > real2)\n          {\n            type_comparison = 1;\n          }\n        else\n          {\n            type_comparison = 0;\n          }\n\n        break;\n      }\n    case REC_TYPE_BOOL:\n      {\n        bool bool1, bool2 = false;\n\n        /* Boolean fields storing 'false' come first.  */\n            \n        bool1 = rec_match (val1,\n                           REC_TYPE_ZBLANKS_RE \"(\" REC_TYPE_BOOL_TRUE_VALUES_RE \")\" REC_TYPE_ZBLANKS_RE);\n        bool2 = rec_match (val2,\n                           REC_TYPE_ZBLANKS_RE \"(\" REC_TYPE_BOOL_TRUE_VALUES_RE \")\" REC_TYPE_ZBLANKS_RE);\n\n        if (!bool1 && bool2)\n          {\n            type_comparison = -1;\n          }\n        else if (bool1 == bool2)\n          {\n            type_comparison = 0;\n          }\n        else\n          {\n            type_comparison = 1;\n          }\n\n        break;\n      }\n    case REC_TYPE_DATE:\n      {\n        struct timespec op1;\n        struct timespec op2;\n        struct timespec diff;\n\n        if (parse_datetime (&op1, val1, NULL)\n            && parse_datetime (&op2, val2, NULL))\n          {\n            if ((op1.tv_sec == op2.tv_sec)\n                && (op1.tv_nsec == op2.tv_nsec))\n              {\n                /* op1 == op2 */\n                type_comparison = 0;\n              }\n            else if (rec_timespec_subtract (&diff, &op1, &op2))\n              {\n                /* op1 < op2 */\n                type_comparison = -1;\n              }\n            else\n              {\n                /* op1 > op2 */\n                type_comparison = 1;\n              }\n          }\n        else\n          {\n            /* Invalid date => lexicographic order.  */\n            goto lexi;\n          }\n\n        break;\n      }\n    default:\n          {\n          lexi:\n            /* Lexicographic order.  */\n            type_comparison = strcmp (val1, val2);\n            break;\n          }\n    }\n\n  return type_comparison;\n}",
      "lines": 135,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "rec_type_parse_type_kind": {
      "start_point": [
        1102,
        0
      ],
      "end_point": [
        1165,
        1
      ],
      "content": "static enum rec_type_kind_e\nrec_type_parse_type_kind (char *str)\n{\n  enum rec_type_kind_e res;\n\n  res = REC_TYPE_NONE;\n\n  if (strcmp (str, REC_TYPE_INT_NAME) == 0)\n    {\n      res = REC_TYPE_INT;\n    }\n  if (strcmp (str, REC_TYPE_BOOL_NAME) == 0)\n    {\n      res = REC_TYPE_BOOL;\n    }\n  if (strcmp (str, REC_TYPE_RANGE_NAME) == 0)\n    {\n      res = REC_TYPE_RANGE;\n    }\n  if (strcmp (str, REC_TYPE_REAL_NAME) == 0)\n    {\n      res = REC_TYPE_REAL;\n    }\n  if (strcmp (str, REC_TYPE_SIZE_NAME) == 0)\n    {\n      res = REC_TYPE_SIZE;\n    }\n  if (strcmp (str, REC_TYPE_LINE_NAME) == 0)\n    {\n      res = REC_TYPE_LINE;\n    }\n  if (strcmp (str, REC_TYPE_REGEXP_NAME) == 0)\n    {\n      res = REC_TYPE_REGEXP;\n    }\n  if (strcmp (str, REC_TYPE_DATE_NAME) == 0)\n    {\n      res = REC_TYPE_DATE;\n    }\n  if (strcmp (str, REC_TYPE_EMAIL_NAME) == 0)\n    {\n      res = REC_TYPE_EMAIL;\n    }\n  if (strcmp (str, REC_TYPE_ENUM_NAME) == 0)\n    {\n      res = REC_TYPE_ENUM;\n    }\n  if (strcmp (str, REC_TYPE_FIELD_NAME) == 0)\n    {\n      res = REC_TYPE_FIELD;\n    }\n  if (strcmp (str, REC_TYPE_REC_NAME) == 0)\n    {\n      res = REC_TYPE_REC;\n    }\n#if defined UUID_TYPE\n  if (strcmp (str, REC_TYPE_UUID_NAME) == 0)\n    {\n      res = REC_TYPE_UUID;\n    }\n#endif\n\n  return res;\n}",
      "lines": 64,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "enum rec_type_kind_e",
        "enum",
        "rec_type_kind_e"
      ]
    },
    "rec_type_check_int": {
      "start_point": [
        1167,
        0
      ],
      "end_point": [
        1181,
        1
      ],
      "content": "static bool\nrec_type_check_int (rec_type_t type,\n                    const char *str,\n                    rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_INT_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid integer.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_rec": {
      "start_point": [
        1183,
        0
      ],
      "end_point": [
        1195,
        1
      ],
      "content": "static bool\nrec_type_check_rec (rec_type_t type,\n                    const char *str,\n                    rec_buf_t errors)\n{\n  /* The values of type 'rec' are of whatever type the primary key of\n     the referred type is.  That check is not implemented here, but in\n     rec-types.c.\n\n     So sorry Mario, but the Princess is kept in another castle...  */\n  \n  return true;\n}",
      "lines": 13,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_field": {
      "start_point": [
        1197,
        0
      ],
      "end_point": [
        1211,
        1
      ],
      "content": "static bool\nrec_type_check_field (rec_type_t type,\n                      const char *str,\n                      rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_FIELD_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid 'field' value.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_uuid": {
      "start_point": [
        1215,
        0
      ],
      "end_point": [
        1234,
        1
      ],
      "content": "static bool\nrec_type_check_uuid (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  int ret;\n  uuid_t uu;\n\n  /* Determine whether the given string is a valid UUID by parsing it\n     using the uuid_parse function provided by the libuuid\n     library.  */\n\n  ret = uuid_parse (str, uu);\n  if ((ret == -1) && errors)\n    {\n      rec_buf_puts (_(\"invalid 'uuid' value.\"), errors);\n    }\n\n  return (ret == 0);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_bool": {
      "start_point": [
        1238,
        0
      ],
      "end_point": [
        1252,
        1
      ],
      "content": "static bool\nrec_type_check_bool (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_BOOL_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid 'bool' value.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_range": {
      "start_point": [
        1254,
        0
      ],
      "end_point": [
        1289,
        1
      ],
      "content": "static bool\nrec_type_check_range (rec_type_t type,\n                      const char *str,\n                      rec_buf_t errors)\n{\n  bool ret;\n  const char *p;\n  int num;\n  char *tmp;\n\n  p = str;\n\n  rec_skip_blanks (&p);\n  if (!rec_parse_int (&p, &num))\n    {\n      if (errors)\n        {\n          rec_buf_puts (_(\"invalid 'range' value.\"), errors);\n        }\n      return false;\n    }\n\n  ret = ((num >= type->data.range[0])\n         && (num <= type->data.range[1]));\n  if (!ret && errors)\n    {\n      if (asprintf (&tmp, _(\"expected an integer between %d and %d.\"),\n                    type->data.range[0], type->data.range[1]) != -1)\n        {\n          rec_buf_puts (tmp, errors);\n          free (tmp);\n        }\n    }\n  \n  return ret;\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_real": {
      "start_point": [
        1291,
        0
      ],
      "end_point": [
        1305,
        1
      ],
      "content": "static bool\nrec_type_check_real (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_REAL_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid 'real' value.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_size": {
      "start_point": [
        1307,
        0
      ],
      "end_point": [
        1328,
        1
      ],
      "content": "static bool\nrec_type_check_size (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  bool ret;\n  char *tmp;\n\n  ret = (strlen (str) <= type->data.max_size);\n  if (!ret && errors)\n    {\n      if (asprintf (&tmp,\n                    _(\"value too large.  Expected a size <= %zu.\"),\n                    type->data.max_size) != -1)\n        {\n          rec_buf_puts (tmp, errors);\n          free (tmp);\n        }\n    }\n  \n  return (strlen (str) <= type->data.max_size);\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_line": {
      "start_point": [
        1330,
        0
      ],
      "end_point": [
        1344,
        1
      ],
      "content": "static bool\nrec_type_check_line (rec_type_t type,\n                     const char *str, \n                     rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_LINE_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid 'line' value.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_regexp": {
      "start_point": [
        1346,
        0
      ],
      "end_point": [
        1363,
        1
      ],
      "content": "static bool\nrec_type_check_regexp (rec_type_t type,\n                       const char *str,\n                       rec_buf_t errors)\n{\n  bool ret;\n  ret = (regexec (&type->data.regexp,\n                  str,\n                  0,\n                  NULL,\n                  0) == 0);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"value does not match the regexp.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_date": {
      "start_point": [
        1365,
        0
      ],
      "end_point": [
        1386,
        1
      ],
      "content": "static bool\nrec_type_check_date (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  bool ret;\n  struct timespec tm;\n\n  if (strcmp (str, \"\") == 0)\n    {\n      /* The parse_datetime call accepts the empty string.  */\n      return false;\n    }\n\n  ret = parse_datetime (&tm, str, NULL);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid date.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_email": {
      "start_point": [
        1388,
        0
      ],
      "end_point": [
        1402,
        1
      ],
      "content": "static bool\nrec_type_check_email (rec_type_t type,\n                      const char *str,\n                      rec_buf_t errors)\n{\n  bool ret;\n\n  ret = rec_match (str, REC_TYPE_EMAIL_VALUE_RE);\n  if (!ret && errors)\n    {\n      rec_buf_puts (_(\"invalid email.\"), errors);\n    }\n\n  return ret;\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_check_enum": {
      "start_point": [
        1404,
        0
      ],
      "end_point": [
        1447,
        1
      ],
      "content": "static bool\nrec_type_check_enum (rec_type_t type,\n                     const char *str,\n                     rec_buf_t errors)\n{\n  size_t i;\n  const char *p, *b;\n  char name[100];\n\n  if (rec_match (str, REC_TYPE_ENUM_VALUE_RE))\n    {\n      /* Get the name from STR.  */\n      p = str;\n      \n      while (p && rec_blank_p (*p))\n        {\n          p++;\n        }\n      \n      b = p;\n      while (p && (rec_letter_p (*p)\n                   || rec_letter_p (*p)\n                   || rec_digit_p (*p)\n                   || (*p == '_')\n                   || (*p == '-')))\n        {\n          name[p - b] = *p;\n          p++;\n        }\n      name[p - b] = '\\0';\n      \n      /* Check for the name in the enum types.  */\n      for (i = 0; i < type->size; i++)\n        if (strcmp (name, type->data.names[i]) == 0)\n          return true;\n    }\n\n  if (errors)\n    {\n      rec_buf_puts (_(\"invalid enum value.\"), errors);\n    }\n\n  return false;\n}",
      "lines": 44,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_parse_size": {
      "start_point": [
        1449,
        0
      ],
      "end_point": [
        1472,
        1
      ],
      "content": "static const char *\nrec_type_parse_size (const char *str, rec_type_t type)\n{\n  const char *p;\n  int size;\n\n  p = str;\n\n  /* Skip blanks.  */\n  rec_skip_blanks (&p);\n\n  /* Get the size.  */\n  if (rec_parse_int (&p, &size)\n      && (size >= 0))\n    {\n      type->data.max_size = size;\n    }\n  else\n    {\n      p = NULL;\n    }\n\n  return p;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nrec_type_parse_size (const char *str, rec_type_t type)",
        "*"
      ]
    },
    "rec_type_parse_enum": {
      "start_point": [
        1474,
        0
      ],
      "end_point": [
        1544,
        1
      ],
      "content": "static const char *\nrec_type_parse_enum (const char *str, rec_type_t type)\n{\n  const char *p;\n  size_t i;\n  \n  p = str;\n\n  type->size = 0;\n  type->data.names = NULL;\n\n  while (*p)\n    {\n      /* Allocate space in the list of enum names if needed.  */\n      if ((type->size % REC_ENUM_ALLOC_NAMES) == 0)\n        type->data.names =\n          realloc (type->data.names, ((type->size / REC_ENUM_ALLOC_NAMES) + 1) * (sizeof(char *) * REC_ENUM_ALLOC_NAMES));\n      \n      /* Skip blanks.  */\n      rec_skip_blanks (&p);\n\n      if (*p == '(')\n        {\n          /* Skip the comment.  */\n          p++;\n          while (*p && (*p != ')') && (*p != '('))\n            {\n              p++;\n            }\n          if (*p == ')')\n            {\n              p++;\n            }\n          else\n            {\n              /* Parse error: unterminated comment. */\n              p = NULL;\n              break;\n            }\n        }\n      else if (*p)\n        {\n          /* Parse an enum entry.  */\n          if (!rec_parse_regexp (&p,\n                                 \"^\" REC_TYPE_ENUM_NAME_RE,\n                                 &(type->data.names[type->size++])))\n            {\n              p = NULL;\n              break;\n            }\n        }\n    }\n\n  if (type->size == 0)\n    {\n      /* We require at least one entry in the enum.  In this case it\n         is not needed to save memory.  */\n      return NULL;\n    }\n\n  if (!p)\n    {\n      /* Free memory.  */\n      for (i = 0; i < type->size; i++)\n        {\n          free (type->data.names[i]);\n        }\n    }\n\n  return p;\n}",
      "lines": 71,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nrec_type_parse_enum (const char *str, rec_type_t type)",
        "*"
      ]
    },
    "rec_type_parse_regexp_type": {
      "start_point": [
        1546,
        0
      ],
      "end_point": [
        1616,
        1
      ],
      "content": "static const char *\nrec_type_parse_regexp_type (const char *str, rec_type_t type)\n{\n  const char *p;\n  char re[200];\n  bool end_regexp;\n  size_t i;\n  char delim_char;\n\n  p = str;\n\n  /* The regexp type descriptor is like:\n           \n     BLANKS BEGIN_RE CHARS END_RE BLANKS\n           \n     where BEGIN_RE == END_RE and is the first non-blank\n     character found in the string.  Escaped apperances of\n     BEGIN_RE in CHARS are un-escaped.\n  */\n\n  /* Skip blanks.  */\n  rec_skip_blanks (&p);\n        \n  end_regexp = false;\n  delim_char = *p;\n  p++;\n        \n  i = 0;\n  while (*p)\n    {\n      if (*p == delim_char)\n        {\n          if (*(p + 1) == delim_char)\n            {\n              re[i++] = delim_char;\n              p++;\n            }\n          else\n            {\n              /* End of the regexp.  */\n              p++;\n              end_regexp = true;\n              break;\n            }\n        }\n      else\n        {\n          re[i++] = *p;\n        }\n            \n      p++;\n    }\n  re[i] = '\\0';\n        \n  if (!end_regexp)\n    {\n      /* Error.  */\n      p = NULL;\n    }\n  else\n    {\n      /* Compile the regexp.  */\n      if (regcomp (&type->data.regexp, re,\n                   REG_EXTENDED) != 0)\n        {\n          p = NULL;\n        }\n    }\n\n  return p;\n}",
      "lines": 71,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nrec_type_parse_regexp_type (const char *str, rec_type_t type)",
        "*"
      ]
    },
    "rec_type_parse_rec": {
      "start_point": [
        1618,
        0
      ],
      "end_point": [
        1633,
        1
      ],
      "content": "static const char *\nrec_type_parse_rec (const char *str, rec_type_t type)\n{\n  const char *p = str;\n  \n  /* Get the record name.  */\n  rec_skip_blanks (&p);\n  if (!rec_parse_regexp (&p,\n                         \"^\" REC_RECORD_TYPE_RE,\n                         &(type->data.recname)))\n    {\n      return NULL;\n    }\n\n  return p;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nrec_type_parse_rec (const char *str, rec_type_t type)",
        "*"
      ]
    },
    "rec_type_parse_range_point": {
      "start_point": [
        1635,
        0
      ],
      "end_point": [
        1654,
        1
      ],
      "content": "static bool\nrec_type_parse_range_point (const char **str, int *num)\n{\n  if (rec_match (*str, \"^MIN\"))\n    {\n      *num = INT_MIN;\n      *str += 3;\n    }\n  else if (rec_match (*str, \"^MAX\"))\n    {\n      *num = INT_MAX;\n      *str += 3;\n    }\n  else if (!rec_parse_int (str, num))\n    {\n      return false;\n    }\n\n  return true;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_type_parse_range": {
      "start_point": [
        1656,
        0
      ],
      "end_point": [
        1688,
        1
      ],
      "content": "static const char *\nrec_type_parse_range (const char *str, rec_type_t type)\n{\n  const char *p;\n\n  p = str;\n\n  rec_skip_blanks (&p);\n\n  if (!rec_type_parse_range_point (&p, &(type->data.range[0])))\n    {\n      return NULL;\n    }\n\n  rec_skip_blanks (&p);\n\n  if (*p == '\\0')\n    {\n      /* One of the indexes is ommitted.  The range is of the\n         form 0..N.  */\n      type->data.range[1] = type->data.range[0];\n      type->data.range[0] = 0;\n    }\n  else\n    {\n      if (!rec_type_parse_range_point (&p, &(type->data.range[1])))\n        {\n          return NULL;\n        }\n    }\n\n  return p;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nrec_type_parse_range (const char *str, rec_type_t type)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-utils.c": {
    "rec_atoi": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "bool\nrec_atoi (const char *str,\n          int *number)\n{\n  bool res;\n  long int li;\n  char *end;\n  int base = 0;\n\n  res = false;\n\n  li = strtol (str, &end, base);\n  if ((*str != '\\0') && (*end == '\\0'))\n    {\n      /* The entire string is valid.  */\n      res = true;\n      *number = (int) li;\n    }\n\n  return res;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_atod": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "bool\nrec_atod (const char *str,\n          double *number)\n{\n  bool res;\n  char *end;\n\n  res = false;\n  \n  setlocale (LC_NUMERIC, \"C\"); /* We want the dot to always be the\n                                  decimal separator. */\n  *number = strtod (str, &end);\n  setlocale (LC_NUMERIC, \"\"); /* Restore the locale from the\n                                 environment.  */\n\n  if ((*str != '\\0') && (*end == '\\0'))\n    {\n      /* The entire string is valid.  */\n      res = true;\n    }\n  \n  return res;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_extract_file": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "char *\nrec_extract_file (const char *str)\n{\n  regex_t regexp;\n  regmatch_t matches;\n  char *rec_file = NULL;\n  size_t rec_file_length = 0;\n\n  if (regcomp (&regexp, \"[ \\n\\t]\" REC_FILE_REGEXP, REG_EXTENDED) != 0)\n    {\n      fprintf (stderr, _(\"internal error: rec_int_rec_extract_file: error compiling regexp.\\n\"));\n      return NULL;\n    }\n\n  if ((regexec (&regexp, str, 1, &matches, 0) == 0)\n      && (matches.rm_so != -1))\n    {\n      /* Get the match.  */\n      rec_file_length = matches.rm_eo - matches.rm_so;\n      rec_file = malloc (rec_file_length + 1);\n      memcpy (rec_file, str + matches.rm_so + 1, rec_file_length - 1);\n      rec_file[rec_file_length - 1] = '\\0';\n    }\n\n  regfree (&regexp);\n  return rec_file;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrec_extract_file (const char *str)",
        "*"
      ]
    },
    "rec_extract_url": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "char *\nrec_extract_url (const char *str)\n{\n  regex_t regexp;\n  regmatch_t matches;\n  char *rec_url = NULL;\n  size_t rec_url_length = 0;\n\n  if (regcomp (&regexp, REC_URL_REGEXP, REG_EXTENDED) != 0)\n    {\n      fprintf (stderr, _(\"internal error: rec_int_rec_extract_url: error compiling regexp.\\n\"));\n      return NULL;\n    }\n\n  if ((regexec (&regexp, str, 1, &matches, 0) == 0)\n      && (matches.rm_so != -1))\n    {\n      /* Get the match.  */\n      rec_url_length = matches.rm_eo - matches.rm_so;\n      rec_url = malloc (rec_url_length + 1);\n      memcpy (rec_url, str + matches.rm_so, rec_url_length);\n      rec_url[rec_url_length] = '\\0';\n    }\n\n  regfree (&regexp);\n  return rec_url;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrec_extract_url (const char *str)",
        "*"
      ]
    },
    "rec_extract_type": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "char *\nrec_extract_type (const char *str)\n{\n  regex_t regexp;\n  regmatch_t matches;\n  char *rec_type = NULL;\n  size_t rec_type_length = 0;\n\n  /* TODO: use a REC_TYPE_NAME_RE  */\n  if (regcomp (&regexp, REC_FNAME_RE, REG_EXTENDED) != 0)\n    {\n      fprintf (stderr, _(\"internal error: rec_int_rec_extract_url: error compiling regexp.\\n\"));\n      return NULL;\n    }\n\n  if ((regexec (&regexp, str, 1, &matches, 0) == 0)\n      && (matches.rm_so != -1))\n    {\n      /* Get the match.  */\n      rec_type_length = matches.rm_eo - matches.rm_so;\n      rec_type = malloc (rec_type_length + 1);\n      memcpy (rec_type, str + matches.rm_so, rec_type_length);\n      rec_type[rec_type_length] = '\\0';\n    }\n\n  regfree (&regexp);\n  return rec_type;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrec_extract_type (const char *str)",
        "*"
      ]
    },
    "rec_parse_int": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "bool\nrec_parse_int (const char **str, int *num)\n{\n  bool ret;\n  const char *p, *b;\n  char number[30];\n\n  ret = true;\n  p = *str;\n\n  b = p;\n  while (rec_digit_p (*p)\n         || ((p == b) && (*p == '-'))\n         || ((*p >= 'a') && (*p <= 'f'))\n         || ((*p >= 'A') && (*p <= 'F'))\n         || (*p == 'x')\n         || (*p == 'X'))\n    {\n      number[p - b] = *p;\n      p++;\n    }\n  number[p - b] = '\\0';\n\n  if (!rec_atoi (number, num))\n    {\n      ret = false;\n    }\n\n  if (ret)\n    {\n      *str = p;\n    }\n\n  return ret;\n}",
      "lines": 35,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_parse_regexp": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "bool\nrec_parse_regexp (const char **str, const char *re, char **result)\n{\n  bool ret;\n  const char *p;\n  regex_t regexp;\n  regmatch_t pm;\n\n  ret = true;\n  p = *str;\n\n  /* Compile the regexp.  */\n  if (regcomp (&regexp, re, REG_EXTENDED) != 0)\n    {\n      ret = false;\n    }\n\n  if (ret)\n    {\n      /* Try to match the regexp.  */\n      if (regexec (&regexp, p, 1, &pm, 0) == 0)\n        {\n          if (result)\n            {\n              /* Get the match into 'result'.  Note that\n                 since the pattern starts with a ^ rm_so shall be 0 and we\n                 can use rm_eo relative to *p.  */\n              *result = malloc (pm.rm_eo + 1);\n              memcpy (*result, p, pm.rm_eo);\n              (*result)[pm.rm_eo] = '\\0';\n            }\n\n          /* Advance 'p'.  */\n          p = p + pm.rm_eo;\n        }\n      else\n        {\n          ret = false;\n          if (result)\n            {\n              *result = NULL;\n            }\n        }\n\n      regfree (&regexp);\n    }\n\n  if (ret)\n    {\n      *str = p;\n    }\n\n  return ret;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_skip_blanks": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "void\nrec_skip_blanks (const char **str)\n{\n  const char *p;\n\n  p = *str;\n  while (rec_blank_p (*p))\n    {\n      p++;\n    }\n\n  *str = p;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "rec_blank_p": {
      "start_point": [
        272,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "bool\nrec_blank_p (char c)\n{\n  return ((c == ' ')\n          || (c == '\\n')\n          || (c == '\\t'));\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "bool"
      ]
    },
    "rec_digit_p": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "bool\nrec_digit_p (char c)\n{\n  return ((c >= '0') && (c <= '9'));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "rec_letter_p": {
      "start_point": [
        286,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "bool\nrec_letter_p (char c)\n{\n  return (((c >= 'a') && (c <= 'z'))\n          || ((c >= 'A') && (c <= 'Z')));\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_match_int": {
      "start_point": [
        293,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static bool\nrec_match_int (const char *str,\n               const char *reg,\n               int flags)\n{\n  bool ret;\n  regex_t regexp;\n\n  if (regcomp (&regexp, reg, flags) != 0)\n    {\n      fprintf (stderr, _(\"internal error: rec_match: error compiling regexp.\\n\"));\n      return false;\n    }\n\n  ret = (regexec (&regexp, str, 0, NULL, 0) == 0);\n  regfree (&regexp);\n\n  return ret;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_match": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "bool\nrec_match (const char *str,\n           const char *reg)\n{\n  return rec_match_int (str, reg, REG_EXTENDED);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_match_insensitive": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "bool\nrec_match_insensitive (const char *str,\n                       const char *reg)\n{\n  return rec_match_int (str, reg, REG_EXTENDED | REG_ICASE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "bool"
      ]
    },
    "rec_extract_size": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        346,
        1
      ],
      "content": "size_t\nrec_extract_size (const char *str)\n{\n  const char *p;\n  char *condition_str;\n  int res;\n\n  if (!rec_match (str, REC_INT_SIZE_RE))\n    {\n      return 0;\n    }\n\n  p = str;\n  rec_skip_blanks (&p);\n  rec_parse_regexp (&p, \"^[><]=?\", &condition_str);\n  rec_skip_blanks (&p);\n  rec_parse_int (&p, &res);\n\n  return (size_t) res;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "rec_extract_size_condition": {
      "start_point": [
        348,
        0
      ],
      "end_point": [
        396,
        1
      ],
      "content": "enum rec_size_condition_e\nrec_extract_size_condition (const char *str)\n{\n  const char *p;\n  char *condition_str = NULL;\n  enum rec_size_condition_e condition;\n\n  if (!rec_match (str, REC_INT_SIZE_RE))\n    {\n      return SIZE_COND_E;\n    }\n\n  p = str;\n  rec_skip_blanks (&p);\n  rec_parse_regexp (&p, \"^[><]=?\", &condition_str);\n\n  if (condition_str)\n    {\n      if (strcmp (condition_str, \">\") == 0)\n        {\n          condition = SIZE_COND_G;\n        }\n      else if (strcmp (condition_str, \">=\") == 0)\n        {\n          condition = SIZE_COND_GE;\n        }\n      else if (strcmp (condition_str, \"<\") == 0)\n        {\n          condition = SIZE_COND_L;\n        }\n      else if (strcmp (condition_str, \"<=\") == 0)\n        {\n          condition = SIZE_COND_LE;\n        }\n      else\n        {\n          fprintf (stderr, \"internal error: rec_extract_size_condition: invalid condition.\\n\");\n          return SIZE_COND_E;\n        }\n\n      free (condition_str);\n    }\n  else\n    {\n      condition = SIZE_COND_E;\n    }\n\n  return condition;\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "enum rec_size_condition_e",
        "enum",
        "rec_size_condition_e"
      ]
    },
    "rec_timespec_subtract": {
      "start_point": [
        398,
        0
      ],
      "end_point": [
        414,
        1
      ],
      "content": "int\nrec_timespec_subtract (struct timespec *result,\n                       struct timespec *x,\n                       struct timespec *y)\n{\n  result->tv_sec = x->tv_sec - y->tv_sec;\n  result->tv_nsec = x->tv_nsec - y->tv_nsec;\n  if (result->tv_nsec < 0)\n    {\n      /* Overflow.  Subtract one second.  */\n      result->tv_sec--;\n      result->tv_nsec += 1000000000;\n    }\n\n  /* Return whether there is an overflow in the 'tv_sec' field.  */\n  return (result->tv_sec < 0);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rec_endian_swap": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        427,
        1
      ],
      "content": "uint32_t\nrec_endian_swap (uint32_t number)\n{\n  uint32_t res;\n\n  res = (number >> 24)\n    | ((number << 8) & 0x00FF0000)\n    | ((number >> 8) & 0x0000FF00)\n    | (number << 24);\n\n  return res;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "uint32_t"
      ]
    },
    "rec_concat_strings": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "char *\nrec_concat_strings (const char *str1,\n                    const char *str2,\n                    const char *str3)\n{\n  char *res = malloc (strlen (str1) + strlen (str2) + strlen (str3) + 1);\n\n  if (res)\n    {\n      memcpy (res, str1, strlen (str1));\n      memcpy (res + strlen (str1), str2, strlen (str2));\n      memcpy (res + strlen (str1) + strlen (str2), str3, strlen (str3) + 1);\n    }\n\n  return res;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "char",
        "*\nrec_concat_strings (const char *str1,\n                    const char *str2,\n                    const char *str3)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec-utils.h": {},
  "recutils/recutils-1.7/src/rec-writer.c": {
    "rec_writer_new_common": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\nrec_writer_new_common (rec_writer_t writer)\n{\n  writer->file_out = NULL;\n  writer->buf_out = NULL;\n  writer->line = 1;\n  writer->eof = false;\n  writer->collapse_p = false;\n  writer->skip_comments_p = false;\n  writer->mode = REC_WRITER_NORMAL;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec_writer_new": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "rec_writer_t\nrec_writer_new (FILE *file_out)\n{\n  rec_writer_t new;\n\n  new = malloc (sizeof(struct rec_writer_s));\n  if (new)\n    {\n      rec_writer_new_common (new);\n      new->file_out = file_out;\n    }\n\n  return new;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "rec_writer_t"
      ]
    },
    "rec_writer_new_str": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "rec_writer_t\nrec_writer_new_str (char **str, size_t *str_size)\n{\n  rec_writer_t new;\n\n  new = malloc (sizeof(struct rec_writer_s));\n  if (new)\n    {\n      rec_writer_new_common (new);\n      new->buf_out = rec_buf_new (str, str_size);\n    }\n\n  return new;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "rec_writer_t"
      ]
    },
    "rec_writer_destroy": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nrec_writer_destroy (rec_writer_t writer)\n{\n  if (writer)\n    {\n      if (writer->file_out)\n        {\n          fflush (writer->file_out);\n        }\n      if (writer->buf_out)\n        {\n          rec_buf_close (writer->buf_out);\n        }\n\n      free (writer);\n    }\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "rec_write_comment": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "bool\nrec_write_comment (rec_writer_t writer,\n                   rec_comment_t comment)\n{\n  char *line;\n  char *str;\n  char *orig_str;\n  size_t i;\n  \n  if (writer->mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_puts (writer, \"(comment \"))\n        {\n          return false;\n        }\n      if (!rec_writer_putc (writer, '\"'))\n        {\n          return false;\n        }\n\n      str = rec_comment_text (comment);\n      for (i = 0; i < strlen (str); i++)\n        {\n          if (str[i] == '\\n')\n            {\n              if (!rec_writer_puts (writer, \"\\\\n\"))\n                {\n                  return false;\n                }\n            }\n          else\n            {\n              if (!rec_writer_putc (writer, str[i]))\n                {\n                  return false;\n                }\n            }\n        }\n\n      if (!rec_writer_puts (writer, \"\\\")\"))\n        {\n          return false;\n        }\n    }\n  else\n    {\n      /* Every line in the comment is written preceded by a '#'\n         character.  The lines composing the comments are separated by\n         newline characters.  */\n\n      bool first = true;\n      \n      str = strdup (rec_comment_text (comment));\n      orig_str = str; /* Save a pointer to str to deallocate it later,\n                         since strsep will modify the str\n                         variable.  */\n      line = strsep (&str, \"\\n\");\n      do\n        {\n          if (!first)\n            {\n              if (!rec_writer_putc (writer, '\\n'))\n                {\n                  return false;\n                }\n            }\n\n          if (!rec_writer_putc (writer, '#') \n              || !rec_writer_puts (writer, line))\n            {\n              return false;\n            }\n\n          first = false;\n        }\n      while ((line = strsep (&str, \"\\n\")));\n\n      free (orig_str);\n    }\n\n  return true;\n}",
      "lines": 82,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_field": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "bool\nrec_write_field (rec_writer_t writer,\n                 rec_field_t field)\n{\n  size_t pos;\n  const char *fname;\n  const char *fvalue;\n  enum rec_writer_mode_e mode = writer->mode;\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_puts (writer, \"(field \"))\n        {\n          return false;\n        }\n      if (!rec_writer_puts (writer, rec_field_char_location_str (field)))\n        {\n          return false;\n        }\n      if (!rec_writer_putc (writer, ' '))\n        {\n          return false;\n        }\n    }\n\n  if ((mode != REC_WRITER_VALUES) && (mode != REC_WRITER_VALUES_ROW))\n    {\n      fname = rec_field_name (field);\n      if (!rec_write_field_name (writer, fname))\n        {\n          return false;\n        }\n    }\n  \n  /* Write the field value */\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_putc (writer, ' '))\n        {\n          return false;\n        }\n  \n      if (!rec_writer_putc (writer, '\"'))\n        {\n          return false;\n        }\n    }\n\n  fvalue = rec_field_value (field);\n\n  if ((strlen (fvalue) > 0) && (mode == REC_WRITER_NORMAL))\n    {\n      if (!rec_writer_putc (writer, ' '))\n        {\n          return false;\n        }\n    }\n\n  for (pos = 0; pos < strlen (fvalue); pos++)\n    {\n      if (fvalue[pos] == '\\n')\n        {\n          if (mode == REC_WRITER_SEXP)\n            {\n              if (!rec_writer_puts (writer, \"\\\\n\"))\n                {\n                  return false;\n                }\n            }\n          else if (mode == REC_WRITER_NORMAL)\n            {\n              if (!rec_writer_puts (writer, \"\\n+ \"))\n                {\n                  return false;\n                }\n            }\n          else\n            {\n              if (!rec_writer_putc (writer, '\\n'))\n                {\n                  return false;\n                }\n            }\n        }\n      else if (((fvalue[pos] == '\"') || (fvalue[pos] == '\\\\')) && (mode == REC_WRITER_SEXP))\n        {\n          if ((!rec_writer_putc (writer, '\\\\'))\n              || (!rec_writer_putc (writer, fvalue[pos])))\n            {\n              return false;\n            }\n        }\n      else\n        {\n          if (!rec_writer_putc (writer, fvalue[pos]))\n            {\n              /* EOF on output */\n              return false;\n            }\n        }\n    }\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_putc (writer, '\"'))\n        {\n          return false;\n        }\n    }\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_puts (writer, \")\"))\n        {\n          return false;\n        }\n    }\n\n  return true;\n}",
      "lines": 120,
      "depth": 16,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_field_name": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "bool\nrec_write_field_name (rec_writer_t writer,\n                      const char *field_name)\n{\n  /* Field names can be written in several formats, according to the\n   * desired mode:\n   *\n   * REC_WRITER_NORMAL\n   *    The field name is written in rec format. i.e. NP:\n   * REC_WRITER_SEXP\n   *    The field name is a string: \"NP\"\n   */\n\n  enum rec_writer_mode_e mode = writer->mode;\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_putc (writer, '\"'))\n        {\n          return false;\n        }\n    }\n\n  if (!rec_writer_puts (writer, field_name))\n    {\n      return false;\n    }\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_putc (writer, '\"'))\n        {\n          return false;\n        }\n    }\n  else\n    {\n      if (!rec_writer_putc (writer, ':'))\n        {\n          return false;\n        }\n    }\n\n  return true;\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_record": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "bool\nrec_write_record (rec_writer_t writer,\n                  rec_record_t record)\n{\n  bool ret;\n  rec_mset_iterator_t iter;\n  rec_mset_elem_t elem;\n  char *data;\n  size_t num_field, num_elem, num_fields, num_elems;\n  enum rec_writer_mode_e mode = writer->mode;\n\n  ret = true;\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_puts (writer, \"(record \"))\n        return false;\n      if (!rec_writer_puts (writer, rec_record_char_location_str (record)))\n        return false;\n      if (!rec_writer_puts (writer, \" (\\n\"))\n        return false;\n    }\n\n  num_elems = rec_record_num_elems (record);\n  num_fields = rec_record_num_fields (record);\n  num_field = 0;\n  num_elem = 0;\n  iter = rec_mset_iterator (rec_record_mset (record));\n  while (rec_mset_iterator_next (&iter, MSET_ANY, (const void **) &data, &elem))\n    {\n      if (rec_mset_elem_type (elem) == MSET_FIELD)\n        {\n          /* Write a field.  */\n          rec_field_t field = (rec_field_t) data;\n\n          if (!rec_write_field (writer, field))\n            {\n              ret = false;\n              break;\n            }\n\n          /* Include a field separator.  */\n\n          if ((mode == REC_WRITER_VALUES_ROW) \n              && (num_field != (num_fields - 1)))\n            {\n              if(mode == REC_WRITER_VALUES_ROW)\n                {\n                  if (!rec_writer_putc (writer, ' '))\n                    return false;\n                }\n            }\n          else if ((writer->skip_comments_p && (num_field != (num_fields - 1)))\n                   || (!writer->skip_comments_p && (num_elem != (num_elems - 1))))\n            {\n              if (!rec_writer_putc (writer, '\\n'))\n                return false;\n            }\n\n          num_field++;\n        }\n      else if (!writer->skip_comments_p)\n        {\n          /* Write a comment.  */\n\n          rec_comment_t comment = (rec_comment_t) data;\n\n          if ((mode != REC_WRITER_VALUES) && (mode != REC_WRITER_VALUES_ROW))\n            {\n              if (!rec_write_comment (writer, comment))\n                {\n                  ret = false;\n                  break;\n                }\n\n              if (num_elem != (num_elems - 1))\n                {\n                  if (!rec_writer_putc (writer, '\\n'))\n                    return false;\n                }\n            }\n        }\n\n      num_elem++;\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  if (mode == REC_WRITER_SEXP)\n    {\n      if (!rec_writer_puts (writer, \"))\"))\n        {\n          return false;\n        }\n    }\n\n  return ret;\n}",
      "lines": 98,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_rset": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "bool\nrec_write_rset (rec_writer_t writer,\n                rec_rset_t rset)\n{\n  bool ret;\n  rec_record_t descriptor;\n  bool wrote_descriptor;\n  size_t position;\n  size_t descriptor_pos;\n  rec_mset_iterator_t iter;\n  rec_mset_elem_t elem;\n  void *data;\n  enum rec_writer_mode_e mode = writer->mode;\n  \n  ret = true;\n  wrote_descriptor = false;\n  position = 0;\n  descriptor_pos = rec_rset_descriptor_pos (rset);\n  descriptor = rec_rset_descriptor (rset);\n\n  /* Special case: record set containing just the record\n     descriptor.  */\n  if ((rec_rset_num_elems (rset) == 0) && descriptor)\n    {\n      rec_write_record (writer,\n                        rec_rset_descriptor (rset));\n      rec_writer_putc (writer, '\\n');\n\n      return true;\n    }\n\n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_ANY, (const void **) &data, &elem))\n    {\n      if (position != 0)\n        {\n          if (!rec_writer_putc (writer, '\\n'))\n            {\n              ret = false;\n            }\n        }\n\n      if (position == descriptor_pos)\n        {\n          if (descriptor \n              && (!(wrote_descriptor = rec_write_record (writer,\n                                                         rec_rset_descriptor (rset)))))\n            {\n              ret = false;\n            }\n          else\n            {\n              if (wrote_descriptor)\n                {\n                  if (!rec_writer_puts (writer, \"\\n\\n\"))\n                    {\n                      ret = false;\n                    }\n                }\n            }\n        }\n      \n      if (rec_mset_elem_type (elem) == MSET_RECORD)\n        {\n          ret = rec_write_record (writer, (rec_record_t) data);\n        }\n      else if (!writer->skip_comments_p)\n        {\n          ret = rec_write_comment (writer, (rec_comment_t) data);\n        }\n\n      if (!writer->collapse_p || (position == (rec_rset_num_elems (rset) - 1)))\n        {\n          if (!rec_writer_putc (writer, '\\n'))\n            {\n              ret = false;\n            }\n        }\n      \n      if (!ret)\n        {\n          break;\n        }\n      \n      position++;\n    }\n\n  rec_mset_iterator_free (&iter);\n\n  /* Special case:\n   *\n   * # comment 1\n   * \n   * # comment 2\n   * ...\n   * %rec: foo\n   */\n  if (!wrote_descriptor\n      && (descriptor_pos >= rec_rset_num_elems (rset))\n      && rec_rset_descriptor (rset))\n    {\n      if (!rec_writer_putc (writer, '\\n'))\n        {\n          ret = false;\n        }\n      if (!rec_write_record (writer, rec_rset_descriptor (rset)))\n        {\n          ret = false;\n        }\n      if (!rec_writer_putc (writer, '\\n'))\n        {\n          ret = false;\n        }\n    }\n\n  return ret;\n}",
      "lines": 117,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_db": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        621,
        1
      ],
      "content": "bool\nrec_write_db (rec_writer_t writer,\n              rec_db_t db)\n{\n  bool ret;\n  int i;\n\n  ret = true;\n  for (i = 0; i < rec_db_size (db); i++)\n    {\n      rec_rset_t rset = rec_db_get_rset (db, i);\n\n      if (i != 0)\n        {\n          if (!rec_writer_putc (writer, '\\n'))\n            {\n              ret = false;\n              break;\n            }\n        }\n      \n      if (!rec_write_rset (writer, rset))\n        {\n          ret = false;\n          break;\n        }\n    }\n\n  return ret;\n}",
      "lines": 30,
      "depth": 13,
      "decorators": [
        "bool"
      ]
    },
    "rec_write_field_str": {
      "start_point": [
        623,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "char *\nrec_write_field_str (rec_field_t field,\n                     rec_writer_mode_t mode)\n{\n  rec_writer_t writer;\n  char *result;\n  size_t result_size;\n  \n  result = NULL;\n  writer = rec_writer_new_str (&result, &result_size);\n  if (writer)\n    {\n      rec_writer_set_mode (writer, mode);\n      rec_write_field (writer, field);\n      rec_writer_destroy (writer);\n    }\n  \n  return result;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_write_field_str (rec_field_t field,\n                     rec_writer_mode_t mode)",
        "*"
      ]
    },
    "rec_write_field_name_str": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        661,
        1
      ],
      "content": "char *\nrec_write_field_name_str (const char *field_name,\n                          rec_writer_mode_t mode)\n{\n  rec_writer_t writer;\n  char *result;\n  size_t result_size;\n  \n  result = NULL;\n  writer = rec_writer_new_str (&result, &result_size);\n  if (writer)\n    {\n      rec_writer_set_mode (writer, mode);\n      rec_write_field_name (writer, field_name);\n      rec_writer_destroy (writer);\n    }\n  \n  return result;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_write_field_name_str (const char *field_name,\n                          rec_writer_mode_t mode)",
        "*"
      ]
    },
    "rec_write_comment_str": {
      "start_point": [
        663,
        0
      ],
      "end_point": [
        681,
        1
      ],
      "content": "char *\nrec_write_comment_str (rec_comment_t comment,\n                       rec_writer_mode_t mode)\n{\n  rec_writer_t writer;\n  char *result;\n  size_t result_size;\n  \n  result = NULL;\n  writer = rec_writer_new_str (&result, &result_size);\n  if (writer)\n    {\n      rec_writer_set_mode (writer, mode);\n      rec_write_comment (writer, comment);\n      rec_writer_destroy (writer);\n    }\n  \n  return result;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "char",
        "*\nrec_write_comment_str (rec_comment_t comment,\n                       rec_writer_mode_t mode)",
        "*"
      ]
    },
    "rec_write_string": {
      "start_point": [
        683,
        0
      ],
      "end_point": [
        688,
        1
      ],
      "content": "bool\nrec_write_string (rec_writer_t writer,\n                  const char *str)\n{\n  return rec_writer_puts (writer, str);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "bool"
      ]
    },
    "rec_writer_set_collapse": {
      "start_point": [
        690,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "void\nrec_writer_set_collapse (rec_writer_t writer,\n                         bool value)\n{\n  writer->collapse_p = value;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_writer_set_skip_comments": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "void\nrec_writer_set_skip_comments (rec_writer_t writer,\n                              bool value)\n{\n  writer->skip_comments_p = value;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_writer_set_mode": {
      "start_point": [
        704,
        0
      ],
      "end_point": [
        709,
        1
      ],
      "content": "void\nrec_writer_set_mode (rec_writer_t writer,\n                     enum rec_writer_mode_e mode)\n{\n  writer->mode = mode;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "rec_writer_putc": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        731,
        1
      ],
      "content": "static bool\nrec_writer_putc (rec_writer_t writer, char c)\n{\n  bool ret;\n\n  ret = false;\n  if (writer->file_out)\n    {\n      ret = (fputc (c, writer->file_out) != EOF);\n    }\n  if (writer->buf_out)\n    {\n      ret = (rec_buf_putc (c, writer->buf_out) != EOF);\n    }\n\n  return ret;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "rec_writer_puts": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        749,
        1
      ],
      "content": "static bool\nrec_writer_puts (rec_writer_t writer, const char *s)\n{\n  bool ret;\n\n  ret = false;\n  if (writer->file_out)\n    {\n      ret = (fputs (s, writer->file_out) != EOF);\n    }\n  if (writer->buf_out)\n    {\n      ret = (rec_buf_puts (s, writer->buf_out) != EOF);\n    }\n\n  return ret;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec.c": {
    "rec_init": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\nrec_init (void)\n{\n  bindtextdomain (PACKAGE, LOCALEDIR);\n#if defined REMOTE_DESCRIPTORS\n  curl_global_init (CURL_GLOBAL_ALL);\n#endif\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rec_fini": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nrec_fini (void)\n{\n#if defined REMOTE_DESCRIPTORS\n  curl_global_cleanup ();\n#endif\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "recutils/recutils-1.7/src/rec.h": {},
  "recutils/recutils-1.7/torture/runtests.c": {
    "main": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int failures;\n  SRunner *sr;\n\n  sr = srunner_create (NULL);\n\n  srunner_add_suite (sr, tsuite_rec_mset ());\n  srunner_add_suite (sr, tsuite_rec_comment ());\n  srunner_add_suite (sr, tsuite_rec_field_name ());\n  srunner_add_suite (sr, tsuite_rec_fex ());\n  srunner_add_suite (sr, tsuite_rec_type ());\n  srunner_add_suite (sr, tsuite_rec_type_reg ());\n  srunner_add_suite (sr, tsuite_rec_field ());\n  srunner_add_suite (sr, tsuite_rec_record ());\n  srunner_add_suite (sr, tsuite_rec_parser ());\n  srunner_add_suite (sr, tsuite_rec_writer ());\n  srunner_add_suite (sr, tsuite_rec_sex ());\n\n  srunner_set_log (sr, \"tests.log\");\n\n  srunner_run_all (sr, CK_ENV);\n  failures = srunner_ntests_failed (sr);\n  srunner_free (sr);\n\n  return (failures == 0) ? 0 : 1;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-destroy.c": {
    "rec_comment_destroy_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "START_TEST(rec_comment_destroy_nominal)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (\"abc\");\n  fail_if (comment == NULL);\n  rec_comment_destroy (comment);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": null
    },
    "test_rec_comment_destroy": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec-comment-destroy\");\n  tcase_add_test (tc, rec_comment_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-dup.c": {
    "rec_comment_dup_nominal": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "START_TEST(rec_comment_dup_nominal)\n{\n  rec_comment_t comment;\n  rec_comment_t copy;\n\n  comment = rec_comment_new (\"abc\");\n  fail_if (comment == NULL);\n\n  copy = rec_comment_dup (comment);\n  fail_if (copy == NULL);\n  fail_if (copy == comment);\n  fail_if (strcmp (rec_comment_text (copy), \"abc\") != 0);\n  \n  rec_comment_destroy (comment);\n  rec_comment_destroy (copy);\n}",
      "lines": 16,
      "depth": 11,
      "decorators": null
    },
    "test_rec_comment_dup": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_dup (void)\n{\n  TCase *tc = tcase_create (\"rec-comment-dup\");\n  tcase_add_test (tc, rec_comment_dup_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_dup (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-equal-p.c": {
    "rec_comment_equal_p_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "START_TEST(rec_comment_equal_p_nominal)\n{\n  rec_comment_t comment1;\n  rec_comment_t comment2;\n  rec_comment_t comment3;\n  rec_comment_t comment_empty;\n\n  comment1 = rec_comment_new (\"abc\");\n  fail_if (comment1 == NULL);\n  \n  comment2 = rec_comment_new (\"xyz\");\n  fail_if (comment2 == NULL);\n\n  comment3 = rec_comment_new (\"abc\"); /* Same than comment1 */\n  fail_if (comment3 == NULL);\n\n  comment_empty = rec_comment_new (\"\");\n  fail_if (comment_empty == NULL);\n\n  fail_if (rec_comment_equal_p (comment1, comment2));\n  fail_if (rec_comment_equal_p (comment1, comment_empty));\n  fail_if (rec_comment_equal_p (comment2, comment_empty));\n  fail_if (!rec_comment_equal_p (comment1, comment1));\n  fail_if (!rec_comment_equal_p (comment_empty, comment_empty));\n  fail_if (!rec_comment_equal_p (comment1, comment3));\n           \n  rec_comment_destroy (comment1);\n  rec_comment_destroy (comment2);\n  rec_comment_destroy (comment3);\n  rec_comment_destroy (comment_empty);\n}",
      "lines": 31,
      "depth": 9,
      "decorators": null
    },
    "test_rec_comment_equal_p": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_equal_p (void)\n{\n  TCase *tc = tcase_create (\"rec-comment-equal-p\");\n  tcase_add_test (tc, rec_comment_equal_p_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_equal_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-new.c": {
    "rec_comment_new_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_comment_new_nominal)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (\"foo\");\n  fail_if (comment == NULL);\n\n  rec_comment_destroy (comment);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_comment_new_null\n * Unit: rec_comment_new\n * Description:\n * + Create a new comment from a NULL.\n * +\n * + 1. rec_comment_new shall return NULL.\n */\nSTART_TEST(rec_comment_new_null)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (NULL);\n  fail_if (comment != NULL);\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_comment_new_null\n * Unit: rec_comment_new\n * Description:\n * + Create a new comment from a NULL.\n * +\n * + 1. rec_comment_new shall return NULL.\n */"
      ]
    },
    "test_rec_comment_new": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_new (void)\n{\n  TCase *tc = tcase_create (\"rec_comment_new\");\n  tcase_add_test (tc, rec_comment_new_nominal);\n  tcase_add_test (tc, rec_comment_new_null);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-set-text.c": {
    "rec_comment_set_text_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_comment_set_text_nominal)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (\"abc\");\n  fail_if (comment == NULL);\n\n  rec_comment_set_text (&comment, \"xyz\");\n  fail_if (strcmp (\"xyz\",\n                   rec_comment_text (comment)) != 0);\n\n  rec_comment_set_text (&comment, \"\");\n  fail_if (strcmp (\"\",\n                   rec_comment_text (comment)) != 0);\n  \n  rec_comment_destroy (comment);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": null
    },
    "test_rec_comment_set_text": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_set_text (void)\n{\n  TCase *tc = tcase_create (\"rec-comment-set-text\");\n  tcase_add_test (tc, rec_comment_set_text_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_set_text (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/rec-comment-text.c": {
    "rec_comment_text_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "START_TEST(rec_comment_text_nominal)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (\"abc\");\n  fail_if (comment == NULL);\n  fail_if (strcmp (\"abc\",\n                   rec_comment_text (comment)) != 0);\n  \n  rec_comment_destroy (comment);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_comment_text_empty\n * Unit: rec_comment_text\n * Description:\n * + Get the contents of an empty comment.\n * +\n * + 1. The function shall return the empty string.\n */\nSTART_TEST(rec_comment_text_empty)\n{\n  rec_comment_t comment;\n\n  comment = rec_comment_new (\"\");\n  fail_if (comment == NULL);\n  fail_if (strcmp (\"\",\n                   rec_comment_text (comment)) != 0);\n\n  rec_comment_destroy (comment);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_comment_text_empty\n * Unit: rec_comment_text\n * Description:\n * + Get the contents of an empty comment.\n * +\n * + 1. The function shall return the empty string.\n */"
      ]
    },
    "test_rec_comment_text": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_comment_text (void)\n{\n  TCase *tc = tcase_create (\"rec-comment-text\");\n  tcase_add_test (tc, rec_comment_text_nominal);\n  tcase_add_test (tc, rec_comment_text_empty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_comment_text (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-comment/tsuite-rec-comment.c": {
    "tsuite_rec_comment": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "Suite *\ntsuite_rec_comment ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-comment\");\n  suite_add_tcase (s, test_rec_comment_new ());\n  suite_add_tcase (s, test_rec_comment_destroy ());\n  suite_add_tcase (s, test_rec_comment_dup ());\n  suite_add_tcase (s, test_rec_comment_text ());\n  suite_add_tcase (s, test_rec_comment_set_text ());\n  suite_add_tcase (s, test_rec_comment_equal_p ());\n\n  return s;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_comment ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-check.c": {
    "rec_fex_check_simple_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "START_TEST(rec_fex_check_simple_nominal)\n{\n  fail_if (!rec_fex_check (\"foo\", REC_FEX_SIMPLE));\n  fail_if (!rec_fex_check (\"foo bar baz\", REC_FEX_SIMPLE));\n  fail_if (!rec_fex_check (\"foo\\nbar\\nbaz\", REC_FEX_SIMPLE));\n  fail_if (!rec_fex_check (\"foo\\tbar\\tbaz\", REC_FEX_SIMPLE));\n}",
      "lines": 7,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          44,
          0
        ],
        "end_point": [
          56,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_check_simple_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for simple field expressions.\n */\nSTART_TEST(rec_fex_check_simple_invalid)\n{\n  fail_if (rec_fex_check (\"fo!o\", REC_FEX_SIMPLE));\n  fail_if (rec_fex_check (\"foo,bar\", REC_FEX_SIMPLE));\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_check_simple_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for simple field expressions.\n */"
        ]
      },
      {
        "start_point": [
          57,
          0
        ],
        "end_point": [
          70,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_check_csv_nominal\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated simple field expressions.\n */\nSTART_TEST(rec_fex_check_csv_nominal)\n{\n  fail_if (!rec_fex_check (\"foo\", REC_FEX_CSV));\n  fail_if (!rec_fex_check (\"foo,bar,baz\", REC_FEX_CSV));\n  fail_if (!rec_fex_check (\"foobarbaz,bar,baz\", REC_FEX_CSV));\n}",
        "lines": 14,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_check_csv_nominal\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated simple field expressions.\n */"
        ]
      },
      {
        "start_point": [
          71,
          0
        ],
        "end_point": [
          83,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_check_csv_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for csv simple field expressions.\n */\nSTART_TEST(rec_fex_check_csv_invalid)\n{\n  fail_if (rec_fex_check (\"fo!o\", REC_FEX_CSV));\n  fail_if (rec_fex_check (\"foo bar\", REC_FEX_CSV));\n}",
        "lines": 13,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_check_csv_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for csv simple field expressions.\n */"
        ]
      },
      {
        "start_point": [
          84,
          0
        ],
        "end_point": [
          101,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_check_sub_nominal\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated field expressions.\n */\nSTART_TEST(rec_fex_check_sub_nominal)\n{\n  fail_if (!rec_fex_check (\"foo\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foo[10]\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foo,bar,baz\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foo[0],bar[1],baz[2]\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foo[0-10],bar[1-100],baz[2-20]\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foobarbaz,bar,baz\", REC_FEX_SUBSCRIPTS));\n  fail_if (!rec_fex_check (\"foobarbaz,bar[100-0],baz\", REC_FEX_SUBSCRIPTS));\n}",
        "lines": 18,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_check_sub_nominal\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated field expressions.\n */"
        ]
      },
      {
        "start_point": [
          102,
          0
        ],
        "end_point": [
          116,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_check_sub_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated field expressions.\n */\nSTART_TEST(rec_fex_check_sub_invalid)\n{\n  fail_if (rec_fex_check (\"fo!o\", REC_FEX_SUBSCRIPTS));\n  fail_if (rec_fex_check (\"foo[]\", REC_FEX_SUBSCRIPTS));\n  fail_if (rec_fex_check (\"foo bar\", REC_FEX_SUBSCRIPTS));\n  fail_if (rec_fex_check (\"foo,bar[[10]\", REC_FEX_SUBSCRIPTS));\n}",
        "lines": 15,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_check_sub_invalid\n * Unit: rec_fex_check\n * Description:\n * + Check for comma-separated field expressions.\n */"
        ]
      }
    ],
    "test_rec_fex_check": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_check (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_check\");\n  tcase_add_test (tc, rec_fex_check_simple_nominal);\n  tcase_add_test (tc, rec_fex_check_simple_invalid);\n  tcase_add_test (tc, rec_fex_check_csv_nominal);\n  tcase_add_test (tc, rec_fex_check_csv_invalid);\n  tcase_add_test (tc, rec_fex_check_sub_nominal);\n  tcase_add_test (tc, rec_fex_check_sub_invalid);\n\n  return tc;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_check (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-destroy.c": {
    "rec_fex_destroy_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "START_TEST(rec_fex_destroy_nominal)\n{\n  rec_fex_t fex;\n\n  fex = rec_fex_new (\"foo\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "test_rec_fex_destroy": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_new\");\n  tcase_add_test (tc, rec_fex_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-elem-field-name.c": {
    "rec_fex_elem_field_name_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_fex_elem_field_name_nominal)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  const char *fname_bar;\n\n  fname_bar = \"bar\";\n\n  fex = rec_fex_new (\"foo bar baz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  \n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (elem),\n                                    fname_bar));\n\n  rec_fex_destroy (fex);\n}",
      "lines": 18,
      "depth": 11,
      "decorators": null
    },
    "test_rec_fex_elem_field_name": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_elem_field_name (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_elem_field_name\");\n  tcase_add_test (tc, rec_fex_elem_field_name_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_elem_field_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-elem-max.c": {
    "rec_fex_elem_max_nosub": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "START_TEST(rec_fex_elem_max_nosub)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n\n  fex = rec_fex_new (\"foo bar baz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_max (elem) != -1);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          78,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_elem_max_min\n * Unit: rec_fex_elem_max\n * Description:\n * + Get the max index of an entry in\n * + a field expression created with\n * + a min subscript.\n */\nSTART_TEST(rec_fex_elem_max_min)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  \n  fex = rec_fex_new (\"foo,bar[6],baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_max (elem) != -1);\n\n  rec_fex_destroy (fex);\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_elem_max_min\n * Unit: rec_fex_elem_max\n * Description:\n * + Get the max index of an entry in\n * + a field expression created with\n * + a min subscript.\n */"
        ]
      },
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_elem_max_minmax\n * Unit: rec_fex_elem_max\n * Description:\n * + Get the max index of an entry in\n * + a field expression created with\n * + full subscripts (both min and max).\n */\nSTART_TEST(rec_fex_elem_max_minmax)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n\n  fex = rec_fex_new (\"foo,bar[2-10],baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_max (elem) != 10);\n\n  rec_fex_destroy (fex);\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_elem_max_minmax\n * Unit: rec_fex_elem_max\n * Description:\n * + Get the max index of an entry in\n * + a field expression created with\n * + full subscripts (both min and max).\n */"
        ]
      }
    ],
    "test_rec_fex_elem_max": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_fex_elem_max (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_elem_max\");\n  tcase_add_test (tc, rec_fex_elem_max_nosub);\n  tcase_add_test (tc, rec_fex_elem_max_min);\n  tcase_add_test (tc, rec_fex_elem_max_minmax);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_elem_max (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-elem-min.c": {
    "rec_fex_elem_min_nosub": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "START_TEST(rec_fex_elem_min_nosub)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n\n  fex = rec_fex_new (\"foo bar baz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_min (elem) != -1);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          55,
          0
        ],
        "end_point": [
          78,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_elem_min_min\n * Unit: rec_fex_elem_min\n * Description:\n * + Get the min index of an entry in\n * + a field expression created with\n * + a min subscript.\n */\nSTART_TEST(rec_fex_elem_min_min)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  \n  fex = rec_fex_new (\"foo,bar[6],baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_min (elem) != 6);\n\n  rec_fex_destroy (fex);\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_elem_min_min\n * Unit: rec_fex_elem_min\n * Description:\n * + Get the min index of an entry in\n * + a field expression created with\n * + a min subscript.\n */"
        ]
      },
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          102,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_elem_min_minmax\n * Unit: rec_fex_elem_min\n * Description:\n * + Get the min index of an entry in\n * + a field expression created with\n * + full subscripts (both min and max).\n */\nSTART_TEST(rec_fex_elem_min_minmax)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n\n  fex = rec_fex_new (\"foo,bar[2-10],baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_min (elem) != 2);\n\n  rec_fex_destroy (fex);\n}",
        "lines": 24,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_elem_min_minmax\n * Unit: rec_fex_elem_min\n * Description:\n * + Get the min index of an entry in\n * + a field expression created with\n * + full subscripts (both min and max).\n */"
        ]
      }
    ],
    "test_rec_fex_elem_min": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_fex_elem_min (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_elem_min\");\n  tcase_add_test (tc, rec_fex_elem_min_nosub);\n  tcase_add_test (tc, rec_fex_elem_min_min);\n  tcase_add_test (tc, rec_fex_elem_min_minmax);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_elem_min (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-elem-rewrite-to.c": {
    "rec_fex_elem_rewrite_to_default": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "START_TEST(rec_fex_elem_rewrite_to_default)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  \n  fex = rec_fex_new (\"foo,bar,baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  \n  elem = rec_fex_get (fex, 0);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_rewrite_to (elem) != NULL);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_fex_elem_rewrite_to_nominal\n * Unit: rec_fex_elem_rewrite_to\n * Description:\n * + The rewrite_to property of a fex\n * + elem must be properly parsed and returned.\n */\nSTART_TEST(rec_fex_elem_rewrite_to_nominal)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  \n  fex = rec_fex_new (\"foo,bar:xxx,baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  \n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (rec_fex_elem_rewrite_to (elem) == NULL);\n  fail_if (strcmp (rec_fex_elem_rewrite_to (elem), \"xxx\") != 0);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_fex_elem_rewrite_to_nominal\n * Unit: rec_fex_elem_rewrite_to\n * Description:\n * + The rewrite_to property of a fex\n * + elem must be properly parsed and returned.\n */"
      ]
    },
    "test_rec_fex_elem_rewrite_to": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\n\nTCase *\ntest_rec_fex_elem_rewrite_to (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_elem_rewrite_to\");\n  tcase_add_test (tc, rec_fex_elem_rewrite_to_default);\n  tcase_add_test (tc, rec_fex_elem_rewrite_to_nominal);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_elem_rewrite_to (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-get.c": {
    "rec_fex_get_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "START_TEST(rec_fex_get_nominal)\n{\n  rec_fex_t fex;\n  rec_fex_elem_t elem;\n  const char *fname_aaa;\n  const char *fname_bbb;\n\n  fname_aaa = \"aaa\";\n  fname_bbb = \"bbb\";\n\n  fex = rec_fex_new (\"aaa bbb\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 2);\n  \n  elem = rec_fex_get (fex, 0);\n  fail_if (elem == NULL);\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (elem),\n                                    fname_aaa));\n  elem = rec_fex_get (fex, 1);\n  fail_if (elem == NULL);\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (elem),\n                                    fname_bbb));\n\n  rec_fex_destroy (fex);\n}",
      "lines": 25,
      "depth": 11,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_fex_get_invalid\n * Unit: rec_fex_get\n * Description:\n * + Get elements from a field expression\n * + providing invalid positions.\n * +\n * + The calls to 'rec_fex_get' shall return\n * + NULL in those cases.\n */\nSTART_TEST(rec_fex_get_invalid)\n{\n  rec_fex_t fex;\n\n  fex = rec_fex_new (\"aaa bbb ccc\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n\n  fail_if (rec_fex_get (fex, -10) != NULL);\n  fail_if (rec_fex_get (fex, 4) != NULL);\n  fail_if (rec_fex_get (fex, 20000) != NULL);\n\n  rec_fex_destroy (fex);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_fex_get_invalid\n * Unit: rec_fex_get\n * Description:\n * + Get elements from a field expression\n * + providing invalid positions.\n * +\n * + The calls to 'rec_fex_get' shall return\n * + NULL in those cases.\n */"
      ]
    },
    "test_rec_fex_get": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_fex_get (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_get\");\n  tcase_add_test (tc, rec_fex_get_nominal);\n  tcase_add_test (tc, rec_fex_get_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_get (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-new.c": {
    "rec_fex_new_single": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "START_TEST(rec_fex_new_single)\n{\n  rec_fex_t fex;\n  const char *fname_foo;\n  const char *fname_foobar;\n  const char *fname_foobarbaz;\n\n  fex = rec_fex_new (NULL, REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 0);\n  rec_fex_destroy (fex);\n\n  fname_foo = \"foo\";\n  fname_foobar = \"foobar\";\n  fname_foobarbaz = \"foobarbaz\";\n\n  fex = rec_fex_new (\"foo\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foobarbaz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  fail_if (!rec_field_name_equal_p (fname_foobarbaz,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  rec_fex_destroy (fex);\n}",
      "lines": 34,
      "depth": 13,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          72,
          0
        ],
        "end_point": [
          150,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_new_simple\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions of the SIMPLE variety.\n */\nSTART_TEST(rec_fex_new_simple)\n{\n  rec_fex_t fex;\n  const char *fname_foo;\n  const char *fname_foobar;\n  const char *fname_foobarbaz;\n\n  fname_foo = \"foo\";\n  fname_foobar = \"foobar\";\n  fname_foobarbaz = \"foobarbaz\";\n\n  fex = rec_fex_new (\"foo foobar foobarbaz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (!rec_field_name_equal_p (fname_foobar,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 1))));\n  fail_if (!rec_field_name_equal_p (fname_foobarbaz,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 2))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 2)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 2)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"\\tfoo foobar\\n \", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 2);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (!rec_field_name_equal_p (fname_foobar,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 1))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 1)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo\\nfoobar\\nfoobarbaz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (!rec_field_name_equal_p (fname_foobar,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 1))));\n  fail_if (!rec_field_name_equal_p (fname_foobarbaz,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 2))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 2)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 2)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"\\n\\t        foo\\nfoobarbaz\\n\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 2);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (!rec_field_name_equal_p (fname_foobarbaz,\n                                  rec_fex_elem_field_name (rec_fex_get (fex, 1))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 1)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 1)) != -1);\n  rec_fex_destroy (fex);\n}",
        "lines": 79,
        "depth": 13,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_new_simple\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions of the SIMPLE variety.\n */"
        ]
      },
      {
        "start_point": [
          151,
          0
        ],
        "end_point": [
          177,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_new_csv\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions of the CSV variety.\n */\nSTART_TEST(rec_fex_new_csv)\n{\n  rec_fex_t fex;\n\n  fex = rec_fex_new (\"foo\", REC_FEX_CSV);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo,bar,baz\", REC_FEX_CSV);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo,bar\", REC_FEX_CSV);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 2);\n  rec_fex_destroy (fex);\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_new_csv\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions of the CSV variety.\n */"
        ]
      },
      {
        "start_point": [
          178,
          0
        ],
        "end_point": [
          231,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_new_subscripts\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions featuring subscripts.\n */\nSTART_TEST(rec_fex_new_subscripts)\n{\n  rec_fex_t fex;\n  const char *fname_foo;\n  const char *fname_foobar;\n  const char *fname_foobarbaz;\n\n  fname_foo = \"foo\";\n  fname_foobar = \"foobar\";\n  fname_foobarbaz = \"foobarbaz\";\n\n  fex = rec_fex_new (\"foo\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo[1]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != 1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo[1],foobar[0-23],foobarbaz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n  fail_if (!rec_field_name_equal_p (fname_foo,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 0))));\n  fail_if (!rec_field_name_equal_p (fname_foobar,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 1))));\n  fail_if (!rec_field_name_equal_p (fname_foobarbaz,\n                                    rec_fex_elem_field_name (rec_fex_get (fex, 2))));\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 0)) != 1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 0)) != -1);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 1)) != 0);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 1)) != 23);\n  fail_if (rec_fex_elem_min (rec_fex_get (fex, 2)) != -1);\n  fail_if (rec_fex_elem_max (rec_fex_get (fex, 2)) != -1);\n  rec_fex_destroy (fex);\n}",
        "lines": 54,
        "depth": 13,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_new_subscripts\n * Unit: rec_fex_new\n * Description:\n * + Create field expressions featuring subscripts.\n */"
        ]
      },
      {
        "start_point": [
          232,
          0
        ],
        "end_point": [
          277,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_fex_new_invalid\n * Unit: rec_fex_new\n * Description:\n * + Try to create field expressions from an invalid string.\n * + The creation of the fex shall fail.\n */\nSTART_TEST(rec_fex_new_invalid)\n{\n  rec_fex_t fex;\n\n  fex = rec_fex_new (\"\", REC_FEX_SIMPLE);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"?\", REC_FEX_SIMPLE);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo&\", REC_FEX_SIMPLE);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo foo:bar\", REC_FEX_SIMPLE);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo,bar,!,baz\", REC_FEX_CSV);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo[]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo[10 10]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"bar[[10]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"bar,foo[10]]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo[10-]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n\n  fex = rec_fex_new (\"foo[-]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex != NULL);\n}",
        "lines": 46,
        "depth": 8,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_fex_new_invalid\n * Unit: rec_fex_new\n * Description:\n * + Try to create field expressions from an invalid string.\n * + The creation of the fex shall fail.\n */"
        ]
      }
    ],
    "test_rec_fex_new": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_new (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_new\");\n  tcase_add_test (tc, rec_fex_new_single);\n  tcase_add_test (tc, rec_fex_new_simple);\n  tcase_add_test (tc, rec_fex_new_csv);\n  tcase_add_test (tc, rec_fex_new_subscripts);\n  tcase_add_test (tc, rec_fex_new_invalid);\n\n  return tc;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-size.c": {
    "rec_fex_size_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "START_TEST(rec_fex_size_nominal)\n{\n  rec_fex_t fex;\n\n  fex = rec_fex_new (\"foo\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 1);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo bar\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 2);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo,bar,baz\", REC_FEX_CSV);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n  rec_fex_destroy (fex);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": null
    },
    "test_rec_fex_size": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_size (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_size\");\n  tcase_add_test (tc, rec_fex_size_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_size (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-sort.c": {
    "rec_fex_sort_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "START_TEST(rec_fex_sort_nominal)\n{\n  rec_fex_t fex;\n  const char *fname_aaa;\n  const char *fname_bbb;\n  const char *fname_ccc;\n\n  fname_aaa = \"aaa\";\n  fname_bbb = \"bbb\";\n  fname_ccc = \"ccc\";\n\n  fex = rec_fex_new (\"ccc[2],aaa[0],bbb[1]\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  fail_if (rec_fex_size (fex) != 3);\n\n  rec_fex_sort (fex);\n\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (rec_fex_get (fex, 0)),\n                                    fname_aaa));\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (rec_fex_get (fex, 1)),\n                                    fname_bbb));\n  fail_if (!rec_field_name_equal_p (rec_fex_elem_field_name (rec_fex_get (fex, 2)),\n                                    fname_ccc));\n\n  rec_fex_destroy (fex);\n}",
      "lines": 26,
      "depth": 13,
      "decorators": null
    },
    "test_rec_fex_sort": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_sort (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_sort\");\n  tcase_add_test (tc, rec_fex_sort_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_sort (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/rec-fex-str.c": {
    "rec_fex_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "START_TEST(rec_fex_str_nominal)\n{\n  rec_fex_t fex;\n  char *str;\n\n  fex = rec_fex_new (\"foo\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  str = rec_fex_str (fex, REC_FEX_SIMPLE);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_CSV);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_SUBSCRIPTS);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo\") != 0);\n  free (str);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo bar baz\", REC_FEX_SIMPLE);\n  fail_if (fex == NULL);\n  str = rec_fex_str (fex, REC_FEX_SIMPLE);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo bar baz\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_CSV);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo,bar,baz\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_SUBSCRIPTS);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo,bar,baz\") != 0);\n  free (str);\n  rec_fex_destroy (fex);\n\n  fex = rec_fex_new (\"foo[0],bar[1-2],baz\", REC_FEX_SUBSCRIPTS);\n  fail_if (fex == NULL);\n  str = rec_fex_str (fex, REC_FEX_SIMPLE);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo bar baz\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_CSV);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo,bar,baz\") != 0);\n  free (str);\n  str = rec_fex_str (fex, REC_FEX_SUBSCRIPTS);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo[0],bar[1-2],baz\") != 0);\n  free (str);\n  rec_fex_destroy (fex);\n}",
      "lines": 53,
      "depth": 10,
      "decorators": null
    },
    "test_rec_fex_str": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "END_TEST\n\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_fex_str (void)\n{\n  TCase *tc = tcase_create (\"rec_fex_str\");\n  tcase_add_test (tc, rec_fex_str_nominal);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_fex_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-fex/tsuite-rec-fex.c": {
    "tsuite_rec_fex": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "Suite *\ntsuite_rec_fex ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-fex\");\n  suite_add_tcase (s, test_rec_fex_new ());\n  suite_add_tcase (s, test_rec_fex_destroy ());\n  suite_add_tcase (s, test_rec_fex_check ());\n  suite_add_tcase (s, test_rec_fex_sort ());\n  suite_add_tcase (s, test_rec_fex_size ());\n  suite_add_tcase (s, test_rec_fex_get ());\n  suite_add_tcase (s, test_rec_fex_elem_field_name ());\n  suite_add_tcase (s, test_rec_fex_elem_rewrite_to ());\n  suite_add_tcase (s, test_rec_fex_elem_min ());\n  suite_add_tcase (s, test_rec_fex_elem_max ());\n  suite_add_tcase (s, test_rec_fex_str ());\n\n  return s;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_fex ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-char-location-str.c": {
    "rec_field_char_location_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "START_TEST(rec_field_char_location_str_nominal)\n{\n  rec_field_t field;\n  const char *num;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  num = rec_field_char_location_str (field);\n  fail_if (num == NULL);\n  fail_if (strcmp (num, \"\") != 0);\n\n  rec_field_set_char_location (field, 100);\n  num = rec_field_char_location_str (field);\n  fail_if (num == NULL);\n  fail_if (strcmp (num, \"100\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": null
    },
    "test_rec_field_char_location_str": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_char_location_str (void)\n{\n  TCase *tc = tcase_create (\"rec_field_char_location_str\");\n  tcase_add_test (tc, rec_field_char_location_str_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_char_location_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-char-location.c": {
    "rec_field_char_location_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "START_TEST(rec_field_char_location_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  fail_if (rec_field_char_location (field) != 0);\n  rec_field_set_char_location (field, 100);\n  fail_if (rec_field_char_location (field) != 100);\n\n  rec_field_destroy (field);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": null
    },
    "test_rec_field_char_location": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_char_location (void)\n{\n  TCase *tc = tcase_create (\"rec_field_char_location\");\n  tcase_add_test (tc, rec_field_char_location_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_char_location (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-destroy.c": {
    "rec_field_destroy_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "START_TEST(rec_field_destroy_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n\n  rec_field_destroy (field);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "test_rec_field_destroy": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_field_new\");\n  tcase_add_test (tc, rec_field_destroy_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-dup.c": {
    "rec_field_dup_empty": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "START_TEST(rec_field_dup_empty)\n{\n  rec_field_t field;\n  rec_field_t field_copy;\n  const char *field_name;\n  const char *field_value;\n\n  /* Create a field */\n  field_name = \"\";\n  field = rec_field_new (field_name, \"\");\n  fail_if(field == NULL);\n\n  /* Create a copy of the field */\n  field_copy = rec_field_dup (field);\n  fail_if(field_copy == NULL);\n\n  /* Get the attributes of the copy */\n  field_name = rec_field_name (field_copy);\n  field_value = rec_field_value (field_copy);\n\n  /* Validate the attributes */\n  fail_if(strcmp (field_name, \"\") != 0);\n  fail_if(strcmp (field_value, \"\") != 0);\n\n  rec_field_destroy (field);\n  rec_field_destroy (field_copy);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_dup_non_empty\n * Unit: rec_field_dup\n * Description:\n * + Dup a field with non-empty name and non-empty value.\n * +\n * + 1. The name of the copied field should be the\n * +    appropriate.\n * + 2. The value of the copied field should be the\n * +    appropriate.\n */\nSTART_TEST(rec_field_dup_nonempty)\n{\n  rec_field_t field;\n  rec_field_t field_copy;\n  const char *field_name;\n  const char *field_value;\n\n  /* Create a field */\n  field_name = \"name\";\n  field = rec_field_new (field_name, \"value\");\n  fail_if(field == NULL);\n\n  /* Create a copy of the field */\n  field_copy = rec_field_dup (field);\n  fail_if(field_copy == NULL);\n\n  /* Get the attributes of the copy */\n  field_name = rec_field_name (field_copy);\n  field_value = rec_field_value (field_copy);\n\n  /* Validate the attributes */\n  fail_if(strcmp (field_name, \"name\") != 0);\n  fail_if(strcmp (field_value, \"value\") != 0);\n\n  rec_field_destroy (field);\n  rec_field_destroy (field_copy);\n}",
      "lines": 40,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_dup_non_empty\n * Unit: rec_field_dup\n * Description:\n * + Dup a field with non-empty name and non-empty value.\n * +\n * + 1. The name of the copied field should be the\n * +    appropriate.\n * + 2. The value of the copied field should be the\n * +    appropriate.\n */"
      ]
    },
    "test_rec_field_dup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "END_TEST\n\n/* \n * Test case creation function\n */\nTCase *\ntest_rec_field_dup (void)\n{\n  TCase *tc = tcase_create(\"rec_field_dup\");\n  tcase_add_test (tc, rec_field_dup_empty);\n  tcase_add_test (tc, rec_field_dup_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/* \n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_dup (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-equal-p.c": {
    "rec_field_equal_p_equal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "START_TEST(rec_field_equal_p_equal)\n{\n  rec_field_t field1;\n  rec_field_t field2;\n\n  field1 = rec_field_new (\"foo\", \"value\");\n  fail_if (field1 == NULL);\n\n  field2 = rec_field_new (\"foo\", \"value\");\n  fail_if (field2 == NULL);\n\n  fail_if (!rec_field_equal_p (field1, field2));\n\n  rec_field_destroy (field1);\n  rec_field_destroy (field2);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_equal_p_nonequal\n * Unit: rec_field_equal_p\n * Description:\n * + Check whether two different fields are\n * + equal.\n * +\n * + The comparison function shall return false.\n */\nSTART_TEST(rec_field_equal_p_nonequal)\n{\n  rec_field_t field1;\n  rec_field_t field2;\n\n  field1 = rec_field_new (\"foo\", \"value\");\n  fail_if (field1 == NULL);\n  field2 = rec_field_new (\"other\", \"value\");\n  fail_if (field2 == NULL);\n\n  fail_if (rec_field_equal_p (field1, field2));\n\n  rec_field_destroy (field1);\n  rec_field_destroy (field2);\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_equal_p_nonequal\n * Unit: rec_field_equal_p\n * Description:\n * + Check whether two different fields are\n * + equal.\n * +\n * + The comparison function shall return false.\n */"
      ]
    },
    "test_rec_field_equal_p": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function.\n */\nTCase *\ntest_rec_field_equal_p (void)\n{\n  TCase *tc = tcase_create (\"rec_field_equal_p\");\n  tcase_add_test (tc, rec_field_equal_p_equal);\n  tcase_add_test (tc, rec_field_equal_p_nonequal);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function.\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_equal_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-location-str.c": {
    "rec_field_location_str_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_field_location_str_nominal)\n{\n  rec_field_t field;\n  const char *num;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  num = rec_field_location_str (field);\n  fail_if (num == NULL);\n  fail_if (strcmp (num, \"\") != 0);\n\n  rec_field_set_location (field, 100);\n  num = rec_field_location_str (field);\n  fail_if (num == NULL);\n  fail_if (strcmp (num, \"100\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 19,
      "depth": 10,
      "decorators": null
    },
    "test_rec_field_location_str": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_location_str (void)\n{\n  TCase *tc = tcase_create (\"rec_field_location_str\");\n  tcase_add_test (tc, rec_field_location_str_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_location_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-location.c": {
    "rec_field_location_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_field_location_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  fail_if (rec_field_location (field) != 0);\n  rec_field_set_location (field, 100);\n  fail_if (rec_field_location (field) != 100);\n\n  rec_field_destroy (field);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": null
    },
    "test_rec_field_location": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_location (void)\n{\n  TCase *tc = tcase_create (\"rec_field_location\");\n  tcase_add_test (tc, rec_field_location_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_location (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-name.c": {
    "rec_field_name_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "START_TEST(rec_field_name_empty)\n{\n  rec_field_t field;\n  const char *fname;\n  \n  fname = \"\";\n  field = rec_field_new (fname, \"\");\n  fail_if(field == NULL);\n\n  fname = rec_field_name (field);\n  fail_if(strcmp (fname, \"\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_name_nonempty\n * Unit: rec_field_name\n * Description:\n * + Get the name of a field with a non-empty name\n * +\n * + 1. The call should not produce an error.\n * + 2. The name of the field should be properly\n * +    returned.\n */\nSTART_TEST(rec_field_name_nonempty)\n{\n  rec_field_t field;\n  const char *fname;\n  \n  fname = \"foo\";\n  field = rec_field_new (fname, \"\");\n  fail_if(field == NULL);\n\n  fname = rec_field_name (field);\n  fail_if(strcmp (fname, \"foo\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_name_nonempty\n * Unit: rec_field_name\n * Description:\n * + Get the name of a field with a non-empty name\n * +\n * + 1. The call should not produce an error.\n * + 2. The name of the field should be properly\n * +    returned.\n */"
      ]
    },
    "test_rec_field_name": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_name (void)\n{\n  TCase *tc = tcase_create(\"rec_field_name\");\n  tcase_add_test (tc, rec_field_name_empty);\n  tcase_add_test (tc, rec_field_name_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-new.c": {
    "rec_field_new_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_field_new_nominal)\n{\n  const char *fname;\n  rec_field_t field;\n\n  fname = \"foo\";\n  field = rec_field_new (fname, \"value\");\n  fail_if (field == NULL);\n\n  rec_field_destroy (field);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": null
    },
    "test_rec_field_new": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_new (void)\n{\n  TCase *tc = tcase_create (\"rec_field_new\");\n  tcase_add_test (tc, rec_field_new_nominal);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-set-char-location.c": {
    "rec_field_set_char_location_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_field_set_char_location_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  rec_field_set_char_location (field, 100);\n  fail_if (rec_field_char_location (field) != 100);\n\n  rec_field_destroy (field);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": null
    },
    "test_rec_field_set_char_location": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_set_char_location (void)\n{\n  TCase *tc = tcase_create (\"rec_field_set_char_location\");\n  tcase_add_test (tc, rec_field_set_char_location_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_set_char_location (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-set-location.c": {
    "rec_field_set_location_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_field_set_location_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  \n  rec_field_set_location (field, 100);\n  fail_if (rec_field_location (field) != 100);\n\n  rec_field_destroy (field);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": null
    },
    "test_rec_field_set_location": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_set_location (void)\n{\n  TCase *tc = tcase_create (\"rec_field_set_location\");\n  tcase_add_test (tc, rec_field_set_location_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_set_location (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-set-name.c": {
    "rec_field_set_name_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "START_TEST(rec_field_set_name_empty)\n{\n  rec_field_t field;\n  const char *field_name;\n  const char *field_name_2;\n  \n  field_name = \"\";\n  field = rec_field_new (field_name, \"\");\n  fail_if(field == NULL);\n  field_name_2 = \"\";\n  rec_field_set_name (field, field_name_2);\n\n  field_name_2 = rec_field_name (field);\n  fail_if(strcmp (field_name_2, \"\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_set_name_nonempty\n * Unit: rec_field_set_name\n * Description:\n * + Set the name of a field to a non-empty name\n * +\n * + 1. The call should not produce an error.\n * + 2. The name of the field should be properly\n * +    set.\n */\nSTART_TEST(rec_field_set_name_nonempty)\n{\n  rec_field_t field;\n  const char *field_name;\n  const char *field_name_2;\n  \n  field_name = \"\";\n  field = rec_field_new (field_name, \"\");\n  fail_if(field == NULL);\n  field_name_2 = \"foo\";\n\n  rec_field_set_name (field, field_name_2);\n\n  field_name_2 = rec_field_name (field);\n  fail_if(strcmp (field_name_2, \"foo\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_set_name_nonempty\n * Unit: rec_field_set_name\n * Description:\n * + Set the name of a field to a non-empty name\n * +\n * + 1. The call should not produce an error.\n * + 2. The name of the field should be properly\n * +    set.\n */"
      ]
    },
    "test_rec_field_set_name": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_set_name (void)\n{\n  TCase *tc = tcase_create(\"rec_field_set_name\");\n  tcase_add_test (tc, rec_field_set_name_empty);\n  tcase_add_test (tc, rec_field_set_name_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_set_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-set-source.c": {
    "rec_field_set_source_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_field_set_source_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n\n  rec_field_set_source (field, \"source\");\n  fail_if (strcmp (rec_field_source (field), \"source\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": null
    },
    "test_rec_field_set_source": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_set_source (void)\n{\n  TCase *tc = tcase_create (\"rec_field_set_source\");\n  tcase_add_test (tc, rec_field_set_source_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_set_source (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-set-value.c": {
    "rec_field_set_value_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "START_TEST(rec_field_set_value_empty)\n{\n  rec_field_t field;\n  const char *fname;\n  const char *field_value;\n  \n  fname = \"\";\n  field = rec_field_new (fname, \"\");\n  fail_if(field == NULL);\n\n  rec_field_set_value (field, \"\");\n  field_value = rec_field_value (field);\n  fail_if(strcmp (field_value, \"\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_set_value_nonempty\n * Unit: rec_field_set_value\n * Description:\n * + Set the value of a field to a non-empty value\n * +\n * + 1. The call should not produce an error.\n * + 2. The value of the field should be properly\n * +    set.\n */\nSTART_TEST(rec_field_set_value_nonempty)\n{\n  rec_field_t field;\n  const char *fname;\n  const char *field_value;\n  \n  fname = \"\";\n  field = rec_field_new (fname, \"foo\");\n  fail_if(field == NULL);\n\n  rec_field_set_value (field, \"foo\");\n  field_value = rec_field_value (field);\n  fail_if(strcmp (field_value, \"foo\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_set_value_nonempty\n * Unit: rec_field_set_value\n * Description:\n * + Set the value of a field to a non-empty value\n * +\n * + 1. The call should not produce an error.\n * + 2. The value of the field should be properly\n * +    set.\n */"
      ]
    },
    "test_rec_field_set_value": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_set_value (void)\n{\n  TCase *tc = tcase_create(\"rec_field_set_value\");\n  tcase_add_test (tc, rec_field_set_value_empty);\n  tcase_add_test (tc, rec_field_set_value_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_set_value (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-source.c": {
    "rec_field_source_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_field_source_nominal)\n{\n  rec_field_t field;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n\n  fail_if (rec_field_source (field) != NULL);\n  rec_field_set_source (field, \"source\");\n  fail_if (strcmp (rec_field_source (field),\n                   \"source\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": null
    },
    "test_rec_field_source": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_field_source (void)\n{\n  TCase *tc = tcase_create (\"rec_field_source\");\n  tcase_add_test (tc, rec_field_source_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_source (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-to-comment.c": {
    "rec_field_to_comment_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "START_TEST(rec_field_to_comment_nominal)\n{\n  rec_field_t field;\n  rec_comment_t comment;\n\n  field = rec_field_new (\"foo\", \"\");\n  fail_if (field == NULL);\n  comment = rec_field_to_comment (field);\n  fail_if (strcmp (rec_comment_text (comment), \"foo:\") != 0);\n  rec_comment_destroy (comment);\n  rec_field_destroy (field);\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  comment = rec_field_to_comment (field);\n  fail_if (strcmp (rec_comment_text (comment), \"foo: value\") != 0);\n  rec_comment_destroy (comment);\n  rec_field_destroy (field);\n\n  field = rec_field_new (\"foo\", \"line1\\nline2\");\n  fail_if (field == NULL);\n  comment = rec_field_to_comment (field);\n  fail_if (strcmp (rec_comment_text (comment), \"foo: line1\\n+ line2\") != 0);\n  rec_comment_destroy (comment);\n  rec_field_destroy (field);\n}",
      "lines": 26,
      "depth": 11,
      "decorators": null
    },
    "test_rec_field_to_comment": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_to_comment (void)\n{\n  TCase *tc = tcase_create (\"rc_field_to_comment\");\n  tcase_add_test (tc, rec_field_to_comment_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_to_comment (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/rec-field-value.c": {
    "rec_field_value_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_field_value_empty)\n{\n  rec_field_t field;\n  const char *fname;\n  const char *field_value;\n  \n  fname = \"\";\n  field = rec_field_new (fname, \"\");\n  fail_if(field == NULL);\n\n  field_value = rec_field_value (field);\n  fail_if(strcmp (field_value, \"\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_value_nonempty\n * Unit: rec_field_value\n * Description:\n * + Get the value of a field with a non-empty value\n * +\n * + 1. The call should not produce an error.\n * + 2. The value of the field should be properly\n * +    returned.\n */\nSTART_TEST(rec_field_value_nonempty)\n{\n  rec_field_t field;\n  const char *fname;\n  const char *field_value;\n  \n  fname = \"\";\n  field = rec_field_new (fname, \"foo\");\n  fail_if(field == NULL);\n\n  field_value = rec_field_value (field);\n  fail_if(strcmp (field_value, \"foo\") != 0);\n\n  rec_field_destroy (field);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_value_nonempty\n * Unit: rec_field_value\n * Description:\n * + Get the value of a field with a non-empty value\n * +\n * + 1. The call should not produce an error.\n * + 2. The value of the field should be properly\n * +    returned.\n */"
      ]
    },
    "test_rec_field_value": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_value (void)\n{\n  TCase *tc = tcase_create(\"rec_field_value\");\n  tcase_add_test (tc, rec_field_value_empty);\n  tcase_add_test (tc, rec_field_value_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_value (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field/tsuite-rec-field.c": {
    "tsuite_rec_field": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "Suite *\ntsuite_rec_field ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-field\");\n  suite_add_tcase (s, test_rec_field_name ());\n  suite_add_tcase (s, test_rec_field_set_name ());\n  suite_add_tcase (s, test_rec_field_value ());\n  suite_add_tcase (s, test_rec_field_set_value ());\n  suite_add_tcase (s, test_rec_field_dup ());\n  suite_add_tcase (s, test_rec_field_new ());\n  suite_add_tcase (s, test_rec_field_destroy ());\n  suite_add_tcase (s, test_rec_field_equal_p ());\n  suite_add_tcase (s, test_rec_field_source ());\n  suite_add_tcase (s, test_rec_field_set_source ());\n  suite_add_tcase (s, test_rec_field_location ());\n  suite_add_tcase (s, test_rec_field_location_str ());\n  suite_add_tcase (s, test_rec_field_set_location ());\n  suite_add_tcase (s, test_rec_field_char_location ());\n  suite_add_tcase (s, test_rec_field_char_location_str ());\n  suite_add_tcase (s, test_rec_field_set_char_location ());\n  suite_add_tcase (s, test_rec_field_to_comment ());\n\n  return s;\n}",
      "lines": 26,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_field ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field-name/rec-field-name-equal-p.c": {
    "rec_field_name_equal_p_empty": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "START_TEST(rec_field_name_equal_p_empty)\n{\n  const char *fname1 = \"\";\n  const char *fname2 = \"\";\n\n  fail_if (!rec_field_name_equal_p (fname1, fname2));\n}",
      "lines": 7,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_field_name_equal_p_nonempty\n * Unit: rec_field_name_equal_p\n * Description:\n * + Compare two field names with\n * + rec_field_name_equal_p.\n */\nSTART_TEST(rec_field_name_equal_p_nonempty)\n{\n  const char *fname1 = \"a\";\n  const char *fname2 = \"a\";\n  const char *fname3 = \"c\";\n\n  fail_if (!rec_field_name_equal_p (fname1, fname1));\n  fail_if (!rec_field_name_equal_p (fname1, fname2));\n  fail_if (rec_field_name_equal_p (fname1, fname3));\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_field_name_equal_p_nonempty\n * Unit: rec_field_name_equal_p\n * Description:\n * + Compare two field names with\n * + rec_field_name_equal_p.\n */"
      ]
    },
    "test_rec_field_name_equal_p": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_name_equal_p (void)\n{\n  TCase *tc = tcase_create (\"rec-field-name-equal-p\");\n  tcase_add_test (tc, rec_field_name_equal_p_empty);\n  tcase_add_test (tc, rec_field_name_equal_p_nonempty);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_name_equal_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field-name/rec-field-name-normalise.c": {
    "rec_field_name_normalise_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_field_name_normalise_nominal)\n{\n  char *normalised;\n\n  normalised = rec_field_name_normalise (\"abc\");\n  fail_if (normalised == NULL);\n  fail_if (strcmp (normalised, \"abc\") != 0);\n  free (normalised);\n  \n  normalised = rec_field_name_normalise (\"a#c d\");\n  fail_if (normalised == NULL);\n  fail_if (strcmp (normalised, \"a_c_d\") != 0);\n  free (normalised);\n\n  normalised = rec_field_name_normalise (\"a-b%c_d\");\n  fail_if (normalised != NULL);\n  free (normalised);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": null
    },
    "test_rec_field_name_normalise": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_name_normalise (void)\n{\n  TCase *tc = tcase_create (\"rec_field_name_normalise\");\n  tcase_add_test (tc, rec_field_name_normalise_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_name_normalise (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field-name/rec-field-name-p.c": {
    "rec_field_name_part_str_p_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_field_name_part_str_p_nominal)\n{\n  fail_if (rec_field_name_p (\"\"));\n  fail_if (rec_field_name_p (\":\"));\n  fail_if (rec_field_name_p (\"-x\"));\n  fail_if (rec_field_name_p (\"_x\"));\n  fail_if (rec_field_name_p (\"0x\"));\n  fail_if (rec_field_name_p (\"x%\"));\n  fail_if (!rec_field_name_p (\"%\"));\n  fail_if (!rec_field_name_p (\"ax\"));\n  fail_if (!rec_field_name_p (\"Ax\"));\n}",
      "lines": 12,
      "depth": 10,
      "decorators": null
    },
    "test_rec_field_name_p": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_field_name_p (void)\n{\n  TCase *tc = tcase_create (\"rec_field_name_part_str_p\");\n  tcase_add_test (tc, rec_field_name_part_str_p_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_field_name_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-field-name/tsuite-rec-field-name.c": {
    "tsuite_rec_field_name": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "Suite *\ntsuite_rec_field_name ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-field-name\");\n  suite_add_tcase (s, test_rec_field_name_equal_p ());\n  suite_add_tcase (s, test_rec_field_name_normalise ());\n  suite_add_tcase (s, test_rec_field_name_p ());\n\n  return s;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_field_name ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/elem-types.h": {
    "type1_disp": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static void\ntype1_disp (void *data)\n{\n  struct type1_t *s;\n\n  s = (struct type1_t *) data;\n  free (s);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "type1_equal": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static bool\ntype1_equal (void *data1,\n             void *data2)\n{\n  struct type1_t *s1;\n  struct type1_t *s2;\n\n  s1 = (struct type1_t *) data1;\n  s2 = (struct type1_t *) data2;\n\n  return (s1->i == s2->i);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "type1_dup": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static void *\ntype1_dup (void *data)\n{\n  struct type1_t *s;\n  struct type1_t *s_copy;\n\n  s = (struct type1_t *) data;\n  s_copy = malloc (sizeof (struct type1_t));\n  if (s_copy)\n    {\n      s_copy->i = s->i;\n    }\n\n  return (void *) s_copy;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntype1_dup (void *data)",
        "*"
      ]
    },
    "type2_disp": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\ntype2_disp (void *data)\n{\n  struct type2_t *s;\n\n  s = (struct type2_t *) data;\n  free (s);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "type2_equal": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static bool type2_equal (void *data1,\n                         void *data2)\n{\n  struct type2_t *s1;\n  struct type2_t *s2;\n\n  s1 = (struct type2_t *) data1;\n  s2 = (struct type2_t *) data2;\n\n  return (s1->c == s2->c);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "type2_dup": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void *\ntype2_dup (void *data)\n{\n  struct type2_t *s;\n  struct type2_t *s_copy;\n\n  s = (struct type2_t *) data;\n  s_copy = malloc (sizeof (struct type2_t));\n  if (s_copy)\n    {\n      s_copy->c = s->c;\n    }\n\n  return (void *) s_copy;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntype2_dup (void *data)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-count.c": {
    "rec_mset_count_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_mset_count_empty)\n{\n  rec_mset_t mset;\n  \n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  fail_if (rec_mset_count (mset, MSET_ANY) != 0);\n  \n  rec_mset_destroy (mset);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          51,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_count_existing\n * Unit: rec_mset_count\n * Description:\n * + Count the number of elements of a non empty\n * + mset.\n * +\n * + 1. The function shall return the number of\n * +    elements.\n */\nSTART_TEST(rec_mset_count_existing)\n{\n  int type;\n  struct type1_t *elem1;\n  struct type1_t *elem2;\n  rec_mset_elem_t e1;\n  rec_mset_elem_t e2;\n  rec_mset_t mset1;\n\n  /* Create a mset, register a type and insert two elements of that\n     type.  */\n  mset1 = rec_mset_new ();\n  fail_if (mset1 == NULL);\n  type = rec_mset_register_type (mset1,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  elem1 = malloc (sizeof (struct type1_t));\n  fail_if (elem1 == NULL);\n  elem1->i = 1;\n  e1 = rec_mset_append (mset1, type, (void *) elem1, MSET_ANY);\n  fail_if (e1 == NULL);\n\n  elem2 = malloc (sizeof (struct type1_t));\n  fail_if (elem2 == NULL);\n  elem2->i = 2;\n  e2 = rec_mset_append (mset1, type, (void *) elem2, MSET_ANY);\n  fail_if (e2 == NULL);\n\n  /* Count elements.  */\n  fail_if (rec_mset_count (mset1, MSET_ANY) != 2);\n  fail_if (rec_mset_count (mset1, type) != 2);\n\n  rec_mset_destroy (mset1);\n}",
        "lines": 49,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_count_existing\n * Unit: rec_mset_count\n * Description:\n * + Count the number of elements of a non empty\n * + mset.\n * +\n * + 1. The function shall return the number of\n * +    elements.\n */"
        ]
      },
      {
        "start_point": [
          100,
          0
        ],
        "end_point": [
          120,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_count_nonexisting\n * Unit: rec_mset_count\n * Description:\n * + Count the number of total elements pertaining to\n * + an unexisting type in a mset.\n * +\n * + 1. The function shall return 0.\n */\nSTART_TEST(rec_mset_count_nonexisting)\n{\n  rec_mset_t mset;\n  \n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  fail_if (rec_mset_count (mset, MSET_ANY + 1) != 0);\n  \n  rec_mset_destroy (mset);\n}",
        "lines": 21,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_count_nonexisting\n * Unit: rec_mset_count\n * Description:\n * + Count the number of total elements pertaining to\n * + an unexisting type in a mset.\n * +\n * + 1. The function shall return 0.\n */"
        ]
      }
    ],
    "test_rec_mset_count": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_count (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_count\");\n  tcase_add_test (tc, rec_mset_count_empty);\n  tcase_add_test (tc, rec_mset_count_existing);\n  tcase_add_test (tc, rec_mset_count_nonexisting);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_count (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-dup.c": {
    "rec_mset_dup_empty": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "START_TEST(rec_mset_dup_empty)\n{\n  rec_mset_t mset1;\n  rec_mset_t mset2;\n\n  /* Create an empty mset.  */\n  mset1 = rec_mset_new ();\n  fail_if (mset1 == NULL);\n\n  /* Get a copy.  */\n  mset2 = rec_mset_dup (mset1);\n  fail_if (mset2 == NULL);\n  fail_if (rec_mset_count (mset2, MSET_ANY) != 0);\n\n  rec_mset_destroy (mset1);\n  rec_mset_destroy (mset2);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_mset_dup_nonempty\n * Unit: rec_mset_dup\n * Description:\n * + Dup an mset containing two elements of a nonempty type.\n * +\n * + 1. The copy shall be successfully returned.\n * + 2. The copy shall contain the same elements.\n */\nSTART_TEST(rec_mset_dup_nonempty)\n{\n  int type;\n  struct type1_t *elem1;\n  struct type1_t *elem2;\n  rec_mset_elem_t e1;\n  rec_mset_elem_t e2;\n  rec_mset_t mset1;\n  rec_mset_t mset2;\n\n  /* Create a mset, register a type and insert two elements of that\n     type.  */\n  mset1 = rec_mset_new ();\n  fail_if (mset1 == NULL);\n  type = rec_mset_register_type (mset1,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  elem1 = malloc (sizeof (struct type1_t));\n  fail_if (elem1 == NULL);\n  elem1->i = 1;\n  e1 = rec_mset_append (mset1, type, (void *) elem1, MSET_ANY);\n  fail_if (e1 == NULL);\n\n  elem2 = malloc (sizeof (struct type1_t));\n  fail_if (elem2 == NULL);\n  elem2->i = 2;\n  e2 = rec_mset_append (mset1, type, (void *) elem2, MSET_ANY);\n  fail_if (e2 == NULL);\n\n  /* Make a copy of the mset.  */\n  mset2 = rec_mset_dup (mset1);\n  fail_if (mset2 == NULL);\n  fail_if (rec_mset_count (mset2, type) != 2);\n  \n  rec_mset_destroy (mset1);\n  rec_mset_destroy (mset2);\n}",
      "lines": 51,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_mset_dup_nonempty\n * Unit: rec_mset_dup\n * Description:\n * + Dup an mset containing two elements of a nonempty type.\n * +\n * + 1. The copy shall be successfully returned.\n * + 2. The copy shall contain the same elements.\n */"
      ]
    },
    "test_rec_mset_dup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_dup (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_dup\");\n  tcase_add_test (tc, rec_mset_dup_empty);\n  tcase_add_test (tc, rec_mset_dup_nonempty);\n  \n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_dup (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-get-at.c": {
    "rec_mset_get_at_empty": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "START_TEST(rec_mset_get_at_empty)\n{\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  fail_if (rec_mset_get_at (mset, MSET_ANY, 0) != NULL);\n\n  rec_mset_destroy (mset);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          50,
          0
        ],
        "end_point": [
          90,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_get_at_existing\n * Unit: rec_mset_get\n * Description:\n * + Get an existing element from a mset.\n * +\n * + 1. The function shall return a pointer to\n * +    the element.\n */\nSTART_TEST(rec_mset_get_at_existing)\n{\n  int type;\n  struct type1_t *elem1, *elem1aux;\n  rec_mset_elem_t e1;\n  rec_mset_t mset;\n\n  /* Create a mset, register a type and insert two elements of that\n     type.  */\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  elem1 = malloc (sizeof (struct type1_t));\n  fail_if (elem1 == NULL);\n  elem1->i = 1;\n  e1 = rec_mset_append (mset, type, (void *) elem1, MSET_ANY);\n  fail_if (e1 == NULL);\n\n  /* Get the element and compare.  */\n  elem1aux = rec_mset_get_at (mset, type, 0);\n  fail_if (elem1aux == NULL);\n  fail_if (elem1aux != elem1);\n\n  rec_mset_destroy (mset);\n}",
        "lines": 41,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_get_at_existing\n * Unit: rec_mset_get\n * Description:\n * + Get an existing element from a mset.\n * +\n * + 1. The function shall return a pointer to\n * +    the element.\n */"
        ]
      },
      {
        "start_point": [
          91,
          0
        ],
        "end_point": [
          132,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_get_at_any\n * Unit: rec_mset_get\n * Description:\n * + Get an existing element from a mset using\n * + the ANY index.\n * +\n * + 1. The function shall return a pointer to\n * +    the element.\n */\nSTART_TEST(rec_mset_get_at_any)\n{\n  int type;\n  struct type1_t *elem1, *elem1aux;\n  rec_mset_elem_t e1;\n  rec_mset_t mset;\n\n  /* Create a mset, register a type and insert two elements of that\n     type.  */\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  elem1 = malloc (sizeof (struct type1_t));\n  fail_if (elem1 == NULL);\n  elem1->i = 1;\n  e1 = rec_mset_append (mset, type, (void *) elem1, MSET_ANY);\n  fail_if (e1 == NULL);\n\n  /* Get the element and compare.  */\n  elem1aux = rec_mset_get_at (mset, MSET_ANY, 0);\n  fail_if (elem1aux == NULL);\n  fail_if (elem1aux != elem1);\n\n  rec_mset_destroy (mset);\n}",
        "lines": 42,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_get_at_any\n * Unit: rec_mset_get\n * Description:\n * + Get an existing element from a mset using\n * + the ANY index.\n * +\n * + 1. The function shall return a pointer to\n * +    the element.\n */"
        ]
      },
      {
        "start_point": [
          133,
          0
        ],
        "end_point": [
          175,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_get_at_invalid\n * Unit: rec_mset_get_at\n * Description:\n * + Get the first element of a mset by using invalid\n * + indexes.\n * +\n * + 1. The function shall return NULL.\n */\nSTART_TEST(rec_mset_get_at_invalid)\n{\n  int type;\n  struct type1_t *elem1;\n  rec_mset_elem_t e1;\n  rec_mset_elem_t e1aux;\n  rec_mset_t mset;\n\n  /* Create a mset, register a type and insert two elements of that\n     type.  */\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  elem1 = malloc (sizeof (struct type1_t));\n  fail_if (elem1 == NULL);\n  elem1->i = 1;\n  e1 = rec_mset_append (mset, type, (void *) elem1, MSET_ANY);\n  fail_if (e1 == NULL);\n\n  /* Try to get invalid elements.  */\n  e1aux = rec_mset_get_at (mset, MSET_ANY, -10);\n  fail_if (e1aux != NULL);\n  e1aux = rec_mset_get_at (mset, MSET_ANY, 1000);\n  fail_if (e1aux != NULL);\n\n  rec_mset_destroy (mset);\n}",
        "lines": 43,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_get_at_invalid\n * Unit: rec_mset_get_at\n * Description:\n * + Get the first element of a mset by using invalid\n * + indexes.\n * +\n * + 1. The function shall return NULL.\n */"
        ]
      }
    ],
    "test_rec_mset_get_at": {
      "start_point": [
        176,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "END_TEST\n\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_get_at (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_get\");\n  tcase_add_test (tc, rec_mset_get_at_empty);\n  tcase_add_test (tc, rec_mset_get_at_existing);\n  tcase_add_test (tc, rec_mset_get_at_any);\n  tcase_add_test (tc, rec_mset_get_at_invalid);\n\n  return tc;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_get_at (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-new.c": {
    "rec_mset_new_and_destroy": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_mset_new_and_destroy)\n{\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  rec_mset_destroy (mset);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": null
    },
    "test_rec_mset_new": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_new (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_new\");\n  tcase_add_test (tc, rec_mset_new_and_destroy);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-register-type.c": {
    "rec_mset_register_type_nominal": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "START_TEST(rec_mset_register_type_nominal)\n{\n  int type;\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n\n  fail_if (type <= 0);\n  rec_mset_destroy (mset);\n}",
      "lines": 17,
      "depth": 7,
      "decorators": null
    },
    "test_rec_mset_register_type": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_register_type (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_register_type\");\n  tcase_add_test (tc, rec_mset_register_type_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_register_type (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/rec-mset-type-p.c": {
    "rec_mset_type_p_any": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "START_TEST(rec_mset_type_p_any)\n{\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n\n  fail_if (!rec_mset_type_p (mset, MSET_ANY));\n  rec_mset_destroy (mset);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          50,
          0
        ],
        "end_point": [
          78,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_mset_type_p_existing\n * Unit: rec_mset_type_p\n * Description:\n * + Register a type in an empty mset and check\n * + for it with rec_mset_type_p.\n * +\n * + 1. The function shall report that the type\n * +    exists.\n */\nSTART_TEST(rec_mset_type_p_existing)\n{\n  int type;\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  \n  fail_if (!rec_mset_type_p (mset, type));\n  rec_mset_destroy (mset);\n}",
        "lines": 29,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_type_p_existing\n * Unit: rec_mset_type_p\n * Description:\n * + Register a type in an empty mset and check\n * + for it with rec_mset_type_p.\n * +\n * + 1. The function shall report that the type\n * +    exists.\n */"
        ]
      },
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          108,
          1
        ],
        "content": "END_TEST\n\n\n/*-\n * Test: rec_mset_type_p_nonexisting\n * Unit: rec_mset_type_p\n * Description:\n * + Register a type in an empty mset and check\n * + for other type with rec_mset_type_p.\n * +\n * + 1. The function shall report that the type\n * +    does not exist.\n */\nSTART_TEST(rec_mset_type_p_nonexisting)\n{\n  int type;\n  rec_mset_t mset;\n\n  mset = rec_mset_new ();\n  fail_if (mset == NULL);\n  type = rec_mset_register_type (mset,\n                                 TYPE1,\n                                 type1_disp,\n                                 type1_equal,\n                                 type1_dup,\n                                 NULL);\n  \n  fail_if (rec_mset_type_p (mset, type + 1));\n  rec_mset_destroy (mset);\n}",
        "lines": 30,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_mset_type_p_nonexisting\n * Unit: rec_mset_type_p\n * Description:\n * + Register a type in an empty mset and check\n * + for other type with rec_mset_type_p.\n * +\n * + 1. The function shall report that the type\n * +    does not exist.\n */"
        ]
      }
    ],
    "test_rec_mset_type_p": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_mset_type_p (void)\n{\n  TCase *tc = tcase_create (\"rec_mset_type_p\");\n  tcase_add_test (tc, rec_mset_type_p_any);\n  tcase_add_test (tc, rec_mset_type_p_existing);\n  tcase_add_test (tc, rec_mset_type_p_nonexisting);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_mset_type_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-mset/tsuite-rec-mset.c": {
    "tsuite_rec_mset": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "Suite *\ntsuite_rec_mset ()\n{\n  Suite *s;\n  \n  s = suite_create (\"rec-mset\");\n  suite_add_tcase (s, test_rec_mset_new ());\n  suite_add_tcase (s, test_rec_mset_dup ());\n  suite_add_tcase (s, test_rec_mset_type_p ());\n  suite_add_tcase (s, test_rec_mset_register_type ());\n  suite_add_tcase (s, test_rec_mset_count ());\n  suite_add_tcase (s, test_rec_mset_get_at ());\n\n  return s;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_mset ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-db.c": {
    "rec_parse_db_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_parse_db_nominal)\n{\n  rec_parser_t parser;\n  rec_db_t db;\n  char *str;\n\n  str = \"%rec: foo\\n\\nfoo: bar\\n\\n%rec: bar\\n\\nfoo: bar\\n\\nfoo: bar\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (!rec_parse_db (parser, &db));\n  fail_if (rec_db_size (db) != 2);\n  rec_db_destroy (db);\n  rec_parser_destroy (parser);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_db_invalid\n * Unit: rec_parse_db\n * Description:\n * + Try to parse invalid databases.\n */\nSTART_TEST(rec_parse_db_invalid)\n{\n  /* Nothing here, since the empty string is a valid (empty)\n     database.  */\n}",
      "lines": 13,
      "depth": 5,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_db_invalid\n * Unit: rec_parse_db\n * Description:\n * + Try to parse invalid databases.\n */"
      ]
    },
    "test_rec_parse_db": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_db (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_db\");\n  tcase_add_test (tc, rec_parse_db_nominal);\n  tcase_add_test (tc, rec_parse_db_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_db (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-field-name-str.c": {
    "rec_parse_field_name_str_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "START_TEST(rec_parse_field_name_str_nominal)\n{\n  char *fname;\n\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  fail_if (strcmp (fname, \"foo\") != 0);\n  free (fname);\n\n  fname = rec_parse_field_name_str (\"foo:\");\n  fail_if (fname == NULL);\n  fail_if (strcmp (fname, \"foo\") != 0);\n  free (fname);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_field_name_str_invalid\n * Unit: rec_parse_field_name_str\n * Description:\n * + Try to parse invalid field names.\n */\nSTART_TEST(rec_parse_field_name_str_invalid)\n{\n  char *fname;\n\n  fname = rec_parse_field_name_str (\"\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\"fo!o\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\"foo::\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\":foo\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\"foobar baz\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\"foo:bar:baz\");\n  fail_if (fname != NULL);\n\n  fname = rec_parse_field_name_str (\"foo:baz!!#\");\n  fail_if (fname != NULL);\n}",
      "lines": 33,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_field_name_str_invalid\n * Unit: rec_parse_field_name_str\n * Description:\n * + Try to parse invalid field names.\n */"
      ]
    },
    "test_rec_parse_field_name_str": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_field_name_str (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_field_name_str\");\n  tcase_add_test (tc, rec_parse_field_name_str_nominal);\n  tcase_add_test (tc, rec_parse_field_name_str_invalid);\n  \n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_field_name_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-field-name.c": {
    "rec_parse_field_name_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "START_TEST(rec_parse_field_name_nominal)\n{\n  rec_parser_t parser;\n  char *fname;\n  char *str;\n\n  str = \"foo:\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field_name (parser, &fname));\n  fail_if (strcmp (fname, \"foo\") != 0);\n  free (fname);\n  rec_parser_destroy (parser);\n\n  str = \"%foo:\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field_name (parser, &fname));\n  fail_if (strcmp (fname, \"%foo\") != 0);\n  free (fname);\n  rec_parser_destroy (parser);\n}",
      "lines": 22,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_field_name_invalid\n * Unit: rec_parse_field_name\n * Description:\n * + Try to parse invalid field names.\n */\nSTART_TEST(rec_parse_field_name_invalid)\n{\n  rec_parser_t parser;\n  char *fname;\n  char *str;  \n\n  str = \" \";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field_name (parser, &fname));\n  rec_parser_destroy (parser);\n\n  str = \"foo\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field_name (parser, &fname));\n  rec_parser_destroy (parser);\n\n  str = \":foo\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field_name (parser, &fname));\n  rec_parser_destroy (parser);\n\n  str = \"fo!o\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field_name (parser, &fname));\n  rec_parser_destroy (parser);\n\n  str = \"%%foo\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field_name (parser, &fname));\n  rec_parser_destroy (parser);\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_field_name_invalid\n * Unit: rec_parse_field_name\n * Description:\n * + Try to parse invalid field names.\n */"
      ]
    },
    "test_rec_parse_field_name": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_field_name (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_field_name\");\n  tcase_add_test (tc, rec_parse_field_name_nominal);\n  tcase_add_test (tc, rec_parse_field_name_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_field_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-field.c": {
    "rec_parse_field_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "START_TEST(rec_parse_field_nominal)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *fname;\n  char *str;\n\n  str = \"foo: bar\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"bar\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo:  bar\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \" bar\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo: bar \";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"bar \") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo:\\n\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo:\\n+ bar\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"\\nbar\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo:\\n+bar\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"\\nbar\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo: bar\\n+baz\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"bar\\nbaz\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo: one\\n+\\n+ \\n+ two\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"one\\n\\n\\ntwo\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  str = \"foo: bar \\\\\\nbaz\";\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (strcmp (rec_field_value (field), \"bar baz\") != 0);\n  free (fname);\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n\n  /*  str = \"foo:\";\n  stm = fmemopen (str, strlen (str), \"r\");\n  fail_if (stm == NULL);\n  parser = rec_parser_new (stm, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_field (parser, &field));\n  rec_parser_destroy (parser);\n  fclose (stm); */\n}",
      "lines": 115,
      "depth": 11,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_field_invalid\n * Unit: rec_parse_field\n * Description:\n * + Try to parse invalid fields.\n */\nSTART_TEST(rec_parse_field_invalid)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *str;\n\n  str = \" \";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_field (parser, &field));\n  rec_parser_destroy (parser);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_field_invalid\n * Unit: rec_parse_field\n * Description:\n * + Try to parse invalid fields.\n */"
      ]
    },
    "test_rec_parse_field": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_field (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_field\");\n  tcase_add_test (tc, rec_parse_field_nominal);\n  tcase_add_test (tc, rec_parse_field_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_field (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-record-str.c": {
    "rec_parse_record_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "START_TEST(rec_parse_record_str_nominal)\n{\n  rec_record_t record;\n  rec_field_t field;\n  char *fname;\n\n  record = rec_parse_record_str (\"foo: bar\");\n  fail_if (record == NULL);\n  fname = rec_parse_field_name_str (\"foo\");\n  fail_if (fname == NULL);\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 0);\n  fail_if (strcmp (rec_field_value (field), \"bar\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                    rec_field_name (field)));\n  free (fname);\n  rec_record_destroy (record);\n}",
      "lines": 17,
      "depth": 11,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_record_str_invalid\n * Unit: rec_parse_record_str\n * Description:\n * + Try to parse invalid records from strings.\n */\nSTART_TEST(rec_parse_record_str_invalid)\n{\n  rec_record_t record;\n  \n  record = rec_parse_record_str (\"\");\n  fail_if (record != NULL);\n\n  record = rec_parse_record_str (\" \");\n  fail_if (record != NULL);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_record_str_invalid\n * Unit: rec_parse_record_str\n * Description:\n * + Try to parse invalid records from strings.\n */"
      ]
    },
    "test_rec_parse_record_str": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function.\n */\nTCase *\ntest_rec_parse_record_str (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_record_str\");\n  tcase_add_test (tc, rec_parse_record_str_nominal);\n  tcase_add_test (tc, rec_parse_record_str_invalid);\n  \n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function.\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_record_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-record.c": {
    "rec_parse_record_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "START_TEST(rec_parse_record_nominal)\n{\n  rec_parser_t parser;\n  rec_record_t record;\n  rec_field_t field;\n  char *fname;\n  char *str;\n\n  str = \"foo: bar\";\n  fname = rec_parse_field_name_str (\"foo\");\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_record (parser, &record));\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 0);\n  fail_if (strcmp (rec_field_value (field), \"bar\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  rec_record_destroy (record);\n  rec_parser_destroy (parser);\n  free (fname);\n\n  str = \"foo: bar\\nfoo2: bar2\";\n  fname = rec_parse_field_name_str (\"foo\");\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_record (parser, &record));\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 0);\n  fail_if (strcmp (rec_field_value (field), \"bar\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  free (fname);\n  fname = rec_parse_field_name_str (\"foo2\");\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 1);\n  fail_if (strcmp (rec_field_value (field), \"bar2\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  free (fname);\n  rec_record_destroy (record);\n  rec_parser_destroy (parser);\n\n  str = \"foo: bar\\nfoo2:\\nfoo3: bar3\";\n  fname = rec_parse_field_name_str (\"foo\");\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (!rec_parse_record (parser, &record));\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 0);\n  fail_if (strcmp (rec_field_value (field), \"bar\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  free (fname);\n  fname = rec_parse_field_name_str (\"foo2\");\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 1);\n  fail_if (strcmp (rec_field_value (field), \"\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  free (fname);\n  fname = rec_parse_field_name_str (\"foo3\");\n  field = (rec_field_t) rec_mset_get_at (rec_record_mset (record), MSET_FIELD, 2);\n  fail_if (strcmp (rec_field_value (field), \"bar3\") != 0);\n  fail_if (!rec_field_name_equal_p (fname,\n                                  rec_field_name (field)));\n  free (fname);\n  rec_record_destroy (record);\n  rec_parser_destroy (parser);\n}",
      "lines": 65,
      "depth": 11,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_record_invalid\n * Unit: rec_parse_record\n * Description:\n * + Try to parse invalid records.\n */\nSTART_TEST(rec_parse_record_invalid)\n{\n  rec_parser_t parser;\n  rec_record_t record;\n  char *str;\n\n  str = \" \";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_record (parser, &record));\n  rec_parser_destroy (parser);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_record_invalid\n * Unit: rec_parse_record\n * Description:\n * + Try to parse invalid records.\n */"
      ]
    },
    "test_rec_parse_record": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_record (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_record\");\n  tcase_add_test (tc, rec_parse_record_nominal);\n  tcase_add_test (tc, rec_parse_record_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_record (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parse-rset.c": {
    "rec_parse_rset_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "START_TEST(rec_parse_rset_nominal)\n{\n  rec_parser_t parser;\n  rec_rset_t rset;\n  char *str;\n\n  str = \"foo1: bar1\\n\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (!rec_parse_rset (parser, &rset));\n  fail_if (rec_rset_num_records (rset) != 3);\n  rec_rset_destroy (rset);\n  rec_parser_destroy (parser);\n\n  str = \"%rec: foo\\n\\nfoo1: bar1\\n\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (!rec_parse_rset (parser, &rset));\n  fail_if (rec_rset_num_records (rset) != 3);\n  rec_rset_destroy (rset);\n  rec_parser_destroy (parser);\n\n  str = \"foo1: bar1\\n\\n#foo2: bar2\\n\\nfoo3: bar3\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (!rec_parse_rset (parser, &rset));\n  fail_if (rec_rset_num_elems (rset) != 3);\n  fail_if (rec_rset_num_comments (rset) != 1);\n  fail_if (rec_rset_num_records (rset) != 2);\n  rec_rset_destroy (rset);\n  rec_parser_destroy (parser);\n}",
      "lines": 29,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_parse_rset_invalid\n * Unit: rec_parse_rset\n * Description:\n * + Try to parse invalid record sets.\n */\nSTART_TEST(rec_parse_rset_invalid)\n{\n  rec_parser_t parser;\n  rec_rset_t rset;\n  char *str;\n\n  str = \" \";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parse_rset (parser, &rset));\n  rec_parser_destroy (parser);\n\n  /* A record set shall have at least one record.  */\n  str = \"#foo1: bar1\\n\\n#foo2: bar2\\n\\n#foo3: bar3\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (rec_parse_rset (parser, &rset));\n  rec_parser_destroy (parser);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_parse_rset_invalid\n * Unit: rec_parse_rset\n * Description:\n * + Try to parse invalid record sets.\n */"
      ]
    },
    "test_rec_parse_rset": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parse_rset (void)\n{\n  TCase *tc = tcase_create (\"rec_parse_rset\");\n  tcase_add_test (tc, rec_parse_rset_nominal);\n  tcase_add_test (tc, rec_parse_rset_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parse_rset (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-destroy.c": {
    "rec_parser_destroy_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "START_TEST(rec_parser_destroy_nominal)\n{\n  rec_parser_t parser;\n\n  parser = rec_parser_new (stdin, \"stdin\");\n  fail_if (parser == NULL);\n\n  rec_parser_destroy (parser);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "test_rec_parser_destroy": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_destroy\");\n  tcase_add_test (tc, rec_parser_destroy_nominal);\n  \n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-eof.c": {
    "rec_parser_eof_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "START_TEST(rec_parser_eof_nominal)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *str;\n\n  str = \"foo: bar\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (rec_parser_eof (parser));\n  fail_if (!rec_parse_field (parser, &field));\n  fail_if (!rec_parser_eof (parser));\n  rec_field_destroy (field);\n  rec_parser_destroy (parser);\n}",
      "lines": 14,
      "depth": 10,
      "decorators": null
    },
    "test_rec_parser_eof": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_eof (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_eof\");\n  tcase_add_test (tc, rec_parser_eof_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_eof (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-error.c": {
    "rec_parser_error_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "START_TEST(rec_parser_error_nominal)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *str;\n\n  str = \"invalid field\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parser_error (parser));\n  fail_if (rec_parse_field (parser, &field));\n  fail_if (!rec_parser_error (parser));\n  rec_parser_destroy (parser);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": null
    },
    "test_rec_parser_error": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_error (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_error\");\n  tcase_add_test (tc, rec_parser_error_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_error (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-new-mem.c": {
    "rec_parser_new_mem_nominal": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_parser_new_mem_nominal)\n{\n  rec_parser_t parser;\n  rec_rset_t rset;\n  char *str;\n  char *short_str;\n\n  str = \"foo1: bar1\\n\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  short_str = \"foo1: bar1\\n\\nfoo2: bar2\";\n  parser = rec_parser_new_mem (str, strlen(short_str), \"dummy\");\n  fail_if (!rec_parse_rset (parser, &rset));\n  fail_if (rec_rset_num_records (rset) != 2);\n  rec_rset_destroy (rset);\n  rec_parser_destroy (parser);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": null
    },
    "test_rec_parser_new_mem": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_new_mem (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_new_mem\");\n  tcase_add_test (tc, rec_parser_new_mem_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_new_mem (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-new-str.c": {
    "rec_parser_new_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_parser_new_str_nominal)\n{\n  rec_parser_t parser;\n  char *buffer = \"foo: bar\";\n\n  parser = rec_parser_new_str (buffer, \"buffer\");\n  fail_if (parser == NULL);\n\n  rec_parser_destroy (parser);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": null
    },
    "test_rec_parser_new_str": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_new_str (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_new_str\");\n  tcase_add_test (tc, rec_parser_new_str_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_new_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-new.c": {
    "rec_parser_new_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "START_TEST(rec_parser_new_nominal)\n{\n  rec_parser_t parser;\n\n  parser = rec_parser_new (stdin, \"stdin\");\n  fail_if (parser == NULL);\n\n  rec_parser_destroy (parser);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "test_rec_parser_new": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_new (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_new\");\n  tcase_add_test (tc, rec_parser_new_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-perror.c": {
    "rec_parser_perror_nominal": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "START_TEST(rec_parser_perror_nominal)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *str;\n\n  str = \"invalid field\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parser_error (parser));\n  fail_if (rec_parse_field (parser, &field));\n  fail_if (!rec_parser_error (parser));\n  rec_parser_perror (parser, \"expected error while parsing: \");\n  rec_parser_destroy (parser);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": null
    },
    "test_rec_parser_perror": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_perror (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_perror\");\n  tcase_add_test (tc, rec_parser_perror_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_perror (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-reset.c": {
    "rec_parser_reset_nominal": {
      "start_point": [
        19,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "START_TEST(rec_parser_reset_nominal)\n{\n  rec_parser_t parser;\n  rec_field_t field;\n  char *str;\n\n  str = \"invalid field\";\n  parser = rec_parser_new_str (str, \"dummy\");\n  fail_if (parser == NULL);\n  fail_if (rec_parser_error (parser));\n  fail_if (rec_parse_field (parser, &field));\n  fail_if (!rec_parser_error (parser));\n  rec_parser_reset (parser);\n  fail_if (rec_parser_error (parser));\n  rec_parser_destroy (parser);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": null
    },
    "test_rec_parser_reset": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_reset (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_reset\");\n  tcase_add_test (tc, rec_parser_reset_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_reset (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/rec-parser-seek-mem.c": {
    "rec_parser_seek_mem_tell": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "START_TEST(rec_parser_seek_mem_tell)\n{\n  rec_parser_t parser;\n  char *str;\n  size_t position;\n\n  str = \"foo1: bar1\\n\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  position = strlen (\"foo1: bar\\n\\n\");\n  parser = rec_parser_new_mem (str, strlen (str), \"dummy\");\n  fail_if (!parser);\n  fail_if (rec_parser_tell (parser) != 0);\n  fail_if (!rec_parser_seek (parser, 3, position));\n  fail_if (rec_parser_tell (parser) != position);\n  rec_parser_destroy (parser);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          53,
          0
        ],
        "end_point": [
          78,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_parser_seek_mem_skip\n * Unit: rec_parser_seek_mem\n * Description:\n * + Check that seek might skip a part of a record.\n */\nSTART_TEST(rec_parser_seek_mem_skip)\n{\n  rec_parser_t parser;\n  rec_record_t record;\n  char *str;\n  size_t position;\n\n  str = \"foo1: bar1\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  position = strlen (\"foo1: bar1\\n\");\n  parser = rec_parser_new_mem (str, strlen (str), \"dummy\");\n  fail_if (!parser);\n  fail_if (!rec_parser_seek (parser, 2, position));\n  fail_if (!rec_parse_record (parser, &record));\n  fail_if (rec_record_num_fields (record) != 1);\n  fail_if (rec_record_location (record) != 2);\n  rec_record_destroy (record);\n  rec_parser_destroy (parser);\n}",
        "lines": 26,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_parser_seek_mem_skip\n * Unit: rec_parser_seek_mem\n * Description:\n * + Check that seek might skip a part of a record.\n */"
        ]
      },
      {
        "start_point": [
          79,
          0
        ],
        "end_point": [
          99,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_parser_seek_mem_fail\n * Unit: rec_parser_seek_mem\n * Description:\n * + Check that seek outside the file fails.\n */\nSTART_TEST(rec_parser_seek_mem_fail)\n{\n  rec_parser_t parser;\n  char *str;\n  size_t position;\n\n  str = \"foo1: bar1\\n\\nfoo2: bar2\\n\\nfoo3: bar3\";\n  position = strlen (str) + 100;\n  parser = rec_parser_new_mem (str, strlen (str), \"dummy\");\n  fail_if (!parser);\n  fail_if (rec_parser_seek (parser, 20, position));\n  rec_parser_destroy (parser);\n}",
        "lines": 21,
        "depth": 9,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_parser_seek_mem_fail\n * Unit: rec_parser_seek_mem\n * Description:\n * + Check that seek outside the file fails.\n */"
        ]
      }
    ],
    "test_rec_parser_seek_mem": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_parser_seek_mem (void)\n{\n  TCase *tc = tcase_create (\"rec_parser_seek_mem\");\n  tcase_add_test (tc, rec_parser_seek_mem_tell);\n  tcase_add_test (tc, rec_parser_seek_mem_skip);\n  tcase_add_test (tc, rec_parser_seek_mem_fail);\n\n  return tc;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_parser_seek_mem (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-parser/tsuite-rec-parser.c": {
    "tsuite_rec_parser": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "Suite *\ntsuite_rec_parser ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-parser\");\n  suite_add_tcase (s, test_rec_parser_new ());\n  suite_add_tcase (s, test_rec_parser_new_str ());\n  suite_add_tcase (s, test_rec_parser_new_mem ());\n  suite_add_tcase (s, test_rec_parser_destroy ());\n  suite_add_tcase (s, test_rec_parse_field_name_str ());\n  suite_add_tcase (s, test_rec_parse_field_name ());\n  suite_add_tcase (s, test_rec_parse_field ());\n  suite_add_tcase (s, test_rec_parse_record ());\n  suite_add_tcase (s, test_rec_parse_record_str ());\n  suite_add_tcase (s, test_rec_parse_rset ());\n  suite_add_tcase (s, test_rec_parse_db ());\n  suite_add_tcase (s, test_rec_parser_eof ());\n  suite_add_tcase (s, test_rec_parser_error ());\n  suite_add_tcase (s, test_rec_parser_reset ());\n  suite_add_tcase (s, test_rec_parser_perror ());\n  suite_add_tcase (s, test_rec_parser_seek_mem ());\n\n  return s;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_parser ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-record/tsuite-rec-record.c": {
    "tsuite_rec_record": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "Suite *\ntsuite_rec_record ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-record\");\n  /*  suite_add_tcase (s, test_rec_record_new ());\n  suite_add_tcase (s, test_rec_record_size ());\n  suite_add_tcase (s, test_rec_record_field_p ());\n  suite_add_tcase (s, test_rec_record_insert_field ());\n  suite_add_tcase (s, test_rec_record_remove_field ()); */\n\n  return s;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_record ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-sex/rec-sex-compile.c": {
    "rec_sex_compile_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "START_TEST(rec_sex_compile_nominal)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  fail_if (!rec_sex_compile (sex,\n                             \"true\"));\n  rec_sex_destroy (sex);\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  fail_if (!rec_sex_compile (sex,\n                             \"false\"));\n  rec_sex_destroy (sex);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_sex_compile_invalid\n * Unit: rec_sex_compile\n * Description:\n * + Try to compile invalid selection expressions.\n */\nSTART_TEST(rec_sex_compile_invalid)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  fail_if (rec_sex_compile (sex, \"\"));\n  rec_sex_destroy (sex);\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  fail_if (rec_sex_compile (sex, \"+\"));\n  rec_sex_destroy (sex);\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_sex_compile_invalid\n * Unit: rec_sex_compile\n * Description:\n * + Try to compile invalid selection expressions.\n */"
      ]
    },
    "test_rec_sex_compile": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_sex_compile (void)\n{\n  TCase *tc = tcase_create (\"rec_sex_compile\");\n  tcase_add_test (tc, rec_sex_compile_nominal);\n  tcase_add_test (tc, rec_sex_compile_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_sex_compile (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-sex/rec-sex-destroy.c": {
    "rec_sex_destroy_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_sex_destroy_nominal)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (true);\n  fail_if (sex == NULL);\n  rec_sex_destroy (sex);\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  rec_sex_destroy (sex);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": null
    },
    "test_rec_sex_destroy": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_sex_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_sex_destroy\");\n  tcase_add_test (tc, rec_sex_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_sex_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-sex/rec-sex-eval.c": {
    "rec_sex_eval_match": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "START_TEST(rec_sex_eval_match)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n\n  rec_sex_destroy (sex);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_sex_eval_nomatch\n * Unit: rec_sex_eval\n * Description:\n * + Eval SEX expressions against non matching\n * + records.\n */\nSTART_TEST(rec_sex_eval_nomatch)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n\n  rec_sex_destroy (sex);\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_sex_eval_nomatch\n * Unit: rec_sex_eval\n * Description:\n * + Eval SEX expressions against non matching\n * + records.\n */"
      ]
    },
    "test_rec_sex_eval": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_sex_eval (void)\n{\n  TCase *tc = tcase_create (\"rec_sex_eval\");\n  tcase_add_test (tc, rec_sex_eval_match);\n  tcase_add_test (tc, rec_sex_eval_nomatch);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_sex_eval (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-sex/rec-sex-new.c": {
    "rec_sex_new_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_sex_new_nominal)\n{\n  rec_sex_t sex;\n\n  sex = rec_sex_new (true);\n  fail_if (sex == NULL);\n  rec_sex_destroy (sex);\n\n  sex = rec_sex_new (false);\n  fail_if (sex == NULL);\n  rec_sex_destroy (sex);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": null
    },
    "test_rec_sex_new": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_sex_new (void)\n{\n  TCase *tc = tcase_create (\"rec_sex_new\");\n  tcase_add_test (tc, rec_sex_new_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_sex_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-sex/tsuite-rec-sex.c": {
    "tsuite_rec_sex": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "Suite *\ntsuite_rec_sex ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-sex\");\n  suite_add_tcase (s, test_rec_sex_new ());\n  suite_add_tcase (s, test_rec_sex_destroy ());\n  suite_add_tcase (s, test_rec_sex_compile ());\n  suite_add_tcase (s, test_rec_sex_eval ());\n\n  return s;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_sex ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-check.c": {
    "rec_type_check_int": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "START_TEST(rec_type_check_int)\n{\n  rec_type_t type;\n  char *err_str;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"10\", NULL));\n  fail_if (!rec_type_check (type, \"01\", NULL));\n  fail_if (!rec_type_check (type, \"-10\", NULL));\n  fail_if (!rec_type_check (type, \"  10  \\n\\t \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"abc\", NULL));\n  fail_if (rec_type_check (type, \"a10\", NULL));\n  fail_if (rec_type_check (type, \"10a\", &err_str));\n  fail_if (err_str == NULL);\n  free (err_str);\n\n  rec_type_destroy (type);\n}",
      "lines": 23,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          60,
          0
        ],
        "end_point": [
          85,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_bool\n * Unit: rec_type_check\n * Description:\n * + Check strings of type bool.\n */\nSTART_TEST(rec_type_check_bool)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"bool\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"true\", NULL));\n  fail_if (!rec_type_check (type, \"false\", NULL));\n  fail_if (!rec_type_check (type, \"1\", NULL));\n  fail_if (!rec_type_check (type, \"0\", NULL));\n  fail_if (!rec_type_check (type, \"yes\", NULL));\n  fail_if (!rec_type_check (type, \"no\", NULL));\n  fail_if (!rec_type_check (type, \"  yes  \\n\\t \", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 26,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_bool\n * Unit: rec_type_check\n * Description:\n * + Check strings of type bool.\n */"
        ]
      },
      {
        "start_point": [
          86,
          0
        ],
        "end_point": [
          116,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_range\n * Unit: rec_type_check\n * Description:\n * + Check strings of type range.\n */\nSTART_TEST(rec_type_check_range)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"range -10 10\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"-10\", NULL));\n  fail_if (!rec_type_check (type, \"10\", NULL));\n  fail_if (!rec_type_check (type, \"010\", NULL));\n  fail_if (!rec_type_check (type, \"5\", NULL));\n  fail_if (!rec_type_check (type, \"  5   \\n\\t  \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"-100\", NULL));\n  fail_if (rec_type_check (type, \"100\", NULL));\n  fail_if (rec_type_check (type, \"-11\", NULL));\n  fail_if (rec_type_check (type, \"11\", NULL));\n  fail_if (rec_type_check (type, \"abc\", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 31,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_range\n * Unit: rec_type_check\n * Description:\n * + Check strings of type range.\n */"
        ]
      },
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          146,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_real\n * Unit: rec_type_check\n * Description:\n * + Check strings of type real.\n */\nSTART_TEST(rec_type_check_real)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"real\");\n  \n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"3\", NULL));\n  fail_if (!rec_type_check (type, \"-3\", NULL));\n  fail_if (!rec_type_check (type, \"03\", NULL));\n  fail_if (!rec_type_check (type, \"3.14\", NULL));\n  fail_if (!rec_type_check (type, \"-3.14\", NULL));\n  fail_if (!rec_type_check (type, \".10\", NULL));\n  fail_if (!rec_type_check (type, \"-.10\", NULL));\n  fail_if (!rec_type_check (type, \"  3.14  \\n\\t  \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"abc\", NULL));\n  fail_if (rec_type_check (type, \"3.14a\", NULL));\n  \n  rec_type_destroy (type);\n}",
        "lines": 30,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_real\n * Unit: rec_type_check\n * Description:\n * + Check strings of type real.\n */"
        ]
      },
      {
        "start_point": [
          147,
          0
        ],
        "end_point": [
          172,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_size\n * Unit: rec_type_check\n * Description:\n * + Check strings of type size.\n */\nSTART_TEST(rec_type_check_size)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"size 5\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"\", NULL));\n  fail_if (!rec_type_check (type, \"abcde\", NULL));\n  fail_if (!rec_type_check (type, \"ab\", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \" abcde \", NULL));\n  fail_if (rec_type_check (type, \"abcdef\", NULL));\n  \n  rec_type_destroy (type);\n}",
        "lines": 26,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_size\n * Unit: rec_type_check\n * Description:\n * + Check strings of type size.\n */"
        ]
      },
      {
        "start_point": [
          173,
          0
        ],
        "end_point": [
          197,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_line\n * Unit: rec_type_check\n * Description:\n * + Check strings of type line.\n */\nSTART_TEST(rec_type_check_line)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"line\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"\", NULL));\n  fail_if (!rec_type_check (type, \"A line.\", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"\\n\", NULL));\n  fail_if (rec_type_check (type, \"several\\nlines\\n\", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_line\n * Unit: rec_type_check\n * Description:\n * + Check strings of type line.\n */"
        ]
      },
      {
        "start_point": [
          198,
          0
        ],
        "end_point": [
          222,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_regexp\n * Unit: rec_type_check\n * Description:\n * + Check strings of type regexp.\n */\nSTART_TEST(rec_type_check_regexp)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"regexp /[abc][abc][abc]$/\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"abc\", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"\", NULL));\n  fail_if (rec_type_check (type, \"abcx\", NULL));\n  fail_if (rec_type_check (type, \"abc \", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_regexp\n * Unit: rec_type_check\n * Description:\n * + Check strings of type regexp.\n */"
        ]
      },
      {
        "start_point": [
          223,
          0
        ],
        "end_point": [
          246,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_date\n * Unit: rec_type_check\n * Description:\n * + Check strings of type date.\n */\nSTART_TEST(rec_type_check_date)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"date\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"13 August 1980\", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"\", NULL));\n  fail_if (rec_type_check (type, \"1000 November -10\", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 24,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_date\n * Unit: rec_type_check\n * Description:\n * + Check strings of type date.\n */"
        ]
      },
      {
        "start_point": [
          247,
          0
        ],
        "end_point": [
          275,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_enum\n * Unit: rec_type_check\n * Description:\n * + Check strings of type enum.\n */\nSTART_TEST(rec_type_check_enum)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"enum A B C\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"A\", NULL));\n  fail_if (!rec_type_check (type, \"B\", NULL));\n  fail_if (!rec_type_check (type, \"C\", NULL));\n  fail_if (!rec_type_check (type, \" B  \\n\\t  \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"A B\", NULL));\n  fail_if (rec_type_check (type, \"XXX\", NULL));\n  fail_if (rec_type_check (type, \"\", NULL));\n  fail_if (rec_type_check (type, \" \", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 29,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_enum\n * Unit: rec_type_check\n * Description:\n * + Check strings of type enum.\n */"
        ]
      },
      {
        "start_point": [
          276,
          0
        ],
        "end_point": [
          303,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_field\n * Unit: rec_type_check\n * Description:\n * + Check strings of type field.\n */\nSTART_TEST(rec_type_check_field)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"field\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"a\", NULL));\n  fail_if (!rec_type_check (type, \"   ac \\n\\t \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"\", NULL));\n  fail_if (rec_type_check (type, \" \", NULL));\n  fail_if (rec_type_check (type, \"a:\", NULL));\n  fail_if (rec_type_check (type, \"a:b:\", NULL));\n  fail_if (rec_type_check (type, \"a%:b:\", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 28,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_field\n * Unit: rec_type_check\n * Description:\n * + Check strings of type field.\n */"
        ]
      },
      {
        "start_point": [
          304,
          0
        ],
        "end_point": [
          328,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_type_check_email\n * Unit: rec_type_check\n * Description:\n * + Check strings of type email.\n */\nSTART_TEST(rec_type_check_email)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"email\");\n  fail_if (type == NULL);\n\n  /* Positive tests.  */\n  fail_if (!rec_type_check (type, \"jemarch@gnu.org\", NULL));\n  fail_if (!rec_type_check (type, \" jemarch@gnu.org  \\n\\t \", NULL));\n\n  /* Negative tests.  */\n  fail_if (rec_type_check (type, \"\", NULL));\n  fail_if (rec_type_check (type, \"invalid@@email.com\", NULL));\n\n  rec_type_destroy (type);\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_type_check_email\n * Unit: rec_type_check\n * Description:\n * + Check strings of type email.\n */"
        ]
      }
    ],
    "test_rec_type_check": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function.\n */\nTCase *\ntest_rec_type_check (void)\n{\n  TCase *tc = tcase_create (\"rec_type_check\");\n  tcase_add_test (tc, rec_type_check_int);\n  tcase_add_test (tc, rec_type_check_bool);\n  tcase_add_test (tc, rec_type_check_range);\n  tcase_add_test (tc, rec_type_check_real);\n  tcase_add_test (tc, rec_type_check_size);\n  tcase_add_test (tc, rec_type_check_line);\n  tcase_add_test (tc, rec_type_check_regexp);\n  tcase_add_test (tc, rec_type_check_date);\n  tcase_add_test (tc, rec_type_check_enum);\n  tcase_add_test (tc, rec_type_check_field);\n  tcase_add_test (tc, rec_type_check_email);\n\n  return tc;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function.\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_check (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-descr-p.c": {
    "rec_type_descr_p_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "START_TEST(rec_type_descr_p_nominal)\n{\n  fail_if (!rec_type_descr_p (\"int\"));\n  fail_if (!rec_type_descr_p (\"int  \\n\\n  \"));\n  fail_if (!rec_type_descr_p (\"bool\"));\n  fail_if (!rec_type_descr_p (\"range 10\"));\n  fail_if (!rec_type_descr_p (\"range 1 10\"));\n  fail_if (!rec_type_descr_p (\"real\"));\n  fail_if (!rec_type_descr_p (\"size 10\"));\n  fail_if (!rec_type_descr_p (\"line\"));\n  fail_if (!rec_type_descr_p (\"regexp /[abc][abc][abc]/\"));\n  fail_if (!rec_type_descr_p (\"regexp |/jo/jo|\"));\n  fail_if (!rec_type_descr_p (\"date\"));\n  fail_if (!rec_type_descr_p (\"enum A B C\"));\n  fail_if (!rec_type_descr_p (\"field\"));\n  fail_if (!rec_type_descr_p (\"email\"));\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_type_descr_p_invalid\n * Unit: rec_type_descr_p\n * Description:\n * + Check for invalid type descriptions.\n */\nSTART_TEST(rec_type_descr_p_invalid)\n{\n  fail_if (rec_type_descr_p (\"\"));\n  fail_if (rec_type_descr_p (\" \"));\n  fail_if (rec_type_descr_p (\"int additionalstuff\"));\n  fail_if (rec_type_descr_p (\"invalidkeyword\"));\n  fail_if (rec_type_descr_p (\"range a b\"));\n  fail_if (rec_type_descr_p (\"range a 1\"));\n  fail_if (rec_type_descr_p (\"range 1 a\"));\n  fail_if (rec_type_descr_p (\"size\"));\n  fail_if (rec_type_descr_p (\"size xxx\"));\n  fail_if (rec_type_descr_p (\"size 10 extra\"));\n  fail_if (rec_type_descr_p (\"regexp\"));\n  fail_if (rec_type_descr_p (\"regexp foo\"));\n  fail_if (rec_type_descr_p (\"regexp /abc/ extra\"));\n  fail_if (rec_type_descr_p (\"enum\"));\n  fail_if (rec_type_descr_p (\"enum # ! '\"));\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_type_descr_p_invalid\n * Unit: rec_type_descr_p\n * Description:\n * + Check for invalid type descriptions.\n */"
      ]
    },
    "test_rec_type_descr_p": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_descr_p (void)\n{\n  TCase *tc = tcase_create (\"rec_type_descr_p\");\n  tcase_add_test (tc, rec_type_descr_p_nominal);\n  tcase_add_test (tc, rec_type_descr_p_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_descr_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-destroy.c": {
    "rec_type_destroy_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "START_TEST(rec_type_destroy_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n\n  rec_type_destroy (type);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": null
    },
    "test_rec_type_destroy": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_type_destroy\");\n  tcase_add_test (tc, rec_type_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-equal-p.c": {
    "rec_type_equal_p_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "START_TEST(rec_type_equal_p_nominal)\n{\n  rec_type_t type1;\n  rec_type_t type2;\n\n  type1 = rec_type_new (\"int\");\n  type2 = rec_type_new (\"int\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"bool\");\n  type2 = rec_type_new (\"bool\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"range 1 10\");\n  type2 = rec_type_new (\"range 1 10\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"range 1 10\");\n  type2 = rec_type_new (\"range -10 0\");\n  fail_if (rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"real\");\n  type2 = rec_type_new (\"real\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"size 10\");\n  type2 = rec_type_new (\"size 10\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"size 10\");\n  type2 = rec_type_new (\"size 20\");\n  fail_if (rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"line\");\n  type2 = rec_type_new (\"line\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"date\");\n  type2 = rec_type_new (\"date\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"enum A B C\");\n  type2 = rec_type_new (\"enum A B C \\n\\n  \");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"enum A B C\");\n  type2 = rec_type_new (\"enum B C A\");\n  fail_if (rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"enum A B C\");\n  type2 = rec_type_new (\"enum B C A D\");\n  fail_if (rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"field\");\n  type2 = rec_type_new (\"field\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n\n  type1 = rec_type_new (\"email\");\n  type2 = rec_type_new (\"email\");\n  fail_if (!rec_type_equal_p (type1, type2));\n  rec_type_destroy (type1);\n  rec_type_destroy (type2);\n}",
      "lines": 89,
      "depth": 9,
      "decorators": null
    },
    "test_rec_type_equal_p": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_equal_p (void)\n{\n  TCase *tc = tcase_create (\"rec_type_equal_p\");\n  tcase_add_test (tc, rec_type_equal_p_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_equal_p (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-kind-str.c": {
    "rec_type_kind_str_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "START_TEST(rec_type_kind_str_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"int\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"bool\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"bool\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"range 1 10\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"range\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"real\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"real\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"size 10\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"size\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"line\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"line\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"regexp /[abc]/\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"regexp\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"date\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"date\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"enum A B C\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"enum\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"email\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"email\") != 0);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"field\");\n  fail_if (type == NULL);\n  fail_if (strcmp (rec_type_kind_str (type), \"field\") != 0);\n  rec_type_destroy (type);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": null
    },
    "test_rec_type_kind_str": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_kind_str (void)\n{\n  TCase *tc = tcase_create (\"rec_type_kind_str\");\n  tcase_add_test (tc, rec_type_kind_str_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_kind_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-kind.c": {
    "rec_type_kind_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "START_TEST(rec_type_kind_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_INT);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"bool\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_BOOL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"range 1 10\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_RANGE);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"real\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_REAL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"size 10\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_SIZE);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"line\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_LINE);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"regexp /[abc]/\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_REGEXP);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"date\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_DATE);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"enum A B C\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_ENUM);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"field\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_FIELD);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"email\");\n  fail_if (type == NULL);\n  fail_if (rec_type_kind (type) != REC_TYPE_EMAIL);\n  rec_type_destroy (type);\n}",
      "lines": 59,
      "depth": 9,
      "decorators": null
    },
    "test_rec_type_kind": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_kind (void)\n{\n  TCase *tc = tcase_create (\"rec_type_kind\");\n  tcase_add_test (tc, rec_type_kind_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_kind (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-name.c": {
    "rec_type_name_anonymous": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "START_TEST(rec_type_name_anonymous)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n  fail_if (rec_type_name (type) != NULL);\n\n  rec_type_destroy (type);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_type_name_nominal\n * Unit: rec_type_name\n * Description:\n * + Get the name of a type.\n * + The returned name shall be correct.\n */\nSTART_TEST(rec_type_name_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"range 0 120\");\n  fail_if (type == NULL);\n  rec_type_set_name (type, \"age_t\");\n  fail_if (strcmp (\"age_t\",\n                   rec_type_name (type)) != 0);\n\n  rec_type_destroy (type);\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_type_name_nominal\n * Unit: rec_type_name\n * Description:\n * + Get the name of a type.\n * + The returned name shall be correct.\n */"
      ]
    },
    "test_rec_type_name": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function.\n */\nTCase *\ntest_rec_type_name (void)\n{\n  TCase *tc = tcase_create (\"rec_type_name\");\n  tcase_add_test (tc, rec_type_name_anonymous);\n  tcase_add_test (tc, rec_type_name_nominal);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function.\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-new.c": {
    "rec_type_new_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "START_TEST(rec_type_new_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"int   \\n\\n  \");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"bool\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n  \n  type = rec_type_new (\"range 10\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"range 1 10\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"real\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"size 10\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"line\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"regexp /[abc][abc][abc]/\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"regexp |/jo/jo|\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"date\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"enum A B C\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"field\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n\n  type = rec_type_new (\"email\");\n  fail_if (type == NULL);\n  rec_type_destroy (type);\n}",
      "lines": 60,
      "depth": 8,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_type_new_invalid\n * Unit: rec_type_new\n * Description:\n * + Try to create types from invalid type descriptions.\n */\nSTART_TEST(rec_type_new_invalid)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\" \");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"int additionalstuff\");\n  fail_if (type != NULL);\n  \n  type = rec_type_new (\"invalidkeyword\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"range\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"range a\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"range a b\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"range a 1\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"range 1 a\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"size\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"size xxx\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"size 10 extra\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"regexp\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"regexp foo\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"regexp /abc/ extra\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"enum\");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"enum  \");\n  fail_if (type != NULL);\n\n  type = rec_type_new (\"enum # ! '\");\n  fail_if (type != NULL);\n}",
      "lines": 66,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_type_new_invalid\n * Unit: rec_type_new\n * Description:\n * + Try to create types from invalid type descriptions.\n */"
      ]
    },
    "test_rec_type_new": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_new (void)\n{\n  TCase *tc = tcase_create (\"rec_type_new\");\n  tcase_add_test (tc, rec_type_new_nominal);\n  tcase_add_test (tc, rec_type_new_invalid);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/rec-type-set-name.c": {
    "rec_type_set_name_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_type_set_name_nominal)\n{\n  rec_type_t type;\n\n  type = rec_type_new (\"int\");\n  fail_if (type == NULL);\n  rec_type_set_name (type, \"foo_t\");\n  fail_if (strcmp (\"foo_t\",\n                   rec_type_name (type)) != 0);\n\n  rec_type_destroy (type);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": null
    },
    "test_rec_type_set_name": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function.\n */\nTCase *\ntest_rec_type_set_name (void)\n{\n  TCase *tc = tcase_create (\"rec_type_set_name\");\n  tcase_add_test (tc, rec_type_set_name_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function.\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_set_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type/tsuite-rec-type.c": {
    "tsuite_rec_type": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "Suite *\ntsuite_rec_type ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-type\");\n  suite_add_tcase (s, test_rec_type_new ());\n  suite_add_tcase (s, test_rec_type_destroy ());\n  suite_add_tcase (s, test_rec_type_descr_p ());\n  suite_add_tcase (s, test_rec_type_kind ());\n  suite_add_tcase (s, test_rec_type_kind_str ());\n  suite_add_tcase (s, test_rec_type_equal_p ());\n  suite_add_tcase (s, test_rec_type_check ());\n  suite_add_tcase (s, test_rec_type_name ());\n  suite_add_tcase (s, test_rec_type_set_name ());\n\n  return s;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_type ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type-reg/rec-type-reg-destroy.c": {
    "rec_type_reg_destroy_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "START_TEST(rec_type_reg_destroy_nominal)\n{\n  rec_type_reg_t reg;\n\n  reg = rec_type_reg_new ();\n  fail_if (reg == NULL);\n\n  rec_type_reg_destroy (reg);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": null
    },
    "test_rec_type_reg_destroy": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_reg_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_type_reg_destroy\");\n  tcase_add_test (tc, rec_type_reg_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_reg_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type-reg/rec-type-reg-get.c": {
    "rec_type_reg_get_nominal": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "START_TEST(rec_type_reg_get_nominal)\n{\n  rec_type_t type;\n  rec_type_t type2;\n  rec_type_reg_t reg;\n\n  reg = rec_type_reg_new ();\n  fail_if (reg == NULL);\n\n  /* Register a type.  */\n  type = rec_type_new (\"int\");\n  rec_type_set_name (type, \"foo\");\n  fail_if (type == NULL);\n  rec_type_reg_add (reg, type);\n\n  /* Get the type and compare.  */\n  type2 = rec_type_reg_get (reg, \"foo\");\n  fail_if (type2 == NULL);\n  fail_if (type2 != type);\n\n  rec_type_reg_destroy (reg);\n}",
      "lines": 22,
      "depth": 8,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_type_reg_get_nonexisting\n * Unit: rec_type_reg_get\n * Description:\n * + Try to get a nonexisting named type\n * + from a type registry.\n */\nSTART_TEST(rec_type_reg_get_nonexisting)\n{\n  rec_type_reg_t reg;\n\n  reg = rec_type_reg_new ();\n  fail_if (reg == NULL);\n\n  fail_if (rec_type_reg_get (reg, \"foo\") != NULL);\n  \n  rec_type_reg_destroy (reg);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_type_reg_get_nonexisting\n * Unit: rec_type_reg_get\n * Description:\n * + Try to get a nonexisting named type\n * + from a type registry.\n */"
      ]
    },
    "test_rec_type_reg_get": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_reg_get (void)\n{\n  TCase *tc = tcase_create (\"rec_type_reg_get\");\n  tcase_add_test (tc, rec_type_reg_get_nominal);\n  tcase_add_test (tc, rec_type_reg_get_nonexisting);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_reg_get (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type-reg/rec-type-reg-new.c": {
    "rec_type_reg_new_nominal": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "START_TEST(rec_type_reg_new_nominal)\n{\n  rec_type_reg_t reg;\n\n  reg = rec_type_reg_new ();\n  fail_if (reg == NULL);\n\n  rec_type_reg_destroy (reg);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": null
    },
    "test_rec_type_reg_new": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test case creation function\n */\nTCase *\ntest_rec_type_reg_new (void)\n{\n  TCase *tc = tcase_create (\"rec_type_reg_new\");\n  tcase_add_test (tc, rec_type_reg_new_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test case creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_type_reg_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-type-reg/tsuite-rec-type-reg.c": {
    "tsuite_rec_type_reg": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "Suite *\ntsuite_rec_type_reg ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-type-reg\");\n  suite_add_tcase (s, test_rec_type_reg_new ());\n  suite_add_tcase (s, test_rec_type_reg_destroy ());\n  suite_add_tcase (s, test_rec_type_reg_get ());\n\n  return s;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_type_reg ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-comment-str.c": {
    "rec_write_comment_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_write_comment_str_nominal)\n{\n  rec_comment_t comment;\n  char *str;\n\n  comment = rec_comment_new (\"foo bar\");\n  str = rec_write_comment_str (comment, REC_WRITER_NORMAL);\n  rec_comment_destroy (comment);\n  fail_if (strcmp (str, \"#foo bar\") != 0);\n  free (str);\n\n  comment = rec_comment_new (\"\");\n  str = rec_write_comment_str (comment, REC_WRITER_NORMAL);\n  fail_if (str == NULL);\n  rec_comment_destroy (comment);\n  fail_if (strcmp (str, \"#\") != 0);\n  free (str);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_write_comment_str_sexp\n * Unit: rec_write_comment_str\n * Description:\n * + Write comments.\n */\nSTART_TEST(rec_write_comment_str_sexp)\n{\n  rec_comment_t comment;\n  char *str;\n\n  comment = rec_comment_new (\"foo bar\");\n  str = rec_write_comment_str (comment, REC_WRITER_SEXP);\n  fail_if (str == NULL);\n  rec_comment_destroy (comment);\n  fail_if (strcmp (str, \"(comment \\\"foo bar\\\")\") != 0);\n  free (str);\n\n  comment = rec_comment_new (\"\");\n  str = rec_write_comment_str (comment, REC_WRITER_SEXP);\n  fail_if (str == NULL);\n  rec_comment_destroy (comment);\n  fail_if (strcmp (str, \"(comment \\\"\\\")\") != 0);\n  free (str);\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_write_comment_str_sexp\n * Unit: rec_write_comment_str\n * Description:\n * + Write comments.\n */"
      ]
    },
    "test_rec_write_comment_str": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_comment_str (void)\n{\n  TCase *tc = tcase_create (\"rec_write_comment_str\");\n  tcase_add_test (tc, rec_write_comment_str_nominal);\n  tcase_add_test (tc, rec_write_comment_str_sexp);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_comment_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-comment.c": {
    "rec_write_comment_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "START_TEST(rec_write_comment_nominal)\n{\n  rec_writer_t writer;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  comment = rec_comment_new (\"foo bar\");\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (writer == NULL);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_comment (writer, comment));\n  rec_comment_destroy (comment);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"#foo bar\") != 0);\n  free (str);\n\n  comment = rec_comment_new (\"one\\ntwo\\nthree\");\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (writer == NULL);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_comment (writer, comment));\n  rec_comment_destroy (comment);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"#one\\n#two\\n#three\") != 0);\n  free (str);\n\n  comment = rec_comment_new (\"\");\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (writer == NULL);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_comment (writer, comment));\n  rec_comment_destroy (comment);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"#\") != 0);\n  free (str);\n}",
      "lines": 37,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_write_comment_sexp\n * Unit: rec_write_comment\n * Description:\n * + Write comments.\n */\nSTART_TEST(rec_write_comment_sexp)\n{\n  rec_writer_t writer;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  comment = rec_comment_new (\"foo bar\");\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (writer == NULL);\n  rec_writer_set_mode (writer, REC_WRITER_SEXP);\n  fail_if (!rec_write_comment (writer, comment));\n  rec_comment_destroy (comment);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"(comment \\\"foo bar\\\")\") != 0);\n  free (str);\n\n  comment = rec_comment_new (\"\");\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (writer == NULL);\n  rec_writer_set_mode (writer, REC_WRITER_SEXP);\n  fail_if (!rec_write_comment (writer, comment));\n  rec_comment_destroy (comment);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"(comment \\\"\\\")\") != 0);\n  free (str);\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_write_comment_sexp\n * Unit: rec_write_comment\n * Description:\n * + Write comments.\n */"
      ]
    },
    "test_rec_write_comment": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_comment (void)\n{\n  TCase *tc = tcase_create (\"rec_write_comment\");\n  tcase_add_test (tc, rec_write_comment_nominal);\n  tcase_add_test (tc, rec_write_comment_sexp);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_comment (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-db.c": {
    "rec_write_db_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "START_TEST(rec_write_db_nominal)\n{\n  rec_writer_t writer;\n  rec_db_t db;\n  rec_rset_t rset;\n  rec_record_t record;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  db = rec_db_new ();\n  fail_if (db == NULL);\n\n  rset = rec_rset_new ();\n  fail_if (rset == NULL);\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  fail_if (rec_mset_append (rec_rset_mset (rset), MSET_RECORD, (void *) record, MSET_ANY) == NULL);\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"bar1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  field = rec_field_new (\"bar2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  fail_if (rec_mset_append (rec_rset_mset (rset), MSET_RECORD, (void *) record, MSET_ANY) == NULL);\n  rec_db_insert_rset (db, rset, rec_db_size (db));\n\n  writer = rec_writer_new_str (&str, &str_size);\n  fail_if (!rec_write_db (writer, db));\n  rec_db_destroy (db);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str,\n                   \"foo1: value1\\nfoo2: value2\\n\\nbar1: value1\\nbar2: value2\\n\") != 0);\n  free (str);\n}",
      "lines": 45,
      "depth": 12,
      "decorators": null
    },
    "test_rec_write_db": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_db (void)\n{\n  TCase *tc = tcase_create (\"rec_write_db\");\n  tcase_add_test (tc, rec_write_db_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_db (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-field-name-str.c": {
    "rec_write_field_name_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "START_TEST(rec_write_field_name_str_nominal)\n{\n  char *fname;\n  char *str;\n\n  fname = \"foo\";\n  str = rec_write_field_name_str (fname, REC_WRITER_NORMAL);\n  fail_if (str == NULL);\n  fail_if (strcmp (str, \"foo:\") != 0);\n  free (str);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_write_field_name_str_sexp\n * Unit: rec_write_field_name_str\n * Description:\n * + Write field names.\n */\nSTART_TEST(rec_write_field_name_str_sexp)\n{\n  char *fname;\n  char *str;\n\n  fname = \"foo\";\n  str = rec_write_field_name_str (fname, REC_WRITER_SEXP);\n  fail_if (strcmp (str, \"\\\"foo\\\"\") != 0);\n  free (str);\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_write_field_name_str_sexp\n * Unit: rec_write_field_name_str\n * Description:\n * + Write field names.\n */"
      ]
    },
    "test_rec_write_field_name_str": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_field_name_str (void)\n{\n  TCase *tc = tcase_create (\"rec_write_field_name_str\");\n  tcase_add_test (tc, rec_write_field_name_str_nominal);\n  tcase_add_test (tc, rec_write_field_name_str_sexp);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_field_name_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-field-name.c": {
    "rec_write_field_name_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "START_TEST(rec_write_field_name_nominal)\n{\n  rec_writer_t writer;\n  char *fname;\n  char *str;\n  size_t str_size;\n\n  fname = \"foo\";\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_field_name (writer, fname));\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"foo:\") != 0);\n  free (str);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_write_field_name_sexp\n * Unit: rec_write_field_name\n * Description:\n * + Write field names.\n */\nSTART_TEST(rec_write_field_name_sexp)\n{\n  rec_writer_t writer;\n  char *fname;\n  char *str;\n  size_t str_size;\n\n  fname = \"foo\";\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_SEXP);\n  fail_if (!rec_write_field_name (writer, fname));\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"\\\"foo\\\"\") != 0);\n  free (str);\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_write_field_name_sexp\n * Unit: rec_write_field_name\n * Description:\n * + Write field names.\n */"
      ]
    },
    "test_rec_write_field_name": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_field_name (void)\n{\n  TCase *tc = tcase_create (\"rec_write_field_name\");\n  tcase_add_test (tc, rec_write_field_name_nominal);\n  tcase_add_test (tc, rec_write_field_name_sexp);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_field_name (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-field-str.c": {
    "rec_write_field_str_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "START_TEST(rec_write_field_str_nominal)\n{\n  rec_field_t field;\n  char *str;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  str = rec_write_field_str (field, REC_WRITER_NORMAL);\n  fail_if (str == NULL);\n  rec_field_destroy (field);\n  fail_if (strcmp (str, \"foo: value\") != 0);\n  free (str);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "END_TEST\n\n/*-\n * Test: rec_write_field_str_sexp\n * Unit: rec_write_field_str\n * Description:\n * + Write fields.\n */\nSTART_TEST(rec_write_field_str_sexp)\n{\n  rec_field_t field;\n  char *str;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  str = rec_write_field_str (field, REC_WRITER_SEXP);\n  fail_if (str == NULL);\n  rec_field_destroy (field);\n  fail_if (strcmp (str, \"(field  \\\"foo\\\" \\\"value\\\")\") != 0);\n  free (str);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "END_TEST",
        "/*-\n * Test: rec_write_field_str_sexp\n * Unit: rec_write_field_str\n * Description:\n * + Write fields.\n */"
      ]
    },
    "test_rec_write_field_str": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_field_str (void)\n{\n  TCase *tc = tcase_create (\"rec_write_field_str\");\n  tcase_add_test (tc, rec_write_field_str_nominal);\n  tcase_add_test (tc, rec_write_field_str_sexp);\n\n  return tc;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_field_str (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-field.c": {
    "rec_write_field_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "START_TEST(rec_write_field_nominal)\n{\n  rec_writer_t writer;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"foo: value\") != 0);\n  free (str);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          56,
          0
        ],
        "end_point": [
          91,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_field_values\n * Unit: rec_write_field\n * Description:\n * + Write a field using the\n * + REC_WRITER_VALUES writing mode.\n */\nSTART_TEST(rec_write_field_values)\n{\n  rec_writer_t writer;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"value\") != 0);\n  free (str);\n\n  field = rec_field_new (\"name\", \"foo\\nbar\\nbaz\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"foo\\nbar\\nbaz\") != 0);\n  free (str);\n}",
        "lines": 36,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_field_values\n * Unit: rec_write_field\n * Description:\n * + Write a field using the\n * + REC_WRITER_VALUES writing mode.\n */"
        ]
      },
      {
        "start_point": [
          92,
          0
        ],
        "end_point": [
          127,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_field_values_row\n * Unit: rec_write_field\n * Description:\n * + Write a field using the\n * + REC_WRITER_VALUES_ROW writing mode.\n */\nSTART_TEST(rec_write_field_values_row)\n{\n  rec_writer_t writer;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES_ROW);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"value\") != 0);\n  free (str);\n\n  field = rec_field_new (\"name\", \"foo\\nbar\\nbaz\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES_ROW);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"foo\\nbar\\nbaz\") != 0);\n  free (str);\n}",
        "lines": 36,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_field_values_row\n * Unit: rec_write_field\n * Description:\n * + Write a field using the\n * + REC_WRITER_VALUES_ROW writing mode.\n */"
        ]
      },
      {
        "start_point": [
          128,
          0
        ],
        "end_point": [
          152,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_field_sexp\n * Unit: rec_write_field\n * Description:\n * + Write fields.\n */\nSTART_TEST(rec_write_field_sexp)\n{\n  rec_writer_t writer;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  field = rec_field_new (\"foo\", \"value\");\n  fail_if (field == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_SEXP);\n  fail_if (!rec_write_field (writer, field));\n  rec_field_destroy (field);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"(field  \\\"foo\\\" \\\"value\\\")\") != 0);\n  free (str);\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_field_sexp\n * Unit: rec_write_field\n * Description:\n * + Write fields.\n */"
        ]
      }
    ],
    "test_rec_write_field": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_field (void)\n{\n  TCase *tc = tcase_create (\"rec_write_field\");\n  tcase_add_test (tc, rec_write_field_nominal);\n  tcase_add_test (tc, rec_write_field_sexp);\n  tcase_add_test (tc, rec_write_field_values);\n  tcase_add_test (tc, rec_write_field_values_row);\n\n  return tc;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_field (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-record.c": {
    "rec_write_record_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "START_TEST(rec_write_record_nominal)\n{\n  rec_writer_t writer;\n  rec_record_t record;\n  rec_field_t field;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment = rec_comment_new (\"comment\");\n  fail_if (comment == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_record (writer, record));\n  rec_record_destroy (record);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str,\n                   \"foo1: value1\\n#comment\\nfoo2: value2\") != 0);\n  free (str);\n}",
      "lines": 29,
      "depth": 12,
      "decorators": null
    },
    "START_TEST": [
      {
        "start_point": [
          68,
          0
        ],
        "end_point": [
          108,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_record_skip_comments\n * Unit: rec_write_record\n * Description:\n * + Write records.\n */\nSTART_TEST(rec_write_record_skip_comments)\n{\n  rec_writer_t writer;\n  rec_record_t record;\n  rec_field_t field;\n  rec_comment_t comment, comment2;\n  char *str;\n  size_t str_size;\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment = rec_comment_new (\"comment\");\n  fail_if (comment == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment2 = rec_comment_new (\"comment2\");\n  fail_if (comment2 == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment2, MSET_ANY) == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  rec_writer_set_skip_comments (writer, true);\n  fail_if (!rec_write_record (writer, record));\n  rec_record_destroy (record);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str,\n                   \"foo1: value1\\nfoo2: value2\") != 0);\n  free (str);\n}",
        "lines": 41,
        "depth": 12,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_record_skip_comments\n * Unit: rec_write_record\n * Description:\n * + Write records.\n */"
        ]
      },
      {
        "start_point": [
          109,
          0
        ],
        "end_point": [
          145,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_record_sexp\n * Unit: rec_write_record\n * Description:\n * + Write records in sexps.\n */\nSTART_TEST(rec_write_record_sexp)\n{\n  rec_writer_t writer;\n  rec_record_t record;\n  rec_field_t field;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment = rec_comment_new (\"comment\");\n  fail_if (comment == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_SEXP);\n  fail_if (!rec_write_record (writer, record));\n  rec_record_destroy (record);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str,\n                   \"(record  (\\n(field  \\\"foo1\\\" \\\"value1\\\")\\n(comment \\\"comment\\\")\\n(field  \\\"foo2\\\" \\\"value2\\\")))\") != 0);\n  free (str);\n}",
        "lines": 37,
        "depth": 12,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_record_sexp\n * Unit: rec_write_record\n * Description:\n * + Write records in sexps.\n */"
        ]
      },
      {
        "start_point": [
          146,
          0
        ],
        "end_point": [
          182,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_record_values\n * Unit: rec_write_record\n * Description:\n * + Write records using the\n * + REC_WRITER_VALUES mode.\n */\nSTART_TEST(rec_write_record_values)\n{\n  rec_writer_t writer;\n  rec_record_t record;\n  rec_field_t field;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment = rec_comment_new (\"comment\");\n  fail_if (comment == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES);\n  fail_if (!rec_write_record (writer, record));\n  rec_record_destroy (record);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"value1\\nvalue2\") != 0);\n  free (str);\n}",
        "lines": 37,
        "depth": 12,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_record_values\n * Unit: rec_write_record\n * Description:\n * + Write records using the\n * + REC_WRITER_VALUES mode.\n */"
        ]
      },
      {
        "start_point": [
          183,
          0
        ],
        "end_point": [
          219,
          1
        ],
        "content": "END_TEST\n\n/*-\n * Test: rec_write_record_values_row\n * Unit: rec_write_record\n * Description:\n * + Write records using the\n * + REC_WRITER_VALUES_ROW mode.\n */\nSTART_TEST(rec_write_record_values_row)\n{\n  rec_writer_t writer;\n  rec_record_t record;\n  rec_field_t field;\n  rec_comment_t comment;\n  char *str;\n  size_t str_size;\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  comment = rec_comment_new (\"comment\");\n  fail_if (comment == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_COMMENT, (void *) comment, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset(record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_VALUES_ROW);\n  fail_if (!rec_write_record (writer, record));\n  rec_record_destroy (record);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str, \"value1 value2\") != 0);\n  free (str);\n}",
        "lines": 37,
        "depth": 12,
        "decorators": [
          "END_TEST",
          "/*-\n * Test: rec_write_record_values_row\n * Unit: rec_write_record\n * Description:\n * + Write records using the\n * + REC_WRITER_VALUES_ROW mode.\n */"
        ]
      }
    ],
    "test_rec_write_record": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "END_TEST\n\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_record (void)\n{\n  TCase *tc = tcase_create (\"rec_write_record\");\n  tcase_add_test (tc, rec_write_record_nominal);\n  tcase_add_test (tc, rec_write_record_skip_comments);\n  tcase_add_test (tc, rec_write_record_sexp);\n  tcase_add_test (tc, rec_write_record_values);\n  tcase_add_test (tc, rec_write_record_values_row);\n\n  return tc;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_record (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-write-rset.c": {
    "rec_write_rset_nominal": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "START_TEST(rec_write_rset_nominal)\n{\n  rec_writer_t writer;\n  rec_rset_t rset;\n  rec_record_t record;\n  rec_field_t field;\n  char *str;\n  size_t str_size;\n\n  rset = rec_rset_new ();\n  fail_if (rset == NULL);\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"foo1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  field = rec_field_new (\"foo2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  fail_if (rec_mset_append (rec_rset_mset (rset), MSET_RECORD, (void *) record, MSET_ANY) == NULL);\n\n  record = rec_record_new ();\n  fail_if (record == NULL);\n  field = rec_field_new (\"bar1\", \"value1\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  field = rec_field_new (\"bar2\", \"value2\");\n  fail_if (field == NULL);\n  fail_if (rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY) == NULL);\n  fail_if (rec_mset_append (rec_rset_mset (rset), MSET_RECORD, (void *) record, MSET_ANY) == NULL);\n  \n  writer = rec_writer_new_str (&str, &str_size);\n  rec_writer_set_mode (writer, REC_WRITER_NORMAL);\n  fail_if (!rec_write_rset (writer, rset));\n  rec_rset_destroy (rset);\n  rec_writer_destroy (writer);\n  fail_if (strcmp (str,\n                   \"foo1: value1\\nfoo2: value2\\n\\nbar1: value1\\nbar2: value2\\n\") != 0);\n  free (str);\n}",
      "lines": 41,
      "depth": 12,
      "decorators": null
    },
    "test_rec_write_rset": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_write_rset (void)\n{\n  TCase *tc = tcase_create (\"rec_write_rset\");\n  tcase_add_test (tc, rec_write_rset_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_write_rset (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-writer-destroy.c": {
    "rec_writer_destroy_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "START_TEST(rec_writer_destroy_nominal)\n{\n  rec_writer_t writer;\n\n  writer = rec_writer_new (stdout);\n  fail_if (writer == NULL);\n\n  rec_writer_destroy (writer);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": null
    },
    "test_rec_writer_destroy": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_writer_destroy (void)\n{\n  TCase *tc = tcase_create (\"rec_writer_destroy\");\n  tcase_add_test (tc, rec_writer_destroy_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_writer_destroy (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/rec-writer-new.c": {
    "rec_writer_new_nominal": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "START_TEST(rec_writer_new_nominal)\n{\n  rec_writer_t writer;\n\n  writer = rec_writer_new (stdout);\n  fail_if (writer == NULL);\n\n  rec_writer_destroy (writer);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": null
    },
    "test_rec_writer_new": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "END_TEST\n\n/*\n * Test creation function\n */\nTCase *\ntest_rec_writer_new (void)\n{\n  TCase *tc = tcase_create (\"rec_writer_new\");\n  tcase_add_test (tc, rec_writer_new_nominal);\n\n  return tc;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "END_TEST",
        "/*\n * Test creation function\n */",
        "TCase",
        "TCase",
        "*\ntest_rec_writer_new (void)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/torture/rec-writer/tsuite-rec-writer.c": {
    "tsuite_rec_writer": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "Suite *\ntsuite_rec_writer ()\n{\n  Suite *s;\n\n  s = suite_create (\"rec-writer\");\n  suite_add_tcase (s, test_rec_writer_new ());\n  suite_add_tcase (s, test_rec_writer_destroy ());\n  suite_add_tcase (s, test_rec_write_comment ());\n  suite_add_tcase (s, test_rec_write_field_name ());\n  suite_add_tcase (s, test_rec_write_field ());\n  suite_add_tcase (s, test_rec_write_record ());\n  suite_add_tcase (s, test_rec_write_rset ());\n  suite_add_tcase (s, test_rec_write_db ());\n  suite_add_tcase (s, test_rec_write_field_name_str ());\n  suite_add_tcase (s, test_rec_write_field_str ());\n  suite_add_tcase (s, test_rec_write_comment_str ());\n\n  return s;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "Suite",
        "*\ntsuite_rec_writer ()",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/utils/csv2rec.c": {
    "recutl_print_help": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, csv2rec synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: csv2rec [OPTIONS]... [CSV_FILE]\\n\"));\n\n  /* TRANSLATORS: --help output, csv2rec short description.\n     no-wrap */\n  fputs (_(\"\\\nConvert csv data into rec data.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, csv2rec options.\n     no-wrap */\n  fputs (_(\"\\\n  -t, --type=TYPE                     type name for the converted records; if this\\n\\\n                                        parameter is ommited then no type is used.\\n\\\n  -s, --strict                        be strict parsing the csv file.\\n\\\n  -e, --omit-empty                    omit empty fields.\\n\"), stdout);\n\n  recutl_print_help_common ();\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "parse_args": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "static void\nparse_args (int argc,\n            char **argv)\n{\n  int ret;\n  char c;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             \"t:se\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case RECORD_TYPE_ARG:\n        case 't':\n          {\n            csv2rec_record_type = xstrdup (optarg);\n            break;\n          }\n        case STRICT_ARG:\n        case 's':\n          {\n            csv2rec_strict = true;\n            break;\n          }\n        case OMIT_EMPTY_ARG:\n        case 'e':\n          {\n            csv2rec_omit_empty = true;\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* Read the name of the csv file, if any.  */\n  if (optind < argc)\n    {\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      csv2rec_csv_file = argv[optind++];\n    }\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_space": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nis_space (unsigned char c)\n{\n  return (c == CSV_SPACE) || (c == CSV_TAB);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_term": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nis_term (unsigned char c)\n{\n  return (c == CSV_CR) || (c == CSV_LF);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "field_cb": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "void\nfield_cb (void *s, size_t len, void *data)\n{\n  char *str;\n  char *field_name;\n  rec_field_t field;\n  struct csv2rec_ctx *ctx;\n  size_t i;\n\n  ctx = (struct csv2rec_ctx *) data;\n  str = xmalloc (len + 1);\n  memcpy (str, s, len);\n  str[len] = '\\0';\n\n  if (ctx->header_p)\n    {\n      /* Add a new field name to ctx.field_names.  */\n\n      if ((ctx->num_field_names % ALLOC_FIELDS) == 0)\n        ctx->field_names =\n          realloc (ctx->field_names, ((ctx->num_field_names / ALLOC_FIELDS) + 1) * (sizeof(char *) * ALLOC_FIELDS));\n\n      /* Normalize the name: spaces and tabs are turned into dashes\n         '_'.  */\n      for (i = 0; i < strlen (str); i++)\n        {\n          if ((str[i] == ' ') || (str[i] == '\\t'))\n            {\n              str[i] = '_';\n            }\n        }\n\n      /* Verify that it is a valid field name.  */\n      field_name = str;\n      if (!rec_field_name_p (field_name))\n        {\n          recutl_fatal (_(\"invalid field name '%s' in header\\n\"),\n                        str);\n        }\n      ctx->field_names[ctx->num_field_names++] = str;\n    }\n  else\n    {\n      /* Create a new field and insert it in the current record.  */\n\n      if (!ctx->record)\n        {\n          /* Create a new record.  */\n          ctx->record = rec_record_new ();\n          if (!ctx->record)\n            recutl_out_of_memory ();\n        }\n      \n      if (!csv2rec_omit_empty || (strlen(str) > 0))\n        {\n          if (ctx->num_fields > ctx->num_field_names)\n            {\n              char *errmsg = NULL;\n              char *source = csv2rec_csv_file;\n\n              if (!source)\n                {\n                  source = \"stdin\";\n                }\n\n              if (!asprintf (&errmsg,\n                             _(\"%s: %d: this line contains %d fields, but %d header fields were read\\n\"),\n                             source,\n                             ctx->lineno, ctx->num_field_names, ctx->num_fields))\n                recutl_out_of_memory ();\n\n              fprintf (stderr, errmsg);\n              exit (EXIT_FAILURE);\n            }\n          field = rec_field_new (ctx->field_names[ctx->num_fields], str);\n          rec_mset_append (rec_record_mset (ctx->record), MSET_FIELD, (void *) field, MSET_ANY);\n        }\n\n      ctx->num_fields++;\n    }\n}",
      "lines": 81,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "record_cb": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "void\nrecord_cb (int c, void *data)\n{\n  struct csv2rec_ctx *ctx;\n  ctx = (struct csv2rec_ctx *) data;\n\n  ctx->lineno++;\n\n  if (ctx->header_p)\n    {\n      ctx->header_p = false;\n    }\n  else\n    {\n      if (!ctx->rset)\n        {\n          /* Create a new record set.  */\n          ctx->rset = rec_rset_new ();\n          if (!ctx->rset)\n            recutl_out_of_memory ();\n\n          /* Add a type, if needed.  */\n          if (csv2rec_record_type)\n            {\n              rec_rset_set_type (ctx->rset, csv2rec_record_type);\n            }\n          \n          /* Add it to the database.  */\n          if (!ctx->db)\n            {\n              ctx->db = rec_db_new ();\n              if (!ctx->db)\n                recutl_out_of_memory ();\n            }\n          rec_db_insert_rset (ctx->db, ctx->rset, rec_db_size (ctx->db));\n        }\n      \n      /* Add the current record to the record set.  */\n      rec_mset_append (rec_rset_mset (ctx->rset), MSET_RECORD, (void *) ctx->record, MSET_ANY);\n      ctx->record = NULL;\n      \n      /* Reset the field counter.  */\n      ctx->num_fields = 0;\n    }\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "process_csv": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static rec_db_t\nprocess_csv (void)\n{\n  struct csv2rec_ctx ctx;\n  FILE *in;\n  struct csv_parser p;\n  unsigned char options = 0;\n  char buf[1024];\n  size_t bytes_read = 0;\n\n  /* Initialize the data in the context.  */\n  ctx.db = NULL;\n  ctx.rset = NULL;\n  ctx.record = NULL;\n  ctx.header_p = true;\n  ctx.field_names = NULL;\n  ctx.num_field_names = 0;\n  ctx.num_fields = 0;\n  ctx.lineno = 0;\n\n  /* Set the files to read/write from/to.\n\n     If a filename was specified, read the csv file from there.\n     Otherwise use the standard input.  The output is written to the\n     standard output in any case.  */\n  if (csv2rec_csv_file)\n    {\n      if (!(in = fopen (csv2rec_csv_file, \"r\")))\n        {\n          recutl_fatal (_(\"cannot read file %s\\n\"), csv2rec_csv_file);\n        }\n    }\n  else\n    {\n      in = stdin;\n    }\n\n  /* Initialize the csv library.  */\n  if (csv_init (&p, options) != 0)\n    {\n      recutl_fatal (_(\"failed to initialize csv parser\\n\"));\n    }\n\n  /* Set some properties of the parser.  */\n  if (csv2rec_strict)\n    {\n      options |= CSV_STRICT;\n      csv_set_opts (&p, options);\n    }\n\n  csv_set_space_func (&p, is_space);\n  csv_set_term_func  (&p, is_term);\n\n  /* Parse the input file in chunks of data.  */\n  while ((bytes_read = fread (buf, 1, 1024, in)) > 0)\n    {\n      if (csv_parse (&p, buf, bytes_read, field_cb, record_cb, &ctx) != bytes_read)\n        {\n          recutl_fatal (_(\"error while parsing CSV file: %s\\n\"),\n                        csv_strerror (csv_error (&p)));\n        }\n\n    }\n  \n  return ctx.db;\n}",
      "lines": 66,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "rec_db_t"
      ]
    },
    "main": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int ret;\n  rec_db_t db;\n  rec_writer_t writer;\n\n  recutl_init (\"csv2rec\");\n\n  parse_args (argc, argv);\n  db = process_csv ();\n  ret = EXIT_SUCCESS;\n\n  if (db)\n    {\n      writer = rec_writer_new (stdout);\n      rec_write_db (writer, db);\n\n      rec_writer_destroy (writer);\n      rec_db_destroy (db);\n    }\n  else\n    {\n      ret = EXIT_FAILURE;\n    }\n\n  return ret;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/mdb2rec.c": {
    "recutl_print_help": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, mdb2rec synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: mdb2rec [OPTIONS]... MDB_FILE [TABLE]\\n\"));\n\n  /* TRANSLATORS: --help output, mdb2rec short description.\n     no-wrap */\n  fputs (_(\"\\\nConvert an mdb file into a rec file.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, mdb2rec options.\n     no-wrap */\n  fputs (_(\"\\\n  -s, --system-tables                 include system tables.\\n\\\n  -e, --keep-empty-fields             don't prune empty fields in the rec\\n\\\n                                        output.\\n\\\n  -l, --list-tables                   dump a list of the table names contained\\n\\\n                                        in the mdb file.\\n\"),\n         stdout);\n\n  recutl_print_help_common ();\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "parse_args": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\nparse_args (int argc,\n            char **argv)\n{\n  int ret;\n  char c;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             \"sel\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case SYSTEM_TABLES_ARG:\n        case 's':\n          {\n            mdb2rec_include_system = true;\n            break;\n          }\n        case KEEP_EMPTY_FIELDS_ARG:\n        case 'e':\n          {\n            mdb2rec_keep_empty_fields = true;\n            break;\n          }\n        case LIST_TABLES_ARG:\n        case 'l':\n          {\n            mdb2rec_list_tables = true;\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* Read the name of the mdb file.  */\n  if ((argc - optind) > 2)\n    {\n      recutl_print_help ();\n      exit (EXIT_FAILURE);\n    }\n  else\n    {\n      mdb2rec_mdb_file = argv[optind++];\n\n      if ((argc - optind) > 0)\n        {\n          mdb2rec_mdb_table = argv[optind++];\n        }\n    }\n}",
      "lines": 58,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_relationships": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static void\nget_relationships (MdbHandle *mdb)\n{\n  char *bound[4];\n  MdbTableDef *table;\n  size_t i;\n\n  table = mdb_read_table_by_name (mdb,\n                                  \"MsysRelationships\",\n                                  MDB_TABLE);\n  if ((!table) || (table->num_rows == 0))\n    {\n      return;\n    }\n\n  mdb_read_columns (table);\n  for (i = 0; i < 4; i++)\n    {\n      bound[i] = xmalloc (MDB_BIND_SIZE);\n    }\n\n  mdb_bind_column_by_name (table, \"szColumn\", bound[0], NULL);\n  mdb_bind_column_by_name (table, \"szObject\", bound[1], NULL);\n  mdb_bind_column_by_name (table, \"szReferencedColumn\", bound[2], NULL);\n  mdb_bind_column_by_name (table, \"szReferencedObject\", bound[3], NULL);\n  mdb_rewind_table (table);\n  \n  num_relationships = table->num_rows;\n  relationships = xmalloc (sizeof (struct relationship_s) * num_relationships);\n\n  i = 0;\n  while (mdb_fetch_row (table))\n    {\n      relationships[i].column = xstrdup (bound[0]);\n      relationships[i].table = xstrdup (bound[1]);\n      relationships[i].referenced_column = xstrdup (bound[2]);\n      relationships[i].referenced_table = xstrdup (bound[3]);\n      i++;\n    }\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_field_name": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "static char *\nget_field_name (MdbHandle *mdb,\n                const char *table_name,\n                const char *col_name)\n{\n  char *field_name;\n  char *referenced_table;\n  char *referenced_column;\n  size_t i;\n\n  /* If this field is a relationship to other table, build a compound\n     field name.  */\n\n  referenced_table = NULL;\n  referenced_column = NULL;\n  for (i = 0; i < num_relationships; i++)\n    {\n      if ((strcmp (relationships[i].table, table_name) == 0) \n          && (strcmp (relationships[i].column, col_name) == 0))\n        {\n          referenced_table =\n            rec_field_name_normalise (relationships[i].referenced_table);\n          if (!referenced_table)\n            {\n              recutl_fatal (_(\"failed to normalise record type name %s\\n\"),\n                            relationships[i].referenced_table);\n            }\n\n          referenced_column = \n            rec_field_name_normalise (relationships[i].referenced_column);\n          if (!referenced_column)\n            {\n              recutl_fatal (_(\"failed to normalise field name %s\\n\"),\n                            relationships[i].referenced_column);\n            }\n\n          break;\n        }\n    }\n\n  field_name = rec_field_name_normalise (col_name);\n  if (!field_name)\n    {\n      recutl_fatal (_(\"failed to normalise field name %s\\n\"),\n                    table_name);\n    }\n\n  if (referenced_table && referenced_column)\n    {\n      /* TODO: handle foreign keys.  */\n    }\n\n  return field_name;\n}",
      "lines": 54,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nget_field_name (MdbHandle *mdb,\n                const char *table_name,\n                const char *col_name)",
        "*"
      ]
    },
    "process_table": {
      "start_point": [
        281,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "static rec_rset_t\nprocess_table (MdbCatalogEntry *entry)\n{\n  rec_rset_t rset;\n  MdbTableDef *table;\n  MdbHandle *mdb;\n  size_t i;\n  MdbColumn *col;\n  char *table_name;\n  char *column_name;\n  char *field_name;\n  char *field_value;\n  char **bound_values;\n  char *normalised;\n  int *bound_lens;\n#define TYPE_VALUE_SIZE 256\n  char type_value[TYPE_VALUE_SIZE];\n  rec_record_t record;\n  rec_field_t field;\n\n  mdb = entry->mdb;\n  table_name = entry->object_name;\n  table = mdb_read_table (entry);\n\n  /* Create the record set.  */\n  rset = rec_rset_new ();\n  if (!rset)\n    recutl_out_of_memory ();\n\n  /* Create the record descriptor and add the %rec: entry.  */\n  field_name = rec_field_name_normalise (table_name);\n  if (!field_name)\n    {\n      recutl_fatal (_(\"failed to normalise record type name %s\\n\"),\n                    table_name);\n    }\n\n  record = rec_record_new ();\n  field = rec_field_new (\"%rec\", field_name);\n  rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY);\n  free (field_name);\n\n  /* Get the columns of the table.  */\n  mdb_read_columns (table);\n\n  /* Loop on the columns.  We will define the key and the types.  */\n  for (i = 0; i < table->num_cols; i++)\n    {\n      col = g_ptr_array_index (table->columns, i);\n      column_name = col->name;\n      type_value[0] = 0;\n      normalised = rec_field_name_normalise (column_name);\n      if (!normalised)\n        {\n          recutl_fatal (_(\"failed to normalise the field name %s\\n\"),\n                        column_name);\n        }\n\n      /* Emit a field type specification.  */\n      switch (col->col_type)\n        {\n        case MDB_BOOL:\n          {\n            snprintf (type_value, TYPE_VALUE_SIZE,\n                      \"%s bool\", normalised);\n            break;\n          }\n        case MDB_BYTE:\n          {\n            snprintf (type_value, TYPE_VALUE_SIZE,\n                      \"%s range 256\", normalised);\n            break;\n          }\n        case MDB_INT:\n        case MDB_LONGINT:\n        case MDB_NUMERIC:\n          {\n            snprintf (type_value, TYPE_VALUE_SIZE,\n                      \"%s int\", normalised);\n            break;\n          }\n        case MDB_MONEY:\n        case MDB_FLOAT:\n        case MDB_DOUBLE:\n          {\n            snprintf (type_value, TYPE_VALUE_SIZE,\n                      \"%s real\", normalised);\n            break;\n          }\n        case MDB_DATETIME:\n          {\n            snprintf (type_value, TYPE_VALUE_SIZE,\n                      \"%s date\", normalised);\n            break;\n          }\n        case MDB_TEXT:\n          {\n            if (col->col_size > 0)\n              {\n                snprintf (type_value, TYPE_VALUE_SIZE,\n                          \"%s size %d\", normalised, col->col_size);\n              }\n            break;\n          }\n        case MDB_REPID:\n        case MDB_MEMO:\n        case MDB_OLE:\n        default:\n          {\n            break;\n          }\n        }\n\n      if (type_value[0] != 0)\n        {\n          /* Insert a type field for this column.  */\n          field = rec_field_new (\"%type\", type_value);\n          rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY);\n        }\n    }\n\n  rec_rset_set_descriptor (rset, record);\n  \n  /* Add the records for this table.  */\n  mdb_rewind_table (table);\n\n  bound_values = xmalloc (table->num_cols * sizeof(char *));\n  bound_lens = xmalloc(table->num_cols * sizeof(int));\n  for (i = 0; i < table->num_cols; i++)\n    {\n      bound_values[i] = xmalloc (MDB_BIND_SIZE);\n      mdb_bind_column (table, i+1, bound_values[i], &bound_lens[i]);\n    }\n\n  while (mdb_fetch_row (table))\n    {\n      record = rec_record_new ();\n      if (!record)\n        recutl_out_of_memory ();\n\n      for (i = 0; i < table->num_cols; i++)\n        {\n          col = g_ptr_array_index (table->columns, i);\n\n          if (col->col_type == MDB_OLE)\n            {\n              continue;\n            }\n\n          /* Compute the value of the field.  */\n          field_value = xmalloc (bound_lens[i] + 1);\n          memcpy (field_value, bound_values[i], bound_lens[i]);\n          field_value[bound_lens[i]] = '\\0';\n\n          if (mdb2rec_keep_empty_fields || (strlen (field_value) > 0))\n            {\n              /* Create the field and append it into the record.  */\n              field = rec_field_new (get_field_name (mdb, table_name, column_name),\n                                     field_value);\n              if (!field)\n                {\n                  recutl_fatal (_(\"invalid field name %s.\\n\"), column_name);\n                }\n\n              rec_mset_append (rec_record_mset (record), MSET_FIELD, (void *) field, MSET_ANY);\n            }\n\n          free (field_value);\n        }\n\n      rec_record_set_container (record, rset);\n      rec_mset_append (rec_rset_mset (rset), MSET_RECORD, (void *) record, MSET_ANY);\n    }\n\n  mdb_free_tabledef (table);\n\n  return rset;\n}",
      "lines": 178,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "rec_rset_t"
      ]
    },
    "process_mdb": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        520,
        1
      ],
      "content": "static rec_db_t\nprocess_mdb (void)\n{\n  rec_db_t db;\n  MdbHandle *mdb;\n  MdbCatalogEntry *entry;\n  int i;\n  char *table_name;\n\n  /* Create the rec database.  */\n  db = rec_db_new ();\n  if (!db)\n    recutl_out_of_memory ();\n\n  /* Initialize libmdb and open the input file.  */\n  mdb_init();\n  mdb_set_date_fmt (\"%Y-%m-%dT%H:%M:%S%z\"); /* ISO 8601 */\n\n  mdb = mdb_open (mdb2rec_mdb_file, MDB_NOFLAGS);\n  if (!mdb)\n    {\n      recutl_fatal (_(\"could not open file %s\\n\"),\n                    mdb2rec_mdb_file);\n    }\n\n  /* Read the catalog.  */\n  if (!mdb_read_catalog (mdb, MDB_TABLE))\n    {\n      recutl_fatal (_(\"file does not appear to be an Access database\\n\"));\n    }\n\n  /* Read relationships from the database.  Relationships in mdb files\n     are stored in the MSysRelationships table.  */\n  get_relationships (mdb);\n\n  /* Iterate on the catalogs.  */\n  for (i = 0; i < mdb->num_catalog; i++)\n    {\n      entry = g_ptr_array_index (mdb->catalog, i);\n\n      table_name = rec_field_name_normalise (entry->object_name);\n\n      if ((entry->object_type == MDB_TABLE)\n          && (mdb_is_user_table (entry) || mdb2rec_include_system)\n          && (!mdb2rec_mdb_table || (strcmp (mdb2rec_mdb_table, table_name) == 0)))\n        {\n          if (mdb2rec_list_tables)\n            {\n              fprintf (stdout, \"%s\\n\", table_name);\n            }\n          else\n            {\n              rec_db_insert_rset (db,\n                                  process_table (entry),\n                                  rec_db_size (db));\n            }\n        }\n    }\n\n  return db;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "rec_db_t"
      ]
    },
    "main": {
      "start_point": [
        522,
        0
      ],
      "end_point": [
        550,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int ret;\n  rec_db_t db;\n  rec_writer_t writer;\n\n  recutl_init (\"mdb2rec\");\n\n  parse_args (argc, argv);\n  db = process_mdb ();\n\n  if (db)\n    {\n      writer = rec_writer_new (stdout);\n      rec_write_db (writer, db);\n      \n      rec_writer_destroy (writer);\n      rec_db_destroy (db);\n\n      ret = EXIT_SUCCESS;\n    }\n  else\n    {\n      ret = EXIT_FAILURE;\n    }\n\n  return ret;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/rec2csv.c": {
    "recutl_print_help": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, rec2csv synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: rec2csv [OPTIONS]... [REC_FILE]\\n\"));\n\n  /* TRANSLATORS: --help output, rec2csv short description.\n     no-wrap */\n  fputs (_(\"\\\nConvert rec data into csv data.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, rec2csv options.\n     no-wrap */\n  fputs (_(\"\\\n  -d, --delim=char                    sets the deliminator (default ',')\\n\\\n  -t, --type=TYPE                     record set to convert to csv; if this parameter\\n\\\n                                        is omitted then the default record set is used\\n\\\n  -S, --sort=FIELDS                   sort the output by the specified fields.\\n\"),\n         stdout);\n\n  recutl_print_help_common ();\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 27,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "rec2csv_parse_args": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nrec2csv_parse_args (int argc,\n                    char **argv)\n{\n  int ret;\n  char c;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             \"t:S:d:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case RECORD_TYPE_ARG:\n        case 'd':\n          {\n            rec2csv_delim = optarg[0];\n            break;\n          }\n        case 't':\n          {\n            rec2csv_record_type = xstrdup (optarg);\n            break;\n          }\n        case SORT_ARG:\n        case 'S':\n          {\n            if (rec2csv_sort_by_fields)\n              {\n                recutl_fatal (_(\"only one list of fields can be specified as a sorting criteria.\\n\"));\n              }\n\n            /* Parse the field name.  */\n\n            if (!rec_fex_check (optarg, REC_FEX_CSV))\n              {\n                recutl_fatal (_(\"invalid field name list in -S.\\n\"));\n              }\n\n            rec2csv_sort_by_fields = rec_fex_new (optarg, REC_FEX_CSV);\n            if (!rec2csv_sort_by_fields)\n              {\n                recutl_fatal (_(\"internal error creating fex.\\n\"));\n              }\n\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n}",
      "lines": 58,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec2csv_generate_csv": {
      "start_point": [
        167,
        0
      ],
      "end_point": [
        247,
        1
      ],
      "content": "static void\nrec2csv_generate_csv (rec_rset_t rset,\n                      rec_fex_t fex)\n{\n  rec_mset_iterator_t iter;\n  rec_fex_elem_t fex_elem;\n  rec_record_t record;\n  rec_field_t field;\n  char *field_name;\n  char *tmp;\n  size_t i;\n\n  /* Generate the row with headers.  */\n  for (i = 0; i < rec_fex_size (fex); i++)\n    {\n      if (i != 0)\n        {\n          putc (rec2csv_delim, stdout);\n        }\n\n      fex_elem = rec_fex_get (fex, i);\n      field_name = xstrdup (rec_fex_elem_field_name (fex_elem));\n\n      /* The header is FNAME or FNAME_N where N is the index starting\n         at 1.  Note that we shall remove the trailing ':', if any. */\n\n      if (field_name[strlen(field_name)-1] == ':')\n        {\n          field_name[strlen(field_name)-1] = '\\0';\n        }\n\n\n      if (rec_fex_elem_min (fex_elem) != 0)\n        {\n          if (asprintf (&tmp, \"%s_%d\",\n                        field_name,\n                        rec_fex_elem_min (fex_elem) + 1) == -1)\n            recutl_out_of_memory ();\n        }\n      else\n        {\n          if (asprintf (&tmp, \"%s\", field_name) == -1)\n            recutl_out_of_memory ();\n        }\n\n      csv_fwrite (stdout, tmp, strlen(tmp));\n      free (field_name);\n      free (tmp);\n    }\n\n  putc ('\\n', stdout);\n\n  /* Generate the data rows.  */\n\n  iter = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void**) &record, NULL))\n    {\n      for (i = 0; i < rec_fex_size (fex); i++)\n        {\n          if (i != 0)\n            {\n              putc (rec2csv_delim, stdout);\n            }\n\n          fex_elem = rec_fex_get (fex, i);\n          field = rec_record_get_field_by_name (record,\n                                                rec_fex_elem_field_name (fex_elem),\n                                                rec_fex_elem_min (fex_elem));\n          if (field)\n            {\n              csv_fwrite (stdout,\n                          rec_field_value (field),\n                          strlen (rec_field_value (field)));\n            }\n        }\n\n      putc ('\\n', stdout);\n    }\n\n  rec_mset_iterator_free (&iter);\n}",
      "lines": 81,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rec2csv_determine_fields": {
      "start_point": [
        249,
        0
      ],
      "end_point": [
        285,
        1
      ],
      "content": "static rec_fex_t\nrec2csv_determine_fields (rec_rset_t rset)\n{\n  rec_fex_t fields;\n  rec_mset_iterator_t iter_rset;\n  rec_mset_iterator_t iter_record;\n  rec_record_t record;\n  rec_field_t field;\n  int field_index;\n  \n  fields = rec_fex_new (NULL, REC_FEX_SIMPLE);\n\n  iter_rset = rec_mset_iterator (rec_rset_mset (rset));\n  while (rec_mset_iterator_next (&iter_rset, MSET_RECORD, (const void **) &record, NULL))\n    {\n      iter_record = rec_mset_iterator (rec_record_mset (record));\n      while (rec_mset_iterator_next (&iter_record, MSET_FIELD, (const void **) &field, NULL))\n        {\n          field_index = rec_record_get_field_index_by_name (record, field);\n          \n          if (!rec_fex_member_p (fields,\n                                 rec_field_name (field),\n                                 field_index, field_index))\n            {\n              rec_fex_append (fields,\n                              rec_field_name (field),\n                              field_index, field_index);\n            }\n        }\n\n      rec_mset_iterator_free (&iter_record);\n    }\n\n  rec_mset_iterator_free (&iter_rset);\n\n  return fields;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "rec_fex_t"
      ]
    },
    "rec2csv_process_data": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "static bool\nrec2csv_process_data (rec_db_t db)\n{\n  bool ret;\n  rec_fex_t row_fields;\n  size_t i;\n  rec_rset_t rset;\n\n  ret = true;\n\n  for (i = 0; i < rec_db_size (db); i++)\n    {\n      rset = rec_db_get_rset (db, i);\n      if (((rec2csv_record_type)\n           && rec_rset_type (rset)\n           && (strcmp (rec_rset_type (rset),\n                       rec2csv_record_type) == 0))\n          || (!rec2csv_record_type\n              && (!rec_rset_type (rset) ||\n                  (rec_db_size (db) == 1))))\n        {\n          /* Process this record set.  */\n\n          if (!rec_rset_sort (rset, rec2csv_sort_by_fields))\n            recutl_out_of_memory ();\n\n          /* Build the fields that will appear in the row. */\n          row_fields = rec2csv_determine_fields (rset);\n  \n          /* Generate the csv data.  */\n          rec2csv_generate_csv (rset, row_fields);\n\n          /* Cleanup.  */\n          rec_fex_destroy (row_fields);\n        }\n    }\n\n  return ret;\n}",
      "lines": 39,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "main": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int res;\n  rec_db_t db;\n\n  res = 0;\n\n  recutl_init (\"rec2csv\");\n\n  /* Parse arguments.  */\n  rec2csv_parse_args (argc, argv);\n\n  /* Get the input data.  */\n  db = recutl_build_db (argc, argv);\n  if (!db)\n    {\n      res = 1;\n    }\n  else\n    /* Process the data.  */\n    if (!rec2csv_process_data (db))\n      {\n        res = 1;\n      }\n\n  rec_db_destroy (db);\n  \n  return res;\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recdel.c": {
    "recutl_print_help": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recdel synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recdel [OPTIONS]... [-t TYPE] [-n NUM | -e RECORD_EXPR | -q STR | -m NUM] [FILE]\\n\"));\n\n  /* TRANSLATORS: --help output, recdel short description.\n     no-wrap */\n  fputs (_(\"\\\nRemove (or comment out) records from a rec file.\\n\"),\n         stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recdel arguments.\n     no-wrap */\n  fputs (_(\"\\\n  -c, --comment                       comment out the matching records instead of\\n\\\n                                        deleting them.\\n\\\n      --force                         delete even in potentially dangerous situations,\\n\\\n                                        and if the deletion is violating record restrictions.\\n\\\n      --no-external                   don't use external descriptors.\\n\\\n      --verbose                       give a detailed report if the integrity check\\n\\\n                                        fails.\\n\"),\n         stdout);\n\n  recutl_print_help_common ();\n  \n  puts (\"\");\n  recutl_print_help_record_selection ();\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, notes on recdel.\n     no-wrap */\n  fputs (_(\"\\\nIf no FILE is specified then the command acts like a filter, getting\\n\\\nthe data from standard input and writing the result to standard output.\\n\"),\n         stdout);\n\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recdel_delete_records": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\nrecdel_delete_records (rec_db_t db)\n{\n  /* Make sure that the user selected an existing record set from\n     which to delete records.  */\n\n  if (!rec_db_type_p (db, recutl_type))\n    {\n      recutl_fatal (_(\"no records of type %s found.\\n\"),\n                    recutl_type ? recutl_type : \"<default>\");\n    }\n\n  /* Invoke the library to perform the requested deletions.  */\n\n  {\n    int flags = 0;\n\n    if (recutl_insensitive)\n      {\n        flags = flags | REC_F_ICASE;\n      }\n\n    if (recdel_comment)\n      {\n        flags = flags | REC_F_COMMENT_OUT;\n      }\n\n    if (!rec_db_delete (db,\n                        recutl_type,\n                        recutl_index (),\n                        recutl_sex,\n                        recutl_quick_str,\n                        recutl_random,\n                        flags))\n      recutl_out_of_memory ();\n  }\n\n\n  /* Check the integrity of the resulting database.  */\n\n  if (!recdel_force && db)\n    {\n      recutl_check_integrity (db, recdel_verbose, recdel_external);\n    }\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "recdel_parse_args": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "void\nrecdel_parse_args (int argc,\n                   char **argv)\n{\n  int ret;\n  char c;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             RECORD_SELECTION_SHORT_ARGS\n                             \"c\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n          RECORD_SELECTION_ARGS_CASES\n        case FORCE_ARG:\n          {\n            recdel_force = true;\n            break;\n          }\n        case VERBOSE_ARG:\n          {\n            recdel_verbose = true;\n            break;\n          }\n        case NO_EXTERNAL_ARG:\n          {\n            recdel_external = false;\n            break;\n          }\n        case COMMENT_ARG:\n        case 'c':\n          {\n            recdel_comment = true;\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* Require the usage of --force for potentially dangerous\n     operations, such as the request of deleting a whole record\n     set.  */\n  \n  if ((recutl_num_indexes() == 0) && !recutl_sex_str && !recutl_quick_str && !recdel_force && (recutl_random == 0))\n    {\n      recutl_error (_(\"ignoring a request to delete all records of type %s.\\n\"),\n                    recutl_type ? recutl_type : \"unknown\");\n      recutl_fatal (_(\"use --force if you really want to proceed, or use either -n or -e.\\n\"));\n    }\n\n  if (recutl_sex_str)\n    {\n      recutl_sex = rec_sex_new (recutl_insensitive);\n      if (!rec_sex_compile (recutl_sex, recutl_sex_str))\n        {\n          recutl_fatal (_(\"invalid selection expression.\\n\"));\n        }\n    }\n\n  /* Read the name of the file where to delete the records.  */\n  if (optind < argc)\n    {\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      recdel_file = argv[optind++];\n    }\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        281,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  rec_db_t db;\n\n  recutl_init (\"recdel\");\n\n  recdel_parse_args (argc, argv);\n\n  db = recutl_read_db_from_file (recdel_file);\n  if (!db)\n    {\n      recutl_fatal (_(\"cannot read file %s\\n\"), recdel_file);\n    }\n\n  if (((recutl_num_indexes() != 0) || recutl_sex || recutl_quick_str) || recdel_force || (recutl_random > 0))\n    {\n      recdel_delete_records (db);\n    }\n\n  if (!recutl_file_is_writable (recdel_file))\n    {\n      recutl_error (_(\"file %s is not writable.\\n\"), recdel_file);\n      return EXIT_FAILURE;\n    }\n  recutl_write_db_to_file (db, recdel_file);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recfix.c": {
    "recutl_print_help": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recfix synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recfix [OPTION]... [OPERATION] [OP_OPTION]... [FILE]\\n\"));\n\n  /* TRANSLATORS: --help output, recfix short description.\n     no-wrap */\n  fputs (_(\"\\\nCheck and fix rec files.\\n\"),\n         stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recfix global arguments.\n     no-wrap */\n  fputs (_(\"\\\n      --no-external                   don't use external descriptors.\\n\\\n      --force                         force the requested operation.\\n\"),\n         stdout);\n\n  recutl_print_help_common ();\n\n  puts(\"\");\n  /* TRANSLATORS: --help output, recfix operations.\n     no-wrap */\n  fputs (_(\"\\\nOperations:\\n\\\n      --check                         check integrity of the specified file.  Default.\\n\\\n      --sort                          sort the records in the specified file.\\n\\\n      --auto                          insert auto-generated fields in records missing them.\\n\"),\n         stdout);\n\n#if defined REC_CRYPT_SUPPORT\n    /* TRANSLATORS: --help output, recfix operations related with encryption.\n       no-wrap */\n    fputs (_(\"\\\n      --encrypt                       encrypt confidential fields in the specified file.\\n\\\n      --decrypt                       decrypt confidential fields in the specified file.\\n\"),\n         stdout);\n\n  puts(\"\");\n  /* TRANSLATORS: --help output, recfix encryption and decryption\n     options.\n     no-wrap */\n  fputs (_(\"\\\nDe/Encryption options:\\n\\\n  -s, --password=PASSWORD             encrypt/decrypt with this password.\\n\"),\n         stdout);\n#endif /* REC_CRYPT_SUPPORT */\n\n  puts(\"\");\n  /* TRANSLATORS: --help output, notes on recfix.\n     no-wrap */\n  fputs (_(\"\\\nIf no FILE is specified then the command acts like a filter, getting\\n\\\nthe data from standard input and writing the result to standard output.\\n\"), stdout);\n\n  puts(\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "recfix_parse_args": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static void\nrecfix_parse_args (int argc,\n                   char **argv)\n{\n  char c;\n  int ret;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             ENCRYPTION_SHORT_ARGS,\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case NO_EXTERNAL_ARG:\n          {\n            recfix_external = false;\n            break;\n          }\n        case FORCE_ARG:\n          {\n            recfix_force = true;\n            break;\n          }\n#if defined REC_CRYPT_SUPPORT\n        case 's':\n        case PASSWORD_ARG:\n          {\n            if (recfix_op == RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"--password|-s must be used as an operation argument.\\n\"));\n              }\n\n            if ((recfix_op != RECFIX_OP_ENCRYPT)\n                && (recfix_op != RECFIX_OP_DECRYPT))\n              {\n                recutl_fatal (_(\"the specified operation does not require a password.\\n\"));\n              }\n\n            if (recfix_password != NULL)\n              {\n                recutl_fatal (_(\"please specify just one password.\\n\"));\n              }\n\n            recfix_password = xstrdup (optarg);\n            break;\n          }\n#endif /* REC_CRYPT_SUPPORT */\n        case OP_CHECK_ARG:\n          {\n            if (recfix_op != RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"please specify just one operation.\\n\"));\n              }\n\n            recfix_op = RECFIX_OP_CHECK;\n            break;\n          }\n        case OP_SORT_ARG:\n          {\n            if (recfix_op != RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"please specify just one operation.\\n\"));\n              }\n\n            recfix_op = RECFIX_OP_SORT;\n            break;\n          }\n        case OP_AUTO_ARG:\n          {\n            if (recfix_op != RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"please specify just one operation.\\n\"));\n              }\n\n            recfix_op = RECFIX_OP_AUTO;\n            break;\n          }\n#if defined REC_CRYPT_SUPPORT\n        case OP_ENCRYPT_ARG:\n          {\n            if (recfix_op != RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"please specify just one operation.\\n\"));\n              }\n\n            recfix_op = RECFIX_OP_ENCRYPT;\n            break;\n          }\n        case OP_DECRYPT_ARG:\n          {\n            if (recfix_op != RECFIX_OP_INVALID)\n              {\n                recutl_fatal (_(\"please specify just one operation.\\n\"));\n              }\n\n            recfix_op = RECFIX_OP_DECRYPT;\n            break;\n          }\n#endif /* REC_CRYPT_SUPPORT */\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* The default operation is check, in case the user did not specify\n     any in the command line.  */\n\n  if (recfix_op == RECFIX_OP_INVALID)\n    {\n      recfix_op = RECFIX_OP_CHECK;\n    }\n\n#if defined REC_CRYPT_SUPPORT\n  /* The encrypt and decrypt operations require the user to specify a\n     password.  If no password was specified with -s and the program\n     is running in a terminal, prompt the user to provide the\n     password.  */\n\n  if (((recfix_op == RECFIX_OP_ENCRYPT)\n       || (recfix_op == RECFIX_OP_DECRYPT))\n      && (recfix_password == NULL))\n    {\n      if (recutl_interactive ())\n        {\n          if (recfix_op == RECFIX_OP_ENCRYPT)\n            {\n              recfix_password = recutl_getpass (true);\n            }\n          else\n            {\n              recfix_password = recutl_getpass (false);\n            }\n        }\n\n      if (!recfix_password || (strlen (recfix_password) == 0))\n        {\n          recutl_fatal (\"please specify a password.\\n\");\n        }\n    }\n#endif /* REC_CRYPT_SUPPORT */\n\n  /* Read the name of the file to work on.  */\n  if (optind < argc)\n    {\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      recfix_file = argv[optind++];\n    }\n}",
      "lines": 159,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recfix_check_database": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "static bool\nrecfix_check_database (rec_db_t db)\n{\n  bool ret;\n  char *errors;\n  size_t errors_size;\n  rec_buf_t buf;\n\n  buf = rec_buf_new (&errors, &errors_size);\n  ret = (rec_int_check_db (db,\n                           true,            /* Check descriptors.  */\n                           recfix_external, /* Use external descriptors.  */\n                           buf) == 0);\n  rec_buf_close (buf);\n  fprintf (stderr, \"%s\", errors);\n\n  return ret;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "bool"
      ]
    },
    "recfix_do_check": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "static int\nrecfix_do_check ()\n{\n  rec_db_t db;\n\n  /* Read the database from the specified file and check its\n     integrity.  */\n\n  db = recutl_read_db_from_file (recfix_file);\n  if (!db)\n    {\n      return EXIT_FAILURE;\n    }\n\n  if (!recfix_check_database (db))\n    {\n      return EXIT_FAILURE;\n    }\n\n  return EXIT_SUCCESS;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "recfix_do_sort": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        412,
        1
      ],
      "content": "static int\nrecfix_do_sort ()\n{\n  rec_db_t db     = NULL;\n  size_t n_rset   = 0;\n  rec_rset_t rset = NULL;\n\n  /* Read the database from the specified file.  */\n\n  db = recutl_read_db_from_file (recfix_file);\n  if (!db)\n    {\n      return EXIT_FAILURE;\n    }\n\n  /* Sort all the record sets contained in the database.  */\n\n  for (n_rset = 0; n_rset < rec_db_size (db); n_rset++)\n    {\n      rset = rec_db_get_rset (db, n_rset);\n      if (!rec_rset_sort (rset, NULL))\n        recutl_out_of_memory ();\n    }\n  \n  if (!recfix_check_database (db))\n    {\n      return EXIT_FAILURE;\n    }\n\n  if (!recutl_file_is_writable (recfix_file))\n    {\n      recutl_error (_(\"file %s is not writable.\\n\"), recfix_file);\n      return EXIT_FAILURE;\n    }\n\n  recutl_write_db_to_file (db, recfix_file);\n  return EXIT_SUCCESS;\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "recfix_do_crypt": {
      "start_point": [
        416,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "static int\nrecfix_do_crypt ()\n{\n  rec_db_t db;\n  size_t n_rset;\n\n  /* Read the database from the specified file. */\n\n  db = recutl_read_db_from_file (recfix_file);\n  if (!db)\n    {\n      return EXIT_FAILURE;\n    }\n\n  /* Encrypt/decrypt any unencrypted/encrypted field marked as\n     \"confidential\" using the given password.  */\n\n  for (n_rset = 0; n_rset < rec_db_size (db); n_rset++)\n    {\n      rec_mset_iterator_t iter;\n      rec_fex_t confidential_fields;\n      rec_record_t record;\n      rec_rset_t rset =\n        rec_db_get_rset (db, n_rset);\n\n      /* Skip record sets not having any confidential fields.  */\n\n      confidential_fields = rec_rset_confidential (rset);\n      if (confidential_fields == NULL)\n        {\n          continue;\n        }\n\n      /* Process every record of the record set.  */\n\n      iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void **) &record, NULL))\n        {\n          if (recfix_op == RECFIX_OP_ENCRYPT)\n            {\n              /* Encrypt any unencrypted confidential field in this\n                 record.  */\n\n              if (!rec_encrypt_record (rset, record, recfix_password)\n                  && !recfix_force)\n                {\n                  recutl_error (_(\"the database contains already encrypted fields\\n\"));\n                  recutl_fatal (_(\"please use --force or --decrypt\\n\"));\n                }\n            }\n          else\n            {\n              /* Decrypt any encrypted confidential field in this\n                 record.  */\n\n              rec_decrypt_record (rset, record, recfix_password);\n            }\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n\n  /* Write the modified database back to the file.  */\n\n  recutl_write_db_to_file (db, recfix_file);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 68,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "recfix_do_auto": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        527,
        1
      ],
      "content": "static int\nrecfix_do_auto ()\n{\n  rec_db_t db    = NULL;\n  size_t n_rset  = 0;\n\n  /* Read the database from the especified file.  */\n\n  db = recutl_read_db_from_file (recfix_file);\n  if (!db)\n    {\n      return EXIT_FAILURE;\n    }\n\n  /* Add auto fields to any record in the database not having it, in\n     record sets featuring auto fields.  */\n\n  for (n_rset = 0; n_rset < rec_db_size (db); n_rset++)\n    {\n      rec_mset_iterator_t iter;\n      rec_record_t record;\n      rec_rset_t rset = rec_db_get_rset (db, n_rset);\n\n      iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void**) &record, NULL))\n        {\n          if (!rec_rset_add_auto_fields (rset, record))\n            recutl_out_of_memory ();\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n\n  if (!recfix_check_database (db))\n    {\n      return EXIT_FAILURE;\n    }\n\n  recutl_write_db_to_file (db, recfix_file);\n  return EXIT_SUCCESS;\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        529,
        0
      ],
      "end_point": [
        578,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int res     = EXIT_SUCCESS;\n\n  recutl_init (\"recfix\");\n\n  /* Parse arguments.  */\n\n  recfix_parse_args (argc, argv);\n\n  /* Execute the proper operation as specified in the recfix_op\n     variable.  */\n\n  switch (recfix_op)\n    {\n    case RECFIX_OP_CHECK:\n      {\n        res = recfix_do_check ();\n        break;\n      }\n    case RECFIX_OP_SORT:\n      {\n        res = recfix_do_sort ();\n        break;\n      }\n    case RECFIX_OP_AUTO:\n      {\n        res = recfix_do_auto ();\n        break;\n      }\n#if defined REC_CRYPT_SUPPORT\n    case RECFIX_OP_ENCRYPT:\n    case RECFIX_OP_DECRYPT:\n      {\n        res = recfix_do_crypt ();\n        break;\n      }\n#endif /* REC_CRYPT_SUPPORT */\n    default:\n      {\n        /* This point shall not be reached.  */\n\n        res = EXIT_FAILURE;\n        recutl_fatal (_(\"unknown operation in recfix: please report this as a bug.\\n\"));\n      }\n    }\n\n  return res;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recfmt.c": {
    "recutl_print_help": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recfmt synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recfmt [OPTION]... [TEMPLATE]\\n\"));\n\n  /* TRANSLATORS: --help output, recfmt arguments.\n     no-wrap */\n  fputs(_(\"\\\nApply a template to records read from standard input.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recfmt arguments.\n     no-wrap */\n  fputs(_(\"\\\n  -f, --file=FILENAME                 read the template to apply from a file.\\n\"),\n        stdout);\n\n  recutl_print_help_common ();\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recfmt_parse_args": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\nrecfmt_parse_args (int argc,\n                   char **argv)\n{\n  char c;\n  int ret;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             \"f:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case FILE_ARG:\n        case 'f':\n          {\n            /* Read the template from the specified file and store it\n               in recfmt_template.  */\n            recfmt_template = recutl_read_file (optarg);\n            if (!recfmt_template)\n              {\n                recutl_fatal (_(\"can't open file %s for reading.\\n\"),\n                              optarg);\n              }\n\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* See if the template is specified in the command line.  */\n  if (optind < argc)\n    {\n      if (recfmt_template)\n        {\n          recutl_fatal (_(\"don't specify a template in the command line and -f at the same time.\\n\"));\n        }\n\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      recfmt_template = xstrdup (argv[optind++]);\n    }\n}",
      "lines": 55,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "recfmt_get_subst": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "char *\nrecfmt_get_subst (rec_record_t record,\n                  char *str)\n{\n  char *res;\n  rec_sex_t sex;\n\n  sex = rec_sex_new (false);\n  if (!rec_sex_compile (sex, str))\n    {\n      recutl_fatal (_(\"invalid expression in a template slot.\\n\"));\n    }\n\n  res = rec_sex_eval_str (sex, record);\n  if (!res)\n    {\n      recutl_fatal (_(\"error evaluating expression in a template slot.\\n\"));\n    }\n\n  rec_sex_destroy (sex);\n\n  return res;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "char",
        "*\nrecfmt_get_subst (rec_record_t record,\n                  char *str)",
        "*"
      ]
    },
    "recfmt_apply_template": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "char *\nrecfmt_apply_template (rec_record_t record,\n                       char *template)\n{\n  rec_buf_t result_buf;\n  char *result;\n  char *tmp;\n  size_t tmp_size;\n  size_t result_size;\n  char *p;\n  regex_t regexp;\n  regmatch_t matches;\n  char *subst_str;\n\n  /* Replace occurrences of:\n\n     {{Name[N]}}\n\n     where Name[N] is the name of a field with an optional subscript.\n     If the subscript is not present then it is assumed to be 0.  If\n     the contents between {{...}} are not a field name then replace the\n     slot with the empty string.\n  */\n\n  if (regcomp (&regexp, \"\\\\{\\\\{\" \"[^}]*\" \"\\\\}\\\\}\", REG_EXTENDED) != 0)\n    {\n      recutl_fatal (_(\"recfmt_apply_template: error compiling regexp. Please report this.\\n\"));\n    }\n\n  result_buf = rec_buf_new (&result, &result_size);\n  p = template;\n  while (*p\n         && (regexec (&regexp, p, 1, &matches, 0) == 0)\n         && (matches.rm_so != -1))\n    {\n      /* Add the prolog, if any.  */\n      if (matches.rm_so > 0)\n        {\n          tmp = xmalloc (matches.rm_so + 1);\n          memcpy (tmp, p, matches.rm_so);\n          tmp[matches.rm_so] = '\\0';\n          rec_buf_puts (tmp, result_buf);\n          free (tmp);\n        }\n\n      /* Get the match.  */\n      tmp_size = matches.rm_eo - matches.rm_so - 4;\n      tmp = xmalloc (tmp_size + 1);\n      memcpy (tmp, p + matches.rm_so + 2, tmp_size);\n      tmp[tmp_size] = '\\0';\n\n      /* Advance p. */\n      p = p + matches.rm_eo;\n\n      /* Get the substitution text and append it to the result.  */\n      subst_str = recfmt_get_subst (record, tmp);\n      if (subst_str)\n        {\n          rec_buf_puts (subst_str, result_buf);\n          free (subst_str);\n        }\n      free (tmp);\n    }\n\n  /* Add the epilog, if any.  */\n  if (*p)\n    {\n      rec_buf_puts (p, result_buf);\n    }\n  \n  rec_buf_close (result_buf);\n\n  return result;\n}",
      "lines": 74,
      "depth": 13,
      "decorators": [
        "char",
        "*\nrecfmt_apply_template (rec_record_t record,\n                       char *template)",
        "*"
      ]
    },
    "recfmt_process_db": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "void\nrecfmt_process_db (rec_db_t db, char *template)\n{\n  size_t n_rset;\n  rec_rset_t rset;\n  rec_record_t record;\n  char *result;\n  rec_mset_iterator_t iter;\n\n  /* Iterate on all the record sets.  */\n  for (n_rset = 0; n_rset < rec_db_size (db); n_rset++)\n    {\n      rset = rec_db_get_rset (db, n_rset);\n\n      /* Iterate on all the records.  */\n\n      iter = rec_mset_iterator (rec_rset_mset (rset));\n      while (rec_mset_iterator_next (&iter, MSET_RECORD, (const void**) &record, NULL))\n        {\n          /* Apply the template to this record.  */\n          result = recfmt_apply_template (record, template);\n          if (result && (*result != '\\0'))\n            {\n              printf (\"%s\", result);\n              free (result);\n            }\n        }\n\n      rec_mset_iterator_free (&iter);\n    }\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  rec_db_t db;\n\n  recutl_init (\"recfmt\");\n\n  recfmt_parse_args (argc, argv);\n\n  db = recutl_read_db_from_file (NULL);\n  if (db && recfmt_template)\n    {\n      recfmt_process_db (db, recfmt_template);\n    }\n\n  return EXIT_SUCCESS;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recinf.c": {
    "recutl_print_help": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recinf synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recinf [OPTION]... [FILE]...\\n\"));\n\n  /* TRANSLATORS: --help output, recinf short description.\n     no-wrap */\n  fputs (_(\"\\\nPrint information about the types of records stored in the input.\\n\"),\n         stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recinf arguments.\n     no-wrap */\n  fputs (_(\"\\\n  -t, --type=RECORD_TYPE          print information on the records having the\\n\\\n                                    specified type.\\n\\\n  -d, --descriptor                include the full record descriptors.\\n\\\n  -n, --names-only                output just the names of the record files\\n\\\n                                    found in the input.\\n\"),\n         stdout);\n\n  recutl_print_help_common ();\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recinf special options.\n     no-wrap */\n  fputs (_(\"\\\nSpecial options:\\n\\\n  -S, --print-sexps                   print the data in sexps instead of rec format.\\n\"),\n         stdout);\n  \n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "print_info_file": {
      "start_point": [
        117,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "bool\nprint_info_file (FILE *in,\n                 char *file_name)\n{\n  bool ret;\n  rec_db_t db;\n  rec_rset_t rset;\n  rec_record_t descriptor;\n  rec_parser_t parser;\n  int position;\n\n  ret = true;\n  parser = rec_parser_new (in, file_name);\n\n  ret = rec_parse_db (parser, &db);\n  if (ret)\n    {\n      for (position = 0; position < rec_db_size (db); position++)\n        {\n          rset = rec_db_get_rset (db, position);\n          descriptor = rec_rset_descriptor (rset);\n\n          if (recinf_type\n              && descriptor\n              && (strcmp (rec_rset_type (rset), recinf_type) != 0))\n            {\n              continue;\n            }\n\n          if (recinf_descriptor)\n            {\n              rec_writer_t writer;\n              \n              if (descriptor)\n                {\n                  writer = rec_writer_new (stdout);\n                  rec_writer_set_mode (writer, recinf_write_mode);\n                  rec_write_record (writer, descriptor);\n                  rec_write_string (writer, \"\\n\");\n                  rec_writer_destroy (writer);\n                }\n              else\n                {\n                  if (recinf_write_mode == REC_WRITER_NORMAL)\n                    {\n                      printf (\"unknown\\n\");\n                    }\n                }\n\n              if (position < (rec_db_size (db) - 1))\n                {\n                  printf (\"\\n\");\n                }\n            }\n          else\n            {\n              if (descriptor)\n                {\n                  if (!recinf_names_only)\n                    {\n                      fprintf (stdout, \"%zd \", rec_rset_num_records (rset));\n                    }\n                  fprintf (stdout, \"%s\\n\", rec_rset_type (rset));\n                }\n              else\n                {\n                  if (!recinf_names_only)\n                    {\n                      printf (\"%zd\\n\", rec_rset_num_records (rset));\n                    }\n                }\n            }          \n        }\n    }\n  \n  if (rec_parser_error (parser))\n    {\n      rec_parser_perror (parser, file_name);\n    }\n\n  rec_parser_destroy (parser);\n\n  return ret;\n}",
      "lines": 84,
      "depth": 18,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  char c;\n  int ret;\n  char *file_name;\n  FILE *in;\n\n  recutl_init (\"recinf\");\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             \"Sdnt:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n        case PRINT_SEXPS_ARG:\n        case 'S':\n          {\n            recinf_write_mode = REC_WRITER_SEXP;\n            break;\n          }\n        case DESCRIPTOR_ARG:\n        case 'd':\n          {\n            recinf_descriptor = true;\n            break;\n          }\n        case NAMES_ARG:\n        case 'n':\n          {\n            recinf_names_only = true;\n            break;\n          }\n        case TYPE_ARG:\n        case 't':\n          {\n            recinf_type = xstrdup (optarg);\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  /* Process the input files, if any.  Otherwise use the standard\n     input to read the rec data. */\n  if (optind < argc)\n    {\n      while (optind < argc)\n        {\n          file_name = argv[optind++];\n          if (!(in = fopen (file_name, \"r\")))\n            {\n              printf(_(\"error: cannot read file %s\\n\"), file_name);\n              exit (EXIT_FAILURE);\n            }\n          else\n            {\n              if (!print_info_file (in, file_name))\n                {\n                  /* Parse error */\n                  exit (EXIT_FAILURE);\n                }\n\n              fclose (in);\n            }\n        }\n    }\n  else\n    {\n      if (!print_info_file (stdin, \"stdin\"))\n        {\n          /* Parse error */\n          exit (EXIT_FAILURE);\n        }\n    }\n  \n  return EXIT_SUCCESS;\n}",
      "lines": 86,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recins.c": {
    "recutl_print_help": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recins synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recins [OPTION]... [-t TYPE] [-n NUM | -e RECORD_EXPR | -q STR | -m NUM] [(-f NAME -v STR) | -r RECDATA]... [FILE]\\n\"));\n\n  /* TRANSLATORS: --help output, recins short description.\n     no-wrap */\n  fputs (_(\"\\\nInsert new records in a rec database.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recins arguments.\n     no-wrap */\n  fputs (_(\"\\\n  -f, --field=STR                     field name; should be followed by a -v.\\n\\\n  -v, --value=STR                     field value; should be preceded by an -f.\\n\\\n  -r, --record=STR                    record that will be inserted in the file.\\n\\\n      --force                         insert the record even if it is violating\\n\\\n                                        record restrictions.\\n\\\n      --no-external                   don't use external descriptors.\\n\\\n      --no-auto                       don't insert auto generated fields.\\n\\\n      --verbose                       give a detailed report if the integrity check\\n\\\n                                        fails.\\n\"), stdout);\n\n#if defined REC_CRYPT_SUPPORT\n  /* TRANSLATORS: --help output, encryption related options.\n     no-wrap */\n  fputs (_(\"\\\n  -s, --password=STR                  encrypt confidential fields with the given password.\\n\"),\n         stdout);\n#endif\n\n  recutl_print_help_common ();\n\n  puts (\"\");\n  recutl_print_help_record_selection ();\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, notes on recins.\n     no-wrap */\n  fputs (_(\"\\\nIf no FILE is specified then the command acts like a filter, getting\\n\\\nthe data from standard input and writing the result to standard output.\\n\"), stdout);\n\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "recins_parse_args": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void recins_parse_args (int argc,\n                        char **argv)\n{\n  int ret;\n  char c;\n  rec_field_t field = NULL;\n  char *field_name = NULL;\n  rec_record_t provided_record;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             RECORD_SELECTION_SHORT_ARGS\n                             ENCRYPTION_SHORT_ARGS\n                             \"f:v:r:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n          RECORD_SELECTION_ARGS_CASES\n        case FORCE_ARG:\n          {\n            recins_force = true;\n            break;\n          }\n        case VERBOSE_ARG:\n          {\n            recins_verbose = true;\n            break;\n          }\n        case NAME_ARG:\n        case 'f':\n          {\n            if (field != NULL)\n              {\n                recutl_fatal (_(\"a -f should be followed by a -v\\n\"));\n                exit (EXIT_FAILURE);\n              }\n\n            if (recins_record == NULL)\n              {\n                recins_record = rec_record_new ();\n                rec_record_set_source (recins_record, \"cmdli\");\n                rec_record_set_location (recins_record, 0);\n              }\n\n            if (!rec_field_name_p (optarg))\n              {\n                recutl_fatal (_(\"invalid field name %s.\\n\"), optarg);\n              }\n            \n            field = rec_field_new (optarg, \"foo\");\n            break;\n          }\n        case VALUE_ARG:\n        case 'v':\n          {\n            if (field == NULL)\n              {\n                recutl_fatal (_(\"a -v should be preceded by a -f\\n\"));\n              }\n\n            rec_field_set_value (field, optarg);\n            rec_mset_append (rec_record_mset (recins_record), MSET_FIELD, (void *) field, MSET_ANY);\n\n            field = NULL;\n            break;\n          }\n        case NO_EXTERNAL_ARG:\n          {\n            recins_external = false;\n            break;\n          }\n        case NO_AUTO_ARG:\n          {\n            recins_auto = false;\n            break;\n          }\n#if defined REC_CRYPT_SUPPORT\n        case PASSWORD_ARG:\n        case 's':\n          {\n            if (recins_password != NULL)\n              {\n                recutl_fatal (_(\"more than one password was specified\\n\"));\n              }\n\n            recins_password = xstrdup (optarg);\n            break;\n          }\n#endif\n        case RECORD_ARG:\n        case 'r':\n          {\n            /* Parse the provided record and put it in recins_record.  */\n            provided_record = rec_parse_record_str (optarg);\n            if (!provided_record)\n              {\n                recutl_fatal (_(\"error while parsing the record provided by -r\\n\"));\n              }\n\n            if (recins_record)\n              {\n                /* Append the fields in provided_record into\n                   recins_record.  */\n                \n                rec_mset_iterator_t iter = rec_mset_iterator (rec_record_mset (provided_record));\n                while (rec_mset_iterator_next (&iter, MSET_FIELD, (const void **) &field, NULL))\n                  {\n                    rec_mset_append (rec_record_mset (recins_record), MSET_FIELD, (void *) rec_field_dup (field), MSET_ANY);\n                    field = NULL;\n                  }\n                rec_mset_iterator_free (&iter);\n\n                rec_record_destroy (provided_record);\n                provided_record = NULL;\n              }\n            else\n              {\n                recins_record = provided_record;\n              }\n\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n        }\n    }\n\n  if (field != NULL)\n    {\n      recutl_fatal (_(\"please provide a value for the field %s\\n\"), field_name);\n    }\n\n  /* Read the name of the file where to make the insertions.  */\n  if (optind < argc)\n    {\n\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      recins_file = argv[optind++];\n    }\n}",
      "lines": 151,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "recins_add_new_record": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        388,
        1
      ],
      "content": "void\nrecins_add_new_record (rec_db_t db)\n{\n  int flags = 0;\n\n#if defined REC_CRYPT_SUPPORT\n\n  /* Get the password interactively from the user if some field is\n     declared as confidential in the requested record set.  */\n\n  {\n    rec_rset_t rset;\n    rec_fex_t confidential_fields;\n\n    if (recutl_type)\n      {\n        rset = rec_db_get_rset_by_type (db, recutl_type);\n    \n        if (rset)\n          {\n            confidential_fields = rec_rset_confidential (rset);\n            if (!confidential_fields)\n              recutl_out_of_memory ();\n            \n            if (rec_fex_size (confidential_fields) > 0)\n              {\n                if (!recins_password && recutl_interactive ())\n                  {\n                    recins_password = recutl_getpass (true);\n                    if (!recins_password)\n                      {\n                        recutl_fatal (\"not in an interactive terminal.\\n\");\n                      }\n                  }\n                \n                /* Passwords can't be empty.  */\n                \n                if (recins_password && (strlen (recins_password) == 0))\n                  {\n                    free (recins_password);\n                    recins_password = NULL;\n                  }\n              }\n          }\n      }\n  }\n\n#endif /* REC_CRYPT_SUPPORT */\n\n  /* Set flags flags and call the library to perform the\n     requested insertion/replacement operation.  */\n\n  if (recutl_insensitive)\n    {\n      flags = flags | REC_F_ICASE;\n    }\n\n  if (!recins_auto)\n    {\n      flags = flags | REC_F_NOAUTO;\n    }\n\n  if (!rec_db_insert (db,\n                      recutl_type,\n                      recutl_index (),\n                      recutl_sex,\n                      recutl_quick_str,\n                      recutl_random,\n                      recins_password,\n                      recins_record,\n                      flags))\n    recutl_out_of_memory ();\n\n  /* Check for the integrity of the resulting database.  */\n\n  if (!recins_force && db)\n    {\n      recutl_check_integrity (db, recins_verbose, recins_external);\n    }\n}",
      "lines": 80,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  rec_db_t db;\n\n  recutl_init (\"recins\");\n\n  recins_parse_args (argc, argv);\n\n  db = recutl_read_db_from_file (recins_file);\n  if (!db)\n    {\n      /* Create an empty database.  */\n      db = rec_db_new ();\n    }\n  recins_add_new_record (db);\n\n  if (!recutl_file_is_writable (recins_file))\n    {\n      recutl_error (_(\"file %s is not writable.\\n\"), recins_file);\n      return EXIT_FAILURE;\n    }\n  recutl_write_db_to_file (db, recins_file);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recsel.c": {
    "recutl_print_help": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recsel synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recsel [OPTION]... [-t TYPE] [-j FIELD] [-n INDEXES | -e RECORD_EXPR | -q STR | -m NUM] [-c | (-p|-P) FIELD_EXPR] [FILE]...\\n\"));\n\n  /* TRANSLATORS: --help output, recsel arguments.\n     no-wrap */\n  fputs(_(\"\\\nSelect and print rec data.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recsel arguments.\n     no-wrap */\n  fputs (_(\"\\\n  -d, --include-descriptors           print record descriptors along with the matched\\n\\\n                                        records.\\n\\\n  -C, --collapse                      do not section the result in records with newlines.\\n\\\n  -S, --sort=FIELD,...                sort the output by the specified fields.\\n\\\n  -G, --group-by=FIELD,...            group records by the specified fields.\\n\\\n  -U, --uniq                          remove duplicated fields in the output records.\\n\"),\n         stdout);\n\n#if defined REC_CRYPT_SUPPORT\n  /* TRANSLATORS: --help output, encryption related options.\n     no-wrap */\n  fputs (_(\"\\\n  -s, --password=STR                  decrypt confidential fields with the given password.\\n\"),\n         stdout);\n#endif\n  \n  recutl_print_help_common ();\n\n  puts (\"\");\n  recutl_print_help_record_selection ();\n  fputs (_(\"\\\n  -j, --join=FIELD                    perform an inner join using the specified field.\\n\"),\n         stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recsel output options.\n     no-wrap */\n  fputs (_(\"\\\nOutput options:\\n\\\n  -p, --print=FIELDS                  comma-separated list of fields to print for each\\n\\\n                                        matching record.\\n\\\n  -P, --print-values=FIELDS           as -p, but print only the values of the selected\\n\\\n                                        fields.\\n\\\n  -R, --print-row=FIELDS              as -P, but separate the values with spaces instead\\n\\\n                                        of newlines.\\n\\\n  -c, --count                         print a count of the matching records instead of\\n\\\n                                        the records themselves.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recsel special options.\n     no-wrap */\n  fputs (_(\"\\\nSpecial options:\\n\\\n      --print-sexps                   print the data in sexps instead of rec format.\\n\"),\n         stdout);\n\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 66,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "recsel_parse_args": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "void\nrecsel_parse_args (int argc,\n                   char **argv)\n{\n  char c;\n  int ret;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             RECORD_SELECTION_SHORT_ARGS\n                             ENCRYPTION_SHORT_ARGS\n                             \"S:Cdcp:P:R:UG:j:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n        COMMON_ARGS_CASES\n        RECORD_SELECTION_ARGS_CASES\n        case DESCRIPTOR_ARG:\n        case 'd':\n          {\n            recsel_descriptors = true;\n            break;\n          }\n        case PRINT_SEXPS_ARG:\n          {\n            recsel_write_mode = REC_WRITER_SEXP;\n            break;\n          }\n        case UNIQ_ARG:\n        case 'U':\n          {\n            recsel_uniq = true;\n            break;\n          }\n#if defined REC_CRYPT_SUPPORT\n        case PASSWORD_ARG:\n        case 's':\n          {\n            if (recsel_password != NULL)\n              {\n                recutl_fatal (_(\"more than one password was specified\\n\"));\n              }\n\n            recsel_password = xstrdup (optarg);\n            break;\n          }\n#endif\n        case SORT_ARG:\n        case 'S':\n          {\n            if (recutl_sort_by_fields)\n              {\n                recutl_fatal (_(\"only one field list can be specified as a sorting criteria.\\n\"));\n              }\n\n            /* Parse the field name.  */\n\n            if (!rec_fex_check (optarg, REC_FEX_CSV))\n              {\n                recutl_fatal (_(\"invalid field names in -S.\\n\"));\n              }\n\n            recutl_sort_by_fields = rec_fex_new (optarg, REC_FEX_CSV);\n            if (!recutl_sort_by_fields)\n              {\n                recutl_fatal (_(\"internal error creating fex.\\n\"));\n              }\n\n            break;\n          }\n        case JOIN_ARG:\n        case 'j':\n          {\n            if (recsel_join)\n              {\n                recutl_fatal (_(\"only one field can be specified as join criteria.\\n\"));\n              }\n\n            if (!rec_field_name_p (optarg))\n              {\n                recutl_fatal (_(\"please specify a correct field name to -j|--join.\\n\"));\n              }\n\n            recsel_join = xstrdup (optarg);\n            break;\n          }\n        case GROUP_BY_ARG:\n        case 'G':\n          {\n            if (recsel_group_by_fields)\n              {\n                recutl_fatal (_(\"only one field list can be specified as a grouping criteria.\\n\"));\n              }\n\n            /* Parse the field name.  */\n            if (!rec_fex_check (optarg, REC_FEX_CSV))\n              {\n                recutl_fatal (_(\"invalid field names in -G.\\n\"));\n              }\n\n            recsel_group_by_fields = rec_fex_new (optarg, REC_FEX_CSV);\n            if (!recsel_group_by_fields)\n              {\n                recutl_fatal (_(\"internal error creating fex.\\n\"));\n              }\n\n            break;\n          }\n        case PRINT_ARG:\n        case PRINT_VALUES_ARG:\n        case PRINT_IN_A_ROW_ARG:\n        case 'p':\n        case 'P':\n        case 'R':\n          {\n            if (recsel_count)\n              {\n                recutl_fatal (_(\"cannot specify -[pPR] and also -c.\\n\"));\n              }\n\n            if ((c == 'P') || (c == PRINT_VALUES_ARG))\n              {\n                recsel_write_mode = REC_WRITER_VALUES;\n              }\n\n            if ((c == 'R') || (c == PRINT_IN_A_ROW_ARG))\n              {\n                recsel_write_mode = REC_WRITER_VALUES_ROW;\n              }\n\n            recsel_fex_str = xstrdup (optarg);\n\n            if (!rec_fex_check (recsel_fex_str, REC_FEX_SUBSCRIPTS))\n              {\n                recutl_fatal (_(\"invalid list of fields in -%c\\n\"), c);\n              }\n\n            /* Create the field expresion.  */\n            recsel_fex = rec_fex_new (recsel_fex_str,\n                                      REC_FEX_SUBSCRIPTS);\n            if (!recsel_fex)\n              {\n                recutl_fatal (_(\"internal error creating the field expression.\\n\"));\n              }\n\n            /* Check that all the functions called in the fex exist.\n               Otherwise raise an error.  */\n            \n            {\n              size_t i = 0;\n              for (i = 0; i < rec_fex_size (recsel_fex); i++)\n                {\n                  rec_fex_elem_t elem = rec_fex_get (recsel_fex, i);\n                  const char *fname = rec_fex_elem_function_name (elem);\n\n                  if (fname && !rec_aggregate_std_p (fname))\n                    {\n                      recutl_fatal (_(\"invalid aggregate function '%s'\\n\"), fname);\n                    }\n                }\n            }\n\n            break;\n          }\n        case COLLAPSE_ARG:\n        case 'C':\n          {\n            recsel_collapse = true;\n            break;\n          }\n        case COUNT_ARG:\n        case 'c':\n          {\n            if (recsel_fex_str)\n              {\n                recutl_fatal (_(\"cannot specify -c and also -p.\\n\"));\n                exit (EXIT_FAILURE);\n              }\n\n            recsel_count = true;\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n          }\n\n        }\n    }\n\n  /* Global checks on the parameters.  */\n\n  if (!recutl_type && recsel_join)\n    {\n      recutl_fatal (_(\"joins can only be used when a named record set is selected.\\n\"));\n    }\n}",
      "lines": 200,
      "depth": 20,
      "decorators": [
        "void"
      ]
    },
    "recsel_process_data": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "bool\nrecsel_process_data (rec_db_t db)\n{\n  int rset_size = 0;\n  rec_rset_t rset = NULL;\n  rec_writer_t writer = NULL;\n\n\n#if defined REC_CRYPT_SUPPORT\n\n  /* If recsel was called interactively and with an empty -s, was not\n     used then prompt the user for it.  Otherwise use the password\n     specified in the command line if any.  */\n\n  if (!recsel_password\n      && (recutl_type || (rec_db_size (db) == 1))\n      && recutl_interactive ())\n    {\n      rec_rset_t rset;\n      rec_fex_t confidential_fields;\n\n      if (recutl_type)\n        {\n          rset = rec_db_get_rset_by_type (db, recutl_type);\n        }\n      else\n        {\n          rset = rec_db_get_rset (db, 0);\n        }\n\n      if (rset)\n        {\n          confidential_fields = rec_rset_confidential (rset);\n          if (rec_fex_size (confidential_fields) > 0)\n            {\n              recsel_password = recutl_getpass (false);\n            }\n          \n          rec_fex_destroy (confidential_fields);\n        }\n    }\n\n  /* Note that the password must be at least one character long.  */\n\n  if (recsel_password && (strlen (recsel_password) == 0))\n    {\n      free (recsel_password);\n      recsel_password = NULL;\n    }\n\n#endif /* REC_CRYPT_SUPPORT */\n\n  /* If the database contains more than one type of records and the\n     user did'nt specify the recutl_type then ask the user to clarify\n     the request.  */\n\n  if (!recutl_type && (rec_db_size (db) > 1))\n    {\n      recutl_fatal (_(\"several record types found.  Please use -t to specify one.\\n\"));\n    }\n\n\n  /* Query the database using the criteria specified by the user in\n     the command line.  */\n\n  {\n    int flags = 0;\n\n    if (recutl_insensitive)\n      {\n        flags = flags | REC_F_ICASE;\n      }\n\n    if (recsel_descriptors)\n      {\n        flags = flags | REC_F_DESCRIPTOR;\n      }\n\n    if (recsel_uniq)\n      {\n        flags = flags | REC_F_UNIQ;\n      }\n\n    rset = rec_db_query (db,\n                         recutl_type,\n                         recsel_join,\n                         recutl_index(),\n                         recutl_sex,\n                         recutl_quick_str,\n                         recutl_random,\n                         recsel_fex,\n                         recsel_password,\n                         recsel_group_by_fields,\n                         recutl_sort_by_fields,\n                         flags);\n    if (!rset)\n      recutl_out_of_memory ();\n  }\n\n  if (recsel_count)\n    {\n      /* Write the number of matching records.  */\n      \n      fprintf (stdout, \"%d\\n\", rec_rset_num_records (rset));\n    }\n  else\n    {\n      /* Write the resulting record set to the standard output.  */\n\n      writer = rec_writer_new (stdout);\n      rec_writer_set_collapse (writer, recsel_collapse);\n      rec_writer_set_skip_comments (writer, true);\n      rec_writer_set_mode (writer, recsel_write_mode);\n      rec_write_rset (writer, rset);\n      rec_writer_destroy (writer);\n    }\n\n  rec_rset_destroy (rset);\n\n  return true;\n}",
      "lines": 121,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "main": {
      "start_point": [
        502,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  int res;\n  rec_db_t db;\n\n  res = 0;\n\n  recutl_init (\"recsel\");\n\n  /* Parse arguments.  */\n  recsel_parse_args (argc, argv);\n\n  /* Get the input data.  */\n  db = recutl_build_db (argc, argv);\n  if (!db)\n    {\n      res = 1;\n      return res;\n    }\n\n  /* Process the data.  */\n  if (!recsel_process_data (db))\n    {\n      res = 1;\n    }\n\n  rec_db_destroy (db);\n\n  return res;\n}",
      "lines": 31,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recset.c": {
    "recutl_print_help": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\nrecutl_print_help (void)\n{\n  /* TRANSLATORS: --help output, recset synopsis.\n     no-wrap */\n  printf (_(\"\\\nUsage: recset [OPTION]... [FILE]...\\n\"));\n\n  /* TRANSLATORS: --help output, recset short description.\n     no-wrap */\n  fputs (_(\"\\\nAlter or delete fields in records.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recset options.\n     no-wrap */\n  fputs (_(\"\\\n      --no-external                   don't use external descriptors.\\n\\\n      --force                         alter the records even if violating record\\n\\\n                                        restrictions.\\n\"), stdout);\n\n  recutl_print_help_common ();\n\n  puts (\"\");\n  recutl_print_help_record_selection ();\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recset field selection options.\n     no-wrap */\n  fputs (_(\"\\\nField selection options:\\n\\\n  -f, --fields=FIELDS                 comma-separated list of field names with optional\\n\\\n                                        subscripts.\\n\"), stdout);\n\n  puts (\"\");\n  /* TRANSLATORS: --help output, recset actions.\n     no-wrap */\n  fputs (_(\"\\\nActions:\\n\\\n  -s, --set=VALUE                     change the value of the selected fields.\\n\\\n  -a, --add=VALUE                     add the selected fields with the given value.\\n\\\n  -S, --set-add=VALUE                 change the value of the selected fields.  If they don't\\n\\\n                                        exist then add a new field with that value.\\n\\\n  -r, --rename=NAME                   rename the selected fields to a given name.  If an entire\\n\\\n                                        record set is selected then the field is renamed in the\\n\\\n                                        record descriptor as well.\\n\\\n  -d, --delete                        delete the selected fields.\\n\\\n  -c, --comment                       comment out the selected fields.\\n\"), stdout);\n\n  puts (\"\");\n  recutl_print_help_footer ();\n}",
      "lines": 52,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recset_parse_args": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "static void\nrecset_parse_args (int argc,\n                   char **argv)\n{\n  int ret;\n  char c;\n\n  while ((ret = getopt_long (argc,\n                             argv,\n                             RECORD_SELECTION_SHORT_ARGS\n                             \"dct:s:S:a:f:r:\",\n                             GNU_longOptions,\n                             NULL)) != -1)\n    {\n      c = ret;\n      switch (c)\n        {\n          COMMON_ARGS_CASES\n          RECORD_SELECTION_ARGS_CASES\n        case FORCE_ARG:\n          {\n            recset_force = true;\n            break;\n          }\n        case VERBOSE_ARG:\n          {\n            recset_verbose = true;\n            break;\n          }\n        case FIELD_EXPR_ARG:\n        case 'f':\n          {\n            recutl_fex_str = xstrdup (optarg);\n            if (!rec_fex_check (recutl_fex_str, REC_FEX_SUBSCRIPTS))\n              {\n                recutl_fatal (_(\"invalid field expression in -f.\\n\"));\n              }\n\n            /* Create the field expression.  */\n            recutl_fex = rec_fex_new (recutl_fex_str,\n                                      REC_FEX_SUBSCRIPTS);\n            if (!recutl_fex)\n              {\n                recutl_fatal (_(\"creating the field expression.\\n\"));\n              }\n\n            /* Sort it.  */\n            rec_fex_sort (recutl_fex);\n\n            break;\n          }\n        case SET_ACTION_ARG:\n        case 's':\n          {\n            CHECK_ACTION_PREREQ;\n            recset_action = REC_SET_ACT_SET;\n            recset_value = xstrdup (optarg);\n            break;\n          }\n        case RENAME_ACTION_ARG:\n        case 'r':\n          {\n            CHECK_ACTION_PREREQ;\n            if (rec_fex_size (recutl_fex) != 1)\n              {\n                recutl_fatal (_(\"the rename operation requires just one field with an optional subscript.\\n\"));\n              }\n\n            recset_action = REC_SET_ACT_RENAME;\n            recset_value = xstrdup (optarg);\n\n            /* Validate the new name.  */\n            recset_new_field_name = recset_value;\n            if (!rec_field_name_p (recset_new_field_name))\n              {\n                recutl_fatal (_(\"invalid field name %s.\\n\"), recset_value);\n              }\n            \n            break;\n          }\n        case ADD_ACTION_ARG:\n        case 'a':\n          {\n            CHECK_ACTION_PREREQ;\n            recset_action = REC_SET_ACT_ADD;\n            recset_value = xstrdup (optarg);\n            break;\n          }\n        case SET_ADD_ACTION_ARG:\n        case 'S':\n          {\n            CHECK_ACTION_PREREQ;\n            recset_action = REC_SET_ACT_SETADD;\n            recset_value = xstrdup (optarg);\n            break;\n          }\n        case DELETE_ACTION_ARG:\n        case 'd':\n          {\n            CHECK_ACTION_PREREQ;\n            recset_action = REC_SET_ACT_DELETE;\n            break;\n          }\n        case COMMENT_ACTION_ARG:\n        case 'c':\n          {\n            CHECK_ACTION_PREREQ;\n            recset_action = REC_SET_ACT_COMMENT;\n            break;\n          }\n        case NO_EXTERNAL_ARG:\n          {\n            recset_external = false;\n            break;\n          }\n        default:\n          {\n            exit (EXIT_FAILURE);\n            break;\n          }\n        }\n    }\n\n  /* Read the name of the data source.  */\n  if (optind < argc)\n    {\n      if ((argc - optind) != 1)\n        {\n          recutl_print_help ();\n          exit (EXIT_FAILURE);\n        }\n\n      recset_file = argv[optind++];\n    }\n\n}",
      "lines": 136,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "recset_process_actions": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "static void\nrecset_process_actions (rec_db_t db)\n{\n  int flags = 0;\n\n  if (recutl_insensitive)\n    {\n      flags = flags | REC_F_ICASE;\n    }\n\n  if (!rec_db_set (db,\n                   recutl_type,\n                   recutl_index (),\n                   recutl_sex,\n                   recutl_quick_str,\n                   recutl_random,\n                   recutl_fex,\n                   recset_action,\n                   recset_value,\n                   flags))\n    recutl_out_of_memory ();\n  \n  /* Check the integrity of the resulting database.  */\n\n  if (!recset_force && db)\n    {\n      recutl_check_integrity (db, recset_verbose, recset_external);\n    }\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "int\nmain (int argc, char *argv[])\n{\n  rec_db_t db;\n  \n  recutl_init (\"recset\");\n\n  /* Parse arguments.  */\n  recset_parse_args (argc, argv);\n\n  db = recutl_read_db_from_file (recset_file);\n  if (!db)\n    {\n      recutl_fatal (_(\"cannot read file %s\\n\"), recset_file);\n    }\n\n  recset_process_actions (db);\n\n  if (!recutl_file_is_writable (recset_file))\n    {\n      recutl_error (_(\"file %s is not writable.\\n\"), recset_file);\n      return EXIT_FAILURE;\n    }\n  recutl_write_db_to_file (db, recset_file);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recutl.c": {
    "recutl_init": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nrecutl_init (char *util_name)\n{\n  set_program_name (xstrdup (util_name));\n\n#if defined REC_CRYPT_SUPPORT\n  /* Initialize libgcrypt */\n  gcry_check_version (NULL);\n  gcry_control (GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\n  /* Initialize librec */\n  rec_init ();\n\n  /* Even exiting has subtleties.  On exit, if any writes failed, change\n     the exit status.  The /dev/full device on GNU/Linux can be used for\n     testing; for instance, hello >/dev/full should exit unsuccessfully.\n     This is implemented in the Gnulib module \"closeout\".  */\n  atexit (close_stdout);\n\n  /* i18n */\n  setlocale (LC_ALL, \"\");\n  bindtextdomain (PACKAGE, LOCALEDIR);\n  textdomain (PACKAGE);\n\n  /* Detect whether the tool has been invoked interactively.  */\n  \n  recutl_interactive_p = isatty (fileno(stdin));\n\n  /* Initially there are no indexes.  */\n\n  recutl_reset_indexes ();\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_interactive": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "bool\nrecutl_interactive (void)\n{\n  return recutl_interactive_p;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "bool"
      ]
    },
    "recutl_print_help_footer": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "void\nrecutl_print_help_footer (void)\n{\n  /* TRANSLATORS: --help output 5+ (reports)\n     TRANSLATORS: the placeholder indicates the bug-reporting address\n     for this application.  Please add _another line_ with the\n     address for translation bugs.\n     no-wrap */\n  printf (_(\"\\\nReport bugs to: %s\\n\"), PACKAGE_BUGREPORT);\n#ifdef PACKAGE_PACKAGER_BUG_REPORTS\n  printf (_(\"Report %s bugs to: %s\\n\"), PACKAGE_PACKAGER,\n          PACKAGE_PACKAGER_BUG_REPORTS);\n#endif\n#ifdef PACKAGE_URL\n  printf (_(\"%s home page: <%s>\\n\"), PACKAGE_NAME, PACKAGE_URL);\n#else\n  printf (_(\"%s home page: <http://www.gnu.org/software/recutils/>\\n\"),\n          PACKAGE_NAME, PACKAGE);\n#endif\n  fputs (_(\"General help using GNU software: <http://www.gnu.org/gethelp/>\\n\"),\n         stdout);\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "recutl_print_help_common": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\nrecutl_print_help_common (void)\n{\n  /* TRANSLATORS: --help output, common arguments.\n     no-wrap */\n  fputs (_(\"\\\n      --help                          print a help message and exit.\\n\\\n      --version                       show version and exit.\\n\"),\n         stdout);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_print_help_record_selection": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\nrecutl_print_help_record_selection (void)\n{\n  /* TRANSLATORS: --help output, record selection arguments\n     no-wrap */\n  fputs (_(\"\\\nRecord selection options:\\n\\\n  -i, --case-insensitive              make strings case-insensitive in selection\\n\\\n                                        expressions.\\n\\\n  -t, --type=TYPE                     operate on records of the specified type only.\\n\\\n  -e, --expression=RECORD_EXPR        selection expression.\\n\\\n  -q, --quick=STR                     select records with fields containing a string.\\n\\\n  -n, --number=NUM,...                select specific records by position, with ranges.\\n\\\n  -m, --random=NUM                    select a given number of random records.\\n\"),\n         stdout);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_print_version": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nrecutl_print_version (void)\n{\n  printf (\"%s (GNU %s) %s\\n\",\n          program_name,\n          PACKAGE,\n          VERSION);\n  /* xgettext: no-wrap */\n  puts (\"\");\n\n  /* It is important to separate the year from the rest of the message,\n     as done here, to avoid having to retranslate the message when a new\n     year comes around.  */  \n  printf (_(\"\\\nCopyright (C) %s Jose E. Marchesi.\\n\\\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>.\\n\\\nThis is free software: you are free to change and redistribute it.\\n\\\nThere is NO WARRANTY, to the extent permitted by law.\\n\"), \"2010, 2011, 2012, 2013, 2014\");\n\n  puts (_(\"\\\n\\n\\\nWritten by Jose E. Marchesi.\"));\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_fatal": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "void\nrecutl_fatal (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  fputs (program_name, stderr);\n  fputs (_(\": error: \"), stderr);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n\n  exit (EXIT_FAILURE);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_out_of_memory": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void\nrecutl_out_of_memory (void)\n{\n  recutl_fatal (_(\"out of memory\\n\"));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_error": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "void\nrecutl_error (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  fputs (program_name, stderr);\n  fputs (_(\": error: \"), stderr);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_warning": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "void\nrecutl_warning (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  fputs (program_name, stderr);\n  fputs (_(\": warning: \"), stderr);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "recutl_parse_db_from_file": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "bool\nrecutl_parse_db_from_file (FILE *in,\n                           char *file_name,\n                           rec_db_t db)\n{\n  bool res;\n  rec_rset_t rset;\n  rec_parser_t parser;\n\n  res = true;\n\n  parser = rec_parser_new (in, file_name);\n  while (rec_parse_rset (parser, &rset))\n    {\n      char *rset_type;\n      /* XXX: check for consistency!!!.  */\n      rset_type = rec_rset_type (rset);\n      if (rec_db_type_p (db, rset_type))\n        {\n          if (rset_type)\n            recutl_fatal (_(\"duplicated record set '%s' from %s.\\n\"),\n                          rset_type, file_name);\n          else\n            {\n              /* Special case: the database already contains anonymous\n                 records (with no type) and the record set to be\n                 inserted also contains anonyous records.  In this\n                 case we just append the records and comments in the\n                 anonymous record set.  */\n\n              rec_rset_t anon_rset = rec_db_get_rset_by_type (db, NULL);\n              rec_mset_iterator_t iter = rec_mset_iterator (rec_rset_mset (rset));\n              rec_mset_elem_t elem;\n              while (rec_mset_iterator_next (&iter, MSET_ANY, NULL, &elem))\n                {\n                  void *data = rec_mset_elem_dup_data (elem);\n                  if (!data\n                      || !rec_mset_append (rec_rset_mset (anon_rset),\n                                           rec_mset_elem_type (elem),\n                                           data,\n                                           MSET_ANY))\n                    return false;\n                }\n              rec_mset_iterator_free (&iter);\n              return true;\n            }\n        }\n          \n      if (!rec_db_insert_rset (db, rset, rec_db_size (db)))\n        {\n          /* Error.  */\n          res = false;\n          break;\n        }\n    }\n\n  if (rec_parser_error (parser))\n    {\n      /* Report parsing errors.  */\n      rec_parser_perror (parser, \"%s\", file_name);\n      res = false;\n    }\n  rec_parser_destroy (parser);\n\n  return res;\n}",
      "lines": 66,
      "depth": 19,
      "decorators": [
        "bool"
      ]
    },
    "recutl_build_db": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "rec_db_t\nrecutl_build_db (int argc, char **argv)\n{\n  rec_db_t db;\n  char *file_name;\n  FILE *in;\n\n  db = rec_db_new ();\n  if (!db)\n    {\n      return NULL;\n    }\n\n  /* Register the default functions in the database.  */\n\n  \n\n  /* Process the input files, if any.  Otherwise use the standard\n     input to read the rec data.  */\n\n  if (optind < argc)\n    {\n      while (optind < argc)\n        {\n          file_name = argv[optind++];\n          if (!(in = fopen (file_name, \"r\")))\n            {\n              recutl_fatal (_(\"cannot read file %s\\n\"), file_name);\n            }\n          else\n            {\n              if (!recutl_parse_db_from_file (in, file_name, db))\n                {\n                  free (db);\n                  db = NULL;\n                }\n              \n              fclose (in);\n            }\n        }\n    }\n  else\n    {\n      if (!recutl_parse_db_from_file (stdin, \"stdin\", db))\n        {\n          free (db);\n          db = NULL;\n        }\n    }\n\n  return db;\n}",
      "lines": 52,
      "depth": 15,
      "decorators": [
        "rec_db_t"
      ]
    },
    "recutl_read_db_from_file": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "rec_db_t\nrecutl_read_db_from_file (char *file_name)\n{\n  rec_db_t db;\n  FILE *in;\n\n  db = rec_db_new ();\n  if (file_name)\n    {\n      in = fopen (file_name, \"r\");\n      if (in == NULL)\n        {\n           return NULL;\n        }\n    }\n  else\n    {\n      /* Process the standard input.  */\n      file_name = \"stdin\";\n      in = stdin;\n    }\n\n  if (!recutl_parse_db_from_file (in,\n                                  file_name,\n                                  db))\n    {\n      rec_db_destroy (db);\n      db = NULL;\n    }\n\n  return db;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "rec_db_t"
      ]
    },
    "recutl_file_is_writable": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "bool\nrecutl_file_is_writable (char *file_name)\n{\n  return !file_name || (euidaccess (file_name, W_OK) == 0);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "bool"
      ]
    },
    "recutl_write_db_to_file": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "void\nrecutl_write_db_to_file (rec_db_t db,\n                         char *file_name)\n{\n  FILE *out;\n  char tmp_file_name[10]=\"recXXXXXX\";\n  rec_writer_t writer;\n  int des;\n  struct stat st1;\n  int stat_result;\n\n  if (!file_name)\n    {\n      out = stdout;\n    }\n  else\n    {\n      /* Record the original file attributes. */\n      stat_result = stat (file_name, &st1);\n\n      /* Create a temporary file with the results. */\n      des = mkstemp (tmp_file_name);\n      if (des == -1)\n        {\n          recutl_fatal (_(\"cannot create a unique name.\\n\"));\n        }\n      out = fdopen (des, \"w+\");\n    }\n\n  writer = rec_writer_new (out);\n  rec_write_db (writer, db);\n\n  if (file_name)\n    {\n      fclose (out);\n    }\n\n  rec_db_destroy (db);\n\n  if (file_name)\n    {\n      /* Rename the temporary file to file_name.  */\n      if (rename (tmp_file_name, file_name) == -1)\n        {\n          remove (tmp_file_name);\n          recutl_fatal (_(\"renaming file %s to %s\\n\"), tmp_file_name, file_name);\n        }\n\n      /* Restore the attributes of the original file. */\n      if (stat_result != -1)\n        {\n          chmod (file_name, st1.st_mode);\n        }\n    }\n}",
      "lines": 55,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "recutl_read_file": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "char *\nrecutl_read_file (char *file_name)\n{\n  char *result;\n  FILE *in;\n\n  result = NULL;\n  in = fopen (file_name, \"r\");\n  if (in)\n    {\n      size_t file_size;\n      result = fread_file (in, &file_size);\n      fclose (in);\n    }\n\n  return result;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "char",
        "*\nrecutl_read_file (char *file_name)",
        "*"
      ]
    },
    "recutl_check_integrity": {
      "start_point": [
        460,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "void\nrecutl_check_integrity (rec_db_t db,\n                        bool verbose_p,\n                        bool external_p)\n{\n  rec_buf_t errors_buf;\n  char *errors_str;\n  size_t errors_str_size;\n\n  errors_buf = rec_buf_new (&errors_str, &errors_str_size);\n  if (rec_int_check_db (db, true, external_p, errors_buf) > 0)\n    {\n      rec_buf_close (errors_buf);\n      if (!verbose_p)\n        {\n          recutl_error (_(\"operation aborted due to integrity failures.\\n\"));\n          recutl_error (_(\"use --verbose to get a detailed report.\\n\"));\n        }\n      else\n        {\n          fprintf (stderr, \"%s\", errors_str);\n        }\n\n      recutl_fatal (_(\"use --force to skip the integrity check.\\n\"));\n    }\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "recutl_yesno": {
      "start_point": [
        487,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "bool\nrecutl_yesno (char *prompt)\n{\n  bool res = false;\n  char *line = NULL;\n\n  while (1)\n    {\n      line = readline (prompt);\n      if (line)\n        {\n          if (strcmp (line, \"yes\") == 0)\n            {\n              res = true;\n              break;\n            }\n          else if (strcmp (line, \"no\") == 0)\n            {\n              res = false;\n              break;\n            }\n        }\n\n      printf (\"Please answer 'yes' or 'no'.\\n\");\n    }           \n\n  return res;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "bool"
      ]
    },
    "recutl_index_list_parse": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        592,
        1
      ],
      "content": "bool\nrecutl_index_list_parse (const char *str)\n{\n  regex_t regexp;\n  bool res = true;\n  const char *p;\n  long int number;\n  char *end;\n  size_t i;\n\n  /* Initialize the list structure.   An pessimistic estimation of the\n     number of indexes encoded in the string is used.  */\n\n  free (recutl_indexes);\n  recutl_indexes = xmalloc (sizeof (size_t) * (strlen (str) * 2 + 2));\n  for (i = 0; i < (strlen (str) * 2 + 2); i++)\n    {\n      recutl_indexes[i] = REC_Q_NOINDEX;\n    }\n  \n  /* Make sure the string is valid.  The code below relies on this\n     fact.  */\n\n  if (regcomp (&regexp, \"^\" INDEX_LIST_RE \"$\", REG_EXTENDED) != 0)\n    {\n      recutl_fatal (_(\"internal error: recutl_index_list_parse: error compiling regexp.\\n\"));\n      return false;\n    }\n\n  if (regexec (&regexp, str, 0, NULL, 0) != 0)\n    {\n      regfree (&regexp);\n      return false;\n    }\n\n  regfree (&regexp);\n\n  /* Parse the string. */\n\n  p = str;\n  while (true)\n    {\n      /* Get the 'min' part of the entry.  */\n\n      number = strtol (p, &end, 10);\n      recutl_indexes[recutl_indexes_size] = (size_t) number;\n      p = end;\n\n      /* Get the 'max' part of the entry, if any.  */\n      \n      if (*p == '-')\n        {\n          p++;\n          number = strtol (p, &end, 10);\n          recutl_indexes[recutl_indexes_size+1] = (size_t) number;\n          p = end;\n        }\n\n      recutl_indexes_size = recutl_indexes_size + 2;\n\n      /* Exit or pass the separator.  */\n\n      if (*p == '\\0')\n        {\n          break;\n        }\n      else\n        {\n          p++;\n        }\n    }\n\n  return res;\n}",
      "lines": 74,
      "depth": 15,
      "decorators": [
        "bool"
      ]
    },
    "recutl_reset_indexes": {
      "start_point": [
        594,
        0
      ],
      "end_point": [
        600,
        1
      ],
      "content": "void\nrecutl_reset_indexes (void)\n{\n  free (recutl_indexes);\n  recutl_indexes = NULL;\n  recutl_indexes_size = 0;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "recutl_num_indexes": {
      "start_point": [
        602,
        0
      ],
      "end_point": [
        606,
        1
      ],
      "content": "size_t\nrecutl_num_indexes (void)\n{\n  return recutl_indexes_size;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "size_t"
      ]
    },
    "recutl_index": {
      "start_point": [
        608,
        0
      ],
      "end_point": [
        612,
        1
      ],
      "content": "size_t *\nrecutl_index (void)\n{\n  return recutl_indexes;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t",
        "*\nrecutl_index (void)",
        "*"
      ]
    },
    "recutl_getpass": {
      "start_point": [
        614,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "char *\nrecutl_getpass (bool asktwice)\n{\n  char *ret = NULL;\n\n  char *pass = getpass (_(\"Password: \"));\n  if (pass)\n    {\n      ret = xstrdup (pass);\n      if (asktwice)\n        {\n          pass = getpass (_(\"Password again: \"));\n          if (pass)\n            {\n              if (strcmp (ret, pass) != 0)\n                {\n                  recutl_fatal (_(\"the provided passwords don't match.\\n\"));\n                  memset (ret, 0, strlen (ret));\n                  memset (pass, 0, strlen (pass));\n                }\n            }\n          else\n            {\n              memset (ret, 0, strlen (ret));\n              free (ret);\n              ret = NULL;\n            }\n        }\n    }\n\n  return ret;\n}",
      "lines": 32,
      "depth": 17,
      "decorators": [
        "char",
        "*\nrecutl_getpass (bool asktwice)",
        "*"
      ]
    }
  },
  "recutils/recutils-1.7/utils/recutl.h": {}
}