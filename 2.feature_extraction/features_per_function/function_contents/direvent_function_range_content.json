{
  "direvent/direvent-5.1/grecs/gitid.h": {},
  "direvent/direvent-5.1/grecs/include/grecs.h": {},
  "direvent/direvent-5.1/grecs/include/wordsplit.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/doc.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/error.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/format.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/json.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/lex.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/list.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/locus.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/mem.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/node.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/opt.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/parser.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/preproc.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/sockaddr.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/symtab.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/table.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/tree.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/txtacc.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/types.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/util.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/value.h": {},
  "direvent/direvent-5.1/grecs/include/grecs/version.h": {},
  "direvent/direvent-5.1/grecs/src/asprintf.c": {
    "grecs_vasprintf": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\ngrecs_vasprintf(char **pbuf, size_t *psize, const char *fmt, va_list ap)\n{\n\tchar *buf = *pbuf;\n\tsize_t buflen = *psize;\n\tint rc = 0;\n  \n\tif (!buf) {\n\t\tif (buflen == 0)\n\t\t\tbuflen = 512; /* Initial allocation */\n      \n\t\tbuf = calloc(1, buflen);\n\t\tif (buf == NULL)\n\t\t\treturn ENOMEM;\n\t}\n  \n\tfor (;;) {\n\t\tva_list aq;\n\t\tssize_t n;\n\n\t\tva_copy(aq, ap);\n\t\tn = vsnprintf(buf, buflen, fmt, aq);\n\t\tva_end(aq);\n\t\tif (n < 0 || n >= buflen || !memchr(buf, '\\0', n + 1)) {\n\t\t\tchar *newbuf;\n\t\t\tsize_t newlen = buflen * 2;\n\t\t\tif (newlen < buflen) {\n\t\t\t\trc = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnewbuf = realloc(buf, newlen);\n\t\t\tif (newbuf == NULL) {\n\t\t\t\trc = ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuflen = newlen;\n\t\t\tbuf = newbuf;\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (rc) {\n\t\tif (!*pbuf) {\n\t\t\t/* We made first allocation, now free it */\n\t\t\tfree(buf);\n\t\t\tbuf = NULL;\n\t\t\tbuflen = 0;\n\t\t}\n\t}\n\t\n\t*pbuf = buf;\n\t*psize = buflen;\n\treturn rc;\n}",
      "lines": 54,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "grecs_asprintf": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "int\ngrecs_asprintf(char **pbuf, size_t *psize, const char *fmt, ...)\n{\n\tint rc;\n\tva_list ap;\n\t\n\tva_start(ap, fmt);\n\trc = grecs_vasprintf(pbuf, psize, fmt, ap);\n\tva_end(ap);\n\treturn rc;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/bind-gram.c": {
    "grecs_bind_tnamerr": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        998,
        1
      ],
      "content": "static YYSIZE_T\ngrecs_bind_tnamerr (char *grecs_bind_res, const char *grecs_bind_str)\n{\n  if (*grecs_bind_str == '\"')\n    {\n      YYSIZE_T grecs_bind_n = 0;\n      char const *grecs_bind_p = grecs_bind_str;\n\n      for (;;)\n\tswitch (*++grecs_bind_p)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++grecs_bind_p != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (grecs_bind_res)\n\t      grecs_bind_res[grecs_bind_n] = *grecs_bind_p;\n\t    grecs_bind_n++;\n\t    break;\n\n\t  case '\"':\n\t    if (grecs_bind_res)\n\t      grecs_bind_res[grecs_bind_n] = '\\0';\n\t    return grecs_bind_n;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! grecs_bind_res)\n    return grecs_bind_strlen (grecs_bind_str);\n\n  return grecs_bind_stpcpy (grecs_bind_res, grecs_bind_str) - grecs_bind_res;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "grecs_bind_syntax_error": {
      "start_point": [
        1009,
        0
      ],
      "end_point": [
        1135,
        1
      ],
      "content": "static int\ngrecs_bind_syntax_error (YYSIZE_T *grecs_bind_msg_alloc, char **grecs_bind_msg,\n                grecs_bind_type_int16 *grecs_bind_ssp, int grecs_bind_token)\n{\n  YYSIZE_T grecs_bind_size0 = grecs_bind_tnamerr (YY_NULL, grecs_bind_tname[grecs_bind_token]);\n  YYSIZE_T grecs_bind_size = grecs_bind_size0;\n  YYSIZE_T grecs_bind_size1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *grecs_bind_format = YY_NULL;\n  /* Arguments of grecs_bind_format. */\n  char const *grecs_bind_arg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int grecs_bind_count = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in grecs_bind_char) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated grecs_bind_char.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (grecs_bind_token != YYEMPTY)\n    {\n      int grecs_bind_n = grecs_bind_pact[*grecs_bind_ssp];\n      grecs_bind_arg[grecs_bind_count++] = grecs_bind_tname[grecs_bind_token];\n      if (!grecs_bind_pact_value_is_default (grecs_bind_n))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int grecs_bind_xbegin = grecs_bind_n < 0 ? -grecs_bind_n : 0;\n          /* Stay within bounds of both grecs_bind_check and grecs_bind_tname.  */\n          int grecs_bind_checklim = YYLAST - grecs_bind_n + 1;\n          int grecs_bind_xend = grecs_bind_checklim < YYNTOKENS ? grecs_bind_checklim : YYNTOKENS;\n          int grecs_bind_x;\n\n          for (grecs_bind_x = grecs_bind_xbegin; grecs_bind_x < grecs_bind_xend; ++grecs_bind_x)\n            if (grecs_bind_check[grecs_bind_x + grecs_bind_n] == grecs_bind_x && grecs_bind_x != YYTERROR\n                && !grecs_bind_table_value_is_error (grecs_bind_table[grecs_bind_x + grecs_bind_n]))\n              {\n                if (grecs_bind_count == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    grecs_bind_count = 1;\n                    grecs_bind_size = grecs_bind_size0;\n                    break;\n                  }\n                grecs_bind_arg[grecs_bind_count++] = grecs_bind_tname[grecs_bind_x];\n                grecs_bind_size1 = grecs_bind_size + grecs_bind_tnamerr (YY_NULL, grecs_bind_tname[grecs_bind_x]);\n                if (! (grecs_bind_size <= grecs_bind_size1\n                       && grecs_bind_size1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                grecs_bind_size = grecs_bind_size1;\n              }\n        }\n    }\n\n  switch (grecs_bind_count)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        grecs_bind_format = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  grecs_bind_size1 = grecs_bind_size + grecs_bind_strlen (grecs_bind_format);\n  if (! (grecs_bind_size <= grecs_bind_size1 && grecs_bind_size1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  grecs_bind_size = grecs_bind_size1;\n\n  if (*grecs_bind_msg_alloc < grecs_bind_size)\n    {\n      *grecs_bind_msg_alloc = 2 * grecs_bind_size;\n      if (! (grecs_bind_size <= *grecs_bind_msg_alloc\n             && *grecs_bind_msg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *grecs_bind_msg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *grecs_bind_p = *grecs_bind_msg;\n    int grecs_bind_i = 0;\n    while ((*grecs_bind_p = *grecs_bind_format) != '\\0')\n      if (*grecs_bind_p == '%' && grecs_bind_format[1] == 's' && grecs_bind_i < grecs_bind_count)\n        {\n          grecs_bind_p += grecs_bind_tnamerr (grecs_bind_p, grecs_bind_arg[grecs_bind_i++]);\n          grecs_bind_format += 2;\n        }\n      else\n        {\n          grecs_bind_p++;\n          grecs_bind_format++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_bind_error": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1972,
        1
      ],
      "content": "int\ngrecs_bind_error(char const *s)\n{\n\tgrecs_error(&grecs_bind_lloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_parser": {
      "start_point": [
        1974,
        0
      ],
      "end_point": [
        1995,
        1
      ],
      "content": "struct grecs_node *\ngrecs_bind_parser(const char *name, int traceflags)\n{\n\tint rc;\n\n\tif (grecs_bind_new_source(name, NULL))\n\t\treturn NULL;\n\tgrecs_bind__flex_debug = traceflags & GRECS_TRACE_LEX;\n\tgrecs_bind_debug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = grecs_bind_parse();\n\tgrecs_bind_close_sources();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_bind_parser(const char *name, int traceflags)",
        "*"
      ]
    },
    "node_to_value": {
      "start_point": [
        1997,
        0
      ],
      "end_point": [
        2030,
        1
      ],
      "content": "static struct grecs_value *\nnode_to_value(struct grecs_node *node, struct grecs_txtacc *acc)\n{\n\tstruct grecs_value *val = grecs_malloc(sizeof(*val));\n\tint delim = 0;\n\t\n\tif (node->ident) {\n\t\tgrecs_txtacc_grow(acc, node->ident, strlen(node->ident));\n\t\tdelim = 1;\n\t}\n\t\n\tif (node->v.value) {\n\t\tif (delim)\n\t\t\tgrecs_txtacc_grow_char(acc, ' ');\n\t\tgrecs_txtacc_format_value(node->v.value, 0, acc);\n\t\tdelim = 1;\n\t}\n\tif (node->type == grecs_node_stmt) {\n\t\tval->type = GRECS_TYPE_STRING;\n\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\tval->v.string = grecs_txtacc_finish(acc, 1);\n\t} else if (node->down) {\n\t\tstruct grecs_list *list = grecs_value_list_create();\n\t\tstruct grecs_node *np;\n\n\t\tif (delim)\n\t\t\tgrecs_txtacc_grow_char(acc, ' ');\n\t\tfor (np = node->down; np; np = np->next)\n\t\t\tgrecs_list_append(list, node_to_value(np, acc));\n\t\tval->type = GRECS_TYPE_LIST;\n\t\tval->v.list = list;\n\t}\n\treturn val;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\nnode_to_value(struct grecs_node *node, struct grecs_txtacc *acc)",
        "*"
      ]
    },
    "stmtlist_to_value": {
      "start_point": [
        2032,
        0
      ],
      "end_point": [
        2045,
        1
      ],
      "content": "static struct grecs_value *\nstmtlist_to_value(struct grecs_node *node)\n{\n\tstruct grecs_txtacc *acc = grecs_txtacc_create();\n\tstruct grecs_value *val;\n\tstruct grecs_node parent;\n\n\tmemset(&parent, 0, sizeof(parent));\n\tparent.type = grecs_node_block;\n\tparent.down = node;\n\tval = node_to_value(&parent, acc);\n\tgrecs_txtacc_free(acc);\n\treturn val;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\nstmtlist_to_value(struct grecs_node *node)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/bind-gram.y": {
    "BIND_CONTROLS": {
      "start_point": [
        50,
        28
      ],
      "end_point": [
        65,
        4
      ],
      "content": "BIND_IDENT BIND_CONTROLS\n%type <string> string\n%type <svalue> value ctlsub\n%type <pvalue> vallist tag\n%type <list> vlist ctllist\n%type <node> stmt simple block maybe_stmtlist\n%type <node_list> stmtlist\n\n%%\n\ninput   : maybe_stmtlist\n          {\n\t\t  parse_tree = grecs_node_create(grecs_node_root, &@1);\n\t\t  parse_tree->v.texttab = grecs_text_table();\n\t\t  grecs_node_bind(parse_tree, $1, 1);\n\t  }",
      "lines": 16,
      "depth": 9,
      "decorators": null
    },
    "stmt": {
      "start_point": [
        83,
        10
      ],
      "end_point": [
        92,
        4
      ],
      "content": "stmtlist stmt\n\t  {\n\t\t  if ($2) {\n\t\t\t  if (!$1.head)\n\t\t\t\t  $1.head = $1.tail = $2;\n\t\t\t  else\n\t\t\t\t  grecs_node_bind($1.tail, $2, 0);\n\t\t  }\n\t\t  $$ = $1;\n\t  }",
      "lines": 10,
      "depth": 10,
      "decorators": null
    },
    "value": [
      {
        "start_point": [
          200,
          10
        ],
        "end_point": [
          203,
          4
        ],
        "content": "vlist value\n          {\n\t\t  grecs_list_append($1, grecs_value_ptr_from_static(&$2));\n\t  }",
        "lines": 4,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          231,
          10
        ],
        "end_point": [
          234,
          4
        ],
        "content": "ctllist value\n          {\n\t\t  grecs_list_append($1, grecs_value_ptr_from_static(&$2));\n\t  }",
        "lines": 4,
        "depth": 9,
        "decorators": null
      }
    ],
    "yyerror": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "int\nyyerror(char const *s)\n{\n\tgrecs_error(&yylloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_parser": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "struct grecs_node *\ngrecs_bind_parser(const char *name, int traceflags)\n{\n\tint rc;\n\n\tif (grecs_bind_new_source(name, NULL))\n\t\treturn NULL;\n\tyy_flex_debug = traceflags & GRECS_TRACE_LEX;\n\tyydebug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = yyparse();\n\tgrecs_bind_close_sources();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_bind_parser(const char *name, int traceflags)",
        "*"
      ]
    },
    "node_to_value": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "static struct grecs_value *\nnode_to_value(struct grecs_node *node, struct grecs_txtacc *acc)\n{\n\tstruct grecs_value *val = grecs_malloc(sizeof(*val));\n\tint delim = 0;\n\t\n\tif (node->ident) {\n\t\tgrecs_txtacc_grow(acc, node->ident, strlen(node->ident));\n\t\tdelim = 1;\n\t}\n\t\n\tif (node->v.value) {\n\t\tif (delim)\n\t\t\tgrecs_txtacc_grow_char(acc, ' ');\n\t\tgrecs_txtacc_format_value(node->v.value, 0, acc);\n\t\tdelim = 1;\n\t}\n\tif (node->type == grecs_node_stmt) {\n\t\tval->type = GRECS_TYPE_STRING;\n\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\tval->v.string = grecs_txtacc_finish(acc, 1);\n\t} else if (node->down) {\n\t\tstruct grecs_list *list = grecs_value_list_create();\n\t\tstruct grecs_node *np;\n\n\t\tif (delim)\n\t\t\tgrecs_txtacc_grow_char(acc, ' ');\n\t\tfor (np = node->down; np; np = np->next)\n\t\t\tgrecs_list_append(list, node_to_value(np, acc));\n\t\tval->type = GRECS_TYPE_LIST;\n\t\tval->v.list = list;\n\t}\n\treturn val;\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\nnode_to_value(struct grecs_node *node, struct grecs_txtacc *acc)",
        "*"
      ]
    },
    "stmtlist_to_value": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static struct grecs_value *\nstmtlist_to_value(struct grecs_node *node)\n{\n\tstruct grecs_txtacc *acc = grecs_txtacc_create();\n\tstruct grecs_value *val;\n\tstruct grecs_node parent;\n\n\tmemset(&parent, 0, sizeof(parent));\n\tparent.type = grecs_node_block;\n\tparent.down = node;\n\tval = node_to_value(&parent, acc);\n\tgrecs_txtacc_free(acc);\n\treturn val;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\nstmtlist_to_value(struct grecs_node *node)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/bind-lex.c": {
    "grecs_bind__get_next_buffer": {
      "start_point": [
        1384,
        0
      ],
      "end_point": [
        1517,
        1
      ],
      "content": "static int grecs_bind__get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf;\n\tregister char *source = (grecs_bind_text_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (grecs_bind__c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf[(grecs_bind__n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_bind__fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (grecs_bind__c_buf_p) - (grecs_bind_text_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((grecs_bind__c_buf_p) - (grecs_bind_text_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_bind__buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__n_chars = (grecs_bind__n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint grecs_bind__c_buf_p_offset =\n\t\t\t\t(int) ((grecs_bind__c_buf_p) - b->grecs_bind__ch_buf);\n\n\t\t\tif ( b->grecs_bind__is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->grecs_bind__buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->grecs_bind__buf_size += b->grecs_bind__buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->grecs_bind__buf_size *= 2;\n\n\t\t\t\tb->grecs_bind__ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tgrecs_bind_realloc((void *) b->grecs_bind__ch_buf,b->grecs_bind__buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->grecs_bind__ch_buf = 0;\n\n\t\t\tif ( ! b->grecs_bind__ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(grecs_bind__c_buf_p) = &b->grecs_bind__ch_buf[grecs_bind__c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf[number_to_move]),\n\t\t\t(grecs_bind__n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__n_chars = (grecs_bind__n_chars);\n\t\t}\n\n\tif ( (grecs_bind__n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tgrecs_bind_restart(grecs_bind_in  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((grecs_bind__size_t) ((grecs_bind__n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tgrecs_bind__size_t new_size = (grecs_bind__n_chars) + number_to_move + ((grecs_bind__n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf = (char *) grecs_bind_realloc((void *) YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind__get_next_buffer()\" );\n\t}\n\n\t(grecs_bind__n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf[(grecs_bind__n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf[(grecs_bind__n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(grecs_bind_text_ptr) = &YY_CURRENT_BUFFER_LVALUE->grecs_bind__ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_bind__get_previous_state": {
      "start_point": [
        1524,
        4
      ],
      "end_point": [
        1555,
        1
      ],
      "content": "static grecs_bind__state_type grecs_bind__get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister grecs_bind__state_type grecs_bind__current_state;\n\tregister char *grecs_bind__cp;\n    \n/* %% [15.0] code to get the start state into grecs_bind__current_state goes here */\n\tgrecs_bind__current_state = (grecs_bind__start);\n\tgrecs_bind__current_state += YY_AT_BOL();\n\n\tfor ( grecs_bind__cp = (grecs_bind_text_ptr) + YY_MORE_ADJ; grecs_bind__cp < (grecs_bind__c_buf_p); ++grecs_bind__cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR grecs_bind__c = (*grecs_bind__cp ? grecs_bind__ec[YY_SC_TO_UI(*grecs_bind__cp)] : 1);\n\t\tif ( grecs_bind__accept[grecs_bind__current_state] )\n\t\t\t{\n\t\t\t(grecs_bind__last_accepting_state) = grecs_bind__current_state;\n\t\t\t(grecs_bind__last_accepting_cpos) = grecs_bind__cp;\n\t\t\t}\n\t\twhile ( grecs_bind__chk[grecs_bind__base[grecs_bind__current_state] + grecs_bind__c] != grecs_bind__current_state )\n\t\t\t{\n\t\t\tgrecs_bind__current_state = (int) grecs_bind__def[grecs_bind__current_state];\n\t\t\tif ( grecs_bind__current_state >= 94 )\n\t\t\t\tgrecs_bind__c = grecs_bind__meta[(unsigned int) grecs_bind__c];\n\t\t\t}\n\t\tgrecs_bind__current_state = grecs_bind__nxt[grecs_bind__base[grecs_bind__current_state] + (unsigned int) grecs_bind__c];\n\t\t}\n\n\treturn grecs_bind__current_state;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "grecs_bind__state_type"
      ]
    },
    "grecs_bind__try_NUL_trans": {
      "start_point": [
        1563,
        4
      ],
      "end_point": [
        1588,
        1
      ],
      "content": "static grecs_bind__state_type grecs_bind__try_NUL_trans  (grecs_bind__state_type grecs_bind__current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int grecs_bind__is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *grecs_bind__cp = (grecs_bind__c_buf_p);\n\n\tregister YY_CHAR grecs_bind__c = 1;\n\tif ( grecs_bind__accept[grecs_bind__current_state] )\n\t\t{\n\t\t(grecs_bind__last_accepting_state) = grecs_bind__current_state;\n\t\t(grecs_bind__last_accepting_cpos) = grecs_bind__cp;\n\t\t}\n\twhile ( grecs_bind__chk[grecs_bind__base[grecs_bind__current_state] + grecs_bind__c] != grecs_bind__current_state )\n\t\t{\n\t\tgrecs_bind__current_state = (int) grecs_bind__def[grecs_bind__current_state];\n\t\tif ( grecs_bind__current_state >= 94 )\n\t\t\tgrecs_bind__c = grecs_bind__meta[(unsigned int) grecs_bind__c];\n\t\t}\n\tgrecs_bind__current_state = grecs_bind__nxt[grecs_bind__base[grecs_bind__current_state] + (unsigned int) grecs_bind__c];\n\tgrecs_bind__is_jam = (grecs_bind__current_state == 93);\n\n\treturn grecs_bind__is_jam ? 0 : grecs_bind__current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "grecs_bind__state_type"
      ]
    },
    "grecs_bind_restart": {
      "start_point": [
        1683,
        4
      ],
      "end_point": [
        1697,
        1
      ],
      "content": "void grecs_bind_restart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        grecs_bind_ensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            grecs_bind__create_buffer(grecs_bind_in,YY_BUF_SIZE );\n\t}\n\n\tgrecs_bind__init_buffer(YY_CURRENT_BUFFER,input_file );\n\tgrecs_bind__load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind__switch_to_buffer": {
      "start_point": [
        1704,
        4
      ],
      "end_point": [
        1736,
        1
      ],
      "content": "void grecs_bind__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tgrecs_bind_pop_buffer_state();\n\t *\t\tgrecs_bind_push_buffer_state(new_buffer);\n     */\n\tgrecs_bind_ensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_bind__c_buf_p) = (grecs_bind__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_pos = (grecs_bind__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__n_chars = (grecs_bind__n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tgrecs_bind__load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (grecs_bind_wrap()) processing, but the only time this flag\n\t * is looked at is after grecs_bind_wrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(grecs_bind__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind__load_buffer_state": {
      "start_point": [
        1739,
        0
      ],
      "end_point": [
        1748,
        1
      ],
      "content": "static void grecs_bind__load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(grecs_bind__n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_bind__n_chars;\n\t(grecs_bind_text_ptr) = (grecs_bind__c_buf_p) = YY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_pos;\n\tgrecs_bind_in = YY_CURRENT_BUFFER_LVALUE->grecs_bind__input_file;\n\t(grecs_bind__hold_char) = *(grecs_bind__c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_bind__create_buffer": {
      "start_point": [
        1757,
        4
      ],
      "end_point": [
        1782,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_bind__create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) grecs_bind_alloc(sizeof( struct grecs_bind__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind__create_buffer()\" );\n\n\tb->grecs_bind__buf_size = size;\n\n\t/* grecs_bind__ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->grecs_bind__ch_buf = (char *) grecs_bind_alloc(b->grecs_bind__buf_size + 2  );\n\tif ( ! b->grecs_bind__ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind__create_buffer()\" );\n\n\tb->grecs_bind__is_our_buffer = 1;\n\n\tgrecs_bind__init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_bind__delete_buffer": {
      "start_point": [
        1789,
        4
      ],
      "end_point": [
        1805,
        1
      ],
      "content": "void grecs_bind__delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->grecs_bind__is_our_buffer )\n\t\tgrecs_bind_free((void *) b->grecs_bind__ch_buf  );\n\n\tgrecs_bind_free((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind__init_buffer": {
      "start_point": [
        1823,
        4
      ],
      "end_point": [
        1853,
        1
      ],
      "content": "static void grecs_bind__init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tgrecs_bind__flush_buffer(b );\n\n\tb->grecs_bind__input_file = file;\n\tb->grecs_bind__fill_buffer = 1;\n\n    /* If b is the current buffer, then grecs_bind__init_buffer was _probably_\n     * called from grecs_bind_restart() or through grecs_bind__get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->grecs_bind__bs_lineno = 1;\n        b->grecs_bind__bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->grecs_bind__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_bind__flush_buffer": {
      "start_point": [
        1860,
        4
      ],
      "end_point": [
        1884,
        1
      ],
      "content": "void grecs_bind__flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->grecs_bind__n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->grecs_bind__ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->grecs_bind__ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->grecs_bind__buf_pos = &b->grecs_bind__ch_buf[0];\n\n\tb->grecs_bind__at_bol = 1;\n\tb->grecs_bind__buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tgrecs_bind__load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_push_buffer_state": {
      "start_point": [
        1894,
        0
      ],
      "end_point": [
        1921,
        1
      ],
      "content": "void grecs_bind_push_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tgrecs_bind_ensure_buffer_stack();\n\n\t/* This block is copied from grecs_bind__switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_bind__c_buf_p) = (grecs_bind__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__buf_pos = (grecs_bind__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_bind__n_chars = (grecs_bind__n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(grecs_bind__buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from grecs_bind__switch_to_buffer. */\n\tgrecs_bind__load_buffer_state( );\n\t(grecs_bind__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_pop_buffer_state": {
      "start_point": [
        1930,
        0
      ],
      "end_point": [
        1947,
        1
      ],
      "content": "void grecs_bind_pop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tgrecs_bind__delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((grecs_bind__buffer_stack_top) > 0)\n\t\t--(grecs_bind__buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tgrecs_bind__load_buffer_state( );\n\t\t(grecs_bind__did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_ensure_buffer_stack": {
      "start_point": [
        1955,
        0
      ],
      "end_point": [
        1999,
        1
      ],
      "content": "static void grecs_bind_ensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    \n\tif (!(grecs_bind__buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(grecs_bind__buffer_stack) = (struct grecs_bind__buffer_state**)grecs_bind_alloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct grecs_bind__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_bind__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind_ensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((grecs_bind__buffer_stack), 0, num_to_alloc * sizeof(struct grecs_bind__buffer_state*));\n\t\t\t\t\n\t\t(grecs_bind__buffer_stack_max) = num_to_alloc;\n\t\t(grecs_bind__buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((grecs_bind__buffer_stack_top) >= ((grecs_bind__buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (grecs_bind__buffer_stack_max) + grow_size;\n\t\t(grecs_bind__buffer_stack) = (struct grecs_bind__buffer_state**)grecs_bind_realloc\n\t\t\t\t\t\t\t\t((grecs_bind__buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct grecs_bind__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_bind__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind_ensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((grecs_bind__buffer_stack) + (grecs_bind__buffer_stack_max), 0, grow_size * sizeof(struct grecs_bind__buffer_state*));\n\t\t(grecs_bind__buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_bind__scan_buffer": {
      "start_point": [
        2009,
        0
      ],
      "end_point": [
        2036,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_bind__scan_buffer  (char * base, grecs_bind__size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) grecs_bind_alloc(sizeof( struct grecs_bind__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind__scan_buffer()\" );\n\n\tb->grecs_bind__buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->grecs_bind__buf_pos = b->grecs_bind__ch_buf = base;\n\tb->grecs_bind__is_our_buffer = 0;\n\tb->grecs_bind__input_file = 0;\n\tb->grecs_bind__n_chars = b->grecs_bind__buf_size;\n\tb->grecs_bind__is_interactive = 0;\n\tb->grecs_bind__at_bol = 1;\n\tb->grecs_bind__fill_buffer = 0;\n\tb->grecs_bind__buffer_status = YY_BUFFER_NEW;\n\n\tgrecs_bind__switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_bind__scan_string": {
      "start_point": [
        2048,
        0
      ],
      "end_point": [
        2052,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_bind__scan_string (grecs_bind_const char * grecs_bind_str )\n{\n    \n\treturn grecs_bind__scan_bytes(grecs_bind_str,strlen(grecs_bind_str) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_bind__scan_bytes": {
      "start_point": [
        2063,
        0
      ],
      "end_point": [
        2091,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_bind__scan_bytes  (grecs_bind_const char * grecs_bind_bytes, int  _grecs_bind_bytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tgrecs_bind__size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _grecs_bind_bytes_len + 2;\n\tbuf = (char *) grecs_bind_alloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_bind__scan_bytes()\" );\n\n\tfor ( i = 0; i < _grecs_bind_bytes_len; ++i )\n\t\tbuf[i] = grecs_bind_bytes[i];\n\n\tbuf[_grecs_bind_bytes_len] = buf[_grecs_bind_bytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = grecs_bind__scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in grecs_bind__scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->grecs_bind__is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_bind__fatal_error": {
      "start_point": [
        2099,
        0
      ],
      "end_point": [
        2103,
        1
      ],
      "content": "static void grecs_bind__fatal_error (grecs_bind_const char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_bind_get_lineno": {
      "start_point": [
        2134,
        0
      ],
      "end_point": [
        2138,
        1
      ],
      "content": "int grecs_bind_get_lineno  (void)\n{\n        \n    return grecs_bind_lineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_get_in": {
      "start_point": [
        2143,
        0
      ],
      "end_point": [
        2146,
        1
      ],
      "content": "FILE *grecs_bind_get_in  (void)\n{\n        return grecs_bind_in;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_bind_get_in  (void)",
        "*"
      ]
    },
    "grecs_bind_get_out": {
      "start_point": [
        2151,
        0
      ],
      "end_point": [
        2154,
        1
      ],
      "content": "FILE *grecs_bind_get_out  (void)\n{\n        return grecs_bind_out;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_bind_get_out  (void)",
        "*"
      ]
    },
    "grecs_bind_get_leng": {
      "start_point": [
        2159,
        0
      ],
      "end_point": [
        2162,
        1
      ],
      "content": "int grecs_bind_get_leng  (void)\n{\n        return grecs_bind_leng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_get_text": {
      "start_point": [
        2168,
        0
      ],
      "end_point": [
        2171,
        1
      ],
      "content": "char *grecs_bind_get_text  (void)\n{\n        return grecs_bind_text;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*grecs_bind_get_text  (void)",
        "*"
      ]
    },
    "grecs_bind_set_lineno": {
      "start_point": [
        2180,
        0
      ],
      "end_point": [
        2184,
        1
      ],
      "content": "void grecs_bind_set_lineno (int  line_number )\n{\n    \n    grecs_bind_lineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_set_in": {
      "start_point": [
        2192,
        0
      ],
      "end_point": [
        2195,
        1
      ],
      "content": "void grecs_bind_set_in (FILE *  in_str )\n{\n        grecs_bind_in = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_set_out": {
      "start_point": [
        2197,
        0
      ],
      "end_point": [
        2200,
        1
      ],
      "content": "void grecs_bind_set_out (FILE *  out_str )\n{\n        grecs_bind_out = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind_get_debug": {
      "start_point": [
        2202,
        0
      ],
      "end_point": [
        2205,
        1
      ],
      "content": "int grecs_bind_get_debug  (void)\n{\n        return grecs_bind__flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_set_debug": {
      "start_point": [
        2207,
        0
      ],
      "end_point": [
        2210,
        1
      ],
      "content": "void grecs_bind_set_debug (int  bdebug )\n{\n        grecs_bind__flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_bind__init_globals": {
      "start_point": [
        2220,
        0
      ],
      "end_point": [
        2246,
        1
      ],
      "content": "static int grecs_bind__init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from grecs_bind_lex_destroy(), so don't allocate here.\n     */\n\n    (grecs_bind__buffer_stack) = 0;\n    (grecs_bind__buffer_stack_top) = 0;\n    (grecs_bind__buffer_stack_max) = 0;\n    (grecs_bind__c_buf_p) = (char *) 0;\n    (grecs_bind__init) = 0;\n    (grecs_bind__start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    grecs_bind_in = stdin;\n    grecs_bind_out = stdout;\n#else\n    grecs_bind_in = (FILE *) 0;\n    grecs_bind_out = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * grecs_bind_lex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_bind_lex_destroy": {
      "start_point": [
        2251,
        0
      ],
      "end_point": [
        2272,
        1
      ],
      "content": "int grecs_bind_lex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tgrecs_bind__delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tgrecs_bind_pop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tgrecs_bind_free((grecs_bind__buffer_stack) );\n\t(grecs_bind__buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * grecs_bind_lex() is called, initialization will occur. */\n    grecs_bind__init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind__flex_strncpy": {
      "start_point": [
        2280,
        0
      ],
      "end_point": [
        2285,
        1
      ],
      "content": "static void grecs_bind__flex_strncpy (char* s1, grecs_bind_const char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_bind__flex_strlen": {
      "start_point": [
        2289,
        0
      ],
      "end_point": [
        2296,
        1
      ],
      "content": "static int grecs_bind__flex_strlen (grecs_bind_const char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_bind_alloc": {
      "start_point": [
        2299,
        0
      ],
      "end_point": [
        2302,
        1
      ],
      "content": "void *grecs_bind_alloc (grecs_bind__size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*grecs_bind_alloc (grecs_bind__size_t  size )",
        "*"
      ]
    },
    "grecs_bind_realloc": {
      "start_point": [
        2304,
        0
      ],
      "end_point": [
        2314,
        1
      ],
      "content": "void *grecs_bind_realloc  (void * ptr, grecs_bind__size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*grecs_bind_realloc  (void * ptr, grecs_bind__size_t  size )",
        "*"
      ]
    },
    "grecs_bind_free": {
      "start_point": [
        2316,
        0
      ],
      "end_point": [
        2319,
        1
      ],
      "content": "void grecs_bind_free (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see grecs_bind_realloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "free_context": {
      "start_point": [
        2345,
        0
      ],
      "end_point": [
        2349,
        1
      ],
      "content": "static void\nfree_context(void *ptr)\n{\n\tfree(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmp_context": {
      "start_point": [
        2351,
        0
      ],
      "end_point": [
        2358,
        1
      ],
      "content": "static int\ncmp_context(const void *a, const void *b)\n{\n\tstruct bind_input_context const *ac = a;\n\tstruct bind_input_context const *bc = b;\n\n\treturn !(ac->i_node == bc->i_node && ac->i_dev == bc->i_dev);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_push_context": {
      "start_point": [
        2360,
        0
      ],
      "end_point": [
        2394,
        1
      ],
      "content": "static int\n_push_context(const char *name, ino_t i_node, dev_t i_dev, grecs_locus_t *loc)\n{\n\tstruct bind_input_context ctx, *pctx;\n\t\n\tif (!input_stack) {\n\t\tinput_stack = grecs_list_create();\n\t\tinput_stack->free_entry = free_context;\n\t\tinput_stack->cmp = cmp_context;\n\t} else {\n\t\tctx.i_dev = i_dev;\n\t\tctx.i_node = i_node;\n\t\tpctx = grecs_list_locate(input_stack, &ctx);\n\t\tif (pctx) {\n\t\t\tgrecs_error(&grecs_bind_lloc, 0,\n\t\t\t\t    _(\"%s has already been included\"), name);\n\t\t\tgrecs_error(&pctx->locus, 0,\n\t\t\t    _(\"this is where the previous inclusion occurred\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tpctx = grecs_malloc(sizeof(*pctx));\n\t\tpctx->i_node = i_node;\n\t\tpctx->i_dev = i_dev;\n                if (loc)\n                        pctx->locus = *loc;\n                else\n                        memset(&pctx->locus, 0, sizeof(pctx->locus)); /* FIXME */\n\t\tpctx->point = grecs_current_locus_point;\n\t\tpctx->state = YY_CURRENT_BUFFER;\n\t\tpctx->input = grecs_bind_in;\n\t\tgrecs_list_push(input_stack, pctx);\n\t}\n\treturn 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pop_context": {
      "start_point": [
        2396,
        0
      ],
      "end_point": [
        2420,
        1
      ],
      "content": "static int\n_pop_context()\n{\n\tstruct bind_input_context *pctx;\n\n\tif (!grecs_bind_in)\n\t\treturn 1;\n        if (grecs_preprocessor)\n                pclose(grecs_bind_in);\n        else\n\t        fclose(grecs_bind_in);\n\tpctx = grecs_list_pop(input_stack);\n\tif (!pctx) {\n\t\tgrecs_bind_in = NULL;\n\t\treturn 1;\n\t}\n\ti_node = pctx->i_node;\n\ti_dev = pctx->i_dev;\n\tgrecs_current_locus_point = pctx->point;\n\tgrecs_bind_in = pctx->input;\n\tgrecs_bind__delete_buffer(YY_CURRENT_BUFFER);\n\tgrecs_bind__switch_to_buffer(pctx->state);\n\tgrecs_free(pctx);\n\treturn 0;\n}",
      "lines": 25,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_bind_wrap": {
      "start_point": [
        2422,
        0
      ],
      "end_point": [
        2426,
        1
      ],
      "content": "int\ngrecs_bind_wrap()\n{\n\treturn _pop_context();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_new_source": {
      "start_point": [
        2428,
        0
      ],
      "end_point": [
        2484,
        1
      ],
      "content": "int\ngrecs_bind_new_source(const char *name, grecs_locus_t *loc)\n{\n\tstruct stat st;\n\tFILE *fp;\n\t\n\tif (access(name, F_OK)) {\n\t\tint ec = errno;\n\t\tchar *tmp = grecs_find_include_file(name, 0);\n\t\tif (!tmp) {\n\t\t\tgrecs_error(loc, ec, _(\"cannot open `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\t\tname = grecs_install_text(tmp);\n\t\tfree(tmp);\n\t}\n\t\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(loc, errno, _(\"cannot open `%s'\"), name);\n\t\treturn 1;\n \t}\n\tif (fstat(fileno(fp), &st)) {\n\t\tgrecs_error(loc, errno, _(\"can't state %s\"), name);\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n        if (grecs_preprocessor) {\n                char *cmd = NULL;\n                size_t size = 0;\n\n\t\tfclose(fp);\n                if (grecs_asprintf(&cmd, &size, \"%s \\\"%s\\\"\",\n                                   grecs_preprocessor, name))\n                        grecs_alloc_die();\n              \n                fp = popen(cmd, \"r\");\n                if (!fp) {\n\t\t        grecs_error(loc, errno, _(\"cannot open `%s'\"), cmd);\n                        grecs_free(cmd);\n                        return 1;\n                }\n                grecs_free(cmd);\n        }\n\n\tif (_push_context(name, st.st_ino, st.st_dev, loc)) {\n\t\treturn 1;\n\t}\n\ti_node = st.st_ino;\n\ti_dev = st.st_dev;\n\tgrecs_bind_in = fp;\n\tgrecs_bind__switch_to_buffer(grecs_bind__create_buffer(grecs_bind_in,YY_BUF_SIZE));\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\treturn 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_close_sources": {
      "start_point": [
        2486,
        0
      ],
      "end_point": [
        2493,
        1
      ],
      "content": "void\ngrecs_bind_close_sources()\n{\n\twhile (!_pop_context())\n\t\t;\n\tgrecs_list_free(input_stack);\n\tinput_stack = NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/bind-lex.l": {
    "noinput": {
      "start_point": [
        1,
        1
      ],
      "end_point": [
        7,
        1
      ],
      "content": "option noinput\n%option nounput\n%top {\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n}",
      "lines": 7,
      "depth": 5,
      "decorators": null
    },
    "free_context": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void\nfree_context(void *ptr)\n{\n\tfree(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmp_context": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static int\ncmp_context(const void *a, const void *b)\n{\n\tstruct bind_input_context const *ac = a;\n\tstruct bind_input_context const *bc = b;\n\n\treturn !(ac->i_node == bc->i_node && ac->i_dev == bc->i_dev);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_push_context": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "static int\n_push_context(const char *name, ino_t i_node, dev_t i_dev, grecs_locus_t *loc)\n{\n\tstruct bind_input_context ctx, *pctx;\n\t\n\tif (!input_stack) {\n\t\tinput_stack = grecs_list_create();\n\t\tinput_stack->free_entry = free_context;\n\t\tinput_stack->cmp = cmp_context;\n\t} else {\n\t\tctx.i_dev = i_dev;\n\t\tctx.i_node = i_node;\n\t\tpctx = grecs_list_locate(input_stack, &ctx);\n\t\tif (pctx) {\n\t\t\tgrecs_error(&yylloc, 0,\n\t\t\t\t    _(\"%s has already been included\"), name);\n\t\t\tgrecs_error(&pctx->locus, 0,\n\t\t\t    _(\"this is where the previous inclusion occurred\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tpctx = grecs_malloc(sizeof(*pctx));\n\t\tpctx->i_node = i_node;\n\t\tpctx->i_dev = i_dev;\n                if (loc)\n                        pctx->locus = *loc;\n                else\n                        memset(&pctx->locus, 0, sizeof(pctx->locus)); /* FIXME */\n\t\tpctx->point = grecs_current_locus_point;\n\t\tpctx->state = YY_CURRENT_BUFFER;\n\t\tpctx->input = yyin;\n\t\tgrecs_list_push(input_stack, pctx);\n\t}\n\treturn 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pop_context": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static int\n_pop_context()\n{\n\tstruct bind_input_context *pctx;\n\n\tif (!yyin)\n\t\treturn 1;\n        if (grecs_preprocessor)\n                pclose(yyin);\n        else\n\t        fclose(yyin);\n\tpctx = grecs_list_pop(input_stack);\n\tif (!pctx) {\n\t\tyyin = NULL;\n\t\treturn 1;\n\t}\n\ti_node = pctx->i_node;\n\ti_dev = pctx->i_dev;\n\tgrecs_current_locus_point = pctx->point;\n\tyyin = pctx->input;\n\tyy_delete_buffer(YY_CURRENT_BUFFER);\n\tyy_switch_to_buffer(pctx->state);\n\tgrecs_free(pctx);\n\treturn 0;\n}",
      "lines": 25,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yywrap": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\nyywrap()\n{\n\treturn _pop_context();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_new_source": {
      "start_point": [
        218,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int\ngrecs_bind_new_source(const char *name, grecs_locus_t *loc)\n{\n\tstruct stat st;\n\tFILE *fp;\n\t\n\tif (access(name, F_OK)) {\n\t\tint ec = errno;\n\t\tchar *tmp = grecs_find_include_file(name, 0);\n\t\tif (!tmp) {\n\t\t\tgrecs_error(loc, ec, _(\"cannot open `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\t\tname = grecs_install_text(tmp);\n\t\tfree(tmp);\n\t}\n\t\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(loc, errno, _(\"cannot open `%s'\"), name);\n\t\treturn 1;\n \t}\n\tif (fstat(fileno(fp), &st)) {\n\t\tgrecs_error(loc, errno, _(\"can't state %s\"), name);\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n        if (grecs_preprocessor) {\n                char *cmd = NULL;\n                size_t size = 0;\n\n\t\tfclose(fp);\n                if (grecs_asprintf(&cmd, &size, \"%s \\\"%s\\\"\",\n                                   grecs_preprocessor, name))\n                        grecs_alloc_die();\n              \n                fp = popen(cmd, \"r\");\n                if (!fp) {\n\t\t        grecs_error(loc, errno, _(\"cannot open `%s'\"), cmd);\n                        grecs_free(cmd);\n                        return 1;\n                }\n                grecs_free(cmd);\n        }\n\n\tif (_push_context(name, st.st_ino, st.st_dev, loc)) {\n\t\treturn 1;\n\t}\n\ti_node = st.st_ino;\n\ti_dev = st.st_dev;\n\tyyin = fp;\n\tyy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\treturn 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_bind_close_sources": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "void\ngrecs_bind_close_sources()\n{\n\twhile (!_pop_context())\n\t\t;\n\tgrecs_list_free(input_stack);\n\tinput_stack = NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/cidr.c": {
    "uint32_to_bytes": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\nuint32_to_bytes (unsigned char *bytes, uint32_t u)\n{\n\tint i;\n\n\tfor (i = 0; i < 4; i++)\t{\n\t\tbytes[i] = u & 0xff;\n\t\tu >>= 8;\n\t}\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_inaddr_to_bytes": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "int\ngrecs_inaddr_to_bytes(int af, void *buf, unsigned char *bytes)\n{\n\tuint32_t u;\n\n\tswitch (af) {\n\tcase AF_INET:\n\t\tmemcpy(&u, buf, sizeof u);\n\t\tuint32_to_bytes(bytes, u);\n\t\treturn 4;\n\n\tcase AF_INET6:\n\t\tmemcpy(bytes, buf, 16);\n\t\treturn 16;\n\t}\n\treturn 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "grecs_sockaddr_to_bytes": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\ngrecs_sockaddr_to_bytes(unsigned char *bytes, struct sockaddr const *sa)\n{\n\tswitch (sa->sa_family) {\n\tcase AF_INET:\n\t\tuint32_to_bytes(bytes,\n\t\t\t\t((struct sockaddr_in*)sa)->sin_addr.s_addr);\n\t\treturn 4;\n\n\tcase AF_INET6:\n\t\tmemcpy(bytes, &((struct sockaddr_in6*)sa)->sin6_addr, 16);\n\t\treturn 16;\n\t}\n\treturn 0;\n}",
      "lines": 15,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "grecs_sockaddr_to_cidr": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "int\ngrecs_sockaddr_to_cidr(struct grecs_cidr *cidr, const struct sockaddr *sa)\n{\n\tunsigned char address[GRECS_INADDR_BYTES];\n\tint len;\n\tint i;\n\n\tlen = grecs_sockaddr_to_bytes(address, sa);\n\tif (len == 0)\n\t\treturn -1;\n\tcidr->family = sa->sa_family;\n\tcidr->len = len;\n\tmemcpy(cidr->address, address, sizeof(cidr->address));\n\tfor (i = 0; i < GRECS_INADDR_BYTES; i++)\n\t\tcidr->netmask[i] = 0xff;\n\treturn 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "masklen_to_netmask": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "static void\nmasklen_to_netmask(unsigned char *buf, size_t len, size_t masklen)\n{\n\tint i, cnt;\n\n\tcnt = masklen / 8;\n\tfor (i = 0; i < cnt; i++)\n\t\tbuf[i] = 0xff;\n\tif (i == GRECS_INADDR_BYTES)\n\t\treturn;\n\tcnt = 8 - masklen % 8;\n\tbuf[i++] = (0xff >> cnt) << cnt;\n\tfor (; i < GRECS_INADDR_BYTES; i++)\n\t\tbuf[i] = 0;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_str_to_cidr": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "int\ngrecs_str_to_cidr(struct grecs_cidr *pcidr, const char *str,\n\t\t  grecs_locus_t const *locus)\n{\n\tint rc;\n\tchar ipbuf[41];\n\tstruct grecs_cidr cidr;\n\tchar *p;\n\tsize_t len;\n\tunion {\n\t\tstruct in_addr in;\n\t\tstruct in6_addr in6;\n\t} inaddr;\n  \n\tp = strchr(str, '/');\n\tif (p)\n\t\tlen = p - str;\n\telse\n\t\tlen = strlen(str);\n\n\tif (len > sizeof(ipbuf)) {\n\t\tgrecs_error(locus, 0, _(\"invalid network mask: %s\"),\n\t\t\t    str);\n\t\treturn -1;\n\t}\n  \n\tmemcpy(ipbuf, str, len);\n\tipbuf[len] = 0;\n\n\tif (grecs_str_is_ipv4(ipbuf))\n\t\tcidr.family = AF_INET;\n\telse if (grecs_str_is_ipv6(ipbuf))\n\t\tcidr.family = AF_INET6;\n\telse {\n\t\tgrecs_error(locus, 0, _(\"unrecognized address family: %s\"),\n\t\t\t    str);\n\t\treturn -1;\n\t}\n\t\n\trc = inet_pton(cidr.family, ipbuf, &inaddr);\n\tif (rc == -1) {\n\t\tgrecs_error(locus, 0, _(\"unrecognized address family: %s\"),\n\t\t\t    str);\n\t\treturn -1;\n\t} else if (rc != 1) {\n\t\tgrecs_error(locus, 0, _(\"invalid network address: %s\"),\n\t\t\t    str);\n\t\treturn -1;\n\t}\n\n\tcidr.len = grecs_inaddr_to_bytes(cidr.family, &inaddr, cidr.address);\n\tif (cidr.len == 0) {\n\t\tgrecs_error(locus, 0, _(\"unrecognized address family: %s\"),\n\t\t\t    str);\n\t\treturn -1;\n\t}\n\n\tif (p) {\n\t\tchar *end;\n\t\tunsigned long masklen;\n      \n\t\tp++;\n\n\t\tmasklen = strtoul(p, &end, 10);\n\t\tif (*end == 0)\n\t\t\tmasklen_to_netmask(cidr.netmask, cidr.len, masklen);\n\t\telse if ((cidr.family == AF_INET && grecs_str_is_ipv4(p))\n\t\t\t || (cidr.family == AF_INET6\n\t\t\t     && grecs_str_is_ipv6(ipbuf))) {\n\t\t\trc = inet_pton(cidr.family, p, &inaddr);\n\t\t\tif (rc != 1) {\n\t\t\t\tgrecs_error(locus, 0, _(\"invalid network mask: %s\"),\n\t\t\t\t\t    str);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tgrecs_inaddr_to_bytes(cidr.family, &inaddr,\n\t\t\t\t\t      cidr.netmask);\n\t\t} else {\n\t\t\tgrecs_error(locus, 0, _(\"invalid network mask: %s\"),\n\t\t\t\t    str);\n\t\t\treturn -1;\n\t\t}\n\t} else\n\t\tmasklen_to_netmask(cidr.netmask, cidr.len, cidr.len * 8);\n\n\tmemcpy(pcidr, &cidr, sizeof(*pcidr));\n\treturn 0;\n}",
      "lines": 88,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "grecs_cidr_match": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "int\ngrecs_cidr_match(struct grecs_cidr *a, struct grecs_cidr *b)\n{\n\tint i;\n\n\tif (a->family != b->family)\n\t\treturn 1;\n\tfor (i = 0; i < a->len; i++) {\n\t\tif (a->address[i] != (b->address[i] & a->netmask[i]))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "grecs_sockadd_cidr_match": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "int\ngrecs_sockadd_cidr_match(struct sockaddr *sa, struct grecs_cidr *cidr)\n{\n\tstruct grecs_cidr t;\n\tif (grecs_sockaddr_to_cidr(&t, sa))\n\t\treturn 1;\n\treturn grecs_cidr_match(cidr, &t);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/dhcpd-gram.c": {
    "make_string_value": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static grecs_value_t *\nmake_string_value(char *string)\n{\n\tgrecs_value_t *val;\n\tval = grecs_malloc(sizeof(val[0]));\n\tval->type = GRECS_TYPE_STRING;\n\tval->v.string = string;\n\treturn val;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "grecs_value_t",
        "*\nmake_string_value(char *string)",
        "*"
      ]
    },
    "grecs_dhcpdtnamerr": {
      "start_point": [
        997,
        0
      ],
      "end_point": [
        1034,
        1
      ],
      "content": "static YYSIZE_T\ngrecs_dhcpdtnamerr (char *grecs_dhcpdres, const char *grecs_dhcpdstr)\n{\n  if (*grecs_dhcpdstr == '\"')\n    {\n      YYSIZE_T grecs_dhcpdn = 0;\n      char const *grecs_dhcpdp = grecs_dhcpdstr;\n\n      for (;;)\n\tswitch (*++grecs_dhcpdp)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++grecs_dhcpdp != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (grecs_dhcpdres)\n\t      grecs_dhcpdres[grecs_dhcpdn] = *grecs_dhcpdp;\n\t    grecs_dhcpdn++;\n\t    break;\n\n\t  case '\"':\n\t    if (grecs_dhcpdres)\n\t      grecs_dhcpdres[grecs_dhcpdn] = '\\0';\n\t    return grecs_dhcpdn;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! grecs_dhcpdres)\n    return grecs_dhcpdstrlen (grecs_dhcpdstr);\n\n  return grecs_dhcpdstpcpy (grecs_dhcpdres, grecs_dhcpdstr) - grecs_dhcpdres;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "grecs_dhcpdsyntax_error": {
      "start_point": [
        1045,
        0
      ],
      "end_point": [
        1171,
        1
      ],
      "content": "static int\ngrecs_dhcpdsyntax_error (YYSIZE_T *grecs_dhcpdmsg_alloc, char **grecs_dhcpdmsg,\n                grecs_dhcpdtype_int16 *grecs_dhcpdssp, int grecs_dhcpdtoken)\n{\n  YYSIZE_T grecs_dhcpdsize0 = grecs_dhcpdtnamerr (YY_NULL, grecs_dhcpdtname[grecs_dhcpdtoken]);\n  YYSIZE_T grecs_dhcpdsize = grecs_dhcpdsize0;\n  YYSIZE_T grecs_dhcpdsize1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *grecs_dhcpdformat = YY_NULL;\n  /* Arguments of grecs_dhcpdformat. */\n  char const *grecs_dhcpdarg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int grecs_dhcpdcount = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in grecs_dhcpdchar) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated grecs_dhcpdchar.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (grecs_dhcpdtoken != YYEMPTY)\n    {\n      int grecs_dhcpdn = grecs_dhcpdpact[*grecs_dhcpdssp];\n      grecs_dhcpdarg[grecs_dhcpdcount++] = grecs_dhcpdtname[grecs_dhcpdtoken];\n      if (!grecs_dhcpdpact_value_is_default (grecs_dhcpdn))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int grecs_dhcpdxbegin = grecs_dhcpdn < 0 ? -grecs_dhcpdn : 0;\n          /* Stay within bounds of both grecs_dhcpdcheck and grecs_dhcpdtname.  */\n          int grecs_dhcpdchecklim = YYLAST - grecs_dhcpdn + 1;\n          int grecs_dhcpdxend = grecs_dhcpdchecklim < YYNTOKENS ? grecs_dhcpdchecklim : YYNTOKENS;\n          int grecs_dhcpdx;\n\n          for (grecs_dhcpdx = grecs_dhcpdxbegin; grecs_dhcpdx < grecs_dhcpdxend; ++grecs_dhcpdx)\n            if (grecs_dhcpdcheck[grecs_dhcpdx + grecs_dhcpdn] == grecs_dhcpdx && grecs_dhcpdx != YYTERROR\n                && !grecs_dhcpdtable_value_is_error (grecs_dhcpdtable[grecs_dhcpdx + grecs_dhcpdn]))\n              {\n                if (grecs_dhcpdcount == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    grecs_dhcpdcount = 1;\n                    grecs_dhcpdsize = grecs_dhcpdsize0;\n                    break;\n                  }\n                grecs_dhcpdarg[grecs_dhcpdcount++] = grecs_dhcpdtname[grecs_dhcpdx];\n                grecs_dhcpdsize1 = grecs_dhcpdsize + grecs_dhcpdtnamerr (YY_NULL, grecs_dhcpdtname[grecs_dhcpdx]);\n                if (! (grecs_dhcpdsize <= grecs_dhcpdsize1\n                       && grecs_dhcpdsize1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                grecs_dhcpdsize = grecs_dhcpdsize1;\n              }\n        }\n    }\n\n  switch (grecs_dhcpdcount)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        grecs_dhcpdformat = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  grecs_dhcpdsize1 = grecs_dhcpdsize + grecs_dhcpdstrlen (grecs_dhcpdformat);\n  if (! (grecs_dhcpdsize <= grecs_dhcpdsize1 && grecs_dhcpdsize1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  grecs_dhcpdsize = grecs_dhcpdsize1;\n\n  if (*grecs_dhcpdmsg_alloc < grecs_dhcpdsize)\n    {\n      *grecs_dhcpdmsg_alloc = 2 * grecs_dhcpdsize;\n      if (! (grecs_dhcpdsize <= *grecs_dhcpdmsg_alloc\n             && *grecs_dhcpdmsg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *grecs_dhcpdmsg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *grecs_dhcpdp = *grecs_dhcpdmsg;\n    int grecs_dhcpdi = 0;\n    while ((*grecs_dhcpdp = *grecs_dhcpdformat) != '\\0')\n      if (*grecs_dhcpdp == '%' && grecs_dhcpdformat[1] == 's' && grecs_dhcpdi < grecs_dhcpdcount)\n        {\n          grecs_dhcpdp += grecs_dhcpdtnamerr (grecs_dhcpdp, grecs_dhcpdarg[grecs_dhcpdi++]);\n          grecs_dhcpdformat += 2;\n        }\n      else\n        {\n          grecs_dhcpdp++;\n          grecs_dhcpdformat++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_dhcpderror": {
      "start_point": [
        2120,
        0
      ],
      "end_point": [
        2125,
        1
      ],
      "content": "int\ngrecs_dhcpderror(char const *s)\n{\n\tgrecs_error(&grecs_dhcpdlloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_parser": {
      "start_point": [
        2127,
        0
      ],
      "end_point": [
        2148,
        1
      ],
      "content": "struct grecs_node *\ngrecs_dhcpd_parser(const char *name, int traceflags)\n{\n\tint rc;\n\n\tif (grecs_dhcpd_new_source(name, NULL))\n\t\treturn NULL;\n\tgrecs_dhcpd_flex_debug = traceflags & GRECS_TRACE_LEX;\n\tgrecs_dhcpddebug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = grecs_dhcpdparse();\n\tgrecs_dhcpd_close_sources();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_dhcpd_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/dhcpd-gram.y": {
    "make_string_value": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static grecs_value_t *\nmake_string_value(char *string)\n{\n\tgrecs_value_t *val;\n\tval = grecs_malloc(sizeof(val[0]));\n\tval->type = GRECS_TYPE_STRING;\n\tval->v.string = string;\n\treturn val;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "grecs_value_t",
        "*\nmake_string_value(char *string)",
        "*"
      ]
    },
    "DHCPD_EXPR": {
      "start_point": [
        63,
        25
      ],
      "end_point": [
        81,
        4
      ],
      "content": "DHCPD_ELSIF DHCPD_EXPR\n%token DHCPD_ELSE \n%token <string> DHCPD_STRING DHCPD_IDENT \n%type <string> string\n%type <svalue> value \n%type <pvalue> vallist tag\n%type <list> vlist strlist\n%type <node> stmt simple block maybe_stmtlist\n%type <node> cond elsecond opt_elsecond elsifcond\n%type <node_list> stmtlist elsifchain opt_elsifchain\n\n%%\n\ninput   : maybe_stmtlist\n          {\n\t\t  parse_tree = grecs_node_create(grecs_node_root, &@1);\n\t\t  parse_tree->v.texttab = grecs_text_table();\n\t\t  grecs_node_bind(parse_tree, $1, 1);\n\t  }",
      "lines": 19,
      "depth": 9,
      "decorators": null
    },
    "stmt": {
      "start_point": [
        99,
        10
      ],
      "end_point": [
        108,
        4
      ],
      "content": "stmtlist stmt\n\t  {\n\t\t  if ($2) {\n\t\t\t  if (!$1.head)\n\t\t\t\t  $1.head = $1.tail = $2;\n\t\t\t  else\n\t\t\t\t  grecs_node_bind($1.tail, $2, 0);\n\t\t  }\n\t\t  $$ = $1;\n\t  }",
      "lines": 10,
      "depth": 10,
      "decorators": null
    },
    "value": {
      "start_point": [
        198,
        10
      ],
      "end_point": [
        201,
        4
      ],
      "content": "vlist value\n          {\n\t\t  grecs_list_append($1, grecs_value_ptr_from_static(&$2));\n\t  }",
      "lines": 4,
      "depth": 9,
      "decorators": null
    },
    "opt_elsecond": {
      "start_point": [
        249,
        47
      ],
      "end_point": [
        267,
        4
      ],
      "content": "opt_elsifchain opt_elsecond\n          {\n\t\t  $$ = grecs_node_create_points(grecs_node_block,\n\t\t\t\t\t\t@1.beg, @7.end);\n\t\t  \n\t\t  grecs_line_begin();\n\t\t  grecs_line_add(\"if\", 2);\n\n\t\t  $$->ident = grecs_line_finish();\n\t\t  $$->idloc = @1;\n\t\t  \n\t\t  $$->v.value = make_string_value ($2);\n\t\t  grecs_node_bind($$, $4, 1);\n\n\t\t  if ($6.head) {\n\t\t\t  grecs_node_bind($6.tail, $7, 0);\n\t\t\t  grecs_node_bind($$, $6.head, 0);\n\t\t  }\n\t  }",
      "lines": 19,
      "depth": 8,
      "decorators": null
    },
    "elsifcond": {
      "start_point": [
        293,
        10
      ],
      "end_point": [
        302,
        4
      ],
      "content": "elsifchain elsifcond\n\t  {\n\t\t  if ($2) {\n\t\t\t  if (!$1.head)\n\t\t\t\t  $1.head = $1.tail = $2;\n\t\t\t  else\n\t\t\t\t  grecs_node_bind($1.tail, $2, 0);\n\t\t  }\n\t\t  $$ = $1;\n\t  }",
      "lines": 10,
      "depth": 10,
      "decorators": null
    },
    "yyerror": {
      "start_point": [
        344,
        0
      ],
      "end_point": [
        349,
        1
      ],
      "content": "int\nyyerror(char const *s)\n{\n\tgrecs_error(&yylloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_parser": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "struct grecs_node *\ngrecs_dhcpd_parser(const char *name, int traceflags)\n{\n\tint rc;\n\n\tif (grecs_dhcpd_new_source(name, NULL))\n\t\treturn NULL;\n\tyy_flex_debug = traceflags & GRECS_TRACE_LEX;\n\tyydebug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = yyparse();\n\tgrecs_dhcpd_close_sources();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_dhcpd_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/dhcpd-lex.c": {
    "grecs_dhcpd_get_next_buffer": {
      "start_point": [
        1447,
        0
      ],
      "end_point": [
        1580,
        1
      ],
      "content": "static int grecs_dhcpd_get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf;\n\tregister char *source = (grecs_dhcpdtext_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (grecs_dhcpd_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[(grecs_dhcpd_n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (grecs_dhcpd_c_buf_p) - (grecs_dhcpdtext_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((grecs_dhcpd_c_buf_p) - (grecs_dhcpdtext_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars = (grecs_dhcpd_n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint grecs_dhcpd_c_buf_p_offset =\n\t\t\t\t(int) ((grecs_dhcpd_c_buf_p) - b->grecs_dhcpd_ch_buf);\n\n\t\t\tif ( b->grecs_dhcpd_is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->grecs_dhcpd_buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->grecs_dhcpd_buf_size += b->grecs_dhcpd_buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->grecs_dhcpd_buf_size *= 2;\n\n\t\t\t\tb->grecs_dhcpd_ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tgrecs_dhcpdrealloc((void *) b->grecs_dhcpd_ch_buf,b->grecs_dhcpd_buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->grecs_dhcpd_ch_buf = 0;\n\n\t\t\tif ( ! b->grecs_dhcpd_ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(grecs_dhcpd_c_buf_p) = &b->grecs_dhcpd_ch_buf[grecs_dhcpd_c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[number_to_move]),\n\t\t\t(grecs_dhcpd_n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars = (grecs_dhcpd_n_chars);\n\t\t}\n\n\tif ( (grecs_dhcpd_n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tgrecs_dhcpdrestart(grecs_dhcpdin  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((grecs_dhcpd_size_t) ((grecs_dhcpd_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tgrecs_dhcpd_size_t new_size = (grecs_dhcpd_n_chars) + number_to_move + ((grecs_dhcpd_n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf = (char *) grecs_dhcpdrealloc((void *) YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpd_get_next_buffer()\" );\n\t}\n\n\t(grecs_dhcpd_n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[(grecs_dhcpd_n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[(grecs_dhcpd_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(grecs_dhcpdtext_ptr) = &YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_dhcpd_get_previous_state": {
      "start_point": [
        1587,
        4
      ],
      "end_point": [
        1618,
        1
      ],
      "content": "static grecs_dhcpd_state_type grecs_dhcpd_get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister grecs_dhcpd_state_type grecs_dhcpd_current_state;\n\tregister char *grecs_dhcpd_cp;\n    \n/* %% [15.0] code to get the start state into grecs_dhcpd_current_state goes here */\n\tgrecs_dhcpd_current_state = (grecs_dhcpd_start);\n\tgrecs_dhcpd_current_state += YY_AT_BOL();\n\n\tfor ( grecs_dhcpd_cp = (grecs_dhcpdtext_ptr) + YY_MORE_ADJ; grecs_dhcpd_cp < (grecs_dhcpd_c_buf_p); ++grecs_dhcpd_cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR grecs_dhcpd_c = (*grecs_dhcpd_cp ? grecs_dhcpd_ec[YY_SC_TO_UI(*grecs_dhcpd_cp)] : 1);\n\t\tif ( grecs_dhcpd_accept[grecs_dhcpd_current_state] )\n\t\t\t{\n\t\t\t(grecs_dhcpd_last_accepting_state) = grecs_dhcpd_current_state;\n\t\t\t(grecs_dhcpd_last_accepting_cpos) = grecs_dhcpd_cp;\n\t\t\t}\n\t\twhile ( grecs_dhcpd_chk[grecs_dhcpd_base[grecs_dhcpd_current_state] + grecs_dhcpd_c] != grecs_dhcpd_current_state )\n\t\t\t{\n\t\t\tgrecs_dhcpd_current_state = (int) grecs_dhcpd_def[grecs_dhcpd_current_state];\n\t\t\tif ( grecs_dhcpd_current_state >= 111 )\n\t\t\t\tgrecs_dhcpd_c = grecs_dhcpd_meta[(unsigned int) grecs_dhcpd_c];\n\t\t\t}\n\t\tgrecs_dhcpd_current_state = grecs_dhcpd_nxt[grecs_dhcpd_base[grecs_dhcpd_current_state] + (unsigned int) grecs_dhcpd_c];\n\t\t}\n\n\treturn grecs_dhcpd_current_state;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "grecs_dhcpd_state_type"
      ]
    },
    "grecs_dhcpd_try_NUL_trans": {
      "start_point": [
        1626,
        4
      ],
      "end_point": [
        1651,
        1
      ],
      "content": "static grecs_dhcpd_state_type grecs_dhcpd_try_NUL_trans  (grecs_dhcpd_state_type grecs_dhcpd_current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int grecs_dhcpd_is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *grecs_dhcpd_cp = (grecs_dhcpd_c_buf_p);\n\n\tregister YY_CHAR grecs_dhcpd_c = 1;\n\tif ( grecs_dhcpd_accept[grecs_dhcpd_current_state] )\n\t\t{\n\t\t(grecs_dhcpd_last_accepting_state) = grecs_dhcpd_current_state;\n\t\t(grecs_dhcpd_last_accepting_cpos) = grecs_dhcpd_cp;\n\t\t}\n\twhile ( grecs_dhcpd_chk[grecs_dhcpd_base[grecs_dhcpd_current_state] + grecs_dhcpd_c] != grecs_dhcpd_current_state )\n\t\t{\n\t\tgrecs_dhcpd_current_state = (int) grecs_dhcpd_def[grecs_dhcpd_current_state];\n\t\tif ( grecs_dhcpd_current_state >= 111 )\n\t\t\tgrecs_dhcpd_c = grecs_dhcpd_meta[(unsigned int) grecs_dhcpd_c];\n\t\t}\n\tgrecs_dhcpd_current_state = grecs_dhcpd_nxt[grecs_dhcpd_base[grecs_dhcpd_current_state] + (unsigned int) grecs_dhcpd_c];\n\tgrecs_dhcpd_is_jam = (grecs_dhcpd_current_state == 110);\n\n\treturn grecs_dhcpd_is_jam ? 0 : grecs_dhcpd_current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "grecs_dhcpd_state_type"
      ]
    },
    "grecs_dhcpdunput": {
      "start_point": [
        1655,
        4
      ],
      "end_point": [
        1695,
        1
      ],
      "content": "static void grecs_dhcpdunput (int c, register char * grecs_dhcpd_bp )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister char *grecs_dhcpd_cp;\n    \n    grecs_dhcpd_cp = (grecs_dhcpd_c_buf_p);\n\n\t/* undo effects of setting up grecs_dhcpdtext */\n\t*grecs_dhcpd_cp = (grecs_dhcpd_hold_char);\n\n\tif ( grecs_dhcpd_cp < YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf + 2 )\n\t\t{ /* need to shift things up to make room */\n\t\t/* +2 for EOB chars. */\n\t\tregister int number_to_move = (grecs_dhcpd_n_chars) + 2;\n\t\tregister char *dest = &YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[\n\t\t\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_size + 2];\n\t\tregister char *source =\n\t\t\t\t&YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf[number_to_move];\n\n\t\twhile ( source > YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf )\n\t\t\t*--dest = *--source;\n\n\t\tgrecs_dhcpd_cp += (int) (dest - source);\n\t\tgrecs_dhcpd_bp += (int) (dest - source);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars =\n\t\t\t(grecs_dhcpd_n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_size;\n\n\t\tif ( grecs_dhcpd_cp < YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_ch_buf + 2 )\n\t\t\tYY_FATAL_ERROR( \"flex scanner push-back overflow\" );\n\t\t}\n\n\t*--grecs_dhcpd_cp = (char) c;\n\n/* %% [18.0] update grecs_dhcpdlineno here */\n\n\t(grecs_dhcpdtext_ptr) = grecs_dhcpd_bp;\n\t(grecs_dhcpd_hold_char) = *grecs_dhcpd_cp;\n\t(grecs_dhcpd_c_buf_p) = grecs_dhcpd_cp;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpdrestart": {
      "start_point": [
        1789,
        4
      ],
      "end_point": [
        1803,
        1
      ],
      "content": "void grecs_dhcpdrestart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        grecs_dhcpdensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            grecs_dhcpd_create_buffer(grecs_dhcpdin,YY_BUF_SIZE );\n\t}\n\n\tgrecs_dhcpd_init_buffer(YY_CURRENT_BUFFER,input_file );\n\tgrecs_dhcpd_load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_switch_to_buffer": {
      "start_point": [
        1810,
        4
      ],
      "end_point": [
        1842,
        1
      ],
      "content": "void grecs_dhcpd_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tgrecs_dhcpdpop_buffer_state();\n\t *\t\tgrecs_dhcpdpush_buffer_state(new_buffer);\n     */\n\tgrecs_dhcpdensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_dhcpd_c_buf_p) = (grecs_dhcpd_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_pos = (grecs_dhcpd_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars = (grecs_dhcpd_n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tgrecs_dhcpd_load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (grecs_dhcpdwrap()) processing, but the only time this flag\n\t * is looked at is after grecs_dhcpdwrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(grecs_dhcpd_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_load_buffer_state": {
      "start_point": [
        1845,
        0
      ],
      "end_point": [
        1854,
        1
      ],
      "content": "static void grecs_dhcpd_load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(grecs_dhcpd_n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars;\n\t(grecs_dhcpdtext_ptr) = (grecs_dhcpd_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_pos;\n\tgrecs_dhcpdin = YY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_input_file;\n\t(grecs_dhcpd_hold_char) = *(grecs_dhcpd_c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpd_create_buffer": {
      "start_point": [
        1863,
        4
      ],
      "end_point": [
        1888,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_dhcpd_create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) grecs_dhcpdalloc(sizeof( struct grecs_dhcpd_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpd_create_buffer()\" );\n\n\tb->grecs_dhcpd_buf_size = size;\n\n\t/* grecs_dhcpd_ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->grecs_dhcpd_ch_buf = (char *) grecs_dhcpdalloc(b->grecs_dhcpd_buf_size + 2  );\n\tif ( ! b->grecs_dhcpd_ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpd_create_buffer()\" );\n\n\tb->grecs_dhcpd_is_our_buffer = 1;\n\n\tgrecs_dhcpd_init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_dhcpd_delete_buffer": {
      "start_point": [
        1895,
        4
      ],
      "end_point": [
        1911,
        1
      ],
      "content": "void grecs_dhcpd_delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->grecs_dhcpd_is_our_buffer )\n\t\tgrecs_dhcpdfree((void *) b->grecs_dhcpd_ch_buf  );\n\n\tgrecs_dhcpdfree((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_init_buffer": {
      "start_point": [
        1929,
        4
      ],
      "end_point": [
        1959,
        1
      ],
      "content": "static void grecs_dhcpd_init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tgrecs_dhcpd_flush_buffer(b );\n\n\tb->grecs_dhcpd_input_file = file;\n\tb->grecs_dhcpd_fill_buffer = 1;\n\n    /* If b is the current buffer, then grecs_dhcpd_init_buffer was _probably_\n     * called from grecs_dhcpdrestart() or through grecs_dhcpd_get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->grecs_dhcpd_bs_lineno = 1;\n        b->grecs_dhcpd_bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->grecs_dhcpd_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpd_flush_buffer": {
      "start_point": [
        1966,
        4
      ],
      "end_point": [
        1990,
        1
      ],
      "content": "void grecs_dhcpd_flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->grecs_dhcpd_n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->grecs_dhcpd_ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->grecs_dhcpd_ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->grecs_dhcpd_buf_pos = &b->grecs_dhcpd_ch_buf[0];\n\n\tb->grecs_dhcpd_at_bol = 1;\n\tb->grecs_dhcpd_buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tgrecs_dhcpd_load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdpush_buffer_state": {
      "start_point": [
        2000,
        0
      ],
      "end_point": [
        2027,
        1
      ],
      "content": "void grecs_dhcpdpush_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tgrecs_dhcpdensure_buffer_stack();\n\n\t/* This block is copied from grecs_dhcpd_switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_dhcpd_c_buf_p) = (grecs_dhcpd_hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_buf_pos = (grecs_dhcpd_c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_dhcpd_n_chars = (grecs_dhcpd_n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(grecs_dhcpd_buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from grecs_dhcpd_switch_to_buffer. */\n\tgrecs_dhcpd_load_buffer_state( );\n\t(grecs_dhcpd_did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdpop_buffer_state": {
      "start_point": [
        2036,
        0
      ],
      "end_point": [
        2053,
        1
      ],
      "content": "void grecs_dhcpdpop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tgrecs_dhcpd_delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((grecs_dhcpd_buffer_stack_top) > 0)\n\t\t--(grecs_dhcpd_buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tgrecs_dhcpd_load_buffer_state( );\n\t\t(grecs_dhcpd_did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdensure_buffer_stack": {
      "start_point": [
        2061,
        0
      ],
      "end_point": [
        2105,
        1
      ],
      "content": "static void grecs_dhcpdensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    \n\tif (!(grecs_dhcpd_buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(grecs_dhcpd_buffer_stack) = (struct grecs_dhcpd_buffer_state**)grecs_dhcpdalloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct grecs_dhcpd_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_dhcpd_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpdensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((grecs_dhcpd_buffer_stack), 0, num_to_alloc * sizeof(struct grecs_dhcpd_buffer_state*));\n\t\t\t\t\n\t\t(grecs_dhcpd_buffer_stack_max) = num_to_alloc;\n\t\t(grecs_dhcpd_buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((grecs_dhcpd_buffer_stack_top) >= ((grecs_dhcpd_buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (grecs_dhcpd_buffer_stack_max) + grow_size;\n\t\t(grecs_dhcpd_buffer_stack) = (struct grecs_dhcpd_buffer_state**)grecs_dhcpdrealloc\n\t\t\t\t\t\t\t\t((grecs_dhcpd_buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct grecs_dhcpd_buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_dhcpd_buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpdensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((grecs_dhcpd_buffer_stack) + (grecs_dhcpd_buffer_stack_max), 0, grow_size * sizeof(struct grecs_dhcpd_buffer_state*));\n\t\t(grecs_dhcpd_buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpd_scan_buffer": {
      "start_point": [
        2115,
        0
      ],
      "end_point": [
        2142,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_dhcpd_scan_buffer  (char * base, grecs_dhcpd_size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) grecs_dhcpdalloc(sizeof( struct grecs_dhcpd_buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpd_scan_buffer()\" );\n\n\tb->grecs_dhcpd_buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->grecs_dhcpd_buf_pos = b->grecs_dhcpd_ch_buf = base;\n\tb->grecs_dhcpd_is_our_buffer = 0;\n\tb->grecs_dhcpd_input_file = 0;\n\tb->grecs_dhcpd_n_chars = b->grecs_dhcpd_buf_size;\n\tb->grecs_dhcpd_is_interactive = 0;\n\tb->grecs_dhcpd_at_bol = 1;\n\tb->grecs_dhcpd_fill_buffer = 0;\n\tb->grecs_dhcpd_buffer_status = YY_BUFFER_NEW;\n\n\tgrecs_dhcpd_switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_dhcpd_scan_string": {
      "start_point": [
        2154,
        0
      ],
      "end_point": [
        2158,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_dhcpd_scan_string (grecs_dhcpdconst char * grecs_dhcpdstr )\n{\n    \n\treturn grecs_dhcpd_scan_bytes(grecs_dhcpdstr,strlen(grecs_dhcpdstr) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_dhcpd_scan_bytes": {
      "start_point": [
        2169,
        0
      ],
      "end_point": [
        2197,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_dhcpd_scan_bytes  (grecs_dhcpdconst char * grecs_dhcpdbytes, int  _grecs_dhcpdbytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tgrecs_dhcpd_size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _grecs_dhcpdbytes_len + 2;\n\tbuf = (char *) grecs_dhcpdalloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_dhcpd_scan_bytes()\" );\n\n\tfor ( i = 0; i < _grecs_dhcpdbytes_len; ++i )\n\t\tbuf[i] = grecs_dhcpdbytes[i];\n\n\tbuf[_grecs_dhcpdbytes_len] = buf[_grecs_dhcpdbytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = grecs_dhcpd_scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in grecs_dhcpd_scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->grecs_dhcpd_is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_dhcpd_fatal_error": {
      "start_point": [
        2205,
        0
      ],
      "end_point": [
        2209,
        1
      ],
      "content": "static void grecs_dhcpd_fatal_error (grecs_dhcpdconst char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpdget_lineno": {
      "start_point": [
        2240,
        0
      ],
      "end_point": [
        2244,
        1
      ],
      "content": "int grecs_dhcpdget_lineno  (void)\n{\n        \n    return grecs_dhcpdlineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpdget_in": {
      "start_point": [
        2249,
        0
      ],
      "end_point": [
        2252,
        1
      ],
      "content": "FILE *grecs_dhcpdget_in  (void)\n{\n        return grecs_dhcpdin;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_dhcpdget_in  (void)",
        "*"
      ]
    },
    "grecs_dhcpdget_out": {
      "start_point": [
        2257,
        0
      ],
      "end_point": [
        2260,
        1
      ],
      "content": "FILE *grecs_dhcpdget_out  (void)\n{\n        return grecs_dhcpdout;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_dhcpdget_out  (void)",
        "*"
      ]
    },
    "grecs_dhcpdget_leng": {
      "start_point": [
        2265,
        0
      ],
      "end_point": [
        2268,
        1
      ],
      "content": "int grecs_dhcpdget_leng  (void)\n{\n        return grecs_dhcpdleng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpdget_text": {
      "start_point": [
        2274,
        0
      ],
      "end_point": [
        2277,
        1
      ],
      "content": "char *grecs_dhcpdget_text  (void)\n{\n        return grecs_dhcpdtext;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*grecs_dhcpdget_text  (void)",
        "*"
      ]
    },
    "grecs_dhcpdset_lineno": {
      "start_point": [
        2286,
        0
      ],
      "end_point": [
        2290,
        1
      ],
      "content": "void grecs_dhcpdset_lineno (int  line_number )\n{\n    \n    grecs_dhcpdlineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdset_in": {
      "start_point": [
        2298,
        0
      ],
      "end_point": [
        2301,
        1
      ],
      "content": "void grecs_dhcpdset_in (FILE *  in_str )\n{\n        grecs_dhcpdin = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdset_out": {
      "start_point": [
        2303,
        0
      ],
      "end_point": [
        2306,
        1
      ],
      "content": "void grecs_dhcpdset_out (FILE *  out_str )\n{\n        grecs_dhcpdout = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpdget_debug": {
      "start_point": [
        2308,
        0
      ],
      "end_point": [
        2311,
        1
      ],
      "content": "int grecs_dhcpdget_debug  (void)\n{\n        return grecs_dhcpd_flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpdset_debug": {
      "start_point": [
        2313,
        0
      ],
      "end_point": [
        2316,
        1
      ],
      "content": "void grecs_dhcpdset_debug (int  bdebug )\n{\n        grecs_dhcpd_flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_init_globals": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "static int grecs_dhcpd_init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from grecs_dhcpdlex_destroy(), so don't allocate here.\n     */\n\n    (grecs_dhcpd_buffer_stack) = 0;\n    (grecs_dhcpd_buffer_stack_top) = 0;\n    (grecs_dhcpd_buffer_stack_max) = 0;\n    (grecs_dhcpd_c_buf_p) = (char *) 0;\n    (grecs_dhcpd_init) = 0;\n    (grecs_dhcpd_start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    grecs_dhcpdin = stdin;\n    grecs_dhcpdout = stdout;\n#else\n    grecs_dhcpdin = (FILE *) 0;\n    grecs_dhcpdout = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * grecs_dhcpdlex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_dhcpdlex_destroy": {
      "start_point": [
        2357,
        0
      ],
      "end_point": [
        2378,
        1
      ],
      "content": "int grecs_dhcpdlex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tgrecs_dhcpd_delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tgrecs_dhcpdpop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tgrecs_dhcpdfree((grecs_dhcpd_buffer_stack) );\n\t(grecs_dhcpd_buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * grecs_dhcpdlex() is called, initialization will occur. */\n    grecs_dhcpd_init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_flex_strncpy": {
      "start_point": [
        2386,
        0
      ],
      "end_point": [
        2391,
        1
      ],
      "content": "static void grecs_dhcpd_flex_strncpy (char* s1, grecs_dhcpdconst char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_dhcpd_flex_strlen": {
      "start_point": [
        2395,
        0
      ],
      "end_point": [
        2402,
        1
      ],
      "content": "static int grecs_dhcpd_flex_strlen (grecs_dhcpdconst char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_dhcpdalloc": {
      "start_point": [
        2405,
        0
      ],
      "end_point": [
        2408,
        1
      ],
      "content": "void *grecs_dhcpdalloc (grecs_dhcpd_size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*grecs_dhcpdalloc (grecs_dhcpd_size_t  size )",
        "*"
      ]
    },
    "grecs_dhcpdrealloc": {
      "start_point": [
        2410,
        0
      ],
      "end_point": [
        2420,
        1
      ],
      "content": "void *grecs_dhcpdrealloc  (void * ptr, grecs_dhcpd_size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*grecs_dhcpdrealloc  (void * ptr, grecs_dhcpd_size_t  size )",
        "*"
      ]
    },
    "grecs_dhcpdfree": {
      "start_point": [
        2422,
        0
      ],
      "end_point": [
        2425,
        1
      ],
      "content": "void grecs_dhcpdfree (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see grecs_dhcpdrealloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_begin_bool": {
      "start_point": [
        2438,
        0
      ],
      "end_point": [
        2442,
        1
      ],
      "content": "void\ngrecs_dhcpd_begin_bool(void)\n{\n        BEGIN(BOOL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_begin_expr": {
      "start_point": [
        2444,
        0
      ],
      "end_point": [
        2448,
        1
      ],
      "content": "void\ngrecs_dhcpd_begin_expr(void)\n{\n        BEGIN(EXPR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "free_context": {
      "start_point": [
        2463,
        0
      ],
      "end_point": [
        2467,
        1
      ],
      "content": "static void\nfree_context(void *ptr)\n{\n\tfree(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmp_context": {
      "start_point": [
        2469,
        0
      ],
      "end_point": [
        2476,
        1
      ],
      "content": "static int\ncmp_context(const void *a, const void *b)\n{\n\tstruct dhcpd_input_context const *ac = a;\n\tstruct dhcpd_input_context const *bc = b;\n\n\treturn !(ac->i_node == bc->i_node && ac->i_dev == bc->i_dev);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_push_context": {
      "start_point": [
        2478,
        0
      ],
      "end_point": [
        2512,
        1
      ],
      "content": "static int\n_push_context(const char *name, ino_t i_node, dev_t i_dev, grecs_locus_t *loc)\n{\n\tstruct dhcpd_input_context ctx, *pctx;\n\t\n\tif (!input_stack) {\n\t\tinput_stack = grecs_list_create();\n\t\tinput_stack->free_entry = free_context;\n\t\tinput_stack->cmp = cmp_context;\n\t} else {\n\t\tctx.i_dev = i_dev;\n\t\tctx.i_node = i_node;\n\t\tpctx = grecs_list_locate(input_stack, &ctx);\n\t\tif (pctx) {\n\t\t\tgrecs_error(&grecs_dhcpdlloc, 0,\n\t\t\t\t    _(\"%s has already been included\"), name);\n\t\t\tgrecs_error(&pctx->locus, 0,\n\t\t\t    _(\"this is where the previous inclusion occurred\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tpctx = grecs_malloc(sizeof(*pctx));\n\t\tpctx->i_node = i_node;\n\t\tpctx->i_dev = i_dev;\n                if (loc)\n                        pctx->locus = *loc;\n                else\n                        memset(&pctx->locus, 0, sizeof(pctx->locus)); /* FIXME */\n\t\tpctx->point = grecs_current_locus_point;\n\t\tpctx->state = YY_CURRENT_BUFFER;\n\t\tpctx->input = grecs_dhcpdin;\n\t\tgrecs_list_push(input_stack, pctx);\n\t}\n\treturn 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pop_context": {
      "start_point": [
        2514,
        0
      ],
      "end_point": [
        2538,
        1
      ],
      "content": "static int\n_pop_context()\n{\n\tstruct dhcpd_input_context *pctx;\n\n\tif (!grecs_dhcpdin)\n\t\treturn 1;\n        if (grecs_preprocessor)\n                pclose(grecs_dhcpdin);\n        else\n\t        fclose(grecs_dhcpdin);\n\tpctx = grecs_list_pop(input_stack);\n\tif (!pctx) {\n\t\tgrecs_dhcpdin = NULL;\n\t\treturn 1;\n\t}\n\ti_node = pctx->i_node;\n\ti_dev = pctx->i_dev;\n\tgrecs_current_locus_point = pctx->point;\n\tgrecs_dhcpdin = pctx->input;\n\tgrecs_dhcpd_delete_buffer(YY_CURRENT_BUFFER);\n\tgrecs_dhcpd_switch_to_buffer(pctx->state);\n\tgrecs_free(pctx);\n\treturn 0;\n}",
      "lines": 25,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_dhcpdwrap": {
      "start_point": [
        2540,
        0
      ],
      "end_point": [
        2544,
        1
      ],
      "content": "int\ngrecs_dhcpdwrap()\n{\n\treturn _pop_context();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_new_source": {
      "start_point": [
        2546,
        0
      ],
      "end_point": [
        2602,
        1
      ],
      "content": "int\ngrecs_dhcpd_new_source(const char *name, grecs_locus_t *loc)\n{\n\tstruct stat st;\n\tFILE *fp;\n\t\n\tif (access(name, F_OK)) {\n\t\tint ec = errno;\n\t\tchar *tmp = grecs_find_include_file(name, 0);\n\t\tif (!tmp) {\n\t\t\tgrecs_error(loc, ec, _(\"cannot open `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\t\tname = grecs_install_text(tmp);\n\t\tfree(tmp);\n\t}\n\t\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(loc, errno, _(\"cannot open `%s'\"), name);\n\t\treturn 1;\n \t}\n\tif (fstat(fileno(fp), &st)) {\n\t\tgrecs_error(loc, errno, _(\"can't state %s\"), name);\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n        if (grecs_preprocessor) {\n                char *cmd = NULL;\n                size_t size = 0;\n\n\t\tfclose(fp);\n                if (grecs_asprintf(&cmd, &size, \"%s \\\"%s\\\"\",\n                                   grecs_preprocessor, name))\n                        grecs_alloc_die();\n              \n                fp = popen(cmd, \"r\");\n                if (!fp) {\n\t\t        grecs_error(loc, errno, _(\"cannot open `%s'\"), cmd);\n                        grecs_free(cmd);\n                        return 1;\n                }\n                grecs_free(cmd);\n        }\n\n\tif (_push_context(name, st.st_ino, st.st_dev, loc)) {\n\t\treturn 1;\n\t}\n\ti_node = st.st_ino;\n\ti_dev = st.st_dev;\n\tgrecs_dhcpdin = fp;\n\tgrecs_dhcpd_switch_to_buffer(grecs_dhcpd_create_buffer(grecs_dhcpdin,YY_BUF_SIZE));\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\treturn 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_close_sources": {
      "start_point": [
        2604,
        0
      ],
      "end_point": [
        2611,
        1
      ],
      "content": "void\ngrecs_dhcpd_close_sources()\n{\n\twhile (!_pop_context())\n\t\t;\n\tgrecs_list_free(input_stack);\n\tinput_stack = NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/dhcpd-lex.l": {
    "noinput": {
      "start_point": [
        1,
        1
      ],
      "end_point": [
        6,
        1
      ],
      "content": "option noinput\n%top {\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n}",
      "lines": 6,
      "depth": 5,
      "decorators": null
    },
    "grecs_dhcpd_begin_bool": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "void\ngrecs_dhcpd_begin_bool(void)\n{\n        BEGIN(BOOL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_dhcpd_begin_expr": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\ngrecs_dhcpd_begin_expr(void)\n{\n        BEGIN(EXPR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "free_context": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void\nfree_context(void *ptr)\n{\n\tfree(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cmp_context": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static int\ncmp_context(const void *a, const void *b)\n{\n\tstruct dhcpd_input_context const *ac = a;\n\tstruct dhcpd_input_context const *bc = b;\n\n\treturn !(ac->i_node == bc->i_node && ac->i_dev == bc->i_dev);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_push_context": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "static int\n_push_context(const char *name, ino_t i_node, dev_t i_dev, grecs_locus_t *loc)\n{\n\tstruct dhcpd_input_context ctx, *pctx;\n\t\n\tif (!input_stack) {\n\t\tinput_stack = grecs_list_create();\n\t\tinput_stack->free_entry = free_context;\n\t\tinput_stack->cmp = cmp_context;\n\t} else {\n\t\tctx.i_dev = i_dev;\n\t\tctx.i_node = i_node;\n\t\tpctx = grecs_list_locate(input_stack, &ctx);\n\t\tif (pctx) {\n\t\t\tgrecs_error(&yylloc, 0,\n\t\t\t\t    _(\"%s has already been included\"), name);\n\t\t\tgrecs_error(&pctx->locus, 0,\n\t\t\t    _(\"this is where the previous inclusion occurred\"));\n\t\t\treturn 1;\n\t\t}\n\n\t\tpctx = grecs_malloc(sizeof(*pctx));\n\t\tpctx->i_node = i_node;\n\t\tpctx->i_dev = i_dev;\n                if (loc)\n                        pctx->locus = *loc;\n                else\n                        memset(&pctx->locus, 0, sizeof(pctx->locus)); /* FIXME */\n\t\tpctx->point = grecs_current_locus_point;\n\t\tpctx->state = YY_CURRENT_BUFFER;\n\t\tpctx->input = yyin;\n\t\tgrecs_list_push(input_stack, pctx);\n\t}\n\treturn 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_pop_context": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "static int\n_pop_context()\n{\n\tstruct dhcpd_input_context *pctx;\n\n\tif (!yyin)\n\t\treturn 1;\n        if (grecs_preprocessor)\n                pclose(yyin);\n        else\n\t        fclose(yyin);\n\tpctx = grecs_list_pop(input_stack);\n\tif (!pctx) {\n\t\tyyin = NULL;\n\t\treturn 1;\n\t}\n\ti_node = pctx->i_node;\n\ti_dev = pctx->i_dev;\n\tgrecs_current_locus_point = pctx->point;\n\tyyin = pctx->input;\n\tyy_delete_buffer(YY_CURRENT_BUFFER);\n\tyy_switch_to_buffer(pctx->state);\n\tgrecs_free(pctx);\n\treturn 0;\n}",
      "lines": 25,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "yywrap": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nyywrap()\n{\n\treturn _pop_context();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_new_source": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        336,
        1
      ],
      "content": "int\ngrecs_dhcpd_new_source(const char *name, grecs_locus_t *loc)\n{\n\tstruct stat st;\n\tFILE *fp;\n\t\n\tif (access(name, F_OK)) {\n\t\tint ec = errno;\n\t\tchar *tmp = grecs_find_include_file(name, 0);\n\t\tif (!tmp) {\n\t\t\tgrecs_error(loc, ec, _(\"cannot open `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\t\tname = grecs_install_text(tmp);\n\t\tfree(tmp);\n\t}\n\t\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(loc, errno, _(\"cannot open `%s'\"), name);\n\t\treturn 1;\n \t}\n\tif (fstat(fileno(fp), &st)) {\n\t\tgrecs_error(loc, errno, _(\"can't state %s\"), name);\n\t\tfclose(fp);\n\t\treturn 1;\n\t}\n        if (grecs_preprocessor) {\n                char *cmd = NULL;\n                size_t size = 0;\n\n\t\tfclose(fp);\n                if (grecs_asprintf(&cmd, &size, \"%s \\\"%s\\\"\",\n                                   grecs_preprocessor, name))\n                        grecs_alloc_die();\n              \n                fp = popen(cmd, \"r\");\n                if (!fp) {\n\t\t        grecs_error(loc, errno, _(\"cannot open `%s'\"), cmd);\n                        grecs_free(cmd);\n                        return 1;\n                }\n                grecs_free(cmd);\n        }\n\n\tif (_push_context(name, st.st_ino, st.st_dev, loc)) {\n\t\treturn 1;\n\t}\n\ti_node = st.st_ino;\n\ti_dev = st.st_dev;\n\tyyin = fp;\n\tyy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE));\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\treturn 0;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_dhcpd_close_sources": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void\ngrecs_dhcpd_close_sources()\n{\n\twhile (!_pop_context())\n\t\t;\n\tgrecs_list_free(input_stack);\n\tinput_stack = NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/diag.c": {
    "default_print_diag": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "static void\ndefault_print_diag(grecs_locus_t const *locus, int err, int errcode,\n\t\t   const char *msg)\n{\n\tfflush(stdout);\n\tif (locus) {\n\t\tYY_LOCATION_PRINT(stderr, *locus);\n\t\tfputc(':', stderr);\n\t\tfputc(' ', stderr);\n\t}\n\tif (!err)\n\t\tfprintf(stderr, \"warning: \");\n\tfprintf(stderr, \"%s\", msg);\n\tif (errcode)\n\t\tfprintf(stderr, \": %s\", strerror(errno));\n\tfputc('\\n', stderr);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_warning": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ngrecs_warning(grecs_locus_t const *locus, int errcode, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *buf = NULL;\n\tsize_t size = 0;\n\t\n\tva_start(ap, fmt);\n\tif (grecs_vasprintf(&buf, &size, fmt, ap))\n\t\tgrecs_alloc_die();\n\tva_end(ap);\n\tgrecs_print_diag_fun(locus, 0, errcode, buf);\n\tfree(buf);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_error": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ngrecs_error(grecs_locus_t const *locus, int errcode, const char *fmt, ...)\n{\n\tva_list ap;\n\tchar *buf = NULL;\n\tsize_t size = 0;\n\t\n\tva_start(ap, fmt);\n\tif (grecs_vasprintf(&buf, &size, fmt, ap))\n\t\tgrecs_alloc_die();\n\tva_end(ap);\n\tgrecs_print_diag_fun(locus, 1, errcode, buf);\n\tfree(buf);\n\tgrecs_error_count++;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_asprint_locus": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "int\ngrecs_asprint_locus(char **locstr, size_t *size, grecs_locus_t const *locus)\n{\n\tint rc;\n\t\n\tif (locus->beg.col == 0)\n\t\trc = grecs_asprintf(locstr, size, \"%s:%u\",\n\t\t\t\t    locus->beg.file,\n\t\t\t\t    locus->beg.line);\n\telse if (strcmp(locus->beg.file, locus->end.file))\n\t\trc = grecs_asprintf(locstr, size, \"%s:%u.%u-%s:%u.%u\",\n\t\t\t\t    locus->beg.file,\n\t\t\t\t    locus->beg.line, locus->beg.col,\n\t\t\t\t    locus->end.file,\n\t\t\t\t    locus->end.line, locus->end.col);\n\telse if (locus->beg.line != locus->end.line)\n\t\trc = grecs_asprintf(locstr, size, \"%s:%u.%u-%u.%u\",\n\t\t\t\t    locus->beg.file,\n\t\t\t\t    locus->beg.line, locus->beg.col,\n\t\t\t\t    locus->end.line, locus->end.col);\n\telse\n\t\trc = grecs_asprintf(locstr, size, \"%s:%u.%u-%u\",\n\t\t\t\t    locus->beg.file,\n\t\t\t\t    locus->beg.line, locus->beg.col,\n\t\t\t\t    locus->end.col);\n\treturn rc;\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/format.c": {
    "grecs_data_type_string": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "const char *\ngrecs_data_type_string(enum grecs_data_type type)\n{\n\tswitch (type) {\n\tcase grecs_type_void:\n\t\treturn \"void\";\n\n\tcase grecs_type_string:\n\t\treturn \"string\";\n\n\tcase grecs_type_short:\n\tcase grecs_type_ushort:\n\tcase grecs_type_int:\n\tcase grecs_type_uint:\n\tcase grecs_type_long:\n\tcase grecs_type_ulong:\n\tcase grecs_type_size:\n\t\t/*FIXME case  grecs_type_off:*/\n\t\treturn \"number\";\n\n\tcase grecs_type_time:\n\t\treturn \"time\";\n\n\tcase grecs_type_bool:\n\t\treturn \"boolean\";\n\n\tcase grecs_type_ipv4:\n\t\treturn \"IPv4\";\n\n\tcase grecs_type_cidr:\n\t\treturn \"CIDR\";\n\n\tcase grecs_type_host:\n\t\treturn \"hostname\";\n\n\tcase grecs_type_sockaddr:\n\t\treturn \"sockaddr\";\n\n\tcase grecs_type_section:\n\t\treturn \"section\";\n\n\tcase grecs_type_null:\n\t\treturn \"null\";\n\t}\n\treturn \"UNKNOWN?\";\n}",
      "lines": 46,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngrecs_data_type_string(enum grecs_data_type type)",
        "*"
      ]
    },
    "format_level": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static void\nformat_level(unsigned level, FILE *stream)\n{\n\twhile (level--)\n\t\tfprintf(stream, \"  \");\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_print_docstring": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ngrecs_print_docstring(const char *docstring, unsigned level, FILE *stream)\n{\n\tsize_t len = strlen(docstring);\n\tint width = 78 - level * 2;\n\n\tif (width < 0) {\n\t\twidth = 78;\n\t\tlevel = 0;\n\t}\n\n\twhile (len) {\n\t\tsize_t seglen;\n\t\tconst char *p;\n\n\t\tfor (seglen = 0, p = docstring; p < docstring + width && *p;\n\t\t     p++) {\n\t\t\tif (*p == '\\n') {\n\t\t\t\tseglen = p - docstring;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (isspace(*p))\n\t\t\t\tseglen = p - docstring;\n\t\t}\n\t\tif (seglen == 0 || *p == 0)\n\t\t\tseglen = p - docstring;\n\n\t\tformat_level(level, stream);\n\t\tfprintf(stream, \"# \");\n\t\tfwrite(docstring, seglen, 1, stream);\n\t\tfputc('\\n', stream);\n\t\tlen -= seglen;\n\t\tdocstring += seglen;\n\t\tif (*docstring == '\\n') {\n\t\t\tdocstring++;\n\t\t\tlen--;\n\t\t} else\n\t\t\twhile (*docstring && isspace(*docstring)) {\n\t\t\t\tdocstring++;\n\t\t\t\tlen--;\n\t\t\t}\n\t}\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_simple_statement": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ngrecs_print_simple_statement(struct grecs_keyword *kwp, unsigned level,\n\t\t\t     FILE *stream)\n{\n\tconst char *argstr;\n\n\tif (kwp->flags & GRECS_INAC)\n\t\tgrecs_print_docstring(N_(\"Disabled;\"), level, stream);\n\tif (kwp->docstring)\n\t\tgrecs_print_docstring(kwp->docstring, level, stream);\n\tformat_level(level, stream);\n\n\tif (kwp->argname)\n\t\targstr = kwp->argname;\n\telse\n\t\targstr = N_(\"arg\");\n\n\tif (strchr(\"<[\", argstr[0]))\n\t\tfprintf(stream, \"%s %s;\\n\", kwp->ident, gettext(argstr));\n\telse if (argstr[0] == '\\'')\n\t\tfprintf(stream, \"%s %s;\\n\", kwp->ident, argstr + 1);\n\telse if (strchr (argstr, ':'))\n\t\tfprintf(stream, \"%s <%s>;\\n\", kwp->ident, gettext(argstr));\n\telse {\n\t\tfprintf(stream, \"%s <%s: \", kwp->ident, gettext(argstr));\n\t\tif (kwp->flags & GRECS_LIST)\n\t\t\tfprintf(stream, \"list of %s\",\n\t\t\t\tgettext(grecs_data_type_string(kwp->type)));\n\t\telse\n\t\t\tfprintf(stream, \"%s\",\n\t\t\t\t gettext(grecs_data_type_string(kwp->type)));\n\t\tfprintf(stream, \">;\\n\");\n\t}\n}",
      "lines": 34,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_block_statement": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "void\ngrecs_print_block_statement(struct grecs_keyword *kwp, unsigned level,\n\t\t\t     FILE *stream)\n{\n\tif (kwp->docstring)\n\t\tgrecs_print_docstring(kwp->docstring, level, stream);\n\tformat_level(level, stream);\n\tfprintf(stream, \"%s\", kwp->ident);\n\tif (kwp->argname) {\n\t\tif (kwp->argname[0] == '\\'')\n\t\t\tfprintf(stream, \" %s\", kwp->argname + 1);\n\t\telse\n\t\t\tfprintf(stream, \" <%s>\", gettext(kwp->argname));\n\t}\n\tfprintf(stream, \" {\\n\");\n\tgrecs_print_statement_array(kwp->kwd, 0, level + 1, stream);\n\tformat_level(level, stream);\n\tfprintf(stream, \"}\\n\");\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_statement_array": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\ngrecs_print_statement_array(struct grecs_keyword *kwp,\n\t\t\t    unsigned n,\n\t\t\t    unsigned level,\n\t\t\t    FILE *stream)\n{\n\tif (!kwp) {\n\t\treturn;\n\t}\n\tfor (; kwp->ident; kwp++, n++) {\n\t\tif (kwp->flags & GRECS_HIDDEN)\n\t\t\tcontinue;\n\t\tif (n)\n\t\t\tfputc('\\n', stream);\n\t\tif (kwp->type == grecs_type_section)\n\t\t\tgrecs_print_block_statement(kwp, level, stream);\n\t\telse\n\t\t\tgrecs_print_simple_statement(kwp, level, stream);\n\t}\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_format_locus": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "void\ngrecs_format_locus(grecs_locus_t *locus, struct grecs_format_closure *clos)\n{\n\tif (locus) {\n\t\tchar *str = NULL;\n\t\tsize_t size = 0;\n\n\t\tif (locus->beg.col == 0)\n\t\t\tgrecs_asprintf(&str, &size, \"%s:%u\",\n\t\t\t\t       locus->beg.file,\n\t\t\t\t       locus->beg.line);\n\t\telse if (strcmp(locus->beg.file, locus->end.file))\n\t\t\tgrecs_asprintf(&str, &size, \"%s:%u.%u-%s:%u.%u\",\n\t\t\t\t       locus->beg.file,\n\t\t\t\t       locus->beg.line, locus->beg.col,\n\t\t\t\t       locus->end.file,\n\t\t\t\t       locus->end.line, locus->end.col);\n\t\telse if (locus->beg.line != locus->end.line)\n\t\t\tgrecs_asprintf(&str, &size, \"%s:%u.%u-%u.%u\",\n\t\t\t\t       locus->beg.file,\n\t\t\t\t       locus->beg.line, locus->beg.col,\n\t\t\t\t       locus->end.line, locus->end.col);\n\t\telse if (locus->beg.col != locus->end.col)\n\t\t\tgrecs_asprintf(&str, &size, \"%s:%u.%u-%u\",\n\t\t\t\t       locus->beg.file,\n\t\t\t\t       locus->beg.line, locus->beg.col,\n\t\t\t\t       locus->end.col);\n\t\telse\n\t\t\tgrecs_asprintf(&str, &size, \"%s:%u.%u\",\n\t\t\t\t       locus->beg.file,\n\t\t\t\t       locus->beg.line,\n\t\t\t\t       locus->beg.col);\n\t\t\n\t\tclos->fmtfun(str, clos->data);\n\t\tfree(str);\n\t}\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "grecs_format_node_path": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "void\ngrecs_format_node_path(struct grecs_node *node, int flags,\n\t\t       struct grecs_format_closure *clos)\n{\n\tchar delim[2] = \".\";\n\n\tif (!node) {\n\t\tclos->fmtfun(\"NULL\", clos->data);\n\t\treturn;\n\t}\n\t\n\tif (node->up)\n\t\tgrecs_format_node_path(node->up, flags, clos);\n\tif (node->type == grecs_node_root)\n\t\treturn;\n\tif (flags & _GRECS_NODE_MASK_DELIM)\n\t\tdelim[0] = flags & _GRECS_NODE_MASK_DELIM;\n\tclos->fmtfun(delim, clos->data);\n\tclos->fmtfun(node->ident, clos->data);\n\tif (node->type == grecs_node_block &&\n\t    !GRECS_VALUE_EMPTY_P(node->v.value)) {\n\t\tclos->fmtfun(\"=\", clos->data);\n\t\tgrecs_format_value(node->v.value, flags|GRECS_NODE_FLAG_QUOTE,\n\t\t\t\t   clos);\n\t}\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "grecs_format_value": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        317,
        1
      ],
      "content": "void\ngrecs_format_value(struct grecs_value *val, int flags,\n\t\t   struct grecs_format_closure *clos)\n{\n\tint i;\n\tstruct grecs_list_entry *ep;\n\tsize_t clen;\n\tint need_quote;\n\n\tif (!val)\n\t\treturn;\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tclen = wordsplit_c_quoted_length(val->v.string,\n\t\t\t\t\t   flags & GRECS_NODE_FLAG_QUOTE_HEX,\n\t\t\t\t\t\t &need_quote);\n\t\tif (flags & GRECS_NODE_FLAG_QUOTE)\n\t\t\tneed_quote = 1;\n\t\telse if (flags & GRECS_NODE_FLAG_NOQUOTE)\n\t\t\tneed_quote = 0;\n\t\tif (need_quote) {\n\t\t\tchar *cbuf = grecs_malloc(clen + 1);\n\t\t\twordsplit_c_quote_copy(cbuf, val->v.string,\n\t\t\t\t\t    flags & GRECS_NODE_FLAG_QUOTE_HEX);\n\t\t\tcbuf[clen] = 0;\n\t\t\tclos->fmtfun(\"\\\"\", clos->data);\n\t\t\tclos->fmtfun(cbuf, clos->data);\n\t\t\tclos->fmtfun(\"\\\"\", clos->data);\n\t\t\tgrecs_free(cbuf);\n\t\t} else\n\t\t\tclos->fmtfun(val->v.string, clos->data);\n\t\tbreak;\n\n\tcase GRECS_TYPE_LIST:\n\t\tclos->fmtfun(\"(\", clos->data);\n\t\tfor (ep = val->v.list->head; ep; ep = ep->next) {\n\t\t\tgrecs_format_value(ep->data, flags, clos);\n\t\t\tif (ep->next)\n\t\t\t\tclos->fmtfun(\", \", clos->data);\n\t\t}\n\t\tclos->fmtfun(\")\", clos->data);\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tfor (i = 0; i < val->v.arg.c; i++) {\n\t\t\tif (i)\n\t\t\t\tclos->fmtfun(\" \", clos->data);\n\t\t\tgrecs_format_value(val->v.arg.v[i], flags, clos);\n\t\t}\n\t}\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "grecs_format_node": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "int\ngrecs_format_node(struct grecs_node *node, int flags,\n\t\t  struct grecs_format_closure *clos)\n{\n\tconst char *delim_str = NULL;\n\n\tif (!(flags & _GRECS_NODE_MASK_OUTPUT)) {\n\t\terrno = EINVAL;\n\t\treturn 1;\n\t}\n\n\tif (!node) {\n\t\tclos->fmtfun(\"NULL\", clos->data);\n\t\treturn 0;\n\t}\n\t\n\tswitch (node->type) {\n\tcase grecs_node_root:\n\tcase grecs_node_block:\n\t\tif (flags & GRECS_NODE_FLAG_DESCEND) {\n\t\t\tfor (node = node->down; node; node = node->next) {\n\t\t\t\tgrecs_format_node(node, flags, clos);\n\t\t\t\tif (node->next)\n\t\t\t\t\tclos->fmtfun(\"\\n\", clos->data);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\tcase grecs_node_stmt:\n\t\tif (flags & GRECS_NODE_FLAG_LOCUS) {\n\t\t\tgrecs_locus_t *locus;\n\t\t\t\n\t\t\tif (flags & GRECS_NODE_FLAG_PATH) {\n\t\t\t\tif (flags & GRECS_NODE_FLAG_VALUE)\n\t\t\t\t\tlocus = &node->locus;\n\t\t\t\telse\n\t\t\t\t\tlocus = &node->idloc;\n\t\t\t} else if (flags & GRECS_NODE_FLAG_VALUE)\n\t\t\t\tlocus = &node->v.value->locus;\n\t\t\telse\n\t\t\t\tlocus = &node->locus;\n\t\t\tgrecs_format_locus(locus, clos);\n\t\t\tdelim_str = \": \";\n\t\t}\n\t\tif (flags & GRECS_NODE_FLAG_PATH) {\n\t\t\tif (delim_str)\n\t\t\t\tclos->fmtfun(delim_str, clos->data);\n\t\t\tgrecs_format_node_path(node, flags, clos);\n\t\t\tdelim_str = \": \";\n\t\t}\n\t\tif (flags & GRECS_NODE_FLAG_VALUE) {\n\t\t\tif (delim_str)\n\t\t\t\tclos->fmtfun(delim_str, clos->data);\n\t\t\tgrecs_format_value(node->v.value, flags, clos);\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 58,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "txtacc_fmt": {
      "start_point": [
        379,
        0
      ],
      "end_point": [
        385,
        1
      ],
      "content": "static int\ntxtacc_fmt(const char *str, void *data)\n{\n\tstruct grecs_txtacc *acc = data;\n\tgrecs_txtacc_grow(acc, str, strlen(str));\n\treturn 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_txtacc_format_value": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "void\ngrecs_txtacc_format_value(struct grecs_value *val, int flags,\n\t\t\t  struct grecs_txtacc *acc)\n{\n\tstruct grecs_format_closure clos = { txtacc_fmt, acc };\n\tgrecs_format_value(val, flags, &clos);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "file_fmt": {
      "start_point": [
        396,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static int\nfile_fmt(const char *str, void *data)\n{\n\tfputs(str, (FILE*)data);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_print_locus": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "void\ngrecs_print_locus(grecs_locus_t *locus, FILE *fp)\n{\n\tstruct grecs_format_closure clos = { file_fmt, fp };\n\tgrecs_format_locus(locus, &clos);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_node_path": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        415,
        1
      ],
      "content": "void\ngrecs_print_node_path(struct grecs_node *node, int flag, FILE *fp)\n{\n\tstruct grecs_format_closure clos = { file_fmt, fp };\n\tgrecs_format_node_path(node, flag, &clos);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_value": {
      "start_point": [
        417,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "void\ngrecs_print_value(struct grecs_value *val, int flags, FILE *fp)\n{\n\tstruct grecs_format_closure clos = { file_fmt, fp };\n\tgrecs_format_value(val, flags, &clos);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_node": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "int\ngrecs_print_node(struct grecs_node *node, int flags, FILE *fp)\n{\n\tstruct grecs_format_closure clos = { file_fmt, fp };\n\treturn grecs_format_node(node, flags, &clos);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/git-parser.c": {
    "rawinput": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nrawinput()\n{\n\tif (!infile || feof(infile))\n\t\treturn input_char = 0;\n\tinput_char = fgetc(infile);\n\tif (input_char == '\\n') {\n\t\ttok.prev_col = grecs_current_locus_point.col;\n\t\tgrecs_locus_point_advance_line(grecs_current_locus_point);\n\t} else if (input_char < 0)\n\t\tinput_char = 0;\n\telse\n\t\tgrecs_current_locus_point.col++;\n\treturn input_char;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "input": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static int\ninput()\n{\n\trawinput();\n\tif (input_char == '#' || input_char == ';') {\n\t\twhile (rawinput() && input_char != '\\n')\n\t\t\t;\n\t}\n\treturn input_char;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "unput": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nunput()\n{\n\tif (!input_char)\n\t\treturn;\n\tif (input_char == '\\n') {\n\t\tgrecs_current_locus_point.line--;\n\t\tgrecs_current_locus_point.col = tok.prev_col;\n\t} else \n\t\tgrecs_current_locus_point.col--;\n\t\t\n\tungetc(input_char, infile);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "error_recovery": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\nerror_recovery()\n{\n\twhile (input() && input_char != '\\n')\n\t\t;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_unquoted": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\ncollect_unquoted()\n{\n\tdo\n\t\tgrecs_txtacc_grow_char(acc, input_char);\n\twhile (input() &&\n\t       !(ISSPACE(input_char) || input_char == ']'));\n\t\t\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_subsection_name": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static void\ncollect_subsection_name()\n{\n\tdo\n\t\tgrecs_txtacc_grow_char(acc, input_char);\n\twhile (input() &&\n\t       (isalnum(input_char) || input_char == '_' ||\n\t\tinput_char == '-'));\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_substring": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static void\ncollect_substring()\n{\n\twhile (rawinput()) {\n\t\tif (input_char == '\\\\') {\n\t\t\tif (!input()) {\n\t\t\t\tgrecs_error(&tok.loc, 0,\n\t\t\t\t\t    \"unexpected EOF in string\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (input_char) {\n\t\t\tcase 'n':\n\t\t\t\tinput_char = '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tinput_char = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tinput_char = '\\b';\n\t\t\t}\n\t\t} else if (input_char == '\"')\n\t\t\tbreak;\n\t\tgrecs_txtacc_grow_char(acc, input_char);\n\t}\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gettoken": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static void\ngettoken(void)\n{\n\tint putback = tok.putback;\n\ttok.putback = 0;\n\tif (putback) {\n\t\tif (putback == '\\n')\n\t\t\tgrecs_locus_point_advance_line(grecs_current_locus_point);\n\t\telse\n\t\t\tgrecs_current_locus_point.col++;\n\t\treturn;\n\t}\n\t\n\ttok.buf = NULL;\n        /* Skip whitespace */\n\twhile (input() && ISSPACE(input_char))\n\t\t;\n\n\ttok.loc.beg = grecs_current_locus_point;\n\t\n\tif (input_char <= 0) {\n\t\ttok.type = TOK_EOF;\n\t\tendpoint(tok, 0);\n\t\treturn;\n\t}\n\t\n\tif (input_char == '[') {\n\t\tint dot_delimited = -1;\n\t\t\n\t\ttok.type = TOK_SECTION;\n\t\tgrecs_list_clear(tok.path);\n\t\tinput();\n\t\tfor (;;) {\n\t\t\tchar *p;\n\n\t\t\tif (!dot_delimited)\n\t\t\t\twhile (ISSPACE(input_char))\n\t\t\t\t\tinput();\n\t\t\telse {\n\t\t\t\tif (input_char == ']')\n\t\t\t\t\tbreak;\n\t\t\t\tif (dot_delimited == 1)\n\t\t\t\t\tinput();\n\t\t\t}\n\t\t\t\n\t\t\tif (input_char == TOK_EOF) {\n\t\t\t\tendpoint(tok, 0);\n\t\t\t\tgrecs_error(&tok.loc, 0,\n\t\t\t\t\t    \"unexpected EOF in section header\");\n\t\t\t\ttok.type = TOK_ERR;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (input_char == ']')\n\t\t\t\tbreak;\n\t\t\tif (input_char == '\\n') {\n\t\t\t\tendpoint(tok, 1);\n\t\t\t\tgrecs_error(&tok.loc, 0,\n\t\t\t\t\t    \"unexpect newline in in section header\");\n\t\t\t\ttok.type = TOK_ERR;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (dot_delimited != 1 && input_char == '\"') {\n\t\t\t\tcollect_substring();\n\t\t\t\tinput();\n\t\t\t\tdot_delimited = 0;\n\t\t\t} else if (dot_delimited == 1)\n\t\t\t\tcollect_subsection_name();\n\t\t\telse\n\t\t\t\tcollect_unquoted();\n\t\t\tif (dot_delimited == -1)\n\t\t\t\tdot_delimited = input_char == '.';\n\t\t\telse if (dot_delimited == 1) {\n\t\t\t\tif (input_char != '.' && input_char != ']') {\n\t\t\t\t\tendpoint(tok, 1);\n\t\t\t\t\tgrecs_error(&tok.loc, 0,\n\t\t\t\t\t\t    \"unexpected character in section header\");\n\t\t\t\t\ttok.type = TOK_ERR;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\t\tp = grecs_txtacc_finish(acc, 0);\n\t\t\tgrecs_list_append(tok.path, p);\n\t\t}\n\n\t\tendpoint(tok, 1);\n\t\tif (grecs_list_size(tok.path) == 0) {\n\t\t\tgrecs_error(&tok.loc, 0, \"empty section header\");\n\t\t\ttok.type = TOK_ERR;\n\t\t\treturn;\n\t\t}\n\n\t\ttok.type = TOK_SECTION;\n\t\treturn;\n\t}\n\n\tif (ISINITIAL(input_char)) {\n\t\ttok.type = TOK_KEYWORD;\n\t\tdo \n\t\t\tgrecs_txtacc_grow_char(acc, input_char);\n\t\twhile (input() && ISIDENT(input_char));\n\t\tunput();\n\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\ttok.buf = grecs_txtacc_finish(acc, 0);\n\t\tendpoint(tok, 0);\n\t\treturn;\n\t}\n\n\ttok.chbuf[0] = input_char;\n\ttok.chbuf[1] = 0;\n\ttok.buf = tok.chbuf;\n\ttok.type = input_char;\n\tendpoint(tok, 0);\n}",
      "lines": 115,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_value": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static void\ncollect_value()\n{\n\tdo {\n\t\tif (input_char == '\"') {\n\t\t\tcollect_substring();\n\t\t\tif (input_char == '\"')\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tif (input_char == '\\\\') {\n\t\t\tif (!rawinput())\n\t\t\t\tbreak;\n\t\t\tswitch (input_char) {\n\t\t\tcase 'n':\n\t\t\t\tinput_char = '\\n';\n\t\t\t\tbreak;\n\t\t\tcase 't':\n\t\t\t\tinput_char = '\\t';\n\t\t\t\tbreak;\n\t\t\tcase 'b':\n\t\t\t\tinput_char = '\\b';\n\t\t\t}\n\t\t}\n\t\tgrecs_txtacc_grow_char(acc, input_char);\n\t} while (input() && input_char != '\\n');\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getvalue": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "static struct grecs_value *\ngetvalue()\n{\n\tint len;\n\tstruct grecs_value *val = grecs_malloc(sizeof(*val));\n\n\twhile (input() && ISSPACE(input_char) && input_char != '\\n')\n\t\t;\n\n\tval->locus.beg = grecs_current_locus_point;\n\t\n\tif (input_char != '\\n')\n\t\tcollect_value();\n\tval->locus.end = grecs_current_locus_point;\n\tval->locus.end.line--;\n\tval->locus.end.col = tok.prev_col;\n\t\n\tgrecs_txtacc_grow_char(acc, 0);\n\ttok.type = TOK_VALUE;\n\ttok.buf = grecs_txtacc_finish(acc, 1);\n\tlen = strlen(tok.buf);\n\twhile (len > 0 && ISSPACE(tok.buf[len-1]))\n\t\ttok.buf[--len] = 0;\n\tval->type = GRECS_TYPE_STRING;\n\tval->v.string = tok.buf;\n\treturn val;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\ngetvalue()",
        "*"
      ]
    },
    "read_statement": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "static int\nread_statement(struct grecs_node *parent)\n{\n\tstruct grecs_node *node;\n\t\n\tgettoken();\n\tif (tok.type == TOK_EOF || tok.type == TOK_SECTION) {\n\t\ttok.putback = 1;\n\t\treturn 0;\n\t}\n\tif (tok.type != TOK_KEYWORD) {\n\t\tgrecs_error(&tok.loc, 0, \"syntax error\");\n\t\terror_recovery();\n\t\treturn 1;\n\t}\n\t\t\n\tnode = grecs_node_create(grecs_node_stmt, &tok.loc);\n\tnode->ident = grecs_strdup(tok.buf);\n\tnode->idloc = tok.loc;\n\t\n\tgettoken();\n\tif (tok.type == TOK_EOF) {\n\t\tgrecs_error(&tok.loc, 0, \"unexpected EOF\");\n\t\tgrecs_node_free(node);\n\t\treturn 0;\n\t}\n\tif (tok.type != TOK_EQ) {\n\t\tgrecs_error(&tok.loc, 0,\n\t\t\t    \"expected `=', but found `%s'\", tok.buf);\n\t\terror_recovery();\n\t\tgrecs_node_free(node);\n\t\treturn 1;\n\t}\n\tnode->v.value = getvalue();\n\tnode->locus.end = node->v.value->locus.end;\n\tgrecs_node_bind(parent, node, 1);\n\treturn 1;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_statement_list": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        371,
        1
      ],
      "content": "static void\nread_statement_list(struct grecs_node *parent)\n{\n\twhile (read_statement(parent))\n\t\t;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "create_subsection_node": {
      "start_point": [
        373,
        0
      ],
      "end_point": [
        390,
        1
      ],
      "content": "struct grecs_node *\ncreate_subsection_node(struct grecs_node *root)\n{\n\tstruct grecs_list_entry *ep;\n\tstruct grecs_node *p;\n\t\n\tfor (ep = tok.path->head; ep; ep = ep->next) {\n\t\tchar *ident = ep->data;\n\t\tp = grecs_find_node(root, ident);\n\t\tif (!p) {\n\t\t\tp = grecs_node_create(grecs_node_block, &tok.loc);\n\t\t\tp->ident = grecs_strdup(ident);\n\t\t\tgrecs_node_bind(root, p, 1);\n\t\t}\n\t\troot = p;\n\t}\n\treturn root;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ncreate_subsection_node(struct grecs_node *root)",
        "*"
      ]
    },
    "read_section": {
      "start_point": [
        392,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static int\nread_section(struct grecs_node *parent)\n{\n\tgettoken();\n\tif (tok.type == TOK_EOF)\n\t\treturn 0;\n\telse if (tok.type == TOK_SECTION) {\n\t\tstruct grecs_node *node = create_subsection_node(parent);\n\t\tread_statement_list(node);\n\t} else if (tok.type == TOK_KEYWORD) {\n\t\tread_statement(parent);\n\t} else {\n\t\tgrecs_error(&tok.loc, 0, \"syntax error\");\n\t\terror_recovery();\n\t}\n\treturn 1;\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_git_parser": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "struct grecs_node *\ngrecs_git_parser(const char *name, int traceflags)\n{\n\tstruct grecs_node *root;\n\t\n\tinfile = fopen(name, \"r\");\n\tif (!infile) {\n\t\tgrecs_error(NULL, errno, _(\"cannot open `%s'\"), name);\n\t\treturn NULL;\n\t}\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\n\tacc = grecs_txtacc_create();\n\ttok.path = grecs_list_create();\n\troot = grecs_node_create(grecs_node_root, &tok.loc);\n\t\n\twhile (read_section(root))\n\t\t;\n\troot->locus.end = grecs_current_locus_point;\n\tfclose(infile);\n\tgrecs_txtacc_free(acc);\n\tgrecs_list_free(tok.path);\n\tif (grecs_error_count) {\n\t\tgrecs_tree_free(root);\n\t\troot = NULL;\n\t}\n\treturn root;\n}",
      "lines": 30,
      "depth": 11,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_git_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/grecs-gram.c": {
    "grecs_grecs_tnamerr": {
      "start_point": [
        964,
        0
      ],
      "end_point": [
        1001,
        1
      ],
      "content": "static YYSIZE_T\ngrecs_grecs_tnamerr (char *grecs_grecs_res, const char *grecs_grecs_str)\n{\n  if (*grecs_grecs_str == '\"')\n    {\n      YYSIZE_T grecs_grecs_n = 0;\n      char const *grecs_grecs_p = grecs_grecs_str;\n\n      for (;;)\n\tswitch (*++grecs_grecs_p)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++grecs_grecs_p != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (grecs_grecs_res)\n\t      grecs_grecs_res[grecs_grecs_n] = *grecs_grecs_p;\n\t    grecs_grecs_n++;\n\t    break;\n\n\t  case '\"':\n\t    if (grecs_grecs_res)\n\t      grecs_grecs_res[grecs_grecs_n] = '\\0';\n\t    return grecs_grecs_n;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! grecs_grecs_res)\n    return grecs_grecs_strlen (grecs_grecs_str);\n\n  return grecs_grecs_stpcpy (grecs_grecs_res, grecs_grecs_str) - grecs_grecs_res;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "grecs_grecs_syntax_error": {
      "start_point": [
        1012,
        0
      ],
      "end_point": [
        1138,
        1
      ],
      "content": "static int\ngrecs_grecs_syntax_error (YYSIZE_T *grecs_grecs_msg_alloc, char **grecs_grecs_msg,\n                grecs_grecs_type_int16 *grecs_grecs_ssp, int grecs_grecs_token)\n{\n  YYSIZE_T grecs_grecs_size0 = grecs_grecs_tnamerr (YY_NULL, grecs_grecs_tname[grecs_grecs_token]);\n  YYSIZE_T grecs_grecs_size = grecs_grecs_size0;\n  YYSIZE_T grecs_grecs_size1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *grecs_grecs_format = YY_NULL;\n  /* Arguments of grecs_grecs_format. */\n  char const *grecs_grecs_arg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int grecs_grecs_count = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in grecs_grecs_char) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated grecs_grecs_char.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (grecs_grecs_token != YYEMPTY)\n    {\n      int grecs_grecs_n = grecs_grecs_pact[*grecs_grecs_ssp];\n      grecs_grecs_arg[grecs_grecs_count++] = grecs_grecs_tname[grecs_grecs_token];\n      if (!grecs_grecs_pact_value_is_default (grecs_grecs_n))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int grecs_grecs_xbegin = grecs_grecs_n < 0 ? -grecs_grecs_n : 0;\n          /* Stay within bounds of both grecs_grecs_check and grecs_grecs_tname.  */\n          int grecs_grecs_checklim = YYLAST - grecs_grecs_n + 1;\n          int grecs_grecs_xend = grecs_grecs_checklim < YYNTOKENS ? grecs_grecs_checklim : YYNTOKENS;\n          int grecs_grecs_x;\n\n          for (grecs_grecs_x = grecs_grecs_xbegin; grecs_grecs_x < grecs_grecs_xend; ++grecs_grecs_x)\n            if (grecs_grecs_check[grecs_grecs_x + grecs_grecs_n] == grecs_grecs_x && grecs_grecs_x != YYTERROR\n                && !grecs_grecs_table_value_is_error (grecs_grecs_table[grecs_grecs_x + grecs_grecs_n]))\n              {\n                if (grecs_grecs_count == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    grecs_grecs_count = 1;\n                    grecs_grecs_size = grecs_grecs_size0;\n                    break;\n                  }\n                grecs_grecs_arg[grecs_grecs_count++] = grecs_grecs_tname[grecs_grecs_x];\n                grecs_grecs_size1 = grecs_grecs_size + grecs_grecs_tnamerr (YY_NULL, grecs_grecs_tname[grecs_grecs_x]);\n                if (! (grecs_grecs_size <= grecs_grecs_size1\n                       && grecs_grecs_size1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                grecs_grecs_size = grecs_grecs_size1;\n              }\n        }\n    }\n\n  switch (grecs_grecs_count)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        grecs_grecs_format = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  grecs_grecs_size1 = grecs_grecs_size + grecs_grecs_strlen (grecs_grecs_format);\n  if (! (grecs_grecs_size <= grecs_grecs_size1 && grecs_grecs_size1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  grecs_grecs_size = grecs_grecs_size1;\n\n  if (*grecs_grecs_msg_alloc < grecs_grecs_size)\n    {\n      *grecs_grecs_msg_alloc = 2 * grecs_grecs_size;\n      if (! (grecs_grecs_size <= *grecs_grecs_msg_alloc\n             && *grecs_grecs_msg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *grecs_grecs_msg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *grecs_grecs_p = *grecs_grecs_msg;\n    int grecs_grecs_i = 0;\n    while ((*grecs_grecs_p = *grecs_grecs_format) != '\\0')\n      if (*grecs_grecs_p == '%' && grecs_grecs_format[1] == 's' && grecs_grecs_i < grecs_grecs_count)\n        {\n          grecs_grecs_p += grecs_grecs_tnamerr (grecs_grecs_p, grecs_grecs_arg[grecs_grecs_i++]);\n          grecs_grecs_format += 2;\n        }\n      else\n        {\n          grecs_grecs_p++;\n          grecs_grecs_format++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_grecs_error": {
      "start_point": [
        1996,
        0
      ],
      "end_point": [
        2001,
        1
      ],
      "content": "int\ngrecs_grecs_error(char const *s)\n{\n\tgrecs_error(&grecs_grecs_lloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs_parser": {
      "start_point": [
        2003,
        0
      ],
      "end_point": [
        2020,
        1
      ],
      "content": "struct grecs_node *\ngrecs_grecs_parser(const char *name, int traceflags)\n{\n\tint rc;\n\tif (grecs_lex_begin(name, traceflags & GRECS_TRACE_LEX))\n\t\treturn NULL;\n\tgrecs_grecs_debug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\trc = grecs_grecs_parse();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_lex_end(rc);\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_grecs_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/grecs-gram.h": {},
  "direvent/direvent-5.1/grecs/src/grecs-gram.y": {
    "MSTRING": [
      {
        "start_point": [
          50,
          20
        ],
        "end_point": [
          61,
          4
        ],
        "content": "list vlist\n%type <node> stmt simple block maybe_stmtlist\n%type <node_list> stmtlist\n\n%%\n\ninput   : maybe_stmtlist\n          {\n\t\t  parse_tree = grecs_node_create(grecs_node_root, &@1);\n\t\t  parse_tree->v.texttab = grecs_text_table();\n\t\t  grecs_node_bind(parse_tree, $1, 1);\n\t  }",
        "lines": 12,
        "depth": 9,
        "decorators": null
      },
      {
        "start_point": [
          79,
          10
        ],
        "end_point": [
          82,
          4
        ],
        "content": "stmtlist stmt\n\t  {\n\t\t  grecs_node_bind($1.tail, $2, 0);\n\t  }",
        "lines": 4,
        "depth": 5,
        "decorators": null
      },
      {
        "start_point": [
          153,
          10
        ],
        "end_point": [
          156,
          4
        ],
        "content": "vlist value\n          {\n\t\t  grecs_list_append($1, grecs_value_ptr_from_static(&$2));\n\t  }",
        "lines": 4,
        "depth": 9,
        "decorators": null
      }
    ],
    "yyerror": {
      "start_point": [
        243,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "int\nyyerror(char const *s)\n{\n\tgrecs_error(&yylloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs_parser": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        267,
        1
      ],
      "content": "struct grecs_node *\ngrecs_grecs_parser(const char *name, int traceflags)\n{\n\tint rc;\n\tif (grecs_lex_begin(name, traceflags & GRECS_TRACE_LEX))\n\t\treturn NULL;\n\tyydebug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\trc = yyparse();\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_lex_end(rc);\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_grecs_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/grecs-lex.c": {
    "grecs_grecs__get_next_buffer": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1664,
        1
      ],
      "content": "static int grecs_grecs__get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf;\n\tregister char *source = (grecs_grecs_text_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (grecs_grecs__c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf[(grecs_grecs__n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_grecs__fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (grecs_grecs__c_buf_p) - (grecs_grecs_text_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((grecs_grecs__c_buf_p) - (grecs_grecs_text_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_grecs__buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__n_chars = (grecs_grecs__n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint grecs_grecs__c_buf_p_offset =\n\t\t\t\t(int) ((grecs_grecs__c_buf_p) - b->grecs_grecs__ch_buf);\n\n\t\t\tif ( b->grecs_grecs__is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->grecs_grecs__buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->grecs_grecs__buf_size += b->grecs_grecs__buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->grecs_grecs__buf_size *= 2;\n\n\t\t\t\tb->grecs_grecs__ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tgrecs_grecs_realloc((void *) b->grecs_grecs__ch_buf,b->grecs_grecs__buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->grecs_grecs__ch_buf = 0;\n\n\t\t\tif ( ! b->grecs_grecs__ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(grecs_grecs__c_buf_p) = &b->grecs_grecs__ch_buf[grecs_grecs__c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf[number_to_move]),\n\t\t\t(grecs_grecs__n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__n_chars = (grecs_grecs__n_chars);\n\t\t}\n\n\tif ( (grecs_grecs__n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tgrecs_grecs_restart(grecs_grecs_in  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((grecs_grecs__size_t) ((grecs_grecs__n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tgrecs_grecs__size_t new_size = (grecs_grecs__n_chars) + number_to_move + ((grecs_grecs__n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf = (char *) grecs_grecs_realloc((void *) YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs__get_next_buffer()\" );\n\t}\n\n\t(grecs_grecs__n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf[(grecs_grecs__n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf[(grecs_grecs__n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(grecs_grecs_text_ptr) = &YY_CURRENT_BUFFER_LVALUE->grecs_grecs__ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_grecs__get_previous_state": {
      "start_point": [
        1671,
        4
      ],
      "end_point": [
        1702,
        1
      ],
      "content": "static grecs_grecs__state_type grecs_grecs__get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister grecs_grecs__state_type grecs_grecs__current_state;\n\tregister char *grecs_grecs__cp;\n    \n/* %% [15.0] code to get the start state into grecs_grecs__current_state goes here */\n\tgrecs_grecs__current_state = (grecs_grecs__start);\n\tgrecs_grecs__current_state += YY_AT_BOL();\n\n\tfor ( grecs_grecs__cp = (grecs_grecs_text_ptr) + YY_MORE_ADJ; grecs_grecs__cp < (grecs_grecs__c_buf_p); ++grecs_grecs__cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR grecs_grecs__c = (*grecs_grecs__cp ? grecs_grecs__ec[YY_SC_TO_UI(*grecs_grecs__cp)] : 1);\n\t\tif ( grecs_grecs__accept[grecs_grecs__current_state] )\n\t\t\t{\n\t\t\t(grecs_grecs__last_accepting_state) = grecs_grecs__current_state;\n\t\t\t(grecs_grecs__last_accepting_cpos) = grecs_grecs__cp;\n\t\t\t}\n\t\twhile ( grecs_grecs__chk[grecs_grecs__base[grecs_grecs__current_state] + grecs_grecs__c] != grecs_grecs__current_state )\n\t\t\t{\n\t\t\tgrecs_grecs__current_state = (int) grecs_grecs__def[grecs_grecs__current_state];\n\t\t\tif ( grecs_grecs__current_state >= 134 )\n\t\t\t\tgrecs_grecs__c = grecs_grecs__meta[(unsigned int) grecs_grecs__c];\n\t\t\t}\n\t\tgrecs_grecs__current_state = grecs_grecs__nxt[grecs_grecs__base[grecs_grecs__current_state] + (unsigned int) grecs_grecs__c];\n\t\t}\n\n\treturn grecs_grecs__current_state;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "grecs_grecs__state_type"
      ]
    },
    "grecs_grecs__try_NUL_trans": {
      "start_point": [
        1710,
        4
      ],
      "end_point": [
        1735,
        1
      ],
      "content": "static grecs_grecs__state_type grecs_grecs__try_NUL_trans  (grecs_grecs__state_type grecs_grecs__current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int grecs_grecs__is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *grecs_grecs__cp = (grecs_grecs__c_buf_p);\n\n\tregister YY_CHAR grecs_grecs__c = 1;\n\tif ( grecs_grecs__accept[grecs_grecs__current_state] )\n\t\t{\n\t\t(grecs_grecs__last_accepting_state) = grecs_grecs__current_state;\n\t\t(grecs_grecs__last_accepting_cpos) = grecs_grecs__cp;\n\t\t}\n\twhile ( grecs_grecs__chk[grecs_grecs__base[grecs_grecs__current_state] + grecs_grecs__c] != grecs_grecs__current_state )\n\t\t{\n\t\tgrecs_grecs__current_state = (int) grecs_grecs__def[grecs_grecs__current_state];\n\t\tif ( grecs_grecs__current_state >= 134 )\n\t\t\tgrecs_grecs__c = grecs_grecs__meta[(unsigned int) grecs_grecs__c];\n\t\t}\n\tgrecs_grecs__current_state = grecs_grecs__nxt[grecs_grecs__base[grecs_grecs__current_state] + (unsigned int) grecs_grecs__c];\n\tgrecs_grecs__is_jam = (grecs_grecs__current_state == 133);\n\n\treturn grecs_grecs__is_jam ? 0 : grecs_grecs__current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "grecs_grecs__state_type"
      ]
    },
    "grecs_grecs_restart": {
      "start_point": [
        1830,
        4
      ],
      "end_point": [
        1844,
        1
      ],
      "content": "void grecs_grecs_restart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        grecs_grecs_ensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            grecs_grecs__create_buffer(grecs_grecs_in,YY_BUF_SIZE );\n\t}\n\n\tgrecs_grecs__init_buffer(YY_CURRENT_BUFFER,input_file );\n\tgrecs_grecs__load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs__switch_to_buffer": {
      "start_point": [
        1851,
        4
      ],
      "end_point": [
        1883,
        1
      ],
      "content": "void grecs_grecs__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tgrecs_grecs_pop_buffer_state();\n\t *\t\tgrecs_grecs_push_buffer_state(new_buffer);\n     */\n\tgrecs_grecs_ensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_grecs__c_buf_p) = (grecs_grecs__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_pos = (grecs_grecs__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__n_chars = (grecs_grecs__n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tgrecs_grecs__load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (grecs_grecs_wrap()) processing, but the only time this flag\n\t * is looked at is after grecs_grecs_wrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(grecs_grecs__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs__load_buffer_state": {
      "start_point": [
        1886,
        0
      ],
      "end_point": [
        1895,
        1
      ],
      "content": "static void grecs_grecs__load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(grecs_grecs__n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_grecs__n_chars;\n\t(grecs_grecs_text_ptr) = (grecs_grecs__c_buf_p) = YY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_pos;\n\tgrecs_grecs_in = YY_CURRENT_BUFFER_LVALUE->grecs_grecs__input_file;\n\t(grecs_grecs__hold_char) = *(grecs_grecs__c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_grecs__create_buffer": {
      "start_point": [
        1904,
        4
      ],
      "end_point": [
        1929,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_grecs__create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) grecs_grecs_alloc(sizeof( struct grecs_grecs__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs__create_buffer()\" );\n\n\tb->grecs_grecs__buf_size = size;\n\n\t/* grecs_grecs__ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->grecs_grecs__ch_buf = (char *) grecs_grecs_alloc(b->grecs_grecs__buf_size + 2  );\n\tif ( ! b->grecs_grecs__ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs__create_buffer()\" );\n\n\tb->grecs_grecs__is_our_buffer = 1;\n\n\tgrecs_grecs__init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_grecs__delete_buffer": {
      "start_point": [
        1936,
        4
      ],
      "end_point": [
        1952,
        1
      ],
      "content": "void grecs_grecs__delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->grecs_grecs__is_our_buffer )\n\t\tgrecs_grecs_free((void *) b->grecs_grecs__ch_buf  );\n\n\tgrecs_grecs_free((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs__init_buffer": {
      "start_point": [
        1970,
        4
      ],
      "end_point": [
        2000,
        1
      ],
      "content": "static void grecs_grecs__init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tgrecs_grecs__flush_buffer(b );\n\n\tb->grecs_grecs__input_file = file;\n\tb->grecs_grecs__fill_buffer = 1;\n\n    /* If b is the current buffer, then grecs_grecs__init_buffer was _probably_\n     * called from grecs_grecs_restart() or through grecs_grecs__get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->grecs_grecs__bs_lineno = 1;\n        b->grecs_grecs__bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->grecs_grecs__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_grecs__flush_buffer": {
      "start_point": [
        2007,
        4
      ],
      "end_point": [
        2031,
        1
      ],
      "content": "void grecs_grecs__flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->grecs_grecs__n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->grecs_grecs__ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->grecs_grecs__ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->grecs_grecs__buf_pos = &b->grecs_grecs__ch_buf[0];\n\n\tb->grecs_grecs__at_bol = 1;\n\tb->grecs_grecs__buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tgrecs_grecs__load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_push_buffer_state": {
      "start_point": [
        2041,
        0
      ],
      "end_point": [
        2068,
        1
      ],
      "content": "void grecs_grecs_push_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tgrecs_grecs_ensure_buffer_stack();\n\n\t/* This block is copied from grecs_grecs__switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_grecs__c_buf_p) = (grecs_grecs__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__buf_pos = (grecs_grecs__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_grecs__n_chars = (grecs_grecs__n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(grecs_grecs__buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from grecs_grecs__switch_to_buffer. */\n\tgrecs_grecs__load_buffer_state( );\n\t(grecs_grecs__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_pop_buffer_state": {
      "start_point": [
        2077,
        0
      ],
      "end_point": [
        2094,
        1
      ],
      "content": "void grecs_grecs_pop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tgrecs_grecs__delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((grecs_grecs__buffer_stack_top) > 0)\n\t\t--(grecs_grecs__buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tgrecs_grecs__load_buffer_state( );\n\t\t(grecs_grecs__did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_ensure_buffer_stack": {
      "start_point": [
        2102,
        0
      ],
      "end_point": [
        2146,
        1
      ],
      "content": "static void grecs_grecs_ensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    \n\tif (!(grecs_grecs__buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(grecs_grecs__buffer_stack) = (struct grecs_grecs__buffer_state**)grecs_grecs_alloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct grecs_grecs__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_grecs__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs_ensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((grecs_grecs__buffer_stack), 0, num_to_alloc * sizeof(struct grecs_grecs__buffer_state*));\n\t\t\t\t\n\t\t(grecs_grecs__buffer_stack_max) = num_to_alloc;\n\t\t(grecs_grecs__buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((grecs_grecs__buffer_stack_top) >= ((grecs_grecs__buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (grecs_grecs__buffer_stack_max) + grow_size;\n\t\t(grecs_grecs__buffer_stack) = (struct grecs_grecs__buffer_state**)grecs_grecs_realloc\n\t\t\t\t\t\t\t\t((grecs_grecs__buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct grecs_grecs__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_grecs__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs_ensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((grecs_grecs__buffer_stack) + (grecs_grecs__buffer_stack_max), 0, grow_size * sizeof(struct grecs_grecs__buffer_state*));\n\t\t(grecs_grecs__buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_grecs__scan_buffer": {
      "start_point": [
        2156,
        0
      ],
      "end_point": [
        2183,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_grecs__scan_buffer  (char * base, grecs_grecs__size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) grecs_grecs_alloc(sizeof( struct grecs_grecs__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs__scan_buffer()\" );\n\n\tb->grecs_grecs__buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->grecs_grecs__buf_pos = b->grecs_grecs__ch_buf = base;\n\tb->grecs_grecs__is_our_buffer = 0;\n\tb->grecs_grecs__input_file = 0;\n\tb->grecs_grecs__n_chars = b->grecs_grecs__buf_size;\n\tb->grecs_grecs__is_interactive = 0;\n\tb->grecs_grecs__at_bol = 1;\n\tb->grecs_grecs__fill_buffer = 0;\n\tb->grecs_grecs__buffer_status = YY_BUFFER_NEW;\n\n\tgrecs_grecs__switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_grecs__scan_string": {
      "start_point": [
        2195,
        0
      ],
      "end_point": [
        2199,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_grecs__scan_string (grecs_grecs_const char * grecs_grecs_str )\n{\n    \n\treturn grecs_grecs__scan_bytes(grecs_grecs_str,strlen(grecs_grecs_str) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_grecs__scan_bytes": {
      "start_point": [
        2210,
        0
      ],
      "end_point": [
        2238,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_grecs__scan_bytes  (grecs_grecs_const char * grecs_grecs_bytes, int  _grecs_grecs_bytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tgrecs_grecs__size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _grecs_grecs_bytes_len + 2;\n\tbuf = (char *) grecs_grecs_alloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_grecs__scan_bytes()\" );\n\n\tfor ( i = 0; i < _grecs_grecs_bytes_len; ++i )\n\t\tbuf[i] = grecs_grecs_bytes[i];\n\n\tbuf[_grecs_grecs_bytes_len] = buf[_grecs_grecs_bytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = grecs_grecs__scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in grecs_grecs__scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->grecs_grecs__is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_grecs__fatal_error": {
      "start_point": [
        2246,
        0
      ],
      "end_point": [
        2250,
        1
      ],
      "content": "static void grecs_grecs__fatal_error (grecs_grecs_const char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_grecs_get_lineno": {
      "start_point": [
        2281,
        0
      ],
      "end_point": [
        2285,
        1
      ],
      "content": "int grecs_grecs_get_lineno  (void)\n{\n        \n    return grecs_grecs_lineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs_get_in": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2293,
        1
      ],
      "content": "FILE *grecs_grecs_get_in  (void)\n{\n        return grecs_grecs_in;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_grecs_get_in  (void)",
        "*"
      ]
    },
    "grecs_grecs_get_out": {
      "start_point": [
        2298,
        0
      ],
      "end_point": [
        2301,
        1
      ],
      "content": "FILE *grecs_grecs_get_out  (void)\n{\n        return grecs_grecs_out;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_grecs_get_out  (void)",
        "*"
      ]
    },
    "grecs_grecs_get_leng": {
      "start_point": [
        2306,
        0
      ],
      "end_point": [
        2309,
        1
      ],
      "content": "int grecs_grecs_get_leng  (void)\n{\n        return grecs_grecs_leng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs_get_text": {
      "start_point": [
        2315,
        0
      ],
      "end_point": [
        2318,
        1
      ],
      "content": "char *grecs_grecs_get_text  (void)\n{\n        return grecs_grecs_text;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*grecs_grecs_get_text  (void)",
        "*"
      ]
    },
    "grecs_grecs_set_lineno": {
      "start_point": [
        2327,
        0
      ],
      "end_point": [
        2331,
        1
      ],
      "content": "void grecs_grecs_set_lineno (int  line_number )\n{\n    \n    grecs_grecs_lineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_set_in": {
      "start_point": [
        2339,
        0
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "void grecs_grecs_set_in (FILE *  in_str )\n{\n        grecs_grecs_in = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_set_out": {
      "start_point": [
        2344,
        0
      ],
      "end_point": [
        2347,
        1
      ],
      "content": "void grecs_grecs_set_out (FILE *  out_str )\n{\n        grecs_grecs_out = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_get_debug": {
      "start_point": [
        2349,
        0
      ],
      "end_point": [
        2352,
        1
      ],
      "content": "int grecs_grecs_get_debug  (void)\n{\n        return grecs_grecs__flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs_set_debug": {
      "start_point": [
        2354,
        0
      ],
      "end_point": [
        2357,
        1
      ],
      "content": "void grecs_grecs_set_debug (int  bdebug )\n{\n        grecs_grecs__flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs__init_globals": {
      "start_point": [
        2367,
        0
      ],
      "end_point": [
        2393,
        1
      ],
      "content": "static int grecs_grecs__init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from grecs_grecs_lex_destroy(), so don't allocate here.\n     */\n\n    (grecs_grecs__buffer_stack) = 0;\n    (grecs_grecs__buffer_stack_top) = 0;\n    (grecs_grecs__buffer_stack_max) = 0;\n    (grecs_grecs__c_buf_p) = (char *) 0;\n    (grecs_grecs__init) = 0;\n    (grecs_grecs__start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    grecs_grecs_in = stdin;\n    grecs_grecs_out = stdout;\n#else\n    grecs_grecs_in = (FILE *) 0;\n    grecs_grecs_out = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * grecs_grecs_lex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_grecs_lex_destroy": {
      "start_point": [
        2398,
        0
      ],
      "end_point": [
        2419,
        1
      ],
      "content": "int grecs_grecs_lex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tgrecs_grecs__delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tgrecs_grecs_pop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tgrecs_grecs_free((grecs_grecs__buffer_stack) );\n\t(grecs_grecs__buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * grecs_grecs_lex() is called, initialization will occur. */\n    grecs_grecs__init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_grecs__flex_strncpy": {
      "start_point": [
        2427,
        0
      ],
      "end_point": [
        2432,
        1
      ],
      "content": "static void grecs_grecs__flex_strncpy (char* s1, grecs_grecs_const char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_grecs__flex_strlen": {
      "start_point": [
        2436,
        0
      ],
      "end_point": [
        2443,
        1
      ],
      "content": "static int grecs_grecs__flex_strlen (grecs_grecs_const char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_grecs_alloc": {
      "start_point": [
        2446,
        0
      ],
      "end_point": [
        2449,
        1
      ],
      "content": "void *grecs_grecs_alloc (grecs_grecs__size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*grecs_grecs_alloc (grecs_grecs__size_t  size )",
        "*"
      ]
    },
    "grecs_grecs_realloc": {
      "start_point": [
        2451,
        0
      ],
      "end_point": [
        2461,
        1
      ],
      "content": "void *grecs_grecs_realloc  (void * ptr, grecs_grecs__size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*grecs_grecs_realloc  (void * ptr, grecs_grecs__size_t  size )",
        "*"
      ]
    },
    "grecs_grecs_free": {
      "start_point": [
        2463,
        0
      ],
      "end_point": [
        2466,
        1
      ],
      "content": "void grecs_grecs_free (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see grecs_grecs_realloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_grecs_wrap": {
      "start_point": [
        2481,
        0
      ],
      "end_point": [
        2491,
        1
      ],
      "content": "int\ngrecs_grecs_wrap()\n{\n\tif (grecs_preprocessor) {\n\t\tgrecs_preproc_extrn_shutdown(grecs_preproc_pid);\n\t\tfclose(grecs_grecs_in);\n\t} else\n\t\tgrecs_preproc_done();\n\tgrecs_current_locus_point.file = NULL;\n\treturn 1;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_lex_begin": {
      "start_point": [
        2493,
        0
      ],
      "end_point": [
        2521,
        1
      ],
      "content": "int\ngrecs_lex_begin(const char *name, int trace)\n{\n\tgrecs_grecs__flex_debug = trace;\n\n\tgrecs_line_acc_create();\n\t\n\tif (grecs_preprocessor) {\n\t\tint fd;\n\t\n\t\tfd = open(name, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\tgrecs_error(NULL, errno, _(\"Cannot open `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\t\tclose(fd);\n\n\t\tgrecs_grecs_in = grecs_preproc_extrn_start(name, &grecs_preproc_pid);\n\t\tif (!grecs_grecs_in) {\n\t\t\tgrecs_error(NULL, errno,\n\t\t\t\t     _(\"Unable to start external preprocessor `%s'\"),\n\t\t\t\t     grecs_preprocessor);\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\treturn grecs_preproc_init(name);\n\n\treturn 0;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_lex_end": {
      "start_point": [
        2523,
        0
      ],
      "end_point": [
        2527,
        1
      ],
      "content": "void\ngrecs_lex_end(int err)\n{\n\tgrecs_line_acc_free();\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "isemptystr": {
      "start_point": [
        2529,
        0
      ],
      "end_point": [
        2543,
        1
      ],
      "content": "static int\nisemptystr(int off)\n{\n\tfor (; grecs_grecs_text[off] && isspace(grecs_grecs_text[off]); off++)\n\t\t;\n\tif (grecs_grecs_text[off] == ';') {\n\t\tint i;\n\t\tfor (i = off + 1; grecs_grecs_text[i]; i++) \n\t\t\tif (!isspace(grecs_grecs_text[i]))\n\t\t\t\treturn 0;\n\t\tgrecs_grecs_less(off);\n\t\treturn 1;\n\t}\n\treturn grecs_grecs_text[off] == 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiline_strip_tabs": {
      "start_point": [
        2545,
        0
      ],
      "end_point": [
        2552,
        1
      ],
      "content": "char *\nmultiline_strip_tabs(char *text)\n{\n\tif (char_to_strip)\n\t\tfor (; *text && char_to_strip(*text); text++)\n\t\t\t;\n\treturn text;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "char",
        "*\nmultiline_strip_tabs(char *text)",
        "*"
      ]
    },
    "multiline_add": {
      "start_point": [
        2554,
        0
      ],
      "end_point": [
        2567,
        1
      ],
      "content": "static void\nmultiline_add(char *s)\n{\n\tif (multiline_unescape) {\n\t\tfor (; *s; s++)\t{\n\t\t\tif (*s == '\\\\') {\n\t\t\t\tgrecs_line_acc_grow_char_unescape(s[1]);\n\t\t\t\t++s;\n\t\t\t} else\n\t\t\t\tgrecs_line_acc_grow_char(*s);\n\t\t}\n\t} else\n\t\tgrecs_line_add(s, strlen(s));\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "is_tab": {
      "start_point": [
        2569,
        0
      ],
      "end_point": [
        2573,
        1
      ],
      "content": "static int\nis_tab(char c)\n{\n\treturn c == '\\t';\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "is_ws": {
      "start_point": [
        2575,
        0
      ],
      "end_point": [
        2579,
        1
      ],
      "content": "static int\nis_ws(char c)\n{\n\treturn c == '\\t' || c == ' ';\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "multiline_begin": {
      "start_point": [
        2581,
        0
      ],
      "end_point": [
        2619,
        1
      ],
      "content": "void\nmultiline_begin(char *p)\n{\n\tif (*p == '-') {\n\t\tif (*++p == ' ') {\n\t\t\tchar_to_strip = is_ws;\n\t\t\tp++;\n\t\t} else\n\t\t\tchar_to_strip = is_tab;\n\t} else\n\t\tchar_to_strip = NULL;\n\tif (*p == '\\\\') {\n\t\tp++;\n\t\tmultiline_unescape = 0;\n\t\tmultiline_delimiter_len = strcspn(p, \" \\t\");\n\t} else if (*p == '\"') {\n\t\tchar *q;\n \n\t\tp++;\n\t\tmultiline_unescape = 0;\n\t\tq = strchr(p, '\"');\n\t\tmultiline_delimiter_len = q - p;\n\t} else {\n\t\tmultiline_delimiter_len = strcspn(p, \" \\t\");\n\t\tmultiline_unescape = 1;\n\t}\n\n\t/* Remove trailing newline */\n\tmultiline_delimiter_len--;\n\tmultiline_delimiter = grecs_malloc(multiline_delimiter_len + 1);\n\tmemcpy(multiline_delimiter, p, multiline_delimiter_len);\n\tmultiline_delimiter[multiline_delimiter_len] = 0;\n\tgrecs_line_begin();\n\n\t/* Update locus */\n\tgrecs_locus_point_advance_line(grecs_current_locus_point);\n\tgrecs_grecs_lloc.beg = grecs_current_locus_point;\n\tgrecs_grecs_lloc.beg.col++;\n}",
      "lines": 39,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ident": {
      "start_point": [
        2621,
        0
      ],
      "end_point": [
        2636,
        1
      ],
      "content": "static int\nident()\n{\n\tchar *p;\n\tchar *str;\n\tsize_t len;\n  \n\tfor (p = grecs_grecs_text; *p && isspace(*p); p++)\n\t\t;\n\n\tlen = strlen(p);\n\tstr = grecs_malloc(len + 1);\n\tstrcpy(str, p);\n\tgrecs_grecs_lval.string = str;\n\treturn IDENT;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "qstring_locus_fixup": {
      "start_point": [
        2638,
        0
      ],
      "end_point": [
        2645,
        1
      ],
      "content": "static void\nqstring_locus_fixup()\n{\n\tif (grecs_adjust_string_locations) {\n\t\tgrecs_grecs_lloc.beg.col++;\n\t\tgrecs_grecs_lloc.end.col--;\n\t}\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_value_ptr_from_static": {
      "start_point": [
        2647,
        0
      ],
      "end_point": [
        2653,
        1
      ],
      "content": "grecs_value_t *\ngrecs_value_ptr_from_static(grecs_value_t *input)\n{\n\tgrecs_value_t *ptr = grecs_malloc(sizeof(*ptr));\n\t*ptr = *input;\n\treturn ptr;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "grecs_value_t",
        "*\ngrecs_value_ptr_from_static(grecs_value_t *input)",
        "*"
      ]
    },
    "assign_locus": {
      "start_point": [
        2656,
        0
      ],
      "end_point": [
        2670,
        1
      ],
      "content": "static int\nassign_locus(struct grecs_locus_point *ploc,\n\t     char *name, char *line, size_t *pxlines)\n{\n\tchar *p;\n\t\n\tif (name) {\n\t\tif (pxlines && (!ploc->file || strcmp(name, ploc->file)))\n\t\t\t*pxlines = 0;\n\t\tploc->file = grecs_install_text(name);\n\t}\n\tploc->line = strtoul(line, &p, 10) - (pxlines ? *pxlines : 0);\n\tploc->col = 0;\n\treturn *p != 0;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_parse_line_directive": {
      "start_point": [
        2672,
        0
      ],
      "end_point": [
        2707,
        1
      ],
      "content": "void\ngrecs_parse_line_directive(char *text, grecs_locus_t *ploc,\n\t\t\t   struct grecs_locus_point *ppoint, size_t *pxlines)\n{\n\tint rc = 1;\n\tstruct wordsplit ws;\n\t\n\tif (wordsplit(text, &ws, WRDSF_DEFFLAGS))\n\t\tgrecs_error(ploc, 0, _(\"cannot parse #line line: %s\"),\n\t\t\t    wordsplit_strerror(&ws));\n\telse {\n\t\tif (ws.ws_wordc == 2)\n\t\t\trc = assign_locus(ppoint, NULL,\n\t\t\t\t\t   ws.ws_wordv[1], pxlines);\n\t\telse if (ws.ws_wordc == 3) \n\t\t\trc = assign_locus(ppoint, ws.ws_wordv[2],\n\t\t\t\t\t   ws.ws_wordv[1], pxlines);\n\t\telse if (ws.ws_wordc == 4) {\n\t\t\trc = assign_locus(ppoint, ws.ws_wordv[2],\n\t\t\t\t\t   ws.ws_wordv[1], 0);\n\t\t\tif (pxlines && rc == 0) {\n\t\t\t\tchar *p;\n\t\t\t\tunsigned long x = strtoul(ws.ws_wordv[3],\n\t\t\t\t\t\t\t   &p, 10);\n\t\t\t\trc = *p != 0;\n\t\t\t\tif (rc == 0)\n\t\t\t\t\t*pxlines = x;\n\t\t\t}\n\t\t} else \n\t\t\tgrecs_error(ploc, 0, _(\"invalid #line statement\"));\n\t\n\t\tif (rc) \n\t\t\tgrecs_error(ploc, 0, _(\"malformed #line statement\"));\n\t\twordsplit_free(&ws);\n\t}\n}",
      "lines": 36,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "grecs_parse_line_directive_cpp": {
      "start_point": [
        2709,
        0
      ],
      "end_point": [
        2728,
        1
      ],
      "content": "void\ngrecs_parse_line_directive_cpp(char *text, grecs_locus_t *ploc,\n\t\t\t       struct grecs_locus_point *ppoint,\n\t\t\t       size_t *pxlines)\n{\n\tstruct wordsplit ws;\n\t\n\tif (wordsplit(text, &ws, WRDSF_DEFFLAGS)) {\n\t\tgrecs_error(ploc, 0, _(\"cannot parse #line line: %s\"),\n\t\t\t    wordsplit_strerror(&ws));\n\t\treturn;\n\t} else if (ws.ws_wordc < 3)\n\t\tgrecs_error(ploc, 0, _(\"invalid #line statement\"));\n\telse {\n\t\tif (assign_locus(ppoint, ws.ws_wordv[2],\n\t\t\t\t ws.ws_wordv[1], pxlines))\n\t\t\tgrecs_error(ploc, 0, _(\"malformed #line statement\"));\n\t}\n\twordsplit_free(&ws);\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/grecs-lex.l": {
    "nounput": {
      "start_point": [
        1,
        1
      ],
      "end_point": [
        7,
        1
      ],
      "content": "option nounput\n%option noinput\n%top {\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\t\n}",
      "lines": 7,
      "depth": 5,
      "decorators": null
    }
  },
  "direvent/direvent-5.1/grecs/src/ipstr.c": {
    "grecs_str_is_ipv4": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int \ngrecs_str_is_ipv4(const char *addr)\n{\n        int dot_count = 0;\n        int digit_count = 0;\n\n\tfor (; *addr; addr++) {\n\t\tif (!isascii(*addr))\n\t\t\treturn 0;\n                if (*addr == '.') {\n                        if (++dot_count > 3)\n                                break;\n                        digit_count = 0;\n                } else if (!(isdigit(*addr) && ++digit_count <= 3))\n                        return 0;\n        }\n\n        return (dot_count == 3);\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "grecs_str_is_ipv6": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int \ngrecs_str_is_ipv6(const char *addr)\n{\n        int col_count = 0; /* Number of colons */\n\tint dcol = 0;      /* Did we encounter a double-colon? */\n\tint dig_count = 0; /* Number of digits in the last group */\n\t\n\tfor (; *addr; addr++) {\n\t\tif (!isascii(*addr))\n\t\t\treturn 0;\n\t\telse if (isxdigit(*addr)) {\n\t\t\tif (++dig_count > 4)\n\t\t\t\treturn 0;\n\t\t} else if (*addr == ':') {\n\t\t\tif (col_count && dig_count == 0 && ++dcol > 1)\n\t\t\t\treturn 0;\n\t\t\tif (++col_count > 7)\n\t\t\t\treturn 0;\n\t\t\tdig_count = 0;\n\t\t} else\n\t\t\treturn 0;\n\t}\n\n\treturn (col_count == 7 || dcol);\n}",
      "lines": 25,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "grecs_str_is_num": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\ngrecs_str_is_num(const char *s)\n{\n\tfor (; *s; ++s)\n\t\tif (!isdigit(*s))\n\t\t\treturn 0;\n\treturn 1;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "grecs_str_is_ipaddr": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\ngrecs_str_is_ipaddr(const char *addr)\n{\n\tif (strchr (addr, '.'))\n\t\treturn grecs_str_is_ipv4(addr);\n\telse if (strchr (addr, ':'))\n\t\treturn grecs_str_is_ipv6(addr);\n\treturn 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/join.c": {
    "reset_point": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\nreset_point(struct grecs_locus_point *point, struct grecs_symtab *st)\n{\n\tstruct grecs_syment *ent, key;\n\tint install = 1;\n\n\tif (!point->file)\n\t\treturn;\n\tkey.name = (char*) point->file;\n\tent = grecs_symtab_lookup_or_install(st, &key, &install);\n\tif (!ent)\n\t\tgrecs_alloc_die();\n\tpoint->file = ent->name;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "reset_locus": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static enum grecs_tree_recurse_res\nreset_locus(enum grecs_tree_recurse_op op, struct grecs_node *node, void *data)\n{\n\tstruct grecs_symtab *st = data;\n\tswitch (op) {\n\tcase grecs_tree_recurse_set:\n\tcase grecs_tree_recurse_pre:\n\t\treset_point(&node->locus.beg, st);\n\t\treset_point(&node->locus.end, st);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn grecs_tree_recurse_ok;\n\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_tree_join": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\ngrecs_tree_join(struct grecs_node *dst, struct grecs_node *src)\n{\n\tstruct grecs_node *p;\n\t\n\tif (dst->type != grecs_node_root || src->type != grecs_node_root)\n\t\treturn 1;\n\tgrecs_node_bind(dst, src->down, 1);\n\tfor (p = src->down; p; p = p->next)\n\t\tp->up = dst;\n\tif (!src->v.texttab) {\n\t\tdst->v.texttab = src->v.texttab;\n\t} else {\n\t\tgrecs_tree_recurse(src->down, reset_locus, dst->v.texttab);\n\t\tgrecs_symtab_free(src->v.texttab);\n\t}\n\tsrc->v.texttab = NULL;\n\tsrc->down = NULL;\n\treturn 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/json-gram.c": {
    "pairfree": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "static void\npairfree(void *ptr)\n{\n\tstruct json_pair *p = ptr;\n\tgrecs_free(p->k);\n\tjson_value_free(p->v);\n\tfree(p);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "objfree": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void\nobjfree(void *ptr)\n{\n\tstruct json_value *o = ptr;\n\tjson_value_free(o);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json_tnamerr": {
      "start_point": [
        962,
        0
      ],
      "end_point": [
        999,
        1
      ],
      "content": "static YYSIZE_T\ngrecs_json_tnamerr (char *grecs_json_res, const char *grecs_json_str)\n{\n  if (*grecs_json_str == '\"')\n    {\n      YYSIZE_T grecs_json_n = 0;\n      char const *grecs_json_p = grecs_json_str;\n\n      for (;;)\n\tswitch (*++grecs_json_p)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++grecs_json_p != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (grecs_json_res)\n\t      grecs_json_res[grecs_json_n] = *grecs_json_p;\n\t    grecs_json_n++;\n\t    break;\n\n\t  case '\"':\n\t    if (grecs_json_res)\n\t      grecs_json_res[grecs_json_n] = '\\0';\n\t    return grecs_json_n;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! grecs_json_res)\n    return grecs_json_strlen (grecs_json_str);\n\n  return grecs_json_stpcpy (grecs_json_res, grecs_json_str) - grecs_json_res;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "grecs_json_syntax_error": {
      "start_point": [
        1010,
        0
      ],
      "end_point": [
        1136,
        1
      ],
      "content": "static int\ngrecs_json_syntax_error (YYSIZE_T *grecs_json_msg_alloc, char **grecs_json_msg,\n                grecs_json_type_int16 *grecs_json_ssp, int grecs_json_token)\n{\n  YYSIZE_T grecs_json_size0 = grecs_json_tnamerr (YY_NULL, grecs_json_tname[grecs_json_token]);\n  YYSIZE_T grecs_json_size = grecs_json_size0;\n  YYSIZE_T grecs_json_size1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *grecs_json_format = YY_NULL;\n  /* Arguments of grecs_json_format. */\n  char const *grecs_json_arg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int grecs_json_count = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in grecs_json_char) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated grecs_json_char.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (grecs_json_token != YYEMPTY)\n    {\n      int grecs_json_n = grecs_json_pact[*grecs_json_ssp];\n      grecs_json_arg[grecs_json_count++] = grecs_json_tname[grecs_json_token];\n      if (!grecs_json_pact_value_is_default (grecs_json_n))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int grecs_json_xbegin = grecs_json_n < 0 ? -grecs_json_n : 0;\n          /* Stay within bounds of both grecs_json_check and grecs_json_tname.  */\n          int grecs_json_checklim = YYLAST - grecs_json_n + 1;\n          int grecs_json_xend = grecs_json_checklim < YYNTOKENS ? grecs_json_checklim : YYNTOKENS;\n          int grecs_json_x;\n\n          for (grecs_json_x = grecs_json_xbegin; grecs_json_x < grecs_json_xend; ++grecs_json_x)\n            if (grecs_json_check[grecs_json_x + grecs_json_n] == grecs_json_x && grecs_json_x != YYTERROR\n                && !grecs_json_table_value_is_error (grecs_json_table[grecs_json_x + grecs_json_n]))\n              {\n                if (grecs_json_count == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    grecs_json_count = 1;\n                    grecs_json_size = grecs_json_size0;\n                    break;\n                  }\n                grecs_json_arg[grecs_json_count++] = grecs_json_tname[grecs_json_x];\n                grecs_json_size1 = grecs_json_size + grecs_json_tnamerr (YY_NULL, grecs_json_tname[grecs_json_x]);\n                if (! (grecs_json_size <= grecs_json_size1\n                       && grecs_json_size1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                grecs_json_size = grecs_json_size1;\n              }\n        }\n    }\n\n  switch (grecs_json_count)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        grecs_json_format = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  grecs_json_size1 = grecs_json_size + grecs_json_strlen (grecs_json_format);\n  if (! (grecs_json_size <= grecs_json_size1 && grecs_json_size1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  grecs_json_size = grecs_json_size1;\n\n  if (*grecs_json_msg_alloc < grecs_json_size)\n    {\n      *grecs_json_msg_alloc = 2 * grecs_json_size;\n      if (! (grecs_json_size <= *grecs_json_msg_alloc\n             && *grecs_json_msg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *grecs_json_msg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *grecs_json_p = *grecs_json_msg;\n    int grecs_json_i = 0;\n    while ((*grecs_json_p = *grecs_json_format) != '\\0')\n      if (*grecs_json_p == '%' && grecs_json_format[1] == 's' && grecs_json_i < grecs_json_count)\n        {\n          grecs_json_p += grecs_json_tnamerr (grecs_json_p, grecs_json_arg[grecs_json_i++]);\n          grecs_json_format += 2;\n        }\n      else\n        {\n          grecs_json_p++;\n          grecs_json_format++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_json_error": {
      "start_point": [
        1897,
        0
      ],
      "end_point": [
        1902,
        1
      ],
      "content": "static int\ngrecs_json_error(char const *s)\n{\n\tjsonlex_diag(s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_value_create": {
      "start_point": [
        1904,
        0
      ],
      "end_point": [
        1910,
        1
      ],
      "content": "struct json_value *\njson_value_create(int type)\n{\n\tstruct json_value *obj = grecs_zalloc(sizeof(*obj));\n\tobj->type = type;\n\treturn obj;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_value_create(int type)",
        "*"
      ]
    },
    "json_value_free": {
      "start_point": [
        1912,
        0
      ],
      "end_point": [
        1942,
        1
      ],
      "content": "void\njson_value_free(struct json_value *obj)\n{\n\tsize_t i;\n\t\n\tif (!obj)\n\t\treturn;\n\n\tswitch (obj->type) {\n\tcase json_null:\n        case json_bool:\n        case json_number:\n\t\tbreak;\n\tcase json_string:\n\t\tgrecs_free(obj->v.s);\n\t\tbreak;\n\tcase json_arr:\n\t\tfor (i = 0; i < obj->v.a->oc; i++)\n\t\t\tjson_value_free(obj->v.a->ov[i]);\n\t\tgrecs_free (obj->v.a->ov);\n\t\tif (obj->v.a->ol) {\n\t\t\tobj->v.a->ol->free_entry = objfree;\n\t\t\tgrecs_list_free(obj->v.a->ol);\n\t\t}\n\t\tgrecs_free(obj->v.a);\n\t\tbreak;\n\tcase json_object:\n\t\tgrecs_symtab_free(obj->v.o);\n\t}\n\tfree(obj);\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "json_st_hash": {
      "start_point": [
        1944,
        0
      ],
      "end_point": [
        1949,
        1
      ],
      "content": "static unsigned\njson_st_hash(void *data, unsigned long n_buckets)\n{\n\tstruct json_pair *p = data;\n\treturn grecs_hash_string(p->k, n_buckets);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "json_st_cmp": {
      "start_point": [
        1951,
        0
      ],
      "end_point": [
        1957,
        1
      ],
      "content": "static int\njson_st_cmp(const void *a, const void *b)\n{\n\tstruct json_pair const *pa = a;\n\tstruct json_pair const *pb = b;\n\treturn strcmp(pa->k, pb->k);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_st_copy": {
      "start_point": [
        1959,
        0
      ],
      "end_point": [
        1966,
        1
      ],
      "content": "static int\njson_st_copy(void *a, void *b)\n{\n\tstruct json_pair *pa = a;\n\tstruct json_pair *pb = b;\n\tmemcpy(pa, pb, sizeof(*pa));\n\treturn 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_st_free": {
      "start_point": [
        1968,
        0
      ],
      "end_point": [
        1975,
        1
      ],
      "content": "static void\njson_st_free(void *ptr)\n{\n\tstruct json_pair *p = ptr;\n\tfree(p->k);\n\tjson_value_free(p->v);\n\tfree(p);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_assoc_create": {
      "start_point": [
        1977,
        0
      ],
      "end_point": [
        1986,
        1
      ],
      "content": "struct grecs_symtab *\njson_assoc_create()\n{\n\treturn grecs_symtab_create(sizeof(struct json_pair),\n\t\t\t\t   json_st_hash,\n\t\t\t\t   json_st_cmp,\n\t\t\t\t   json_st_copy,\n\t\t\t\t   NULL,\n\t\t\t\t   json_st_free);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "struct grecs_symtab",
        "struct",
        "grecs_symtab",
        "*\njson_assoc_create()",
        "*"
      ]
    },
    "json_parse_string": {
      "start_point": [
        1988,
        0
      ],
      "end_point": [
        1997,
        1
      ],
      "content": "struct json_value *\njson_parse_string(char const *input, size_t len)\n{\n\tjsonlex_setup(input, len);\n\tif (grecs_json_parse()) {\n\t\t/* FIXME: error recovery */\n\t\treturn NULL;\n\t}\n\treturn json_return_obj;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_parse_string(char const *input, size_t len)",
        "*"
      ]
    },
    "json_value_lookup": {
      "start_point": [
        1999,
        0
      ],
      "end_point": [
        2059,
        1
      ],
      "content": "struct json_value *\njson_value_lookup(struct json_value *obj, const char *ident)\n{\n\tchar *qbuf = NULL;\n\tsize_t qlen = 0;\n\t\n\twhile (obj && *ident) {\n\t\tchar const *p;\n\t\tchar *q;\n\t\tsize_t l;\n\t\t\n\t\tfor (p = ident; *p; p++) {\n\t\t\tif (*p == '\\\\')\n\t\t\t\t++p;\n\t\t\telse if (*p == '.')\n\t\t\t\tbreak;\n\t\t}\n\t\tl = p - ident + 1;\n\t\tif (l > qlen) {\n\t\t\tqlen = l;\n\t\t\tqbuf = grecs_realloc(qbuf, qlen);\n\t\t}\n\t\tq = qbuf;\n\t\twhile (*ident) {\n\t\t\tif (*ident == '\\\\') {\n\t\t\t\tchar c;\n\t\t\t\t++ident;\n\t\t\t\tif (json_unescape(*ident, &c))\n\t\t\t\t\t*q++ = *ident++;\n\t\t\t\telse\n\t\t\t\t\t*q++ = c;\n\t\t\t} else if (*ident == '.') {\n\t\t\t\t++ident;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\t*q++ = *ident++;\n\t\t}\n\t\t*q = 0;\n\t\t\n\t\tswitch (obj->type) {\n\t\tcase json_null:\n\t\tcase json_bool:\n\t\tcase json_number:\n\t\tcase json_string:\n\t\t\tobj = NULL;\n\t\t\tbreak;\n\t\tcase json_arr:\n\t\t\tl = strtoul(qbuf, &q, 10);\n\t\t\tif (*q != 0 || json_array_get(obj, l, &obj))\n\t\t\t\tobj = NULL;\n\t\t\tbreak;\n\t\tcase json_object:\n\t\t\tif (json_object_get(obj, qbuf, &obj))\n\t\t\t\tobj = NULL;\n\t\t}\t\n\t}\n\tif (*ident)\n\t\tobj = NULL;\n\tfree(qbuf);\n\treturn obj;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_value_lookup(struct json_value *obj, const char *ident)",
        "*"
      ]
    },
    "json_new_string": {
      "start_point": [
        2061,
        0
      ],
      "end_point": [
        2067,
        1
      ],
      "content": "struct json_value *\njson_new_string(char const *str)\n{\n\tstruct json_value *j = json_value_create(json_string);\n\tj->v.s = grecs_strdup(str);\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_string(char const *str)",
        "*"
      ]
    },
    "json_new_number": {
      "start_point": [
        2069,
        0
      ],
      "end_point": [
        2075,
        1
      ],
      "content": "struct json_value *\njson_new_number(double n)\n{\n\tstruct json_value *j = json_value_create(json_number);\n\tj->v.n = n;\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_number(double n)",
        "*"
      ]
    },
    "json_new_bool": {
      "start_point": [
        2077,
        0
      ],
      "end_point": [
        2083,
        1
      ],
      "content": "struct json_value *\njson_new_bool(int b)\n{\n\tstruct json_value *j = json_value_create(json_bool);\n\tj->v.b = b;\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_bool(int b)",
        "*"
      ]
    },
    "json_new_null": {
      "start_point": [
        2085,
        0
      ],
      "end_point": [
        2089,
        1
      ],
      "content": "struct json_value *\njson_new_null(void)\n{\n\treturn json_value_create(json_null);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_null(void)",
        "*"
      ]
    },
    "json_new_object": {
      "start_point": [
        2091,
        0
      ],
      "end_point": [
        2097,
        1
      ],
      "content": "struct json_value *\njson_new_object(void)\n{\n\tstruct json_value *j = json_value_create(json_object);\n\tj->v.o = json_assoc_create();\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_object(void)",
        "*"
      ]
    },
    "json_object_set": {
      "start_point": [
        2099,
        0
      ],
      "end_point": [
        2116,
        1
      ],
      "content": "int\njson_object_set(struct json_value *obj, char const *name,\n\t\tstruct json_value *val)\n{\n\tstruct json_pair pair, *ret;\n\tint install;\n\tif (obj->type != json_object) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tpair.k = (char*) name;\n\tpair.v = NULL;\n\tret = grecs_symtab_lookup_or_install(obj->v.o, &pair, &install);\n\tif (install)\n\t\tret->k = grecs_strdup(ret->k);\n\tret->v = val;\n\treturn 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_object_get": {
      "start_point": [
        2118,
        0
      ],
      "end_point": [
        2135,
        1
      ],
      "content": "int\njson_object_get(struct json_value *obj, char const *name,\n\t\tstruct json_value **retval)\n{\n\tstruct json_pair pair, *ret;\n\tif (obj->type != json_object) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tpair.k = (char*) name;\n\tpair.v = NULL;\n\tret = grecs_symtab_lookup_or_install(obj->v.o, &pair, NULL);\n\tif (ret) {\n\t\t*retval = ret->v;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_new_array": {
      "start_point": [
        2137,
        0
      ],
      "end_point": [
        2146,
        1
      ],
      "content": "struct json_value *\njson_new_array(void)\n{\n\tstruct json_value *j = json_value_create(json_arr);\n\tj->v.a = grecs_malloc(sizeof(*j->v.a));\n\tj->v.a->oc = 0;\n\tj->v.a->ov = NULL;\n\tj->v.a->ol = NULL;\n\treturn j;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_array(void)",
        "*"
      ]
    },
    "json_array_size": {
      "start_point": [
        2148,
        0
      ],
      "end_point": [
        2156,
        1
      ],
      "content": "size_t\njson_array_size(struct json_value *j)\n{\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\treturn j->v.a->oc + grecs_list_size(j->v.a->ol);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "json_array_flatten": {
      "start_point": [
        2158,
        0
      ],
      "end_point": [
        2176,
        1
      ],
      "content": "void\njson_array_flatten(struct json_value *j)\n{\n\tsize_t size, i;\n\tstruct grecs_list_entry *ep;\n\n\tsize = grecs_list_size(j->v.a->ol);\n\n\tif (size == 0)\n\t\treturn;\n\n\tj->v.a->ov = grecs_realloc(j->v.a->ov,\n\t\t\t\t (j->v.a->oc + size) * sizeof(j->v.a->ov[0]));\n\n\tfor (ep = j->v.a->ol->head, i = j->v.a->oc; ep; ep = ep->next, i++)\n\t\tj->v.a->ov[i] = ep->data;\n\tj->v.a->oc = i;\n\tgrecs_list_clear(j->v.a->ol);\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "json_array_insert": {
      "start_point": [
        2178,
        0
      ],
      "end_point": [
        2197,
        1
      ],
      "content": "int\njson_array_insert(struct json_value *j, size_t idx, struct json_value *v)\n{\n\tsize_t size;\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tsize = json_array_size(j);\n\tif (idx < size) {\n\t\tjson_array_flatten(j);\n\t\tj->v.a->ov[idx] = v;\n\t} else {\n\t\tsize_t i;\n\t\tfor (i = size; i < idx; i++)\n\t\t\tjson_array_append(j, NULL);\n\t\tjson_array_append(j, v);\n\t}\n\treturn 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "json_array_append": {
      "start_point": [
        2199,
        0
      ],
      "end_point": [
        2211,
        1
      ],
      "content": "int\njson_array_append(struct json_value *j, struct json_value *v)\n{\n \tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (!j->v.a->ol)\n\t\tj->v.a->ol = grecs_list_create();\n\tgrecs_list_append(j->v.a->ol, v);\n\treturn 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_array_set": {
      "start_point": [
        2213,
        0
      ],
      "end_point": [
        2227,
        1
      ],
      "content": "int\njson_array_set(struct json_value *j, size_t idx, struct json_value *v)\n{\n \tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (idx >= json_array_size(j)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\tjson_array_flatten(j);\n\tj->v.a->ov[idx] = v;\n\treturn 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_array_get": {
      "start_point": [
        2229,
        0
      ],
      "end_point": [
        2244,
        1
      ],
      "content": "int\njson_array_get(struct json_value *j, size_t idx, struct json_value **retval)\n{\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (idx >= json_array_size(j)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\t\t\n\tjson_array_flatten(j);\n\t*retval = j->v.a->ov[idx];\n\treturn 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/json-gram.y": {
    "pairfree": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "static void\npairfree(void *ptr)\n{\n\tstruct json_pair *p = ptr;\n\tgrecs_free(p->k);\n\tjson_value_free(p->v);\n\tfree(p);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "objfree": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\nobjfree(void *ptr)\n{\n\tstruct json_value *o = ptr;\n\tjson_value_free(o);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "input": {
      "start_point": [
        63,
        1
      ],
      "end_point": [
        77,
        4
      ],
      "content": "union {\n\tint b;\n\tdouble n;\n\tchar *s;\n\tstruct grecs_symtab *o;\n\tstruct json_value *obj;\n\tstruct grecs_list *list;\n\tstruct json_pair *p;\n}\n%%\n\ninput   : object\n          {\n  \t      json_return_obj = $1;\n\t  }",
      "lines": 15,
      "depth": 6,
      "decorators": null
    },
    "yyerror": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static int\nyyerror(char const *s)\n{\n\tjsonlex_diag(s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_value_create": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "struct json_value *\njson_value_create(int type)\n{\n\tstruct json_value *obj = grecs_zalloc(sizeof(*obj));\n\tobj->type = type;\n\treturn obj;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_value_create(int type)",
        "*"
      ]
    },
    "json_value_free": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "void\njson_value_free(struct json_value *obj)\n{\n\tsize_t i;\n\t\n\tif (!obj)\n\t\treturn;\n\n\tswitch (obj->type) {\n\tcase json_null:\n        case json_bool:\n        case json_number:\n\t\tbreak;\n\tcase json_string:\n\t\tgrecs_free(obj->v.s);\n\t\tbreak;\n\tcase json_arr:\n\t\tfor (i = 0; i < obj->v.a->oc; i++)\n\t\t\tjson_value_free(obj->v.a->ov[i]);\n\t\tgrecs_free (obj->v.a->ov);\n\t\tif (obj->v.a->ol) {\n\t\t\tobj->v.a->ol->free_entry = objfree;\n\t\t\tgrecs_list_free(obj->v.a->ol);\n\t\t}\n\t\tgrecs_free(obj->v.a);\n\t\tbreak;\n\tcase json_object:\n\t\tgrecs_symtab_free(obj->v.o);\n\t}\n\tfree(obj);\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "json_st_hash": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static unsigned\njson_st_hash(void *data, unsigned long n_buckets)\n{\n\tstruct json_pair *p = data;\n\treturn grecs_hash_string(p->k, n_buckets);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "json_st_cmp": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "static int\njson_st_cmp(const void *a, const void *b)\n{\n\tstruct json_pair const *pa = a;\n\tstruct json_pair const *pb = b;\n\treturn strcmp(pa->k, pb->k);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_st_copy": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static int\njson_st_copy(void *a, void *b)\n{\n\tstruct json_pair *pa = a;\n\tstruct json_pair *pb = b;\n\tmemcpy(pa, pb, sizeof(*pa));\n\treturn 0;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_st_free": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "static void\njson_st_free(void *ptr)\n{\n\tstruct json_pair *p = ptr;\n\tfree(p->k);\n\tjson_value_free(p->v);\n\tfree(p);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_assoc_create": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "struct grecs_symtab *\njson_assoc_create()\n{\n\treturn grecs_symtab_create(sizeof(struct json_pair),\n\t\t\t\t   json_st_hash,\n\t\t\t\t   json_st_cmp,\n\t\t\t\t   json_st_copy,\n\t\t\t\t   NULL,\n\t\t\t\t   json_st_free);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "struct grecs_symtab",
        "struct",
        "grecs_symtab",
        "*\njson_assoc_create()",
        "*"
      ]
    },
    "json_parse_string": {
      "start_point": [
        274,
        0
      ],
      "end_point": [
        283,
        1
      ],
      "content": "struct json_value *\njson_parse_string(char const *input, size_t len)\n{\n\tjsonlex_setup(input, len);\n\tif (yyparse()) {\n\t\t/* FIXME: error recovery */\n\t\treturn NULL;\n\t}\n\treturn json_return_obj;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_parse_string(char const *input, size_t len)",
        "*"
      ]
    },
    "json_value_lookup": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "struct json_value *\njson_value_lookup(struct json_value *obj, const char *ident)\n{\n\tchar *qbuf = NULL;\n\tsize_t qlen = 0;\n\t\n\twhile (obj && *ident) {\n\t\tchar const *p;\n\t\tchar *q;\n\t\tsize_t l;\n\t\t\n\t\tfor (p = ident; *p; p++) {\n\t\t\tif (*p == '\\\\')\n\t\t\t\t++p;\n\t\t\telse if (*p == '.')\n\t\t\t\tbreak;\n\t\t}\n\t\tl = p - ident + 1;\n\t\tif (l > qlen) {\n\t\t\tqlen = l;\n\t\t\tqbuf = grecs_realloc(qbuf, qlen);\n\t\t}\n\t\tq = qbuf;\n\t\twhile (*ident) {\n\t\t\tif (*ident == '\\\\') {\n\t\t\t\tchar c;\n\t\t\t\t++ident;\n\t\t\t\tif (json_unescape(*ident, &c))\n\t\t\t\t\t*q++ = *ident++;\n\t\t\t\telse\n\t\t\t\t\t*q++ = c;\n\t\t\t} else if (*ident == '.') {\n\t\t\t\t++ident;\n\t\t\t\tbreak;\n\t\t\t} else\n\t\t\t\t*q++ = *ident++;\n\t\t}\n\t\t*q = 0;\n\t\t\n\t\tswitch (obj->type) {\n\t\tcase json_null:\n\t\tcase json_bool:\n\t\tcase json_number:\n\t\tcase json_string:\n\t\t\tobj = NULL;\n\t\t\tbreak;\n\t\tcase json_arr:\n\t\t\tl = strtoul(qbuf, &q, 10);\n\t\t\tif (*q != 0 || json_array_get(obj, l, &obj))\n\t\t\t\tobj = NULL;\n\t\t\tbreak;\n\t\tcase json_object:\n\t\t\tif (json_object_get(obj, qbuf, &obj))\n\t\t\t\tobj = NULL;\n\t\t}\t\n\t}\n\tif (*ident)\n\t\tobj = NULL;\n\tfree(qbuf);\n\treturn obj;\n}",
      "lines": 61,
      "depth": 14,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_value_lookup(struct json_value *obj, const char *ident)",
        "*"
      ]
    },
    "json_new_string": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "struct json_value *\njson_new_string(char const *str)\n{\n\tstruct json_value *j = json_value_create(json_string);\n\tj->v.s = grecs_strdup(str);\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_string(char const *str)",
        "*"
      ]
    },
    "json_new_number": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "struct json_value *\njson_new_number(double n)\n{\n\tstruct json_value *j = json_value_create(json_number);\n\tj->v.n = n;\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_number(double n)",
        "*"
      ]
    },
    "json_new_bool": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "struct json_value *\njson_new_bool(int b)\n{\n\tstruct json_value *j = json_value_create(json_bool);\n\tj->v.b = b;\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_bool(int b)",
        "*"
      ]
    },
    "json_new_null": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        375,
        1
      ],
      "content": "struct json_value *\njson_new_null(void)\n{\n\treturn json_value_create(json_null);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_null(void)",
        "*"
      ]
    },
    "json_new_object": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        383,
        1
      ],
      "content": "struct json_value *\njson_new_object(void)\n{\n\tstruct json_value *j = json_value_create(json_object);\n\tj->v.o = json_assoc_create();\n\treturn j;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_object(void)",
        "*"
      ]
    },
    "json_object_set": {
      "start_point": [
        385,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "int\njson_object_set(struct json_value *obj, char const *name,\n\t\tstruct json_value *val)\n{\n\tstruct json_pair pair, *ret;\n\tint install;\n\tif (obj->type != json_object) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tpair.k = (char*) name;\n\tpair.v = NULL;\n\tret = grecs_symtab_lookup_or_install(obj->v.o, &pair, &install);\n\tif (install)\n\t\tret->k = grecs_strdup(ret->k);\n\tret->v = val;\n\treturn 0;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_object_get": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        421,
        1
      ],
      "content": "int\njson_object_get(struct json_value *obj, char const *name,\n\t\tstruct json_value **retval)\n{\n\tstruct json_pair pair, *ret;\n\tif (obj->type != json_object) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tpair.k = (char*) name;\n\tpair.v = NULL;\n\tret = grecs_symtab_lookup_or_install(obj->v.o, &pair, NULL);\n\tif (ret) {\n\t\t*retval = ret->v;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_new_array": {
      "start_point": [
        423,
        0
      ],
      "end_point": [
        432,
        1
      ],
      "content": "struct json_value *\njson_new_array(void)\n{\n\tstruct json_value *j = json_value_create(json_arr);\n\tj->v.a = grecs_malloc(sizeof(*j->v.a));\n\tj->v.a->oc = 0;\n\tj->v.a->ov = NULL;\n\tj->v.a->ol = NULL;\n\treturn j;\n}",
      "lines": 10,
      "depth": 12,
      "decorators": [
        "struct json_value",
        "struct",
        "json_value",
        "*\njson_new_array(void)",
        "*"
      ]
    },
    "json_array_size": {
      "start_point": [
        434,
        0
      ],
      "end_point": [
        442,
        1
      ],
      "content": "size_t\njson_array_size(struct json_value *j)\n{\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn 0;\n\t}\n\treturn j->v.a->oc + grecs_list_size(j->v.a->ol);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "json_array_flatten": {
      "start_point": [
        444,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "void\njson_array_flatten(struct json_value *j)\n{\n\tsize_t size, i;\n\tstruct grecs_list_entry *ep;\n\n\tsize = grecs_list_size(j->v.a->ol);\n\n\tif (size == 0)\n\t\treturn;\n\n\tj->v.a->ov = grecs_realloc(j->v.a->ov,\n\t\t\t\t (j->v.a->oc + size) * sizeof(j->v.a->ov[0]));\n\n\tfor (ep = j->v.a->ol->head, i = j->v.a->oc; ep; ep = ep->next, i++)\n\t\tj->v.a->ov[i] = ep->data;\n\tj->v.a->oc = i;\n\tgrecs_list_clear(j->v.a->ol);\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "json_array_insert": {
      "start_point": [
        464,
        0
      ],
      "end_point": [
        483,
        1
      ],
      "content": "int\njson_array_insert(struct json_value *j, size_t idx, struct json_value *v)\n{\n\tsize_t size;\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tsize = json_array_size(j);\n\tif (idx < size) {\n\t\tjson_array_flatten(j);\n\t\tj->v.a->ov[idx] = v;\n\t} else {\n\t\tsize_t i;\n\t\tfor (i = size; i < idx; i++)\n\t\t\tjson_array_append(j, NULL);\n\t\tjson_array_append(j, v);\n\t}\n\treturn 0;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "json_array_append": {
      "start_point": [
        485,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "int\njson_array_append(struct json_value *j, struct json_value *v)\n{\n \tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tif (!j->v.a->ol)\n\t\tj->v.a->ol = grecs_list_create();\n\tgrecs_list_append(j->v.a->ol, v);\n\treturn 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_array_set": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        513,
        1
      ],
      "content": "int\njson_array_set(struct json_value *j, size_t idx, struct json_value *v)\n{\n \tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (idx >= json_array_size(j)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\tjson_array_flatten(j);\n\tj->v.a->ov[idx] = v;\n\treturn 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "json_array_get": {
      "start_point": [
        515,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "int\njson_array_get(struct json_value *j, size_t idx, struct json_value **retval)\n{\n\tif (j->type != json_arr) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\tif (idx >= json_array_size(j)) {\n\t\terrno = ENOENT;\n\t\treturn -1;\n\t}\n\t\t\n\tjson_array_flatten(j);\n\t*retval = j->v.a->ov[idx];\n\treturn 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/json-lex.c": {
    "jsonlex_setup": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        655,
        1
      ],
      "content": "void\njsonlex_setup(char const *s, size_t l)\n{\n\tinput_ptr = s;\n\tinput_size = l;\n\tjson_current_locus_point.file = NULL;\n\tjson_current_locus_point.line = 1;\n\tjson_current_locus_point.col = 0;\n\tjson_err_diag = NULL;\n\tgrecs_json__flex_debug = 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "jsonlex_diag": {
      "start_point": [
        657,
        0
      ],
      "end_point": [
        664,
        1
      ],
      "content": "void\njsonlex_diag(const char *s)\n{\n\tif (!json_err_diag) {\n\t\tjson_err_diag = s;\n\t\tjson_err_locus = grecs_json_lloc;\n\t}\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "utf8_wctomb": {
      "start_point": [
        666,
        0
      ],
      "end_point": [
        715,
        1
      ],
      "content": "static int\nutf8_wctomb(char *u)\n{\n\tunsigned int wc = strtoul(u, NULL, 16);\n\tint count;\n\tchar r[6];\n\t\n\tif (wc < 0x80)\n\t\tcount = 1;\n\telse if (wc < 0x800)\n\t\tcount = 2;\n\telse if (wc < 0x10000)\n\t\tcount = 3;\n\telse if (wc < 0x200000)\n\t\tcount = 4;\n\telse if (wc < 0x4000000)\n\t\tcount = 5;\n\telse if (wc <= 0x7fffffff)\n\t\tcount = 6;\n\telse\n\t\treturn -1;\n\n\tswitch (count) {\n\t\t/* Note: code falls through cases! */\n\tcase 6:\n\t\tr[5] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x4000000;\n\tcase 5:\n\t\tr[4] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x200000;\n\tcase 4:\n\t\tr[3] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x10000;\n\tcase 3:\n\t\tr[2] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x800;\n\tcase 2:\n\t\tr[1] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0xc0;\n\tcase 1:\n\t\tr[0] = wc;\n\t}\n\tgrecs_line_acc_grow(r, count);\n\treturn count;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_unescape": {
      "start_point": [
        717,
        0
      ],
      "end_point": [
        730,
        1
      ],
      "content": "int\njson_unescape(char c, char *o)\n{\n\tstatic char transtab[] = \"\\\\\\\\\\\"\\\"b\\bf\\fn\\nr\\rt\\t\";\n\tchar *p;\n\n\tfor (p = transtab; *p; p += 2) {\n\t\tif (p[0] == c) {\n\t\t\t*o = p[1];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "grecs_json_wrap": {
      "start_point": [
        733,
        0
      ],
      "end_point": [
        737,
        1
      ],
      "content": "static int\ngrecs_json_wrap()\n{\n\treturn 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_line_begin": {
      "start_point": [
        741,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "static void\njson_line_begin()\n{\n\tif (!json_line_acc)\n\t\tjson_line_acc = grecs_txtacc_create();\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_line_finish": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        757,
        1
      ],
      "content": "static char *\njson_line_finish()\n{\n\tif (json_line_acc) {\n\t\tchar nil = 0;\n\t\tgrecs_txtacc_grow(json_line_acc, &nil, 1);\n\t\treturn grecs_txtacc_finish(json_line_acc, 1);\n\t}\n\treturn NULL;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\njson_line_finish()",
        "*"
      ]
    },
    "json_line_grow": {
      "start_point": [
        759,
        0
      ],
      "end_point": [
        763,
        1
      ],
      "content": "static void\njson_line_grow(char const *text, size_t len)\t\n{\n\tgrecs_txtacc_grow(json_line_acc, text, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json__get_next_buffer": {
      "start_point": [
        1389,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "static int grecs_json__get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf;\n\tregister char *source = (grecs_json_text_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (grecs_json__c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf[(grecs_json__n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_json__fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (grecs_json__c_buf_p) - (grecs_json_text_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((grecs_json__c_buf_p) - (grecs_json_text_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_json__buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__n_chars = (grecs_json__n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint grecs_json__c_buf_p_offset =\n\t\t\t\t(int) ((grecs_json__c_buf_p) - b->grecs_json__ch_buf);\n\n\t\t\tif ( b->grecs_json__is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->grecs_json__buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->grecs_json__buf_size += b->grecs_json__buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->grecs_json__buf_size *= 2;\n\n\t\t\t\tb->grecs_json__ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tgrecs_json_realloc((void *) b->grecs_json__ch_buf,b->grecs_json__buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->grecs_json__ch_buf = 0;\n\n\t\t\tif ( ! b->grecs_json__ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(grecs_json__c_buf_p) = &b->grecs_json__ch_buf[grecs_json__c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->grecs_json__buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf[number_to_move]),\n\t\t\t(grecs_json__n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__n_chars = (grecs_json__n_chars);\n\t\t}\n\n\tif ( (grecs_json__n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tgrecs_json_restart(grecs_json_in  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((grecs_json__size_t) ((grecs_json__n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->grecs_json__buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tgrecs_json__size_t new_size = (grecs_json__n_chars) + number_to_move + ((grecs_json__n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf = (char *) grecs_json_realloc((void *) YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json__get_next_buffer()\" );\n\t}\n\n\t(grecs_json__n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf[(grecs_json__n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf[(grecs_json__n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(grecs_json_text_ptr) = &YY_CURRENT_BUFFER_LVALUE->grecs_json__ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_json__get_previous_state": {
      "start_point": [
        1529,
        4
      ],
      "end_point": [
        1559,
        1
      ],
      "content": "static grecs_json__state_type grecs_json__get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister grecs_json__state_type grecs_json__current_state;\n\tregister char *grecs_json__cp;\n    \n/* %% [15.0] code to get the start state into grecs_json__current_state goes here */\n\tgrecs_json__current_state = (grecs_json__start);\n\n\tfor ( grecs_json__cp = (grecs_json_text_ptr) + YY_MORE_ADJ; grecs_json__cp < (grecs_json__c_buf_p); ++grecs_json__cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR grecs_json__c = (*grecs_json__cp ? grecs_json__ec[YY_SC_TO_UI(*grecs_json__cp)] : 1);\n\t\tif ( grecs_json__accept[grecs_json__current_state] )\n\t\t\t{\n\t\t\t(grecs_json__last_accepting_state) = grecs_json__current_state;\n\t\t\t(grecs_json__last_accepting_cpos) = grecs_json__cp;\n\t\t\t}\n\t\twhile ( grecs_json__chk[grecs_json__base[grecs_json__current_state] + grecs_json__c] != grecs_json__current_state )\n\t\t\t{\n\t\t\tgrecs_json__current_state = (int) grecs_json__def[grecs_json__current_state];\n\t\t\tif ( grecs_json__current_state >= 61 )\n\t\t\t\tgrecs_json__c = grecs_json__meta[(unsigned int) grecs_json__c];\n\t\t\t}\n\t\tgrecs_json__current_state = grecs_json__nxt[grecs_json__base[grecs_json__current_state] + (unsigned int) grecs_json__c];\n\t\t}\n\n\treturn grecs_json__current_state;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "grecs_json__state_type"
      ]
    },
    "grecs_json__try_NUL_trans": {
      "start_point": [
        1567,
        4
      ],
      "end_point": [
        1592,
        1
      ],
      "content": "static grecs_json__state_type grecs_json__try_NUL_trans  (grecs_json__state_type grecs_json__current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int grecs_json__is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *grecs_json__cp = (grecs_json__c_buf_p);\n\n\tregister YY_CHAR grecs_json__c = 1;\n\tif ( grecs_json__accept[grecs_json__current_state] )\n\t\t{\n\t\t(grecs_json__last_accepting_state) = grecs_json__current_state;\n\t\t(grecs_json__last_accepting_cpos) = grecs_json__cp;\n\t\t}\n\twhile ( grecs_json__chk[grecs_json__base[grecs_json__current_state] + grecs_json__c] != grecs_json__current_state )\n\t\t{\n\t\tgrecs_json__current_state = (int) grecs_json__def[grecs_json__current_state];\n\t\tif ( grecs_json__current_state >= 61 )\n\t\t\tgrecs_json__c = grecs_json__meta[(unsigned int) grecs_json__c];\n\t\t}\n\tgrecs_json__current_state = grecs_json__nxt[grecs_json__base[grecs_json__current_state] + (unsigned int) grecs_json__c];\n\tgrecs_json__is_jam = (grecs_json__current_state == 60);\n\n\treturn grecs_json__is_jam ? 0 : grecs_json__current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "grecs_json__state_type"
      ]
    },
    "grecs_json_restart": {
      "start_point": [
        1686,
        4
      ],
      "end_point": [
        1700,
        1
      ],
      "content": "void grecs_json_restart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        grecs_json_ensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            grecs_json__create_buffer(grecs_json_in,YY_BUF_SIZE );\n\t}\n\n\tgrecs_json__init_buffer(YY_CURRENT_BUFFER,input_file );\n\tgrecs_json__load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_json__switch_to_buffer": {
      "start_point": [
        1707,
        4
      ],
      "end_point": [
        1739,
        1
      ],
      "content": "void grecs_json__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tgrecs_json_pop_buffer_state();\n\t *\t\tgrecs_json_push_buffer_state(new_buffer);\n     */\n\tgrecs_json_ensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_json__c_buf_p) = (grecs_json__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__buf_pos = (grecs_json__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__n_chars = (grecs_json__n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tgrecs_json__load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (grecs_json_wrap()) processing, but the only time this flag\n\t * is looked at is after grecs_json_wrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(grecs_json__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_json__load_buffer_state": {
      "start_point": [
        1742,
        0
      ],
      "end_point": [
        1751,
        1
      ],
      "content": "static void grecs_json__load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(grecs_json__n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_json__n_chars;\n\t(grecs_json_text_ptr) = (grecs_json__c_buf_p) = YY_CURRENT_BUFFER_LVALUE->grecs_json__buf_pos;\n\tgrecs_json_in = YY_CURRENT_BUFFER_LVALUE->grecs_json__input_file;\n\t(grecs_json__hold_char) = *(grecs_json__c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json__create_buffer": {
      "start_point": [
        1760,
        4
      ],
      "end_point": [
        1785,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_json__create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) grecs_json_alloc(sizeof( struct grecs_json__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json__create_buffer()\" );\n\n\tb->grecs_json__buf_size = size;\n\n\t/* grecs_json__ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->grecs_json__ch_buf = (char *) grecs_json_alloc(b->grecs_json__buf_size + 2  );\n\tif ( ! b->grecs_json__ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json__create_buffer()\" );\n\n\tb->grecs_json__is_our_buffer = 1;\n\n\tgrecs_json__init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_json__delete_buffer": {
      "start_point": [
        1792,
        4
      ],
      "end_point": [
        1808,
        1
      ],
      "content": "void grecs_json__delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->grecs_json__is_our_buffer )\n\t\tgrecs_json_free((void *) b->grecs_json__ch_buf  );\n\n\tgrecs_json_free((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_json__init_buffer": {
      "start_point": [
        1826,
        4
      ],
      "end_point": [
        1856,
        1
      ],
      "content": "static void grecs_json__init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tgrecs_json__flush_buffer(b );\n\n\tb->grecs_json__input_file = file;\n\tb->grecs_json__fill_buffer = 1;\n\n    /* If b is the current buffer, then grecs_json__init_buffer was _probably_\n     * called from grecs_json_restart() or through grecs_json__get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->grecs_json__bs_lineno = 1;\n        b->grecs_json__bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->grecs_json__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json__flush_buffer": {
      "start_point": [
        1863,
        4
      ],
      "end_point": [
        1887,
        1
      ],
      "content": "void grecs_json__flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->grecs_json__n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->grecs_json__ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->grecs_json__ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->grecs_json__buf_pos = &b->grecs_json__ch_buf[0];\n\n\tb->grecs_json__at_bol = 1;\n\tb->grecs_json__buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tgrecs_json__load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_push_buffer_state": {
      "start_point": [
        1897,
        0
      ],
      "end_point": [
        1924,
        1
      ],
      "content": "void grecs_json_push_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tgrecs_json_ensure_buffer_stack();\n\n\t/* This block is copied from grecs_json__switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_json__c_buf_p) = (grecs_json__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__buf_pos = (grecs_json__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_json__n_chars = (grecs_json__n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(grecs_json__buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from grecs_json__switch_to_buffer. */\n\tgrecs_json__load_buffer_state( );\n\t(grecs_json__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_pop_buffer_state": {
      "start_point": [
        1933,
        0
      ],
      "end_point": [
        1950,
        1
      ],
      "content": "void grecs_json_pop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tgrecs_json__delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((grecs_json__buffer_stack_top) > 0)\n\t\t--(grecs_json__buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tgrecs_json__load_buffer_state( );\n\t\t(grecs_json__did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_ensure_buffer_stack": {
      "start_point": [
        1958,
        0
      ],
      "end_point": [
        2002,
        1
      ],
      "content": "static void grecs_json_ensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    \n\tif (!(grecs_json__buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(grecs_json__buffer_stack) = (struct grecs_json__buffer_state**)grecs_json_alloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct grecs_json__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_json__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json_ensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((grecs_json__buffer_stack), 0, num_to_alloc * sizeof(struct grecs_json__buffer_state*));\n\t\t\t\t\n\t\t(grecs_json__buffer_stack_max) = num_to_alloc;\n\t\t(grecs_json__buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((grecs_json__buffer_stack_top) >= ((grecs_json__buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (grecs_json__buffer_stack_max) + grow_size;\n\t\t(grecs_json__buffer_stack) = (struct grecs_json__buffer_state**)grecs_json_realloc\n\t\t\t\t\t\t\t\t((grecs_json__buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct grecs_json__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_json__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json_ensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((grecs_json__buffer_stack) + (grecs_json__buffer_stack_max), 0, grow_size * sizeof(struct grecs_json__buffer_state*));\n\t\t(grecs_json__buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json__scan_buffer": {
      "start_point": [
        2012,
        0
      ],
      "end_point": [
        2039,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_json__scan_buffer  (char * base, grecs_json__size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) grecs_json_alloc(sizeof( struct grecs_json__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json__scan_buffer()\" );\n\n\tb->grecs_json__buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->grecs_json__buf_pos = b->grecs_json__ch_buf = base;\n\tb->grecs_json__is_our_buffer = 0;\n\tb->grecs_json__input_file = 0;\n\tb->grecs_json__n_chars = b->grecs_json__buf_size;\n\tb->grecs_json__is_interactive = 0;\n\tb->grecs_json__at_bol = 1;\n\tb->grecs_json__fill_buffer = 0;\n\tb->grecs_json__buffer_status = YY_BUFFER_NEW;\n\n\tgrecs_json__switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_json__scan_string": {
      "start_point": [
        2051,
        0
      ],
      "end_point": [
        2055,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_json__scan_string (grecs_json_const char * grecs_json_str )\n{\n    \n\treturn grecs_json__scan_bytes(grecs_json_str,strlen(grecs_json_str) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_json__scan_bytes": {
      "start_point": [
        2066,
        0
      ],
      "end_point": [
        2094,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_json__scan_bytes  (grecs_json_const char * grecs_json_bytes, int  _grecs_json_bytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tgrecs_json__size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _grecs_json_bytes_len + 2;\n\tbuf = (char *) grecs_json_alloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_json__scan_bytes()\" );\n\n\tfor ( i = 0; i < _grecs_json_bytes_len; ++i )\n\t\tbuf[i] = grecs_json_bytes[i];\n\n\tbuf[_grecs_json_bytes_len] = buf[_grecs_json_bytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = grecs_json__scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in grecs_json__scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->grecs_json__is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_json__fatal_error": {
      "start_point": [
        2102,
        0
      ],
      "end_point": [
        2106,
        1
      ],
      "content": "static void grecs_json__fatal_error (grecs_json_const char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json_get_lineno": {
      "start_point": [
        2137,
        0
      ],
      "end_point": [
        2141,
        1
      ],
      "content": "int grecs_json_get_lineno  (void)\n{\n        \n    return grecs_json_lineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_json_get_in": {
      "start_point": [
        2146,
        0
      ],
      "end_point": [
        2149,
        1
      ],
      "content": "FILE *grecs_json_get_in  (void)\n{\n        return grecs_json_in;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_json_get_in  (void)",
        "*"
      ]
    },
    "grecs_json_get_out": {
      "start_point": [
        2154,
        0
      ],
      "end_point": [
        2157,
        1
      ],
      "content": "FILE *grecs_json_get_out  (void)\n{\n        return grecs_json_out;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_json_get_out  (void)",
        "*"
      ]
    },
    "grecs_json_get_leng": {
      "start_point": [
        2162,
        0
      ],
      "end_point": [
        2165,
        1
      ],
      "content": "int grecs_json_get_leng  (void)\n{\n        return grecs_json_leng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_json_get_text": {
      "start_point": [
        2171,
        0
      ],
      "end_point": [
        2174,
        1
      ],
      "content": "char *grecs_json_get_text  (void)\n{\n        return grecs_json_text;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*grecs_json_get_text  (void)",
        "*"
      ]
    },
    "grecs_json_set_lineno": {
      "start_point": [
        2183,
        0
      ],
      "end_point": [
        2187,
        1
      ],
      "content": "void grecs_json_set_lineno (int  line_number )\n{\n    \n    grecs_json_lineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_set_in": {
      "start_point": [
        2195,
        0
      ],
      "end_point": [
        2198,
        1
      ],
      "content": "void grecs_json_set_in (FILE *  in_str )\n{\n        grecs_json_in = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_set_out": {
      "start_point": [
        2200,
        0
      ],
      "end_point": [
        2203,
        1
      ],
      "content": "void grecs_json_set_out (FILE *  out_str )\n{\n        grecs_json_out = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_json_get_debug": {
      "start_point": [
        2205,
        0
      ],
      "end_point": [
        2208,
        1
      ],
      "content": "int grecs_json_get_debug  (void)\n{\n        return grecs_json__flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_json_set_debug": {
      "start_point": [
        2210,
        0
      ],
      "end_point": [
        2213,
        1
      ],
      "content": "void grecs_json_set_debug (int  bdebug )\n{\n        grecs_json__flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_json__init_globals": {
      "start_point": [
        2223,
        0
      ],
      "end_point": [
        2249,
        1
      ],
      "content": "static int grecs_json__init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from grecs_json_lex_destroy(), so don't allocate here.\n     */\n\n    (grecs_json__buffer_stack) = 0;\n    (grecs_json__buffer_stack_top) = 0;\n    (grecs_json__buffer_stack_max) = 0;\n    (grecs_json__c_buf_p) = (char *) 0;\n    (grecs_json__init) = 0;\n    (grecs_json__start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    grecs_json_in = stdin;\n    grecs_json_out = stdout;\n#else\n    grecs_json_in = (FILE *) 0;\n    grecs_json_out = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * grecs_json_lex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_json_lex_destroy": {
      "start_point": [
        2254,
        0
      ],
      "end_point": [
        2275,
        1
      ],
      "content": "int grecs_json_lex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tgrecs_json__delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tgrecs_json_pop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tgrecs_json_free((grecs_json__buffer_stack) );\n\t(grecs_json__buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * grecs_json_lex() is called, initialization will occur. */\n    grecs_json__init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_json__flex_strncpy": {
      "start_point": [
        2283,
        0
      ],
      "end_point": [
        2288,
        1
      ],
      "content": "static void grecs_json__flex_strncpy (char* s1, grecs_json_const char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_json__flex_strlen": {
      "start_point": [
        2292,
        0
      ],
      "end_point": [
        2299,
        1
      ],
      "content": "static int grecs_json__flex_strlen (grecs_json_const char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_json_alloc": {
      "start_point": [
        2302,
        0
      ],
      "end_point": [
        2305,
        1
      ],
      "content": "void *grecs_json_alloc (grecs_json__size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*grecs_json_alloc (grecs_json__size_t  size )",
        "*"
      ]
    },
    "grecs_json_realloc": {
      "start_point": [
        2307,
        0
      ],
      "end_point": [
        2317,
        1
      ],
      "content": "void *grecs_json_realloc  (void * ptr, grecs_json__size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*grecs_json_realloc  (void * ptr, grecs_json__size_t  size )",
        "*"
      ]
    },
    "grecs_json_free": {
      "start_point": [
        2319,
        0
      ],
      "end_point": [
        2322,
        1
      ],
      "content": "void grecs_json_free (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see grecs_json_realloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/json-lex.l": {
    "noinput": {
      "start_point": [
        0,
        1
      ],
      "end_point": [
        6,
        1
      ],
      "content": "option noinput\n%option nounput\n%top {\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n}",
      "lines": 7,
      "depth": 5,
      "decorators": null
    },
    "jsonlex_setup": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\njsonlex_setup(char const *s, size_t l)\n{\n\tinput_ptr = s;\n\tinput_size = l;\n\tjson_current_locus_point.file = NULL;\n\tjson_current_locus_point.line = 1;\n\tjson_current_locus_point.col = 0;\n\tjson_err_diag = NULL;\n\tyy_flex_debug = 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "jsonlex_diag": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "void\njsonlex_diag(const char *s)\n{\n\tif (!json_err_diag) {\n\t\tjson_err_diag = s;\n\t\tjson_err_locus = yylloc;\n\t}\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "utf8_wctomb": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\nutf8_wctomb(char *u)\n{\n\tunsigned int wc = strtoul(u, NULL, 16);\n\tint count;\n\tchar r[6];\n\t\n\tif (wc < 0x80)\n\t\tcount = 1;\n\telse if (wc < 0x800)\n\t\tcount = 2;\n\telse if (wc < 0x10000)\n\t\tcount = 3;\n\telse if (wc < 0x200000)\n\t\tcount = 4;\n\telse if (wc < 0x4000000)\n\t\tcount = 5;\n\telse if (wc <= 0x7fffffff)\n\t\tcount = 6;\n\telse\n\t\treturn -1;\n\n\tswitch (count) {\n\t\t/* Note: code falls through cases! */\n\tcase 6:\n\t\tr[5] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x4000000;\n\tcase 5:\n\t\tr[4] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x200000;\n\tcase 4:\n\t\tr[3] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x10000;\n\tcase 3:\n\t\tr[2] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0x800;\n\tcase 2:\n\t\tr[1] = 0x80 | (wc & 0x3f);\n\t\twc = wc >> 6;\n\t\twc |= 0xc0;\n\tcase 1:\n\t\tr[0] = wc;\n\t}\n\tgrecs_line_acc_grow(r, count);\n\treturn count;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_unescape": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\njson_unescape(char c, char *o)\n{\n\tstatic char transtab[] = \"\\\\\\\\\\\"\\\"b\\bf\\fn\\nr\\rt\\t\";\n\tchar *p;\n\n\tfor (p = transtab; *p; p += 2) {\n\t\tif (p[0] == c) {\n\t\t\t*o = p[1];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "yywrap": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "static int\nyywrap()\n{\n\treturn 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_line_begin": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "static void\njson_line_begin()\n{\n\tif (!json_line_acc)\n\t\tjson_line_acc = grecs_txtacc_create();\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_line_finish": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static char *\njson_line_finish()\n{\n\tif (json_line_acc) {\n\t\tchar nil = 0;\n\t\tgrecs_txtacc_grow(json_line_acc, &nil, 1);\n\t\treturn grecs_txtacc_finish(json_line_acc, 1);\n\t}\n\treturn NULL;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "char",
        "*\njson_line_finish()",
        "*"
      ]
    },
    "json_line_grow": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\njson_line_grow(char const *text, size_t len)\t\n{\n\tgrecs_txtacc_grow(json_line_acc, text, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/jsonfmt.c": {
    "json_writez": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        29,
        1
      ],
      "content": "static void\njson_writez(struct json_format *fmt, char const *str)\n{\n\tsize_t len = strlen(str);\n\tfmt->write(fmt->data, str, len);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_writec": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\njson_writec(struct json_format *fmt, char c)\n{\n\tfmt->write(fmt->data, &c, 1);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_indent": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static void\njson_indent(struct json_format *fmt, size_t level)\n{\n\tlevel *= fmt->indent;\n\twhile (level--)\n\t\tjson_writec(fmt, ' ');\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_format_delim": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\njson_format_delim(struct json_format *fmt, size_t level)\n{\n\tjson_writec(fmt, ',');\n\tif (fmt->indent) {\n\t\tjson_writec(fmt, '\\n');\n\t\tjson_indent(fmt, level);\n\t} else\n\t\tjson_writec(fmt, ' ');\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "escape": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "static int\nescape(char c, char *o)\n{\n\tstatic char transtab[] = \"\\\\\\\\\\\"\\\"b\\bf\\fn\\nr\\rt\\t\";\n\tchar *p;\n\n\tfor (p = transtab; *p; p += 2) {\n\t\tif (p[1] == c) {\n\t\t\t*o = p[0];\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -1;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_format_string": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void\njson_format_string(struct json_format *fmt, const char *s)\n{\n\tjson_writec(fmt, '\"');\n\tfor (; *s; s++) {\n\t\tchar c;\n\t\tif (!escape(*s, &c)) {\n\t\t\tjson_writec(fmt, '\\\\');\n\t\t\tjson_writec(fmt, c);\n\t\t} else\n\t\t\tjson_writec(fmt, *s);\n\t}\n\tjson_writec(fmt, '\"');\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_format_number": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static void\njson_format_number(struct json_format *fmt, double n)\n{\n\tchar *buffer = NULL;\n\tsize_t size = 0;\n\tif (fmt->precision == -1) \n\t\tgrecs_asprintf(&buffer, &size, \"%e\", n);\n\telse\n\t\tgrecs_asprintf(&buffer, &size, \"%.*f\", fmt->precision, n);\n\tjson_writez(fmt, buffer);\n\tfree(buffer);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "collect_keypairs": {
      "start_point": [
        99,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static int\ncollect_keypairs(void *sym, void *data)\n{\n\tstruct json_pair *p = sym;\n\tstruct json_pair ***kp = data;\n\t**kp = p;\n\t++*kp;\n\treturn 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "keypair_cmp_name": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static int\nkeypair_cmp_name(const void *a, const void *b)\n{\n\tstruct json_pair const * const *kpa = a;\n\tstruct json_pair const * const *kpb = b;\n\treturn strcmp((*kpa)->k, (*kpb)->k);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "json_format_obj": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static void\njson_format_obj(struct json_format *fmt, struct json_value *obj, size_t level)\n{\n\tsize_t count, i;\n\tstruct json_pair **keypairs, **kp;\n\t\n\tcount = grecs_symtab_count_entries(obj->v.o);\n\tkeypairs = grecs_calloc(count, sizeof(*keypairs));\n\tkp = keypairs;\n\tgrecs_symtab_enumerate(obj->v.o, collect_keypairs, &kp);\n\tqsort(keypairs, count, sizeof(*keypairs), keypair_cmp_name);\n\n\tjson_writec(fmt, '{');\n\tif (count) {\n\t\tif (fmt->indent)\n\t\t\tjson_writec(fmt, '\\n');\n\t\tfor (i = 0; i < count; i++) {\n\t\t\t(i ? json_format_delim : json_indent)(fmt, level);\n\t\t\tjson_format_string(fmt, keypairs[i]->k);\n\t\t\tjson_writec(fmt, ':');\n\t\t\tif (fmt->indent)\n\t\t\t\tjson_writec(fmt, ' ');\n\t\t\tjson_formatter(fmt, keypairs[i]->v, level);\n\t\t}\n\t\tif (fmt->indent) {\n\t\t\tjson_writec(fmt, '\\n');\n\t\t\tjson_indent(fmt, level-1);\n\t\t}\n\t}\n\tjson_writec(fmt, '}');\n\tgrecs_free(keypairs);\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_format_array": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "static void\njson_format_array(struct json_format *fmt, struct json_value *obj,\n\t\t  size_t level)\n{\n\tsize_t i;\n\n\tjson_array_flatten(obj);\n\t\n\tjson_writec(fmt, '[');\n\tif (obj->v.a->oc) {\n\t\tif (fmt->indent)\n\t\t\tjson_writec(fmt, '\\n');\n\t\tfor (i = 0; i < obj->v.a->oc; i++) {\n\t\t\t(i ? json_format_delim : json_indent)(fmt, level);\n\t\t\tjson_formatter(fmt, obj->v.a->ov[i], level);\n\t\t}\n\t\tif (fmt->indent) {\n\t\t\tjson_writec(fmt, '\\n');\n\t\t\tjson_indent(fmt, level-1);\n\t\t}\n\t}\n\tjson_writec(fmt, ']');\n}",
      "lines": 23,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_formatter": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void\njson_formatter(struct json_format *fmt, struct json_value *obj, size_t level)\n{\n\tif (!obj) {\n\t\tjson_writez(fmt, \"null\");\n\t\treturn;\n\t}\n\n\t++level;\n\tswitch (obj->type) {\n\tcase json_null:\n\t\tjson_writez(fmt, \"null\");\n\t\tbreak;\n\t\t\n\tcase json_bool:\n\t\tjson_writez(fmt, obj->v.b ? \"true\" : \"false\");\n\t\tbreak;\n\t\t\n\tcase json_number:\n\t\tjson_format_number(fmt, obj->v.n);\n\t\tbreak;\n\n\tcase json_string:\n\t\tjson_format_string(fmt, obj->v.s);\n\t\tbreak;\n\t\t\n\tcase json_arr:\n\t\tjson_format_array(fmt, obj, level);\n\t\tbreak;\n\n\tcase json_object: \n\t\tjson_format_obj(fmt, obj, level);\n\t\tbreak;\n\t}\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "json_format_value": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\njson_format_value(struct json_value *obj, struct json_format *fmt)\n{\n\tjson_formatter(fmt, obj, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/lineacc.c": {
    "grecs_line_acc_create": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "void\ngrecs_line_acc_create()\n{\n\tline_acc = grecs_txtacc_create();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_acc_free": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\ngrecs_line_acc_free()\n{\n\tgrecs_txtacc_free(line_acc);\n\tline_acc = NULL;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_acc_grow_char": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "void\ngrecs_line_acc_grow_char(int c)\n{\n\tchar t = c;\n\tgrecs_txtacc_grow(line_acc, &t, 1);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_acc_grow_char_unescape": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "int\ngrecs_line_acc_grow_char_unescape(int c)\n{\n\tif (c != '\\n') {\n\t\tint uc = wordsplit_c_unquote_char(c);\n\t\tgrecs_line_acc_grow_char(uc ? uc : c);\n\t\treturn !uc;\n\t}\n\treturn 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "grecs_line_acc_grow": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\ngrecs_line_acc_grow(const char *text, size_t len)\n{\n\tgrecs_txtacc_grow(line_acc, text, len);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_acc_grow_unescape_last": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ngrecs_line_acc_grow_unescape_last(char *text, size_t len,\n\t\t\t\t  grecs_locus_t const *loc)\n{\n\tgrecs_txtacc_grow(line_acc, text, len - 2);\n\tif (grecs_line_acc_grow_char_unescape(text[len - 1]) && loc)\n\t\tgrecs_warning(loc, 0,\n\t\t\t      _(\"unknown escape sequence: '\\\\%c'\"),\n\t\t\t      text[len - 1]);\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_begin": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ngrecs_line_begin()\n{\n\tif (!line_acc)\n\t\tgrecs_line_acc_create();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_line_finish": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "char *\ngrecs_line_finish()\n{\n\tgrecs_line_acc_grow_char(0);\n\treturn grecs_txtacc_finish(line_acc, 1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "char",
        "*\ngrecs_line_finish()",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/list.c": {
    "grecs_list_create": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "struct grecs_list *\ngrecs_list_create()\n{\n\tstruct grecs_list *lp = grecs_malloc(sizeof(*lp));\n\tmemset(lp, 0, sizeof(*lp));\n\treturn lp;\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "struct grecs_list",
        "struct",
        "grecs_list",
        "*\ngrecs_list_create()",
        "*"
      ]
    },
    "grecs_list_size": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "size_t\ngrecs_list_size(struct grecs_list *lp)\n{\n\treturn lp ? lp->count : 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "size_t"
      ]
    },
    "grecs_list_insert_entry": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\ngrecs_list_insert_entry(struct grecs_list *lp,\n\t\t\tstruct grecs_list_entry *anchor,\n\t\t\tstruct grecs_list_entry *ent, int before)\n{\n\tstruct grecs_list_entry *p;\n\t\n\tif (!anchor) {\n\t\tent->prev = NULL;\n\t\tent->next = lp->head;\n\t\tif (lp->head)\n\t\t\tlp->head->prev = ent;\n\t\telse\n\t\t\tlp->tail = ent;\n\t\tlp->head = ent;\n\t\tlp->count++;\n\t\treturn;\n\t}\n\t\t\n\tif (before) {\n\t\tgrecs_list_insert_entry(lp, anchor->prev, ent, 0);\n\t\treturn;\n\t}\n\n\tent->prev = anchor;\n\tif ((p = anchor->next))\n\t\tp->prev = ent;\n\telse\n\t\tlp->tail = ent;\n\tent->next = p;\n\tanchor->next = ent;\n\tlp->count++;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_remove_entry": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\ngrecs_list_remove_entry(struct grecs_list *lp, struct grecs_list_entry *ent)\n{\n\tstruct grecs_list_entry *p;\n\tif ((p = ent->prev))\n\t\tp->next = ent->next;\n\telse\n\t\tlp->head = ent->next;\n\tif ((p = ent->next))\n\t\tp->prev = ent->prev;\n\telse\n\t\tlp->tail = ent->prev;\n\tgrecs_free(ent);\n\tlp->count--;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_append": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\ngrecs_list_append(struct grecs_list *lp, void *val)\n{\n\tstruct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));\n\tep->data = val;\n\tgrecs_list_insert_entry(lp, lp->tail, ep, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_add": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\ngrecs_list_add(struct grecs_list *dst, struct grecs_list *src)\n{\n\tif (!src->head)\n\t\treturn;\n\n\tsrc->head->prev = dst->tail;\n\tif (dst->tail)\n\t\tdst->tail->next = src->head;\n\telse\n\t\tdst->head = src->head;\n\tdst->tail = src->tail;\n\tdst->count += src->count;\n\tsrc->head = src->tail = NULL;\n\tsrc->count = 0;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_push": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\ngrecs_list_push(struct grecs_list *lp, void *val)\n{\n\tstruct grecs_list_entry *ep = grecs_malloc(sizeof(*ep));\n\tep->data = val;\n\tgrecs_list_insert_entry(lp, NULL, ep, 0);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_pop": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void *\ngrecs_list_pop(struct grecs_list *lp)\n{\n\tvoid *data;\n\tstruct grecs_list_entry *ep = lp->head;\n\tif (ep)\t{\n\t\tdata = ep->data;\n\t\tgrecs_list_remove_entry(lp, ep);\n\t} else\n\t\tdata = NULL;\n\treturn data;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void",
        "*\ngrecs_list_pop(struct grecs_list *lp)",
        "*"
      ]
    },
    "grecs_list_remove_tail": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void *\ngrecs_list_remove_tail(struct grecs_list *lp)\n{\n\tvoid *data;\n\tstruct grecs_list_entry *ep;\n  \n\tif (!lp->tail)\n\t\treturn NULL;\n\tep = lp->tail;\n\tdata = lp->tail->data;\n\tgrecs_list_remove_entry(lp, ep);\n\treturn data;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_list_remove_tail(struct grecs_list *lp)",
        "*"
      ]
    },
    "grecs_list_clear": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "void\ngrecs_list_clear(struct grecs_list *lp)\n{\n\tstruct grecs_list_entry *ep = lp->head;\n\n\twhile (ep) {\n\t\tstruct grecs_list_entry *next = ep->next;\n\t\tif (lp->free_entry)\n\t\t\tlp->free_entry(ep->data);\n\t\tgrecs_free(ep);\n\t\tep = next;\n\t}\n\tlp->head = lp->tail = NULL;\n\tlp->count = 0;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_list_free": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\ngrecs_list_free(struct grecs_list *lp)\n{\n\tif (lp) {\n\t\tgrecs_list_clear(lp);\n\t\tgrecs_free(lp);\n\t}\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_ptrcmp": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static int\n_ptrcmp(const void *a, const void *b)\n{\n\treturn a != b;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_list_locate": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "void *\ngrecs_list_locate(struct grecs_list *lp, void *data)\n{\n\tstruct grecs_list_entry *ep;\n\tint (*cmp)(const void *, const void *) = lp->cmp ? lp->cmp : _ptrcmp;\n\n\tfor (ep = lp->head; ep; ep = ep->next) {\n\t\tif (cmp(ep->data, data) == 0)\n\t\t\treturn ep->data;\n\t}\n\treturn NULL;\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void",
        "*\ngrecs_list_locate(struct grecs_list *lp, void *data)",
        "*"
      ]
    },
    "grecs_list_index": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "void *\ngrecs_list_index(struct grecs_list *lp, size_t idx)\n{\n\tstruct grecs_list_entry *ep;\n\t\n\tfor (ep = lp->head; ep && idx; ep = ep->next, idx--)\n\t\t;\n\treturn ep ? ep->data : NULL;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_list_index(struct grecs_list *lp, size_t idx)",
        "*"
      ]
    },
    "grecs_list_compare": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "int\ngrecs_list_compare(struct grecs_list *a, struct grecs_list *b)\n{\n\tstruct grecs_list_entry *ap, *bp;\n\tint (*cmp)(const void *, const void *);\n\n\tif (!a)\n\t\treturn !!b;\n\telse if (!b)\n\t\treturn 1;\n\t\n\tif (grecs_list_size(a) != grecs_list_size(b))\n\t\treturn 1;\n\tif (a->cmp != b->cmp)\n\t\treturn 1;\n\t\n\tcmp = a->cmp ? a->cmp : _ptrcmp;\n\t\n\tfor (ap = a->head, bp = b->head; ap; ap = ap->next, bp = bp->next)\n\t\tif (cmp (ap->data, bp->data))\n\t\t\treturn 1;\n\t\n\treturn 0;\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/lookup.c": {
    "_grecs_list_eq": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static int\n_grecs_list_eq(struct grecs_value *a, struct grecs_value *b)\n{\n\tstruct grecs_list_entry *aent, *bent;\n\tif (grecs_list_size(a->v.list) != grecs_list_size(b->v.list))\n\t\treturn 0;\n\n\tfor (aent = a->v.list->head, bent = b->v.list->head;;\n\t     aent = aent->next, bent = bent->next) {\n\t\tif (!aent)\n\t\t\treturn bent == NULL;\n\t\tif (!bent)\n\t\t\treturn 0;\n\t\tif (!grecs_value_eq(aent->data, bent->data))\n\t\t\treturn 0;\n\t}\n\t/*notreached*/\n\treturn 1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_grecs_array_eq": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\n_grecs_array_eq(struct grecs_value *a, struct grecs_value *b)\n{\n\tsize_t i;\n\n\tif (a->v.arg.c != b->v.arg.c)\n\t\treturn 0;\n\n\tfor (i = 0; i < a->v.arg.c; i++)\n\t\tif (!grecs_value_eq(a->v.arg.v[i], b->v.arg.v[i]))\n\t\t\treturn 0;\n\treturn 1;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_value_eq": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\ngrecs_value_eq(struct grecs_value *a, struct grecs_value *b)\n{\n\tif (a == 0 || b == 0)\n\t\treturn a == b;\n\tif (a->type != b->type)\n\t\treturn 0;\n\tswitch (a->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tif (a->v.string == NULL)\n\t\t\treturn b->v.string == NULL;\n\t\treturn strcmp(a->v.string, b->v.string) == 0;\n      \n\tcase GRECS_TYPE_LIST:\n\t\treturn _grecs_list_eq(a, b);\n      \n\tcase GRECS_TYPE_ARRAY:\n\t\treturn _grecs_array_eq(a, b);\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "_grecs_list_match": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static int\n_grecs_list_match(struct grecs_value *pat, struct grecs_value *b, int flags)\n{\n\tstruct grecs_list_entry *aent, *bent;\n\tif (grecs_list_size(pat->v.list) != grecs_list_size(b->v.list))\n\t\treturn 0;\n\n\tfor (aent = pat->v.list->head, bent = b->v.list->head;;\n\t     aent = aent->next, bent = bent->next) {\n\t\tif (!aent)\n\t\t\treturn bent == NULL;\n\t\tif (!bent)\n\t\t\treturn 0;\n\t\tif (!grecs_value_match(aent->data, bent->data, flags))\n\t\t\treturn 0;\n\t}\n\t/*notreached*/\n\treturn 1;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_grecs_array_match": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\n_grecs_array_match(struct grecs_value *pat, struct grecs_value *b, int flags)\n{\n\tsize_t i;\n\n\tif (pat->v.arg.c > b->v.arg.c)\n\t\treturn 0;\n\n\tfor (i = 0; i < pat->v.arg.c; i++)\n\t\tif (!grecs_value_match(pat->v.arg.v[i], b->v.arg.v[i], flags))\n\t\t\treturn 0;\n\treturn 1;\n}",
      "lines": 13,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_value_match": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "int\ngrecs_value_match(struct grecs_value *pat, struct grecs_value *b, int flags)\n{\n\tif (pat == 0 || b == 0)\n\t\treturn pat == b;\n\tif (pat->type != b->type) {\n\t\tif (pat->type != GRECS_TYPE_STRING)\n\t\t\treturn 0;\n\t\tswitch (b->type) {\n\t\tcase GRECS_TYPE_LIST:\n\t\t\tb = grecs_list_index(b->v.list, 0);\n\t\t\tbreak;\n\n\t\tcase GRECS_TYPE_ARRAY:\n\t\t\tb = b->v.arg.v[0];\n\t\t}\n\t}\n\t\n\tswitch (pat->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tif (pat->v.string == NULL)\n\t\t\treturn b->v.string == NULL;\n\t\treturn fnmatch(pat->v.string, b->v.string, flags) == 0;\n      \n\tcase GRECS_TYPE_LIST:\n\t\treturn _grecs_list_match(pat, b, flags);\n      \n\tcase GRECS_TYPE_ARRAY:\n\t\treturn _grecs_array_match(pat, b, flags);\n    }\n  return 0;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "grecs_match_buf_create": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "grecs_match_buf_t\ngrecs_match_buf_create(int argc, char **argv, struct grecs_value **labelv)\n{\n\tint i;\n\tstruct grecs_match_buf *buf = grecs_zalloc(sizeof(*buf));\n\n\tbuf->argc = argc;\n\tbuf->argv = argv;\n\tbuf->labelv = labelv;\n\t/* Compress argv/argc by replacing contiguous sequences of *'s\n\t   with a single *. */\n\tfor (i = 0; i < buf->argc; i++) {\n\t\tif (ISWC(buf->argv[i], '*')) {\n\t\t\tint j;\n\t\t\t\n\t\t\tfor (j = i + 1;\n\t\t\t     j < buf->argc && ISWC(buf->argv[j], '*'); j++) {\n\t\t\t        free(buf->argv[j]);\n\t\t\t\tgrecs_value_free_content(buf->labelv[i]);\n\t\t\t}\n\t\t\tj -= i;\n\t\t\tif (j > 1) {\n\t\t\t\tmemmove(&buf->argv[i+1], &buf->argv[i+j],\n\t\t\t\t\t(buf->argc - (i + j)) *\n\t\t\t\t\tsizeof(buf->argv[0]));\n\t\t\t\tmemmove(&buf->labelv[i+1], &buf->labelv[i+j],\n\t\t\t\t\t(buf->argc - (i + j)) *\n\t\t\t\t\tsizeof(buf->labelv[0]));\n\t\t\t\tbuf->argc -= j - 1;\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\treturn buf;\n}",
      "lines": 35,
      "depth": 17,
      "decorators": [
        "grecs_match_buf_t"
      ]
    },
    "grecs_match_buf_get_args": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "size_t\ngrecs_match_buf_get_args(grecs_match_buf_t buf, char ***argv)\n{\n\tif (argv)\n\t\t*argv = buf->argv;\n\treturn buf->argc;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "grecs_match_buf_get_node": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "struct grecs_node *\ngrecs_match_buf_get_node(grecs_match_buf_t buf)\n{\n\treturn buf->node;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_match_buf_get_node(grecs_match_buf_t buf)",
        "*"
      ]
    },
    "grecs_match_buf_get_root": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "struct grecs_node *\ngrecs_match_buf_get_root(grecs_match_buf_t buf)\n{\n\treturn buf->root;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_match_buf_get_root(grecs_match_buf_t buf)",
        "*"
      ]
    },
    "grecs_match_buf_set_root": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void\ngrecs_match_buf_set_root(grecs_match_buf_t buf, struct grecs_node *root)\n{\n\tbuf->root = root;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_match_buf_free_contents": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\ngrecs_match_buf_free_contents(struct grecs_match_buf *buf)\n{\n\tsize_t i;\n\tfor (i = 0; i < buf->argc; i++) {\n\t\tfree(buf->argv[i]);\n\t\tgrecs_value_free(buf->labelv[i]);\n\t}\n\tfree(buf->argv);\n\tfree(buf->labelv);\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_match_buf_free": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "void\ngrecs_match_buf_free(struct grecs_match_buf *buf)\n{\n\tif (buf) {\n\t\tgrecs_match_buf_free_contents(buf);\n\t\tfree(buf);\n\t}\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "parse_label": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        298,
        1
      ],
      "content": "static struct grecs_value *\nparse_label(const char *str)\n{\n\tstruct grecs_value *val = NULL;\n\tsize_t i;\n\tstruct wordsplit ws;\n\tsize_t len = strlen (str);\n  \n\tif (len > 1 && str[0] == '(' && str[len-1] == ')') {\n\t\tstruct grecs_list *lst;\n      \n\t\tws.ws_delim = \",\";\n\t\tif (wordsplit_len (str + 1, len - 2, &ws,\n\t\t\t\t      WRDSF_DEFFLAGS|WRDSF_DELIM|\n\t\t\t\t      WRDSF_WS)) {\n\t\t\treturn NULL;\n\t\t}\n\n\t\tlst = grecs_value_list_create();\n\t\tfor (i = 0; i < ws.ws_wordc; i++) {\n\t\t\tstruct grecs_value *p = grecs_zalloc(sizeof(*p));\n\t\t\tp->type = GRECS_TYPE_STRING;\n\t\t\tp->v.string = ws.ws_wordv[i];\n\t\t\tgrecs_list_append(lst, p);\n\t\t}\n\t\tval = grecs_malloc(sizeof(*val));\n\t\tval->type = GRECS_TYPE_LIST;\n\t\tval->v.list = lst;\n\t} else {      \n\t\tif (wordsplit(str, &ws, WRDSF_DEFFLAGS))\n\t\t\treturn NULL;\n\t\tval = grecs_zalloc(sizeof(*val));\n\t\tif (ws.ws_wordc == 1) {\n\t\t\tval->type = GRECS_TYPE_STRING;\n\t\t\tval->v.string = ws.ws_wordv[0];\n\t\t} else {\n\t\t\tval->type = GRECS_TYPE_ARRAY;\n\t\t\tval->v.arg.c = ws.ws_wordc;\n\t\t\tval->v.arg.v = grecs_calloc(ws.ws_wordc,\n\t\t\t\t\t\t    sizeof(val->v.arg.v[0]));\n\t\t\tfor (i = 0; i < ws.ws_wordc; i++) {\n\t\t\t\tval->v.arg.v[i] =\n\t\t\t\t\tgrecs_zalloc(sizeof(*val->v.arg.v[0]));\n\t\t\t\tval->v.arg.v[i]->type = GRECS_TYPE_STRING;\n\t\t\t\tval->v.arg.v[i]->v.string = ws.ws_wordv[i];\n\t\t\t}\n\t\t}\n\t}\n\tws.ws_wordc = 0;\n\twordsplit_free(&ws);\n\treturn val;\n}",
      "lines": 52,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "struct grecs_value",
        "struct",
        "grecs_value",
        "*\nparse_label(const char *str)",
        "*"
      ]
    },
    "split_cfg_path": {
      "start_point": [
        300,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static int\nsplit_cfg_path(const char *path, int *pargc, char ***pargv,\n\t       grecs_value_t ***pvalv)\n{\n\tint argc;\n\tchar **argv;\n\tchar *delim = \".\";\n\tchar static_delim[2] = { 0, 0 };\n  \n\tif (path[0] == '\\\\') {\n\t\targv = calloc(2, sizeof (*argv));\n\t\tif (!argv)\n\t\t\treturn WRDSE_NOSPACE;\n\t\targv[0] = strdup(path + 1);\n\t\tif (!argv[0]) {\n\t\t\tfree(argv);\n\t\t\treturn WRDSE_NOSPACE;\n\t\t}\n\t\targv[1] = NULL;\n\t\targc = 1;\n\t} else {\n\t\tint rc;\n\t\tstruct wordsplit ws;\n\t\t\n\t\tif (strchr(\"./:;,^~\", path[0])) {\n\t\t\tdelim = static_delim;\n\t\t\tdelim[0] = path[0];\n\t\t\tpath++;\n\t\t}\n\t\tws.ws_delim = delim;\n      \n\t\trc = wordsplit(path, &ws,\n\t\t\t       WRDSF_DELIM | WRDSF_DEFFLAGS);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\targc = ws.ws_wordc;\n\t\targv = ws.ws_wordv;\n\t\tws.ws_wordc = 0;\n\t\tws.ws_wordv = NULL;\n\t\twordsplit_free(&ws);\n\t}\n\n\t*pargv = argv;\n\t*pargc = argc;\n\tif (pvalv) {\n\t\tint i;\n\t\tgrecs_value_t **valv;\n\t\t\n\t\tvalv = grecs_calloc(argc, sizeof(valv[0]));\n\t\tfor (i = 0; i < argc; i++) {\n\t\t\tchar *p = strchr(argv[i], '=');\n\t\t\tif (p) {\n\t\t\t\t*p++ = 0;\n\t\t\t\tvalv[i] = parse_label(p);\n\t\t\t}\n\t\t}\n\t\t*pvalv = valv;\n\t}\n\treturn 0;\n}",
      "lines": 60,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_node_exact_match": {
      "start_point": [
        362,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "enum grecs_tree_recurse_res\ngrecs_node_exact_match(enum grecs_tree_recurse_op op,\n\t\t       struct grecs_node *node, void *data)\n{\n\tint match = 0;\n\tstruct grecs_match_buf *buf = data;\n\n\tif (node->type == grecs_node_root)\n\t\treturn grecs_tree_recurse_ok;\n\tif (op == grecs_tree_recurse_post) {\n\t\tif (buf->argi == 0)\n\t\t\treturn grecs_tree_recurse_stop;\n\t\t--buf->argi;\n\t\treturn grecs_tree_recurse_ok;\n\t}\n\t\n\tif (strcmp(buf->argv[buf->argi], node->ident) == 0\n\t    && (!buf->labelv[buf->argi] ||\n\t\tgrecs_value_eq(buf->labelv[buf->argi], node->v.value))) {\n\t\tif (buf->argi + 1 == buf->argc) {\n\t\t\tbuf->node = node;\n\t\t\treturn grecs_tree_recurse_stop;\n\t\t}\n\t\tmatch = 1;\n\t}\n\n\tif (match) {\n\t\tif (op == grecs_tree_recurse_pre) {\n\t\t\tif (buf->argi + 1 == buf->argc)\t\n\t\t\t\treturn grecs_tree_recurse_skip;\n\t\t\tbuf->argi++;\n\t\t}\n\t\treturn grecs_tree_recurse_ok;\n\t}\n\t\n\treturn node->type == grecs_node_block ?\n\t\tgrecs_tree_recurse_skip : grecs_tree_recurse_ok;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_find_node": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "struct grecs_node *\ngrecs_find_node(struct grecs_node *node, const char *path)\n{\n\tint rc;\n\tstruct grecs_match_buf buf;\n  \n\tif (strcmp(path, \".\") == 0)\n\t\treturn node;\n\trc = split_cfg_path(path, &buf.argc, &buf.argv, &buf.labelv);\n\tif (rc || !buf.argc)\n\t\treturn NULL;\n\tbuf.argi = 0;\n\tbuf.node = NULL;\n\tgrecs_tree_recurse(node, grecs_node_exact_match, &buf);\n\tgrecs_match_buf_free_contents(&buf);\n\treturn buf.node;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_find_node(struct grecs_node *node, const char *path)",
        "*"
      ]
    },
    "fixup_loci": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "static void\nfixup_loci(struct grecs_node *node, \n\t   grecs_locus_t const *plocus,\n\t   struct grecs_locus_point const *endp)\n{\n\tgrecs_locus_t loc = *plocus;\n\t\n\tfor (; node; node = node->down) {\n\t\tnode->idloc = loc;\n\t\t\n\t\tnode->locus = loc;\n\t\tif (endp)\n\t\t\tnode->locus.end = *endp;\n\t}\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_node_from_path_locus": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "struct grecs_node *\ngrecs_node_from_path_locus(const char *path, const char *value,\n\t\t\t   grecs_locus_t *plocus, grecs_locus_t *vallocus)\n{\n\tint rc;\n\tint i;\n\tint argc;\n\tchar **argv;\n\tstruct grecs_node *dn = NULL;\n\t\n\trc = split_cfg_path(path, &argc, &argv, NULL);\n\tif (rc)\n\t\treturn NULL;\n\n\tdn = grecs_node_create(grecs_node_stmt, NULL);\n\tdn->ident = argv[argc - 1];\n\tif (value) {\n\t\tstruct grecs_value *gval = parse_label(value);\n\t\tif (vallocus)\n\t\t\tgval->locus = *vallocus;\n\t\tdn->v.value = gval;\n\t} else\n\t\tdn->v.value = NULL;\t\t\n\t\n\tfor (i = argc - 2; i >= 0; i--) {\n\t\tstruct grecs_value *label = NULL;\n\t\tstruct grecs_node *node;\n\t\tchar *p, *q = argv[i];\n\n\t\tdo {\n\t\t\tp = strchr(q, '=');\n\t\t\tif (p && p > argv[i] && p[-1] != '\\\\') {\n\t\t\t\t*p++ = 0;\n\t\t\t\tlabel = parse_label(p);\n\t\t\t\tbreak;\n\t\t\t} else if (p)\n\t\t\t\tq = p + 1;\n\t\t\telse\n\t\t\t\tbreak;\n\t\t} while (*q);\n\t\t\n\t\tnode = grecs_node_create(grecs_node_block, plocus);\n\t\tnode->ident = argv[i];\n\t\tif (label)\n\t\t\tnode->v.value = label;\n\n\t\tnode->down = dn;\n\t\tif (dn)\n\t\t\tdn->up = node;\n\t\tdn = node;\n\t}\n\n\tif (plocus)\n\t\tfixup_loci(dn, \n\t\t\t   plocus, vallocus ? &vallocus->end : NULL);\n\t\t\n\tfree(argv);\n\treturn dn;\n}",
      "lines": 59,
      "depth": 13,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_node_from_path_locus(const char *path, const char *value,\n\t\t\t   grecs_locus_t *plocus, grecs_locus_t *vallocus)",
        "*"
      ]
    },
    "grecs_node_from_path": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        500,
        1
      ],
      "content": "struct grecs_node *\ngrecs_node_from_path(const char *path, const char *value)\n{\n\treturn grecs_node_from_path_locus(path, value, NULL, NULL);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_node_from_path(const char *path, const char *value)",
        "*"
      ]
    },
    "is_root": {
      "start_point": [
        503,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static int\nis_root(struct grecs_match_buf *buf, struct grecs_node *node)\n{\n\treturn (buf->root == node || node->type == grecs_node_root);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_match": {
      "start_point": [
        509,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static int\ngrecs_match(struct grecs_match_buf *buf)\n{\n\tstruct grecs_node *node;\n\tint wcard = 0;\n\t\n\tbuf->argi = buf->argc - 1;\n\tnode = buf->node;\n\n\twhile (buf->argi >= 0) {\n\t\tif (ISWC(buf->argv[buf->argi], '*')) {\n\t\t\twcard = 1;\n\t\t\tif (buf->argi-- == 0)\n\t\t\t\treturn 1;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tif ((ISWC(buf->argv[buf->argi], '%') ||\n\t\t     strcmp(buf->argv[buf->argi], node->ident) == 0)\n\t\t    /* FIXME: */\n\t\t    && (!buf->labelv[buf->argi] ||\n\t\t\tgrecs_value_match(buf->labelv[buf->argi],\n\t\t\t\t\t  node->v.value, 0))) {\n\t\t\twcard = 0;\n\t\t\tnode = node->up;\n\t\t\tif (buf->argi-- == 0)\n\t\t\t\treturn is_root(buf, node);\n\t\t} else if (!wcard)\n\t\t\treturn 0;\n\t\telse\n\t\t\tnode = node->up;\n\t\tif (is_root(buf, node))\n\t\t\treturn ISWC(buf->argv[buf->argi], '*');\n\t}\n\treturn 0;\n}",
      "lines": 36,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_match_next": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "struct grecs_node *\ngrecs_match_next(struct grecs_match_buf *buf)\n{\n\tif (!buf)\n\t\treturn NULL;\n\twhile ((buf->node = grecs_next_node(buf->node)))\n\t\tif (grecs_match(buf))\n\t\t\tbreak;\n\treturn buf->node;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_match_next(struct grecs_match_buf *buf)",
        "*"
      ]
    },
    "grecs_match_buf_first": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "struct grecs_node *\ngrecs_match_buf_first(struct grecs_match_buf *buf, struct grecs_node *tree)\n{\n\tstruct grecs_node *node;\n\n\tbuf->argi = 0;\n\tbuf->root = tree;\n\tbuf->node = grecs_tree_first_node(tree);\n\tif (!buf->node)\n\t\treturn NULL;\n\tif (grecs_match(buf))\n\t\tnode = buf->node;\n\telse\n\t\tnode = grecs_match_next(buf);\n\treturn node;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_match_buf_first(struct grecs_match_buf *buf, struct grecs_node *tree)",
        "*"
      ]
    },
    "grecs_match_first": {
      "start_point": [
        574,
        0
      ],
      "end_point": [
        599,
        1
      ],
      "content": "struct grecs_node *\ngrecs_match_first(struct grecs_node *tree, const char *pattern,\n\t\t  struct grecs_match_buf **pbuf)\n{\n\tstruct grecs_node *node;\n\tstruct grecs_match_buf *buf;\n\n\tif (strcmp(pattern, \".\") == 0) {\n\t\t*pbuf = NULL;\n\t\treturn tree;\n\t}\n\t\n\tbuf = grecs_zalloc(sizeof(*buf));\n\tif (split_cfg_path(pattern, &buf->argc, &buf->argv, &buf->labelv)) {\n\t\tfree(buf);\n\t\treturn NULL;\n\t}\n\tnode = grecs_match_buf_first(buf, tree);\n\tif (node)\n\t\t*pbuf = buf;\n\telse {\n\t\tgrecs_match_buf_free(buf);\n\t\t*pbuf = NULL;\n\t}\n\treturn node;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_match_first(struct grecs_node *tree, const char *pattern,\n\t\t  struct grecs_match_buf **pbuf)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/mem.c": {
    "def_malloc_fun": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "static void *\ndef_malloc_fun(size_t size)\n{\n\treturn malloc(size);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndef_malloc_fun(size_t size)",
        "*"
      ]
    },
    "def_realloc_fun": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static void *\ndef_realloc_fun(void *ptr, size_t size)\n{\n\treturn realloc(ptr, size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ndef_realloc_fun(void *ptr, size_t size)",
        "*"
      ]
    },
    "def_free_fun": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static void\ndef_free_fun(void *ptr)\n{\n\tfree(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_free": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ngrecs_free(void *ptr)\n{\n\tgrecs_free_fun(ptr);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_malloc": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void *\ngrecs_malloc(size_t size)\n{\n\tvoid *ptr = grecs_malloc_fun(size);\n\tif (!ptr)\n\t\tgrecs_alloc_die();\n\treturn ptr;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_malloc(size_t size)",
        "*"
      ]
    },
    "grecs_zalloc": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void *\ngrecs_zalloc(size_t size)\n{\n\tvoid *ptr = grecs_malloc(size);\n\tmemset(ptr, 0, size);\n\treturn ptr;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_zalloc(size_t size)",
        "*"
      ]
    },
    "grecs_calloc": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void *\ngrecs_calloc(size_t nmemb, size_t size)\n{\n\treturn grecs_zalloc(nmemb * size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_calloc(size_t nmemb, size_t size)",
        "*"
      ]
    },
    "grecs_realloc": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void *\ngrecs_realloc(void *ptr, size_t size)\n{\n\tvoid *newptr = grecs_realloc_fun(ptr, size);\n\tif (!newptr)\n\t\tgrecs_alloc_die();\n\treturn newptr;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void",
        "*\ngrecs_realloc(void *ptr, size_t size)",
        "*"
      ]
    },
    "grecs_strdup": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "char *\ngrecs_strdup(const char *str)\n{\n\tchar *newstr = grecs_malloc(strlen(str) + 1);\n\treturn strcpy(newstr, str);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "char",
        "*\ngrecs_strdup(const char *str)",
        "*"
      ]
    },
    "grecs_alloc_die": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\ngrecs_alloc_die(void)\n{\n\tif (grecs_alloc_die_fun)\n\t\tgrecs_alloc_die_fun();\n\tgrecs_error(NULL, ENOMEM, \"fatal error\");\n\texit(70); /* EX_SOFTWARE */\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/meta1-gram.c": {
    "grecs_meta1_tnamerr": {
      "start_point": [
        947,
        0
      ],
      "end_point": [
        984,
        1
      ],
      "content": "static YYSIZE_T\ngrecs_meta1_tnamerr (char *grecs_meta1_res, const char *grecs_meta1_str)\n{\n  if (*grecs_meta1_str == '\"')\n    {\n      YYSIZE_T grecs_meta1_n = 0;\n      char const *grecs_meta1_p = grecs_meta1_str;\n\n      for (;;)\n\tswitch (*++grecs_meta1_p)\n\t  {\n\t  case '\\'':\n\t  case ',':\n\t    goto do_not_strip_quotes;\n\n\t  case '\\\\':\n\t    if (*++grecs_meta1_p != '\\\\')\n\t      goto do_not_strip_quotes;\n\t    /* Fall through.  */\n\t  default:\n\t    if (grecs_meta1_res)\n\t      grecs_meta1_res[grecs_meta1_n] = *grecs_meta1_p;\n\t    grecs_meta1_n++;\n\t    break;\n\n\t  case '\"':\n\t    if (grecs_meta1_res)\n\t      grecs_meta1_res[grecs_meta1_n] = '\\0';\n\t    return grecs_meta1_n;\n\t  }\n    do_not_strip_quotes: ;\n    }\n\n  if (! grecs_meta1_res)\n    return grecs_meta1_strlen (grecs_meta1_str);\n\n  return grecs_meta1_stpcpy (grecs_meta1_res, grecs_meta1_str) - grecs_meta1_res;\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "YYSIZE_T"
      ]
    },
    "grecs_meta1_syntax_error": {
      "start_point": [
        995,
        0
      ],
      "end_point": [
        1121,
        1
      ],
      "content": "static int\ngrecs_meta1_syntax_error (YYSIZE_T *grecs_meta1_msg_alloc, char **grecs_meta1_msg,\n                grecs_meta1_type_int16 *grecs_meta1_ssp, int grecs_meta1_token)\n{\n  YYSIZE_T grecs_meta1_size0 = grecs_meta1_tnamerr (YY_NULL, grecs_meta1_tname[grecs_meta1_token]);\n  YYSIZE_T grecs_meta1_size = grecs_meta1_size0;\n  YYSIZE_T grecs_meta1_size1;\n  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };\n  /* Internationalized format string. */\n  const char *grecs_meta1_format = YY_NULL;\n  /* Arguments of grecs_meta1_format. */\n  char const *grecs_meta1_arg[YYERROR_VERBOSE_ARGS_MAXIMUM];\n  /* Number of reported tokens (one for the \"unexpected\", one per\n     \"expected\"). */\n  int grecs_meta1_count = 0;\n\n  /* There are many possibilities here to consider:\n     - Assume YYFAIL is not used.  It's too flawed to consider.  See\n       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>\n       for details.  YYERROR is fine as it does not invoke this\n       function.\n     - If this state is a consistent state with a default action, then\n       the only way this function was invoked is if the default action\n       is an error action.  In that case, don't check for expected\n       tokens because there are none.\n     - The only way there can be no lookahead present (in grecs_meta1_char) is if\n       this state is a consistent state with a default action.  Thus,\n       detecting the absence of a lookahead is sufficient to determine\n       that there is no unexpected or expected token to report.  In that\n       case, just report a simple \"syntax error\".\n     - Don't assume there isn't a lookahead just because this state is a\n       consistent state with a default action.  There might have been a\n       previous inconsistent state, consistent state with a non-default\n       action, or user semantic action that manipulated grecs_meta1_char.\n     - Of course, the expected token list depends on states to have\n       correct lookahead information, and it depends on the parser not\n       to perform extra reductions after fetching a lookahead from the\n       scanner and before detecting a syntax error.  Thus, state merging\n       (from LALR or IELR) and default reductions corrupt the expected\n       token list.  However, the list is correct for canonical LR with\n       one exception: it will still contain any token that will not be\n       accepted due to an error action in a later state.\n  */\n  if (grecs_meta1_token != YYEMPTY)\n    {\n      int grecs_meta1_n = grecs_meta1_pact[*grecs_meta1_ssp];\n      grecs_meta1_arg[grecs_meta1_count++] = grecs_meta1_tname[grecs_meta1_token];\n      if (!grecs_meta1_pact_value_is_default (grecs_meta1_n))\n        {\n          /* Start YYX at -YYN if negative to avoid negative indexes in\n             YYCHECK.  In other words, skip the first -YYN actions for\n             this state because they are default actions.  */\n          int grecs_meta1_xbegin = grecs_meta1_n < 0 ? -grecs_meta1_n : 0;\n          /* Stay within bounds of both grecs_meta1_check and grecs_meta1_tname.  */\n          int grecs_meta1_checklim = YYLAST - grecs_meta1_n + 1;\n          int grecs_meta1_xend = grecs_meta1_checklim < YYNTOKENS ? grecs_meta1_checklim : YYNTOKENS;\n          int grecs_meta1_x;\n\n          for (grecs_meta1_x = grecs_meta1_xbegin; grecs_meta1_x < grecs_meta1_xend; ++grecs_meta1_x)\n            if (grecs_meta1_check[grecs_meta1_x + grecs_meta1_n] == grecs_meta1_x && grecs_meta1_x != YYTERROR\n                && !grecs_meta1_table_value_is_error (grecs_meta1_table[grecs_meta1_x + grecs_meta1_n]))\n              {\n                if (grecs_meta1_count == YYERROR_VERBOSE_ARGS_MAXIMUM)\n                  {\n                    grecs_meta1_count = 1;\n                    grecs_meta1_size = grecs_meta1_size0;\n                    break;\n                  }\n                grecs_meta1_arg[grecs_meta1_count++] = grecs_meta1_tname[grecs_meta1_x];\n                grecs_meta1_size1 = grecs_meta1_size + grecs_meta1_tnamerr (YY_NULL, grecs_meta1_tname[grecs_meta1_x]);\n                if (! (grecs_meta1_size <= grecs_meta1_size1\n                       && grecs_meta1_size1 <= YYSTACK_ALLOC_MAXIMUM))\n                  return 2;\n                grecs_meta1_size = grecs_meta1_size1;\n              }\n        }\n    }\n\n  switch (grecs_meta1_count)\n    {\n# define YYCASE_(N, S)                      \\\n      case N:                               \\\n        grecs_meta1_format = S;                       \\\n      break\n      YYCASE_(0, YY_(\"syntax error\"));\n      YYCASE_(1, YY_(\"syntax error, unexpected %s\"));\n      YYCASE_(2, YY_(\"syntax error, unexpected %s, expecting %s\"));\n      YYCASE_(3, YY_(\"syntax error, unexpected %s, expecting %s or %s\"));\n      YYCASE_(4, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s\"));\n      YYCASE_(5, YY_(\"syntax error, unexpected %s, expecting %s or %s or %s or %s\"));\n# undef YYCASE_\n    }\n\n  grecs_meta1_size1 = grecs_meta1_size + grecs_meta1_strlen (grecs_meta1_format);\n  if (! (grecs_meta1_size <= grecs_meta1_size1 && grecs_meta1_size1 <= YYSTACK_ALLOC_MAXIMUM))\n    return 2;\n  grecs_meta1_size = grecs_meta1_size1;\n\n  if (*grecs_meta1_msg_alloc < grecs_meta1_size)\n    {\n      *grecs_meta1_msg_alloc = 2 * grecs_meta1_size;\n      if (! (grecs_meta1_size <= *grecs_meta1_msg_alloc\n             && *grecs_meta1_msg_alloc <= YYSTACK_ALLOC_MAXIMUM))\n        *grecs_meta1_msg_alloc = YYSTACK_ALLOC_MAXIMUM;\n      return 1;\n    }\n\n  /* Avoid sprintf, as that infringes on the user's name space.\n     Don't have undefined behavior even if the translation\n     produced a string with the wrong number of \"%s\"s.  */\n  {\n    char *grecs_meta1_p = *grecs_meta1_msg;\n    int grecs_meta1_i = 0;\n    while ((*grecs_meta1_p = *grecs_meta1_format) != '\\0')\n      if (*grecs_meta1_p == '%' && grecs_meta1_format[1] == 's' && grecs_meta1_i < grecs_meta1_count)\n        {\n          grecs_meta1_p += grecs_meta1_tnamerr (grecs_meta1_p, grecs_meta1_arg[grecs_meta1_i++]);\n          grecs_meta1_format += 2;\n        }\n      else\n        {\n          grecs_meta1_p++;\n          grecs_meta1_format++;\n        }\n  }\n  return 0;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_meta1_error": {
      "start_point": [
        1913,
        0
      ],
      "end_point": [
        1918,
        1
      ],
      "content": "int\ngrecs_meta1_error(char const *s)\n{\n\tgrecs_error(&grecs_meta1_lloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1_parser": {
      "start_point": [
        1920,
        0
      ],
      "end_point": [
        1946,
        1
      ],
      "content": "struct grecs_node *\ngrecs_meta1_parser(const char *name, int traceflags)\n{\n\tint rc;\n\tFILE *fp;\n\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(NULL, errno, _(\"Cannot open `%s'\"), name);\n\t\treturn NULL;\n\t}\n\tgrecs_meta1_set_in(fp);\n\tgrecs_meta1__flex_debug = traceflags & GRECS_TRACE_LEX;\n\tgrecs_meta1_debug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = grecs_meta1_parse();\n\tfclose(fp);\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_meta1_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/meta1-gram.y": {
    "block": {
      "start_point": [
        75,
        10
      ],
      "end_point": [
        78,
        4
      ],
      "content": "stmtlist stmt\n          {\n\t\t  grecs_node_bind($1.tail, $2, 0);\n\t  }",
      "lines": 4,
      "depth": 5,
      "decorators": null
    },
    "yyerror": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "int\nyyerror(char const *s)\n{\n\tgrecs_error(&yylloc, 0, \"%s\", s);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1_parser": {
      "start_point": [
        198,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "struct grecs_node *\ngrecs_meta1_parser(const char *name, int traceflags)\n{\n\tint rc;\n\tFILE *fp;\n\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(NULL, errno, _(\"Cannot open `%s'\"), name);\n\t\treturn NULL;\n\t}\n\tyyset_in(fp);\n\tyy_flex_debug = traceflags & GRECS_TRACE_LEX;\n\tyydebug = traceflags & GRECS_TRACE_GRAM;\n\tparse_tree = NULL;\n\tgrecs_line_acc_create();\n\trc = yyparse();\n\tfclose(fp);\n\tif (grecs_error_count)\n\t\trc = 1;\n\tgrecs_line_acc_free();\n\tif (rc) {\n\t\tgrecs_tree_free(parse_tree);\n\t\tparse_tree = NULL;\n\t}\n\treturn parse_tree;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_meta1_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/meta1-lex.c": {
    "grecs_meta1__get_next_buffer": {
      "start_point": [
        1290,
        0
      ],
      "end_point": [
        1423,
        1
      ],
      "content": "static int grecs_meta1__get_next_buffer (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tregister char *dest = YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf;\n\tregister char *source = (grecs_meta1_text_ptr);\n\tregister int number_to_move, i;\n\tint ret_val;\n\n\tif ( (grecs_meta1__c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf[(grecs_meta1__n_chars) + 1] )\n\t\tYY_FATAL_ERROR(\n\t\t\"fatal flex scanner internal error--end of buffer missed\" );\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_meta1__fill_buffer == 0 )\n\t\t{ /* Don't try to fill the buffer, so this is an EOF. */\n\t\tif ( (grecs_meta1__c_buf_p) - (grecs_meta1_text_ptr) - YY_MORE_ADJ == 1 )\n\t\t\t{\n\t\t\t/* We matched a single character, the EOB, so\n\t\t\t * treat this as a final EOF.\n\t\t\t */\n\t\t\treturn EOB_ACT_END_OF_FILE;\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\t/* We matched some text prior to the EOB, first\n\t\t\t * process it.\n\t\t\t */\n\t\t\treturn EOB_ACT_LAST_MATCH;\n\t\t\t}\n\t\t}\n\n\t/* Try to read more data. */\n\n\t/* First move last chars to start of buffer. */\n\tnumber_to_move = (int) ((grecs_meta1__c_buf_p) - (grecs_meta1_text_ptr)) - 1;\n\n\tfor ( i = 0; i < number_to_move; ++i )\n\t\t*(dest++) = *(source++);\n\n\tif ( YY_CURRENT_BUFFER_LVALUE->grecs_meta1__buffer_status == YY_BUFFER_EOF_PENDING )\n\t\t/* don't do the read, it's not guaranteed to return an EOF,\n\t\t * just force an EOF\n\t\t */\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__n_chars = (grecs_meta1__n_chars) = 0;\n\n\telse\n\t\t{\n\t\t\tint num_to_read =\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_size - number_to_move - 1;\n\n\t\twhile ( num_to_read <= 0 )\n\t\t\t{ /* Not enough room in the buffer - grow it. */\n\n\t\t\t/* just a shorter name for the current buffer */\n\t\t\tYY_BUFFER_STATE b = YY_CURRENT_BUFFER;\n\n\t\t\tint grecs_meta1__c_buf_p_offset =\n\t\t\t\t(int) ((grecs_meta1__c_buf_p) - b->grecs_meta1__ch_buf);\n\n\t\t\tif ( b->grecs_meta1__is_our_buffer )\n\t\t\t\t{\n\t\t\t\tint new_size = b->grecs_meta1__buf_size * 2;\n\n\t\t\t\tif ( new_size <= 0 )\n\t\t\t\t\tb->grecs_meta1__buf_size += b->grecs_meta1__buf_size / 8;\n\t\t\t\telse\n\t\t\t\t\tb->grecs_meta1__buf_size *= 2;\n\n\t\t\t\tb->grecs_meta1__ch_buf = (char *)\n\t\t\t\t\t/* Include room in for 2 EOB chars. */\n\t\t\t\t\tgrecs_meta1_realloc((void *) b->grecs_meta1__ch_buf,b->grecs_meta1__buf_size + 2  );\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t/* Can't grow it, we don't own it. */\n\t\t\t\tb->grecs_meta1__ch_buf = 0;\n\n\t\t\tif ( ! b->grecs_meta1__ch_buf )\n\t\t\t\tYY_FATAL_ERROR(\n\t\t\t\t\"fatal error - scanner input buffer overflow\" );\n\n\t\t\t(grecs_meta1__c_buf_p) = &b->grecs_meta1__ch_buf[grecs_meta1__c_buf_p_offset];\n\n\t\t\tnum_to_read = YY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_size -\n\t\t\t\t\t\tnumber_to_move - 1;\n\n\t\t\t}\n\n\t\tif ( num_to_read > YY_READ_BUF_SIZE )\n\t\t\tnum_to_read = YY_READ_BUF_SIZE;\n\n\t\t/* Read in more data. */\n\t\tYY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf[number_to_move]),\n\t\t\t(grecs_meta1__n_chars), (size_t) num_to_read );\n\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__n_chars = (grecs_meta1__n_chars);\n\t\t}\n\n\tif ( (grecs_meta1__n_chars) == 0 )\n\t\t{\n\t\tif ( number_to_move == YY_MORE_ADJ )\n\t\t\t{\n\t\t\tret_val = EOB_ACT_END_OF_FILE;\n\t\t\tgrecs_meta1_restart(grecs_meta1_in  );\n\t\t\t}\n\n\t\telse\n\t\t\t{\n\t\t\tret_val = EOB_ACT_LAST_MATCH;\n\t\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__buffer_status =\n\t\t\t\tYY_BUFFER_EOF_PENDING;\n\t\t\t}\n\t\t}\n\n\telse\n\t\tret_val = EOB_ACT_CONTINUE_SCAN;\n\n\tif ((grecs_meta1__size_t) ((grecs_meta1__n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_size) {\n\t\t/* Extend the array by 50%, plus the number we really need. */\n\t\tgrecs_meta1__size_t new_size = (grecs_meta1__n_chars) + number_to_move + ((grecs_meta1__n_chars) >> 1);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf = (char *) grecs_meta1_realloc((void *) YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf,new_size  );\n\t\tif ( ! YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1__get_next_buffer()\" );\n\t}\n\n\t(grecs_meta1__n_chars) += number_to_move;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf[(grecs_meta1__n_chars)] = YY_END_OF_BUFFER_CHAR;\n\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf[(grecs_meta1__n_chars) + 1] = YY_END_OF_BUFFER_CHAR;\n\n\t(grecs_meta1_text_ptr) = &YY_CURRENT_BUFFER_LVALUE->grecs_meta1__ch_buf[0];\n\n\treturn ret_val;\n}",
      "lines": 134,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_meta1__get_previous_state": {
      "start_point": [
        1430,
        4
      ],
      "end_point": [
        1460,
        1
      ],
      "content": "static grecs_meta1__state_type grecs_meta1__get_previous_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister grecs_meta1__state_type grecs_meta1__current_state;\n\tregister char *grecs_meta1__cp;\n    \n/* %% [15.0] code to get the start state into grecs_meta1__current_state goes here */\n\tgrecs_meta1__current_state = (grecs_meta1__start);\n\n\tfor ( grecs_meta1__cp = (grecs_meta1_text_ptr) + YY_MORE_ADJ; grecs_meta1__cp < (grecs_meta1__c_buf_p); ++grecs_meta1__cp )\n\t\t{\n/* %% [16.0] code to find the next state goes here */\n\t\tregister YY_CHAR grecs_meta1__c = (*grecs_meta1__cp ? grecs_meta1__ec[YY_SC_TO_UI(*grecs_meta1__cp)] : 1);\n\t\tif ( grecs_meta1__accept[grecs_meta1__current_state] )\n\t\t\t{\n\t\t\t(grecs_meta1__last_accepting_state) = grecs_meta1__current_state;\n\t\t\t(grecs_meta1__last_accepting_cpos) = grecs_meta1__cp;\n\t\t\t}\n\t\twhile ( grecs_meta1__chk[grecs_meta1__base[grecs_meta1__current_state] + grecs_meta1__c] != grecs_meta1__current_state )\n\t\t\t{\n\t\t\tgrecs_meta1__current_state = (int) grecs_meta1__def[grecs_meta1__current_state];\n\t\t\tif ( grecs_meta1__current_state >= 54 )\n\t\t\t\tgrecs_meta1__c = grecs_meta1__meta[(unsigned int) grecs_meta1__c];\n\t\t\t}\n\t\tgrecs_meta1__current_state = grecs_meta1__nxt[grecs_meta1__base[grecs_meta1__current_state] + (unsigned int) grecs_meta1__c];\n\t\t}\n\n\treturn grecs_meta1__current_state;\n}",
      "lines": 31,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "grecs_meta1__state_type"
      ]
    },
    "grecs_meta1__try_NUL_trans": {
      "start_point": [
        1468,
        4
      ],
      "end_point": [
        1493,
        1
      ],
      "content": "static grecs_meta1__state_type grecs_meta1__try_NUL_trans  (grecs_meta1__state_type grecs_meta1__current_state )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tregister int grecs_meta1__is_jam;\n    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */\n\tregister char *grecs_meta1__cp = (grecs_meta1__c_buf_p);\n\n\tregister YY_CHAR grecs_meta1__c = 1;\n\tif ( grecs_meta1__accept[grecs_meta1__current_state] )\n\t\t{\n\t\t(grecs_meta1__last_accepting_state) = grecs_meta1__current_state;\n\t\t(grecs_meta1__last_accepting_cpos) = grecs_meta1__cp;\n\t\t}\n\twhile ( grecs_meta1__chk[grecs_meta1__base[grecs_meta1__current_state] + grecs_meta1__c] != grecs_meta1__current_state )\n\t\t{\n\t\tgrecs_meta1__current_state = (int) grecs_meta1__def[grecs_meta1__current_state];\n\t\tif ( grecs_meta1__current_state >= 54 )\n\t\t\tgrecs_meta1__c = grecs_meta1__meta[(unsigned int) grecs_meta1__c];\n\t\t}\n\tgrecs_meta1__current_state = grecs_meta1__nxt[grecs_meta1__base[grecs_meta1__current_state] + (unsigned int) grecs_meta1__c];\n\tgrecs_meta1__is_jam = (grecs_meta1__current_state == 53);\n\n\treturn grecs_meta1__is_jam ? 0 : grecs_meta1__current_state;\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "grecs_meta1__state_type"
      ]
    },
    "grecs_meta1_restart": {
      "start_point": [
        1587,
        4
      ],
      "end_point": [
        1601,
        1
      ],
      "content": "void grecs_meta1_restart  (FILE * input_file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! YY_CURRENT_BUFFER ){\n        grecs_meta1_ensure_buffer_stack ();\n\t\tYY_CURRENT_BUFFER_LVALUE =\n            grecs_meta1__create_buffer(grecs_meta1_in,YY_BUF_SIZE );\n\t}\n\n\tgrecs_meta1__init_buffer(YY_CURRENT_BUFFER,input_file );\n\tgrecs_meta1__load_buffer_state( );\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1__switch_to_buffer": {
      "start_point": [
        1608,
        4
      ],
      "end_point": [
        1640,
        1
      ],
      "content": "void grecs_meta1__switch_to_buffer  (YY_BUFFER_STATE  new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\t/* TODO. We should be able to replace this entire function body\n\t * with\n\t *\t\tgrecs_meta1_pop_buffer_state();\n\t *\t\tgrecs_meta1_push_buffer_state(new_buffer);\n     */\n\tgrecs_meta1_ensure_buffer_stack ();\n\tif ( YY_CURRENT_BUFFER == new_buffer )\n\t\treturn;\n\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_meta1__c_buf_p) = (grecs_meta1__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_pos = (grecs_meta1__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__n_chars = (grecs_meta1__n_chars);\n\t\t}\n\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\tgrecs_meta1__load_buffer_state( );\n\n\t/* We don't actually know whether we did this switch during\n\t * EOF (grecs_meta1_wrap()) processing, but the only time this flag\n\t * is looked at is after grecs_meta1_wrap() is called, so it's safe\n\t * to go ahead and always set it.\n\t */\n\t(grecs_meta1__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1__load_buffer_state": {
      "start_point": [
        1643,
        0
      ],
      "end_point": [
        1652,
        1
      ],
      "content": "static void grecs_meta1__load_buffer_state  (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \t(grecs_meta1__n_chars) = YY_CURRENT_BUFFER_LVALUE->grecs_meta1__n_chars;\n\t(grecs_meta1_text_ptr) = (grecs_meta1__c_buf_p) = YY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_pos;\n\tgrecs_meta1_in = YY_CURRENT_BUFFER_LVALUE->grecs_meta1__input_file;\n\t(grecs_meta1__hold_char) = *(grecs_meta1__c_buf_p);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_meta1__create_buffer": {
      "start_point": [
        1661,
        4
      ],
      "end_point": [
        1686,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_meta1__create_buffer  (FILE * file, int  size )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tYY_BUFFER_STATE b;\n    \n\tb = (YY_BUFFER_STATE) grecs_meta1_alloc(sizeof( struct grecs_meta1__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1__create_buffer()\" );\n\n\tb->grecs_meta1__buf_size = size;\n\n\t/* grecs_meta1__ch_buf has to be 2 characters longer than the size given because\n\t * we need to put in 2 end-of-buffer characters.\n\t */\n\tb->grecs_meta1__ch_buf = (char *) grecs_meta1_alloc(b->grecs_meta1__buf_size + 2  );\n\tif ( ! b->grecs_meta1__ch_buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1__create_buffer()\" );\n\n\tb->grecs_meta1__is_our_buffer = 1;\n\n\tgrecs_meta1__init_buffer(b,file );\n\n\treturn b;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_meta1__delete_buffer": {
      "start_point": [
        1693,
        4
      ],
      "end_point": [
        1709,
        1
      ],
      "content": "void grecs_meta1__delete_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \n\tif ( ! b )\n\t\treturn;\n\n\tif ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */\n\t\tYY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;\n\n\tif ( b->grecs_meta1__is_our_buffer )\n\t\tgrecs_meta1_free((void *) b->grecs_meta1__ch_buf  );\n\n\tgrecs_meta1_free((void *) b  );\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1__init_buffer": {
      "start_point": [
        1727,
        4
      ],
      "end_point": [
        1757,
        1
      ],
      "content": "static void grecs_meta1__init_buffer  (YY_BUFFER_STATE  b, FILE * file )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\n{\n\tint oerrno = errno;\n    \n\tgrecs_meta1__flush_buffer(b );\n\n\tb->grecs_meta1__input_file = file;\n\tb->grecs_meta1__fill_buffer = 1;\n\n    /* If b is the current buffer, then grecs_meta1__init_buffer was _probably_\n     * called from grecs_meta1_restart() or through grecs_meta1__get_next_buffer.\n     * In that case, we don't want to reset the lineno or column.\n     */\n    if (b != YY_CURRENT_BUFFER){\n        b->grecs_meta1__bs_lineno = 1;\n        b->grecs_meta1__bs_column = 0;\n    }\n\n/* %if-c-only */\n\n        b->grecs_meta1__is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;\n    \n/* %endif */\n/* %if-c++-only */\n/* %endif */\n\terrno = oerrno;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_meta1__flush_buffer": {
      "start_point": [
        1764,
        4
      ],
      "end_point": [
        1788,
        1
      ],
      "content": "void grecs_meta1__flush_buffer (YY_BUFFER_STATE  b )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif ( ! b )\n\t\treturn;\n\n\tb->grecs_meta1__n_chars = 0;\n\n\t/* We always need two end-of-buffer characters.  The first causes\n\t * a transition to the end-of-buffer state.  The second causes\n\t * a jam in that state.\n\t */\n\tb->grecs_meta1__ch_buf[0] = YY_END_OF_BUFFER_CHAR;\n\tb->grecs_meta1__ch_buf[1] = YY_END_OF_BUFFER_CHAR;\n\n\tb->grecs_meta1__buf_pos = &b->grecs_meta1__ch_buf[0];\n\n\tb->grecs_meta1__at_bol = 1;\n\tb->grecs_meta1__buffer_status = YY_BUFFER_NEW;\n\n\tif ( b == YY_CURRENT_BUFFER )\n\t\tgrecs_meta1__load_buffer_state( );\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_push_buffer_state": {
      "start_point": [
        1798,
        0
      ],
      "end_point": [
        1825,
        1
      ],
      "content": "void grecs_meta1_push_buffer_state (YY_BUFFER_STATE new_buffer )\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (new_buffer == NULL)\n\t\treturn;\n\n\tgrecs_meta1_ensure_buffer_stack();\n\n\t/* This block is copied from grecs_meta1__switch_to_buffer. */\n\tif ( YY_CURRENT_BUFFER )\n\t\t{\n\t\t/* Flush out information for old buffer. */\n\t\t*(grecs_meta1__c_buf_p) = (grecs_meta1__hold_char);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__buf_pos = (grecs_meta1__c_buf_p);\n\t\tYY_CURRENT_BUFFER_LVALUE->grecs_meta1__n_chars = (grecs_meta1__n_chars);\n\t\t}\n\n\t/* Only push if top exists. Otherwise, replace top. */\n\tif (YY_CURRENT_BUFFER)\n\t\t(grecs_meta1__buffer_stack_top)++;\n\tYY_CURRENT_BUFFER_LVALUE = new_buffer;\n\n\t/* copied from grecs_meta1__switch_to_buffer. */\n\tgrecs_meta1__load_buffer_state( );\n\t(grecs_meta1__did_buffer_switch_on_eof) = 1;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_pop_buffer_state": {
      "start_point": [
        1834,
        0
      ],
      "end_point": [
        1851,
        1
      ],
      "content": "void grecs_meta1_pop_buffer_state (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n    \tif (!YY_CURRENT_BUFFER)\n\t\treturn;\n\n\tgrecs_meta1__delete_buffer(YY_CURRENT_BUFFER );\n\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\tif ((grecs_meta1__buffer_stack_top) > 0)\n\t\t--(grecs_meta1__buffer_stack_top);\n\n\tif (YY_CURRENT_BUFFER) {\n\t\tgrecs_meta1__load_buffer_state( );\n\t\t(grecs_meta1__did_buffer_switch_on_eof) = 1;\n\t}\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_ensure_buffer_stack": {
      "start_point": [
        1859,
        0
      ],
      "end_point": [
        1903,
        1
      ],
      "content": "static void grecs_meta1_ensure_buffer_stack (void)\n/* %endif */\n/* %if-c++-only */\n/* %endif */\n{\n\tint num_to_alloc;\n    \n\tif (!(grecs_meta1__buffer_stack)) {\n\n\t\t/* First allocation is just for 2 elements, since we don't know if this\n\t\t * scanner will even need a stack. We use 2 instead of 1 to avoid an\n\t\t * immediate realloc on the next call.\n         */\n\t\tnum_to_alloc = 1;\n\t\t(grecs_meta1__buffer_stack) = (struct grecs_meta1__buffer_state**)grecs_meta1_alloc\n\t\t\t\t\t\t\t\t(num_to_alloc * sizeof(struct grecs_meta1__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_meta1__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1_ensure_buffer_stack()\" );\n\t\t\t\t\t\t\t\t  \n\t\tmemset((grecs_meta1__buffer_stack), 0, num_to_alloc * sizeof(struct grecs_meta1__buffer_state*));\n\t\t\t\t\n\t\t(grecs_meta1__buffer_stack_max) = num_to_alloc;\n\t\t(grecs_meta1__buffer_stack_top) = 0;\n\t\treturn;\n\t}\n\n\tif ((grecs_meta1__buffer_stack_top) >= ((grecs_meta1__buffer_stack_max)) - 1){\n\n\t\t/* Increase the buffer to prepare for a possible push. */\n\t\tint grow_size = 8 /* arbitrary grow size */;\n\n\t\tnum_to_alloc = (grecs_meta1__buffer_stack_max) + grow_size;\n\t\t(grecs_meta1__buffer_stack) = (struct grecs_meta1__buffer_state**)grecs_meta1_realloc\n\t\t\t\t\t\t\t\t((grecs_meta1__buffer_stack),\n\t\t\t\t\t\t\t\tnum_to_alloc * sizeof(struct grecs_meta1__buffer_state*)\n\t\t\t\t\t\t\t\t);\n\t\tif ( ! (grecs_meta1__buffer_stack) )\n\t\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1_ensure_buffer_stack()\" );\n\n\t\t/* zero only the new slots.*/\n\t\tmemset((grecs_meta1__buffer_stack) + (grecs_meta1__buffer_stack_max), 0, grow_size * sizeof(struct grecs_meta1__buffer_state*));\n\t\t(grecs_meta1__buffer_stack_max) = num_to_alloc;\n\t}\n}",
      "lines": 45,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_meta1__scan_buffer": {
      "start_point": [
        1913,
        0
      ],
      "end_point": [
        1940,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_meta1__scan_buffer  (char * base, grecs_meta1__size_t  size )\n{\n\tYY_BUFFER_STATE b;\n    \n\tif ( size < 2 ||\n\t     base[size-2] != YY_END_OF_BUFFER_CHAR ||\n\t     base[size-1] != YY_END_OF_BUFFER_CHAR )\n\t\t/* They forgot to leave room for the EOB's. */\n\t\treturn 0;\n\n\tb = (YY_BUFFER_STATE) grecs_meta1_alloc(sizeof( struct grecs_meta1__buffer_state )  );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1__scan_buffer()\" );\n\n\tb->grecs_meta1__buf_size = size - 2;\t/* \"- 2\" to take care of EOB's */\n\tb->grecs_meta1__buf_pos = b->grecs_meta1__ch_buf = base;\n\tb->grecs_meta1__is_our_buffer = 0;\n\tb->grecs_meta1__input_file = 0;\n\tb->grecs_meta1__n_chars = b->grecs_meta1__buf_size;\n\tb->grecs_meta1__is_interactive = 0;\n\tb->grecs_meta1__at_bol = 1;\n\tb->grecs_meta1__fill_buffer = 0;\n\tb->grecs_meta1__buffer_status = YY_BUFFER_NEW;\n\n\tgrecs_meta1__switch_to_buffer(b  );\n\n\treturn b;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_meta1__scan_string": {
      "start_point": [
        1952,
        0
      ],
      "end_point": [
        1956,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_meta1__scan_string (grecs_meta1_const char * grecs_meta1_str )\n{\n    \n\treturn grecs_meta1__scan_bytes(grecs_meta1_str,strlen(grecs_meta1_str) );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_meta1__scan_bytes": {
      "start_point": [
        1967,
        0
      ],
      "end_point": [
        1995,
        1
      ],
      "content": "YY_BUFFER_STATE grecs_meta1__scan_bytes  (grecs_meta1_const char * grecs_meta1_bytes, int  _grecs_meta1_bytes_len )\n{\n\tYY_BUFFER_STATE b;\n\tchar *buf;\n\tgrecs_meta1__size_t n;\n\tint i;\n    \n\t/* Get memory for full buffer, including space for trailing EOB's. */\n\tn = _grecs_meta1_bytes_len + 2;\n\tbuf = (char *) grecs_meta1_alloc(n  );\n\tif ( ! buf )\n\t\tYY_FATAL_ERROR( \"out of dynamic memory in grecs_meta1__scan_bytes()\" );\n\n\tfor ( i = 0; i < _grecs_meta1_bytes_len; ++i )\n\t\tbuf[i] = grecs_meta1_bytes[i];\n\n\tbuf[_grecs_meta1_bytes_len] = buf[_grecs_meta1_bytes_len+1] = YY_END_OF_BUFFER_CHAR;\n\n\tb = grecs_meta1__scan_buffer(buf,n );\n\tif ( ! b )\n\t\tYY_FATAL_ERROR( \"bad buffer in grecs_meta1__scan_bytes()\" );\n\n\t/* It's okay to grow etc. this buffer, and we should throw it\n\t * away when we're done.\n\t */\n\tb->grecs_meta1__is_our_buffer = 1;\n\n\treturn b;\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "YY_BUFFER_STATE"
      ]
    },
    "grecs_meta1__fatal_error": {
      "start_point": [
        2003,
        0
      ],
      "end_point": [
        2007,
        1
      ],
      "content": "static void grecs_meta1__fatal_error (grecs_meta1_const char* msg )\n{\n    \t(void) fprintf( stderr, \"%s\\n\", msg );\n\texit( YY_EXIT_FAILURE );\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_meta1_get_lineno": {
      "start_point": [
        2038,
        0
      ],
      "end_point": [
        2042,
        1
      ],
      "content": "int grecs_meta1_get_lineno  (void)\n{\n        \n    return grecs_meta1_lineno;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1_get_in": {
      "start_point": [
        2047,
        0
      ],
      "end_point": [
        2050,
        1
      ],
      "content": "FILE *grecs_meta1_get_in  (void)\n{\n        return grecs_meta1_in;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_meta1_get_in  (void)",
        "*"
      ]
    },
    "grecs_meta1_get_out": {
      "start_point": [
        2055,
        0
      ],
      "end_point": [
        2058,
        1
      ],
      "content": "FILE *grecs_meta1_get_out  (void)\n{\n        return grecs_meta1_out;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "FILE",
        "*grecs_meta1_get_out  (void)",
        "*"
      ]
    },
    "grecs_meta1_get_leng": {
      "start_point": [
        2063,
        0
      ],
      "end_point": [
        2066,
        1
      ],
      "content": "int grecs_meta1_get_leng  (void)\n{\n        return grecs_meta1_leng;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1_get_text": {
      "start_point": [
        2072,
        0
      ],
      "end_point": [
        2075,
        1
      ],
      "content": "char *grecs_meta1_get_text  (void)\n{\n        return grecs_meta1_text;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "char",
        "*grecs_meta1_get_text  (void)",
        "*"
      ]
    },
    "grecs_meta1_set_lineno": {
      "start_point": [
        2084,
        0
      ],
      "end_point": [
        2088,
        1
      ],
      "content": "void grecs_meta1_set_lineno (int  line_number )\n{\n    \n    grecs_meta1_lineno = line_number;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_set_in": {
      "start_point": [
        2096,
        0
      ],
      "end_point": [
        2099,
        1
      ],
      "content": "void grecs_meta1_set_in (FILE *  in_str )\n{\n        grecs_meta1_in = in_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_set_out": {
      "start_point": [
        2101,
        0
      ],
      "end_point": [
        2104,
        1
      ],
      "content": "void grecs_meta1_set_out (FILE *  out_str )\n{\n        grecs_meta1_out = out_str ;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_get_debug": {
      "start_point": [
        2106,
        0
      ],
      "end_point": [
        2109,
        1
      ],
      "content": "int grecs_meta1_get_debug  (void)\n{\n        return grecs_meta1__flex_debug;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1_set_debug": {
      "start_point": [
        2111,
        0
      ],
      "end_point": [
        2114,
        1
      ],
      "content": "void grecs_meta1_set_debug (int  bdebug )\n{\n        grecs_meta1__flex_debug = bdebug ;\n}",
      "lines": 4,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1__init_globals": {
      "start_point": [
        2124,
        0
      ],
      "end_point": [
        2150,
        1
      ],
      "content": "static int grecs_meta1__init_globals (void)\n{\n        /* Initialization is the same as for the non-reentrant scanner.\n     * This function is called from grecs_meta1_lex_destroy(), so don't allocate here.\n     */\n\n    (grecs_meta1__buffer_stack) = 0;\n    (grecs_meta1__buffer_stack_top) = 0;\n    (grecs_meta1__buffer_stack_max) = 0;\n    (grecs_meta1__c_buf_p) = (char *) 0;\n    (grecs_meta1__init) = 0;\n    (grecs_meta1__start) = 0;\n\n/* Defined in main.c */\n#ifdef YY_STDINIT\n    grecs_meta1_in = stdin;\n    grecs_meta1_out = stdout;\n#else\n    grecs_meta1_in = (FILE *) 0;\n    grecs_meta1_out = (FILE *) 0;\n#endif\n\n    /* For future reference: Set errno on error, since we are called by\n     * grecs_meta1_lex_init()\n     */\n    return 0;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_meta1_lex_destroy": {
      "start_point": [
        2155,
        0
      ],
      "end_point": [
        2176,
        1
      ],
      "content": "int grecs_meta1_lex_destroy  (void)\n{\n    \n    /* Pop the buffer stack, destroying each element. */\n\twhile(YY_CURRENT_BUFFER){\n\t\tgrecs_meta1__delete_buffer(YY_CURRENT_BUFFER  );\n\t\tYY_CURRENT_BUFFER_LVALUE = NULL;\n\t\tgrecs_meta1_pop_buffer_state();\n\t}\n\n\t/* Destroy the stack itself. */\n\tgrecs_meta1_free((grecs_meta1__buffer_stack) );\n\t(grecs_meta1__buffer_stack) = NULL;\n\n    /* Reset the globals. This is important in a non-reentrant scanner so the next time\n     * grecs_meta1_lex() is called, initialization will occur. */\n    grecs_meta1__init_globals( );\n\n/* %if-reentrant */\n/* %endif */\n    return 0;\n}",
      "lines": 22,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_meta1__flex_strncpy": {
      "start_point": [
        2184,
        0
      ],
      "end_point": [
        2189,
        1
      ],
      "content": "static void grecs_meta1__flex_strncpy (char* s1, grecs_meta1_const char * s2, int n )\n{\n\tregister int i;\n\tfor ( i = 0; i < n; ++i )\n\t\ts1[i] = s2[i];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_meta1__flex_strlen": {
      "start_point": [
        2193,
        0
      ],
      "end_point": [
        2200,
        1
      ],
      "content": "static int grecs_meta1__flex_strlen (grecs_meta1_const char * s )\n{\n\tregister int n;\n\tfor ( n = 0; s[n]; ++n )\n\t\t;\n\n\treturn n;\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_meta1_alloc": {
      "start_point": [
        2203,
        0
      ],
      "end_point": [
        2206,
        1
      ],
      "content": "void *grecs_meta1_alloc (grecs_meta1__size_t  size )\n{\n\treturn (void *) malloc( size );\n}",
      "lines": 4,
      "depth": 7,
      "decorators": [
        "void",
        "*grecs_meta1_alloc (grecs_meta1__size_t  size )",
        "*"
      ]
    },
    "grecs_meta1_realloc": {
      "start_point": [
        2208,
        0
      ],
      "end_point": [
        2218,
        1
      ],
      "content": "void *grecs_meta1_realloc  (void * ptr, grecs_meta1__size_t  size )\n{\n\t/* The cast to (char *) in the following accommodates both\n\t * implementations that use char* generic pointers, and those\n\t * that use void* generic pointers.  It works with the latter\n\t * because both ANSI C and C++ allow castless assignment from\n\t * any pointer type to void*, and deal with argument conversions\n\t * as though doing an assignment.\n\t */\n\treturn (void *) realloc( (char *) ptr, size );\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void",
        "*grecs_meta1_realloc  (void * ptr, grecs_meta1__size_t  size )",
        "*"
      ]
    },
    "grecs_meta1_free": {
      "start_point": [
        2220,
        0
      ],
      "end_point": [
        2223,
        1
      ],
      "content": "void grecs_meta1_free (void * ptr )\n{\n\tfree( (char *) ptr );\t/* see grecs_meta1_realloc() for (char *) cast */\n}",
      "lines": 4,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_meta1_wrap": {
      "start_point": [
        2236,
        0
      ],
      "end_point": [
        2240,
        1
      ],
      "content": "int\ngrecs_meta1_wrap()\n{\n        return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    },
    "meta1_line_add_unescape_hex": {
      "start_point": [
        2242,
        0
      ],
      "end_point": [
        2249,
        1
      ],
      "content": "static void\nmeta1_line_add_unescape_hex(const char *text, size_t len)\n{\n        for (; text[len-1] != 'x' && len > 0; len--)\n\t\t;\n\tgrecs_line_acc_grow(text, len - 2);\n\tgrecs_line_acc_grow_char((char) strtoul (text + len, NULL, 16));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/meta1-lex.l": {
    "noinput": {
      "start_point": [
        1,
        1
      ],
      "end_point": [
        29,
        1
      ],
      "content": "option noinput\n%option nounput\n%top {\n/* MeTA1 configuration lexer for Grecs.\n   Copyright (C) 2007-2016 Sergey Poznyakoff\n\n   Grecs is free software; you can redistribute it and/or modify it\n   under the terms of the GNU General Public License as published by the\n   Free Software Foundation; either version 3 of the License, or (at your\n   option) any later version.\n\n   Grecs is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU General Public License for more details.\n\n   You should have received a copy of the GNU General Public License along\n   with Grecs. If not, see <http://www.gnu.org/licenses/>. */\n\n/* This file implements a lexical analyzer for MeTA1 main configuration file.\n */\n\n#ifdef HAVE_CONFIG_H\n# include <config.h>\n#endif\n#include \"grecs.h\"\n#include \"meta1-gram.h\"\n#include <ctype.h>\n}",
      "lines": 29,
      "depth": 5,
      "decorators": null
    },
    "yywrap": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\nyywrap()\n{\n        return 1;\n}",
      "lines": 5,
      "depth": 4,
      "decorators": [
        "int"
      ]
    },
    "meta1_line_add_unescape_hex": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nmeta1_line_add_unescape_hex(const char *text, size_t len)\n{\n        for (; text[len-1] != 'x' && len > 0; len--)\n\t\t;\n\tgrecs_line_acc_grow(text, len - 2);\n\tgrecs_line_acc_grow_char((char) strtoul (text + len, NULL, 16));\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/opthelp.c": {
    "indent": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static void\nindent(size_t start, size_t col)\n{\n\tfor (; start < col; start++)\n\t\tputchar(' ');\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_option_descr": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "static void\nprint_option_descr(const char *descr, size_t lmargin, size_t rmargin)\n{\n\twhile (*descr) {\n\t\tint i, s = 0;\n\t\tsize_t width = rmargin - lmargin;\n\n\t\tfor (i = 0; ; i++) {\n\t\t\tif (descr[i] == 0 || descr[i] == ' ' ||\n\t\t\t    descr[i] == '\\t') {\n\t\t\t\tif (i > width)\n\t\t\t\t\tbreak;\n\t\t\t\ts = i;\n\t\t\t\tif (descr[i] == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%*.*s\\n\", s, s, descr);\n\t\tdescr += s;\n\t\tif (*descr) {\n\t\t\tindent(0, lmargin);\n\t\t\tdescr++;\n\t\t}\n\t}\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "optcmp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static int\noptcmp(const void *a, const void *b)\n{\n\tstruct grecs_opthelp const *ap = (struct grecs_opthelp const *)a;\n\tstruct grecs_opthelp const *bp = (struct grecs_opthelp const *)b;\n\tconst char *opta, *optb;\n\tsize_t alen, blen;\n\t\n\tfor (opta = ap->opt; *opta == '-'; opta++)\n\t\t;\n\talen = strcspn (opta, \",\");\n  \n\tfor (optb = bp->opt; *optb == '-'; optb++)\n\t\t;\n\tblen = strcspn (optb, \",\");\n\t\n\tif (alen > blen)\n\t\tblen = alen;\n\t\n\treturn strncmp (opta, optb, blen);\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_options": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\nsort_options(struct grecs_opthelp *opthelp, int start, int count)\n{\n\tqsort(opthelp + start, count, sizeof(opthelp[0]), optcmp);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sort_group": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static int\nsort_group(struct grecs_opthelp *opthelp, size_t optcount, int start)\n{\n\tint i;\n  \n\tfor (i = start; i < optcount && opthelp[i].opt; i++)\n\t\t;\n\tsort_options(opthelp, start, i - start);\n\treturn i + 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sort_opthelp": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\nsort_opthelp(struct grecs_opthelp *opthelp, size_t optcount)\n{\n\tint start;\n\n\tfor (start = 0; start < optcount; ) {\n\t\tif (!opthelp[start].opt)\n\t\t\tstart = sort_group(opthelp, optcount, start + 1);\n\t\telse \n\t\t\tstart = sort_group(opthelp, optcount, start);\n\t}\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_print_help": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "void\ngrecs_print_help(struct grecs_proginfo *pinfo)\n{\n\tunsigned i;\n\tint argsused = 0;\n\tstruct grecs_opthelp *opthelp;\n\tsize_t optcount;\n\n\tprintf(\"%s %s \",\n\t       _(\"Usage:\"), pinfo->progname);\n\tif (pinfo->subcmd)\n\t\tprintf(\"%s \", pinfo->subcmd[0]);\n\tprintf(\"[%s]... %s\\n\",\n\t       _(\"OPTION\"),\n\t       !ISEMPTY(pinfo->args_doc) ? gettext(pinfo->args_doc) : \"\");\n\tif (pinfo->subcmd && pinfo->subcmd[1]) {\n\t\tchar **p;\n\n\t\tprintf(\"%s: \", pinfo->subcmd[2] ? _(\"Aliases\") : _(\"Alias\"));\n\t\tfor (p = pinfo->subcmd + 1; *p; p++)\n\t\t\tprintf(\"%s%c\", *p, p[1] ? ' ' : '\\n');\n\t}\n\tif (!ISEMPTY(pinfo->docstring))\n\t\tprint_option_descr(gettext(pinfo->docstring), 0, RMARGIN);\n\tputchar('\\n');\n\n\topthelp = pinfo->opthelp;\n\toptcount = pinfo->optcount;\n\tsort_opthelp(opthelp, optcount);\n\tfor (i = 0; i < optcount; i++) {\n\t\tunsigned n;\n\t\tif (opthelp[i].opt) {\n\t\t\tn = printf(\"  %s\", opthelp[i].opt);\n\t\t\tif (opthelp[i].arg) {\n\t\t\t\tchar *cb, *ce;\n\t\t\t\targsused = 1;\n\t\t\t\tif (strlen(opthelp[i].opt) == 2) {\n\t\t\t\t\tif (!opthelp[i].is_optional) {\n\t\t\t\t\t\tputchar(' ');\n\t\t\t\t\t\tn++;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tputchar ('=');\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\tif (opthelp[i].is_optional) {\n\t\t\t\t\tcb = \"[\";\n\t\t\t\t\tce = \"]\";\n\t\t\t\t} else\n\t\t\t\t\tcb = ce = \"\";\n\t\t\t\tn += printf(\"%s%s%s\", cb,\n\t\t\t\t\t    gettext(opthelp[i].arg), ce);\n\t\t\t}\n\t\t\tif (n >= DESCRCOLUMN) {\n\t\t\t\tputchar('\\n');\n\t\t\t\tn = 0;\n\t\t\t}\n\t\t\tindent(n, DESCRCOLUMN);\n\t\t\tprint_option_descr(gettext(opthelp[i].descr),\n\t\t\t\t\t   DESCRCOLUMN, RMARGIN);\n\t\t} else {\n\t\t\tif (i)\n\t\t\t\tputchar('\\n');\n\t\t\tindent(0, GROUPCOLUMN);\n\t\t\tprint_option_descr(gettext(opthelp[i].descr),\n\t\t\t\t\t   GROUPCOLUMN, RMARGIN);\n\t\t\tputchar('\\n');\n\t\t}\n\t}\n\n\tputchar('\\n');\n\tif (argsused) {\n\t\tprint_option_descr(_(\"Mandatory or optional arguments to \"\n\t\t\t\t     \"long options are also mandatory or \"\n\t\t\t\t     \"optional for any corresponding short \"\n\t\t\t\t     \"options.\"), 0, RMARGIN);\n\t\tputchar('\\n');\n\t}\n \n\tif (pinfo->print_help_hook)\n\t\tpinfo->print_help_hook(stdout);\n\n\tif (!ISEMPTY(pinfo->bug_address))\n\t\t/* TRANSLATORS: The placeholder indicates the bug-reporting\n\t\t   address for this package.  Please add _another line_ saying\n\t\t   \"Report translation bugs to <...>\\n\" with the address for\n\t\t   translation bugs (typically your translation team's web or\n\t\t   email address).  */\n\t\tprintf(_(\"Report bugs to %s.\\n\"), pinfo->bug_address);\n\n\tif (!ISEMPTY(pinfo->url))\n\t\tprintf(_(\"%s home page: <%s>\\n\"), pinfo->package, pinfo->url);\n\tif (!ISEMPTY(pinfo->epilogue))\n\t\tprintf(\"%s\", gettext(pinfo->epilogue));\n}",
      "lines": 95,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "cmpidx_short": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        216,
        1
      ],
      "content": "static int\ncmpidx_short(const void *a, const void *b)\n{\n\tstruct grecs_opthelp const **opta = (struct grecs_opthelp const **)a;\n\tstruct grecs_opthelp const **optb = (struct grecs_opthelp const **)b;\n\n\treturn (*opta)->opt[1] - (*optb)->opt[1];\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cmpidx_long": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static int\ncmpidx_long(const void *a, const void *b)\n{\n\tstruct grecs_opthelp const **ap = (struct grecs_opthelp const **)a;\n\tstruct grecs_opthelp const **bp = (struct grecs_opthelp const **)b;\n\tchar const *opta, *optb;\n\tsize_t lena, lenb;\n\n\tif ((*ap)->opt[1] == '-')\n\t\topta = (*ap)->opt;\n\telse\n\t\topta = (*ap)->opt + 4;\n\tlena = strcspn(opta, \",\");\n  \n\tif ((*bp)->opt[1] == '-')\n\t\toptb = (*bp)->opt;\n\telse\n\t\toptb = (*bp)->opt + 4;\n\tlenb = strcspn(optb, \",\");\n\treturn strncmp(opta, optb, lena > lenb ? lenb : lena);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_print_usage": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\ngrecs_print_usage(struct grecs_proginfo *pinfo)\n{\n\tunsigned i;\n\tunsigned n;\n\tchar *buf;\n\tsize_t bufsize;\n\tunsigned nidx;\n\tstruct grecs_opthelp **optidx;\n\tstruct grecs_opthelp *opthelp = pinfo->opthelp;\n\tsize_t optcount = pinfo->optcount;\n  \n#define FLUSH do {\t\t\t\t\\\n\t\tbuf[n] = 0;\t\t\t\\\n\t\tprintf(\"%s\\n\", buf);\t\t\\\n\t\tn = USAGECOLUMN;\t\t\\\n\t\tmemset(buf, ' ', n);\t\t\\\n\t}  while (0)\n#define ADDC(c) \\\n  do { if (n == RMARGIN) FLUSH; buf[n++] = c; } while (0)\n\n\toptidx = grecs_calloc(optcount, sizeof(optidx[0]));\n\n\tbufsize = RMARGIN + 1;\n\tbuf = grecs_malloc(bufsize);\n\t\n\tn = snprintf(buf, bufsize, \"%s %s \", _(\"Usage:\"), pinfo->progname);\n\tif (pinfo->subcmd)\n\t\tn += snprintf(buf + n, bufsize - n, \"%s \", pinfo->subcmd[0]);\n\t\n\t/* Print a list of short options without arguments. */\n\tfor (i = nidx = 0; i < optcount; i++)\n\t\tif (opthelp[i].opt &&\n\t\t    opthelp[i].descr &&\n\t\t    opthelp[i].opt[1] != '-' &&\n\t\t    opthelp[i].arg == NULL)\n\t\t\toptidx[nidx++] = opthelp + i;\n\n\tif (nidx) {\n\t\tqsort(optidx, nidx, sizeof(optidx[0]), cmpidx_short);\n\n\t\tADDC('[');\n\t\tADDC('-');\n\t\tfor (i = 0; i < nidx; i++) {\n\t\t\tADDC(optidx[i]->opt[1]);\n\t\t}\n\t\tADDC(']');\n\t}\n\n\t/* Print a list of short options with arguments. */\n\tfor (i = nidx = 0; i < optcount; i++) {\n\t\tif (opthelp[i].opt &&\n\t\t    opthelp[i].descr &&\n\t\t    opthelp[i].opt[1] != '-' &&\n\t\t    opthelp[i].arg)\n\t\t\toptidx[nidx++] = opthelp + i;\n\t}\n\n\tif (nidx) {\n\t\tqsort(optidx, nidx, sizeof(optidx[0]), cmpidx_short);\n    \n\t\tfor (i = 0; i < nidx; i++) {\n\t\t\tstruct grecs_opthelp *opt = optidx[i];\n\t\t\tsize_t len = 5 + strlen(opt->arg)\n\t\t\t\t       + (opt->is_optional ? 2 : 1);\n      \n\t\t\tif (n + len > RMARGIN)\n\t\t\t\tFLUSH;\n\t\t\tbuf[n++] = ' ';\n\t\t\tbuf[n++] = '[';\n\t\t\tbuf[n++] = '-';\n\t\t\tbuf[n++] = opt->opt[1];\n\t\t\tif (opt->is_optional) {\n\t\t\t\tbuf[n++] = '[';\n\t\t\t\tstrcpy(&buf[n], opt->arg);\n\t\t\t\tn += strlen(opt->arg);\n\t\t\t\tbuf[n++] = ']';\n\t\t\t} else {\n\t\t\t\tbuf[n++] = ' ';\n\t\t\t\tstrcpy(&buf[n], opt->arg);\n\t\t\t\tn += strlen(opt->arg);\n\t\t\t}\n\t\t\tbuf[n++] = ']';\n\t\t}\n\t}\n  \n#ifdef HAVE_GETOPT_LONG\n\t/* Print a list of long options */\n\tfor (i = nidx = 0; i < optcount; i++) {\n\t\tif (opthelp[i].opt && opthelp[i].descr\n\t\t    && (opthelp[i].opt[1] == '-' || opthelp[i].opt[2] == ','))\n\t\t\toptidx[nidx++] = opthelp + i;\n\t}\n\n\tif (nidx) {\n\t\tqsort (optidx, nidx, sizeof(optidx[0]), cmpidx_long);\n\t\n\t\tfor (i = 0; i < nidx; i++) {\n\t\t\tstruct grecs_opthelp *opt = optidx[i];\n\t\t\tsize_t len;\n\t\t\tconst char *longopt;\n\t  \n\t\t\tif (opt->opt[1] == '-')\n\t\t\t\tlongopt = opt->opt;\n\t\t\telse if (opt->opt[2] == ',')\n\t\t\t\tlongopt = opt->opt + 4;\n\t\t\telse\n\t\t\t\tcontinue;\n\n\t\t\tlen = 3 + strlen(longopt)\n\t\t\t\t+ (opt->arg ? 1 + strlen(opt->arg)\n\t\t\t\t+ (opt->is_optional ? 2 : 0) : 0);\n\t\t\tif (n + len > RMARGIN) {\n\t\t\t\tFLUSH;\n\t\t\t\t/* Make sure we have enough buffer space if\n                                   the string cannot be split */\n\t\t\t\tif (n + len > bufsize) {\n\t\t\t\t\tbufsize = n + len;\n\t\t\t\t\tbuf = grecs_realloc(buf, bufsize);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf[n++] = ' ';\n\t\t\tbuf[n++] = '[';\n\t\t\tstrcpy(&buf[n], longopt);\n\t\t\tn += strlen(longopt);\n\t\t\tif (opt->arg) {\n\t\t\t\tbuf[n++] = '=';\n\t\t\t\tif (opt->is_optional) {\n\t\t\t\t\tbuf[n++] = '[';\n\t\t\t\t\tstrcpy(&buf[n], opt->arg);\n\t\t\t\t\tn += strlen(opt->arg);\n\t\t\t\t\tbuf[n++] = ']';\n\t\t\t\t} else {\n\t\t\t\t\tstrcpy(&buf[n], opt->arg);\n\t\t\t\t\tn += strlen(opt->arg);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf[n++] = ']';\n\t\t}\n\t}\n#endif\n\t/* Print argument list */\n\tif (pinfo->args_doc) {\n\t\tsize_t len = strlen(pinfo->args_doc) + 1;\n\t\tif (n + len <= RMARGIN) {\n\t\t\tbuf[n++] = ' ';\n\t\t\tstrcpy(buf + n, pinfo->args_doc);\n\t\t\tn += len;\n\t\t} else {\n\t\t\tstruct wordsplit ws;\n\n\t\t\tif (wordsplit(pinfo->args_doc, &ws, \n\t\t\t\t      WRDSF_SHOWERR |\n\t\t\t\t      WRDSF_NOVAR |\n\t\t\t\t      WRDSF_NOCMD |\n\t\t\t\t      WRDSF_QUOTE |\n\t\t\t\t      WRDSF_SQUEEZE_DELIMS))\n\t\t\t\tabort();\n\n\t\t\tfor (i = 0; i < ws.ws_wordc; i++) {\n\t\t\t\tlen = strlen(ws.ws_wordv[i]) + 1;\n\t\t\t\tif (n + len > RMARGIN) {\n\t\t\t\t\tFLUSH;\n\t\t\t\t\t/* Make sure we have enough buffer\n\t\t\t\t\t   space if the string cannot be\n\t\t\t\t\t   split */\n\t\t\t\t\tif (n + len > bufsize) {\n\t\t\t\t\t\tbufsize = n + len;\n\t\t\t\t\t\tbuf = grecs_realloc(buf,\n\t\t\t\t\t\t\t\t    bufsize);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbuf[n++] = ' ';\n\t\t\t\tstrcpy(buf + n, ws.ws_wordv[i]);\n\t\t\t\tn += len;\n\t\t\t}\n\t\t}\t\n\t}\n\t\n\tFLUSH;\n\n\tif (pinfo->subcmd && pinfo->subcmd[1]) {\n\t\tchar **p;\n\t\t\n\t\tprintf(\"%s: %s\", pinfo->subcmd[2] ? _(\"Aliases\") : _(\"Alias\"),\n\t\t\tpinfo->progname);\n\t\tfor (p = pinfo->subcmd + 1; *p; p++)\n\t\t\tprintf(\" %s\", *p);\n\t\tputchar('\\n');\n\t}\n\t\n\tfree(optidx);\n\tfree(buf);\n}",
      "lines": 194,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_version_only": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        462,
        1
      ],
      "content": "void\ngrecs_print_version_only(struct grecs_proginfo *pinfo, FILE *stream)\n{\n\tfprintf(stream, \"%s\", pinfo->progname);\n\tif (!ISEMPTY(pinfo->package))\n\t\tfprintf(stream, \" (%s)\", pinfo->package);\n\tif (!ISEMPTY(pinfo->version))\n\t\tfprintf(stream, \" %s\", pinfo->version);\n\tfputc('\\n', stream);\n\t\n\t/* TRANSLATORS: Translate \"(C)\" to the copyright symbol\n\t   (C-in-a-circle), if this symbol is available in the user's\n\t   locale.  Otherwise, do not translate \"(C)\"; leave it as-is.  */\n\tfprintf(stream, version_etc_copyright, _(\"(C)\"),\n\t\t ISEMPTY(pinfo->copyright_year) ?\n\t\t         \"2012\" : pinfo->copyright_year,\n\t\t ISEMPTY(pinfo->copyright_holder) ?\n\t\t\"Free Software Foundation, inc.\" : pinfo->copyright_holder);\n\tfputc('\\n', stream);\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_print_version": {
      "start_point": [
        470,
        0
      ],
      "end_point": [
        523,
        1
      ],
      "content": "void\ngrecs_print_version(struct grecs_proginfo *pinfo, FILE *stream)\n{\n\tgrecs_print_version_only(pinfo, stream);\n\tfputs(gettext(ISEMPTY(pinfo->license) ?\n\t\t        gplv3 : pinfo->license), stream);\n\tif (pinfo->print_version_hook)\n\t\tpinfo->print_version_hook(stream);\n\n\tif (pinfo->authors) {\n\t\tint i;\n\t\tunsigned width;\n\t\tconst char *written_by = _(\"Written by \");\n\t\t/* TRANSLATORS: This string is used as a delimiter between\n\t\t   authors' names as in:\n\n\t\t     Written by Winnie the Pooh, Piglet ...\n\t\t*/\n\t\tconst char *middle_delim = _(\", \");\n\t\t/* TRANSLATORS: This string acts as a delimiter before the\n\t\t   last author's names, e.g.:\n  \n\t\t   Written by Winnie the Pooh, Piglet and Christopher Robin.\n\t\t*/\n\t\tconst char *final_delim = _(\" and \");\n\n\t\twidth = strlen(written_by);\n\t\tfputs(written_by, stream);\n\t\tfor (i = 0; ; ) {\n\t\t\tconst char *author = pinfo->authors[i++];\n\t\t\tsize_t len = strlen(author);\n\t\t\tconst char *delim = NULL;\n\t\t\t\n\t\t\tif (pinfo->authors[i]) {\n\t\t\t\tdelim = pinfo->authors[i+1] ?\n\t\t\t\t\tmiddle_delim : final_delim;\n\t\t\t\tlen += strlen (delim);\n\t\t\t} else\n\t\t\t\tlen++;\n\t\t\tif (width + len > RMARGIN) {\n\t\t\t\tfputc('\\n', stream);\n\t\t\t\twidth = 0;\n\t\t\t}\n\t\t\tfputs(author, stream);\n\t\t\twidth += len;\n\t\t\tif (delim)\n\t\t\t\tfputs(delim, stream);\n\t\t\telse\n\t\t\t\tbreak;\n\t\t}\n\t\tfputc('.', stream);\n\t\tfputc('\\n', stream);\n\t}\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/parser.c": {
    "grecs_gram_trace": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\ngrecs_gram_trace(int n)\n{\n\tif (n)\n\t\tgrecs_trace_flags |= GRECS_TRACE_GRAM;\n\telse\n\t\tgrecs_trace_flags &= ~GRECS_TRACE_GRAM;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_lex_trace": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ngrecs_lex_trace(int n)\n{\n\tif (n)\n\t\tgrecs_trace_flags |= GRECS_TRACE_LEX;\n\telse\n\t\tgrecs_trace_flags &= ~GRECS_TRACE_LEX;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_parse": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "struct grecs_node *\ngrecs_parse(const char *name)\n{\n\tif (!grecs_trace_flags) {\n\t\tchar *p = getenv(\"GRECS_DEBUG\");\n\t\tif (p) {\n\t\t\twhile (*p) {\n\t\t\t\tswitch (*p++) {\n\t\t\t\tcase 'g':\n\t\t\t\tcase 'G':\n\t\t\t\t\tgrecs_trace_flags |= GRECS_TRACE_GRAM;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\tcase 'L':\n\t\t\t\t\tgrecs_trace_flags |= GRECS_TRACE_LEX;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tgrecs_error_count = 0;\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\treturn grecs_parser_fun(name, grecs_trace_flags);\n}",
      "lines": 26,
      "depth": 14,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_parse(const char *name)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/parsertab.c": {
    "grecs_enumerate_parsers": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\ngrecs_enumerate_parsers(int (*fun)(const char *, grecs_parser_t, void *),\n\t\t\tvoid *data)\n{\n\tstruct parser_tab *pt;\n\tint rc = 0;\n\t\n\tfor (pt = parser_tab; rc == 0 && pt->name; pt++)\n\t\trc = fun(pt->name, pt->parser, data);\n\treturn rc;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "grecs_get_parser_by_type": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "grecs_parser_t\ngrecs_get_parser_by_type(const char *type)\n{\n\tstruct parser_tab *pt;\n\n\tfor (pt = parser_tab; pt->name; pt++) {\n\t\tif (strcasecmp(pt->name, type) == 0)\n\t\t\treturn pt->parser;\n\t}\n\treturn NULL;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "grecs_parser_t"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/path-parser.c": {
    "next_char": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static int\nnext_char(FILE *infile)\n{\n\tint c = fgetc(infile);\n\tif (c == '\\n')\n\t\tgrecs_locus_point_advance_line(grecs_current_locus_point);\n\telse {\n\t\tgrecs_current_locus_point.col++;\n\t\tif (c == '\\\\') {\n\t\t\tint nc = fgetc(infile);\n\t\t\tif (nc == '\\n') {\n\t\t\t\tgrecs_locus_point_advance_line(grecs_current_locus_point);\n\t\t\t\tc = fgetc(infile);\n\t\t\t\tgrecs_current_locus_point.col++;\n\t\t\t} else\n\t\t\t\tungetc(nc, infile);\n\t\t}\n\t}\n\treturn c;\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_path_parser": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "struct grecs_node *\ngrecs_path_parser(const char *name, int traceflags)\n{\n\tstruct grecs_node *root, *subtree = NULL, *node;\n\tFILE *infile;\n\tstruct grecs_txtacc *acc = NULL;\n\tchar *kw, *val;\n\tgrecs_locus_t kwloc, valloc, rootloc;\n\tint inquote;\n\tint lookahead;\n\tint err = 0;\n\tunsigned prev_col;\n\t\n\tinfile = fopen(name, \"r\");\n\tif (!infile) {\n\t\tgrecs_error(NULL, errno, _(\"cannot open `%s'\"), name);\n\t\treturn NULL;\n\t}\n\tgrecs_current_locus_point.file = grecs_install_text(name);\n\tgrecs_current_locus_point.line = 1;\n\tgrecs_current_locus_point.col = 0;\n\trootloc.beg = grecs_current_locus_point;\n\trootloc.beg.col++;\n\t\n\tacc = grecs_txtacc_create();\n\t\n\twhile ((lookahead = next_char(infile)) > 0) {\n\t\twhile (1) {\n\t\t\twhile (lookahead == ' ' || lookahead == '\\t')\n\t\t\t\tlookahead = next_char(infile);\n\n\t\t\tif (lookahead == '#') {\n\t\t\t\twhile ((lookahead = next_char(infile)) &&\n\t\t\t\t       lookahead != '\\n')\n\t\t\t\t\t;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif (lookahead <= 0)\n\t\t\tbreak;\n\n\t\tkwloc.beg = grecs_current_locus_point;\n\n\t\tinquote = 0;\n\t\tfor (; lookahead > 0 && lookahead != ':';\n\t\t     lookahead = next_char(infile)) {\n\t\t\tif (inquote) {\n\t\t\t\tif (inquote == '\"' && lookahead == '\\\\') {\n\t\t\t\t\tlookahead = next_char(infile);\n\t\t\t\t\tif (lookahead <= 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t} else if (lookahead == inquote)\n\t\t\t\t\tinquote = 0;\n\t\t\t} else if (lookahead == '\\'' || lookahead == '\"')\n\t\t\t\tinquote = lookahead;\n\t\t\tgrecs_txtacc_grow_char(acc, lookahead);\n\t\t}\n\t\t\n\t\tif (lookahead <= 0) {\n\t\t\tgrecs_error(&kwloc, 0, _(\"unexpected end of file\"));\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\tkw = grecs_txtacc_finish(acc, 0);\n\n\t\tkwloc.end = grecs_current_locus_point;\n\t\tkwloc.end.col--;\n\t\t\n\t\twhile ((lookahead = next_char(infile)) > 0 &&\n\t\t       (lookahead == ' ' || lookahead == '\\t'));\n\n\t\tif (lookahead <= 0) {\n\t\t\tgrecs_error(&kwloc, 0, _(\"unexpected end of file\"));\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tvalloc.beg = grecs_current_locus_point;\n\t\tdo {\n\t\t\tgrecs_txtacc_grow_char(acc, lookahead);\n\t\t\tprev_col = grecs_current_locus_point.col;\n\t\t} while ((lookahead = next_char(infile)) > 0 &&\n\t\t\t lookahead != '\\n');\n\t\tvalloc.end = grecs_current_locus_point;\n\t\tvalloc.end.line--;\n\t\tvalloc.end.col = prev_col;\n\t\t\n\t\tgrecs_txtacc_grow_char(acc, 0);\n\t\tval = grecs_txtacc_finish(acc, 0);\n\n\t\tnode = grecs_node_from_path_locus(kw, val, &kwloc, &valloc);\n\t\tif (!node) {\n\t\t\tgrecs_error(&kwloc, 0, _(\"parse error\"));\n\t\t\terr = 1;\n\t\t\tbreak;\n\t\t}\n\t\tnode->locus.end = valloc.end;\n\t\tnode->idloc = kwloc;\n\t\t\n\t\tif (!subtree)\n\t\t\tsubtree = node;\n\t\telse\n\t\t\tgrecs_node_bind(subtree, node, 0);\n\t\tgrecs_txtacc_free_string(acc, kw);\n\t\tgrecs_txtacc_free_string(acc, val);\n\t}\n\n\tfclose(infile);\n\tgrecs_txtacc_free(acc);\n\n\tif (err) {\n\t\tgrecs_tree_free(subtree);\n\t\troot = NULL;\n\t} else {\n\t\trootloc.end = grecs_current_locus_point;\n\t\troot = grecs_node_create(grecs_node_root, &rootloc);\n\t\troot->v.texttab = grecs_text_table();\n\t\tgrecs_node_bind(root, subtree, 1);\n\t\tgrecs_tree_reduce(root, NULL, 0);\n\t}\n\t\n\treturn root;\n}",
      "lines": 127,
      "depth": 16,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_path_parser(const char *name, int traceflags)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/preproc.c": {
    "grecs_getline": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "ssize_t\ngrecs_getline(char **pbuf, size_t *psize, FILE *fp)\n{\n\tchar *buf = *pbuf;\n\tsize_t size = *psize;\n\tssize_t off = 0;\n  \n\tif (!buf) {\n\t\tsize = 1;\n\t\tbuf = grecs_malloc(size);\n\t}\n\t\n\tdo {\n\t\tif (off == size - 1) {\n\t\t\tsize_t nsize = 2 * size;\n\t\t\tif (nsize < size)\n\t\t\t\tgrecs_alloc_die();\n\t\t\tbuf = grecs_realloc(buf, nsize);\n\t\t\tsize = nsize;\n\t\t}\n\t\tif (!fgets(buf + off, size - off, fp)) {\n\t\t\tif (off == 0)\n\t\t\t\toff = -1;\n\t\t\tbreak;\n\t\t}\n\t\toff += strlen(buf + off);\n\t} while (buf[off - 1] != '\\n');\n\n\t*pbuf = buf;\n\t*psize = size;\n\treturn off;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "ssize_t"
      ]
    },
    "putback": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static void\nputback(const char *str)\n{\n\tsize_t len;\n\t\n\tif (!*str)\n\t\treturn;\n\tlen = strlen(str) + 1;\n\tif (len > putback_max) {\n\t\tputback_max = len;\n\t\tputback_buffer = grecs_realloc(putback_buffer, putback_max);\n\t}\n\tstrcpy(putback_buffer, str);\n\tputback_size = len - 1;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "pp_line_stmt": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\npp_line_stmt()\n{\n\tsize_t ls_size;\n\tsize_t pb_size;\n\n\tif (grecs_asprintf(&linebufbase, &linebufsize,\n\t\t\t   \"#line %lu \\\"%s\\\" %lu\\n\",\n\t\t\t   (unsigned long) POINT.line,\n\t\t\t   POINT.file, (unsigned long) context_stack->xlines))\n\t\tgrecs_alloc_die();\n\n\tls_size = strlen(linebufbase);\n\tpb_size = putback_size + ls_size + 1;\n\n\tif (pb_size > putback_max) {\n\t\tputback_max = pb_size;\n\t\tputback_buffer = grecs_realloc(putback_buffer, putback_max);\n\t}\n\n\tcontext_stack->xlines++;\n\tstrcpy(putback_buffer + putback_size, linebufbase);\n\tputback_size += ls_size;\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "next_line": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static int\nnext_line()\n{\n\tssize_t rc;\n\n\tdo {\n\t\tif (putback_size) {\n\t\t\tif (putback_size + 1 > bufsize) {\n\t\t\t\tbufsize = putback_size + 1;\n\t\t\t\tlinebuf = grecs_realloc(linebuf, bufsize);\n\t\t\t}\n\t\t\tstrcpy(linebuf, putback_buffer);\n\t\t\trc = putback_size;\n\t\t\tputback_size = 0;\n\t\t}\n\t\telse if (!context_stack)\n\t\t\treturn 0;\n\t\telse\n\t\t\trc = grecs_getline(&linebuf, &bufsize, INFILE);\n\t} while (rc == -1 && pop_source() == 0);\n\treturn rc;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_preproc_fill_buffer": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "size_t\ngrecs_preproc_fill_buffer(char *buf, size_t size)\n{\n\tsize_t bufsize = size;\n\n\twhile (next_line() > 0) {\n\t\tchar *p;\n\t\tsize_t len;\n\t\tint is_line = 0;\n\t\t\n\t\tfor (p = linebuf; *p && isspace(*p); p++)\n\t\t\t;\n\t\tif (*p == '#') {\n\t\t\tsize_t l;\n\t\t\tfor (p++; *p && isspace(*p); p++)\n\t\t\t\t;\n\t\t\tl = strlen(p);\n\t\t\tif (STRMATCH(p, l, \"include_once\")) {\n\t\t\t\tif (parse_include(linebuf, 1))\n\t\t\t\t\tputback(\"/*include_once*/\\n\");\n\t\t\t\tcontinue;\n\t\t\t} else if (STRMATCH(p, l, \"include\")) {\n\t\t\t\tif (parse_include(linebuf, 0))\n\t\t\t\t\tputback(\"/*include*/\\n\");\n\t\t\t\tcontinue;\n\t\t\t} else if (STRMATCH(p, l, \"line\"))\n\t\t\t\tis_line = 1;\n\t\t}\n\n\t\tlen = strlen(linebuf);\n\n\t\tif (len > size)\n\t\t\tlen = size;\n\t\t\n\t\tmemcpy(buf, linebuf, len);\n\t\tbuf += len;\n\t\tsize -= len;\n\t\t\n\t\tif (size == 0) {\n\t\t\tputback(linebuf + len);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!is_line && len > 0 && linebuf[len - 1] == '\\n')\n\t\t\tPOINT.line++;\n\t}\n\treturn bufsize - size;\n}",
      "lines": 48,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "ctx_lookup": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static struct buffer_ctx *\nctx_lookup(struct stat *st)\n{\n\tstruct buffer_ctx *ctx;\n\n\tif (!context_stack)\n\t\treturn NULL;\n\n\tfor (ctx = context_stack->prev; ctx; ctx = ctx->prev)\n\t\tif (STAT_ID_EQ(*st, ctx->id))\n\t\t\tbreak;\n\treturn ctx;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct buffer_ctx",
        "struct",
        "buffer_ctx",
        "*\nctx_lookup(struct stat *st)",
        "*"
      ]
    },
    "grecs_include_path_count": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "size_t\ngrecs_include_path_count(int flag)\n{\n    size_t count = 0;\n    if (flag & GRECS_STD_INCLUDE)\n\tcount += grecs_list_size(grecs_std_include_path);\n    if (flag & GRECS_USR_INCLUDE)\n\tcount += grecs_list_size(grecs_usr_include_path);\n    return count;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "foreach_dir": {
      "start_point": [
        256,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\nforeach_dir(struct grecs_list *list, int flag,\n\t    int (*fun)(int, const char *, void *), void *data)\n{\n    int rc = 0;\n    struct grecs_list_entry *ep;\n\n    for (ep = list->head; rc == 0 && ep; ep = ep->next)\n\trc = fun(flag, ep->data, data);\n    return rc;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_foreach_include_dir": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int\ngrecs_foreach_include_dir(int flag, int (*fun)(int, const char *, void *),\n\t\t\t  void *data)\n{\n    int rc = 0;\n\n    if (flag & GRECS_STD_INCLUDE)\n\trc = foreach_dir(grecs_std_include_path, GRECS_STD_INCLUDE, fun, data);\n    if (rc == 0 && (flag & GRECS_USR_INCLUDE))\n\trc = foreach_dir(grecs_usr_include_path, GRECS_USR_INCLUDE, fun, data);\n    return rc;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pp_list_find": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "static int\npp_list_find(struct grecs_list *list, struct file_data *dptr)\n{\n\tstruct grecs_list_entry *ep;\n\n\tif (!list)\n\t\treturn 0;\n\tfor (ep = list->head; !dptr->found && ep; ep = ep->next) {\n\t\tconst char *dir = ep->data;\n\t\tsize_t size = strlen (dir) + 1 + dptr->namelen + 1;\n\t\tif (size > dptr->buflen) {\n\t\t\tdptr->buflen = size;\n\t\t\tdptr->buf = grecs_realloc(dptr->buf, dptr->buflen);\n\t\t}\n\t\tstrcpy(dptr->buf, dir);\n\t\tstrcat(dptr->buf, \"/\");\n\t\tstrcat(dptr->buf, dptr->name);\n\t\tdptr->found = access(dptr->buf, F_OK) == 0;\n\t}\n\treturn dptr->found;\n}",
      "lines": 21,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "incl_free": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        316,
        1
      ],
      "content": "static void\nincl_free(void *data)\n{\n\tgrecs_free(data);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_include_path_clear": {
      "start_point": [
        318,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "void\ngrecs_include_path_clear()\n{\n\tif (grecs_usr_include_path)\n\t\tgrecs_list_clear(grecs_usr_include_path);\n\tif (grecs_std_include_path)\n\t\tgrecs_list_clear(grecs_std_include_path);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "grecs_include_path_setup_v": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        343,
        1
      ],
      "content": "void\ngrecs_include_path_setup_v(char **dirs)\n{\n\tif (!grecs_usr_include_path) {\n\t\tgrecs_usr_include_path = grecs_list_create();\n\t\tgrecs_usr_include_path->free_entry = incl_free;\n\t}\n\tgrecs_std_include_path = grecs_list_create();\n\tgrecs_std_include_path->free_entry = incl_free;\n\tif (dirs) {\n\t\tint i;\n\t\tfor (i = 0; dirs[i]; i++)\n\t\t\t/* FIXME: Element never freed */\n\t\t\tgrecs_list_append(grecs_std_include_path,\n\t\t\t\t\t  grecs_strdup(dirs[i]));\n\t}\n}",
      "lines": 17,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "grecs_include_path_setup": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        372,
        1
      ],
      "content": "void\ngrecs_include_path_setup(const char *dir, ...)\n{\n\tconst char *p;\n\tchar **argv = NULL;\n\tsize_t argc = 0;\n\tsize_t argi = 0;\n\tva_list ap;\n\t\n\tva_start(ap, dir);\n\tp = dir;\n\twhile (1) {\n\t\tif (argi == argc) {\n\t\t\tif (argc == 0)\n\t\t\t\targc = 16;\n\t\t\telse\n\t\t\t\targc += 16;\n\t\t\targv = grecs_realloc(argv, argc * sizeof(argv[0]));\n\t\t}\n\t\targv[argi++] = (char*) p;\n\t\tif (!p)\n\t\t\tbreak;\n\t\tp = va_arg(ap, const char*);\n\t}\n\tgrecs_include_path_setup_v(argv);\n\tgrecs_free(argv);\n\tva_end(ap);\n}",
      "lines": 28,
      "depth": 15,
      "decorators": [
        "void"
      ]
    },
    "grecs_preproc_add_include_dir": {
      "start_point": [
        374,
        0
      ],
      "end_point": [
        382,
        1
      ],
      "content": "void\ngrecs_preproc_add_include_dir(char *dir)\n{\n\tif (!grecs_usr_include_path) {\n\t\tgrecs_usr_include_path = grecs_list_create();\n\t\tgrecs_usr_include_path->free_entry = incl_free;\n\t}\n\tgrecs_list_append(grecs_usr_include_path, grecs_strdup(dir));\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "incl_hasher": {
      "start_point": [
        387,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static unsigned\nincl_hasher(void *data, unsigned long n_buckets)\n{\n\tconst struct input_file_ident *id = data;\n\treturn (id->i_node + id->device) % n_buckets;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "incl_compare": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        401,
        1
      ],
      "content": "static int\nincl_compare(void const *data1, void const *data2)\n{\n\tconst struct input_file_ident *id1 = data1;\n\tconst struct input_file_ident *id2 = data2;\n\treturn !(id1->device == id2->device && id1->i_node == id2->i_node);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "incl_copy": {
      "start_point": [
        403,
        0
      ],
      "end_point": [
        408,
        1
      ],
      "content": "static int\nincl_copy(void *dst, void *src)\n{\n\tmemcpy(dst, src, sizeof(struct input_file_ident));\n\treturn 0;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "source_lookup": {
      "start_point": [
        410,
        0
      ],
      "end_point": [
        433,
        1
      ],
      "content": "static int\nsource_lookup(struct stat *st)\n{\n\tstruct input_file_ident key;\n\tint install = 1;\n  \n\tif (!incl_sources) {\n\t\tincl_sources = grecs_symtab_create(\n\t\t\tsizeof(struct input_file_ident), \n\t\t\tincl_hasher,\n\t\t\tincl_compare,\n\t\t\tincl_copy,\n\t\t\tNULL,/*FIXME: alloc*/\n\t\t\tNULL);\n\t\tif (!incl_sources)\n\t\t\tgrecs_alloc_die();\n\t}\n\t\n\tkey.i_node = st->st_ino;\n\tkey.device = st->st_dev;\n\tif (!grecs_symtab_lookup_or_install(incl_sources, &key, &install))\n\t\tgrecs_alloc_die();\n\treturn !install;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "push_source": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "static int\npush_source(const char *name, int once)\n{\n\tFILE *fp;\n\tstruct buffer_ctx *ctx;\n\tstruct stat st;\n\tint rc = stat(name, &st);\n\n\tif (context_stack) {\n\t\tif (rc) {\n\t\t\tgrecs_error(&LOCUS, errno,\n\t\t\t\t    _(\"Cannot stat `%s'\"), name);\n\t\t\treturn 1;\n\t\t}\n\n\t\tif (POINT.file && STAT_ID_EQ(st, context_stack->id)) {\n\t\t\tgrecs_error(&LOCUS, 0, _(\"Recursive inclusion\"));\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tif ((ctx = ctx_lookup(&st))) {\n\t\t\tgrecs_error(&LOCUS, 0, _(\"Recursive inclusion\"));\n\t\t\tif (ctx->prev)\n\t\t\t\tgrecs_error(&ctx->prev->locus, 0,\n\t\t\t\t\t    _(\"`%s' already included here\"),\n\t\t\t\t\t    name);\n\t\t\telse\n\t\t\t\tgrecs_error(&LOCUS, 0,\n\t\t\t\t\t    _(\"`%s' already included at top level\"),\n\t\t\t\t\t    name);\n\t\t\treturn 1;\n\t\t}\n\t} else if (rc) {\n\t\tgrecs_error(NULL, errno, _(\"Cannot stat `%s'\"), name);\n\t\treturn 1;\n\t}\n\n\tif (once && source_lookup(&st))\n\t\treturn -1;\n\n\tfp = fopen(name, \"r\");\n\tif (!fp) {\n\t\tgrecs_error(context_stack ? &LOCUS : NULL, errno,\n\t\t\t    _(\"Cannot open `%s'\"), name);\n\t\treturn 1;\n\t}\n\n\t/* Push current context */\n\tctx = grecs_malloc(sizeof(*ctx));\n\tctx->locus.beg.file = grecs_install_text(name);\n\tctx->locus.beg.line = 1;\n\tctx->locus.beg.col = 0;\n\tctx->locus.end.file = NULL;\n\tctx->locus.end.line = ctx->locus.end.col = 0;\n\tctx->xlines = 0;\n\tctx->namelen = strlen(ctx->locus.beg.file);\n\tctx->id.i_node = st.st_ino;\n\tctx->id.device = st.st_dev;\n\tctx->infile = fp;\n\tctx->prev = context_stack;\n\tcontext_stack = ctx;\n\n\tif (grecs_grecs__flex_debug)\n\t  fprintf (stderr, \"Processing file `%s'\\n\", name);\n\n\tpp_line_stmt();\n\n\treturn 0;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pop_source": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        544,
        1
      ],
      "content": "static int\npop_source()\n{\n\tstruct buffer_ctx *ctx;\n\t\n\tif (!context_stack)\n\t\treturn 1;\n\t\n\tfclose(INFILE);\n\n\t/* Restore previous context */\n\tctx = context_stack->prev;\n\tgrecs_free(context_stack);\n\tcontext_stack = ctx;\n\n\tif (include_pos < include_glob.gl_pathc) {\n\t\tpush_source(include_glob.gl_pathv[include_pos++], include_once);\n\t\treturn 0;\n\t} else if (include_glob.gl_pathc) {\n\t\tglobfree(&include_glob);\n\t\tinclude_pos = include_glob.gl_pathc = 0;\n\t}\n\t\n\tif (!context_stack) {\n\t\tif (grecs_grecs__flex_debug)\n\t\t\tfprintf(stderr, \"End of input\\n\");\n\t\treturn 1;\n\t}\n\n\tPOINT.line++;\n\n\tif (grecs_grecs__flex_debug)\n\t\tfprintf(stderr, \"Resuming file `%s' at line %lu\\n\",\n\t\t\tPOINT.file, (unsigned long) POINT.line);\n\n\tpp_line_stmt();\n\n\treturn 0;\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_find_include_file": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        573,
        1
      ],
      "content": "char *\ngrecs_find_include_file(const char *name, int allow_cwd)\n{\n\tstatic char *cwd = \".\";\n\tstruct file_data fd;\n\n\tfd.name = name;\n\tfd.namelen = strlen(name);\n\tfd.buf = NULL;\n\tfd.buflen = 0;\n\tfd.found = 0;\n\n\tif (!grecs_usr_include_path)\n\t\tgrecs_include_path_setup(NULL);\n\tif (allow_cwd) {\n\t\tgrecs_list_append(grecs_usr_include_path, cwd);\n\t\tpp_list_find(grecs_usr_include_path, &fd);\n\t\tgrecs_list_remove_tail(grecs_usr_include_path);\n\t} else\n\t\tpp_list_find(grecs_usr_include_path, &fd);\n\n\tif (!fd.found) {\n\t\tpp_list_find(grecs_std_include_path, &fd);\n\t\tif (!fd.found)\n\t\t\treturn NULL;\n\t}\n\treturn fd.buf;\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "char",
        "*\ngrecs_find_include_file(const char *name, int allow_cwd)",
        "*"
      ]
    },
    "isglob": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        583,
        1
      ],
      "content": "static int\nisglob(const char *s)\n{\n\tfor (; *s; s++) {\n\t\tif (strchr(\"*?[\", *s))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_include": {
      "start_point": [
        585,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "static int\nparse_include(const char *text, int once)\n{\n\tstruct wordsplit ws;\n\tchar *tmp = NULL;\n\tchar *p = NULL;\n\tint rc = 1;\n\t\n\tif (wordsplit(text, &ws, WRDSF_DEFFLAGS))\n\t\tgrecs_error(&LOCUS, 0, _(\"Cannot parse include line\"));\n\telse if (ws.ws_wordc != 2) {\n\t\twordsplit_free(&ws);\n\t\tgrecs_error(&LOCUS, 0, _(\"invalid include statement\"));\n\t} else {\n\t\tsize_t len;\n\t\tint allow_cwd;\n\t\t\n\t\tp = ws.ws_wordv[1];\n\t\tlen = strlen (p);\n\t\t\n\t\tif (p[0] == '<' && p[len - 1] == '>') {\n\t\t\tallow_cwd = 0;\n\t\t\tp[len - 1] = 0;\n\t\t\tp++;\n\t\t} else\n\t\t\tallow_cwd = 1;\n\t\t\n\t\tif (isglob(p)) {\n\t\t\tswitch (glob(p, 0, NULL, &include_glob)) {\n\t\t\tcase 0:\n\t\t\t\tinclude_pos = 0;\n\t\t\t\tinclude_once = once;\n\t\t\t\tbreak;\n\t\t\tcase GLOB_NOSPACE:\n\t\t\t\tgrecs_alloc_die();\n\t\t\tcase GLOB_NOMATCH:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgrecs_error(&LOCUS, 0,  _(\"read error\"));\n\t\t\t}\n\t\t\tp = NULL;\n\t\t} else if (p[0] != '/') {\n\t\t\tchar *q = p;\n\t\t\tp = grecs_find_include_file(q, allow_cwd);\n\t\t\tif (!p)\n\t\t\t\tgrecs_error(&LOCUS, 0,\n\t\t\t\t\t    _(\"%s: No such file or directory\"),\n\t\t\t\t\t    q);\n\t\t}\n \t}\n  \n\tif (p)\n\t\trc = push_source(p, once);\n\telse if (include_pos < include_glob.gl_pathc)\n\t\trc = push_source(include_glob.gl_pathv[include_pos++], once);\n\t\n\tgrecs_free(tmp);\n\twordsplit_free(&ws);\n\treturn rc;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_preproc_init": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        650,
        1
      ],
      "content": "int\ngrecs_preproc_init(const char *name)\n{\n\treturn push_source(name, 0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "grecs_preproc_done": {
      "start_point": [
        652,
        0
      ],
      "end_point": [
        669,
        1
      ],
      "content": "void\ngrecs_preproc_done()\n{\n\tgrecs_symtab_free(incl_sources);\n\tincl_sources = NULL;\n\n\tgrecs_free(linebuf);\n\tlinebuf = NULL;\n\tbufsize = 0;\n\t\n\tgrecs_free(putback_buffer);\n\tputback_buffer = NULL;\n\tputback_size = putback_max = 0;\n\t\n\tfree(linebufbase); /* Allocated via standard malloc/realloc */\n\tlinebufbase = NULL;\n\tlinebufsize = 0;\n}",
      "lines": 18,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_preproc_run": {
      "start_point": [
        671,
        0
      ],
      "end_point": [
        713,
        1
      ],
      "content": "int\ngrecs_preproc_run(const char *config_file, const char *extpp)\n{\n\tsize_t i;\n\tchar buffer[512];\n\t\n\tif (grecs_preproc_init(config_file))\n\t\treturn 1;\n\tif (extpp) {\n\t\tFILE *outfile;\n\t\tchar *setup_file;\n\t\tchar *cmd = NULL;\n\n\t\tsetup_file = grecs_find_include_file(\"pp-setup\", 1);\n\t\tif (setup_file) {\n\t\t\tsize_t size = 0;\n\t\t\tif (grecs_asprintf(&cmd, &size,\n\t\t\t\t\t   \"%s %s -\", extpp, setup_file))\n\t\t\t\tgrecs_alloc_die();\n\t\t\tgrecs_free(setup_file);\n\t\t} else\n\t\t\tcmd = grecs_strdup(extpp);\n\t\t/*FIXME_DEBUG_F1 (2, \"Running preprocessor: `%s'\", cmd);*/\n\t\toutfile = popen(cmd, \"w\");\n\t\tif (!outfile) {\n\t\t\tgrecs_error(NULL, errno,\n\t\t\t\t    _(\"Unable to start external preprocessor `%s'\"),\n\t\t\t\t    cmd);\n\t\t\tgrecs_free(cmd);\n\t\t\treturn 1;\n\t\t}\n\n\t\twhile ((i = grecs_preproc_fill_buffer(buffer, sizeof buffer)))\n\t\t\tfwrite(buffer, 1, i, outfile);\n\t\tpclose(outfile);\n\t\tgrecs_free(cmd);\n\t} else {\n\t\twhile ((i = grecs_preproc_fill_buffer(buffer, sizeof buffer)))\n\t\t\tfwrite(buffer, 1, i, stdout);\n\t}\n\tgrecs_preproc_done();\n\treturn 0;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_preproc_extrn_start": {
      "start_point": [
        715,
        0
      ],
      "end_point": [
        803,
        1
      ],
      "content": "FILE *\ngrecs_preproc_extrn_start(const char *file_name, pid_t *ppid)\n{\n\tint pout[2];\n\tpid_t pid;\n\tint i;\n\tFILE *fp = NULL;\n\t\n\t/*FIXME_DEBUG_F1 (2, \"Running preprocessor: `%s'\", ppcmd);*/\n\n\tif (pipe(pout)) {\n\t\tgrecs_error(NULL, errno, \"pipe\");\n\t\treturn NULL;\n\t}\n\tswitch (pid = fork()) {\n\t\t/* The child branch.  */\n\tcase 0:\n\t\tif (pout[1] != 1) {\n\t\t\tif (dup2(pout[1], 1) == -1) {\n\t\t\t\tgrecs_error(NULL, errno, \"dup2\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t}\n\n\t\t/* Close unneeded descripitors */\n\t\tfor (i = getdtablesize(); i > 2; i--)\n\t\t\tclose(i);\n\n\t\tif (!grecs_log_to_stderr) {\n\t\t\tint p[2];\n\t\t\tchar *buf = NULL;\n\t\t\tsize_t size = 0;\n\t\t\tFILE *fp;\n\t  \n\t\t\tsignal(SIGCHLD, SIG_DFL);\n\t\t\tif (pipe(p)) {\n\t\t\t\tgrecs_error(NULL, errno, \"pipe\");\n\t\t\t\texit(127);\n\t\t\t}\n\t\t\tswitch (pid = fork()) {\n\t\t\t\t/* Grandchild */\n\t\t\tcase 0:\n\t\t\t\tif (p[1] != 2 && dup2(p[1], 2) == -1) {\n\t\t\t\t\tgrecs_error(NULL, errno, \"dup2\");\n\t\t\t\t\texit(127);\n\t\t\t\t}\n\t\t\t\tclose(p[0]);\n\n\t\t\t\tif (grecs_preproc_run(file_name,\n\t\t\t\t\t\t      grecs_preprocessor))\n\t\t\t\t\texit(127);\n\t\t\t\texit(0);\n\n\t\t\tcase -1:\n\t\t\t\t/*  Fork failed */\n\t\t\t\tif (grecs_log_setup_hook)\n\t\t\t\t\tgrecs_log_setup_hook();\n\t\t\t\tgrecs_error(NULL, errno, _(\"Cannot run `%s'\"),\n\t\t\t\t\t    grecs_preprocessor);\n\t\t\t\texit(127);\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\t/* Sub-master */\n\t\t\t\tclose (p[1]);\n\t\t\t\tfp = fdopen(p[0], \"r\");\n\t\t\t\tif (grecs_log_setup_hook)\n\t\t\t\t\tgrecs_log_setup_hook();\n\t\t\t\twhile (grecs_getline(&buf, &size, fp) > 0)\n\t\t\t\t\tgrecs_error(NULL, 0, \"%s\", buf);\n\t\t\t}\n\t\t} else {\n\t\t\tgrecs_preproc_run(file_name, grecs_preprocessor);\n\t\t}\n\t\texit (0);\n\n\tcase -1:\n\t\t/*  Fork failed */\n\t\tgrecs_error(NULL, errno, _(\"Cannot run `%s'\"),\n\t\t\t    grecs_preprocessor);\n\t\tbreak;\n\t\t\n\tdefault:\n\t\tclose(pout[1]);\n\t\tfp = fdopen(pout[0], \"r\");\n\t\tbreak;\n\t}\n\t*ppid = pid;\n\treturn fp;\n}",
      "lines": 89,
      "depth": 18,
      "decorators": [
        "FILE",
        "*\ngrecs_preproc_extrn_start(const char *file_name, pid_t *ppid)",
        "*"
      ]
    },
    "grecs_preproc_extrn_shutdown": {
      "start_point": [
        805,
        0
      ],
      "end_point": [
        810,
        1
      ],
      "content": "void\ngrecs_preproc_extrn_shutdown(pid_t pid)\n{\n\tint status;\n\twaitpid(pid, &status, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/sockaddr.c": {
    "grecs_sockaddr_new": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "struct grecs_sockaddr *\ngrecs_sockaddr_new(size_t s)\n{\n\tstruct grecs_sockaddr *sp = grecs_malloc(sizeof(*sp));\n\tsp->next = NULL;\n\tsp->sa = grecs_zalloc(s);\n\tsp->len = s;\n\treturn sp;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "struct grecs_sockaddr",
        "struct",
        "grecs_sockaddr",
        "*\ngrecs_sockaddr_new(size_t s)",
        "*"
      ]
    },
    "grecs_sockaddr_free": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngrecs_sockaddr_free(struct grecs_sockaddr *p)\n{\n\twhile (p) {\n\t\tstruct grecs_sockaddr *next = p->next;\n\t\tfree(p->sa);\n\t\tfree(p);\n\t\tp = next;\n\t}\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "parse_unix": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nparse_unix(struct grecs_sockaddr **ret, const char *arg, const char *addrstr,\n\t   struct grecs_sockaddr_hints *gh, grecs_locus_t const *locus)\n{\n\tstruct sockaddr_un *s_un;\n\tsize_t slen = strlen(addrstr);\n\tstruct grecs_sockaddr *sp;\n\t\n\tif (slen >= sizeof s_un->sun_path) {\n\t\tgrecs_error(locus, 0, _(\"socket path name too long: %s\"), arg);\n\t\treturn -1;\n\t}\n\t\n\tsp = grecs_sockaddr_new(sizeof(s_un[0]));\n\ts_un = (struct sockaddr_un *) sp->sa;\n\ts_un->sun_family = AF_UNIX;\n\tstrcpy(s_un->sun_path, addrstr);\n\n\t*ret = sp;\n\treturn 0;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_inet": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "static int\nparse_inet(struct grecs_sockaddr **ret,\n\t   int family, const char *arg, const char *addrstr,\n\t   struct grecs_sockaddr_hints *gh, grecs_locus_t const *locus)\n{\n\tint rc;\n\tstruct addrinfo hints;\n\tstruct addrinfo *res, *ap;\n\tconst char *node = NULL;\n\tchar *nodebuf = NULL;\n\tconst char *service = NULL;\n\tstruct grecs_sockaddr *head = NULL, *tail = NULL;\n\tchar portbuf[64];\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = family;\n\thints.ai_socktype = SOCK_STREAM;\n\n\tif ((family == AF_INET6 || family == AF_UNSPEC)\n\t    && addrstr[0] == '[') {\n\t\tchar *p = strchr(addrstr + 1, ']');\n\t\tif (p && p > addrstr + 1) {\n\t\t\tsize_t len;\n\t\t\t\n\t\t\taddrstr++;\n\t\t\tlen = p - addrstr;\n\t\t\tnodebuf = grecs_malloc(len + 1);\n\t\t\tmemcpy(nodebuf, addrstr, len);\n\t\t\tnodebuf[len] = 0;\n\t\t\tnode = nodebuf;\n\t\t\tservice = p + 1;\n\t\t\tfamily = AF_INET6;\n\t\t} else\n\t\t\tservice = strchr(addrstr, ':');\n\t} else\n\t\tservice = strrchr(addrstr, ':');\n\n\tif (service && *service) {\n\t\tif (*service != ':') {\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t    _(\"%s: garbage near %s\"), arg, service);\n\t\t\treturn -1;\n\t\t}\n\t\tservice++;\n\t}\n\t\n\tif (!node) {\n\t\tif (service) {\n\t\t\tsize_t len = service - addrstr - 1;\n\t\t\t\n\t\t\tif (len == 0)\n\t\t\t\tnode = NULL;\n\t\t\telse {\n\t\t\t\tnodebuf = grecs_malloc(len + 1);\n\t\t\t\tmemcpy(nodebuf, addrstr, len);\n\t\t\t\tnodebuf[len] = 0;\n\t\t\t\tnode = nodebuf;\n\t\t\t}\n\t\t} else {\n\t\t\tif (grecs_str_is_ipaddr(addrstr))\n\t\t\t\tnode = addrstr;\n\t\t\telse if (grecs_str_is_num(addrstr)) {\n\t\t\t\tservice = addrstr;\n\t\t\t\thints.ai_flags |= AI_NUMERICSERV;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif (!service || !*service) {\n\t\tif (!node && addrstr[0])\n\t\t\tnode = addrstr;\n\t\tif (gh->flags & GRECS_HINT_SERVICE) {\n\t\t\tservice = gh->service;\n\t\t} else if (gh->flags & GRECS_HINT_PORT) {\n\t\t\tsnprintf(portbuf, sizeof portbuf, \"%hu\", gh->port);\n\t\t\tservice = portbuf;\n\t\t\thints.ai_flags |= AI_NUMERICSERV;\n\t\t} else if (!(gh->flags & GRECS_AH_PASSIVE)) {\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t    _(\"service not specified: %s\"), arg);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t\n\tif (!node) {\n\t\tif (gh->flags & GRECS_AH_PASSIVE)\n\t\t\thints.ai_flags |= AI_PASSIVE;\n\t}\n\t\n\trc = getaddrinfo(node, service, &hints, &res);\n\tfree(nodebuf);\n\tswitch (rc) {\n\tcase 0:\n\t\tbreak;\n\tcase EAI_SYSTEM:\n\t\tgrecs_error(locus, 0,\n\t\t\t    _(\"%s: cannot parse address: %s\"),\n\t\t\t    arg, strerror(errno));\n\t\tbreak;\n\tcase EAI_BADFLAGS:\n\tcase EAI_SOCKTYPE:\n\t\tgrecs_error(locus, 0,\n\t\t\t    \"%s:%d: internal error converting %s\",\n\t\t\t    __FILE__,__LINE__,arg);\n\t\tbreak;\n\tcase EAI_MEMORY:\n\t\tgrecs_alloc_die();\n\tdefault:\n\t\tgrecs_error(locus, 0,\n\t\t\t    \"%s: %s\", arg, gai_strerror(rc));\n\t\treturn -1;\n\t}\n\n\tfor (ap = res; ap; ap = ap->ai_next) {\n\t\tif (family == AF_UNSPEC || ap->ai_addr->sa_family == family) {\n\t\t\tstruct grecs_sockaddr *sp =\n\t\t\t\tgrecs_sockaddr_new(ap->ai_addrlen);\n\t\t\tmemcpy(sp->sa, ap->ai_addr, ap->ai_addrlen);\n\t\t\tsp->len = ap->ai_addrlen;\n\t\t\tif (!head)\n\t\t\t\thead = sp;\n\t\t\telse\n\t\t\t\ttail->next = sp;\n\t\t\ttail = sp;\n\t\t}\n\t}\n\tfreeaddrinfo(res);\n\t*ret = head;\n\treturn 0;\n}",
      "lines": 130,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_inet4": {
      "start_point": [
        207,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "static int\nparse_inet4(struct grecs_sockaddr **ret, const char *arg, const char *addrstr,\n\t    struct grecs_sockaddr_hints *gh, grecs_locus_t const *locus)\n{\n\treturn parse_inet(ret, AF_INET, arg, addrstr, gh, locus);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_inet6": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "static int\nparse_inet6(struct grecs_sockaddr **ret, const char *arg, const char *addrstr,\n\t    struct grecs_sockaddr_hints *gh, grecs_locus_t const *locus)\n{\n\treturn parse_inet(ret, AF_INET6, arg, addrstr, gh, locus);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_str_to_sockaddr": {
      "start_point": [
        238,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "int\ngrecs_str_to_sockaddr(struct grecs_sockaddr **sap,\n\t\t      const char *arg, struct grecs_sockaddr_hints *gh,\n\t\t      grecs_locus_t const *locus)\n{\n\tchar *p;\n\tstruct grecs_sockaddr_hints ghints;\n\t\n\tif (!gh) {\n\t\tmemset(&ghints, 0, sizeof(ghints));\n\t\tif (grecs_default_port) {\n\t\t\tghints.flags = GRECS_HINT_PORT;\n\t\t\tghints.port = ntohs(grecs_default_port);\n\t\t}\n\t\tgh = &ghints;\n\t}\n\t\n\tp = strchr(arg, ':');\n\tif (p && p > arg && p[1] == '/' && p[2] == '/') {\n\t\tsize_t len = p - arg;\n\t\tstruct schemetab *sp;\n\n\t\tfor (sp = schemetab; sp->scheme; sp++)\n\t\t\tif (len == sp->len &&\n\t\t\t    memcmp(arg, sp->scheme, len) == 0)\n\t\t\t\treturn sp->parser(sap, arg, p + 3, gh, locus);\n\t\tgrecs_error(locus, 0,\n\t\t\t    _(\"unknown or unsupported scheme: %s\"), arg);\n\t\treturn -1;\n\t}\n\n\tif (arg[0] == '/')\n\t\treturn parse_unix(sap, arg, arg, gh, locus);\n\telse if (strlen(arg) > 5 && memcmp(arg, \"unix:\", 5) == 0) {\n\t\tif (arg[5] != '/')\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t    _(\"%s: UNIX socket must be an absolute file name\"),\n\t\t\t\t    arg);\n\t\treturn parse_unix(sap, arg, arg + 5, gh, locus);\n\t}\n\t\n\treturn parse_inet(sap, AF_UNSPEC, arg, arg, gh, locus);\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/sort.c": {
    "node_list_init": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static void\nnode_list_init(struct node_list *list, struct grecs_node *node)\n{\n\tif (node) {\n\t\tlist->head = node;\n\t\twhile (node->next)\n\t\t\tnode = node->next;\n\t\tlist->tail = node;\n\t} else\n\t\tlist->head = list->tail = NULL;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_list_add": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\nnode_list_add(struct node_list *list, struct grecs_node *node)\n{\n\tnode->next = NULL;\n\tnode->prev = list->tail;\n\tif (list->tail)\n\t\tlist->tail->next = node;\n\telse\n\t\tlist->head = node;\n\tlist->tail = node;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_list_join": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\nnode_list_join(struct node_list *a, struct node_list *b)\n{\n\tif (!b->head)\n\t\treturn;\n\tb->head->prev = a->tail;\n\tif (a->tail)\n\t\ta->tail->next = b->head;\n\telse\n\t\ta->head = b->head;\n\ta->tail = b->tail;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_qsort_nodelist": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static void\n_qsort_nodelist(struct node_list *list,\n\t\tint (*compare)(struct grecs_node const *,\n\t\t\t       struct grecs_node const *))\n{\n\tstruct grecs_node *cur, *middle;\n\tstruct node_list high_list, low_list;\n\tint rc;\n\t\n\tif (!list->head)\n\t\treturn;\n\tcur = list->head;\n\tdo {\n\t\tcur = cur->next;\n\t\tif (!cur)\n\t\t\treturn;\n\t} while ((rc = compare(list->head, cur)) == 0);\n\n\t/* Select the lower of the two as the middle value */\n\tmiddle = (rc > 0) ? cur : list->head;\n\n\t/* Split into two sublists */\n\tnode_list_init(&low_list, NULL);\n\tnode_list_init(&high_list, NULL);\n\tfor (cur = list->head; cur; ) {\n\t\tstruct grecs_node *next = cur->next;\n\t\tcur->next = NULL;\n\t\tif (compare(middle, cur) < 0)\n\t\t\tnode_list_add(&high_list, cur);\n\t\telse\n\t\t\tnode_list_add(&low_list, cur);\n\t\tcur = next;\n\t}\n\n\tif (!low_list.head)\n\t\tlow_list = high_list;\n\telse if (high_list.head) {\n\t\t/* Sort both sublists recursively */\n\t\t_qsort_nodelist(&low_list, compare);\n\t\t_qsort_nodelist(&high_list, compare);\n\t\t/* Join both lists in order */\n\t\tnode_list_join(&low_list, &high_list);\n\t}\n\t/* Return the resulting list */\n\tlist->head = low_list.head;\n\tlist->tail = low_list.tail;\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_nodelist_sort": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "struct grecs_node *\ngrecs_nodelist_sort(struct grecs_node *node,\n\t\t    int (*compare)(struct grecs_node const *,\n\t\t\t\t   struct grecs_node const *))\n{\n\tstruct node_list list;\n\tnode_list_init(&list, node);\n\t_qsort_nodelist(&list, compare);\n\treturn list.head;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_nodelist_sort(struct grecs_node *node,\n\t\t    int (*compare)(struct grecs_node const *,\n\t\t\t\t   struct grecs_node const *))",
        "*"
      ]
    },
    "grecs_tree_sort": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\ngrecs_tree_sort(struct grecs_node *node,\n\t\tint (*compare)(struct grecs_node const *,\n\t\t\t       struct grecs_node const *))\n{\n\tif (node && node->down) {\n\t\tnode->down = grecs_nodelist_sort(node->down, compare);\n\t\tfor (node = node->down; node; node = node->next)\n\t\t\tgrecs_tree_sort(node, compare);\n\t}\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/symtab.c": {
    "syment_free": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\nsyment_free(struct grecs_symtab *st, void *ptr)\n{\n\tif (st->syment_free_fun)\n\t\tst->syment_free_fun(ptr);\n\telse\n\t\tfree(ptr);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "syment_alloc": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static struct grecs_syment *\nsyment_alloc(struct grecs_symtab *st, void *key)\n{\n\tstruct grecs_syment *ent;\n\t\n\tent = st->syment_alloc_fun ?\n\t\tst->syment_alloc_fun(st->elsize) : malloc(st->elsize);\n\tif (ent) {\n\t\tmemset(ent, 0, st->elsize);\n\t\tif (st->copy_fun(ent, key)) {\n\t\t\tint ec = errno;\n\t\t\tsyment_free(st, ent);\n\t\t\terrno = ec;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ent;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct grecs_syment",
        "struct",
        "grecs_syment",
        "*\nsyment_alloc(struct grecs_symtab *st, void *key)",
        "*"
      ]
    },
    "grecs_hash_string": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "unsigned\ngrecs_hash_string(const char *name, unsigned long hashsize)\n{\n\tunsigned i;\n\t\n\tfor (i = 0; *name; name++) {\n\t\ti <<= 1;\n\t\ti ^= *(unsigned char*) name;\n\t}\n\treturn i % hashsize;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "grecs_hash_string_ci": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "unsigned\ngrecs_hash_string_ci(const char *name, unsigned long hashsize)\n{\n\tunsigned i;\n\t\n\tfor (i = 0; *name; name++) {\n\t\ti <<= 1;\n\t\ti ^= tolower (*(unsigned char*) name);\n\t}\n\treturn i % hashsize;\n}",
      "lines": 11,
      "depth": 13,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "def_hash": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static unsigned\ndef_hash(void *data, unsigned long hashsize)\n{\n  struct grecs_syment *sym = data;\n  return grecs_hash_string(sym->name, hashsize);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "def_cmp": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static int\ndef_cmp(const void *a, const void *b)\n{\n\tstruct grecs_syment const *syma = a;\n\tstruct grecs_syment const *symb = b;\n\n\treturn strcmp(syma->name, symb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "def_copy": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static int\ndef_copy(void *a, void *b)\n{\n\tstruct grecs_syment *syma = a;\n\tstruct grecs_syment *symb = b;\n\n\tsyma->name = strdup(symb->name);\n\treturn syma->name == NULL;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "def_free_fun": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\ndef_free_fun(void *p)\n{\n\tstruct grecs_syment *sym = p;\n\tfree(sym->name);\n\tfree(sym);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "symtab_insert_pos": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static unsigned\nsymtab_insert_pos(struct grecs_symtab *st, void *elt)\n{\n\tunsigned i;\n\tunsigned pos = st->hash_fun(elt, hash_size[st->hash_num]);\n\t\n\tfor (i = pos; st->tab[i];) {\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\t/* FIXME: Error message? */\n\t\t\tabort();\n\t}\n\treturn i;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "grecs_symtab_replace": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "int\ngrecs_symtab_replace(struct grecs_symtab *st, void *ent, void **old_ent)\n{\n\tstruct grecs_syment *entry;\n\tunsigned i, pos = st->hash_fun(ent, hash_size[st->hash_num]);\n\tfor (i = pos; (entry = st->tab[i]);) {\n\t\tif (st->cmp_fun(entry, ent) == 0)\n\t\t\tbreak;\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\treturn ENOENT;\n\t}\n\tif (old_ent)\n\t\t*old_ent = entry;\n\tst->tab[i] = ent;\n\treturn 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "symtab_rehash": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static int\nsymtab_rehash(struct grecs_symtab *st)\n{\n\tstruct grecs_syment **old_tab = st->tab;\n\tstruct grecs_syment **new_tab;\n\tunsigned int i;\n\tunsigned int hash_num = st->hash_num + 1;\n\t\n\tif (hash_num >= max_rehash)\n\t\treturn E2BIG;\n\n\tnew_tab = calloc(hash_size[hash_num], sizeof(*new_tab));\n\tif (!new_tab)\n\t\treturn ENOMEM;\n\tst->tab = new_tab;\n\tif (old_tab) {\n\t\tst->hash_num = hash_num;\n\t\tfor (i = 0; i < hash_size[hash_num-1]; i++) {\n\t\t\tstruct grecs_syment *elt = old_tab[i];\n\t\t\tif (elt->name) {\n\t\t\t\tunsigned n = symtab_insert_pos(st, elt);\n\t\t\t\tnew_tab[n] = elt;\n\t\t\t}\n\t\t}\n\t\tfree(old_tab);\n\t}\n\treturn 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_symtab_strerror": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "const char *\ngrecs_symtab_strerror(int rc)\n{\n\tswitch (rc) {\n\tcase ENOENT:\n\t\treturn _(\"element not found in table\");\n\tcase E2BIG:\n\t\treturn _(\"symbol table is full\");\n\tcase ENOMEM:\n\t\treturn strerror(ENOMEM);\n\t}\n\treturn strerror(rc);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\ngrecs_symtab_strerror(int rc)",
        "*"
      ]
    },
    "grecs_symtab_remove": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\ngrecs_symtab_remove(struct grecs_symtab *st, void *elt)\n{\n\tunsigned int pos, i, j, r;\n\tstruct grecs_syment *entry;\n\t\n\tpos = st->hash_fun(elt, hash_size[st->hash_num]);\n\tfor (i = pos; (entry = st->tab[i]);) {\n\t\tif (st->cmp_fun(entry, elt) == 0)\n\t\t\tbreak;\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\treturn ENOENT;\n\t}\n\t\n\tif (!entry)\n\t\treturn ENOENT;\n\n\tsyment_free(st, entry);\n\n\tfor (;;) {\n\t\tst->tab[i] = NULL;\n\t\tj = i;\n\n\t\tdo {\n\t\t\tif (++i >= hash_size[st->hash_num])\n\t\t\t\ti = 0;\n\t\t\tif (!st->tab[i])\n\t\t\t\treturn 0;\n\t\t\tr = st->hash_fun(st->tab[i], hash_size[st->hash_num]);\n\t\t}\n\t\twhile ((j < r && r <= i)\n\t\t       || (i < j && j < r) || (r <= i && i < j));\n\t\tst->tab[j] = st->tab[i];\n\t}\n\treturn 0;\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "grecs_symtab_get_index": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "int\ngrecs_symtab_get_index(unsigned *idx, struct grecs_symtab *st,\n\t\t       void *key, int *install)\n{\n\tint rc;\n\tunsigned i, pos;\n\tstruct grecs_syment *elem;\n  \n\tif (!st->tab) {\n\t\tif (install) {\n\t\t\trc = symtab_rehash(st);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else\n\t\t\treturn ENOENT;\n\t}\n\n\tpos = st->hash_fun(key, hash_size[st->hash_num]);\n\n\tfor (i = pos; (elem = st->tab[i]);) {\n\t\tif (st->cmp_fun(elem, key) == 0) {\n\t\t\tif (install)\n\t\t\t\t*install = 0;\n\t\t\t*idx = i; \n\t\t\treturn 0;\n\t\t}\n      \n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\tbreak;\n\t}\n\n\tif (!install)\n\t\treturn ENOENT;\n  \n\tif (!elem) {\n\t\t*install = 1;\n\t\t*idx = i;\n\t\treturn 0;\n\t}\n\n\tif ((rc = symtab_rehash(st)) != 0)\n\t\treturn rc;\n\n\treturn grecs_symtab_get_index(idx, st, key, install);\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "grecs_symtab_lookup_or_install": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "void *\ngrecs_symtab_lookup_or_install(struct grecs_symtab *st, void *key,\n\t\t\t       int *install)\n{\n\tunsigned i;\n\tint rc = grecs_symtab_get_index(&i, st, key, install);\n\tif (rc == 0) {\n\t\tif (install && *install == 1) {\n\t\t\tstruct grecs_syment *ent = syment_alloc(st, key);\n\t\t\tif (!ent) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tst->tab[i] = ent;\n\t\t\treturn ent;\n\t\t} else\n\t\t\treturn st->tab[i];\n\t}\n\terrno = rc;\n\treturn NULL;\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "void",
        "*\ngrecs_symtab_lookup_or_install(struct grecs_symtab *st, void *key,\n\t\t\t       int *install)",
        "*"
      ]
    },
    "grecs_symtab_clear": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "void\ngrecs_symtab_clear(struct grecs_symtab *st)\n{\n\tunsigned i, hs;\n  \n\tif (!st || !st->tab)\n\t\treturn;\n\n\ths = hash_size[st->hash_num];\n\tfor (i = 0; i < hs; i++) {\n\t\tstruct grecs_syment *elem = st->tab[i];\n\t\tif (elem) {\n\t\t\tsyment_free(st, elem);\n\t\t\tst->tab[i] = NULL;\n\t\t}\n\t}\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "grecs_symtab_create": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "struct grecs_symtab *\ngrecs_symtab_create(size_t elsize, \n\t\t    unsigned (*hash_fun)(void *, unsigned long),\n\t\t    int (*cmp_fun)(const void *, const void *),\n\t\t    int (*copy_fun)(void *, void *),\n\t\t    void *(*alloc_fun)(size_t), void (*free_fun)(void *))\n{\n\tstruct grecs_symtab *st = malloc(sizeof(*st));\n\tif (st) {\n\t\tmemset(st, 0, sizeof(*st));\n\t\tst->elsize = elsize;\n\t\tst->hash_fun = hash_fun ? hash_fun : def_hash;\n\t\tst->cmp_fun = cmp_fun ? cmp_fun : def_cmp;\n\t\tst->copy_fun = copy_fun ? copy_fun : def_copy;\n\t\tst->syment_alloc_fun = alloc_fun;\n\t\tif (free_fun)\n\t\t\tst->syment_free_fun = free_fun;\n\t\telse if (!copy_fun)\n\t\t\tst->syment_free_fun = def_free_fun;\n\t\telse\n\t\t\tst->syment_free_fun = NULL;\n\t\tst->tab = calloc(hash_size[st->hash_num], sizeof(*st->tab));\n\t\tif (!st->tab) {\n\t\t\tfree(st);\n\t\t\tst = NULL;\n\t\t}\n\t}\n\treturn st;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "struct grecs_symtab",
        "struct",
        "grecs_symtab",
        "*\ngrecs_symtab_create(size_t elsize, \n\t\t    unsigned (*hash_fun)(void *, unsigned long),\n\t\t    int (*cmp_fun)(const void *, const void *),\n\t\t    int (*copy_fun)(void *, void *),\n\t\t    void *(*alloc_fun)(size_t), void (*free_fun)(void *))",
        "*"
      ]
    },
    "grecs_symtab_create_default": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "struct grecs_symtab *\ngrecs_symtab_create_default(size_t elsize)\n{\n\treturn grecs_symtab_create(elsize,\n\t\t\t\t   NULL, NULL, NULL, NULL, NULL);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "struct grecs_symtab",
        "struct",
        "grecs_symtab",
        "*\ngrecs_symtab_create_default(size_t elsize)",
        "*"
      ]
    },
    "grecs_symtab_free": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "void\ngrecs_symtab_free(struct grecs_symtab *st)\n{\n\tif (st) {\n\t\tgrecs_symtab_clear(st);\n\t\tfree(st->tab);\n\t\tfree(st);\n\t}\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_symtab_count_entries": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "size_t\ngrecs_symtab_count_entries(struct grecs_symtab *st)\n{\n\tunsigned i;\n\tsize_t count = 0;\n\t\n\tfor (i = 0; i < hash_size[st->hash_num]; i++)\n\t\tif (st->tab[i])\n\t\t\tcount++;\n\treturn count;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "grecs_symtab_enumerate": {
      "start_point": [
        400,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "int\ngrecs_symtab_enumerate(struct grecs_symtab *st, grecs_symtab_enumerator_t fun,\n\t\t       void *data)\n{\n\tunsigned i;\n\n\tif (!st)\n\t\treturn 0;\n\tfor (i = 0; i < hash_size[st->hash_num]; i++) {\n\t\tstruct grecs_syment *ep = st->tab[i];\n\t\tif (ep) {\n\t\t\tint rc = fun(ep, data);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/text.c": {
    "grecs_install_text": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "char *\ngrecs_install_text(const char *str)\n{\n\tstruct grecs_syment key;\n\tstruct grecs_syment *ent;\n\tint install = 1;\n\n\tif (!text_table) {\n\t\ttext_table = grecs_symtab_create_default(\n\t\t\t              sizeof(struct grecs_syment));\n\t\tif (!text_table)\n\t\t\tgrecs_alloc_die();\n\t}\n  \n\tkey.name = (char*) str;\n\tent = grecs_symtab_lookup_or_install(text_table, &key, &install);\n\tif (!ent)\n\t\tgrecs_alloc_die();\n\treturn ent->name;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "char",
        "*\ngrecs_install_text(const char *str)",
        "*"
      ]
    },
    "grecs_destroy_text": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ngrecs_destroy_text()\n{\n\tgrecs_symtab_free(text_table);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_text_table": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "struct grecs_symtab *\ngrecs_text_table()\n{\n\tstruct grecs_symtab *tmp = text_table;\n\ttext_table = NULL;\n\treturn tmp;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "struct grecs_symtab",
        "struct",
        "grecs_symtab",
        "*\ngrecs_text_table()",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/tree.c": {
    "grecs_value_free_content": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\ngrecs_value_free_content(struct grecs_value *val)\n{\n\tint i;\n\n\tif (!val)\n\t\treturn;\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tgrecs_free(val->v.string);\n\t\tbreak;\n\n\tcase GRECS_TYPE_LIST:\n\t\tgrecs_list_free(val->v.list);\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tfor (i = 0; i < val->v.arg.c; i++)\n\t\t\tgrecs_value_free(val->v.arg.v[i]);\n\t\tfree(val->v.arg.v);\n\t}\n}",
      "lines": 22,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "grecs_value_free": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ngrecs_value_free(struct grecs_value *val)\n{\n\tgrecs_value_free_content(val);\n\tgrecs_free(val);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "grecs_node_create": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "struct grecs_node *\ngrecs_node_create(enum grecs_node_type type, grecs_locus_t *loc)\n{\n\tstruct grecs_node *np = grecs_zalloc(sizeof(*np));\n\tnp->type = type;\n\tif (loc)\n\t\tnp->locus = *loc;\n\treturn np;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_node_create(enum grecs_node_type type, grecs_locus_t *loc)",
        "*"
      ]
    },
    "grecs_node_create_points": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "struct grecs_node *\ngrecs_node_create_points(enum grecs_node_type type,\n\t\t\t struct grecs_locus_point beg,\n\t\t\t struct grecs_locus_point end)\n{\n\tgrecs_locus_t loc;\n\n\tloc.beg = beg;\n\tloc.end = end;\n\treturn grecs_node_create(type, &loc);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_node_create_points(enum grecs_node_type type,\n\t\t\t struct grecs_locus_point beg,\n\t\t\t struct grecs_locus_point end)",
        "*"
      ]
    },
    "grecs_node_bind": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void\ngrecs_node_bind(struct grecs_node *master, struct grecs_node *node, int dn)\n{\n\tstruct grecs_node *np;\n\n\tif (!node)\n\t\treturn;\n\tif (dn) {\n\t\tif (!master->down) {\n\t\t\tmaster->down = node;\n\t\t\tnode->prev = NULL;\n\t\t} else {\n\t\t\tfor (np = master->down; np->next; np = np->next)\n\t\t\t\t;\n\t\t\tnp->next = node;\n\t\t\tnode->prev = np;\n\t\t}\n\t\tfor (; node; node = node->next)\n\t\t\tnode->up = master;\n\t} else {\n\t\tif (!master->next) {\n\t\t\tmaster->next = node;\n\t\t\tnode->prev = master;\n\t\t} else {\n\t\t\tfor (np = master->next; np->next; np = np->next)\n\t\t\t\t;\n\t\t\tnp->next = node;\n\t\t\tnode->prev = np;\n\t\t}\n\t\tnode->up = master->up;\n\t}\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_node_unlink": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\ngrecs_node_unlink(struct grecs_node *node)\n{\n\tif (node->prev)\n\t\tnode->prev->next = node->next;\n\telse if (node->up)\n\t\tnode->up->down = node->next;\n\telse\n\t\treturn 1;\n\tif (node->next)\n\t\tnode->next->prev = node->prev;\n\treturn 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "listel_dispose": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static void\nlistel_dispose(void *el)\n{\n\tgrecs_free(el);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_grecs_simple_list_create": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "struct grecs_list *\n_grecs_simple_list_create(int dispose)\n{\n\tstruct grecs_list *lp = grecs_list_create();\n\tif (dispose)\n\t\tlp->free_entry = listel_dispose;\n\treturn lp;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "struct grecs_list",
        "struct",
        "grecs_list",
        "*\n_grecs_simple_list_create(int dispose)",
        "*"
      ]
    },
    "_tree_recurse": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "static enum grecs_tree_recurse_res\n_tree_recurse(struct grecs_node *node, grecs_tree_recursor_t recfun,\n\t      void *data)\n{\n\tenum grecs_tree_recurse_res res;\n#define CKRES()\t\t\t\t\t\t\\\n\tswitch (res) {\t\t\t\t\t\\\n        case grecs_tree_recurse_fail:\t\t\t\\\n        case grecs_tree_recurse_stop:\t\t\t\\\n\t\treturn res;\t\t\t\t\\\n\tdefault:\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\\\n\t}\n\n\twhile (node) {\n\t\tstruct grecs_node *next = node->next;\n\t\tif (node->type == grecs_node_stmt) {\n\t\t\tres = recfun(grecs_tree_recurse_set, node, data);\n\t\t\tCKRES();\n\t\t} else {\n\t\t\tswitch (recfun(grecs_tree_recurse_pre, node, data)) {\n\t\t\tcase grecs_tree_recurse_ok:\n\t\t\t\tres = _tree_recurse(node->down, recfun, data);\n\t\t\t\tCKRES();\n\t\t\t\tres = recfun(grecs_tree_recurse_post, node,\n\t\t\t\t\t     data);\n\t\t\t\tCKRES();\n\t\t\t\tbreak;\n\t\t\tcase grecs_tree_recurse_fail:\n\t\t\t\treturn grecs_tree_recurse_fail;\n\t\t\tcase grecs_tree_recurse_stop:\n\t\t\t\treturn grecs_tree_recurse_stop;\n\t\t\tcase grecs_tree_recurse_skip:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tnode = next;\n\t}\n\treturn grecs_tree_recurse_ok;\n#undef CKRES\n}",
      "lines": 41,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_tree_recurse": {
      "start_point": [
        194,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\ngrecs_tree_recurse(struct grecs_node *node, grecs_tree_recursor_t recfun,\n\t\t   void *data)\n{\n\tswitch (_tree_recurse(node, recfun, data)) {\n\tcase grecs_tree_recurse_ok:\n\tcase grecs_tree_recurse_stop:\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn 1;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "grecs_node_free": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void\ngrecs_node_free(struct grecs_node *node)\n{\n\tif (!node)\n\t\treturn;\n\tswitch (node->type) {\n\tcase grecs_node_root:\n\t\tgrecs_symtab_free(node->v.texttab);\n\t\tbreak;\n\tdefault:\n\t\tgrecs_value_free(node->v.value);\n\t}\n\tgrecs_free(node->ident);\n\tgrecs_free(node);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "freeproc": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static enum grecs_tree_recurse_res\nfreeproc(enum grecs_tree_recurse_op op, struct grecs_node *node, void *data)\n{\n\tswitch (op) {\n\tcase grecs_tree_recurse_set:\n\tcase grecs_tree_recurse_post:\n\t\tgrecs_node_unlink(node);\n\t\tgrecs_node_free(node);\n\t\tbreak;\n\tcase grecs_tree_recurse_pre:\n\t\t/* descend into the subtree */\n\t\tbreak;\n\t}\n\treturn grecs_tree_recurse_ok;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_tree_free": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "int\ngrecs_tree_free(struct grecs_node *node)\n{\n\tif (!node)\n\t\treturn 0;\n\tif (node->type != grecs_node_root) {\n\t\terrno = EINVAL;\n\t\treturn 1;\n\t}\n\tgrecs_tree_recurse(node, freeproc, NULL);\n\treturn 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "find_keyword": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static struct grecs_keyword *\nfind_keyword(struct grecs_keyword *cursect, const char *ident)\n{\n\tstruct grecs_keyword *kwp;\n  \n\tif (cursect && cursect->kwd && cursect != &fake) {\n\t\tfor (kwp = cursect->kwd; kwp->ident; kwp++)\n\t\t\tif (strcmp(kwp->ident, ident) == 0)\n\t\t\t\treturn kwp;\n\t} else {\n\t\treturn &fake;\n\t}\n\treturn NULL;\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "struct grecs_keyword",
        "struct",
        "grecs_keyword",
        "*\nfind_keyword(struct grecs_keyword *cursect, const char *ident)",
        "*"
      ]
    },
    "target_ptr": {
      "start_point": [
        302,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void *\ntarget_ptr(struct grecs_keyword *kwp, char *base)\n{\n\tif (kwp->varptr)\n\t\tbase = (char*) kwp->varptr + kwp->offset;\n\telse if (base)\n\t\tbase += kwp->offset;\n\t\n\treturn base;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ntarget_ptr(struct grecs_keyword *kwp, char *base)",
        "*"
      ]
    },
    "string_to_bool": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "static int\nstring_to_bool(const char *string, int *pval, grecs_locus_t const *locus)\n{\n\tif (strcmp(string, \"yes\") == 0\n\t    || strcmp(string, \"true\") == 0\n\t    || strcmp(string, \"t\") == 0\n\t    || strcmp(string, \"1\") == 0)\n\t\t*pval = 1;\n\telse if (strcmp(string, \"no\") == 0\n\t\t || strcmp(string, \"false\") == 0\n\t\t || strcmp(string, \"nil\") == 0\n\t\t || strcmp(string, \"0\") == 0)\n\t\t*pval = 0;\n\telse {\n\t\tgrecs_error(locus, 0,\n\t\t\t     _(\"%s: not a valid boolean value\"),\n\t\t\t     string);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "string_to_host": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "static int\nstring_to_host(struct in_addr *in, const char *string,\n\t       grecs_locus_t const *locus)\n{\n\tif (inet_aton(string, in) == 0) {\n\t\tstruct hostent *hp;\n\n\t\thp = gethostbyname(string);\n\t\tif (hp == NULL)\n\t\t\treturn 1;\n\t\tmemcpy(in, hp->h_addr, sizeof(struct in_addr));\n\t}\n\treturn 0;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "string_to_sockaddr": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        428,
        1
      ],
      "content": "static int\nstring_to_sockaddr(struct grecs_sockaddr *sp, const char *string,\n\t\t   grecs_locus_t const *locus)\n{\n\tif (string[0] == '/') {\n\t\tstruct sockaddr_un s_un;\n\t\tif (strlen(string) >= sizeof(s_un.sun_path)) {\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t     _(\"%s: UNIX socket name too long\"),\n\t\t\t\t     string);\n\t\t\treturn 1;\n\t\t}\n\t\ts_un.sun_family = AF_UNIX;\n\t\tstrcpy(s_un.sun_path, string);\n\t\tsp->len = sizeof(s_un);\n\t\tsp->sa = grecs_malloc(sp->len);\n\t\tmemcpy(sp->sa, &s_un, sp->len);\n\t} else {\n\t\tchar *p = strchr(string, ':');\n\t\tsize_t len;\n\t\tstruct sockaddr_in sa;\n\t\t\n\t\tsa.sin_family = AF_INET;\n\t\tif (p) \n\t\t\tlen = p - string;\n\t\telse\n\t\t\tlen = strlen(string);\n\t\t\n\t\tif (len == 0)\n\t\t\tsa.sin_addr.s_addr = INADDR_ANY;\n\t\telse {\n\t\t\tchar *host = grecs_malloc(len + 1);\n\t\t\tmemcpy(host, string, len);\n\t\t\thost[len] = 0;\n\t\t\t\n\t\t\tif (string_to_host(&sa.sin_addr, host, locus)) {\n\t\t\t\tgrecs_error(locus, 0,\n\t\t\t\t\t     _(\"%s: not a valid IP address or hostname\"),\n\t\t\t\t\t     host);\n\t\t\t\tgrecs_free(host);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tgrecs_free(host);\n\t\t}\n\t\t\n\t\tif (p) {\n\t\t\tstruct servent *serv;\n\t\t\t\n\t\t\tp++;\n\t\t\tserv = getservbyname(p, \"tcp\");\n\t\t\tif (serv != NULL)\n\t\t\t\tsa.sin_port = serv->s_port;\n\t\t\telse {\n\t\t\t\tunsigned long l;\n\t\t\t\tchar *q;\n\t\t\t\t\n\t\t\t\t/* Not in services, maybe a number? */\n\t\t\t\tl = strtoul(p, &q, 0);\n\t\t\t\t\n\t\t\t\tif (*q || l > USHRT_MAX) {\n\t\t\t\t\tgrecs_error(locus, 0,\n\t\t\t\t\t\t     _(\"%s: not a valid port number\"), p);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tsa.sin_port = htons(l);\n\t\t\t}\n\t\t} else if (grecs_default_port)\n\t\t\tsa.sin_port = grecs_default_port;\n\t\telse {\n\t\t\tgrecs_error(locus, 0, _(\"missing port number\"));\n\t\t\treturn 1;\n\t\t}\n\t\tsp->len = sizeof(sa);\n\t\tsp->sa = grecs_malloc(sp->len);\n\t\tmemcpy(sp->sa, &sa, sp->len);\n\t}\n\treturn 0;\n}",
      "lines": 78,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_string_convert": {
      "start_point": [
        546,
        0
      ],
      "end_point": [
        637,
        1
      ],
      "content": "int\ngrecs_string_convert(void *target, enum grecs_data_type type,\n\t\t     const char *string, grecs_locus_t const *locus)\n{\n  switch (type) {\n  case grecs_type_void:\n\t  abort();\n\n  case grecs_type_null:\n\t  break;\n\t  \n  case grecs_type_string:\n\t  *(char**)target = grecs_strdup(string);\n\t  break;\n\t    \n  case grecs_type_short:\n\t  GETUNUM(string, short, *(short*)target, locus);\n\t  break;\n\t    \n  case grecs_type_ushort:\n\t  GETUNUM(string, unsigned short, *(unsigned short*)target, locus);\n\t  break;\n\t    \n  case grecs_type_bool:\n\t  return string_to_bool(string, (int*)target, locus);\n\t    \n  case grecs_type_int:\n\t  GETSNUM(string, int, *(int*)target, locus);\n\t  break;\n\t    \n  case grecs_type_uint:\n\t  GETUNUM(string, unsigned int, *(unsigned int*)target, locus);\n\t  break;\n      \n  case grecs_type_long:\n\t  GETSNUM(string, long, *(long*)target, locus);\n\t  break;\n\t    \n  case grecs_type_ulong:\n\t  GETUNUM(string, unsigned long, *(unsigned long*)target, locus);\n\t  break;\n\t    \n  case grecs_type_size:\n\t  GETUNUM(string, size_t, *(size_t*)target, locus);\n\t  break;\n\t  /*FIXME\t    \n  case grecs_type_off:\n          GETSNUM(string, off_t, *(off_t*)target, locus);\n\t  break;\n\t  */    \n  case grecs_type_time:\n\t  /*FIXME: Use getdate */\n\t  GETUNUM(string, time_t, *(time_t*)target, locus);\n\t  break;\n\n  case grecs_type_ipv4:\n\t  if (inet_aton(string, (struct in_addr *)target)) {\n\t\t  grecs_error(locus, 0, _(\"%s: not a valid IP address\"),\n\t\t\t       string);\n\t\t  return 1;\n\t  }\n\t  break;\n\t  \n  case grecs_type_host:\n\t  if (string_to_host((struct in_addr *)target, string, locus)) {\n\t\t  grecs_error(locus, 0,\n\t\t\t       _(\"%s: not a valid IP address or hostname\"),\n\t\t\t       string);\n\t\t  return 1;\n\t  }\n\t  break;    \n\t    \n  case grecs_type_sockaddr:\n#if GRECS_SOCKADDR_LIST\n\t  return grecs_str_to_sockaddr((struct grecs_sockaddr **)target,\n\t\t\t\t       string, grecs_sockaddr_hints,\n\t\t\t\t       locus);\n#else\n\t  return string_to_sockaddr((struct grecs_sockaddr *)target, string,\n\t\t\t\t    locus);\n#endif\n\n  case grecs_type_cidr:\n\t  return grecs_str_to_cidr((struct grecs_cidr *)target, string, locus);\n\t    \n  case grecs_type_section:\n\t  grecs_error(locus, 0,\n\t\t       _(\"invalid use of block statement\"));\n\t  return 1;\n  }\n  return 0;\n}",
      "lines": 92,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "string_cmp": {
      "start_point": [
        645,
        0
      ],
      "end_point": [
        649,
        1
      ],
      "content": "static int\nstring_cmp(const void *elt1, const void *elt2)\n{\n\treturn strcmp((const char *)elt1,(const char *)elt2);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cidr_cmp": {
      "start_point": [
        670,
        0
      ],
      "end_point": [
        678,
        1
      ],
      "content": "static int\ncidr_cmp(const void *elt1, const void *elt2)\n{\n\tstruct grecs_cidr const *cp1 = elt1, *cp2 = elt2;\n\treturn !(cp1->family == cp2->family\n\t\t && cp1->len == cp2->len\n\t\t && memcmp(cp1->address, cp2->address, cp1->len) == 0\n\t\t && memcmp(cp1->netmask, cp2->netmask, cp1->len) == 0);\n}",
      "lines": 9,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "grecs_process_ident": {
      "start_point": [
        707,
        0
      ],
      "end_point": [
        835,
        1
      ],
      "content": "void\ngrecs_process_ident(struct grecs_keyword *kwp, grecs_value_t *value,\n\t\t     void *base, grecs_locus_t *locus)\n{\n\tvoid *target;\n\n\tif (!kwp)\n\t\treturn;\n\t\n\ttarget = target_ptr(kwp, (char *) base);\n\t\n\tif (kwp->callback) {\n#if GRECS_TREE_API\n\t\tstruct grecs_node node = { 0 };\n\t\tnode.locus = *locus;\n\t\tnode.v.value = value;\n\t\tnode.ident = (char*) kwp->ident;\n\t\tkwp->callback(grecs_callback_set_value,\n\t\t\t      &node,\n\t\t\t      target,\n\t\t\t      &kwp->callback_data);\n#else\n\t\tkwp->callback(grecs_callback_set_value,\n\t\t\t      locus,\n\t\t\t      target,\n\t\t\t      value,\n\t\t\t      &kwp->callback_data);\n#endif\n\t} else if (kwp->type == grecs_type_void || target == NULL)\n\t\treturn;\n\telse if (!value) {\n\t\tgrecs_error(locus, 0, \"%s has no value\", kwp->ident);\n\t\treturn;\n\t} else if (value->type == GRECS_TYPE_ARRAY) {\n\t\tgrecs_error(locus, 0,\n\t\t\t     _(\"too many arguments to `%s'; missing semicolon?\"),\n\t\t\t     kwp->ident);\n\t\treturn;\n\t} else if (value->type == GRECS_TYPE_LIST) {\n\t\tif (kwp->flags & GRECS_LIST) {\n\t\t\tstruct grecs_list_entry *ep;\n\t\t\tenum grecs_data_type type = kwp->type;\n\t\t\tint num = 1;\n\t\t\tstruct grecs_list *list;\n\t\t\tsize_t size;\n\t\t\t\n\t\t\tif (type >= grecs_prop_count\n\t\t\t    || (size = grecs_prop_tab[type].size) == 0) {\n\t\t\t\tgrecs_error(locus, 0,\n\t\t\t\t\t     _(\"INTERNAL ERROR at %s:%d: \"\n\t\t\t\t\t       \"unhandled data type %d\"),\n\t\t\t\t\t     __FILE__, __LINE__, type);\n\t\t\t\tabort();\n\t\t\t}\n\n\t\t\tlist = _grecs_simple_list_create(\n\t\t\t\t     type == grecs_type_string);\n\t\t\tlist->cmp = grecs_prop_tab[type].cmp;\n\t\t\t\t\n\t\t\tfor (ep = value->v.list->head; ep; ep = ep->next) {\n\t\t\t\tconst grecs_value_t *vp = ep->data;\n\n\t\t\t\tif (vp->type != GRECS_TYPE_STRING)\n\t\t\t\t\tgrecs_error(&vp->locus, 0,\n\t\t\t     _(\"%s: incompatible data type in list item #%d\"),\n\t\t\t\t\t\t     kwp->ident, num);\n\t\t\t\telse if (type == grecs_type_string)\n\t\t\t\t\tgrecs_list_append(list,\n\t\t\t\t\t\t\t  grecs_strdup(vp->v.string));\n\t\t\t\telse {\n\t\t\t\t\tvoid *ptr = grecs_malloc(size);\n\t\t\t\t\tif (grecs_string_convert(ptr,\n\t\t\t\t\t\t\t\t type,\n\t\t\t\t\t\t\t\t vp->v.string,\n\t\t\t\t\t\t\t\t &vp->locus)\n\t\t\t\t\t    == 0) \n\t\t\t\t\t\tgrecs_list_append(list, ptr);\n\t\t\t\t\telse\n\t\t\t\t\t\tgrecs_free(ptr);\n\t\t\t\t}\n\t\t\t}\n\t\t\t*(struct grecs_list**)target = list;\n\t\t} else {\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t     _(\"incompatible data type for `%s'\"),\n\t\t\t\t     kwp->ident);\n\t\t\treturn;\n\t\t}\n\t} else if (kwp->flags & GRECS_LIST) {\n\t\tstruct grecs_list *list;\n\t\tenum grecs_data_type type = kwp->type;\n\t\tsize_t size;\n\t\tvoid *ptr;\n      \n\t\tif (type >= grecs_prop_count\n\t\t    || (size = grecs_prop_tab[type].size) == 0) {\n\t\t\tgrecs_error(locus, 0,\n\t\t\t\t     _(\"INTERNAL ERROR at %s:%d: unhandled data type %d\"),\n\t\t\t\t     __FILE__, __LINE__, type);\n\t\t\tabort();\n\t\t}\n\t\t\n\t\tlist = _grecs_simple_list_create(1);\n\t\tlist->cmp = grecs_prop_tab[type].cmp;\n\t\tif (type == grecs_type_string)\n\t\t\tgrecs_list_append(list,\n\t\t\t\t\t  grecs_strdup(value->v.string));\n\t\telse {\n\t\t\tptr = grecs_malloc(size);\n\t\t\tif (grecs_string_convert(ptr, type,\n\t\t\t\t\t\t value->v.string,\n\t\t\t\t\t\t &value->locus)) {\n\t\t\t\tgrecs_free(ptr);\n\t\t\t\tgrecs_list_free(list);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tgrecs_list_append(list, ptr);\n\t\t}\n\t\t*(struct grecs_list**)target = list;\n\t} else {\n\t\tif (kwp->type == grecs_type_string\n\t\t    && !(kwp->flags & GRECS_CONST))\n\t\t\tfree(*(char**)target);\n\t\tgrecs_string_convert(target, kwp->type,\n\t\t\t\t     value->v.string,\n\t\t\t\t     &value->locus);\n\t}\n\tkwp->flags &= ~GRECS_CONST;\n}",
      "lines": 129,
      "depth": 23,
      "decorators": [
        "void"
      ]
    },
    "stmt_begin": {
      "start_point": [
        846,
        0
      ],
      "end_point": [
        875,
        1
      ],
      "content": "static void\nstmt_begin(struct nodeproc_closure *clos,\n\t   struct grecs_keyword *kwp, struct grecs_node *node)\n{\n\tvoid *target;\n\t\n\tgrecs_list_push(clos->sections, clos->cursect);\n\tif (kwp) {\n\t\ttarget = target_ptr(kwp, CURRENT_BASE(clos));\n\t\tclos->cursect = kwp;\n\t\tif (kwp->callback) {\n#if GRECS_TREE_API\t\t\t\n\t\t\tif (kwp->callback(grecs_callback_section_begin,\n\t\t\t\t\t  node,\n\t\t\t\t\t  target,\n\t\t\t\t\t  &kwp->callback_data))\n#else\n\t\t\tif (kwp->callback(grecs_callback_section_begin,\n\t\t\t\t\t  &node->locus,\n\t\t\t\t\t  target,\n\t\t\t\t\t  node->v.value,\n\t\t\t\t\t  &kwp->callback_data))\n#endif\n\t\t\t\tclos->cursect = &fake;\n\t\t} else\n\t\t\tkwp->callback_data = target;\n\t} else\n\t\t/* install an \"ignore-all\" section */\n\t\tclos->cursect = kwp;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "stmt_end": {
      "start_point": [
        877,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "static void\nstmt_end(struct nodeproc_closure *clos, struct grecs_node *node)\n{\n\tgrecs_callback_fn callback = NULL;\n\tvoid *dataptr = NULL;\n\tstruct grecs_keyword *kwp = clos->cursect;\n\t\n\tif (clos->cursect && clos->cursect->callback) {\n\t\tcallback = clos->cursect->callback;\n\t\tdataptr = &clos->cursect->callback_data;\n\t}\n\n\tclos->cursect = (struct grecs_keyword *)grecs_list_pop(clos->sections);\n\tif (!clos->cursect)\n\t\tabort();\n\tif (callback)\n#if GRECS_TREE_API\t\t\t\n\t\tcallback(grecs_callback_section_end,\n\t\t\t node,\n\t\t\t kwp ? target_ptr(kwp, CURRENT_BASE(clos)) : NULL,\n\t\t\t dataptr);\n#else\t\t\n\t\tcallback(grecs_callback_section_end,\n\t\t\t &node->locus,\n\t\t\t kwp ? target_ptr(kwp, CURRENT_BASE(clos)) : NULL,\n\t\t\t NULL,\n\t\t\t dataptr);\n#endif\n\tif (kwp)\n\t\tkwp->callback_data = NULL;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nodeproc": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        940,
        1
      ],
      "content": "static enum grecs_tree_recurse_res\nnodeproc(enum grecs_tree_recurse_op op, struct grecs_node *node, void *data)\n{\n\tstruct nodeproc_closure *clos = data;\n\tstruct grecs_keyword *kwp;\n\t\n\tswitch (op) {\n\tcase grecs_tree_recurse_set:\n\t\tkwp = find_keyword(clos->cursect, node->ident);\n\t\tif (!kwp) {\n\t\t\tgrecs_error(&node->idloc, 0, _(\"Unknown keyword\"));\n\t\t\treturn grecs_tree_recurse_skip;\n\t\t}\n\t\tgrecs_process_ident(kwp, node->v.value, CURRENT_BASE(clos),\n\t\t\t\t    &node->idloc);\n\t\tbreak;\n\t\t\n\tcase grecs_tree_recurse_pre:\n\t\tkwp = find_keyword(clos->cursect, node->ident);\n\t\tif (!kwp) {\n\t\t\tgrecs_error(&node->locus, 0, _(\"Unknown keyword\"));\n\t\t\treturn grecs_tree_recurse_skip;\n\t\t}\n\t\tstmt_begin(clos, kwp, node);\n\t\tbreak;\n\t\t\n\tcase grecs_tree_recurse_post:\n\t\tstmt_end(clos, node);\n\t\tbreak;\n\t}\n\treturn grecs_tree_recurse_ok;\n}",
      "lines": 32,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_tree_process": {
      "start_point": [
        942,
        0
      ],
      "end_point": [
        958,
        1
      ],
      "content": "int\ngrecs_tree_process(struct grecs_node *node, struct grecs_keyword *kwd)\n{\n\tint rc;\n\tstruct nodeproc_closure clos;\n\tstruct grecs_keyword config_keywords;\n\n\tmemset(&config_keywords, 0, sizeof(config_keywords));\n\tconfig_keywords.kwd = kwd;\n\tclos.cursect = &config_keywords;\n\tclos.sections = grecs_list_create();\n\tif (node->type == grecs_node_root)\n\t\tnode = node->down;\n\trc = grecs_tree_recurse(node, nodeproc, &clos);\n\tgrecs_list_free(clos.sections);\n\treturn rc;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_node_eq": {
      "start_point": [
        961,
        0
      ],
      "end_point": [
        974,
        1
      ],
      "content": "int\ngrecs_node_eq(struct grecs_node *a, struct grecs_node *b)\n{\n\tif (a->type != b->type)\n\t\treturn 1;\n\tif (a->type == grecs_node_root)\n\t\treturn 0;\n\tif (strcmp(a->ident, b->ident))\n\t\treturn 1;\n\tif (a->type == grecs_node_block &&\n\t    !grecs_value_eq(a->v.value, b->v.value))\n\t\treturn 1;\n\treturn 0;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "free_value_entry": {
      "start_point": [
        976,
        0
      ],
      "end_point": [
        981,
        1
      ],
      "content": "static void\nfree_value_entry(void *ptr)\n{\n\tstruct grecs_value *v = ptr;\n\tgrecs_value_free(v);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_value_list_create": {
      "start_point": [
        983,
        0
      ],
      "end_point": [
        989,
        1
      ],
      "content": "struct grecs_list *\ngrecs_value_list_create()\n{\n\tstruct grecs_list *list = grecs_list_create();\n\tlist->free_entry = free_value_entry;\n\treturn list;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct grecs_list",
        "struct",
        "grecs_list",
        "*\ngrecs_value_list_create()",
        "*"
      ]
    },
    "value_to_list": {
      "start_point": [
        991,
        0
      ],
      "end_point": [
        1011,
        1
      ],
      "content": "static void\nvalue_to_list(struct grecs_value *val)\n{\n\tstruct grecs_list *list;\n\tint i;\n\t\n\tif (val->type == GRECS_TYPE_LIST)\n\t\treturn;\n\tlist = grecs_value_list_create();\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tgrecs_list_append(list, grecs_value_ptr_from_static(val));\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tfor (i = 0; i < val->v.arg.c; i++)\n\t\t\tgrecs_list_append(list, val->v.arg.v[i]);\n\t}\n\tval->type = GRECS_TYPE_LIST;\n\tval->v.list = list;\n}",
      "lines": 21,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "value_to_array": {
      "start_point": [
        1013,
        0
      ],
      "end_point": [
        1026,
        1
      ],
      "content": "static void\nvalue_to_array(struct grecs_value *val)\n{\n\tif (val->type == GRECS_TYPE_ARRAY)\n\t\treturn;\n\telse {\n\t\tstruct grecs_value **vp;\n\t\tvp = grecs_calloc(1, sizeof(*vp));\n\t\tvp[0] = grecs_value_ptr_from_static(val);\n\t\tval->type = GRECS_TYPE_ARRAY;\n\t\tval->v.arg.c = 1;\n\t\tval->v.arg.v = vp;\n\t}\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "array_add": {
      "start_point": [
        1028,
        0
      ],
      "end_point": [
        1041,
        1
      ],
      "content": "static void\narray_add(struct grecs_value *vx, struct grecs_value *vy)\n{\n\tsize_t i;\n\t\n\tvx->v.arg.v = grecs_realloc(vx->v.arg.v,\n\t\t\t\t    (vx->v.arg.c + vy->v.arg.c) *\n\t\t\t\t       sizeof(vx->v.arg.v[0]));\n\tfor (i = 0; i < vy->v.arg.c; i++)\n\t\tvx->v.arg.v[i + vy->v.arg.c] = vy->v.arg.v[i];\n\tgrecs_free(vy->v.arg.v);\n\tvy->v.arg.v = NULL;\n\tvy->v.arg.c = 0;\n}",
      "lines": 14,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_aggregate_stmt": {
      "start_point": [
        1043,
        0
      ],
      "end_point": [
        1062,
        1
      ],
      "content": "static void\nnode_aggregate_stmt(struct grecs_node *dst, struct grecs_node *src, int islist)\n{\n\tif (islist) {\n\t\tstruct grecs_list *t;\n\t\t/* Coerce both arguments to lists */\n\t\tvalue_to_list(dst->v.value);\n\t\tvalue_to_list(src->v.value);\n\t\t/* Aggregate two lists in order */\n\t\tgrecs_list_add(src->v.value->v.list, dst->v.value->v.list);\n\t\t/* Swap them */\n\t\tt = dst->v.value->v.list;\n\t\tdst->v.value->v.list = src->v.value->v.list;\n\t\tsrc->v.value->v.list = t;\n\t} else {\n\t\tvalue_to_array(dst->v.value);\n\t\tvalue_to_array(src->v.value);\n\t\tarray_add(dst->v.value, src->v.value);\n\t}\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_merge_stmt": {
      "start_point": [
        1064,
        0
      ],
      "end_point": [
        1077,
        1
      ],
      "content": "static void\nnode_merge_stmt(struct grecs_node *to_node, struct grecs_node *from_node,\n\t\tstruct grecs_keyword *kwp, int flags)\n{\n\tif (kwp &&\n\t    (flags & GRECS_AGGR) ^ (kwp->flags & GRECS_AGGR) &&\n\t    ((kwp->flags & GRECS_LIST) || kwp->callback))\n\t\tnode_aggregate_stmt(to_node, from_node,\n\t\t\t\t    kwp->flags & GRECS_LIST);\n\telse {\n\t\tgrecs_value_free(from_node->v.value);\n\t\tfrom_node->v.value = NULL;\n\t}\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_merge_block": {
      "start_point": [
        1079,
        0
      ],
      "end_point": [
        1095,
        1
      ],
      "content": "static void\nnode_merge_block(struct grecs_node *to_node, struct grecs_node *from_node,\n\t\t struct grecs_keyword *kwp)\n{\n\tstruct grecs_node *sp;\n\n\tif (!from_node->down)\n\t\treturn;\n\tfor (sp = from_node->down; ; sp = sp->next) {\n\t\tsp->up = to_node;\n\t\tif (!sp->next)\n\t\t\tbreak;\n\t}\n\tsp->next = to_node->down;\n\tto_node->down = from_node->down;\n\tfrom_node->down = NULL;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_reduce": {
      "start_point": [
        1097,
        0
      ],
      "end_point": [
        1121,
        1
      ],
      "content": "static int\nnode_reduce(struct grecs_node *node, struct grecs_keyword *kwp, int flags)\n{\n\tstruct grecs_node *p;\n\n\tfor (p = node->next; p; p = p->next)\n\t\tif (grecs_node_eq(p, node) == 0)\n\t\t\tbreak;\n\tif (p) {\n\t\tswitch (node->type) {\n\t\tcase grecs_node_root:\n\t\t\treturn 0;\n\t\tcase grecs_node_stmt:\n\t\t\tnode_merge_stmt(p, node, kwp, flags);\n\t\t\tbreak;\n\t\tcase grecs_node_block:\n\t\t\tnode_merge_block(p, node, kwp);\n\t\t\tbreak;\n\t\t}\n\t\tgrecs_node_unlink(node);\n\t\tgrecs_node_free(node);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 25,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "reduceproc": {
      "start_point": [
        1123,
        0
      ],
      "end_point": [
        1155,
        1
      ],
      "content": "static enum grecs_tree_recurse_res\nreduceproc(enum grecs_tree_recurse_op op, struct grecs_node *node, void *data)\n{\n\tstruct nodeproc_closure *clos = data;\n\t\n\tif (op == grecs_tree_recurse_post) {\n\t\tif (clos->sections)\n\t\t\tclos->cursect = (struct grecs_keyword *)\n\t\t\t\t           grecs_list_pop(clos->sections);\n\t} else {\n\t\tstruct grecs_keyword *kwp = NULL;\n\t\tif (clos->cursect) {\n\t\t\tkwp = find_keyword(clos->cursect, node->ident);\n\t\t\tif (!kwp) {\n\t\t\t\tgrecs_error(&node->locus, 0,\n\t\t\t\t\t    _(\"%s: unknown keyword\"),\n\t\t\t\t\t    node->ident);\n\t\t\t\treturn grecs_tree_recurse_skip;\n\t\t\t}\n\t\t\tif (kwp->flags & GRECS_INAC)\n\t\t\t\treturn grecs_tree_recurse_skip;\n\t\t\tif (!(kwp->flags & GRECS_MULT) &&\n\t\t\t    node_reduce(node, kwp, clos->flags))\n\t\t\t\treturn grecs_tree_recurse_skip;\n\t\t\tif (op == grecs_tree_recurse_pre) {\n\t\t\t\tgrecs_list_push(clos->sections, clos->cursect);\n\t\t\t\tclos->cursect = kwp;\n\t\t\t} \n\t\t} else if (node_reduce(node, kwp, clos->flags))\n\t\t\treturn grecs_tree_recurse_skip;\n\t}\n\treturn grecs_tree_recurse_ok;\n}",
      "lines": 33,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "enum grecs_tree_recurse_res",
        "enum",
        "grecs_tree_recurse_res"
      ]
    },
    "grecs_tree_reduce": {
      "start_point": [
        1157,
        0
      ],
      "end_point": [
        1178,
        1
      ],
      "content": "int\ngrecs_tree_reduce(struct grecs_node *node, struct grecs_keyword *kwd,\n\t\t  int flags)\n{\n\tint rc;\n\tstruct nodeproc_closure clos;\n\tstruct grecs_keyword config_keywords;\n\n\tmemset(&config_keywords, 0, sizeof(config_keywords));\n\tconfig_keywords.kwd = kwd;\n\tif (kwd) {\n\t\tclos.cursect = &config_keywords;\n\t\tclos.sections = grecs_list_create();\n\t} else {\n\t\tclos.cursect = NULL;\n\t\tclos.sections = NULL;\n\t}\n\tclos.flags = flags;\n\trc = grecs_tree_recurse(node->down, reduceproc, &clos);\n\tgrecs_list_free(clos.sections);\n\treturn rc;\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "grecs_tree_first_node": {
      "start_point": [
        1181,
        0
      ],
      "end_point": [
        1187,
        1
      ],
      "content": "struct grecs_node *\ngrecs_tree_first_node(struct grecs_node *tree)\n{\n\tif (tree->type == grecs_node_root)\n\t\treturn tree->down;\n\treturn tree;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_tree_first_node(struct grecs_node *tree)",
        "*"
      ]
    },
    "grecs_next_node": {
      "start_point": [
        1189,
        0
      ],
      "end_point": [
        1202,
        1
      ],
      "content": "struct grecs_node *\ngrecs_next_node(struct grecs_node *node)\n{\n\tif (!node)\n\t\treturn NULL;\n\tif (node->down)\n\t\treturn node->down;\n\twhile (!node->next) {\n\t\tnode = node->up;\n\t\tif (!node || node->type == grecs_node_root)\n\t\t\treturn NULL;\n\t}\n\treturn node->next;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "struct grecs_node",
        "struct",
        "grecs_node",
        "*\ngrecs_next_node(struct grecs_node *node)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/txtacc.c": {
    "grecs_txtacc_alloc_entry": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "static struct grecs_txtacc_entry *\ngrecs_txtacc_alloc_entry(struct grecs_list *list, size_t size)\n{\n\tstruct grecs_txtacc_entry *p = grecs_malloc(sizeof (*p));\n\tp->buf = grecs_malloc(size);\n\tp->size = size;\n\tp->len = 0;\n\tgrecs_list_append(list, p);\n\treturn p;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct grecs_txtacc_entry",
        "struct",
        "grecs_txtacc_entry",
        "*\ngrecs_txtacc_alloc_entry(struct grecs_list *list, size_t size)",
        "*"
      ]
    },
    "grecs_txtacc_cur_entry": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static struct grecs_txtacc_entry *\ngrecs_txtacc_cur_entry(struct grecs_txtacc *acc)\n{\n\tstruct grecs_txtacc_entry *ent;\n\n\tif (grecs_list_size(acc->cur) == 0)\n\t\treturn grecs_txtacc_alloc_entry(acc->cur,\n\t\t\t\t\t\tGRECS_TXTACC_BUFSIZE);\n\tent = acc->cur->tail->data;\n\tif (grecs_txtacc_entry_freesize(ent) == 0)\n\t\tent = grecs_txtacc_alloc_entry(acc->cur,\n\t\t\t\t\t       GRECS_TXTACC_BUFSIZE);\n\treturn ent;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "struct grecs_txtacc_entry",
        "struct",
        "grecs_txtacc_entry",
        "*\ngrecs_txtacc_cur_entry(struct grecs_txtacc *acc)",
        "*"
      ]
    },
    "grecs_txtacc_entry_append": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\ngrecs_txtacc_entry_append(struct grecs_txtacc_entry *ent,\n\t\t\t  const char *p, size_t size)\n{\n\tmemcpy(ent->buf + ent->len, p, size);\n\tent->len += size;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_txtacc_entry_tailor": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static void\ngrecs_txtacc_entry_tailor(struct grecs_txtacc_entry *ent)\n{\n\tif (ent->size > ent->len) {\n\t\tchar *p = grecs_realloc(ent->buf, ent->len);\n\t\tif (!p)\n\t\t\treturn;\n\t\tent->buf = p;\n\t\tent->size = ent->len;\n\t}\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_txtacc_entry_free": {
      "start_point": [
        84,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "static void\ngrecs_txtacc_entry_free(void *p)\n{\n\tif (p) {\n\t\tstruct grecs_txtacc_entry *ent = p;\n\t\tfree(ent->buf);\n\t\tfree(ent);\n\t}\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "grecs_txtacc_create": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "struct grecs_txtacc *\ngrecs_txtacc_create()\n{\n\tstruct grecs_txtacc *acc = grecs_malloc(sizeof (*acc));\n\tacc->cur = grecs_list_create();\n\tacc->cur->free_entry = grecs_txtacc_entry_free;\n\tacc->mem = grecs_list_create();\n\tacc->mem->free_entry = grecs_txtacc_entry_free;\n\treturn acc;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "struct grecs_txtacc",
        "struct",
        "grecs_txtacc",
        "*\ngrecs_txtacc_create()",
        "*"
      ]
    },
    "grecs_txtacc_free": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\ngrecs_txtacc_free(struct grecs_txtacc *acc)\n{\n\tif (acc) {\n\t\tgrecs_list_free(acc->cur);\n\t\tgrecs_list_free(acc->mem);\n\t\tfree(acc);\n\t}\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_txtacc_grow": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\ngrecs_txtacc_grow(struct grecs_txtacc *acc, const char *buf, size_t size)\n{\n\twhile (size) {\n\t\tstruct grecs_txtacc_entry *ent = grecs_txtacc_cur_entry(acc);\n\t\tsize_t rest = grecs_txtacc_entry_freesize(ent);\n\t\tif (rest > size)\n\t\t\trest = size;\n\t\tgrecs_txtacc_entry_append(ent, buf, rest);\n\t\tbuf += rest;\n\t\tsize -= rest;\n\t}\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "grecs_txtacc_grow_string": {
      "start_point": [
        129,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ngrecs_txtacc_grow_string(struct grecs_txtacc *acc, const char *buf)\n{\n\tgrecs_txtacc_grow(acc, buf, strlen(buf));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "grecs_txtacc_grow_string_escape": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\ngrecs_txtacc_grow_string_escape(struct grecs_txtacc *acc, const char *buf)\n{\n\tfor (; *buf; buf++) {\n\t\tif (strchr(\" \\t\\n\\\"\\'\\\\\", *buf))\n\t\t\tgrecs_txtacc_grow_char(acc, '\\\\');\n\t\tgrecs_txtacc_grow_char(acc, *buf);\n\t}\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_txtacc_finish": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "char *\ngrecs_txtacc_finish(struct grecs_txtacc *acc, int steal)\n{\n\tstruct grecs_list_entry *ep;\n\tstruct grecs_txtacc_entry *txtent;\n\tsize_t size;\n\tchar *p;\n\t\n\tswitch (grecs_list_size(acc->cur)) {\n\tcase 0:\n\t\treturn NULL;\n\n\tcase 1:\n\t\ttxtent = acc->cur->head->data;\n\t\tacc->cur->head->data = NULL;\n\t\tgrecs_txtacc_entry_tailor(txtent);\n\t\tgrecs_list_append(acc->mem, txtent);\n\t\tbreak;\n\n\tdefault:\n\t\tsize = 0;\n\t\tfor (ep = acc->cur->head; ep; ep = ep->next) {\n\t\t\ttxtent = ep->data;\n\t\t\tsize += txtent->len;\n\t\t}\n      \n\t\ttxtent = grecs_txtacc_alloc_entry(acc->mem, size);\n\t\tfor (ep = acc->cur->head; ep; ep = ep->next) {\n\t\t\tstruct grecs_txtacc_entry *tp = ep->data;\n\t\t\tgrecs_txtacc_entry_append(txtent, tp->buf, tp->len);\n\t\t}\n\t}\n  \n\tgrecs_list_clear(acc->cur);\n\tp = txtent->buf;\n\tif (steal) {\n\t\tgrecs_list_remove_tail(acc->mem);\n\t\tfree(txtent);\n\t}\n\treturn p;\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "char",
        "*\ngrecs_txtacc_finish(struct grecs_txtacc *acc, int steal)",
        "*"
      ]
    },
    "grecs_txtacc_free_string": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "void\ngrecs_txtacc_free_string(struct grecs_txtacc *acc, char *str)\n{\n\tstruct grecs_list_entry *ep;\n\tfor (ep = acc->mem->head; ep; ep = ep->next) {\n\t\tstruct grecs_txtacc_entry *tp = ep->data;\n\t\tif (tp->buf == str) {\n\t\t\tgrecs_list_remove_entry(acc->mem, ep);\n\t\t\tgrecs_txtacc_entry_free(tp);\n\t\t\treturn;\n\t\t}\n\t}\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "grecs_txtacc_clear": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\ngrecs_txtacc_clear(struct grecs_txtacc *acc)\n{\n\tgrecs_list_clear(acc->cur);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/version.c": {
    "grecs_version_split": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "struct grecs_version_info *\ngrecs_version_split(const char *vstr)\n{\n\tchar *p;\n\tsize_t len;\n\tstruct grecs_version_info *pv = grecs_zalloc(sizeof(*pv));\n\t\n\tpv->buffer = grecs_strdup(vstr);\n\tlen = strcspn(pv->buffer, \" \\t\");\n\tif (pv->buffer[len]) {\n\t\tpv->package = pv->buffer;\n\t\tpv->buffer[len++] = 0;\n\t\tfor (; pv->buffer[len] && isspace(pv->buffer[len]); len++)\n\t\t\t;\n\t} else {\n\t\tpv->package = NULL;\n\t\tlen = 0;\n\t}\n\tif (!pv->buffer[len]) {\n\t\tfree(pv->buffer);\n\t\tfree(pv);\n\t\treturn NULL;\n\t}\n\tpv->version = pv->buffer + len;\n\tpv->major = strtoul(pv->version, &p, 10);\n\tif (*p && *p == '.') {\n\t\tpv->minor = strtoul(p + 1, &p, 10);\n\t\tif (*p && *p == '.') {\n\t\t\tchar *q;\n\t\t\t\n\t\t\tpv->patch = strtoul(p + 1, &q, 10);\n\t\t\tif (q == p + 1)\n\t\t\t\tpv->patch = 0;\n\t\t\telse\n\t\t\t\tp = q;\n\t\t}\n\t}\n\tpv->suffix = p;\n\treturn pv;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "struct grecs_version_info",
        "struct",
        "grecs_version_info",
        "*\ngrecs_version_split(const char *vstr)",
        "*"
      ]
    },
    "grecs_version_info_free": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ngrecs_version_info_free(struct grecs_version_info *pv)\n{\n\tif (pv) {\n\t\tif (pv->buffer)\n\t\t\tgrecs_free(pv->buffer);\n\t\tfree(pv);\n\t}\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "grecs_version": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "struct grecs_version_info *\ngrecs_version(void)\n{\n\tstruct grecs_version_info *pv = grecs_zalloc(sizeof(*pv));\n\tsize_t size = 0;\n\t\n\tpv->package = PACKAGE_NAME;\n#ifdef GRECS_VERSION_PATCHLEVEL\n# ifdef GRECS_VERSION_SUFFIX\n\tgrecs_asprintf(&pv->buffer, &size,\n\t\t       \"%d.%d.%d%s\",\n\t\t       GRECS_VERSION_MAJOR, GRECS_VERSION_MINOR,\n\t\t       GRECS_VERSION_PATCHLEVEL, GRECS_VERSION_SUFFIX);\n# else\n\tgrecs_asprintf(&pv->buffer, &size,\n\t\t       \"%d.%d.%d\",\n\t\t       GRECS_VERSION_MAJOR, GRECS_VERSION_MINOR,\n\t\t       GRECS_VERSION_PATCHLEVEL);\n# endif\t\n#else\n# ifdef GRECS_VERSION_SUFFIX\n\tgrecs_asprintf(&pv->buffer, &size,\n\t\t       \"%d.%d%s\",\n\t\t       GRECS_VERSION_MAJOR, GRECS_VERSION_MINOR,\n\t\t       GRECS_VERSION_SUFFIX);\n# else\n\tgrecs_asprintf(&pv->buffer, &size,\n\t\t       \"%d.%d\",\n\t\t       GRECS_VERSION_MAJOR, GRECS_VERSION_MINOR);\n# endif\n#endif\n\tpv->version = pv->buffer;\n\tpv->major = GRECS_VERSION_MAJOR;\n\tpv->minor = GRECS_VERSION_MINOR;\n#ifdef GRECS_VERSION_PATCHLEVEL\n\tpv->patch = GRECS_VERSION_PATCHLEVEL;\n#endif\n#ifdef GRECS_VERSION_SUFFIX\n\tpv->suffix = GRECS_VERSION_SUFFIX;\n#endif\n\tpv->id = GRECS_GIT_ID;\n\treturn pv;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "struct grecs_version_info",
        "struct",
        "grecs_version_info",
        "*\ngrecs_version(void)",
        "*"
      ]
    },
    "grecs_version_info_cmp": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\ngrecs_version_info_cmp(struct grecs_version_info *vx,\n\t\t       struct grecs_version_info *vy,\n\t\t       int *pres)\n{\n\tif (vx->package && vy->package && strcmp(vx->package, vy->package))\n\t\treturn 1;\n\telse if (vx->major > vy->major)\n\t\t*pres = 1;\n\telse if (vx->major < vy->major)\n\t\t*pres = -1;\n\telse if (vx->minor > vy->minor)\n\t\t*pres = 1;\n\telse if (vx->minor < vy->minor)\n\t\t*pres = -1;\n\telse if (vx->patch > vy->patch)\n\t\t*pres = 1;\n\telse if (vx->patch < vy->patch)\n\t\t*pres = -1;\n\telse if (vx->suffix && vy->suffix)\n\t\t*pres = strcmp(vx->suffix, vy->suffix);\n\telse\n\t\t*pres = 0;\n\treturn 0;\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "grecs_version_cmp": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "int\ngrecs_version_cmp(const char *vstr1, const char *vstr2, int *pres)\n{\n\tstruct grecs_version_info *v1, *v2;\n\tint rc;\n\t\n\tif (!vstr1 || !vstr2)\n\t\treturn -1;\n\tv1 = grecs_version_split(vstr1);\n\tif (!v1)\n\t\treturn -1;\n\tv2 = grecs_version_split(vstr2);\n\tif (!v2) {\n\t\tgrecs_version_info_free(v1);\n\t\treturn -1;\n\t}\n\trc = grecs_version_info_cmp(v1, v2, pres);\n\tgrecs_version_info_free(v1);\n\tgrecs_version_info_free(v2);\n\treturn rc;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "grecs_version_ok": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "int\ngrecs_version_ok(const char *vstr)\n{\n\tstruct grecs_version_info *vmy, *vreq;\n\tint rc, res;\n\t\n\tif (!vstr)\n\t\treturn -1;\n\tvreq = grecs_version_split(vstr);\n\tif (!vreq)\n\t\treturn -1;\n\tvmy = grecs_version();\n\tif (vreq->suffix && !vmy->suffix)\n\t\tvmy->suffix = \"\";\n\trc = grecs_version_info_cmp(vmy, vreq, &res);\n\tgrecs_version_info_free(vmy);\n\tgrecs_version_info_free(vreq);\n\treturn rc == 0 && res >= 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/src/wordsplit.c": {
    "_wsplt_alloc_die": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static void\n_wsplt_alloc_die (struct wordsplit *wsp)\n{\n  wsp->ws_error (_(\"memory exhausted\"));\n  abort ();\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_wsplt_error": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\n_wsplt_error (const char *fmt, ...)\n{\n  va_list ap;\n\n  va_start (ap, fmt);\n  vfprintf (stderr, fmt, ap);\n  va_end (ap);\n  fputc ('\\n', stderr);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_wsplt_seterr": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static int\n_wsplt_seterr (struct wordsplit *wsp, int ec)\n{\n  wsp->ws_errno = ec;\n  if (wsp->ws_flags & WRDSF_SHOWERR)\n    wordsplit_perror (wsp);\n  return ec;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_wsplt_nomem": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static int\n_wsplt_nomem (struct wordsplit *wsp)\n{\n  errno = ENOMEM;\n  wsp->ws_errno = WRDSE_NOSPACE;\n  if (wsp->ws_flags & WRDSF_ENOMEMABRT)\n    wsp->ws_alloc_die (wsp);\n  if (wsp->ws_flags & WRDSF_SHOWERR)\n    wordsplit_perror (wsp);\n  if (!(wsp->ws_flags & WRDSF_REUSE))\n    wordsplit_free (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_wsplt_subsplit": {
      "start_point": [
        106,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static int\n_wsplt_subsplit (struct wordsplit *wsp, struct wordsplit *wss,\n\t\t char const *str, int len,\n\t\t int flags)\n{\n  wss->ws_delim = wsp->ws_delim;\n  wss->ws_debug = wsp->ws_debug;\n  wss->ws_error = wsp->ws_error;\n  wss->ws_alloc_die = wsp->ws_alloc_die;\n\n  if (!(flags & WRDSF_NOVAR))\n    {\n      wss->ws_env = wsp->ws_env;\n      wss->ws_getvar = wsp->ws_getvar;\n      flags |= wsp->ws_flags & (WRDSF_ENV | WRDSF_ENV_KV | WRDSF_GETVAR);\n    }\n  if (!(flags & WRDSF_NOCMD))\n    {\n      wss->ws_command = wsp->ws_command;\n    }\n\n  if ((flags & (WRDSF_NOVAR|WRDSF_NOCMD)) != (WRDSF_NOVAR|WRDSF_NOCMD))\n    {\n      wss->ws_closure = wsp->ws_closure;\n      flags |= wsp->ws_flags & WRDSF_CLOSURE;\n    }\n\n  wss->ws_options = wsp->ws_options;\n  \n  flags |= WRDSF_DELIM\n         | WRDSF_ALLOC_DIE\n         | WRDSF_ERROR\n         | WRDSF_DEBUG\n         | (wsp->ws_flags & (WRDSF_SHOWDBG | WRDSF_SHOWERR | WRDSF_OPTIONS));\n\t    \n  return wordsplit_run (str, len, wss, flags, wsp->ws_lvl + 1);\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_wsplt_seterr_sub": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\n_wsplt_seterr_sub (struct wordsplit *wsp, struct wordsplit *wss)\n{\n  if (wsp->ws_errno == WRDSE_USERERR)\n    free (wsp->ws_usererr);\n  wsp->ws_errno = wss->ws_errno;\n  if (wss->ws_errno == WRDSE_USERERR)\n    {\n      wsp->ws_usererr = wss->ws_usererr;\n      wss->ws_errno = WRDSE_EOF;\n      wss->ws_usererr = NULL;\n    }\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_init0": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static void\nwordsplit_init0 (struct wordsplit *wsp)\n{\n  if (wsp->ws_flags & WRDSF_REUSE)\n    {\n      if (!(wsp->ws_flags & WRDSF_APPEND))\n\twordsplit_free_words (wsp);\n      wordsplit_clearerr (wsp);\n    }\n  else\n    {\n      wsp->ws_wordv = NULL;\n      wsp->ws_wordc = 0;\n      wsp->ws_wordn = 0;\n    }\n\n  wsp->ws_errno = 0;\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_init": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "static int\nwordsplit_init (struct wordsplit *wsp, const char *input, size_t len,\n\t\tint flags)\n{\n  wsp->ws_flags = flags;\n\n  if (!(wsp->ws_flags & WRDSF_ALLOC_DIE))\n    wsp->ws_alloc_die = _wsplt_alloc_die;\n  if (!(wsp->ws_flags & WRDSF_ERROR))\n    wsp->ws_error = _wsplt_error;\n\n  if (!(wsp->ws_flags & WRDSF_NOVAR))\n    {\n      /* These will be initialized on first variable assignment */\n      wsp->ws_envidx = wsp->ws_envsiz = 0;\n      wsp->ws_envbuf = NULL;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_NOCMD))\n    {\n      if (!wsp->ws_command)\n\t{\n\t  _wsplt_seterr (wsp, WRDSE_USAGE);\n\t  errno = EINVAL;\n\t  return wsp->ws_errno;\n\t}\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      if (!(wsp->ws_flags & WRDSF_DEBUG))\n\t{\n\t  if (wsp->ws_flags & WRDSF_ERROR)\n\t    wsp->ws_debug = wsp->ws_error;\n\t  else if (wsp->ws_flags & WRDSF_SHOWERR)\n\t    wsp->ws_debug = _wsplt_error;\n\t  else\n\t    wsp->ws_flags &= ~WRDSF_SHOWDBG;\n\t}\n    }\n\n  wsp->ws_input = input;\n  wsp->ws_len = len;\n\n  if (!(wsp->ws_flags & WRDSF_DOOFFS))\n    wsp->ws_offs = 0;\n\n  if (!(wsp->ws_flags & WRDSF_DELIM))\n    wsp->ws_delim = \" \\t\\n\";\n\n  if (!(wsp->ws_flags & WRDSF_COMMENT))\n    wsp->ws_comment = NULL;\n\n  if (!(wsp->ws_flags & WRDSF_CLOSURE))\n    wsp->ws_closure = NULL;\n\n  if (!(wsp->ws_flags & WRDSF_OPTIONS))\n    wsp->ws_options = 0;\n\n  if (wsp->ws_flags & WRDSF_ESCAPE)\n    {\n      if (!wsp->ws_escape[WRDSX_WORD])\n\twsp->ws_escape[WRDSX_WORD] = \"\";\n      if (!wsp->ws_escape[WRDSX_QUOTE])\n\twsp->ws_escape[WRDSX_QUOTE] = \"\";\n    }\n  else\n    {\n      if (wsp->ws_flags & WRDSF_CESCAPES)\n\t{\n\t  wsp->ws_escape[WRDSX_WORD] = wordsplit_c_escape_tab;\n\t  wsp->ws_escape[WRDSX_QUOTE] = wordsplit_c_escape_tab;\n\t  wsp->ws_options |= WRDSO_OESC_QUOTE | WRDSO_OESC_WORD       \n\t                     | WRDSO_XESC_QUOTE | WRDSO_XESC_WORD;\n\t}\n      else\n\t{\n\t  wsp->ws_escape[WRDSX_WORD] = \"\";\n\t  wsp->ws_escape[WRDSX_QUOTE] = \"\\\\\\\\\\\"\\\"\";\n\t  wsp->ws_options |= WRDSO_BSKEEP_QUOTE;\n\t}\n    }\n  \n  wsp->ws_endp = 0;\n\n  wordsplit_init0 (wsp);\n\n  return 0;\n}",
      "lines": 89,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "alloc_space": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        299,
        1
      ],
      "content": "static int\nalloc_space (struct wordsplit *wsp, size_t count)\n{\n  size_t offs = (wsp->ws_flags & WRDSF_DOOFFS) ? wsp->ws_offs : 0;\n  char **ptr;\n  size_t newalloc;\n\n  if (wsp->ws_wordv == NULL)\n    {\n      newalloc = offs + count > ALLOC_INIT ? count : ALLOC_INIT;\n      ptr = calloc (newalloc, sizeof (ptr[0]));\n    }\n  else if (wsp->ws_wordn < offs + wsp->ws_wordc + count)\n    {\n      newalloc = offs + wsp->ws_wordc +\n\t(count > ALLOC_INCR ? count : ALLOC_INCR);\n      ptr = realloc (wsp->ws_wordv, newalloc * sizeof (ptr[0]));\n    }\n  else\n    return 0;\n\n  if (ptr)\n    {\n      wsp->ws_wordn = newalloc;\n      wsp->ws_wordv = ptr;\n    }\n  else\n    return _wsplt_nomem (wsp);\n  return 0;\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "the": {
      "start_point": [
        313,
        7
      ],
      "end_point": [
        329,
        1
      ],
      "content": "segment even if it is empty */\n\nstruct wordsplit_node\n{\n  struct wordsplit_node *prev;\t/* Previous element */\n  struct wordsplit_node *next;\t/* Next element */\n  int flags;\t\t\t/* Node flags */\n  union\n  {\n    struct\n    {\n      size_t beg;\t\t/* Start of word in ws_input */\n      size_t end;\t\t/* End of word in ws_input */\n    } segm;\n    char *word;\n  } v;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": null
    },
    "wsnode_flagstr": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "static const char *\nwsnode_flagstr (int flags)\n{\n  static char retbuf[7];\n  char *p = retbuf;\n\n  if (flags & _WSNF_WORD)\n    *p++ = 'w';\n  else if (flags & _WSNF_NULL)\n    *p++ = 'n';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_QUOTE)\n    *p++ = 'q';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_NOEXPAND)\n    *p++ = 'E';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_JOIN)\n    *p++ = 'j';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_SEXP)\n    *p++ = 's';\n  else\n    *p++ = '-';\n  if (flags & _WSNF_DELIM)\n    *p++ = 'd';\n  else\n    *p++ = '-';\n  *p = 0;\n  return retbuf;\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_flagstr (int flags)",
        "*"
      ]
    },
    "wsnode_ptr": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "static const char *\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return \"\";\n  else if (p->flags & _WSNF_WORD)\n    return p->v.word;\n  else\n    return wsp->ws_input + p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nwsnode_ptr (struct wordsplit *wsp, struct wordsplit_node *p)",
        "*"
      ]
    },
    "wsnode_len": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        387,
        1
      ],
      "content": "static size_t\nwsnode_len (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_NULL)\n    return 0;\n  else if (p->flags & _WSNF_WORD)\n    return strlen (p->v.word);\n  else\n    return p->v.segm.end - p->v.segm.beg;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "wsnode_new": {
      "start_point": [
        389,
        0
      ],
      "end_point": [
        397,
        1
      ],
      "content": "static int\nwsnode_new (struct wordsplit *wsp, struct wordsplit_node **pnode)\n{\n  struct wordsplit_node *node = calloc (1, sizeof (*node));\n  if (!node)\n    return _wsplt_nomem (wsp);\n  *pnode = node;\n  return 0;\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_free": {
      "start_point": [
        399,
        0
      ],
      "end_point": [
        405,
        1
      ],
      "content": "static void\nwsnode_free (struct wordsplit_node *p)\n{\n  if (p->flags & _WSNF_WORD)\n    free (p->v.word);\n  free (p);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_append": {
      "start_point": [
        407,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "static void\nwsnode_append (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  node->next = NULL;\n  node->prev = wsp->ws_tail;\n  if (wsp->ws_tail)\n    wsp->ws_tail->next = node;\n  else\n    wsp->ws_head = node;\n  wsp->ws_tail = node;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_remove": {
      "start_point": [
        419,
        0
      ],
      "end_point": [
        441,
        1
      ],
      "content": "static void\nwsnode_remove (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p;\n\n  p = node->prev;\n  if (p)\n    {\n      p->next = node->next;\n      if (!node->next)\n\tp->flags &= ~_WSNF_JOIN;\n    }\n  else\n    wsp->ws_head = node->next;\n\n  p = node->next;\n  if (p)\n    p->prev = node->prev;\n  else\n    wsp->ws_tail = node->prev;\n\n  node->next = node->prev = NULL;\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wsnode_insert": {
      "start_point": [
        443,
        0
      ],
      "end_point": [
        477,
        1
      ],
      "content": "static void\nwsnode_insert (struct wordsplit *wsp, struct wordsplit_node *node,\n\t       struct wordsplit_node *anchor, int before)\n{\n  if (!wsp->ws_head)\n    {\n      node->next = node->prev = NULL;\n      wsp->ws_head = wsp->ws_tail = node;\n    }\n  else if (before)\n    {\n      if (anchor->prev)\n\twsnode_insert (wsp, node, anchor->prev, 0);\n      else\n\t{\n\t  node->prev = NULL;\n\t  node->next = anchor;\n\t  anchor->prev = node;\n\t  wsp->ws_head = node;\n\t}\n    }\n  else\n    {\n      struct wordsplit_node *p;\n\n      p = anchor->next;\n      if (p)\n\tp->prev = node;\n      else\n\twsp->ws_tail = node;\n      node->next = p;\n      node->prev = anchor;\n      anchor->next = node;\n    }\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_add_segm": {
      "start_point": [
        479,
        0
      ],
      "end_point": [
        495,
        1
      ],
      "content": "static int\nwordsplit_add_segm (struct wordsplit *wsp, size_t beg, size_t end, int flg)\n{\n  struct wordsplit_node *node;\n  int rc;\n\n  if (end == beg && !(flg & _WSNF_EMPTYOK))\n    return 0;\n  rc = wsnode_new (wsp, &node);\n  if (rc)\n    return rc;\n  node->flags = flg & ~(_WSNF_WORD | _WSNF_EMPTYOK);\n  node->v.segm.beg = beg;\n  node->v.segm.end = end;\n  wsnode_append (wsp, node);\n  return 0;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_free_nodes": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        509,
        1
      ],
      "content": "static void\nwordsplit_free_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      wsnode_free (p);\n      p = next;\n    }\n  wsp->ws_head = wsp->ws_tail = NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_dump_nodes": {
      "start_point": [
        511,
        0
      ],
      "end_point": [
        530,
        1
      ],
      "content": "static void\nwordsplit_dump_nodes (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  int n = 0;\n\n  for (p = wsp->ws_head, n = 0; p; p = p->next, n++)\n    {\n      if (p->flags & _WSNF_WORD)\n\twsp->ws_debug (\"(%02d) %4d: %p: %#04x (%s):%s;\",\n\t\t       wsp->ws_lvl,\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags), p->v.word);\n      else\n\twsp->ws_debug (\"(%02d) %4d: %p: %#04x (%s):%.*s;\",\n\t\t       wsp->ws_lvl,\n\t\t       n, p, p->flags, wsnode_flagstr (p->flags),\n\t\t       (int) (p->v.segm.end - p->v.segm.beg),\n\t\t       wsp->ws_input + p->v.segm.beg);\n    }\n}",
      "lines": 20,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "coalesce_segment": {
      "start_point": [
        532,
        0
      ],
      "end_point": [
        582,
        1
      ],
      "content": "static int\ncoalesce_segment (struct wordsplit *wsp, struct wordsplit_node *node)\n{\n  struct wordsplit_node *p, *end;\n  size_t len = 0;\n  char *buf, *cur;\n  int stop;\n\n  for (p = node; p && (p->flags & _WSNF_JOIN); p = p->next)\n    {\n      len += wsnode_len (p);\n    }\n  if (p)\n    len += wsnode_len (p);\n  end = p;\n\n  buf = malloc (len + 1);\n  if (!buf)\n    return _wsplt_nomem (wsp);\n  cur = buf;\n\n  p = node;\n  for (stop = 0; !stop;)\n    {\n      struct wordsplit_node *next = p->next;\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n\n      memcpy (cur, str, slen);\n      cur += slen;\n      if (p != node)\n\t{\n\t  node->flags |= p->flags & _WSNF_QUOTE;\n\t  wsnode_remove (wsp, p);\n\t  stop = p == end;\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n\n  *cur = 0;\n\n  node->flags &= ~_WSNF_JOIN;\n\n  if (node->flags & _WSNF_WORD)\n    free (node->v.word);\n  else\n    node->flags |= _WSNF_WORD;\n  node->v.word = buf;\n  return 0;\n}",
      "lines": 51,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_quoteremoval": {
      "start_point": [
        588,
        0
      ],
      "end_point": [
        624,
        1
      ],
      "content": "static int\nwsnode_quoteremoval (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      int unquote;\n\n      if (wsp->ws_flags & WRDSF_QUOTE)\n\t{\n\t  unquote = !(p->flags & _WSNF_NOEXPAND);\n\t}\n      else\n\tunquote = 0;\n\n      if (unquote)\n\t{\n\t  if (!(p->flags & _WSNF_WORD))\n\t    {\n\t      char *newstr = malloc (slen + 1);\n\t      if (!newstr)\n\t\treturn _wsplt_nomem (wsp);\n\t      memcpy (newstr, str, slen);\n\t      newstr[slen] = 0;\n\t      p->v.word = newstr;\n\t      p->flags |= _WSNF_WORD;\n\t    }\n\n\t  wordsplit_string_unquote_copy (wsp, p->flags & _WSNF_QUOTE,\n\t\t\t\t\t p->v.word, str, slen);\n\t}\n    }\n  return 0;\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_coalesce": {
      "start_point": [
        626,
        0
      ],
      "end_point": [
        638,
        1
      ],
      "content": "static int\nwsnode_coalesce (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      if (p->flags & _WSNF_JOIN)\n\tif (coalesce_segment (wsp, p))\n\t  return 1;\n    }\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_finish": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "static int\nwordsplit_finish (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  size_t n;\n\n  n = 0;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    n++;\n\n  if (alloc_space (wsp, n + 1))\n    return 1;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str = wsnode_ptr (wsp, p);\n      size_t slen = wsnode_len (p);\n      char *newstr = malloc (slen + 1);\n\n      /* Assign newstr first, even if it is NULL.  This way\n         wordsplit_free will work even if we return\n         nomem later. */\n      wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = newstr;\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str, slen);\n      newstr[slen] = 0;\n\n      wsp->ws_wordc++;\n\n    }\n  wsp->ws_wordv[wsp->ws_offs + wsp->ws_wordc] = NULL;\n  return 0;\n}",
      "lines": 35,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_split_prefix": {
      "start_point": [
        678,
        0
      ],
      "end_point": [
        710,
        1
      ],
      "content": "static int\nnode_split_prefix (struct wordsplit *wsp,\n\t\t   struct wordsplit_node **ptail,\n\t\t   struct wordsplit_node *node,\n\t\t   size_t beg, size_t len, int flg)\n{\n  struct wordsplit_node *newnode;\n\n  if (len == 0)\n    return 0;\n  if (wsnode_new (wsp, &newnode))\n    return 1;\n  wsnode_insert (wsp, newnode, *ptail, 0);\n  if (node->flags & _WSNF_WORD)\n    {\n      const char *str = wsnode_ptr (wsp, node);\n      char *newstr = malloc (len + 1);\n      if (!newstr)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newstr, str + beg, len);\n      newstr[len] = 0;\n      newnode->flags = _WSNF_WORD;\n      newnode->v.word = newstr;\n    }\n  else\n    {\n      newnode->v.segm.beg = node->v.segm.beg + beg;\n      newnode->v.segm.end = newnode->v.segm.beg + len;\n    }\n  newnode->flags |= flg;\n  *ptail = newnode;\n  return 0;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "find_closing_paren": {
      "start_point": [
        712,
        0
      ],
      "end_point": [
        767,
        1
      ],
      "content": "static int\nfind_closing_paren (const char *str, size_t i, size_t len, size_t *poff,\n\t\t    char *paren)\n{\n  enum { st_init, st_squote, st_dquote } state = st_init;\n  size_t level = 1;\n\n  for (; i < len; i++)\n    {\n      switch (state)\n\t{\n\tcase st_init:\n\t  switch (str[i])\n\t    {\n\t    default:\n\t      if (str[i] == paren[0])\n\t\t{\n\t\t  level++;\n\t\t  break;\n\t\t}\n\t      else if (str[i] == paren[1])\n\t\t{\n\t\t  if (--level == 0)\n\t\t    {\n\t\t      *poff = i;\n\t\t      return 0;\n\t\t    }\n\t\t  break;\n\t\t}\n\t      break;\n\t      \n\t    case '\"':\n\t      state = st_dquote;\n\t      break;\n\n\t    case '\\'':\n\t      state = st_squote;\n\t      break;\n\t    }\n\t  break;\n\n\tcase st_squote:\n\t  if (str[i] == '\\'')\n\t    state = st_init;\n\t  break;\n\n\tcase st_dquote:\n\t  if (str[i] == '\\\\')\n\t    i++;\n\t  else if (str[i] == '\"')\n\t    state = st_init;\n\t  break;\n\t}\n    }\n  return 1;\n}",
      "lines": 56,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_find_env": {
      "start_point": [
        769,
        0
      ],
      "end_point": [
        814,
        1
      ],
      "content": "static int\nwordsplit_find_env (struct wordsplit *wsp, const char *name, size_t len,\n\t\t    char const **ret)\n{\n  size_t i;\n\n  if (!(wsp->ws_flags & WRDSF_ENV))\n    return WRDSE_UNDEF;\n\n  if (wsp->ws_flags & WRDSF_ENV_KV)\n    {\n      /* A key-value pair environment */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t elen = strlen (wsp->ws_env[i]);\n\t  if (elen == len && memcmp (wsp->ws_env[i], name, elen) == 0)\n\t    {\n\t      *ret = wsp->ws_env[i + 1];\n\t      return WRDSE_OK;\n\t    }\n\t  /* Skip the value.  Break the loop if it is NULL. */\n\t  i++;\n\t  if (wsp->ws_env[i] == NULL)\n\t    break;\n\t}\n    }\n  else if (wsp->ws_env)\n    {\n      /* Usual (A=B) environment. */\n      for (i = 0; wsp->ws_env[i]; i++)\n\t{\n\t  size_t j;\n\t  const char *var = wsp->ws_env[i];\n\n\t  for (j = 0; j < len; j++)\n\t    if (name[j] != var[j])\n\t      break;\n\t  if (j == len && var[j] == '=')\n\t    {\n\t      *ret = var + j + 1;\n\t      return WRDSE_OK;\n\t    }\n\t}\n    }\n  return WRDSE_UNDEF;\n}",
      "lines": 46,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsplt_assign_var": {
      "start_point": [
        816,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "static int\nwsplt_assign_var (struct wordsplit *wsp, const char *name, size_t namelen,\n\t\t  char *value)\n{\n  int n = (wsp->ws_flags & WRDSF_ENV_KV) ? 2 : 1;\n  char *v;\n  \n  if (wsp->ws_envidx + n >= wsp->ws_envsiz)\n    {\n      size_t sz;\n      char **newenv;\n\n      if (!wsp->ws_envbuf)\n\t{\n\t  if (wsp->ws_flags & WRDSF_ENV)\n\t    {\n\t      size_t i = 0, j;\n\n\t      if (wsp->ws_env)\n\t\t{\n\t\t  for (; wsp->ws_env[i]; i++)\n\t\t    ;\n\t\t}\n\t      \n\t      sz = i + n + 1;\n\n\t      newenv = calloc (sz, sizeof(newenv[0]));\n\t      if (!newenv)\n\t\treturn _wsplt_nomem (wsp);\n\n\t      for (j = 0; j < i; j++)\n\t\t{\n\t\t  newenv[j] = strdup (wsp->ws_env[j]);\n\t\t  if (!newenv[j])\n\t\t    {\n\t\t      for (; j > 1; j--)\n\t\t\tfree (newenv[j-1]);\n\t\t      free (newenv[j-1]);\n\t\t      return _wsplt_nomem (wsp);\n\t\t    }\n\t\t}\n\t      newenv[j] = NULL;\n\t      \n\t      wsp->ws_envbuf = newenv;\n\t      wsp->ws_envidx = i;\n\t      wsp->ws_envsiz = sz;\n\t      wsp->ws_env = (const char**) wsp->ws_envbuf;\n\t    }\n\t  else\n\t    {\n\t      newenv = calloc (WORDSPLIT_ENV_INIT, sizeof(newenv[0]));\n\t      if (!newenv)\n\t\treturn _wsplt_nomem (wsp);\n\t      wsp->ws_envbuf = newenv;\n\t      wsp->ws_envidx = 0;\n\t      wsp->ws_envsiz = WORDSPLIT_ENV_INIT;\n\t      wsp->ws_env = (const char**) wsp->ws_envbuf;\n\t      wsp->ws_flags |= WRDSF_ENV;\n\t    }\n\t}\n      else\n\t{\n\t  wsp->ws_envsiz *= 2;\n\t  newenv = realloc (wsp->ws_envbuf,\n\t\t\t    wsp->ws_envsiz * sizeof (wsp->ws_envbuf[0]));\n\t  if (!newenv)\n\t    return _wsplt_nomem (wsp);\n\t  wsp->ws_envbuf = newenv;\n\t  wsp->ws_env = (const char**) wsp->ws_envbuf;\n\t}\n    }\n  \n  if (wsp->ws_flags & WRDSF_ENV_KV)\n    {\n      /* A key-value pair environment */\n      char *p = malloc (namelen + 1);\n      if (!p)\n\treturn _wsplt_nomem (wsp);\n      memcpy (p, name, namelen);\n      p[namelen] = 0;\n\n      v = strdup (value);\n      if (!v)\n\t{\n\t  free (p);\n\t  return _wsplt_nomem (wsp);\n\t}\n      wsp->ws_env[wsp->ws_envidx++] = p;\n      wsp->ws_env[wsp->ws_envidx++] = v;\n    }\n  else\n    {\n      v = malloc (namelen + strlen(value) + 2);\n      if (!v)\n\treturn _wsplt_nomem (wsp);\n      memcpy (v, name, namelen);\n      v[namelen++] = '=';\n      strcpy(v + namelen, value);\n      wsp->ws_env[wsp->ws_envidx++] = v;\n    }\n  wsp->ws_env[wsp->ws_envidx++] = NULL;\n  return WRDSE_OK;\n}",
      "lines": 103,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "expvar": {
      "start_point": [
        920,
        0
      ],
      "end_point": [
        1203,
        1
      ],
      "content": "static int\nexpvar (struct wordsplit *wsp, const char *str, size_t len,\n\tstruct wordsplit_node **ptail, const char **pend, int flg)\n{\n  size_t i = 0;\n  const char *defstr = NULL;\n  char *value;\n  const char *vptr;\n  struct wordsplit_node *newnode;\n  const char *start = str - 1;\n  int rc;\n  struct wordsplit ws;\n  \n  if (ISVARBEG (str[0]))\n    {\n      for (i = 1; i < len; i++)\n\tif (!ISVARCHR (str[i]))\n\t  break;\n      *pend = str + i - 1;\n    }\n  else if (str[0] == '{')\n    {\n      str++;\n      len--;\n      for (i = 1; i < len; i++)\n\t{\n\t  if (str[i] == ':')\n\t    {\n\t      size_t j;\n\t      \n\t      defstr = str + i + 1;\n\t      if (find_closing_paren (str, i + 1, len, &j, \"{}\"))\n\t\treturn _wsplt_seterr (wsp, WRDSE_CBRACE);\n\t      *pend = str + j;\n\t      break;\n\t    }\n\t  else if (str[i] == '}')\n\t    {\n\t      defstr = NULL;\n\t      *pend = str + i;\n\t      break;\n\t    }\n\t  else if (strchr (\"-+?=\", str[i]))\n\t    {\n\t      size_t j;\n\t      \n\t      defstr = str + i;\n\t      if (find_closing_paren (str, i, len, &j, \"{}\"))\n\t\treturn _wsplt_seterr (wsp, WRDSE_CBRACE);\n\t      *pend = str + j;\n\t      break;\n\t    }\n\t}\n      if (i == len)\n\treturn _wsplt_seterr (wsp, WRDSE_CBRACE);\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | flg;\n      newnode->v.word = malloc (3);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      newnode->v.word[0] = '$';\n      newnode->v.word[1] = str[0];\n      newnode->v.word[2] = 0;\n      *pend = str;\n      return 0;\n    }\n\n  /* Actually expand the variable */\n  /* str - start of the variable name\n     i   - its length\n     defstr - default replacement str */\n\n  if (defstr && strchr(\"-+?=\", defstr[0]) == 0)\n    {\n      rc = WRDSE_UNDEF;\n      defstr = NULL;\n    }\n  else\n    {\n      rc = wordsplit_find_env (wsp, str, i, &vptr);\n      if (rc == WRDSE_OK)\n\t{\n\t  value = strdup (vptr);\n\t  if (!value)\n\t    rc = WRDSE_NOSPACE;\n\t}\n      else if (wsp->ws_flags & WRDSF_GETVAR)\n\trc = wsp->ws_getvar (&value, str, i, wsp->ws_closure);\n      else\n\trc = WRDSE_UNDEF;\n\n      if (rc == WRDSE_OK && value[0] == 0 && defstr && defstr[-1] == ':')\n\t{\n\t  free (value);\n\t  rc = WRDSE_UNDEF;\n\t}\n    }\n  \n  switch (rc)\n    {\n    case WRDSE_OK:\n      if (defstr && *defstr == '+')\n\t{\n\t  size_t size = *pend - ++defstr;\n\n\t  rc = _wsplt_subsplit (wsp, &ws, defstr, size,\n\t\t\t\tWRDSF_NOSPLIT | WRDSF_WS | WRDSF_QUOTE |\n\t\t\t\t(wsp->ws_flags &\n\t\t\t\t (WRDSF_NOVAR | WRDSF_NOCMD)));\n\t  if (rc)\n\t    return rc;\n\t  free (value);\n\t  value = ws.ws_wordv[0];\n\t  ws.ws_wordv[0] = NULL;\n\t  wordsplit_free (&ws);\n\t}\n      break;\n      \n    case WRDSE_UNDEF:\n      if (defstr)\n\t{\n\t  size_t size;\n\t  if (*defstr == '-' || *defstr == '=')\n\t    {\n\t      size = *pend - ++defstr;\n\n\t      rc = _wsplt_subsplit (wsp, &ws, defstr, size,\n\t\t\t\t    WRDSF_NOSPLIT | WRDSF_WS | WRDSF_QUOTE |\n\t\t\t\t    (wsp->ws_flags &\n\t\t\t\t     (WRDSF_NOVAR | WRDSF_NOCMD)));\n\t      if (rc)\n\t\treturn rc;\n\n\t      value = ws.ws_wordv[0];\n\t      ws.ws_wordv[0] = NULL;\n\t      wordsplit_free (&ws);\n\t      \n\t      if (defstr[-1] == '=')\n\t\twsplt_assign_var (wsp, str, i, value);\n\t    }\n\t  else \n\t    {\n\t      if (*defstr == '?')\n\t\t{\n\t\t  size = *pend - ++defstr;\n\t\t  if (size == 0)\n\t\t    wsp->ws_error (_(\"%.*s: variable null or not set\"),\n\t\t\t\t   (int) i, str);\n\t\t  else\n\t\t    {\n\t\t      rc = _wsplt_subsplit (wsp, &ws, defstr, size,\n\t\t\t\t\t    WRDSF_NOSPLIT | WRDSF_WS |\n\t\t\t\t\t    WRDSF_QUOTE |\n\t\t\t\t\t    (wsp->ws_flags &\n\t\t\t\t\t     (WRDSF_NOVAR | WRDSF_NOCMD)));\n\t\t      if (rc == 0)\n\t\t\twsp->ws_error (\"%.*s: %s\",\n\t\t\t\t       (int) i, str, ws.ws_wordv[0]);\n\t\t      else\n\t\t\twsp->ws_error (\"%.*s: %.*s\",\n\t\t\t\t       (int) i, str, (int) size, defstr);\n\t\t      wordsplit_free (&ws);\n\t\t    }\n\t\t}\n\t      value = NULL;\n\t    }\n\t}\n      else if (wsp->ws_flags & WRDSF_UNDEF)\n\t{\n\t  _wsplt_seterr (wsp, WRDSE_UNDEF);\n\t  return 1;\n\t}\n      else\n\t{\n\t  if (wsp->ws_flags & WRDSF_WARNUNDEF)\n\t    wsp->ws_error (_(\"warning: undefined variable `%.*s'\"),\n\t\t\t   (int) i, str);\n\t  if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n\t    value = NULL;\n\t  else\n\t    {\n\t      value = strdup (\"\");\n\t      if (!value)\n\t\treturn _wsplt_nomem (wsp);\n\t    }\n\t}\n      break;\n      \n    case WRDSE_NOSPACE:\n      return _wsplt_nomem (wsp);\n\n    case WRDSE_USERERR:\n      if (wsp->ws_errno == WRDSE_USERERR)\n\tfree (wsp->ws_usererr);\n      wsp->ws_usererr = value;\n      /* fall through */\n    default:\n      _wsplt_seterr (wsp, rc);\n      return 1;\n    }\n\n  if (value)\n    {\n      if (flg & _WSNF_QUOTE)\n\t{\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n\t  newnode->v.word = value;\n\t}\n      else if (*value == 0)\n\t{\n\t  free (value);\n\t  /* Empty string is a special case */\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_NULL;\n\t}\n      else\n\t{\n\t  struct wordsplit ws;\n\t  int i, rc;\n\t  \n\t  rc = _wsplt_subsplit (wsp, &ws, value, strlen (value),\n\t\t\t\tWRDSF_NOVAR | WRDSF_NOCMD |\n\t\t\t\tWRDSF_QUOTE);\n\t  free (value);\n\t  if (rc)\n\t    {\n\t      _wsplt_seterr_sub (wsp, &ws);\n\t      wordsplit_free (&ws);\n\t      return 1;\n\t    }\n\t  for (i = 0; i < ws.ws_wordc; i++)\n\t    {\n\t      if (wsnode_new (wsp, &newnode))\n\t\treturn 1;\n\t      wsnode_insert (wsp, newnode, *ptail, 0);\n\t      *ptail = newnode;\n\t      newnode->flags = _WSNF_WORD |\n\t\t_WSNF_NOEXPAND |\n\t\t(i + 1 < ws.ws_wordc ? (flg & ~_WSNF_JOIN) : flg);\n\t      newnode->v.word = strdup (ws.ws_wordv[i]);\n\t      if (!newnode->v.word)\n\t\treturn _wsplt_nomem (wsp);\n\t    }\n\t  wordsplit_free (&ws);\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_KEEPUNDEF)\n    {\n      size_t size = *pend - start + 1;\n\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n      newnode->v.word = malloc (size + 1);\n      if (!newnode->v.word)\n\treturn _wsplt_nomem (wsp);\n      memcpy (newnode->v.word, start, size);\n      newnode->v.word[size] = 0;\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_NULL;\n    }\n  return 0;\n}",
      "lines": 284,
      "depth": 23,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "begin_var_p": {
      "start_point": [
        1205,
        0
      ],
      "end_point": [
        1209,
        1
      ],
      "content": "static int\nbegin_var_p (int c)\n{\n  return c == '{' || ISVARBEG (c);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "node_expand": {
      "start_point": [
        1211,
        0
      ],
      "end_point": [
        1264,
        1
      ],
      "content": "static int\nnode_expand (struct wordsplit *wsp, struct wordsplit_node *node,\n\t     int (*beg_p) (int),\n\t     int (*ws_exp_fn) (struct wordsplit *wsp,\n\t\t\t       const char *str, size_t len,\n\t\t\t       struct wordsplit_node **ptail,\n\t\t\t       const char **pend,\n\t\t\t       int flg))\n{\n  const char *str = wsnode_ptr (wsp, node);\n  size_t slen = wsnode_len (node);\n  const char *end = str + slen;\n  const char *p;\n  size_t off = 0;\n  struct wordsplit_node *tail = node;\n\n  for (p = str; p < end; p++)\n    {\n      if (*p == '\\\\')\n\t{\n\t  p++;\n\t  continue;\n\t}\n      if (*p == '$' && beg_p (p[1]))\n\t{\n\t  size_t n = p - str;\n\n\t  if (tail != node)\n\t    tail->flags |= _WSNF_JOIN;\n\t  if (node_split_prefix (wsp, &tail, node, off, n, _WSNF_JOIN))\n\t    return 1;\n\t  p++;\n\t  if (ws_exp_fn (wsp, p, slen - n, &tail, &p,\n\t\t\t node->flags & (_WSNF_JOIN | _WSNF_QUOTE)))\n\t    return 1;\n\t  off += p - str + 1;\n\t  str = p + 1;\n\t}\n    }\n  if (p > str)\n    {\n      if (tail != node)\n\ttail->flags |= _WSNF_JOIN;\n      if (node_split_prefix (wsp, &tail, node, off, p - str,\n\t\t\t     node->flags & (_WSNF_JOIN|_WSNF_QUOTE)))\n\treturn 1;\n    }\n  if (tail != node)\n    {\n      wsnode_remove (wsp, node);\n      wsnode_free (node);\n    }\n  return 0;\n}",
      "lines": 54,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsnode_nullelim": {
      "start_point": [
        1267,
        0
      ],
      "end_point": [
        1284,
        1
      ],
      "content": "static void\nwsnode_nullelim (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (p->flags & _WSNF_DELIM && p->prev)\n\tp->prev->flags &= ~_WSNF_JOIN;\n      if (p->flags & _WSNF_NULL)\n\t{\n\t  wsnode_remove (wsp, p);\n\t  wsnode_free (p);\n\t}\n      p = next;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "wordsplit_varexp": {
      "start_point": [
        1286,
        0
      ],
      "end_point": [
        1302,
        1
      ],
      "content": "static int\nwordsplit_varexp (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (!(p->flags & _WSNF_NOEXPAND))\n\tif (node_expand (wsp, p, begin_var_p, expvar))\n\t  return 1;\n      p = next;\n    }\n\n  wsnode_nullelim (wsp);\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "begin_cmd_p": {
      "start_point": [
        1304,
        0
      ],
      "end_point": [
        1308,
        1
      ],
      "content": "static int\nbegin_cmd_p (int c)\n{\n  return c == '(';\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "expcmd": {
      "start_point": [
        1310,
        0
      ],
      "end_point": [
        1423,
        1
      ],
      "content": "static int\nexpcmd (struct wordsplit *wsp, const char *str, size_t len,\n\tstruct wordsplit_node **ptail, const char **pend, int flg)\n{\n  int rc;\n  size_t j;\n  char *value;\n  struct wordsplit_node *newnode;\n  \n  str++;\n  len--;\n\n  if (find_closing_paren (str, 0, len, &j, \"()\"))\n    {\n      _wsplt_seterr (wsp, WRDSE_PAREN);\n      return 1;\n    }\n\n  *pend = str + j;\n  if (wsp->ws_options & WRDSO_ARGV)\n    {\n      struct wordsplit ws;\n\n      rc = _wsplt_subsplit (wsp, &ws, str, j,\n\t\t\t    WRDSF_NOVAR | WRDSF_NOCMD |\n\t\t\t    WRDSF_WS | WRDSF_QUOTE);\n      if (rc)\n\t{\n\t  _wsplt_seterr_sub (wsp, &ws);\n\t  wordsplit_free (&ws);\n\t  return 1;\n\t}\n      rc = wsp->ws_command (&value, str, j, ws.ws_wordv, wsp->ws_closure);\n      wordsplit_free (&ws);\n    }\n  else\n    rc = wsp->ws_command (&value, str, j, NULL, wsp->ws_closure);\n  \n  if (rc == WRDSE_NOSPACE)\n    return _wsplt_nomem (wsp);\n  else if (rc)\n    {\n      if (rc == WRDSE_USERERR)\n\t{\n\t  if (wsp->ws_errno == WRDSE_USERERR)\n\t    free (wsp->ws_usererr);\n\t  wsp->ws_usererr = value;\n\t}\n      _wsplt_seterr (wsp, rc);\n      return 1;\n    }\n\n  if (value)\n    {\n      if (flg & _WSNF_QUOTE)\n\t{\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_WORD | _WSNF_NOEXPAND | flg;\n\t  newnode->v.word = value;\n\t}\n      else if (*value == 0)\n\t{\n\t  free (value);\n\t  /* Empty string is a special case */\n\t  if (wsnode_new (wsp, &newnode))\n\t    return 1;\n\t  wsnode_insert (wsp, newnode, *ptail, 0);\n\t  *ptail = newnode;\n\t  newnode->flags = _WSNF_NULL;\n\t}\n      else\n\t{\n\t  struct wordsplit ws;\n\t  int i, rc;\n\n\t  rc = _wsplt_subsplit (wsp, &ws, value, strlen (value),\n\t\t\t\tWRDSF_NOVAR | WRDSF_NOCMD |\n\t\t\t\tWRDSF_WS | WRDSF_QUOTE);\n\t  free (value);\n\t  if (rc)\n\t    {\n\t      _wsplt_seterr_sub (wsp, &ws);\n\t      wordsplit_free (&ws);\n\t      return 1;\n\t    }\n\t  for (i = 0; i < ws.ws_wordc; i++)\n\t    {\n\t      if (wsnode_new (wsp, &newnode))\n\t\treturn 1;\n\t      wsnode_insert (wsp, newnode, *ptail, 0);\n\t      *ptail = newnode;\n\t      newnode->flags = _WSNF_WORD |\n\t\t_WSNF_NOEXPAND |\n\t\t(i + 1 < ws.ws_wordc ? (flg & ~_WSNF_JOIN) : flg);\n\t      newnode->v.word = strdup (ws.ws_wordv[i]);\n\t      if (!newnode->v.word)\n\t\treturn _wsplt_nomem (wsp);\n\t    }\n\t  wordsplit_free (&ws);\n\t}\n    }\n  else\n    {\n      if (wsnode_new (wsp, &newnode))\n\treturn 1;\n      wsnode_insert (wsp, newnode, *ptail, 0);\n      *ptail = newnode;\n      newnode->flags = _WSNF_NULL;\n    }\n  return 0;\n}",
      "lines": 114,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_cmdexp": {
      "start_point": [
        1425,
        0
      ],
      "end_point": [
        1441,
        1
      ],
      "content": "static int\nwordsplit_cmdexp (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p;)\n    {\n      struct wordsplit_node *next = p->next;\n      if (!(p->flags & _WSNF_NOEXPAND))\n\tif (node_expand (wsp, p, begin_cmd_p, expcmd))\n\t  return 1;\n      p = next;\n    }\n\n  wsnode_nullelim (wsp);\n  return 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_trimws": {
      "start_point": [
        1446,
        0
      ],
      "end_point": [
        1480,
        1
      ],
      "content": "static int\nwordsplit_trimws (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n\n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      size_t n;\n\n      if (!(p->flags & _WSNF_QUOTE))\n\t{\n\t  /* Skip leading whitespace: */\n\t  for (n = p->v.segm.beg; n < p->v.segm.end && ISWS (wsp->ws_input[n]);\n\t       n++)\n\t    ;\n\t  p->v.segm.beg = n;\n\t}\n      \n      while (p->next && (p->flags & _WSNF_JOIN))\n\tp = p->next;\n      \n      if (p->flags & _WSNF_QUOTE)\n\tcontinue;\n      \n      /* Trim trailing whitespace */\n      for (n = p->v.segm.end;\n\t   n > p->v.segm.beg && ISWS (wsp->ws_input[n - 1]); n--);\n      p->v.segm.end = n;\n      if (p->v.segm.beg == p->v.segm.end)\n\tp->flags |= _WSNF_NULL;\n    }\n\n  wsnode_nullelim (wsp);\n  return 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_tildexpand": {
      "start_point": [
        1482,
        0
      ],
      "end_point": [
        1553,
        1
      ],
      "content": "static int\nwordsplit_tildexpand (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p;\n  char *uname = NULL;\n  size_t usize = 0;\n  \n  for (p = wsp->ws_head; p; p = p->next)\n    {\n      const char *str;\n\n      if (p->flags & _WSNF_QUOTE)\n\tcontinue;\n\n      str = wsnode_ptr (wsp, p);\n      if (str[0] == '~')\n\t{\n\t  size_t i, size, dlen;\n\t  size_t slen = wsnode_len (p);\n\t  struct passwd *pw;\n\t  char *newstr;\n\t  \n\t  for (i = 1; i < slen && str[i] != '/'; i++)\n\t    ;\n\t  if (i == slen)\n\t    continue;\n\t  if (i > 1)\n\t    {\n\t      if (i > usize)\n\t\t{\n\t\t  char *p = realloc (uname, i);\n\t\t  if (!p)\n\t\t    {\n\t\t      free (uname);\n\t\t      return _wsplt_nomem (wsp);\n\t\t    }\n\t\t  uname = p;\n\t\t  usize = i;\n\t\t}\n\t      --i;\n\t      memcpy (uname, str + 1, i);\n\t      uname[i] = 0;\n\t      pw = getpwnam (uname);\n\t    }\n\t  else\n\t    pw = getpwuid (getuid ());\n\n\t  if (!pw)\n\t    continue;\n\n\t  dlen = strlen (pw->pw_dir);\n\t  size = slen - i + dlen;\n\t  newstr = malloc (size);\n\t  if (!newstr)\n\t    {\n\t      free (uname);\n\t      return _wsplt_nomem (wsp);\n\t    }\n\t  --size;\n\n\t  memcpy (newstr, pw->pw_dir, dlen);\n\t  memcpy (newstr + dlen, str + i + 1, slen - i - 1);\n\t  newstr[size] = 0;\n\t  if (p->flags & _WSNF_WORD)\n\t    free (p->v.word);\n\t  p->v.word = newstr;\n\t  p->flags |= _WSNF_WORD;\n\t}\n    }\n  free (uname);\n  return 0;\n}",
      "lines": 72,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "isglob": {
      "start_point": [
        1555,
        0
      ],
      "end_point": [
        1564,
        1
      ],
      "content": "static int\nisglob (const char *s, int l)\n{\n  while (l--)\n    {\n      if (strchr (\"*?[\", *s++))\n\treturn 1;\n    }\n  return 0;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_pathexpand": {
      "start_point": [
        1566,
        0
      ],
      "end_point": [
        1669,
        1
      ],
      "content": "static int\nwordsplit_pathexpand (struct wordsplit *wsp)\n{\n  struct wordsplit_node *p, *next;\n  char *pattern = NULL;\n  size_t patsize = 0;\n  size_t slen;\n  int flags = 0;\n\n#ifdef GLOB_PERIOD\n  if (wsp->ws_options & WRDSO_DOTGLOB)\n    flags = GLOB_PERIOD;\n#endif\n  \n  for (p = wsp->ws_head; p; p = next)\n    {\n      const char *str;\n\n      next = p->next;\n\n      if (p->flags & _WSNF_QUOTE)\n\tcontinue;\n\n      str = wsnode_ptr (wsp, p);\n      slen = wsnode_len (p);\n\n      if (isglob (str, slen))\n\t{\n\t  int i;\n\t  glob_t g;\n\t  struct wordsplit_node *prev;\n\t  \n\t  if (slen + 1 > patsize)\n\t    {\n\t      char *p = realloc (pattern, slen + 1);\n\t      if (!p)\n\t\treturn _wsplt_nomem (wsp);\n\t      pattern = p;\n\t      patsize = slen + 1;\n\t    }\n\t  memcpy (pattern, str, slen);\n\t  pattern[slen] = 0;\n      \n\t  switch (glob (pattern, flags, NULL, &g))\n\t    {\n\t    case 0:\n\t      break;\n\t      \n\t    case GLOB_NOSPACE:\n\t      free (pattern);\n\t      return _wsplt_nomem (wsp);\n\t      \n\t    case GLOB_NOMATCH:\n\t      if (wsp->ws_options & WRDSO_NULLGLOB)\n\t\t{\n\t\t  wsnode_remove (wsp, p);\n\t\t  wsnode_free (p);\n\t\t}\n\t      else if (wsp->ws_options & WRDSO_FAILGLOB)\n\t\t{\n\t\t  char buf[128];\n\t\t  if (wsp->ws_errno == WRDSE_USERERR)\n\t\t    free (wsp->ws_usererr);\n\t\t  snprintf (buf, sizeof (buf), _(\"no files match pattern %s\"),\n\t\t\t    pattern);\n\t\t  free (pattern);\n\t\t  wsp->ws_usererr = strdup (buf);\n\t\t  if (!wsp->ws_usererr)\n\t\t    return _wsplt_nomem (wsp);\n\t\t  else\n\t\t    return _wsplt_seterr (wsp, WRDSE_USERERR);\n\t\t}\n\t      continue;\n\t      \n\t    default:\n\t      free (pattern);\n\t      return _wsplt_seterr (wsp, WRDSE_GLOBERR);\n\t    }\n\n\t  prev = p;\n\t  for (i = 0; i < g.gl_pathc; i++)\n\t    {\n\t      struct wordsplit_node *newnode;\n\t      char *newstr;\n\t      \n\t      if (wsnode_new (wsp, &newnode))\n\t\treturn 1;\n\t      newstr = strdup (g.gl_pathv[i]);\n\t      if (!newstr)\n\t\treturn _wsplt_nomem (wsp);\n\t      newnode->v.word = newstr;\n\t      newnode->flags |= _WSNF_WORD|_WSNF_QUOTE;\n\t      wsnode_insert (wsp, newnode, prev, 0);\n\t      prev = newnode;\n\t    }\n\t  globfree (&g);\n\n\t  wsnode_remove (wsp, p);\n\t  wsnode_free (p);\n\t}\n    }\n  free (pattern);\n  return 0;\n}",
      "lines": 104,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_sed_expr": {
      "start_point": [
        1671,
        0
      ],
      "end_point": [
        1702,
        1
      ],
      "content": "static int\nskip_sed_expr (const char *command, size_t i, size_t len)\n{\n  int state;\n\n  do\n    {\n      int delim;\n\n      if (command[i] == ';')\n\ti++;\n      if (!(command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1])))\n\tbreak;\n\n      delim = command[++i];\n      state = 1;\n      for (i++; i < len; i++)\n\t{\n\t  if (state == 3)\n\t    {\n\t      if (command[i] == delim || !ISALNUM (command[i]))\n\t\tbreak;\n\t    }\n\t  else if (command[i] == '\\\\')\n\t    i++;\n\t  else if (command[i] == delim)\n\t    state++;\n\t}\n    }\n  while (state == 3 && i < len && command[i] == ';');\n  return i;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "skip_delim": {
      "start_point": [
        1704,
        0
      ],
      "end_point": [
        1731,
        1
      ],
      "content": "static size_t\nskip_delim (struct wordsplit *wsp)\n{\n  size_t start = wsp->ws_endp;\n  if (wsp->ws_flags & WRDSF_SQUEEZE_DELIMS)\n    {\n      if ((wsp->ws_flags & WRDSF_RETURN_DELIMS) &&\n\t  ISDELIM (wsp, wsp->ws_input[start]))\n\t{\n\t  int delim = wsp->ws_input[start];\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && delim == wsp->ws_input[start]);\n\t}\n      else\n\t{\n\t  do\n\t    start++;\n\t  while (start < wsp->ws_len && ISDELIM (wsp, wsp->ws_input[start]));\n\t}\n      start--;\n    }\n\n  if (!(wsp->ws_flags & WRDSF_RETURN_DELIMS))\n    start++;\n\n  return start;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "scan_qstring": {
      "start_point": [
        1737,
        0
      ],
      "end_point": [
        1764,
        1
      ],
      "content": "static int\nscan_qstring (struct wordsplit *wsp, size_t start, size_t * end)\n{\n  size_t j;\n  const char *command = wsp->ws_input;\n  size_t len = wsp->ws_len;\n  char q = command[start];\n\n  for (j = start + 1; j < len && command[j] != q; j++)\n    if (q == '\"' && command[j] == '\\\\')\n      j++;\n  if (j < len && command[j] == q)\n    {\n      int flags = _WSNF_QUOTE | _WSNF_EMPTYOK;\n      if (q == '\\'')\n\tflags |= _WSNF_NOEXPAND;\n      if (wordsplit_add_segm (wsp, start + 1, j, flags))\n\treturn _WRDS_ERR;\n      *end = j;\n    }\n  else\n    {\n      wsp->ws_endp = start;\n      _wsplt_seterr (wsp, WRDSE_QUOTE);\n      return _WRDS_ERR;\n    }\n  return 0;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "scan_word": {
      "start_point": [
        1766,
        0
      ],
      "end_point": [
        1864,
        1
      ],
      "content": "static int\nscan_word (struct wordsplit *wsp, size_t start)\n{\n  size_t len = wsp->ws_len;\n  const char *command = wsp->ws_input;\n  const char *comment = wsp->ws_comment;\n  int join = 0;\n  int flags = 0;\n\n  size_t i = start;\n\n  if (i >= len)\n    {\n      wsp->ws_errno = WRDSE_EOF;\n      return _WRDS_EOF;\n    }\n\n  start = i;\n\n  if (wsp->ws_flags & WRDSF_SED_EXPR\n      && command[i] == 's' && i + 3 < len && ISPUNCT (command[i + 1]))\n    {\n      flags = _WSNF_SEXP;\n      i = skip_sed_expr (command, i, len);\n    }\n  else if (!ISDELIM (wsp, command[i]))\n    {\n      while (i < len)\n\t{\n\t  if (comment && strchr (comment, command[i]) != NULL)\n\t    {\n\t      size_t j;\n\t      for (j = i + 1; j < len && command[j] != '\\n'; j++)\n\t\t;\n\t      if (wordsplit_add_segm (wsp, start, i, 0))\n\t\treturn _WRDS_ERR;\n\t      wsp->ws_endp = j;\n\t      return _WRDS_OK;\n\t    }\n\n\t  if (wsp->ws_flags & WRDSF_QUOTE)\n\t    {\n\t      if (command[i] == '\\\\')\n\t\t{\n\t\t  if (++i == len)\n\t\t    break;\n\t\t  i++;\n\t\t  continue;\n\t\t}\n\n\t      if (((wsp->ws_flags & WRDSF_SQUOTE) && command[i] == '\\'') ||\n\t\t  ((wsp->ws_flags & WRDSF_DQUOTE) && command[i] == '\"'))\n\t\t{\n\t\t  if (join && wsp->ws_tail)\n\t\t    wsp->ws_tail->flags |= _WSNF_JOIN;\n\t\t  if (wordsplit_add_segm (wsp, start, i, _WSNF_JOIN))\n\t\t    return _WRDS_ERR;\n\t\t  if (scan_qstring (wsp, i, &i))\n\t\t    return _WRDS_ERR;\n\t\t  start = i + 1;\n\t\t  join = 1;\n\t\t}\n\t    }\n\n\t  if (command[i] == '$')\n\t    {\n\t      if (!(wsp->ws_flags & WRDSF_NOVAR)\n\t\t  && command[i+1] == '{'\n\t\t  && find_closing_paren (command, i + 2, len, &i, \"{}\") == 0)\n\t\tcontinue;\n\t      if (!(wsp->ws_flags & WRDSF_NOCMD)\n\t\t  && command[i+1] == '('\n\t\t  && find_closing_paren (command, i + 2, len, &i, \"()\") == 0)\n\t\tcontinue;\n\t    }\n\n\t  if (ISDELIM (wsp, command[i]))\n\t    break;\n\t  else\n\t    i++;\n\t}\n    }\n  else if (wsp->ws_flags & WRDSF_RETURN_DELIMS)\n    {\n      i++;\n      flags |= _WSNF_DELIM;\n    }\n  else if (!(wsp->ws_flags & WRDSF_SQUEEZE_DELIMS))\n    flags |= _WSNF_EMPTYOK;\n\n  if (join && i > start && wsp->ws_tail)\n    wsp->ws_tail->flags |= _WSNF_JOIN;\n  if (wordsplit_add_segm (wsp, start, i, flags))\n    return _WRDS_ERR;\n  wsp->ws_endp = i;\n  if (wsp->ws_flags & WRDSF_INCREMENTAL)\n    return _WRDS_EOF;\n  return _WRDS_OK;\n}",
      "lines": 99,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "xtonum": {
      "start_point": [
        1869,
        0
      ],
      "end_point": [
        1883,
        1
      ],
      "content": "static int\nxtonum (int *pval, const char *src, int base, int cnt)\n{\n  int i, val;\n\n  for (i = 0, val = 0; i < cnt; i++, src++)\n    {\n      int n = *(unsigned char *) src;\n      if (n > 127 || (n = to_num (n)) >= base)\n\tbreak;\n      val = val * base + n;\n    }\n  *pval = val;\n  return i;\n}",
      "lines": 15,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_c_quoted_length": {
      "start_point": [
        1885,
        0
      ],
      "end_point": [
        1913,
        1
      ],
      "content": "size_t\nwordsplit_c_quoted_length (const char *str, int quote_hex, int *quote)\n{\n  size_t len = 0;\n\n  *quote = 0;\n  for (; *str; str++)\n    {\n      if (strchr (\" \\\"\", *str))\n\t*quote = 1;\n\n      if (*str == ' ')\n\tlen++;\n      else if (*str == '\"')\n\tlen += 2;\n      else if (*str != '\\t' && *str != '\\\\' && ISPRINT (*str))\n\tlen++;\n      else if (quote_hex)\n\tlen += 3;\n      else\n\t{\n\t  if (wordsplit_c_quote_char (*str))\n\t    len += 2;\n\t  else\n\t    len += 4;\n\t}\n    }\n  return len;\n}",
      "lines": 29,
      "depth": 15,
      "decorators": [
        "size_t"
      ]
    },
    "wsplt_unquote_char": {
      "start_point": [
        1915,
        0
      ],
      "end_point": [
        1925,
        1
      ],
      "content": "int\nwsplt_unquote_char (const char *transtab, int c)\n{\n  while (*transtab && transtab[1])\n    {\n      if (*transtab++ == c)\n\treturn *transtab;\n      ++transtab;\n    }\n  return 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "wsplt_quote_char": {
      "start_point": [
        1927,
        0
      ],
      "end_point": [
        1936,
        1
      ],
      "content": "int\nwsplt_quote_char (const char *transtab, int c)\n{\n  for (; *transtab && transtab[1]; transtab += 2)\n    {\n      if (transtab[1] == c)\n\treturn *transtab;\n    }\n  return 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_c_unquote_char": {
      "start_point": [
        1938,
        0
      ],
      "end_point": [
        1942,
        1
      ],
      "content": "int\nwordsplit_c_unquote_char (int c)\n{\n  return wsplt_unquote_char (wordsplit_c_escape_tab, c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_c_quote_char": {
      "start_point": [
        1944,
        0
      ],
      "end_point": [
        1948,
        1
      ],
      "content": "int\nwordsplit_c_quote_char (int c)\n{\n  return wsplt_quote_char (wordsplit_c_escape_tab, c);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_string_unquote_copy": {
      "start_point": [
        1950,
        0
      ],
      "end_point": [
        2026,
        1
      ],
      "content": "void\nwordsplit_string_unquote_copy (struct wordsplit *ws, int inquote,\n\t\t\t       char *dst, const char *src, size_t n)\n{\n  int i = 0;\n  int c;\n\n  inquote = !!inquote;\n  while (i < n)\n    {\n      if (src[i] == '\\\\')\n\t{\n\t  ++i;\n\t  if (WRDSO_ESC_TEST (ws, inquote, WRDSO_XESC)\n\t      && (src[i] == 'x' || src[i] == 'X'))\n\t    {\n\t      if (n - i < 2)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i + 1,\n\t\t\t\t    16, 2);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off + 1;\n\t\t    }\n\t\t}\n\t    }\n\t  else if (WRDSO_ESC_TEST (ws, inquote, WRDSO_OESC)\n\t\t   && (unsigned char) src[i] < 128 && ISDIGIT (src[i]))\n\t    {\n\t      if (n - i < 1)\n\t\t{\n\t\t  *dst++ = '\\\\';\n\t\t  *dst++ = src[i++];\n\t\t}\n\t      else\n\t\t{\n\t\t  int off = xtonum (&c, src + i, 8, 3);\n\t\t  if (off == 0)\n\t\t    {\n\t\t      *dst++ = '\\\\';\n\t\t      *dst++ = src[i++];\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      *dst++ = c;\n\t\t      i += off;\n\t\t    }\n\t\t}\n\t    }\n\t  else if ((c = wsplt_unquote_char (ws->ws_escape[inquote], src[i])))\n\t    {\n\t      *dst++ = c;\n\t      ++i;\n\t    }\n\t  else\n\t    {\n\t      if (WRDSO_ESC_TEST (ws, inquote, WRDSO_BSKEEP))\n\t\t*dst++ = '\\\\';\n\t      *dst++ = src[i++];\n\t    }\n\t}\n      else\n\t*dst++ = src[i++];\n    }\n  *dst = 0;\n}",
      "lines": 77,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_c_quote_copy": {
      "start_point": [
        2028,
        0
      ],
      "end_point": [
        2065,
        1
      ],
      "content": "void\nwordsplit_c_quote_copy (char *dst, const char *src, int quote_hex)\n{\n  for (; *src; src++)\n    {\n      if (*src == '\"')\n\t{\n\t  *dst++ = '\\\\';\n\t  *dst++ = *src;\n\t}\n      else if (*src != '\\t' && *src != '\\\\' && ISPRINT (*src))\n\t*dst++ = *src;\n      else\n\t{\n\t  char tmp[4];\n\n\t  if (quote_hex)\n\t    {\n\t      snprintf (tmp, sizeof tmp, \"%%%02X\", *(unsigned char *) src);\n\t      memcpy (dst, tmp, 3);\n\t      dst += 3;\n\t    }\n\t  else\n\t    {\n\t      int c = wordsplit_c_quote_char (*src);\n\t      *dst++ = '\\\\';\n\t      if (c)\n\t\t*dst++ = c;\n\t      else\n\t\t{\n\t\t  snprintf (tmp, sizeof tmp, \"%03o\", *(unsigned char *) src);\n\t\t  memcpy (dst, tmp, 3);\n\t\t  dst += 3;\n\t\t}\n\t    }\n\t}\n    }\n}",
      "lines": 38,
      "depth": 19,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_process_list": {
      "start_point": [
        2093,
        0
      ],
      "end_point": [
        2152,
        1
      ],
      "content": "static int\nwordsplit_process_list (struct wordsplit *wsp, size_t start)\n{\n  struct exptab *p;\n  \n  if (wsp->ws_flags & WRDSF_NOSPLIT)\n    {\n      /* Treat entire input as a quoted argument */\n      if (wordsplit_add_segm (wsp, start, wsp->ws_len, _WSNF_QUOTE))\n\treturn wsp->ws_errno;\n    }\n  else\n    {\n      int rc;\n\n      while ((rc = scan_word (wsp, start)) == _WRDS_OK)\n\tstart = skip_delim (wsp);\n      /* Make sure tail element is not joinable */\n      if (wsp->ws_tail)\n\twsp->ws_tail->flags &= ~_WSNF_JOIN;\n      if (rc == _WRDS_ERR)\n\treturn wsp->ws_errno;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    {\n      wsp->ws_debug (\"(%02d) %s\", wsp->ws_lvl, _(\"Initial list:\"));\n      wordsplit_dump_nodes (wsp);\n    }\n\n  for (p = exptab; p->descr; p++)\n    {\n      if ((p->opt & EXPOPT_NEG)\n\t  ? !(wsp->ws_flags & p->flag) : (wsp->ws_flags & p->flag))\n\t{\n\t  if (p->opt & EXPOPT_COALESCE)\n\t    {\n\t      if (wsnode_coalesce (wsp))\n\t\tbreak;\n\t      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t\t{\n\t\t  wsp->ws_debug (\"(%02d) %s\", wsp->ws_lvl,\n\t\t\t\t _(\"Coalesced list:\"));\n\t\t  wordsplit_dump_nodes (wsp);\n\t\t}\n\t    }\n\t  if (p->expansion)\n\t    {\n\t      if (p->expansion (wsp))\n\t\tbreak;\n\t      if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t\t{\n\t\t  wsp->ws_debug (\"(%02d) %s\", wsp->ws_lvl, _(p->descr));\n\t\t  wordsplit_dump_nodes (wsp);\n\t\t}\n\t    }\n\t}\n    }\n  return wsp->ws_errno;\n}",
      "lines": 60,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_run": {
      "start_point": [
        2154,
        0
      ],
      "end_point": [
        2217,
        1
      ],
      "content": "static int\nwordsplit_run (const char *command, size_t length, struct wordsplit *wsp,\n               int flags, int lvl)\n{\n  int rc;\n  size_t start;\n  const char *cmdptr;\n  size_t cmdlen;\n\n  if (!command)\n    {\n      if (!(flags & WRDSF_INCREMENTAL))\n\treturn EINVAL;\n\n      start = skip_delim (wsp);\n      if (wsp->ws_endp == wsp->ws_len)\n\treturn _wsplt_seterr (wsp, WRDSE_NOINPUT);\n\n      cmdptr = wsp->ws_input + wsp->ws_endp;\n      cmdlen = wsp->ws_len - wsp->ws_endp;\n      wsp->ws_flags |= WRDSF_REUSE;\n      wordsplit_init0 (wsp);\n    }\n  else\n    {\n      cmdptr = command;\n      cmdlen = length;\n      start = 0;\n      rc = wordsplit_init (wsp, cmdptr, cmdlen, flags);\n      if (rc)\n\treturn rc;\n      wsp->ws_lvl = lvl;\n    }\n\n  if (wsp->ws_flags & WRDSF_SHOWDBG)\n    wsp->ws_debug (_(\"(%02d) Input:%.*s;\"), wsp->ws_lvl, (int) cmdlen, cmdptr);\n\n  rc = wordsplit_process_list (wsp, start);\n  if (rc == 0 && (flags & WRDSF_INCREMENTAL))\n    {\n      while (!wsp->ws_head && wsp->ws_endp < wsp->ws_len)\n\t{\n\t  start = skip_delim (wsp);\n\t  if (wsp->ws_flags & WRDSF_SHOWDBG)\n\t    {\n\t      cmdptr = wsp->ws_input + wsp->ws_endp;\n\t      cmdlen = wsp->ws_len - wsp->ws_endp;\n\t      wsp->ws_debug (_(\"(%02d) Restart:%.*s;\"),\n\t\t\t     wsp->ws_lvl, (int) cmdlen, cmdptr);\n\t    }\n\t  rc = wordsplit_process_list (wsp, start);\n\t  if (rc)\n\t    break;\n\t}\n    }\n  if (rc)\n    {\n      wordsplit_free_nodes (wsp);\n      return rc;\n    }\n  wordsplit_finish (wsp);\n  wordsplit_free_nodes (wsp);\n  return wsp->ws_errno;\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wordsplit_len": {
      "start_point": [
        2219,
        0
      ],
      "end_point": [
        2224,
        1
      ],
      "content": "int\nwordsplit_len (const char *command, size_t length, struct wordsplit *wsp, \n               int flags)\n{\n  return wordsplit_run (command, length, wsp, flags, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "wordsplit": {
      "start_point": [
        2226,
        0
      ],
      "end_point": [
        2230,
        1
      ],
      "content": "int\nwordsplit (const char *command, struct wordsplit *ws, int flags)\n{\n  return wordsplit_len (command, command ? strlen (command) : 0, ws, flags);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "wordsplit_free_words": {
      "start_point": [
        2232,
        0
      ],
      "end_point": [
        2247,
        1
      ],
      "content": "void\nwordsplit_free_words (struct wordsplit *ws)\n{\n  size_t i;\n\n  for (i = 0; i < ws->ws_wordc; i++)\n    {\n      char *p = ws->ws_wordv[ws->ws_offs + i];\n      if (p)\n\t{\n\t  free (p);\n\t  ws->ws_wordv[ws->ws_offs + i] = NULL;\n\t}\n    }\n  ws->ws_wordc = 0;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_free_envbuf": {
      "start_point": [
        2249,
        0
      ],
      "end_point": [
        2264,
        1
      ],
      "content": "void\nwordsplit_free_envbuf (struct wordsplit *ws)\n{\n  if (ws->ws_flags & WRDSF_NOCMD)\n    return;\n  if (ws->ws_envbuf)\n    {\n      size_t i;\n\n      for (i = 0; ws->ws_envbuf[i]; i++)\n\tfree (ws->ws_envbuf[i]);\n      free (ws->ws_envbuf);\n      ws->ws_envidx = ws->ws_envsiz = 0;\n      ws->ws_envbuf = NULL;\n    }\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_clearerr": {
      "start_point": [
        2266,
        0
      ],
      "end_point": [
        2273,
        1
      ],
      "content": "void\nwordsplit_clearerr (struct wordsplit *ws)\n{\n  if (ws->ws_errno == WRDSE_USERERR)\n    free (ws->ws_usererr);\n  ws->ws_usererr = NULL;\n  ws->ws_errno = WRDSE_OK;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_free": {
      "start_point": [
        2275,
        0
      ],
      "end_point": [
        2282,
        1
      ],
      "content": "void\nwordsplit_free (struct wordsplit *ws)\n{\n  wordsplit_free_words (ws);\n  free (ws->ws_wordv);\n  ws->ws_wordv = NULL;\n  wordsplit_free_envbuf (ws);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_getwords": {
      "start_point": [
        2284,
        0
      ],
      "end_point": [
        2294,
        1
      ],
      "content": "void\nwordsplit_getwords (struct wordsplit *ws, size_t *wordc, char ***wordv)\n{\n  char **p = realloc (ws->ws_wordv,\n\t\t      (ws->ws_wordc + 1) * sizeof (ws->ws_wordv[0]));\n  *wordv = p ? p : ws->ws_wordv;\n  *wordc = ws->ws_wordc;\n  ws->ws_wordv = NULL;\n  ws->ws_wordc = 0;\n  ws->ws_wordn = 0;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "wordsplit_strerror": {
      "start_point": [
        2310,
        0
      ],
      "end_point": [
        2318,
        1
      ],
      "content": "const char *\nwordsplit_strerror (struct wordsplit *ws)\n{\n  if (ws->ws_errno == WRDSE_USERERR)\n    return ws->ws_usererr;\n  if (ws->ws_errno < _wordsplit_nerrs)\n    return _wordsplit_errstr[ws->ws_errno];\n  return N_(\"unknown error\");\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nwordsplit_strerror (struct wordsplit *ws)",
        "*"
      ]
    },
    "wordsplit_perror": {
      "start_point": [
        2320,
        0
      ],
      "end_point": [
        2334,
        1
      ],
      "content": "void\nwordsplit_perror (struct wordsplit *wsp)\n{\n  switch (wsp->ws_errno)\n    {\n    case WRDSE_QUOTE:\n      wsp->ws_error (_(\"missing closing %c (start near #%lu)\"),\n\t\t     wsp->ws_input[wsp->ws_endp],\n\t\t     (unsigned long) wsp->ws_endp);\n      break;\n\n    default:\n      wsp->ws_error (wordsplit_strerror (wsp));\n    }\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/distck.c": {
    "main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        17,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tint res;\n\tstruct grecs_version_info *packver, *libver;\n\n\tpackver = grecs_version_split(PACKAGE_STRING);\n\tlibver  = grecs_version();\n\tif (!(grecs_version_info_cmp(packver, libver, &res) == 0 &&\n\t      res == 0)) {\n\t\t    fprintf(stderr, \"grecs.h does not match package number\\n\");\n\t\t    return 1;\n\t}\n\treturn 0;\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/gcfenum.c": {
    "usage": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static void\nusage(const char *arg, FILE *fp, int code)\n{\n\tfprintf(fp,\n\t\t\"usage: %s [-h] [-locus] [-delim=char] [-reduce] file\\n\",\n\t\targ);\n\texit(code);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tchar *progname = argv[0];\n\tchar *file = NULL;\n\tstruct grecs_node *tree, *node;\n\tint flags = GRECS_NODE_FLAG_QUOTE|\n\t\t    GRECS_NODE_FLAG_PATH;\n\tint reduce = 0;\n\t\n\twhile (--argc) {\n\t\tchar *arg = *++argv;\n\t\tif (strcmp(arg, \"-locus\") == 0)\n\t\t\tflags |= GRECS_NODE_FLAG_LOCUS;\n\t\telse if (strncmp(arg, \"-delim=\", 7) == 0)\n\t\t\tflags |= arg[7];\n\t\telse if (strcmp(arg, \"-reduce\") == 0)\n\t\t\treduce = 1;\n\t\telse if (strcmp(arg, \"-h\") == 0)\n\t\t\tusage(progname, stdout, 0);\n\t\telse if (arg[0] == '-')\n\t\t\tusage(progname, stderr, 1);\n\t\telse\n\t\t\tfile = arg;\n\t}\n\t\n\tif (!file || argc)\n\t\tusage(progname, stderr, 1);\n\n\ttree = grecs_parse(file);\n\tif (!tree)\n\t\texit(1);\n\tif (reduce)\n\t\tgrecs_tree_reduce(tree, NULL, 0);\n\n\tfor (node = grecs_tree_first_node(tree); node;\n\t     node = grecs_next_node(node)) {\n\t\tgrecs_print_node(node, flags, stdout);\n\t\tfputc('\\n', stdout);\n\t}\n\tgrecs_tree_free(tree);\n\texit(0);\n}",
      "lines": 43,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/gcffmt.c": {
    "list_parser_types": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nlist_parser_types(const char *name, grecs_parser_t parser, void *data)\n{\n\tstruct list_helper *p = data;\n\tfprintf(p->file, \"%c%s\", p->delim, name);\n\tp->delim = '|';\n\treturn 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static void\nusage(const char *arg, FILE *fp, int code)\n{\n\tstruct list_helper lh;\n\t\n\tfprintf(fp,\n\t\t\"usage: %s [-h] [-list[=type]] [-locus] [-delim=char] [-reduce] [-sort]\\n\",\n\t\targ);\n\t\n\tfprintf(fp, \"    [-nopath] [-novalue] [-type\");\n\tlh.file = fp;\n\tlh.delim = '=';\n\tgrecs_enumerate_parsers(list_parser_types, &lh);\n\tfprintf(fp, \"] [-Idir] [-include=dir] file [file...]\\n\");\n\texit(code);\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_ident_cmp": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static int\nnode_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)\n{\n\treturn strcmp(a->ident, b->ident);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "list_parser": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nlist_parser(const char *name, grecs_parser_t parser, void *data)\n{\n\tprintf(\"%s\\n\", name);\n\treturn 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "find_parser": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\nfind_parser(const char *name, grecs_parser_t parser, void *data)\n{\n\tif (strcasecmp(name, (char*)data) == 0)\n\t\texit(0);\n\treturn 0;\n}",
      "lines": 7,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "set_parser": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nset_parser(const char *arg)\n{\n\tgrecs_parser_t p = grecs_get_parser_by_type(arg);\n\tif (p) {\n\t\tgrecs_parser_fun = p;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tchar *progname = argv[0];\n\tchar *file = NULL;\n\tstruct grecs_node *tree;\n\tint flags = GRECS_NODE_FLAG_DEFAULT;\n\tint reduce = 0;\n\tint sort = 0;\n\t\n\twhile (--argc) {\n\t\tchar *arg = *++argv;\n\t\tif (strcmp(arg, \"-locus\") == 0)\n\t\t\tflags |= GRECS_NODE_FLAG_LOCUS;\n\t\telse if (strcmp(arg, \"-nopath\") == 0)\n\t\t\tflags &= ~GRECS_NODE_FLAG_PATH;\n\t\telse if (strcmp(arg, \"-novalue\") == 0)\n\t\t\tflags &= ~GRECS_NODE_FLAG_VALUE;\n\t\telse if (strncmp(arg, \"-delim=\", 7) == 0)\n\t\t\tflags |= arg[7];\n\t\telse if (strcmp(arg, \"-reduce\") == 0)\n\t\t\treduce = 1;\n\t\telse if (strcmp(arg, \"-sort\") == 0)\n\t\t\tsort = 1;\n\t\telse if (strcmp(arg, \"-h\") == 0)\n\t\t\tusage(progname, stdout, 0);\n\t\telse if (strcmp(arg, \"-list\") == 0) {\n\t\t\tgrecs_enumerate_parsers(list_parser, NULL);\n\t\t\texit(0);\n\t\t} else if (strncmp(arg, \"-list=\", 6) == 0) {\n\t\t\tgrecs_enumerate_parsers(find_parser, arg + 6);\n\t\t\texit(2);\n\t\t} else if (strncmp(arg, \"-type=\", 6) == 0) {\n\t\t\tif (set_parser(arg + 6))\n\t\t\t\tusage(progname, stderr, 1);\n\t\t} else if (strncmp(arg, \"-I\", 2) == 0)\n\t\t\tgrecs_preproc_add_include_dir(arg+2);\n\t\telse if (strncmp(arg, \"-include=\", 9) == 0)\n\t\t\tgrecs_preproc_add_include_dir(arg+9);\n\t\telse if (strcmp(arg, \"-x\") == 0)\n\t\t\tgrecs_gram_trace(1);\n\t\telse if (strcmp(arg, \"-X\") == 0)\n\t\t\tgrecs_lex_trace(1);\n\t\telse if (arg[0] == '-')\n\t\t\tusage(progname, stderr, 1);\n\t\telse {\n\t\t\tfile = arg;\n\t\t\t--argc;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!grecs_parser_fun) {\n\t\tfprintf(stderr, \"%s: requested type not supported\", progname);\n\t\texit(2);\n\t}\n\t\n\tif (!file)\n\t\tusage(progname, stderr, 1);\n\n\ttree = grecs_parse(file);\n\tif (!tree)\n\t\texit(1);\n\n\tfor (; argc; argc--) {\n\t\tchar *arg = *++argv;\n\t\tstruct grecs_node *node = grecs_parse(arg);\n\t\tif (!node)\n\t\t\texit(1);\n\t\tif (grecs_tree_join(tree, node)) {\n\t\t\tfprintf(stderr, \"join failed\\n\");\n\t\t\texit(1);\n\t\t}\n\t\tgrecs_tree_free(node);\n\t}\n\t\n\tif (reduce)\n\t\tgrecs_tree_reduce(tree, NULL, 0);\n\tif (sort)\n\t\tgrecs_tree_sort(tree, node_ident_cmp);\n\tgrecs_print_node(tree, flags, stdout);\n\tfputc('\\n', stdout);\n\tgrecs_tree_free(tree);\n\texit(0);\n}",
      "lines": 85,
      "depth": 24,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/gcfpeek.c": {
    "usage": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        31,
        1
      ],
      "content": "static void\nusage(const char *arg, FILE *fp, int code)\n{\n\tfprintf(fp,\n\t\t\"usage: %s [-h] [-locus] [-delim=char] [-nodesc] [-nopath] [-reduce] [-match] [-root=path] file path\\n\",\n\t\targ);\n\texit(code);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_parser": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        42,
        1
      ],
      "content": "int\nset_parser(const char *arg)\n{\n\tgrecs_parser_t p = grecs_get_parser_by_type(arg);\n\tif (p) {\n\t\tgrecs_parser_fun = p;\n\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tchar *progname = argv[0];\n\tchar *path = NULL;\n\tchar *file = NULL;\n\tstruct grecs_node *tree, *root, *node;\n\tint flags = GRECS_NODE_FLAG_DEFAULT;\n\tint rc = 2;\n\tint reduce = 0;\n\tint match = 0;\n\tchar *root_path = NULL;\n\t\n\twhile (--argc) {\n\t\tchar *arg = *++argv;\n\t\tif (strcmp(arg, \"-locus\") == 0)\n\t\t\tflags |= GRECS_NODE_FLAG_LOCUS;\n\t\telse if (strncmp(arg, \"-delim=\", 7) == 0)\n\t\t\tflags |= arg[7];\n\t\telse if (strcmp(arg, \"-reduce\") == 0)\n\t\t\treduce = 1;\n\t\telse if (strcmp(arg, \"-match\") == 0)\n\t\t\tmatch = 1;\n\t\telse if (strcmp(arg, \"-nodesc\") == 0)\n\t\t\tflags &= ~GRECS_NODE_FLAG_DESCEND;\n\t\telse if (strcmp(arg, \"-nopath\") == 0)\n\t\t\tflags &= ~GRECS_NODE_FLAG_PATH;\n\t\telse if (strncmp(arg, \"-type=\", 6) == 0) {\n\t\t\tif (set_parser(arg + 6))\n\t\t\t\tusage(progname, stderr, 1);\n\t\t} else if (strncmp(arg, \"-root=\", 6) == 0)\n\t\t\troot_path = arg + 6;\n\t\telse if (strcmp(arg, \"-h\") == 0)\n\t\t\tusage(progname, stdout, 0);\n\t\telse if (arg[0] == '-')\n\t\t\tusage(progname, stderr, 1);\n\t\telse if (file) {\n\t\t\tif (path)\n\t\t\t\tusage(progname, stderr, 1);\n\t\t\telse\n\t\t\t\tpath = arg;\n\t\t} else\n\t\t\tfile = arg;\n\t}\n\t\n\tif (!file || !path || argc)\n\t\tusage(progname, stderr, 1);\n\n\ttree = grecs_parse(file);\n\tif (!tree)\n\t\texit(1);\n\tif (reduce)\n\t\tgrecs_tree_reduce(tree, NULL, 0);\n\n\tif (root_path) {\n\t\troot = grecs_find_node(tree, root_path);\n\t\tif (!root) {\n\t\t\tfprintf(stderr, \"%s: node %s not found\\n\",\n\t\t\t\tprogname, root_path);\n\t\t\texit(1);\n\t\t}\n\t} else\n\t\troot = tree;\n\t\n\tif (match) {\n\t\tgrecs_match_buf_t match_buf;\n\n\t\tfor (node = grecs_match_first(root, path, &match_buf);\n\t\t     node;\n\t\t     node = grecs_match_next(match_buf)) {\n\t\t\trc = 0;\n\t\t\tgrecs_print_node(node, flags, stdout);\n\t\t\tfputc('\\n', stdout);\n\t\t}\n\t\tgrecs_match_buf_free(match_buf);\n\t} else {\n\t\tfor (node = root; node; node = node->next) {\n\t\t\tnode = grecs_find_node(node, path);\n\t\t\tif (!node)\n\t\t\t\tbreak;\n\t\t\trc = 0;\n\t\t\tgrecs_print_node(node, flags, stdout);\n\t\t\tfputc('\\n', stdout);\n\t\t}\n\t}\n\tgrecs_tree_free(tree);\n\texit(rc);\n}",
      "lines": 88,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/gcfset.c": {
    "cb_logging_facility": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\ncb_logging_facility(GRECS_CB_ARGS)\n{\n\tGRECS_CB_AUTO\n\t\t\n\tif (cmd != grecs_callback_set_value) {\n\t\tgrecs_error(locus, 0, \"Unexpected block statement\");\n\t\treturn 1;\n\t}\n\tif (!value || value->type != GRECS_TYPE_STRING) {\n\t\tgrecs_error(locus, 0, \"expected string argument\");\n\t\treturn 1;\n\t}\n\n\t*(char**)varptr = grecs_strdup(value->v.string);\n\treturn 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cb_program": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static int\ncb_program(GRECS_CB_ARGS)\n{\n\tstruct program *prog;\n\tvoid **pdata = cb_data;\n\tGRECS_CB_AUTO\n\n\tswitch (cmd) {\n\tcase grecs_callback_section_begin:\n\t\tif (!value || value->type != GRECS_TYPE_STRING) {\n\t\t\tgrecs_error(locus, 0, \"tag must be a string\");\n\t\t\treturn 0;\n\t\t}\n\t\tprog = grecs_zalloc(sizeof(*prog));\n\t\tprog->name = grecs_strdup(value->v.string);\n\t\tprog->locus = *locus;\n\t\t*pdata = prog;\n\t\tbreak;\n\n\tcase grecs_callback_section_end:\n\t\tprog = *pdata;\n\t\tif (!proglist)\n\t\t\tproglist = grecs_list_create();\n\t\tgrecs_list_append(proglist, prog);\n\t\tbreak;\n\n\tcase grecs_callback_set_value:\n\t\tgrecs_error(locus, 0, \"invalid use of block statement\");\n\t}\n\treturn 0;\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "print_logging_setup": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\nprint_logging_setup(struct logging_setup *p)\n{\n\tprintf(\"logging: %d/%s/%s/%d\\n\",\n\t       p->use_syslog, S(p->facility), S(p->tag), p->print_priority);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_program": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static void\nprint_program(struct program *prog)\n{\n\tprintf(\"Program %s:\\n\", prog->name);\n\tprintf(\"scalar = %s\\n\", S(prog->scalar_string));\n\tprint_logging_setup(&prog->logging_setup);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "node_ident_cmp": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        191,
        1
      ],
      "content": "static int\nnode_ident_cmp(struct grecs_node const *a, struct grecs_node const *b)\n{\n\treturn strcmp(a->ident, b->ident);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static void\nusage(const char *arg, FILE *fp, int code)\n{\n\tfprintf(fp, \"usage: %s [-h] [-cfhelp] [-reduce] [-sort] [-print] [-locus] [-noset] file\\n\", arg);\n\texit(code);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tchar *progname = argv[0];\n\tconst char *file = NULL;\n\tstruct grecs_node *tree;\n\tint cfhelp = 0;\n\tint reduce = 0;\n\tint print = 0;\n\tint sort = 0;\n\tint flags = GRECS_NODE_FLAG_DEFAULT;\n\tint dontset = 0;\n\t\n\twhile (--argc) {\n\t\tchar *arg = *++argv;\n\t\tif (strcmp(arg, \"-cfhelp\") == 0)\n\t\t\tcfhelp = 1;\n\t\telse if (strcmp(arg, \"-h\") == 0)\n\t\t\tusage(progname, stdout, 0);\n\t\telse if (strcmp(arg, \"-reduce\") == 0)\n\t\t\treduce = 1;\n\t\telse if (strcmp(arg, \"-print\") == 0)\n\t\t\tprint = 1;\n\t\telse if (strcmp(arg, \"-locus\") == 0)\n\t\t\tflags |= GRECS_NODE_FLAG_LOCUS;\n\t\telse if (strncmp(arg, \"-delim=\", 7) == 0)\n\t\t\tflags |= arg[7];\n\t\telse if (strcmp(arg, \"-sort\") == 0)\n\t\t\tsort = 1;\n\t\telse if (strcmp(arg, \"-noset\") == 0)\n\t\t\tdontset = 1;\n\t\telse if (arg[0] == '-')\n\t\t\tusage(progname, stderr, 1);\n\t\telse if (file)\n\t\t\tusage(progname, stderr, 1);\n\t\telse\n\t\t\tfile = arg;\n\t}\n\t\t\t\t\n\tif ((!file && !cfhelp) || argc)\n\t\tusage(progname, stderr, 1);\n\n\tif (cfhelp) {\n\t\tstatic char docstring[] =\n\t\t\t\"Sample configuration file structure.\\n\";\n\t\tgrecs_print_docstring(docstring, 0, stdout);\n\t\tgrecs_print_statement_array(main_kwtab, 1, 0, stdout);\n\t\texit(0);\n\t}\n\t\n\ttree = grecs_parse(file);\n\tif (!tree)\n\t\texit(2);\n\tif (reduce)\n\t\tgrecs_tree_reduce(tree, main_kwtab, GRECS_AGGR);\n\tif (sort)\n\t\tgrecs_tree_sort(tree, node_ident_cmp);\n\tif (print) {\n\t\tgrecs_print_node(tree, flags, stdout);\n\t\tfputc('\\n', stdout);\n\t}\n\tif (dontset)\n\t\texit(0);\n\tif (grecs_tree_process(tree, main_kwtab))\n\t\texit(2);\n\tgrecs_tree_free(tree);\n\t\n\tprintf(\"Global settings:\\n\");\n\tprintf(\"scalar = %s\\n\", S(scalar_string));\n\tif (listvar) {\n\t\tstruct grecs_list_entry *ep;\n\t\tprintf(\"listvar =\");\n\t\tfor (ep = listvar->head; ep; ep = ep->next)\n\t\t\tprintf(\" \\\"%s\\\"\", (char*)ep->data);\n\t\tputchar('\\n');\n\t}\n\t\n\tprint_logging_setup(&logging_setup);\n\n\tif (proglist) {\n\t\tstruct grecs_list_entry *ep;\n\t\t\n\t\tprintf(\"Programs configured: %lu\\n\",\n\t\t       (unsigned long) grecs_list_size(proglist));\n\t\tfor (ep = proglist->head; ep; ep = ep->next)\n\t\t\tprint_program(ep->data);\n\t}\n\t\n\texit(0);\n}",
      "lines": 90,
      "depth": 18,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/gcfver.c": {
    "main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tstruct grecs_version_info *vinfo;\n\tint res;\n\t\n\tif (argc > 3) {\n\t\tfprintf(stderr, \"usage: %s [version [version]]\\n\", argv[0]);\n\t\texit(1);\n\t}\n\tif (argc == 2)\n\t\texit(!grecs_version_ok(argv[1]));\n\tif (argc == 3)\n\t\texit(grecs_version_cmp(argv[1], argv[2], &res) ? 1 :\n\t\t     res == 0 ? 0 : res < 0 ? 2 : 3);\n\t/* Default action: */\n\tvinfo = grecs_version();\n\tprintf(\"package: %s\\n\", vinfo->package);\n\tprintf(\"version: %s\\n\", vinfo->version);\n\tprintf(\"major: %d\\n\", vinfo->major);\n\tprintf(\"minor: %d\\n\", vinfo->minor);\n\tprintf(\"patch: %d\\n\", vinfo->patch);\n\tprintf(\"suffix:\");\n\tif (vinfo->suffix && vinfo->suffix[0])\n\t\tprintf(\" %s\", vinfo->suffix);\n\tputchar('\\n');\n\tgrecs_version_info_free(vinfo);\n\texit(0);\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/json.c": {
    "printer": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static void\nprinter(void *d, char const *buf, size_t size)\n{\n\tFILE *fp = d;\n\tfwrite(buf, size, 1, fp);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "usage": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\nusage(const char *arg, FILE *fp, int code)\n{\n\tfprintf(fp,\n\t\t\"usage: %s [-file=FILE][-indent=N][-precision=N] [expr]\\n\",\n\t\targ);\n\texit(code);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tchar *progname = argv[0];\n\tchar *file = NULL;\n\tchar *input;\n\tsize_t size;\n\tstruct json_value *obj;\n\tchar *key = NULL;\n\t\n\twhile (--argc) {\n\t\tchar *arg = *++argv;\n\t\tif (strncmp(arg, \"-file=\", 6) == 0)\n\t\t\tfile = arg + 6;\n\t\telse if (strncmp(arg, \"-indent=\", 8) == 0)\n\t\t\tfmt.indent = atoi(arg + 8);\n\t\telse if (strncmp(arg, \"-search=\", 8) == 0)\n\t\t\tkey = arg + 8;\n\t\telse if (strncmp(arg, \"-precision=\", 11) == 0)\n\t\t\tfmt.precision = atoi(arg + 11);\n\t\telse if (arg[0] == '-')\n\t\t\tusage(progname, stderr, 1);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tif (file) {\n\t\tstruct stat st;\n\t\tint fd;\n\t\tssize_t n;\n\t\t\n\t\tif (argc != 0)\n\t\t\tusage(progname, stderr, 1);\n\t\t\n\t\tfd = open(file, O_RDONLY);\n\t\tif (fd == -1) {\n\t\t\tperror(file);\n\t\t\treturn 2;\n\t\t}\n\t\tif (fstat(fd, &st)) {\n\t\t\tperror(\"fstat\");\n\t\t\treturn 2;\n\t\t}\n\t\tsize = (size_t) st.st_size;\n\t\tif (size != st.st_size)\n\t\t\tabort();\n\t\tinput = grecs_malloc(size + 1);\n\t\tn = read(fd, input, size);\n\t\tif (n == -1) {\n\t\t\tperror(\"read\");\n\t\t\treturn 2;\n\t\t}\n\t\tif (n != size) {\n\t\t\tfprintf(stderr, \"%s: short read from %s\\n\",\n\t\t\t\tprogname, file);\n\t\t\treturn 2;\n\t\t}\n\t\tinput[n] = 0;\n\t\tclose(fd);\n\t} else if (argc == 1) {\n\t\tif (file)\n\t\t\tusage(progname, stderr, 1);\n\t\tinput = *argv;\n\t\tsize = strlen(input);\n\t} else\n\t\tusage(progname, stderr, 1);\n\t\n\tobj = json_parse_string(input, size);\n\tif (!obj) {\n\t\tjson_err_locus.beg.file = json_err_locus.end.file =\n\t\t\tfile ? file : \"input\";\n\t\tgrecs_error(&json_err_locus, 0, \"%s\", json_err_diag);\n\t\treturn 3;\n\t}\n\tif (key) {\n\t\tstruct json_value *p = json_value_lookup(obj, key);\n\t\tif (!p)\n\t\t\treturn 4;\n\t\tobj = p;\n\t}\n\tfmt.data = stdout;\n\tjson_format_value(obj, &fmt);\n\tputchar('\\n');\n\treturn 0;\n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/grecs/tests/wsp.c": {
    "kwxlat": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static int\nkwxlat (struct kwd *kwp, const char *str, int *res)\n{\n  for (; kwp->name; kwp++)\n    if (strcmp (kwp->name, str) == 0)\n      {\n\t*res = kwp->tok;\n\treturn 0;\n      }\n  return -1;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "help": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static void\nhelp ()\n{\n  size_t i;\n  \n  printf (\"usage: %s [options] [VAR=VALUE...]\\n\", progname);\n  printf (\"options are:\\n\");\n  printf (\" [-]trimnl\\n\");\n  printf (\" [-]plaintext\\n\");\n  printf (\" -env\\n\");\n  printf (\" env sys|none|null\\n\");\n  putchar ('\\n');\n  for (i = 0; bool_keytab[i].name; i++)\n    printf (\" [-]%s\\n\", bool_keytab[i].name);\n  putchar ('\\n');\n  for (i = 0; string_keytab[i].name; i++)\n    {\n      printf (\" -%s\\n\", string_keytab[i].name);\n      printf (\" %s ARG\\n\", string_keytab[i].name);\n    }\n  printf (\" escape-word ARG\\n\");\n  printf (\" escape-quote ARG\\n\");\n  putchar ('\\n');\n  for (i = 0; opt_keytab[i].name; i++)\n    {\n      printf (\" [-]%s\\n\", opt_keytab[i].name);\n    }\n  putchar ('\\n');\n  printf (\" -dooffs\\n\");\n  printf (\" dooffs COUNT ARGS...\\n\");\n  exit (0);\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "print_qword": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void\nprint_qword (const char *word, int plaintext)\n{\n  static char *qbuf = NULL;\n  static size_t qlen = 0;\n  int quote;\n  size_t size = wordsplit_c_quoted_length (word, 0, &quote);\n\n  if (plaintext)\n    {\n      printf (\"%s\", word);\n      return;\n    }\n\n  if (*word == 0)\n    quote = 1;\n  \n  if (size >= qlen)\n    {\n      qlen = size + 1;\n      qbuf = realloc (qbuf, qlen);\n      assert (qbuf != NULL);\n    }\n  wordsplit_c_quote_copy (qbuf, word, 0);\n  qbuf[size] = 0;\n  if (quote)\n    printf (\"\\\"%s\\\"\", qbuf);\n  else\n    printf (\"%s\", qbuf);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "make_env_kv": {
      "start_point": [
        153,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static char **\nmake_env_kv ()\n{\n  size_t i, j, size;\n  char **newenv;\n  \n  /* Count the number of entries */\n  for (i = 0; environ[i]; i++)\n    ;\n\n  size = i * 2 + 1;\n  newenv = calloc (size, sizeof (newenv[0]));\n  assert (newenv != NULL);\n\n  for (i = j = 0; environ[i]; i++)\n    {\n      size_t len = strcspn (environ[i], \"=\");\n      char *p = malloc (len+1);\n      assert (p != NULL);\n      memcpy (p, environ[i], len);\n      p[len] = 0;\n      newenv[j++] = p;\n      p = strdup (environ[i] + len + 1);\n      assert (p != NULL);\n      newenv[j++] = p;\n    }\n  newenv[j] = NULL;\n  return newenv;\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "**\nmake_env_kv ()",
        "*",
        "*\nmake_env_kv ()",
        "*"
      ]
    },
    "wsp_getvar": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static int\nwsp_getvar (char **ret, const char *vptr, size_t vlen, void *data)\n{\n  char **base = data;\n  int i;\n\n  for (i = 0; base[i]; i++)\n    {\n      size_t l = strcspn (base[i], \"=\");\n      if (l == vlen && memcmp (base[i], vptr, vlen) == 0)\n\t{\n\t  char *p = strdup (base[i] + vlen + 1);\n\t  if (p == NULL)\n\t    return WRDSE_NOSPACE;\n\t  *ret = p;\n\t  return WRDSE_OK;\n\t}\n    }\n  return WRDSE_UNDEF;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "wsp_runcmd": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static int\nwsp_runcmd (char **ret, const char *str, size_t len, char **argv, void *closure)\n{\n  FILE *fp;\n  char *cmd;\n  int c, lastc;\n  char *buffer = NULL;\n  size_t bufsize = 0;\n  size_t buflen = 0;\n  \n  cmd = malloc (len + 1);\n  if (!cmd)\n    return WRDSE_NOSPACE;\n  memcpy (cmd, str, len);\n  cmd[len] = 0;\n\n  fp = popen(cmd, \"r\");\n  if (!fp)\n    {\n      size_t size = 0;\n      ret = NULL;\n      if (grecs_asprintf (ret, &size, \"can't run %s: %s\",\n\t\t\t  cmd, strerror (errno)))\n\treturn WRDSE_NOSPACE;\n      else\n\treturn WRDSE_USERERR;\n    }\n\n  while ((c = fgetc (fp)) != EOF)\n    {\n      lastc = c;\n      if (c == '\\n')\n\tc = ' ';\n      if (buflen == bufsize)\n\t{\n\t  char *p;\n\t  \n\t  if (bufsize == 0)\n\t    bufsize = 80;\n\t  else\n\t    bufsize *= 2;\n\t  p = realloc (buffer, bufsize);\n\t  if (!p)\n\t    {\n\t      free (buffer);\n\t      free (cmd);\n\t      return WRDSE_NOSPACE;\n\t    }\n\t  buffer = p;\n\t}\n      buffer[buflen++] = c;\n    }\n\n  if (buffer)\n    {\n      if (lastc == '\\n')\n\t--buflen;\n      buffer[buflen] = 0;\n    }\n  \n  pclose (fp);\n  free (cmd);\n\n  *ret = buffer;\n  return WRDSE_OK;\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "set_escape_string": {
      "start_point": [
        285,
        0
      ],
      "end_point": [
        318,
        1
      ],
      "content": "static void\nset_escape_string (wordsplit_t *ws, int *wsflags, int q, const char *str)\n{\n  if (*str == ':')\n    {\n      while (*++str != ':')\n\t{\n\t  int f;\n\t  switch (*str)\n\t    {\n\t    case '+':\n\t      f = WRDSO_BSKEEP;\n\t      break;\n\n\t    case '0':\n\t      f = WRDSO_OESC;\n\t      break;\n\n\t    case 'x':\n\t      f = WRDSO_XESC;\n\t      break;\n\n\t    default:\n\t      fprintf (stderr, \"%s: invalid escape flag near %s\\n\",\n\t\t       progname, str);\n\t      abort ();\n\t    }\n\t  WRDSO_ESC_SET (ws, q, f);\n\t}\n      *wsflags |= WRDSF_OPTIONS;\n      ++str;\n    }\n  ws->ws_escape[q] = str;\n}",
      "lines": 34,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        320,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  char buf[1024], *ptr, *saved_ptr;\n  int i, offarg = 0;\n  int trimnl_option = 0;\n  int plaintext_option = 0;\n  int wsflags = (WRDSF_DEFFLAGS & ~WRDSF_NOVAR) |\n                 WRDSF_ENOMEMABRT |\n                 WRDSF_SHOWERR;\n  wordsplit_t ws;\n  int next_call = 0;\n  char *fenvbase[128];\n  size_t fenvidx = 0;\n  size_t fenvmax = sizeof (fenvbase) / sizeof (fenvbase[0]);\n  int use_env = env_sys;\n  \n  progname = argv[0];\n\n  ws.ws_options = 0;\n  for (i = 1; i < argc; i++)\n    {\n      char *opt = argv[i];\n      int negate;\n      int flag;\n\n      if (opt[0] == '-')\n\t{\n\t  negate = 1;\n\t  opt++;\n\t}\n      else if (opt[0] == '+')\n\t{\n\t  negate = 0;\n\t  opt++;\n\t}\n      else\n\tnegate = 0;\n\n      if (strcmp (opt, \"h\") == 0 ||\n\t  strcmp (opt, \"help\") == 0 ||\n\t  strcmp (opt, \"-help\") == 0)\n\t{\n\t  help ();\n\t}\n\t  \n      if (strcmp (opt, \"trimnl\") == 0)\n\t{\n\t  trimnl_option = !negate;\n\t  continue;\n\t}\n\n      if (strcmp (opt, \"plaintext\") == 0)\n\t{\n\t  plaintext_option = !negate;\n\t  continue;\n\t}\n\n      if (strcmp (opt, \"env\") == 0)\n\t{\n\t  if (negate)\n\t    use_env = env_none;\n\t  else\n\t    {\n\t      i++;\n\t      if (i == argc)\n\t\t{\n\t\t  fprintf (stderr, \"%s: missing argument for env\\n\",\n\t\t\t   progname);\n\t\t  exit (1);\n\t\t}\n\n\t      if (kwxlat (env_keytab, argv[i], &use_env))\n\t\t{\n\t\t  fprintf (stderr, \"%s: invalid argument for env\\n\",\n\t\t\t   progname);\n\t\t  exit (1);\n\t\t}\n\t    }\n\t  continue;\n\t}\n      \n      if (kwxlat (bool_keytab, opt, &flag) == 0)\n\t{\n\t  if (negate)\n\t    wsflags &= ~flag;\n\t  else\n\t    wsflags |= flag;\n\t  continue;\n\t}\n\n      if (kwxlat (string_keytab, opt, &flag) == 0)\n\t{\n\t  if (negate)\n\t    wsflags &= ~flag;\n\t  else\n\t    {\n\t      i++;\n\t      if (i == argc)\n\t\t{\n\t\t  fprintf (stderr, \"%s: missing argument for %s\\n\",\n\t\t\t   progname, opt);\n\t\t  exit (1);\n\t\t}\n\t      \n\t      switch (flag)\n\t\t{\n\t\tcase WRDSF_DELIM:\n\t\t  ws.ws_delim = argv[i];\n\t\t  break;\n\n\t\tcase WRDSF_COMMENT:\n\t\t  ws.ws_comment = argv[i];\n\t\t  break;\n\n\t\tcase WRDSF_ESCAPE:\n\t\t  set_escape_string (&ws, &wsflags, 0, argv[i]);\n\t\t  set_escape_string (&ws, &wsflags, 1, argv[i]);\n\t\t  break;\n\t\t}\n\t      \n\t      wsflags |= flag;\n\t    }\n\t  continue;\n\t}\n\n      if (strcmp (opt, \"escape-word\") == 0\n\t  || strcmp (opt, \"escape-quote\") == 0)\n\t{\n\t  int q = opt[7] == 'q';\n\t  \n\t  i++;\n\t  if (i == argc)\n\t    {\n\t      fprintf (stderr, \"%s: missing argument for %s\\n\",\n\t\t       progname, opt);\n\t      exit (1);\n\t    }\n\t  if (!(wsflags & WRDSF_ESCAPE))\n\t    {\n\t      wsflags |= WRDSF_ESCAPE;\n\t      ws.ws_escape[!q] = NULL;\n\t    }\n\t  set_escape_string (&ws, &wsflags, q, argv[i]);\n\t  continue;\n\t}\n\n      if (strcmp (opt, \"dooffs\") == 0)\n\t{\n\t  if (negate)\n\t    wsflags &= ~WRDSF_DOOFFS;\n\t  else\n\t    {\n\t      char *p;\n\n\t      i++;\n\t      \n\t      if (i == argc)\n\t\t{\n\t\t  fprintf (stderr, \"%s: missing arguments for %s\\n\",\n\t\t\t   progname, opt);\n\t\t  exit (1);\n\t\t}\n\t      ws.ws_offs = strtoul (argv[i], &p, 10);\n\t      if (*p)\n\t\t{\n\t\t  fprintf (stderr, \"%s: invalid number: %s\\n\",\n\t\t\t   progname, argv[i]);\n\t\t  exit (1);\n\t\t}\n\n\t      i++;\n\t      if (i + ws.ws_offs > argc)\n\t\t{\n\t\t  fprintf (stderr, \"%s: not enough arguments for %s\\n\",\n\t\t\t   progname, opt);\n\t\t  exit (1);\n\t\t}\n\t      offarg = i;\n\t      i += ws.ws_offs - 1;\n\t      wsflags |= WRDSF_DOOFFS;\n\t    }\n\t  continue;\n\t}\n\n      if (kwxlat (opt_keytab, opt, &flag) == 0)\n\t{\n\t  wsflags |= WRDSF_OPTIONS;\n\t  if (negate)\n\t    ws.ws_options &= ~flag;\n\t  else\n\t    ws.ws_options |= flag;\n\t  continue;\n\t}\n      \n      if (strchr (opt, '='))\n\t{\n\t  assert (fenvidx < fenvmax - 1);\n\t  fenvbase[fenvidx++] = opt;\n\t  continue;\n\t}\n      \n      fprintf (stderr, \"%s: unrecognized argument: %s\\n\",\n\t       progname, opt);\n      exit (1);\n    }\n\n  if (fenvidx)\n    {\n      fenvbase[fenvidx] = NULL;\n      wsflags |= WRDSF_GETVAR | WRDSF_CLOSURE;\n      ws.ws_getvar = wsp_getvar;\n      ws.ws_closure = fenvbase;\n    }\n\n  switch (use_env)\n    {\n    case env_null:\n      wsflags |= WRDSF_ENV;\n      ws.ws_env = NULL;\n      break;\n\n    case env_none:\n      break;\n\n    case env_sys:\n      wsflags |= WRDSF_ENV;\n      if (wsflags & WRDSF_ENV_KV)\n\tws.ws_env = (const char **) make_env_kv ();\n      else\n\tws.ws_env = (const char **) environ;\n      break;\n    }\n  \n  if (!(wsflags & WRDSF_NOCMD))\n    ws.ws_command = wsp_runcmd;\n  \n  if (wsflags & WRDSF_INCREMENTAL)\n    trimnl_option = 1;\n  \n  next_call = 0;\n  while ((ptr = fgets (buf, sizeof (buf), stdin)))\n    {\n      int rc;\n      size_t i;\n      \n      if (trimnl_option)\n\t{\n\t  size_t len = strlen (ptr);\n\t  if (len && ptr[len-1] == '\\n')\n\t    ptr[len-1] = 0;\n\t}\n      \n      if (wsflags & WRDSF_INCREMENTAL)\n\t{\n\t  if (next_call)\n\t    {\n\t      if (*ptr == 0)\n\t\tptr = NULL;\n\t      else\n\t\tfree (saved_ptr);\n\t    }\n\t  else\n\t    next_call = 1;\n\t  if (ptr)\n\t    {\n\t      ptr = saved_ptr = strdup (ptr);\n\t      assert (ptr != NULL);\n\t    }\n\t}\n\t\n      rc = wordsplit (ptr, &ws, wsflags);\n      if (rc)\n\t{\n\t  if (!(wsflags & WRDSF_SHOWERR))\n\t    wordsplit_perror (&ws);\n\t  continue;\n\t}\n\t  \n      if (offarg)\n\t{\n\t  for (i = 0; i < ws.ws_offs; i++)\n\t    ws.ws_wordv[i] = argv[offarg + i];\n\t  offarg = 0;\n\t}\n\n      wsflags |= WRDSF_REUSE | (ws.ws_flags & WRDSF_ENV);\n      printf (\"NF: %lu\", (unsigned long) ws.ws_wordc);\n      if (wsflags & WRDSF_DOOFFS)\n\tprintf (\" (%lu)\", (unsigned long) ws.ws_offs);\n      putchar ('\\n');\n      for (i = 0; i < ws.ws_offs; i++)\n\t{\n\t  printf (\"(%lu): \", (unsigned long) i);\n\t  print_qword (ws.ws_wordv[i], plaintext_option);\n\t  putchar ('\\n');\n\t}\n      for (; i < ws.ws_offs + ws.ws_wordc; i++)\n\t{\n\t  printf (\"%lu: \", (unsigned long) i);\n\t  print_qword (ws.ws_wordv[i], plaintext_option);\n\t  putchar ('\\n');\n\t}\n    }\n  return 0;\n}",
      "lines": 306,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/cmdline.h": {
    "print_dir": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "static int\nprint_dir(int flag, const char *dir, void *data)\n{\n\tFILE *fp = data;\n\tfprintf(fp, \"%s\\n\", dir);\n\treturn 0;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "help_hook": {
      "start_point": [
        386,
        0
      ],
      "end_point": [
        402,
        1
      ],
      "content": "static void\nhelp_hook(FILE *fp)\n{\n\tfprintf(fp,\n\t\t_(\"The optional CONFIG argument supplies the name of the \"\n\t\t  \"configuration file\\n\"\n\t          \"to use instead of %s.\\n\\n\"), DEFAULT_CONFFILE); \n\t/* TRANSLATORS: %s is one of: inotify, kqueue */\n\tfprintf(fp, _(\"This direvent uses %s interface.\\n\\n\"), INTERFACE);\n\n\tif (grecs_include_path_count(GRECS_STD_INCLUDE)) {\n\t\tfprintf(fp, _(\"Include search path:\\n\"));\n\t\tgrecs_foreach_include_dir(GRECS_STD_INCLUDE, print_dir, fp);\n\t} else\n\t\tfprintf(fp, _(\"No include search path.\\n\"));\n\tfprintf(fp, \"\\n\");\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "parse_options": {
      "start_point": [
        404,
        0
      ],
      "end_point": [
        641,
        1
      ],
      "content": "void\nparse_options(int argc, char *argv[], int *index)\n{\n\tproginfo.print_help_hook = help_hook;\n\t\n#line 111\n {\n#line 111\n  int c;\n#line 111\n\n#line 111\n  optind = 0;\n#line 111\n#ifdef HAVE_GETOPT_LONG\n#line 111\n  while ((c = getopt_long(argc, argv, \"dl:F:fI:T:P:tu:HhV\",\n#line 111\n\t\t\t  long_options, NULL)) != EOF)\n#line 111\n#else\n#line 111\n  while ((c = getopt(argc, argv, \"dl:F:fI:T:P:tu:HhV\")) != EOF)\n#line 111\n#endif\n#line 111\n    {\n#line 111\n      switch (c)\n#line 111\n\t{\n#line 111\n\tdefault:\n#line 111\n\t   \t   exit(EX_USAGE);\n#line 111\n\t#line 12 \"cmdline.opt\"\n\t case 'd':\n#line 12\n\t  {\n#line 12\n       \n\topt_debug_level++;\n\n#line 14\n\t     break;\n#line 14\n\t  }\n#line 18 \"cmdline.opt\"\n\t case 'l':\n#line 18\n\t  {\n#line 18\n\n\tif (strcmp(optarg, \"none\") == 0)\n\t\tlog_to_stderr = -1;\n\telse\n\t\tlog_to_stderr = get_priority(optarg);\n\n#line 23\n\t     break;\n#line 23\n\t  }\n#line 27 \"cmdline.opt\"\n\t case 'F':\n#line 27\n\t  {\n#line 27\n       \n\topt_facility = get_facility(optarg);\n\n#line 29\n\t     break;\n#line 29\n\t  }\n#line 33 \"cmdline.opt\"\n\t case 'f':\n#line 33\n\t  {\n#line 33\n       \n\topt_foreground++;\n\n#line 35\n\t     break;\n#line 35\n\t  }\n#line 39 \"cmdline.opt\"\n\t case 'I':\n#line 39\n\t  {\n#line 39\n\n        grecs_preproc_add_include_dir(optarg);\n\n#line 41\n\t     break;\n#line 41\n\t  }\n#line 45 \"cmdline.opt\"\n\t case 'T':\n#line 45\n\t  {\n#line 45\n\n\tself_test_prog = optarg;\n\n#line 47\n\t     break;\n#line 47\n\t  }\n#line 51 \"cmdline.opt\"\n\t case 'P':\n#line 51\n\t  {\n#line 51\n       \n\topt_pidfile = optarg;\n\n#line 53\n\t     break;\n#line 53\n\t  }\n#line 57 \"cmdline.opt\"\n\t case 't':\n#line 57\n\t  {\n#line 57\n       \n\tlint_only = 1;\n\n#line 59\n\t     break;\n#line 59\n\t  }\n#line 63 \"cmdline.opt\"\n\t case 'u':\n#line 63\n\t  {\n#line 63\n\n\topt_user = optarg;\n\tif (!getpwnam(opt_user)) {\n\t\tdiag(LOG_CRIT, \"no such user: %s\", opt_user);\n\t\texit(1);\n\t}\n\n#line 69\n\t     break;\n#line 69\n\t  }\n#line 73 \"cmdline.opt\"\n\t case 'H':\n#line 73\n\t  {\n#line 73\n\n\tconfig_help();\n\texit(0);\n\n#line 76\n\t     break;\n#line 76\n\t  }\n#line 79 \"cmdline.opt\"\n\t case 'h':\n#line 79\n\t  {\n#line 79\n\n#line 79\n\t\tgrecs_print_help(&proginfo);\n#line 79\n\t\texit(0);\n#line 79\n\t \n#line 79\n\t     break;\n#line 79\n\t  }\n#line 79 \"cmdline.opt\"\n\t case OPTION_USAGE:\n#line 79\n\t  {\n#line 79\n\n#line 79\n\t\tgrecs_print_usage(&proginfo);\n#line 79\n\t\texit(0);\n#line 79\n\t \n#line 79\n\t     break;\n#line 79\n\t  }\n#line 79 \"cmdline.opt\"\n\t case 'V':\n#line 79\n\t  {\n#line 79\n\n#line 79\n\t\t/* Give version */\n#line 79\n\t\tgrecs_print_version(&proginfo, stdout);\n#line 79\n\t\texit(0);\n#line 79\n\t \n#line 79\n\t     break;\n#line 79\n\t  }\n\n#line 111 \"cmdline.opt\"\n\t}\n#line 111\n    }\n#line 111\n  *index = optind;\n#line 111\n  if (cmdline_tree)\n#line 111\n    {\n#line 111\n      struct grecs_node *rn = grecs_node_create(grecs_node_root, NULL);\n#line 111\n      rn->down = cmdline_tree;\n#line 111\n      cmdline_tree = rn;\n#line 111\n    }\n#line 111\n }\n#line 111\n\n}",
      "lines": 238,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/src/config.c": {
    "get_facility": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nget_facility(const char *arg)\n{\n\tint f;\n\tchar *p;\n\n\terrno = 0;\n\tf = strtoul (arg, &p, 0);\n\tif (*p == 0 && errno == 0)\n\t\treturn f;\n\tif (trans_strtotok(kwfac, arg, &f)) {\n\t\tdiag(LOG_CRIT, _(\"unknown syslog facility: %s\"), arg);\n\t\texit(1);\n\t}\n\treturn f;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "get_priority": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nget_priority(const char *arg)\n{\n\tint f;\n\tchar *p;\n\n\terrno = 0;\n\tf = strtoul (arg, &p, 0);\n\tif (*p == 0 && errno == 0)\n\t\treturn f;\n\tif (trans_strtotok(kwpri, arg, &f)) {\n\t\tdiag(LOG_CRIT, _(\"unknown syslog priority: %s\"), arg);\n\t\texit(1);\n\t}\n\treturn f;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "assert_grecs_value_type": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "int\nassert_grecs_value_type(grecs_locus_t *locus,\n\t\t\tconst grecs_value_t *value, int type)\n{\n\tif (GRECS_VALUE_EMPTY_P(value)) {\n\t\tgrecs_error(locus, 0, _(\"expected %s\"),\n\t\t\t    grecs_data_type_string(type));\n\t\treturn 1;\n\t}\n\tif (value->type != type) {\n\t\tgrecs_error(locus, 0, _(\"expected %s, but found %s\"),\n\t\t\t    grecs_data_type_string(type),\n\t\t\t    grecs_data_type_string(value->type));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "cb_syslog_facility": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static int\ncb_syslog_facility(enum grecs_callback_command cmd, grecs_node_t *node,\n\t\t   void *varptr, void *cb_data)\n{\n\tgrecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *value = node->v.value;\n\tint fac;\n\n\tASSERT_SCALAR(cmd, locus);\n\tif (assert_grecs_value_type(&value->locus, value, GRECS_TYPE_STRING))\n\t\treturn 1;\n\n\tif (trans_strtotok(kwfac, value->v.string, &fac))\n\t\tgrecs_error(&value->locus, 0,\n\t\t\t    _(\"unknown syslog facility `%s'\"),\n\t\t\t    value->v.string);\n\telse\n\t\t*(int*)varptr = fac;\n\treturn 0;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "envfree": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "static void\nenvfree(char **env)\n{\n\tint i;\n\n\tif (!env)\n\t\treturn;\n\tfor (i = 0; env[i]; i++)\n\t\tfree(env[i]);\n\tfree(env);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eventconf_init": {
      "start_point": [
        175,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "static void\neventconf_init()\n{\n\tmemset(&eventconf, 0, sizeof eventconf);\n\teventconf.timeout = DEFAULT_TIMEOUT;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eventconf_free": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void\neventconf_free()\n{\n\tgrecs_list_free(eventconf.pathlist);\n\tgrecs_list_free(eventconf.fnames);\n\tfree(eventconf.command);\n\tfree(eventconf.gidv);\n\tenvfree(eventconf.env);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eventconf_flush": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "void\neventconf_flush(grecs_locus_t *loc)\n{\n\tstruct grecs_list_entry *ep;\n\t\n\tfor (ep = eventconf.pathlist->head; ep; ep = ep->next) {\n\t\tstruct pathent *pe = ep->data;\n\t\tstruct dirwatcher *dwp;\n\t\tstruct handler *hp;\n\t\tint isnew;\n\t\t\n\t\tdwp = dirwatcher_install(pe->path, &isnew);\n\t\tif (!dwp)\n\t\t\tabort();\n\t\tif (!isnew && dwp->depth != pe->depth)\n\t\t\tgrecs_error(loc, 0,\n\t\t\t\t    _(\"%s: recursion depth does not match previous definition\"),\n\t\t\t\t    pe->path);\n\t\tdwp->depth = pe->depth;\n\t\t\n\t\thp = emalloc(sizeof(*hp));\n\t\thp->next = NULL;\n\t\thp->ev_mask = eventconf.eventmask;\n\t\thp->fnames = eventconf.fnames;\n\t\thp->flags = eventconf.flags;\n\t\thp->timeout = eventconf.timeout;\n\t\thp->prog = eventconf.command;\n\t\thp->uid = eventconf.uid;\n\t\thp->gidc = eventconf.gidc;\n\t\thp->gidv = eventconf.gidv;\n\t\thp->env = eventconf.env;\n\t\t\n\t\tif (dwp->handler_tail)\n\t\t\tdwp->handler_tail->next = hp;\n\t\telse\n\t\t\tdwp->handler_list = hp;\n\t\tdwp->handler_tail = hp;\n\t}\n\tgrecs_list_free(eventconf.pathlist);\n\teventconf_init();\n}",
      "lines": 41,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "cb_watcher": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static int\ncb_watcher(enum grecs_callback_command cmd, grecs_node_t *node,\n\t   void *varptr, void *cb_data)\n{\n\tint err = 0;\n\t\n\tswitch (cmd) {\n\tcase grecs_callback_section_begin:\n\t\teventconf_init();\n\t\tbreak;\n\tcase grecs_callback_section_end:\n\t\tif (!eventconf.pathlist) {\n\t\t\tgrecs_error(&node->locus, 0, _(\"no paths configured\"));\n\t\t\t++err;\n\t\t}\n\t\tif (!eventconf.command) {\n\t\t\tgrecs_error(&node->locus, 0,\n\t\t\t\t    _(\"no command configured\"));\n\t\t\t++err;\n\t\t}\n\t\tif (evtnullp(&eventconf.eventmask))\n\t\t\tevtsetall(&eventconf.eventmask);\n\t\tif (err == 0)\n\t\t\teventconf_flush(&node->locus);\n\t\telse\n\t\t\teventconf_free();\n\t\tbreak;\n\tcase grecs_callback_set_value:\n\t\tgrecs_error(&node->locus, 0,\n\t\t\t    _(\"invalid use of block statement\"));\n\t}\n\treturn 0;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pathent_alloc": {
      "start_point": [
        268,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static struct pathent *\npathent_alloc(char *s, long depth)\n{\n\tsize_t len = strlen(s);\n\tstruct pathent *p = emalloc(sizeof(*p) + len);\n\tp->len = len;\n\tstrcpy(p->path, s);\n\tp->depth = depth;\n\treturn p;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct pathent",
        "struct",
        "pathent",
        "*\npathent_alloc(char *s, long depth)",
        "*"
      ]
    },
    "cb_path": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static int\ncb_path(enum grecs_callback_command cmd, grecs_node_t *node,\n\tvoid *varptr, void *cb_data)\n{\n        grecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *val = node->v.value;\n\tstruct grecs_list **lpp = varptr, *lp;\n\tstruct pathent *pe;\n\tchar *s;\n\tlong depth = 0;\n\t\t\n\tASSERT_SCALAR(cmd, locus);\n\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\ts = val->v.string;\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tif (assert_grecs_value_type(&val->v.arg.v[0]->locus,\n\t\t\t\t\t    val->v.arg.v[0],\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\tif (assert_grecs_value_type(&val->v.arg.v[1]->locus,\n\t\t\t\t\t    val->v.arg.v[1],\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\tif (strcmp(val->v.arg.v[1]->v.string, \"recursive\")) {\n\t\t\tgrecs_error(&val->v.arg.v[1]->locus, 0,\n\t\t\t\t    _(\"expected \\\"recursive\\\" or end of statement\"));\n\t\t\treturn 1;\n\t\t}\n\t\tswitch (val->v.arg.c) {\n\t\tcase 2:\n\t\t\tdepth = -1;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (grecs_string_convert(&depth, grecs_type_long,\n\t\t\t\t\t\t val->v.arg.v[2]->v.string,\n\t\t\t\t\t\t &val->v.arg.v[2]->locus))\n\t\t\t\treturn 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgrecs_error(&val->v.arg.v[3]->locus, 0,\n\t\t\t\t    _(\"surplus argument\"));\n\t\t\treturn 1;\n\t\t}\n\t\ts = val->v.arg.v[0]->v.string;\n\t\tbreak;\n\tcase GRECS_TYPE_LIST:\n\t\tgrecs_error(locus, 0, _(\"unexpected list\"));\n\t\treturn 1;\n\t}\n\tpe = pathent_alloc(s, depth);\n        if (*lpp)\n\t\tlp = *lpp;\n\telse {\n\t\tlp = _grecs_simple_list_create(1);\n\t\t*lpp = lp;\n\t}\n\tgrecs_list_append(lp, pe);\n\treturn 0;\n}",
      "lines": 63,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cb_eventlist": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "static int\ncb_eventlist(enum grecs_callback_command cmd, grecs_node_t *node,\n\t     void *varptr, void *cb_data)\n{\n        grecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *val = node->v.value;\n\tevent_mask *mask = varptr;\n\tevent_mask m;\n\tstruct grecs_list_entry *ep;\n\tint i;\n\t\n\tASSERT_SCALAR(cmd, locus);\n\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tif (getevt(val->v.string, &m)) {\n\t\t\tgrecs_error(&val->locus, 0,\n\t\t\t\t    _(\"unrecognized event code\"));\n\t\t\treturn 1;\n\t\t}\n\t\tmask->gen_mask |= m.gen_mask;\n\t\tmask->sys_mask |= m.sys_mask;\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tfor (i = 0; i < val->v.arg.c; i++) {\n\t\t\tif (assert_grecs_value_type(&val->v.arg.v[i]->locus,\n\t\t\t\t\t\t    val->v.arg.v[i],\n\t\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\t\treturn 1;\n\t\t\tif (getevt(val->v.arg.v[i]->v.string, &m)) {\n\t\t\t\tgrecs_error(&val->v.arg.v[i]->locus, 0,\n\t\t\t\t\t    _(\"unrecognized event code\"));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tmask->gen_mask |= m.gen_mask;\n\t\t\tmask->sys_mask |= m.sys_mask;\n\t\t}\n\t\tbreak;\n\tcase GRECS_TYPE_LIST:\n\t\tfor (ep = val->v.list->head; ep; ep = ep->next)\t{\n\t\t\tgrecs_value_t *vp = ep->data;\n\t\t\tif (assert_grecs_value_type(&vp->locus, vp,\n\t\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\t\treturn 1;\n\t\t\tif (getevt(vp->v.string, &m)) {\n\t\t\t\tgrecs_error(&vp->locus, 0,\n\t\t\t\t\t    _(\"unrecognized event code\"));\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tmask->gen_mask |= m.gen_mask;\n\t\t\tmask->sys_mask |= m.sys_mask;\n\t\t}\n\t\tbreak;\n\t}\n\treturn 0;\n}",
      "lines": 57,
      "depth": 19,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "membergid": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        409,
        1
      ],
      "content": "static int\nmembergid(gid_t gid, size_t gc, gid_t *gv)\n{\n\tint i;\n\tfor (i = 0; i < gc; i++)\n\t\tif (gv[i] == gid)\n\t\t\treturn 1;\n\treturn 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_user_groups": {
      "start_point": [
        411,
        0
      ],
      "end_point": [
        440,
        1
      ],
      "content": "static void\nget_user_groups(char *user, gid_t gid, size_t *pgidc, gid_t **pgidv)\n{\n\tsize_t gidc = 0, n = 0;\n\tgid_t *gidv = NULL;\n\tstruct group *gr;\n\n\tn = 32;\n\tgidv = emalloc(n * sizeof(gidv[0]));\n\tgidv[0] = gid;\n\tgidc = 1;\n\t\n\tsetgrent();\n\twhile (gr = getgrent()) {\n\t\tchar **p;\n\t\tfor (p = gr->gr_mem; *p; p++)\n\t\t\tif (strcmp(*p, user) == 0) {\n\t\t\t\tif (n == gidc) {\n\t\t\t\t\tn += 32;\n\t\t\t\t\tgidv = erealloc(gidv,\n\t\t\t\t\t\t\tn * sizeof(gidv[0]));\n\t\t\t\t}\n\t\t\t\tif (!membergid(gr->gr_gid, gidc, gidv))\n\t\t\t\t\tgidv[gidc++] = gr->gr_gid;\n\t\t\t}\n\t}\n\tendgrent();\n\t*pgidc = gidc;\n\t*pgidv = gidv;\n}",
      "lines": 30,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cb_user": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        504,
        1
      ],
      "content": "static int\ncb_user(enum grecs_callback_command cmd, grecs_node_t *node,\n\tvoid *varptr, void *cb_data)\n{\n        grecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *val = node->v.value;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\tgrecs_value_t *uv, *gv = NULL;\n\tgid_t gid;\n\t\n\tASSERT_SCALAR(cmd, locus);\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tuv = val;\n\t\tbreak;\n\t\t\n\tcase GRECS_TYPE_ARRAY:\n\t\tif (assert_grecs_value_type(&val->v.arg.v[0]->locus,\n\t\t\t\t\t    val->v.arg.v[0],\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\tif (assert_grecs_value_type(&val->v.arg.v[1]->locus,\n\t\t\t\t\t    val->v.arg.v[1],\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\tif (val->v.arg.c > 2) {\n\t\t\tgrecs_locus_t loc;\n\t\t\tloc.beg = val->v.arg.v[2]->locus.beg;\n\t\t\tloc.end = val->v.arg.v[val->v.arg.c - 1]->locus.end;\n\t\t\tgrecs_error(&loc, 0, _(\"surplus arguments\"));\n\t\t\treturn 1;\n\t\t}\n\t\tuv = val->v.arg.v[0];\n\t\tgv = val->v.arg.v[1];\n\t\tbreak;\n\n\tcase GRECS_TYPE_LIST:\n\t\tgrecs_error(locus, 0, _(\"unexpected list\"));\n\t\treturn 1;\n\t}\n\n\tpw = getpwnam(uv->v.string);\n\tif (!pw) {\n\t\tgrecs_error(&uv->locus, 0, _(\"no such user\"));\n\t\treturn 1;\n\t}\n\n\tif (gv) {\n\t\tgr = getgrnam(gv->v.string);\n\t\tif (!gr) {\n\t\t\tgrecs_error(&gv->locus, 0, _(\"no such group\"));\n\t\t\treturn 1;\n\t\t}\n\t\tgid = gr->gr_gid;\n\t} else\n\t\tgid = pw->pw_gid;\n\n\teventconf.uid = pw->pw_uid;\n\tget_user_groups(uv->v.string, gid, &eventconf.gidc, &eventconf.gidv);\n\t\n\treturn 0;\n}",
      "lines": 63,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cb_option": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        537,
        1
      ],
      "content": "static int\ncb_option(enum grecs_callback_command cmd, grecs_node_t *node,\n\t  void *varptr, void *cb_data)\n{\n        grecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *val = node->v.value;\n\tstruct grecs_list_entry *ep;\n\t\n\tASSERT_SCALAR(cmd, locus);\n\tif (assert_grecs_value_type(&val->locus, val, GRECS_TYPE_LIST))\n\t\treturn 1;\n\n\tfor (ep = val->v.list->head; ep; ep = ep->next)\t{\n\t\tgrecs_value_t *vp = ep->data;\n\t\tif (assert_grecs_value_type(&vp->locus, vp,\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\tif (strcmp(vp->v.string, \"nowait\") == 0)\n\t\t\teventconf.flags |= HF_NOWAIT;\n\t\telse if (strcmp(vp->v.string, \"wait\") == 0)\n\t\t\teventconf.flags &= ~HF_NOWAIT;\n\t\telse if (strcmp(vp->v.string, \"stdout\") == 0)\n\t\t\teventconf.flags |= HF_STDOUT;\n\t\telse if (strcmp(vp->v.string, \"stderr\") == 0)\n\t\t\teventconf.flags |= HF_STDERR;\n\t\telse if (strcmp(vp->v.string, \"shell\") == 0)\n\t\t\teventconf.flags |= HF_SHELL;\n\t\telse \n\t\t\tgrecs_error(&vp->locus, 0, _(\"unrecognized option\"));\n\t}\n\treturn 0;\n}",
      "lines": 32,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cb_environ": {
      "start_point": [
        539,
        0
      ],
      "end_point": [
        585,
        1
      ],
      "content": "static int\ncb_environ(enum grecs_callback_command cmd, grecs_node_t *node,\n\t   void *varptr, void *cb_data)\n{\n        grecs_locus_t *locus = &node->locus;\n\tgrecs_value_t *val = node->v.value;\n\tstruct grecs_list_entry *ep;\n\tint i;\n\t\n\tASSERT_SCALAR(cmd, locus);\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tif (assert_grecs_value_type(&val->locus, val,\n\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\treturn 1;\n\t\teventconf.env = ecalloc(2, sizeof(eventconf.env[0]));\n\t\teventconf.env[0] = estrdup(val->v.string);\n\t\teventconf.env[1] = NULL;\n\t\tbreak;\n\t\t\n\tcase GRECS_TYPE_ARRAY:\n\t\teventconf.env = ecalloc(val->v.arg.c + 1,\n\t\t\t\t\tsizeof(eventconf.env[0]));\n\t\tfor (i = 0; i < val->v.arg.c; i++) {\n\t\t\tif (assert_grecs_value_type(&val->v.arg.v[i]->locus,\n\t\t\t\t\t\t    val->v.arg.v[i],\n\t\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\t\treturn 1;\n\t\t\teventconf.env[i] = estrdup(val->v.arg.v[i]->v.string);\n\t\t}\n\t\teventconf.env[i] = NULL;\n\t\tbreak;\n\n\tcase GRECS_TYPE_LIST:\n\t\teventconf.env = ecalloc(val->v.list->count + 1,\n\t\t\t\t\tsizeof(eventconf.env[0]));\n\t\tfor (i = 0, ep = val->v.list->head; ep; ep = ep->next, i++) {\n\t\t\tgrecs_value_t *vp = ep->data;\n\t\t\tif (assert_grecs_value_type(&vp->locus, vp,\n\t\t\t\t\t\t    GRECS_TYPE_STRING))\n\t\t\t\treturn 1;\n\t\t\teventconf.env[i] = estrdup(vp->v.string);\n\t\t}\n\t\teventconf.env[i] = NULL;\n\t}\n\treturn 0;\n}",
      "lines": 47,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "file_name_pattern": {
      "start_point": [
        587,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "static int\nfile_name_pattern(struct grecs_list *lp, grecs_value_t *val)\n{\n\tchar *arg;\n\tint rc;\n\tint flags = REG_EXTENDED|REG_NOSUB;\n\tstruct filename_pattern *pat;\n\t\n\tif (assert_grecs_value_type(&val->locus, val, GRECS_TYPE_STRING))\n\t\treturn 1;\n\targ = val->v.string;\n\n\tpat = emalloc(sizeof(*pat));\n\tif (*arg == '!') {\n\t\tpat->neg = 1;\n\t\t++arg;\n\t} else\n\t\tpat->neg = 0;\n\tif (arg[0] == '/') {\n\t\tchar *q, *p;\n\n\t\tpat->type = PAT_REGEX;\n\t\t\n\t\tp = strchr(arg+1, '/');\n\t\tif (!p) {\n\t\t\tgrecs_error(&val->locus, 0, _(\"unterminated regexp\"));\n\t\t\tfree(pat);\n\t\t\treturn 1;\n\t\t}\n\t\tfor (q = p + 1; *q; q++) {\n\t\t\tswitch (*q) {\n\t\t\tcase 'b':\n\t\t\t\tflags &= ~REG_EXTENDED;\n\t\t\t\tbreak;\n\t\t\tcase 'i':\n\t\t\t\tflags |= REG_ICASE;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tgrecs_error(&val->locus, 0,\n\t\t\t\t\t    _(\"unrecognized flag: %c\"), *q);\n\t\t\t\tfree(pat);\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\t*p = 0;\n\t\trc = regcomp(&pat->v.re, arg + 1, flags);\n\t\t*p = '/';\n\n\t\tif (rc) {\n\t\t\tchar errbuf[128];\n\t\t\tregerror(rc, &pat->v.re, errbuf, sizeof(errbuf));\n\t\t\tgrecs_error(&val->locus, 0, \"%s\", errbuf);\n\t\t\tfilename_pattern_free(pat);\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tpat->type = PAT_GLOB;\n\t\tpat->v.glob = estrdup(arg);\n\t}\n\n\tgrecs_list_append(lp, pat);\n\n\treturn 0;\n}",
      "lines": 65,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cb_file_pattern": {
      "start_point": [
        653,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static int\ncb_file_pattern(enum grecs_callback_command cmd, grecs_node_t *node,\n\t\tvoid *varptr, void *cb_data)\n{\n\tgrecs_value_t *val = node->v.value;\n\tstruct grecs_list_entry *ep;\n\tstruct grecs_list *lp, **lpp = varptr;\n\tint i;\n\t\n\tASSERT_SCALAR(cmd, &node->locus);\n\n\tif (!*lpp) {\n\t\tlp = grecs_list_create();\n\t\tlp->free_entry = filename_pattern_free;\n\t\t*lpp = lp;\n\t} else\n\t\tlp = *lpp;\n\t\n\tswitch (val->type) {\n\tcase GRECS_TYPE_STRING:\n\t\tfile_name_pattern(lp, val);\n\t\tbreak;\n\n\tcase GRECS_TYPE_ARRAY:\n\t\tfor (i = 0; i < val->v.arg.c; i++)\n\t\t\tif (file_name_pattern(lp, val->v.arg.v[i]))\n\t\t\t\tbreak;\n\t\tbreak;\n\n\tcase GRECS_TYPE_LIST:\n\t\tfor (ep = val->v.list->head; ep; ep = ep->next)\n\t\t\tif (file_name_pattern(lp,\n\t\t\t\t\t      (grecs_value_t *) ep->data))\n\t\t\t\tbreak;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}",
      "lines": 39,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "config_help": {
      "start_point": [
        738,
        0
      ],
      "end_point": [
        746,
        1
      ],
      "content": "void\nconfig_help()\n{\n\tstatic char docstring[] =\n\t\tN_(\"Configuration file structure for direvent.\\n\"\n\t\t   \"For more information, use `info direvent configuration'.\");\n\tgrecs_print_docstring(docstring, 0, stdout);\n\tgrecs_print_statement_array(direvent_kw, 1, 0, stdout);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "config_init": {
      "start_point": [
        748,
        0
      ],
      "end_point": [
        752,
        1
      ],
      "content": "void\nconfig_init(void)\n{\n\tgrecs_include_path_setup(INCLUDE_PATH_ARGS, NULL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "config_parse": {
      "start_point": [
        754,
        0
      ],
      "end_point": [
        765,
        1
      ],
      "content": "void\nconfig_parse(char const *conffile)\n{\n\tstruct grecs_node *tree;\n\n\ttree = grecs_parse(conffile);\n\tif (!tree)\n\t\texit(1);\n\tif (grecs_tree_process(tree, direvent_kw))\n\t\texit(1);\n\t\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/src/detach-bsd.c": {
    "detach": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "int\ndetach(void (*init)())\n{\n\tstruct sigaction oldsa, sa;\n\tpid_t pid;\n\tint ec;\n\n\tinit();\n\t\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_handler = SIG_IGN;\n\tsa.sa_flags = 0;\n\n\tif (sigaction(SIGHUP, &sa, &oldsa))\n\t\treturn -1;\n\n\tswitch (rfork(RFPROC)) {\n\tcase -1:\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tpid = setsid();\n\tec = errno;\n\t\n\tsigaction(SIGHUP, &oldsa, NULL);\n\t\n\tif (pid == -1) {\n\t\terrno = ec;\n\t\treturn -1;\n\t}\n\n\tchdir(\"/\");\n\n\tclose(0);\n\tclose(1);\n\tclose(2);\n\topen(_PATH_DEVNULL, O_RDONLY);\n\topen(_PATH_DEVNULL, O_WRONLY);\n\tdup(1);\n\n\treturn 0;\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/detach-darwin.c": {
    "catch_signal": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ncatch_signal(int sig)\n{\n\tlastsig = sig;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "void"
      ]
    },
    "waitchild": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\nwaitchild()\n{\n\twhile (lastsig == 0) \n\t\tpause();\n\t\n\tif (lastsig == SIGUSR1)\n\t\t_exit(0);\n\tdiag(LOG_CRIT, \"failed to install watchers\");\n\texit(1);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "detach": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "int\ndetach(void (*init)())\n{\n\tstatic struct sigtab sigtab[] = {\n\t\t{ SIGHUP, SIG_IGN },\n\t\t{ SIGCHLD, catch_signal },\n\t\t{ SIGUSR1, catch_signal }\n\t};\n\tstruct sigaction oldsa[NITEMS(sigtab)];\n\tpid_t pid;\n\tint ec;\n\n\tif (sigv_set_tab(NITEMS(sigtab), sigtab, oldsa))\n\t\treturn -1;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\tsigv_restore_tab(NITEMS(sigtab), sigtab, oldsa);\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\twaitchild();\n\t}\n\n\tinit();\n\tkill(getppid(), SIGUSR1);\n\t\n\tpid = setsid();\n\tec = errno;\n\t\n\tsigv_restore_tab(NITEMS(sigtab), sigtab, oldsa);\n\t\n\tif (pid == -1) {\n\t\terrno = ec;\n\t\treturn -1;\n\t}\n\n        chdir(\"/\");\n\n\tclose(0);\n\tclose(1);\n\tclose(2);\n\topen(_PATH_DEVNULL, O_RDONLY);\n\topen(_PATH_DEVNULL, O_WRONLY);\n\tdup(1);\n\n\treturn 0;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/detach-std.c": {
    "detach": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\ndetach(void (*init)())\n{\n\tstruct sigaction oldsa, sa;\n\tpid_t pid;\n\tint ec;\n\n\tinit();\n\t\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_handler = SIG_IGN;\n\tsa.sa_flags = 0;\n\n\tif (sigaction(SIGHUP, &sa, &oldsa))\n\t\treturn -1;\n\n\tswitch (fork()) {\n\tcase -1:\n\t\treturn -1;\n\tcase 0:\n\t\tbreak;\n\tdefault:\n\t\t_exit(0);\n\t}\n\n\tpid = setsid();\n\tec = errno;\n\t\n\tsigaction(SIGHUP, &oldsa, NULL);\n\t\n\tif (pid == -1) {\n\t\terrno = ec;\n\t\treturn -1;\n\t}\n\n\tchdir(\"/\");\n\n\tclose(0);\n\tclose(1);\n\tclose(2);\n\topen(_PATH_DEVNULL, O_RDONLY);\n\topen(_PATH_DEVNULL, O_WRONLY);\n\tdup(1);\n\t\n\treturn 0;\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/direvent.c": {
    "severity": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "const char *\nseverity(int prio)\n{\n\tswitch (prio) {\n\tcase LOG_EMERG:\n\t\treturn \"EMERG\";\n\tcase LOG_ALERT:\n\t\treturn \"ALERT\";\n\tcase LOG_CRIT:\n\t\treturn \"CRIT\";\n\tcase LOG_ERR:\n\t\treturn \"ERROR\";\n\tcase LOG_WARNING:\n\t\treturn \"WARNING\";\n\tcase LOG_NOTICE:\n\t\treturn \"NOTICE\";\n\tcase LOG_INFO:\n\t\treturn \"INFO\";\n\tcase LOG_DEBUG:\n\t\treturn \"DEBUG\";\n\t}\n\treturn NULL;\n}",
      "lines": 23,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nseverity(int prio)",
        "*"
      ]
    },
    "vdiag": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "void\nvdiag(int prio, const char *fmt, va_list ap)\n{\n\tconst char *s;\n\tva_list tmp;\n\t\n\tif (log_to_stderr >= prio) {\n\t\tfprintf(stderr, \"%s: \", program_name);\n\t\ts = severity(prio);\n\t\tif (s)\n\t\t\tfprintf(stderr, \"[%s] \", s);\n\t\tva_copy(tmp, ap);\n\t\tvfprintf(stderr, fmt, tmp);\n\t\tfputc('\\n', stderr);\n\t\tva_end(tmp);\n\t}\n\n\tif (facility > 0) {\n\t\tif (syslog_include_prio && (s = severity(prio)) != NULL) {\n\t\t\tstatic char *fmtbuf;\n\t\t\tstatic size_t fmtsize;\n\t\t\tsize_t len = strlen(fmt) + strlen(s) + 4;\n\t\t\tchar *p;\n\t\t\t\n\t\t\tif (len > fmtsize) {\n\t\t\t\tfmtbuf = erealloc(fmtbuf, len);\n\t\t\t\tfmtsize = len;\n\t\t\t}\n\n\t\t\tp = fmtbuf;\n\t\t\t*p++ = '[';\n\t\t\twhile (*s)\n\t\t\t\t*p++ = *s++;\n\t\t\t*p++ = ']';\n\t\t\t*p++ = ' ';\n\t\t\twhile (*p++ = *fmt++);\n\t\t\tvsyslog(prio, fmtbuf, ap);\n\t\t} else\t\t\t\n\t\t\tvsyslog(prio, fmt, ap);\n\t}\n}",
      "lines": 41,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "diag": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ndiag(int prio, const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvdiag(prio, fmt, ap);\n\tva_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "debugprt": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ndebugprt(const char *fmt, ...)\n{\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tvdiag(LOG_DEBUG, fmt, ap);\n\tva_end(ap);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "emalloc": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "void *\nemalloc(size_t size)\n{\n\tvoid *p = malloc(size);\n\tif (!p) {\n\t\tdiag(LOG_CRIT, _(\"not enough memory\"));\n\t\texit(2);\n\t}\n\treturn p;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void",
        "*\nemalloc(size_t size)",
        "*"
      ]
    },
    "ecalloc": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "void *\necalloc(size_t nmemb, size_t size)\n{\n\tvoid *p = calloc(nmemb, size);\n\tif (!p) {\n\t\tdiag(LOG_CRIT, \"not enough memory\");\n\t\texit(2);\n\t}\n\treturn p;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void",
        "*\necalloc(size_t nmemb, size_t size)",
        "*"
      ]
    },
    "erealloc": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void *\nerealloc(void *ptr, size_t size)\n{\n\tvoid *p = realloc(ptr, size);\n\tif (!p) {\n\t\tdiag(LOG_CRIT, _(\"not enough memory\"));\n\t\texit(2);\n\t}\n\treturn p;\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void",
        "*\nerealloc(void *ptr, size_t size)",
        "*"
      ]
    },
    "estrdup": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "char *\nestrdup(const char *str)\n{\n\tsize_t len = strlen(str);\n\tchar *p = emalloc(len + 1);\n\tmemcpy(p, str, len);\n\tp[len] = 0;\n\treturn p;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "char",
        "*\nestrdup(const char *str)",
        "*"
      ]
    },
    "mkfilename": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "char *\nmkfilename(const char *dir, const char *file)\n{\n\tchar *tmp;\n\tsize_t dirlen = strlen(dir);\n\tsize_t fillen = strlen(file);\n\tsize_t len;\n\n\twhile (dirlen > 0 && dir[dirlen-1] == '/')\n\t\tdirlen--;\n\n\tlen = dirlen + (dir[0] ? 1 : 0) + fillen;\n\ttmp = malloc(len + 1);\n\tif (tmp) {\n\t\tmemcpy(tmp, dir, dirlen);\n\t\tif (dir[0])\n\t\t\ttmp[dirlen++] = '/';\n\t\tmemcpy(tmp + dirlen, file, fillen);\n\t\ttmp[len] = 0;\n\t}\n\treturn tmp;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "char",
        "*\nmkfilename(const char *dir, const char *file)",
        "*"
      ]
    },
    "trans_strtotok": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        212,
        1
      ],
      "content": "int\ntrans_strtotok(struct transtab *tab, const char *str, int *ret)\n{\n\tfor (; tab->name; tab++)\n\t\tif (strcmp(tab->name, str) == 0) {\n\t\t\t*ret = tab->tok;\n\t\t\treturn 0;\n\t\t}\n\treturn -1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "trans_toktostr": {
      "start_point": [
        214,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "char *\ntrans_toktostr(struct transtab *tab, int tok)\n{\n\tfor (; tab->name; tab++)\n\t\tif (tab->tok == tok)\n\t\t\treturn tab->name;\n\treturn NULL;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "char",
        "*\ntrans_toktostr(struct transtab *tab, int tok)",
        "*"
      ]
    },
    "trans_toknext": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "char *\ntrans_toknext(struct transtab *tab, int tok, int *next)\n{\n\tint i;\n\t\n\tfor (i = *next; tab[i].name; i++)\n\t\tif (tab[i].tok & tok) {\n\t\t\t*next = i + 1;\n\t\t\treturn tab[i].name;\n\t\t}\n\t*next = i;\n\treturn NULL;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "char",
        "*\ntrans_toknext(struct transtab *tab, int tok, int *next)",
        "*"
      ]
    },
    "trans_tokfirst": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "char *\ntrans_tokfirst(struct transtab *tab, int tok, int *next)\n{\n\t*next = 0;\n\treturn trans_toknext(tab, tok, next);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "char",
        "*\ntrans_tokfirst(struct transtab *tab, int tok, int *next)",
        "*"
      ]
    },
    "set_program_name": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\nset_program_name(const char *arg)\n{\n\tchar *p = strrchr(arg, '/');\n\tif (p)\n\t\tprogram_name = p + 1;\n\telse\n\t\tprogram_name = arg;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "signal_setup": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "void\nsignal_setup(void (*sf) (int))\n{\n\tstatic int sigv[] = { SIGTERM, SIGQUIT, SIGINT, SIGHUP, SIGALRM,\n\t\t\t      SIGUSR1, SIGUSR1, SIGCHLD };\n\tsigv_set_all(sf, NITEMS(sigv), sigv, NULL);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "storepid": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nstorepid(const char *pidfile)\n{\n\tFILE *fp = fopen(pidfile, \"w\");\n\tif (!fp) {\n\t\tdiag(LOG_ERR, _(\"cannot open pidfile %s for writing: %s\"),\n\t\t     pidfile, strerror(errno));\n\t} else {\n\t\tfprintf(fp, \"%lu\\n\", (unsigned long) getpid());\n\t\tfclose(fp);\n\t}\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "membergid": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static int\nmembergid(gid_t gid, size_t gc, gid_t *gv)\n{\n\tint i;\n\tfor (i = 0; i < gc; i++)\n\t\tif (gv[i] == gid)\n\t\t\treturn 1;\n\treturn 0;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "get_user_groups": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        327,
        1
      ],
      "content": "static void\nget_user_groups(uid_t uid, size_t *pgidc, gid_t **pgidv)\n{\n\tsize_t gidc = 0, n = 0;\n\tgid_t *gidv = NULL;\n\tstruct passwd *pw;\n\tstruct group *gr;\n\n\tpw = getpwuid(uid);\n\tif (!pw) {\n\t\tdiag(LOG_ERR, 0, _(\"no user with UID %lu\"),\n\t\t     (unsigned long)uid);\n\t\texit(2);\n\t}\n\t\n\tn = 32;\n\tgidv = ecalloc(n, sizeof(gidv[0]));\n\t\t\n\tgidv[0] = pw->pw_gid;\n\tgidc = 1;\n\t\n\tsetgrent();\n\twhile (gr = getgrent()) {\n\t\tchar **p;\n\t\tfor (p = gr->gr_mem; *p; p++)\n\t\t\tif (strcmp(*p, pw->pw_name) == 0) {\n\t\t\t\tif (n == gidc) {\n\t\t\t\t\tn += 32;\n\t\t\t\t\tgidv = erealloc(gidv,\n\t\t\t\t\t\t\tn * sizeof(gidv[0]));\n\t\t\t\t}\n\t\t\t\tif (!membergid(gr->gr_gid, gidc, gidv))\n\t\t\t\t\tgidv[gidc++] = gr->gr_gid;\n\t\t\t}\n\t}\n\tendgrent();\n\t*pgidc = gidc;\n\t*pgidv = gidv;\n}",
      "lines": 39,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "setuser": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        361,
        1
      ],
      "content": "void\nsetuser(const char *user)\n{\n\tstruct passwd *pw;\n\tsize_t gidc;\n\tgid_t *gidv;\n\t\t\n\tpw = getpwnam(user);\n\tif (!pw) {\n\t\tdiag(LOG_CRIT, \"getpwnam(%s): %s\", user, strerror(errno));\n\t\texit(2);\n\t}\n\tif (pw->pw_uid == 0)\n\t\treturn;\n\n\tget_user_groups(pw->pw_uid, &gidc, &gidv);\n\tif (setgroups(gidc, gidv) < 0) {\n\t\tdiag(LOG_CRIT, \"setgroups: %s\", strerror(errno));\n\t\texit(2);\n\t}\n\tfree(gidv);\n\n\tif (setgid(pw->pw_gid)) {\n\t\tdiag(LOG_CRIT, \"setgid(%lu): %s\", (unsigned long) pw->pw_gid,\n\t\t     strerror(errno));\n\t\texit(2);\n\t}\n\tif (setuid(pw->pw_uid)) {\n\t\tdiag(LOG_CRIT, \"setuid(%lu): %s\", (unsigned long) pw->pw_uid,\n\t\t     strerror(errno));\n\t\texit(2);\n\t}\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ev_log": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "void\nev_log(int flags, struct dirwatcher *dp)\n{\n\tint i;\n\tchar *p;\n\t\n\tif (debug_level > 0) {\n\t\tfor (p = trans_tokfirst(sysev_transtab, flags, &i); p;\n\t\t     p = trans_toknext(sysev_transtab, flags, &i))\n\t\t\tdebug(1, (\"%s: %s\", dp->dirname, p));\n\t}\n}",
      "lines": 12,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "genev_init": {
      "start_point": [
        378,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "void\ngenev_init()\n{\n\tint i;\n\t\n\tfor (i = 0; i < genev_xlat[i].gen_mask; i++)\n\t\tdefevt(trans_toktostr(genev_transtab, genev_xlat[i].gen_mask),\n\t\t       &genev_xlat[i], 0);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "sigmain": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        406,
        1
      ],
      "content": "void\nsigmain(int sig)\n{\n\tsigno = sig;\n\tswitch (signo) {\n\tcase SIGCHLD:\n\tcase SIGALRM:\n\t\tbreak;\n\tdefault:\n\t\tstop = 1;\n\t}\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "self_test": {
      "start_point": [
        408,
        0
      ],
      "end_point": [
        435,
        1
      ],
      "content": "void\nself_test()\n{\n\tpid_t pid;\n\tchar *args[4];\n\t\n\tpid = fork();\n\tif (pid == (pid_t)-1) {\n\t\tdiag(LOG_CRIT,\n\t\t     _(\"cannot run `%s': fork failed: %s\"),\n\t\t     self_test_prog, strerror(errno));\n\t\texit(2);\n\t}\n\t\n\tif (pid != 0) {\n\t\tself_test_pid = pid;\n\t\treturn;\n\t}\n\n\targs[0] = \"/bin/sh\";\n\targs[1] = \"-c\";\n\targs[2] = self_test_prog;\n\targs[3] = NULL;\n\texecv(args[0], args);\n\n\tdiag(LOG_ERR, \"execv: %s: %s\", self_test_prog, strerror(errno));\n\t_exit(127);\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        453,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tint i;\n\n#ifdef ENABLE_NLS\n\tsetlocale(LC_ALL, \"\");\n\tbindtextdomain(PACKAGE, LOCALEDIR);\n\ttextdomain(PACKAGE);\n#endif\n\n\tset_program_name(argv[0]);\n\ttag = estrdup(program_name);\n\n\tgenev_init();\n\tconfig_init();\n\t\n\tparse_options(argc, argv, &i);\n\n\targc -= i;\n\targv += i;\n\n\tswitch (argc) {\n\tdefault:\n\t\tdiag(LOG_CRIT, _(\"too many arguments\"));\n\t\texit(1);\n\tcase 1:\n\t\tconffile = argv[0];\n\t\tbreak;\n\tcase 0:\n\t\tbreak;\n\t}\n\n\tconfig_parse(conffile);\n\tif (lint_only)\n\t\treturn 0;\n\n\tif (opt_debug_level)\n\t\tdebug_level += opt_debug_level;\n\tif (opt_foreground)\n\t\tforeground = opt_foreground;\n\tif (opt_pidfile)\n\t\tpidfile = opt_pidfile;\n\tif (opt_facility != -1)\n\t\tfacility = opt_facility;\n\tif (!foreground && facility <= 0)\n\t\tfacility = LOG_DAEMON;\n\tif (opt_user)\n\t\tuser = opt_user;\n\t\n\tif (facility > 0) {\n\t\topenlog(tag, LOG_PID, facility);\n\t\tgrecs_log_to_stderr = 0;\n\t}\n\n\tif (foreground)\n\t\tsetup_watchers();\n\telse {\n\t\t/* Become a daemon */\n\t\tif (detach(setup_watchers)) {\n\t\t\tdiag(LOG_CRIT, \"daemon: %s\", strerror(errno));\n\t\t\texit(1);\n\t\t}\n\t\tlog_to_stderr = -1;\n\t}\n\t\n\tdiag(LOG_INFO, _(\"%s %s started\"), program_name, VERSION);\n\n\t/* Write pidfile */\n\tif (pidfile)\n\t\tstorepid(pidfile);\n\n\t/* Relinquish superuser privileges */\n\tif (user && getuid() == 0)\n\t\tsetuser(user);\n\n\tsignal_setup(sigmain);\n\n\tif (self_test_prog)\n\t\tself_test();\n\t\n\t/* Main loop */\n\twhile (!stop && sysev_select() == 0) {\n\t\tprocess_timeouts();\n\t\tprocess_cleanup(0);\n\t}\n\n\tdiag(LOG_INFO, _(\"%s %s stopped\"), program_name, VERSION);\n\n\tif (pidfile)\n\t\tunlink(pidfile);\n\t\n\treturn exit_code;\n}",
      "lines": 94,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/direvent.h": {},
  "direvent/direvent-5.1/src/environ.c": {
    "find_env": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static char *\nfind_env(const char *name, int val)\n{\n\tif (environ) {\n\t\tint nlen = strcspn(name, \"+=\");\n\t\tint i;\n\n\t\tfor (i = 0; environ[i]; i++) {\n\t\t\tsize_t elen = strcspn(environ[i], \"=\");\n\t\t\tif (elen == nlen &&\n\t\t\t    memcmp(name, environ[i], nlen) == 0)\n\t\t\t\treturn val ? environ[i] + elen + 1 : environ[i];\n\t\t}\n\t}\n\treturn NULL;\n}",
      "lines": 16,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nfind_env(const char *name, int val)",
        "*"
      ]
    },
    "locate_unset": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static int\nlocate_unset(char **env, const char *name)\n{\n\tint i;\n\tint nlen = strcspn(name, \"=\");\n\n\tfor (i = 0; env[i]; i++) {\n\t\tif (env[i][0] == '-') {\n\t\t\tsize_t elen = strcspn (env[i] + 1, \"=\");\n\t\t\tif (elen == nlen &&\n\t\t\t    memcmp (name, env[i] + 1, nlen) == 0) {\n\t\t\t\tif (env[i][nlen + 1])\n\t\t\t\t\treturn strcmp(name + nlen,\n\t\t\t\t\t\t      env[i] + 1 + nlen) == 0;\n\t\t\t\telse\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 21,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "env_concat": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static char *\nenv_concat(const char *name, size_t namelen, const char *a, const char *b)\n{\n\tchar *res;\n\tsize_t len;\n        \n\tif (a && b) {\n\t\tres = emalloc(namelen + 1 + strlen(a) + strlen(b) + 1);\n\t\tstrcpy(res + namelen + 1, a);\n\t\tstrcat(res, b);\n\t} else if (a) {\n\t\tlen = strlen(a);\n\t\tif (ispunct(a[len-1]))\n\t\t\tlen--;\n\t\tres = emalloc(namelen + 1 + len + 1);\n\t\tmemcpy(res + namelen + 1, a, len);\n\t\tres[namelen + 1 + len] = 0;\n\t}\n\telse { /* if (a == NULL) */\n\t\tif (ispunct(b[0]))\n\t\t\tb++;\n\t\tlen = strlen(b);\n\t\tres = emalloc(namelen + 1 + len + 1);\n\t\tstrcpy(res + namelen + 1, b);\n\t}\n\tmemcpy(res, name, namelen);\n\tres[namelen] = '=';\n\treturn res;\n}",
      "lines": 29,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "char",
        "*\nenv_concat(const char *name, size_t namelen, const char *a, const char *b)",
        "*"
      ]
    },
    "environ_setup": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        219,
        1
      ],
      "content": "char **\nenviron_setup(char **hint, char **kve)\n{\n\tchar *empty[1] = { NULL };\n\tchar **old_env = environ;\n\tchar **new_env;\n\tchar **addenv = defenv;\n\tchar *var;\n\tsize_t count, i, n;\n\tstruct wordsplit ws;\n\tint wsflags = WRDSF_NOCMD | WRDSF_QUOTE | WRDSF_NOSPLIT |\n\t\t      WRDSF_ENV | WRDSF_ENV_KV;\n\n\tws.ws_env = (const char **) kve;\n\n\tif (!hint)\n\t\thint = empty;\n\telse if (strcmp(hint[0], \"-\") == 0 || strcmp(hint[0], \"--\") == 0) {\n\t\told_env = NULL;\n\t\tif (hint[0][1] == '-')\n\t\t\taddenv = empty;\n\t\thint++;\n        }\n\t\n\t/* Count new environment size */\n\tcount = 0;\n\tif (old_env)\n\t\tfor (i = 0; old_env[i]; i++)\n\t\t\tcount++;\n\n\tfor (i = 0; addenv[i]; i++)\n\t\tcount++;\n\t\n\tfor (i = 0; hint[i]; i++)\n\t\tcount++;\n\n\tif (self_test_pid)\n\t\tcount++;\n\n\t/* Allocate new environment. */\n\tnew_env = ecalloc(count + 1, sizeof new_env[0]);\n  \n\t/* Populate the environment. */\n\tn = 0;\n  \n\tif (old_env)\n\t\tfor (i = 0; old_env[i]; i++) {\n\t\t\tif (!locate_unset(hint, old_env[i]))\n\t\t\t\tnew_env[n++] = old_env[i];\n\t\t}\n\n\tfor (i = 0; addenv[i]; i++)\n\t\tif (!locate_unset(hint, addenv[i])) {\n\t\t\tif (wordsplit(addenv[i], &ws, wsflags)) {\n\t\t\t\tdiag(LOG_CRIT, \"wordsplit: %s\",\n\t\t\t\t     wordsplit_strerror(&ws));\n\t\t\t\t_exit(127);\n\t\t\t}\n\t\t\twsflags |= WRDSF_REUSE;\n\t\t\tnew_env[n++] = estrdup(ws.ws_wordv[0]);\n\t\t}\n\t\t\n\tfor (i = 0; hint[i]; i++) {\n\t\tchar *p;\n\n\t\tif (hint[i][0] == '-') {\n\t\t\t/* Skip unset directives. */\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (wordsplit(hint[i], &ws, wsflags)) {\n\t\t\tdiag(LOG_CRIT, \"wordsplit: %s\",\n\t\t\t     wordsplit_strerror(&ws));\n\t\t\t_exit(127);\n\t\t}\n\t\twsflags |= WRDSF_REUSE;\n\t\tvar = ws.ws_wordv[0];\n\t\t\n\t\tif ((p = strchr(var, '='))) {\n\t\t\tif (p == var)\n\t\t\t\tcontinue; /* Ignore erroneous entry */\n\t\t\tif (p[-1] == '+') \n\t\t\t\tnew_env[n++] = env_concat(var,\n\t\t\t\t\t\t\t  p - var - 1,\n\t\t\t\t\t\t\t  find_env(var, 1),\n\t\t\t\t\t\t\t  p + 1);\n\t\t\telse if (p[1] == '+')\n\t\t\t\tnew_env[n++] = env_concat(var,\n\t\t\t\t\t\t\t  p - var,\n\t\t\t\t\t\t\t  p + 2,\n\t\t\t\t\t\t\t  find_env(var, 1));\n\t\t\telse\n\t\t\t\tnew_env[n++] = estrdup(var);\n\t\t} else {\n\t\t\tp = find_env(var, 0);\n\t\t\tif (p)\n\t\t\t\tnew_env[n++] = p;\n\t\t}\n\t}\n\tif (self_test_pid) {\n\t\tchar buf[512];\n\t\tsnprintf(buf, sizeof buf, \"DIREVENT_SELF_TEST_PID=%lu\",\n\t\t\t (unsigned long)self_test_pid);\n\t\tnew_env[n++] = estrdup(buf);;\n\t}\n\tnew_env[n] = NULL;\n\n\tif (wsflags & WRDSF_REUSE)\n\t\twordsplit_free(&ws);\n\treturn new_env;\n}",
      "lines": 111,
      "depth": 15,
      "decorators": [
        "char",
        "**\nenviron_setup(char **hint, char **kve)",
        "*",
        "*\nenviron_setup(char **hint, char **kve)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/src/event.c": {
    "hash_string": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "unsigned\nhash_string(const char *name, unsigned long hashsize)\n{\n\tunsigned i;\n\t\n\tfor (i = 0; *name; name++) {\n\t\ti <<= 1;\n\t\ti ^= *(unsigned char*) name;\n\t}\n\treturn i % hashsize;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "symevt_hash": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static unsigned\nsymevt_hash(void *data, unsigned long hashsize)\n{\n\tstruct symevt *sym = data;\n\treturn hash_string(sym->name, hashsize);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "symevt_cmp": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static int\nsymevt_cmp(const void *a, const void *b)\n{\n\tstruct symevt const *syma = a;\n\tstruct symevt const *symb = b;\n\n\treturn strcmp(syma->name, symb->name);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "symevt_copy": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static int\nsymevt_copy(void *a, void *b)\n{\n\tstruct symevt *syma = a;\n\tstruct symevt *symb = b;\n\n\tsyma->used = 1;\n\tsyma->name = estrdup(symb->name);\n\treturn 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "symevt_free": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "static void\nsymevt_free(void *p)\n{\n\tstruct symevt *sym = p;\n\tfree(sym->name);\n\tfree(sym);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "defevt": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "int\ndefevt(const char *name, event_mask *mask, int line)\n{\n\tstruct symevt key, *evp;\n\tint install = 1;\n\t\n\tif (!evtab) {\n\t\tevtab = hashtab_create(sizeof(struct symevt),\n\t\t\t\t       symevt_hash, symevt_cmp,\n\t\t\t\t       symevt_copy,\n\t\t\t\t       NULL, symevt_free);\n\t\tif (!evtab) {\n\t\t\tdiag(LOG_CRIT, \"not enough memory\");\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tkey.name = (char *) name;\n\tevp = hashtab_lookup_or_install(evtab, &key, &install);\n\tif (!install)\n\t\treturn evp->line;\n\tevp->mask = *mask;\n\tevp->line = line;\n\treturn 0;\n}",
      "lines": 25,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "getevt": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "int\ngetevt(const char *name, event_mask *mask)\n{\n\tif (evtab) {\n\t\tstruct symevt key, *evp;\n\t\tkey.name = (char *) name;\n\t\tevp = hashtab_lookup_or_install(evtab, &key, NULL);\n\t\tif (evp) {\n\t\t\t*mask = evp->mask;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (trans_strtotok(sysev_transtab, name, &mask->sys_mask))\n\t\treturn -1;\n\tmask->gen_mask = 0;\n\treturn 0;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "evtnullp": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "int\nevtnullp(event_mask *mask)\n{\n\treturn mask->gen_mask == 0 && mask->sys_mask == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "event_mask_init": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "event_mask *\nevent_mask_init(event_mask *m, int fflags, event_mask const *req)\n{\n\tint i;\n\n\tm->sys_mask = fflags & req->sys_mask;\n\tm->gen_mask = 0;\n\tfor (i = 0; i < genev_xlat[i].gen_mask; i++)\n\t\tif (genev_xlat[i].sys_mask & m->sys_mask)\n\t\t\tm->gen_mask |= genev_xlat[i].gen_mask;\n\tif (req->gen_mask)\n\t\tm->gen_mask &= req->gen_mask;\n\treturn m;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "event_mask",
        "*\nevent_mask_init(event_mask *m, int fflags, event_mask const *req)",
        "*"
      ]
    },
    "evtsetall": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nevtsetall(event_mask *m)\n{\n\tint i;\n\t\n\tm->sys_mask = 0;\n\tm->gen_mask = 0;\n\tfor (i = 0; i < genev_xlat[i].gen_mask; i++) {\n\t\tm->gen_mask |= genev_xlat[i].gen_mask;\n\t\tm->sys_mask |= genev_xlat[i].sys_mask;\n\t}\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/src/ev_inotify.c": {
    "sysev_filemask": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "int\nsysev_filemask(struct dirwatcher *dp)\n{\n\treturn 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sysev_init": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nsysev_init()\n{\n\tifd = inotify_init();\n\tif (ifd == -1) {\n\t\tdiag(LOG_CRIT, \"inotify_init: %s\", strerror(errno));\n\t\texit(1);\n\t}\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sysev_add_watch": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "int\nsysev_add_watch(struct dirwatcher *dwp, event_mask mask)\n{\n\treturn inotify_add_watch(ifd, dwp->dirname, mask.sys_mask);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "sysev_rm_watch": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nsysev_rm_watch(struct dirwatcher *dwp)\n{\n\tinotify_rm_watch(ifd, dwp->wd);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "remove_watcher": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nremove_watcher(const char *dir, const char *name)\n{\n\tstruct dirwatcher *dwp;\n\tchar *fullname = mkfilename(dir, name);\n\tif (!fullname) {\n\t\tdiag(LOG_EMERG, \"not enough memory: \"\n\t\t     \"cannot look up a watcher to delete\");\n\t\treturn;\n\t}\n\tdwp = dirwatcher_lookup(fullname);\n\tfree(fullname);\n\tif (dwp)\n\t\tdirwatcher_destroy(dwp);\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "process_event": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void\nprocess_event(struct inotify_event *ep)\n{\n\tstruct dirwatcher *dp;\n\tstruct handler *h;\n\tevent_mask m;\n\tchar *dirname, *filename;\n\t\n\tdp = dirwatcher_lookup_wd(ep->wd);\n\tif (ep->mask & IN_IGNORED)\n\t\treturn;\n\telse if (ep->mask & IN_Q_OVERFLOW) {\n\t\tdiag(LOG_NOTICE,\n\t\t     \"event queue overflow\");\n\t\treturn;\n\t} else if (ep->mask & IN_UNMOUNT) {\n\t\t/* FIXME: not sure if there's\n\t\t   anything to do. Perhaps we should\n\t\t   deregister the watched dirs that\n\t\t   were located under the mountpoint\n\t\t*/\n\t\treturn;\n\t} else if (!dp) {\n\t\tif (ep->name)\n\t\t\tdiag(LOG_NOTICE, \"unrecognized event %x\"\n\t\t\t     \"for %s\", ep->mask, ep->name);\n\t\telse\n\t\t\tdiag(LOG_NOTICE,\n\t\t\t     \"unrecognized event %x\", ep->mask);\n\t\treturn;\n\t}\n\n\tev_log(ep->mask, dp);\n\n\tif (ep->mask & IN_CREATE) {\n\t\tdebug(1, (\"%s/%s created\", dp->dirname, ep->name));\n\t\tif (check_new_watcher(dp->dirname, ep->name) > 0)\n\t\t\treturn;\n\t} else if (ep->mask & (IN_DELETE|IN_MOVED_FROM)) {\n\t\tdebug(1, (\"%s/%s deleted\", dp->dirname, ep->name));\n\t\tremove_watcher(dp->dirname, ep->name);\n\t}\n\n\tif (ep->len == 0)\n\t\tfilename = split_pathname(dp, &dirname);\n\telse {\n\t\tdirname = dp->dirname;\n\t\tfilename = ep->name;\n\t}\n\tfor (h = dp->handler_list; h; h = h->next) {\n\t\tif (handler_matches_event(h, sys, ep->mask, filename))\n\t\t\trun_handler(h, event_mask_init(&m,\n\t\t\t\t\t\t       ep->mask,\n\t\t\t\t\t\t       &h->ev_mask),\n\t\t\t\t    dirname, filename);\n\t}\n\tunsplit_pathname(dp);\n}",
      "lines": 58,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sysev_select": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\nsysev_select()\n{\n\tchar buffer[4096];\n\tstruct inotify_event *ep;\n\tsize_t size;\n\tssize_t rdbytes;\n\n\trdbytes = read(ifd, buffer, sizeof(buffer));\n\tif (rdbytes == -1) {\n\t\tif (errno == EINTR) {\n\t\t\tif (signo == SIGCHLD || signo == SIGALRM)\n\t\t\t\treturn 0;\n\t\t\tdiag(LOG_NOTICE, \"got signal %d\", signo);\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\tdiag(LOG_NOTICE, \"read failed: %s\", strerror(errno));\n\t\treturn 1;\n\t}\n\t\t\n\tep = (struct inotify_event *) buffer;\n\twhile (rdbytes) {\n\t\tif (ep->wd >= 0)\n\t\t\tprocess_event(ep);\n\t\tsize = sizeof(*ep) + ep->len;\n\t\tep = (struct inotify_event *) ((char*) ep + size);\n\t\trdbytes -= size;\n\t}\n\t\n\treturn 0;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/ev_kqueue.c": {
    "sysev_init": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nsysev_init()\n{\n\tkq = kqueue();\n\tif (kq == -1) {\n\t\tdiag(LOG_CRIT, \"kqueue: %s\", strerror(errno));\n\t\texit(1);\n\t}\n\tevtab = calloc(sysconf(_SC_OPEN_MAX), sizeof(evtab[0]));\n\tchtab = calloc(sysconf(_SC_OPEN_MAX), sizeof(chtab[0]));\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sysev_filemask": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "int\nsysev_filemask(struct dirwatcher *dp)\n{\n\tstruct handler *h;\n\n\tfor (h = dp->handler_list; h; h = h->next) {\n\t\tif (h->ev_mask.sys_mask)\n\t\t\treturn S_IFMT;\n\t}\n\treturn 0;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sysev_add_watch": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "int\nsysev_add_watch(struct dirwatcher *dwp, event_mask mask)\n{\n\tint wd = open(dwp->dirname, O_RDONLY);\n\tif (wd >= 0) {\n\t\tstruct stat st;\n\t\tint sysmask;\n\t\t\n\t\tif (fstat(wd, &st)) {\n\t\t\tclose(wd);\n\t\t\treturn -1;\n\t\t}\n\t\tdwp->file_mode = st.st_mode;\n\t\tdwp->file_ctime = st.st_ctime;\n\t\tsysmask = mask.sys_mask;\n\t\tif (S_ISDIR(st.st_mode) && mask.gen_mask & GENEV_CREATE)\n\t\t\tsysmask |= NOTE_WRITE;\n\t\tEV_SET(chtab + chcnt, wd, EVFILT_VNODE,\n\t\t       EV_ADD | EV_ENABLE | EV_CLEAR, sysmask,\n\t\t       0, dwp);\n\t\twd = chcnt++;\n\t}\n\treturn wd;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sysev_rm_watch": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\nsysev_rm_watch(struct dirwatcher *dwp)\n{\n\tclose(chtab[dwp->wd].ident);\n\tchtab[dwp->wd].ident = -1;\n\tif (chclosed == -1 || chclosed > dwp->wd)\n\t\tchclosed = dwp->wd;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "chclosed_elim": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\nchclosed_elim()\n{\n\tint i, j;\n\t\n\tif (chclosed == -1)\n\t\treturn;\n\n\tfor (i = chclosed, j = chclosed + 1; j < chcnt; j++)\n\t\tif (chtab[j].ident != -1) {\n\t\t\tstruct dirwatcher *dwp;\n\t\t\t\n\t\t\tchtab[i] = chtab[j];\n\t\t\tdwp = chtab[i].udata;\n\t\t\tdwp->wd = i;\n\t\t\ti++;\n\t\t}\n\tchcnt = i;\n\tchclosed = -1;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_created": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static void\ncheck_created(struct dirwatcher *dp)\n{\n\tDIR *dir;\n\tstruct dirent *ent;\n\tstruct handler *h;\n\n\tdir = opendir(dp->dirname);\n\tif (!dir) {\n\t\tdiag(LOG_ERR, \"cannot open directory %s: %s\",\n\t\t     dp->dirname, strerror(errno));\n\t\treturn;\n\t}\n\n\twhile (ent = readdir(dir)) {\n\t\tstruct stat st;\n\t\tchar *pathname;\n\t\t\n\t\tif (ent->d_name[0] == '.' &&\n\t\t    (ent->d_name[1] == 0 ||\n\t\t     (ent->d_name[1] == '.' && ent->d_name[2] == 0)))\n\t\t\tcontinue;\n\t\t\n\t\tpathname = mkfilename(dp->dirname, ent->d_name);\n\t\tif (!pathname) {\n\t\t\tdiag(LOG_ERR, \"cannot stat %s/%s: not enough memory\",\n\t\t\t     dp->dirname, ent->d_name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (stat(pathname, &st)) {\n\t\t\tdiag(LOG_ERR, \"cannot stat %s: %s\",\n\t\t\t     pathname, strerror(errno));\n\t\t/* If ok, first see if the file is newer than the last\n\t\t   directory scan.  If not, there is still a chance\n\t\t   the file is new (the timestamp precision leaves a\n\t\t   time window long enough for a file to be created)\n\t\t   so try the more expensive hash lookup to see if we\n\t\t   know about that file.  If the file is new, register\n\t\t   a watcher for it. */\n\t\t} else if (st.st_ctime > dp->file_ctime ||\n\t\t\t   !dirwatcher_lookup(pathname)) {\n\t\t\tdeliver_ev_create(dp, ent->d_name);\n\t\t\tsubwatcher_create(dp, pathname,\n\t\t\t\t\t  S_ISDIR(st.st_mode), 1);\n\t\t\tdp->file_ctime = st.st_ctime;\n\t\t}\n\t\tfree(pathname);\n\t}\n\tclosedir(dir);\n}",
      "lines": 51,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_event": {
      "start_point": [
        180,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "static void\nprocess_event(struct kevent *ep)\n{\n\tstruct dirwatcher *dp = ep->udata;\n\tstruct handler *h;\n\tevent_mask m;\n\tchar *filename, *dirname;\n\t\n\tif (!dp) {\n\t\tdiag(LOG_NOTICE, \"unrecognized event %x\", ep->fflags);\n\t\treturn;\n\t}\n\n\tev_log(ep->fflags, dp);\n\n\tif (S_ISDIR(dp->file_mode)) {\n\t\t/* Check if new files have appeared. */\n\t\tif (ep->fflags & NOTE_WRITE)\n\t\t\tcheck_created(dp);\n\t\treturn;\n\t}\n\n\tfilename = split_pathname(dp, &dirname);\n\tfor (h = dp->handler_list; h; h = h->next) {\n\t\tif (handler_matches_event(h, sys, ep->fflags, filename)) {\n\t\t\trun_handler(h,\n\t\t\t\t    event_mask_init(&m, ep->fflags, &h->ev_mask),\n\t\t\t\t    dirname, filename);\n\t\t}\n\t}\n\tunsplit_pathname(dp);\n\t\n\tif (ep->fflags & (NOTE_DELETE|NOTE_RENAME)) {\n\t\tdebug(1, (\"%s deleted\", dp->dirname));\n\t\tdirwatcher_destroy(dp);\n\t\treturn;\n\t}\n}",
      "lines": 38,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sysev_select": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        241,
        1
      ],
      "content": "int\nsysev_select()\n{\n\tint i, n;\n\t\n\tchclosed_elim();\n\tn = kevent(kq, chtab, chcnt, evtab, chcnt, NULL);\n\tif (n == -1) {\n\t\tif (errno == EINTR) {\n\t\t\tif (signo == SIGCHLD || signo == SIGALRM)\n\t\t\t\treturn 0;\n\t\t\tdiag(LOG_NOTICE, \"got signal %d\", signo);\n\t\t}\n\t\tdiag(LOG_ERR, \"kevent: %s\", strerror(errno));\n\t\treturn 1;\n\t} \n\n\tfor (i = 0; i < n; i++) \n\t\tprocess_event(&evtab[i]);\n\n\treturn 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/fnpat.c": {
    "filename_pattern_free": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "void\nfilename_pattern_free(void *p)\n{\n\tstruct filename_pattern *pat = p;\n\tswitch (pat->type) {\n\tcase PAT_GLOB:\n\t\tfree(pat->v.glob);\n\t\tbreak;\n\tcase PAT_REGEX:\n\t\tregfree(&pat->v.re);\n\t}\n\tfree(pat);\n}",
      "lines": 13,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "filename_pattern_match": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nfilename_pattern_match(struct grecs_list *lp, const char *name)\n{\n\tstruct grecs_list_entry *ep;\n\n\tif (!lp)\n\t\treturn 0;\n\tfor (ep = lp->head; ep; ep = ep->next) {\n\t\tstruct filename_pattern *pat = ep->data;\n\t\tint rc;\n\t\t\n\t\tswitch (pat->type) {\n\t\tcase PAT_GLOB:\n\t\t\trc = fnmatch(pat->v.glob, name, FNM_PATHNAME);\n\t\t\tbreak;\n\t\tcase PAT_REGEX:\n\t\t\trc = regexec(&pat->v.re, name, 0, NULL, 0);\n\t\t\tbreak;\n\t\t}\n\t\tif (pat->neg)\n\t\t\trc = !rc;\n\t\tif (rc == 0)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
      "lines": 26,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/gettext.h": {
    "pgettext_aux": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static const char *\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)\n{\n  const char *translation = dcgettext (domain, msg_ctxt_id, category);\n  if (translation == msg_ctxt_id)\n    return msgid;\n  else\n    return translation;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\npgettext_aux (const char *domain,\n              const char *msg_ctxt_id, const char *msgid,\n              int category)",
        "*"
      ]
    },
    "npgettext_aux": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "static const char *\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)\n{\n  const char *translation =\n    dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n  if (translation == msg_ctxt_id || translation == msgid_plural)\n    return (n == 1 ? msgid : msgid_plural);\n  else\n    return translation;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\nnpgettext_aux (const char *domain,\n               const char *msg_ctxt_id, const char *msgid,\n               const char *msgid_plural, unsigned long int n,\n               int category)",
        "*"
      ]
    },
    "dcpgettext_expr": {
      "start_point": [
        200,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "static const char *\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcgettext (domain, msg_ctxt_id, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (translation != msg_ctxt_id)\n        return translation;\n    }\n  return msgid;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcpgettext_expr (const char *domain,\n                 const char *msgctxt, const char *msgid,\n                 int category)",
        "*"
      ]
    },
    "dcnpgettext_expr": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static const char *\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)\n{\n  size_t msgctxt_len = strlen (msgctxt) + 1;\n  size_t msgid_len = strlen (msgid) + 1;\n  const char *translation;\n#if _LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n  char msg_ctxt_id[msgctxt_len + msgid_len];\n#else\n  char buf[1024];\n  char *msg_ctxt_id =\n    (msgctxt_len + msgid_len <= sizeof (buf)\n     ? buf\n     : (char *) malloc (msgctxt_len + msgid_len));\n  if (msg_ctxt_id != NULL)\n#endif\n    {\n      memcpy (msg_ctxt_id, msgctxt, msgctxt_len - 1);\n      msg_ctxt_id[msgctxt_len - 1] = '\\004';\n      memcpy (msg_ctxt_id + msgctxt_len, msgid, msgid_len);\n      translation = dcngettext (domain, msg_ctxt_id, msgid_plural, n, category);\n#if !_LIBGETTEXT_HAVE_VARIABLE_SIZE_ARRAYS\n      if (msg_ctxt_id != buf)\n        free (msg_ctxt_id);\n#endif\n      if (!(translation == msg_ctxt_id || translation == msgid_plural))\n        return translation;\n    }\n  return (n == 1 ? msgid : msgid_plural);\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\ndcnpgettext_expr (const char *domain,\n                  const char *msgctxt, const char *msgid,\n                  const char *msgid_plural, unsigned long int n,\n                  int category)",
        "*"
      ]
    }
  },
  "direvent/direvent-5.1/src/hashtab.c": {
    "hashent_free": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\nhashent_free(struct hashtab *st, void *ptr)\n{\n\tif (st->hashent_free_fun)\n\t\tst->hashent_free_fun(ptr);\n\telse\n\t\tfree(ptr);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hashent_alloc": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static struct hashent *\nhashent_alloc(struct hashtab *st, void *key)\n{\n\tstruct hashent *ent;\n\t\n\tent = st->hashent_alloc_fun ?\n\t\tst->hashent_alloc_fun(st->elsize) : malloc(st->elsize);\n\tif (ent) {\n\t\tmemset(ent, 0, st->elsize);\n\t\tif (st->copy_fun(ent, key)) {\n\t\t\tint ec = errno;\n\t\t\thashent_free(st, ent);\n\t\t\terrno = ec;\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn ent;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "struct hashent",
        "struct",
        "hashent",
        "*\nhashent_alloc(struct hashtab *st, void *key)",
        "*"
      ]
    },
    "hashtab_insert_pos": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static unsigned\nhashtab_insert_pos(struct hashtab *st, void *elt)\n{\n\tunsigned i;\n\tunsigned pos = st->hash_fun(elt, hash_size[st->hash_num]);\n\t\n\tfor (i = pos; st->tab[i];) {\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\t/* FIXME: Error message? */\n\t\t\tabort();\n\t}\n\treturn i;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "hashtab_replace": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "int\nhashtab_replace(struct hashtab *st, void *ent, void **old_ent)\n{\n\tstruct hashent *entry;\n\tunsigned i, pos = st->hash_fun(ent, hash_size[st->hash_num]);\n\tfor (i = pos; entry = st->tab[i];) {\n\t\tif (st->cmp_fun(entry, ent) == 0)\n\t\t\tbreak;\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\treturn ENOENT;\n\t}\n\tif (old_ent)\n\t\t*old_ent = entry;\n\tst->tab[i] = ent;\n\treturn 0;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "hashtab_rehash": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static int\nhashtab_rehash(struct hashtab *st)\n{\n\tstruct hashent **old_tab = st->tab;\n\tstruct hashent **new_tab;\n\tunsigned int i;\n\tunsigned int hash_num = st->hash_num + 1;\n\t\n\tif (hash_num >= max_rehash)\n\t\treturn E2BIG;\n\n\tnew_tab = calloc(hash_size[hash_num], sizeof(*new_tab));\n\tif (!new_tab)\n\t\treturn ENOMEM;\n\tst->tab = new_tab;\n\tif (old_tab) {\n\t\tst->hash_num = hash_num;\n\t\tfor (i = 0; i < hash_size[hash_num-1]; i++) {\n\t\t\tstruct hashent *elt = old_tab[i];\n\t\t\tif (elt->used) {\n\t\t\t\tunsigned n = hashtab_insert_pos(st, elt);\n\t\t\t\tnew_tab[n] = elt;\n\t\t\t}\n\t\t}\n\t\tfree(old_tab);\n\t}\n\treturn 0;\n}",
      "lines": 28,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "hashtab_strerror": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "const char *\nhashtab_strerror(int rc)\n{\n\tswitch (rc) {\n\tcase ENOENT:\n\t\treturn _(\"element not found in table\");\n\tcase E2BIG:\n\t\treturn _(\"symbol table is full\");\n\tcase ENOMEM:\n\t\treturn _(\"out of memory\");\n\t}\n\treturn strerror(rc);\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nhashtab_strerror(int rc)",
        "*"
      ]
    },
    "hashtab_remove": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "int\nhashtab_remove(struct hashtab *st, void *elt)\n{\n\tunsigned int pos, i, j, r;\n\tstruct hashent *entry;\n\t\n\tpos = st->hash_fun(elt, hash_size[st->hash_num]);\n\tfor (i = pos; entry = st->tab[i];) {\n\t\tif (st->cmp_fun(entry, elt) == 0)\n\t\t\tbreak;\n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\treturn ENOENT;\n\t}\n\t\n\thashent_free(st, entry);\n\n\tfor (;;) {\n\t\tst->tab[i] = NULL;\n\t\tj = i;\n\n\t\tdo {\n\t\t\tif (++i >= hash_size[st->hash_num])\n\t\t\t\ti = 0;\n\t\t\tif (!st->tab[i])\n\t\t\t\treturn 0;\n\t\t\tr = st->hash_fun(st->tab[i], hash_size[st->hash_num]);\n\t\t}\n\t\twhile ((j < r && r <= i)\n\t\t       || (i < j && j < r) || (r <= i && i < j));\n\t\tst->tab[j] = st->tab[i];\n\t}\n\treturn 0;\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "hashtab_get_index": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "int\nhashtab_get_index(unsigned *idx, struct hashtab *st, void *key, int *install)\n{\n\tint rc;\n\tunsigned i, pos;\n\tstruct hashent *elem;\n  \n\tif (!st->tab) {\n\t\tif (install) {\n\t\t\trc = hashtab_rehash(st);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t} else\n\t\t\treturn ENOENT;\n\t}\n\n\tpos = st->hash_fun(key, hash_size[st->hash_num]);\n\n\tfor (i = pos; elem = st->tab[i];) {\n\t\tif (st->cmp_fun(elem, key) == 0) {\n\t\t\tif (install)\n\t\t\t\t*install = 0;\n\t\t\t*idx = i; \n\t\t\treturn 0;\n\t\t}\n      \n\t\tif (++i >= hash_size[st->hash_num])\n\t\t\ti = 0;\n\t\tif (i == pos)\n\t\t\tbreak;\n\t}\n\n\tif (!install)\n\t\treturn ENOENT;\n  \n\tif (!elem) {\n\t\t*install = 1;\n\t\t*idx = i;\n\t\treturn 0;\n\t}\n\n\tif ((rc = hashtab_rehash(st)) != 0)\n\t\treturn rc;\n\n\treturn hashtab_get_index(idx, st, key, install);\n}",
      "lines": 46,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "hashtab_lookup_or_install": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "void *\nhashtab_lookup_or_install(struct hashtab *st, void *key, int *install)\n{\n\tunsigned i;\n\tint rc = hashtab_get_index(&i, st, key, install);\n\tif (rc == 0) {\n\t\tif (install && *install == 1) {\n\t\t\tstruct hashent *ent = hashent_alloc(st, key);\n\t\t\tif (!ent) {\n\t\t\t\terrno = ENOMEM;\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tst->tab[i] = ent;\n\t\t\treturn ent;\n\t\t} else\n\t\t\treturn st->tab[i];\n\t}\n\terrno = rc;\n\treturn NULL;\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void",
        "*\nhashtab_lookup_or_install(struct hashtab *st, void *key, int *install)",
        "*"
      ]
    },
    "hashtab_clear": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\nhashtab_clear(struct hashtab *st)\n{\n\tunsigned i, hs;\n  \n\tif (!st || !st->tab)\n\t\treturn;\n\n\ths = hash_size[st->hash_num];\n\tfor (i = 0; i < hs; i++) {\n\t\tstruct hashent *elem = st->tab[i];\n\t\tif (elem) {\n\t\t\thashent_free(st, elem);\n\t\t\tst->tab[i] = NULL;\n\t\t}\n\t}\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "hashtab_create": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "struct hashtab *\nhashtab_create(size_t elsize, \n\t       unsigned (*hash_fun)(void *, unsigned long),\n\t       int (*cmp_fun)(const void *, const void *),\n\t       int (*copy_fun)(void *, void *),\n\t       void *(*alloc_fun)(size_t), void (*free_fun)(void *))\n{\n\tstruct hashtab *st = malloc(sizeof(*st));\n\tif (st) {\n\t\tmemset(st, 0, sizeof(*st));\n\t\tst->elsize = elsize;\n\t\tst->hash_fun = hash_fun;\n\t\tst->cmp_fun = cmp_fun;\n\t\tst->copy_fun = copy_fun;\n\t\tst->hashent_alloc_fun = alloc_fun;\n\t\tst->hashent_free_fun = free_fun;\n\t\tst->tab = calloc(hash_size[st->hash_num], sizeof(*st->tab));\n\t\tif (!st->tab) {\n\t\t\tfree(st);\n\t\t\tst = NULL;\n\t\t}\n\t}\n\treturn st;\n}",
      "lines": 24,
      "depth": 13,
      "decorators": [
        "struct hashtab",
        "struct",
        "hashtab",
        "*\nhashtab_create(size_t elsize, \n\t       unsigned (*hash_fun)(void *, unsigned long),\n\t       int (*cmp_fun)(const void *, const void *),\n\t       int (*copy_fun)(void *, void *),\n\t       void *(*alloc_fun)(size_t), void (*free_fun)(void *))",
        "*"
      ]
    },
    "hashtab_free": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "void\nhashtab_free(struct hashtab *st)\n{\n\tif (st) {\n\t\thashtab_clear(st);\n\t\tfree(st->tab);\n\t\tfree(st);\n\t}\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hashtab_count_entries": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        315,
        1
      ],
      "content": "size_t\nhashtab_count_entries(struct hashtab *st)\n{\n\tunsigned i;\n\tsize_t count = 0;\n\t\n\tfor (i = 0; i < hash_size[st->hash_num]; i++)\n\t\tif (st->tab[i])\n\t\t\tcount++;\n\treturn count;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "size_t"
      ]
    },
    "hashtab_foreach": {
      "start_point": [
        317,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "int\nhashtab_foreach(struct hashtab *st, hashtab_enumerator_t fun, void *data)\n{\n\tunsigned i;\n\n\tif (!st)\n\t\treturn 0;\n\tfor (i = 0; i < hash_size[st->hash_num]; i++) {\n\t\tstruct hashent *ep = st->tab[i];\n\t\tif (ep) {\n\t\t\tint rc = fun(ep, data);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "hashtab_count": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        348,
        1
      ],
      "content": "size_t\nhashtab_count(struct hashtab *st)\n{\n\tunsigned i;\n\tsize_t count = 0;\n\t\n\tif (!st)\n\t\treturn 0;\n\tfor (i = 0; i < hash_size[st->hash_num]; i++) {\n\t\tif (st->tab[i])\n\t\t\t++count;\n\t}\n\treturn count;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    }
  },
  "direvent/direvent-5.1/src/progman.c": {
    "proc_unlink": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "struct process *\nproc_unlink(struct process **root, struct process *p)\n{\n\tif (p->prev)\n\t\tp->prev->next = p->next;\n\telse\n\t\t*root = p->next;\n\tif (p->next)\n\t\tp->next->prev = p->prev;\n\tp->next = p->prev = NULL;\n\treturn p;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "struct process",
        "struct",
        "process",
        "*\nproc_unlink(struct process **root, struct process *p)",
        "*"
      ]
    },
    "proc_pop": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "struct process *\nproc_pop(struct process **pp)\n{\n\tif (*pp)\n\t\treturn proc_unlink(pp, *pp);\n\treturn NULL;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "struct process",
        "struct",
        "process",
        "*\nproc_pop(struct process **pp)",
        "*"
      ]
    },
    "proc_push": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\nproc_push(struct process **pp, struct process *p)\n{\n\tp->prev = NULL;\n\tp->next = *pp;\n\tif (*pp)\n\t\t(*pp)->prev = p;\n\t*pp = p;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "register_process": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "struct process *\nregister_process(int type, pid_t pid, time_t t, unsigned timeout)\n{\n\tstruct process *p;\n\n\tif (proc_avail)\n\t\tp = proc_pop(&proc_avail);\n\telse\n\t\tp = emalloc(sizeof(*p));\n\tmemset(p, 0, sizeof(*p));\n\tp->type = type;\n\tp->timeout = timeout;\n\tp->pid = pid;\n\tp->start = t;\n\tproc_push(&proc_list, p);\n\treturn p;\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "struct process",
        "struct",
        "process",
        "*\nregister_process(int type, pid_t pid, time_t t, unsigned timeout)",
        "*"
      ]
    },
    "deregister_process": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\nderegister_process(pid_t pid, time_t t)\n{\n\tstruct process *p;\n\n\tfor (p = proc_list; p; p = p->next)\n\t\tif (p->pid == pid) {\n\t\t\tif (p->prev)\n\t\t\t\tp->prev->next = p->next;\n\t\t\telse\n\t\t\t\tproc_list = p;\n\t\t\tif (p->next)\n\t\t\t\tp->next->prev = p->prev;\n\t\t\tfree(p);\n\t\t\tbreak;\n\t\t}\n}",
      "lines": 17,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "process_lookup": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "struct process *\nprocess_lookup(pid_t pid)\n{\n\tstruct process *p;\n\n\tfor (p = proc_list; p; p = p->next)\n\t\tif (p->pid == pid)\n\t\t\treturn p;\n\treturn NULL;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "struct process",
        "struct",
        "process",
        "*\nprocess_lookup(pid_t pid)",
        "*"
      ]
    },
    "print_status": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static void\nprint_status(pid_t pid, int status, sigset_t *mask)\n{\n\tif (WIFEXITED(status)) {\n\t\tif (WEXITSTATUS(status) == 0)\n\t\t\tdebug(1, (_(\"process %lu exited successfully\"),\n\t\t\t\t  (unsigned long) pid));\n\t\telse\n\t\t\tdiag(LOG_ERR, _(\"process %lu failed with status %d\"),\n\t\t\t     (unsigned long) pid, WEXITSTATUS(status));\n\t} else if (WIFSIGNALED(status)) {\n\t\tint prio;\n\n\t\tif (sigismember(mask, WTERMSIG(status)))\n\t\t\tprio = LOG_DEBUG;\n\t\telse\n\t\t\tprio = LOG_ERR;\n\n\t\tdiag(prio, _(\"process %lu terminated on signal %d\"),\n\t\t     (unsigned long) pid, WTERMSIG(status));\n\t} else if (WIFSTOPPED(status))\n\t\tdiag(LOG_ERR, _(\"process %lu stopped on signal %d\"),\n\t\t     (unsigned long) pid, WSTOPSIG(status));\n#ifdef WCOREDUMP\n\telse if (WCOREDUMP(status))\n\t\tdiag(LOG_ERR,\n\t\t     _(\"process %lu dumped core\"), (unsigned long) pid);\n#endif\n\telse\n\t\tdiag(LOG_ERR,\n\t\t     _(\"process %lu terminated with unrecognized status\"),\n\t\t     (unsigned long) pid);\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "process_cleanup": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "void\nprocess_cleanup(int expect_term)\n{\n\tpid_t pid;\n\tint status;\n\t\n\twhile ((pid = waitpid(-1, &status, WNOHANG)) > 0) {\n\t\tsigset_t set;\n\t\tsigemptyset(&set);\n\n\t\tif (pid == self_test_pid) {\n\t\t\tsigaddset(&set, SIGHUP);\n\t\t\tprint_status(pid, status, &set);\n\t\t\t\n\t\t\tif (WIFEXITED(status))\n\t\t\t\texit_code = WEXITSTATUS(status);\n\t\t\telse if (WIFSIGNALED(status)) {\n\t\t\t\tif (WTERMSIG(status) == SIGHUP)\n\t\t\t\t\texit_code = 0;\n\t\t\t\telse\n\t\t\t\t\texit_code = 2;\n\t\t\t} else\n\t\t\t\texit_code = 2;\n\t\t\tstop = 1;\n\t\t} else {\n\t\t\tstruct process *p = process_lookup(pid);\n\n\t\t\tif (expect_term)\n\t\t\t\tsigaddset(&set, SIGTERM);\n\t\t\tif (!p) {\n\t\t\t\tsigaddset(&set, SIGTERM);\n\t\t\t\tsigaddset(&set, SIGKILL);\n\t\t\t}\n\t\t\tprint_status(pid, status, &set);\n\t\t\tif (!p)\n\t\t\t\tcontinue;\n\n\t\t\tif (p->type == PROC_HANDLER) {\n\t\t\t\tif (p->v.redir[REDIR_OUT])\n\t\t\t\t\tp->v.redir[REDIR_OUT]->v.master = NULL;\n\t\t\t\tif (p->v.redir[REDIR_ERR])\n\t\t\t\t\tp->v.redir[REDIR_ERR]->v.master = NULL;\n\t\t\t}\n\t\t\tp->pid = 0;\n\t\t\tproc_unlink(&proc_list, p);\n\t\t\tproc_push(&proc_avail, p);\n\t\t}\n\t}\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "process_timeouts": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\nprocess_timeouts()\n{\n\tstruct process *p;\n\ttime_t now = time(NULL);\n\ttime_t alarm_time = 0, x;\n\n\tdebug(2, (_(\"begin scanning process list\")));\n\tfor (p = proc_list; p; p = p->next) {\n\t\tx = now - p->start;\n\t\tif (x >= p->timeout) {\n\t\t\tdiag(LOG_ERR, _(\"process %lu timed out\"),\n\t\t\t     (unsigned long) p->pid);\n\t\t\tkill(p->pid, SIGKILL);\n\t\t} else if (alarm_time == 0 ||\n\t\t\t   p->timeout - x < alarm_time)\n\t\t\talarm_time = p->timeout - x;\n\t}\n\n\tif (alarm_time) {\n\t\tdebug(2, (_(\"scheduling alarm in %lu seconds\"),\n\t\t\t  (unsigned long) alarm_time));\n\t\talarm(alarm_time);\n\t}\n\tdebug(2, (\"end scanning process list\"));\n}",
      "lines": 26,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "switchpriv": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "int\nswitchpriv(struct handler *hp)\n{\n\tif (hp->uid == 0 || hp->uid == getuid())\n\t\treturn 0;\n\t\n\tif (setgroups(hp->gidc, hp->gidv) < 0) {\n\t\tdiag(LOG_CRIT, \"setgroups: %s\",\n\t\t     strerror(errno));\n\t\treturn 1;\n\t}\n\tif (setregid(hp->gidv[0], hp->gidv[0]) < 0) {\n\t\tdiag(LOG_CRIT, \"setregid(%lu,%lu): %s\",\n\t\t     (unsigned long) hp->gidv[0],\n\t\t     (unsigned long) hp->gidv[0],\n\t\t     strerror(errno));\n\t\treturn 1;\n\t}\n\tif (setreuid(hp->uid, hp->uid) < 0) {\n\t\tdiag(LOG_CRIT, \"setreuid(%lu,%lu): %s\",\n\t\t     (unsigned long) hp->uid,\n\t\t     (unsigned long) hp->uid,\n\t\t     strerror(errno));\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "close_fds": {
      "start_point": [
        290,
        0
      ],
      "end_point": [
        300,
        1
      ],
      "content": "static void\nclose_fds(bigfd_set fdset)\n{\n\tint i;\n\n\tfor (i = sysconf(_SC_OPEN_MAX) - 1; i >= 0; i--) {\n\t\tif (fdset && BIGFD_ISSET(i, fdset))\n\t\t\tcontinue;\n\t\tclose(i);\n\t}\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "redir_exit": {
      "start_point": [
        304,
        0
      ],
      "end_point": [
        308,
        1
      ],
      "content": "static void\nredir_exit(int sig)\n{\n\t_exit(0);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "open_redirector": {
      "start_point": [
        310,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "int\nopen_redirector(const char *tag, int prio, struct process **return_proc)\n{\n\tint p[2];\n\tFILE *fp;\n\tchar buf[512];\n\tpid_t pid;\n\tbigfd_set fdset;\n\n\tif (pipe(p)) {\n\t\tdiag(LOG_ERR,\n\t\t     _(\"cannot start redirector for %s, pipe failed: %s\"),\n\t\t     tag, strerror(errno));\n\t\treturn -1;\n\t}\n\tswitch (pid = fork()) {\n\tcase 0:\n\t\t/* Redirector process */\n\t\tfdset = BIGFD_SET_ALLOC();\n\t\tBIGFD_SET(p[0], fdset);\n\t\tif (facility <= 0)\n\t\t\tBIGFD_SET(2, fdset);\n\t\tclose_fds(fdset);\n\t\t\n\t\talarm(0);\n\t\tsignal_setup(redir_exit);\n\n\t\tfp = fdopen(p[0], \"r\");\n\t\tif (fp == NULL)\n\t\t\t_exit(1);\n\t\tif (facility > 0) \n\t\t\topenlog(tag, LOG_PID, facility);\n\n\t\twhile (fgets(buf, sizeof(buf), fp) > 0) {\n\t\t\tint len = strlen(buf);\n\t\t\tif (len && buf[len-1] == '\\n')\n\t\t\t\tbuf[len-1] = 0;\n\t\t\tdiag(prio, \"%s\", buf);\n\t\t}\n\t\t_exit(0);\n      \n\tcase -1:\n\t\tdiag(LOG_CRIT,\n\t\t     _(\"cannot run redirector `%s': fork failed: %s\"),\n\t\t     tag, strerror(errno));\n\t\treturn -1;\n\n\tdefault:\n\t\tdebug(1, (_(\"redirector for %s started, pid=%lu\"),\n\t\t\t  tag, (unsigned long) pid));\n\t\tclose(p[0]);\n\t\t*return_proc = register_process(PROC_REDIR, pid, \n\t\t\t\t\t\ttime(NULL), 0);\n\t\treturn p[1];\n\t}\n}",
      "lines": 56,
      "depth": 15,
      "decorators": [
        "int"
      ]
    },
    "runcmd": {
      "start_point": [
        367,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "static void\nruncmd(const char *cmd, char **envhint, event_mask *event, const char *file,\n       int shell)\n{\n\tchar *kve[13];\n\tchar *p,*q;\n\tchar buf[1024];\n\tint i = 0, j;\n\tchar **argv;\n\tchar *xargv[4];\n\tstruct wordsplit ws;\n\t\n\tkve[i++] = \"file\";\n\tkve[i++] = (char*) file;\n\t\n\tsnprintf(buf, sizeof buf, \"%d\", event->sys_mask);\n\tkve[i++] = \"sysev_code\";\n\tkve[i++] = estrdup(buf);\n\n\tif (self_test_pid) {\n\t\tsnprintf(buf, sizeof buf, \"%lu\", (unsigned long)self_test_pid);\n\t\tkve[i++] = \"self_test_pid\";\n\t\tkve[i++] = estrdup(buf);\n\t}\n\t\n\tq = buf;\n\tfor (p = trans_tokfirst(sysev_transtab, event->sys_mask, &j); p;\n\t     p = trans_toknext(sysev_transtab, event->sys_mask, &j)) {\n\t\tif (q > buf)\n\t\t\t*q++ = ' ';\n\t\twhile (*p)\n\t\t\t*q++ = *p++;\n\t}\n\t*q = 0;\t\n\tif (q > buf) {\n\t\tkve[i++] = \"sysev_name\";\n\t\tkve[i++] = estrdup(buf);\n\t}\n\tp = trans_toktostr(genev_transtab, event->gen_mask);\n\tif (p) {\n\t\tsnprintf(buf, sizeof buf, \"%d\", event->gen_mask);\n\t\tkve[i++] = \"genev_code\";\n\t\tkve[i++] = estrdup(buf);\n\t\tkve[i++] = \"genev_name\";\n\t\tkve[i++] = p;\n\t}\n\tkve[i++] = 0;\n\n\tws.ws_env = (const char **) kve;\n\tif (wordsplit(cmd, &ws,\n\t\t      WRDSF_NOCMD | WRDSF_QUOTE\n\t\t      | WRDSF_SQUEEZE_DELIMS | WRDSF_CESCAPES\n\t\t      | WRDSF_ENV | WRDSF_ENV_KV\n\t\t      | (shell ? WRDSF_NOSPLIT : 0))) {\n\t\tdiag(LOG_CRIT, \"wordsplit: %s\",\n\t\t     wordsplit_strerror (&ws));\n\t\t_exit(127);\n\t}\n\t\n\tif (shell) {\n\t\txargv[0] = \"/bin/sh\";\n\t\txargv[1] = \"-c\";\n\t\txargv[2] = ws.ws_wordv[0];\n\t\txargv[3] = NULL;\n\t\targv = xargv;\n\t} else\n\t\targv = ws.ws_wordv;\n\n\texecve(argv[0], argv, environ_setup(envhint, kve));\n\n\tdiag(LOG_ERR, \"execve: %s \\\"%s\\\": %s\", argv[0], cmd, strerror(errno));\n\t_exit(127);\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "run_handler": {
      "start_point": [
        441,
        0
      ],
      "end_point": [
        540,
        1
      ],
      "content": "int\nrun_handler(struct handler *hp, event_mask *event,\n\t    const char *dirname, const char *file)\n{\n\tpid_t pid;\n\tint redir_fd[2] = { -1, -1 };\n\tstruct process *redir_proc[2] = { NULL, NULL };\n\tstruct process *p;\n\n\tif (!hp->prog)\n\t\treturn 0;\n\t\n\tdebug(1, (_(\"starting %s, dir=%s, file=%s\"), hp->prog, dirname, file));\n\tif (hp->flags & HF_STDERR)\n\t\tredir_fd[REDIR_ERR] = open_redirector(hp->prog, LOG_ERR,\n\t\t\t\t\t\t      &redir_proc[REDIR_ERR]);\n\tif (hp->flags & HF_STDOUT)\n\t\tredir_fd[REDIR_OUT] = open_redirector(hp->prog, LOG_INFO,\n\t\t\t\t\t\t      &redir_proc[REDIR_OUT]);\n\t\n\tpid = fork();\n\tif (pid == -1) {\n\t\tdiag(LOG_ERR, \"fork: %s\", strerror(errno));\n\t\tclose(redir_fd[REDIR_OUT]);\n\t\tclose(redir_fd[REDIR_ERR]);\n\t\tif (redir_proc[REDIR_OUT])\n\t\t\tkill(redir_proc[REDIR_OUT]->pid, SIGKILL);\n\t\tif (redir_proc[REDIR_ERR])\n\t\t\tkill(redir_proc[REDIR_ERR]->pid, SIGKILL);\n\t\treturn -1;\n\t}\n\t\n\tif (pid == 0) {\t\t\n\t\t/* child */\n\t\tbigfd_set fdset = BIGFD_SET_ALLOC();\n\t\t\n\t\tif (switchpriv(hp))\n\t\t\t_exit(127);\n\t\t\n\t\tif (chdir(dirname)) {\n\t\t\tdiag(LOG_CRIT, _(\"cannot change to %s: %s\"),\n\t\t\t     dirname, strerror(errno));\n\t\t\t_exit(127);\n\t\t}\n\n\t\tif (redir_fd[REDIR_OUT] != -1) {\n\t\t\tif (redir_fd[REDIR_OUT] != 1 &&\n\t\t\t    dup2(redir_fd[REDIR_OUT], 1) == -1) {\n\t\t\t\tdiag(LOG_ERR, \"dup2: %s\", strerror(errno));\n\t\t\t\t_exit(127);\n\t\t\t}\n\t\t\tBIGFD_SET(1, fdset);\n\t\t}\n\t\tif (redir_fd[REDIR_ERR] != -1) {\n\t\t\tif (redir_fd[REDIR_ERR] != 2 &&\n\t\t\t    dup2(redir_fd[REDIR_ERR], 2) == -1) {\n\t\t\t\tdiag(LOG_ERR, \"dup2: %s\", strerror(errno));\n\t\t\t\t_exit(127);\n\t\t\t}\n\t\t\tBIGFD_SET(2, fdset);\n\t\t}\n\t\tclose_fds(fdset);\n\t\talarm(0);\n\t\tsignal_setup(SIG_DFL);\n\t\truncmd(hp->prog, hp->env, event, file, hp->flags & HF_SHELL);\n\t}\n\n\t/* master */\n\tdebug(1, (_(\"%s running; dir=%s, file=%s, pid=%lu\"),\n\t\t  hp->prog, dirname, file, (unsigned long)pid));\n\n\tp = register_process(PROC_HANDLER, pid, time(NULL), hp->timeout);\n\n\tif (redir_proc[REDIR_OUT]) {\n\t\tredir_proc[REDIR_OUT]->v.master = p;\n\t\tredir_proc[REDIR_OUT]->timeout = hp->timeout;\n\t}\n\tif (redir_proc[REDIR_ERR]) {\n\t\tredir_proc[REDIR_ERR]->v.master = p;\n\t\tredir_proc[REDIR_ERR]->timeout = hp->timeout;\n\t}\n\tmemcpy(p->v.redir, redir_proc, sizeof(p->v.redir));\n\t\n\tclose(redir_fd[REDIR_OUT]);\n\tclose(redir_fd[REDIR_ERR]);\n\n\tif (hp->flags & HF_NOWAIT) {\n\t\treturn 0;\n\t}\n\n\tdebug(1, (_(\"waiting for %s (%lu) to terminate\"),\n\t\t  hp->prog, (unsigned long)pid));\n\twhile (time(NULL) - p->start < 2 * p->timeout) {\n\t\tsleep(1);\n\t\tprocess_cleanup(1);\n\t\tif (p->pid == 0)\n\t\t\tbreak;\n\t}\n\treturn 0;\n}",
      "lines": 100,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/sigv.c": {
    "sigv_set_action": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        28,
        1
      ],
      "content": "int\nsigv_set_action(int sigc, int *sigv, struct sigaction *sa)\n{\n\tint i;\n\t\n\tfor (i = 0; i < sigc; i++) {\n\t\tif (sigaction(sigv[i], &sa[i], NULL))\n\t\t\treturn i+1;\n\t}\n\treturn 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sigv_restore_tab": {
      "start_point": [
        30,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nsigv_restore_tab(int sigc, struct sigtab *sigtab, struct sigaction *sa)\n{\n\tint i;\n\t\n\tfor (i = 0; i < sigc; i++) {\n\t\tif (sigaction(sigtab[i].signo, &sa[i], NULL))\n\t\t\treturn i+1;\n\t}\n\treturn 0;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "sigv_set_all": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\nsigv_set_all(void (*handler)(int), int sigc, int *sigv,\n\t     struct sigaction *retsa)\n{\n\tint i;\n\tstruct sigaction sa;\n\t\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\t\n\tfor (i = 0; i < sigc; i++) {\n\t\tsa.sa_handler = handler;\n\t\t\n\t\tif (sigaction(sigv[i], &sa, retsa ? &retsa[i] : NULL)) {\n\t\t\tif (retsa) {\n\t\t\t\tint ec = errno;\n\t\t\t\tsigv_set_action(i, sigv, retsa);\n\t\t\t\terrno = ec;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sigv_set_tab": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\nsigv_set_tab(int sigc, struct sigtab *sigtab, struct sigaction *retsa)\n{\n\tint i;\n\tstruct sigaction sa;\n\t\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = 0;\n\t\n\tfor (i = 0; i < sigc; i++) {\n\t\tsa.sa_handler = sigtab[i].sigfun;\n\t\t\n\t\tif (sigaction(sigtab[i].signo, &sa,\n\t\t\t      retsa ? &retsa[i] : NULL)) {\n\t\t\tif (retsa) {\n\t\t\t\tint ec = errno;\n\t\t\t\tsigv_restore_tab(i, sigtab, retsa);\n\t\t\t\terrno = ec;\n\t\t\t}\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "direvent/direvent-5.1/src/watcher.c": {
    "dirwatcher_unref": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\ndirwatcher_unref(struct dirwatcher *dw)\n{\n\tif (--dw->refcnt)\n\t\treturn;\n\tfree(dw->dirname);\n\tfree(dw);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dwname_hash": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "static unsigned\ndwname_hash(void *data, unsigned long hashsize)\n{\n\tstruct dwref *sym = data;\n\treturn hash_string(sym->dw->dirname, hashsize);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "dwname_cmp": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "static int\ndwname_cmp(const void *a, const void *b)\n{\n\tstruct dwref const *syma = a;\n\tstruct dwref const *symb = b;\n\n\treturn strcmp(syma->dw->dirname, symb->dw->dirname);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dwname_copy": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\ndwname_copy(void *a, void *b)\n{\n\tstruct dwref *syma = a;\n\tstruct dwref *symb = b;\n\n\tsyma->used = 1;\n\tsyma->dw = symb->dw;\n\treturn 0;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dwref_free": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "static void\ndwref_free(void *p)\n{\n\tstruct dwref *dwref = p;\n\tdirwatcher_unref(dwref->dw);\n\tfree(dwref);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dirwatcher_install": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "struct dirwatcher *\ndirwatcher_install(const char *path, int *pnew)\n{\n\tstruct dirwatcher *dw, dwkey;\n\tstruct dwref key;\n\tstruct dwref *ent;\n\tint install = 1;\n\n\tif (!texttab) {\n\t\ttexttab = hashtab_create(sizeof(struct dwref),\n\t\t\t\t\t dwname_hash, dwname_cmp, dwname_copy,\n\t\t\t\t\t NULL, dwref_free);\n\t\tif (!texttab) {\n\t\t\tdiag(LOG_CRIT, N_(\"not enough memory\"));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tdwkey.dirname = (char*) path;\n\tkey.dw = &dwkey;\n\tent = hashtab_lookup_or_install(texttab, &key, &install);\n\tif (install) {\n\t\tdw = ecalloc(1, sizeof(*dw));\n\t\tdw->dirname = estrdup(path);\n\t\tdw->wd = -1;\n\t\tdw->refcnt++;\n\t\tent->dw = dw;\n\t}\n\tif (!ent)\n\t\tabort(); /* FIXME */\n\tif (pnew)\n\t\t*pnew = install;\n\treturn ent->dw;\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "struct dirwatcher",
        "struct",
        "dirwatcher",
        "*\ndirwatcher_install(const char *path, int *pnew)",
        "*"
      ]
    },
    "dirwatcher_lookup": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "struct dirwatcher *\ndirwatcher_lookup(const char *dirname)\n{\n\tstruct dirwatcher dwkey;\n\tstruct dwref key;\n\tstruct dwref *ent;\n\n\tif (!texttab)\n\t\treturn NULL;\n\t\n\tdwkey.dirname = (char*) dirname;\n\tkey.dw = &dwkey;\n\tent = hashtab_lookup_or_install(texttab, &key, NULL);\n\treturn ent ? ent->dw : NULL;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "struct dirwatcher",
        "struct",
        "dirwatcher",
        "*\ndirwatcher_lookup(const char *dirname)",
        "*"
      ]
    },
    "dirwatcher_remove": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\ndirwatcher_remove(const char *dirname)\n{\n\tstruct dirwatcher dwkey;\n\tstruct dwref key;\n\n\tif (!texttab)\n\t\treturn;\n\t\n\tdwkey.dirname = (char*) dirname;\n\tkey.dw = &dwkey;\n\thashtab_remove(texttab, &key);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "dw_hash": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static unsigned\ndw_hash(void *data, unsigned long hashsize)\n{\n\tstruct dwref *ent = data;\n\treturn ent->dw->wd % hashsize;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "dw_cmp": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "static int\ndw_cmp(const void *a, const void *b)\n{\n\tstruct dwref const *ha = a;\n\tstruct dwref const *hb = b;\n\treturn ha->dw->wd != hb->dw->wd;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dw_copy": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static int\ndw_copy(void *a, void *b)\n{\n\tstruct dwref *ha = a;\n\tstruct dwref *hb = b;\n\n\tha->used = 1;\n\tha->dw = hb->dw;\n\tha->dw->refcnt++;\n\treturn 0;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "dirwatcher_register": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\ndirwatcher_register(struct dirwatcher *dw)\n{\n\tstruct dwref key;\n\tstruct dwref *ent;\n\tint install = 1;\n\n\tif (!dwtab) {\n\t\tdwtab = hashtab_create(sizeof(struct dwref),\n\t\t\t\t       dw_hash, dw_cmp, dw_copy,\n\t\t\t\t       NULL, dwref_free);\n\t\tif (!dwtab) {\n\t\t\tdiag(LOG_ERR, _(\"not enough memory\"));\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tmemset(&key, 0, sizeof(key));\n\tkey.dw = dw;\n\tent = hashtab_lookup_or_install(dwtab, &key, &install);\n\tif (!ent) {\n\t\tdiag(LOG_ERR, _(\"not enough memory\"));\n\t\texit(1);\n\t}\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "dirwatcher_lookup_wd": {
      "start_point": [
        195,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "struct dirwatcher *\ndirwatcher_lookup_wd(int wd)\n{\n\tstruct dirwatcher dwkey;\n\tstruct dwref dwref, *ent;\n\n\tif (!dwtab) \n\t\treturn NULL;\n\tdwkey.wd = wd;\n\tdwref.dw = &dwkey;\n\tent = hashtab_lookup_or_install(dwtab, &dwref, NULL);\n\treturn ent ? ent->dw : NULL;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "struct dirwatcher",
        "struct",
        "dirwatcher",
        "*\ndirwatcher_lookup_wd(int wd)",
        "*"
      ]
    },
    "dirwatcher_remove_wd": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\ndirwatcher_remove_wd(int wd)\n{\n\tstruct dirwatcher dwkey;\n\tstruct dwref dwref;\n\n\tif (!dwtab) \n\t\treturn;\n\tdwkey.wd = wd;\n\tdwref.dw = &dwkey;\n\thashtab_remove(dwtab, &dwref);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dirwatcher_init": {
      "start_point": [
        223,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "int \ndirwatcher_init(struct dirwatcher *dwp)\n{\n\tevent_mask mask = { 0, 0 };\n\tstruct handler *hp;\n\tint wd;\n\n\tdebug(1, (_(\"creating watcher %s\"), dwp->dirname));\n\n\tfor (hp = dwp->handler_list; hp; hp = hp->next) {\n\t\tmask.sys_mask |= hp->ev_mask.sys_mask;\n\t\tmask.gen_mask |= hp->ev_mask.gen_mask;\n\t}\n\t\n\twd = sysev_add_watch(dwp, mask);\n\tif (wd == -1) {\n\t\tdiag(LOG_ERR, _(\"cannot set watcher on %s: %s\"),\n\t\t     dwp->dirname, strerror(errno));\n\t\treturn 1;\n\t}\n\n\tdwp->wd = wd;\n\tdirwatcher_register(dwp);\n\n\treturn 0;\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "subwatcher_create": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "int\nsubwatcher_create(struct dirwatcher *parent, const char *dirname,\n\t\t  int isdir, int notify)\n{\n\tstruct dirwatcher *dwp;\n\tint inst;\n\t\n\tdwp = dirwatcher_install(dirname, &inst);\n\tif (!inst)\n\t\treturn -1;\n\n\tdwp->handler_list = parent->handler_list;\n\tdwp->parent = parent;\n\t\n\tif (parent->depth == -1)\n\t\tdwp->depth = parent->depth;\n\telse if (parent->depth)\n\t\tdwp->depth = parent->depth - 1;\n\telse\n\t\tdwp->depth = 0;\n\t\n\tif (dirwatcher_init(dwp)) {\n\t\t//FIXME dirwatcher_free(dwp);\n\t\treturn -1;\n\t}\n\n\treturn 1 + (isdir ? watch_subdirs(dwp, notify) : 0);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "deliver_ev_create": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        292,
        1
      ],
      "content": "void\ndeliver_ev_create(struct dirwatcher *dp, const char *name)\n{\n\tevent_mask m = { GENEV_CREATE, 0 };\n\tstruct handler *h;\n\n\tfor (h = dp->handler_list; h; h = h->next) {\n\t\tif (handler_matches_event(h, gen, GENEV_CREATE, name))\n\t\t\trun_handler(h, &m, dp->dirname, name);\n\t}\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "check_new_watcher": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        335,
        1
      ],
      "content": "int\ncheck_new_watcher(const char *dir, const char *name)\n{\n\tint rc;\n\tchar *fname;\n\tstruct stat st;\n\tstruct dirwatcher *parent;\n\n\tparent = dirwatcher_lookup(dir);\n\tif (!parent || !parent->depth)\n\t\treturn 0;\n\t\n\tfname = mkfilename(dir, name);\n\tif (!fname) {\n\t\tdiag(LOG_ERR,\n\t\t     _(\"cannot create watcher %s/%s: not enough memory\"),\n\t\t     dir, name);\n\t\treturn -1;\n\t}\n\n\tif (stat(fname, &st)) {\n\t\tdiag(LOG_ERR,\n\t\t     _(\"cannot create watcher %s/%s, stat failed: %s\"),\n\t\t     dir, name, strerror(errno));\n\t\trc = -1;\n\t} else if (S_ISDIR(st.st_mode)) {\n\t\tdeliver_ev_create(parent, name);\n\t\trc = subwatcher_create(parent, fname, 1, 1);\n\t} else\n\t\trc = 0;\n\tfree(fname);\n\treturn rc;\n}",
      "lines": 33,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "watch_subdirs": {
      "start_point": [
        339,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "static int\nwatch_subdirs(struct dirwatcher *parent, int notify)\n{\n\tDIR *dir;\n\tstruct dirent *ent;\n\tint filemask = sysev_filemask(parent);\n\tint total = 0;\n\n\tif (parent->depth)\n\t\tfilemask |= S_IFDIR;\n\tif (!filemask)\n\t\treturn 0;\n\t\n\tdir = opendir(parent->dirname);\n\tif (!dir) {\n\t\tdiag(LOG_ERR, _(\"cannot open directory %s: %s\"),\n\t\t     parent->dirname, strerror(errno));\n\t\treturn 0;\n\t}\n\n\twhile (ent = readdir(dir)) {\n\t\tstruct stat st;\n\t\tchar *dirname;\n\t\t\n\t\tif (ent->d_name[0] == '.' &&\n\t\t    (ent->d_name[1] == 0 ||\n\t\t     (ent->d_name[1] == '.' && ent->d_name[2] == 0)))\n\t\t\tcontinue;\n\t\t\n\t\tdirname = mkfilename(parent->dirname, ent->d_name);\n\t\tif (!dirname) {\n\t\t\tdiag(LOG_ERR, _(\"cannot stat %s/%s: not enough memory\"),\n\t\t\t     parent->dirname, ent->d_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (stat(dirname, &st)) {\n\t\t\tdiag(LOG_ERR, _(\"cannot stat %s: %s\"),\n\t\t\t     dirname, strerror(errno));\n\t\t} else {\n\t\t\tif (notify)\n\t\t\t\tdeliver_ev_create(parent, ent->d_name);\n\t\t\tif (st.st_mode & filemask) {\n\t\t\t\tint rc = subwatcher_create(parent, dirname,\n\t\t\t\t\t\t\t   S_ISDIR(st.st_mode),\n\t\t\t\t\t\t\t   notify);\n\t\t\t\tif (rc > 0)\n\t\t\t\t\ttotal += rc;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t}\n\tclosedir(dir);\n\treturn total;\n}",
      "lines": 54,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "setwatcher": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        404,
        1
      ],
      "content": "int\nsetwatcher(struct hashent *ent, void *null)\n{\n\tstruct dwref *dwref = (struct dwref *) ent;\n\tstruct dirwatcher *dwp = dwref->dw;\n\t\n\tif (dwp->wd == -1 && dirwatcher_init(dwp) == 0)\n\t\twatch_subdirs(dwp, 0);\n\treturn 0;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "setup_watchers": {
      "start_point": [
        406,
        0
      ],
      "end_point": [
        419,
        1
      ],
      "content": "void\nsetup_watchers()\n{\n\tsysev_init();\n\tif (hashtab_count(texttab) == 0) {\n\t\tdiag(LOG_CRIT, _(\"no event handlers configured\"));\n\t\texit(1);\n\t}\n\thashtab_foreach(texttab, setwatcher, NULL);\n\tif (hashtab_count(dwtab) == 0) {\n\t\tdiag(LOG_CRIT, _(\"no event handlers installed\"));\n\t\texit(2);\n\t}\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "dirwatcher_destroy": {
      "start_point": [
        421,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "void\ndirwatcher_destroy(struct dirwatcher *dwp)\n{\n\tdebug(1, (_(\"removing watcher %s\"), dwp->dirname));\n\tsysev_rm_watch(dwp);\n\n\tdirwatcher_remove_wd(dwp->wd);\n\tdirwatcher_remove(dwp->dirname);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "split_pathname": {
      "start_point": [
        431,
        0
      ],
      "end_point": [
        444,
        1
      ],
      "content": "char *\nsplit_pathname(struct dirwatcher *dp, char **dirname)\n{\n\tchar *p = strrchr(dp->dirname, '/');\n\tif (p) {\n\t\tdp->split_p = p;\n\t\t*p++ = 0;\n\t\t*dirname = dp->dirname;\n\t} else {\n\t\tp = dp->dirname;\n\t\t*dirname = \".\";\n\t}\n\treturn p;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "char",
        "*\nsplit_pathname(struct dirwatcher *dp, char **dirname)",
        "*"
      ]
    },
    "unsplit_pathname": {
      "start_point": [
        446,
        0
      ],
      "end_point": [
        453,
        1
      ],
      "content": "void\nunsplit_pathname(struct dirwatcher *dp)\n{\n\tif (dp->split_p) {\n\t\t*dp->split_p = '/';\n\t\tdp->split_p = NULL;\n\t}\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "direvent/direvent-5.1/tests/envdump.c": {
    "agetcwd": {
      "start_point": [
        27,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "char *\nagetcwd()\n{\n\tchar *buf = NULL;\n\tsize_t bufsize = 128;\n\t\n\tfor (;;) {\n\t\terrno = 0;\n\t\tbuf = malloc(bufsize);\n\t\tif (!buf) {\n\t\t\tfprintf(stderr, \"%s: not enough memory\\n\", progname);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (getcwd(buf, bufsize))\n\t\t\tbreak;\n\t\tfree(buf);\n\t\tif (errno != ERANGE) {\n\t\t\tfprintf(stderr, \"%s: \", progname);\n\t\t\tperror(\"getcwd\");\n\t\t\treturn NULL;\n\t\t}\n\n\t\tbufsize += bufsize / 16;\n\t\tbufsize += 32;\n\t}\n\treturn buf;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "char",
        "*\nagetcwd()",
        "*"
      ]
    },
    "compvar": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "int\ncompvar(char *enva, char *envb, int lazy)\n{\n\tint c;\n\n\tfor (; *envb; enva++, envb++) {\n\t\tif (*enva == 0) {\n\t\t\tif (lazy)\n\t\t\t\treturn 0;\n\t\t\tbreak;\n\t\t}\n\t\tif (c = *enva - *envb)\n\t\t\treturn c;\n\t\tif (*enva == '=' || *envb == '=')\n\t\t\treturn c;\n\t}\n\t\n\treturn *enva - *envb;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "compenv": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "int\ncompenv(const void *a, const void *b)\n{\n\treturn compvar(*(char * const *)a, *(char * const *)b, 0);\n}",
      "lines": 5,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "locate": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "char *\nlocate(char **itab, char *s)\n{\n\tfor (;*itab;itab++) {\n\t\tif (compvar(*itab, s, 1) == 0)\n\t\t\tbreak;\n\t}\n\treturn *itab;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "char",
        "*\nlocate(char **itab, char *s)",
        "*"
      ]
    },
    "strtosig": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\nstrtosig(char *str)\n{\n\tstruct sigtab *sp;\n\tint sig;\n\tchar *end;\n\t\t\n\tif (strncmp(str, \"SIG\", 3) == 0)\n\t\tstr += 3;\n\tfor (sp = sigtab; sp->name; sp++)\n\t\tif (strcmp(sp->name, str) == 0)\n\t\t\treturn sp->sig;\n\n\tsig = strtoul(str, &end, 10);\n\tif (*end) {\n\t\tfprintf(stderr, \"%s: bad signal number (near %s)\\n\",\n\t\t\tprogname, end);\n\t\texit(1);\n\t}\n\treturn sig;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "read_pid_and_sig": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\nread_pid_and_sig(char *arg, pid_t *pid, int *sig)\n{\n\tchar *p, *end;\n\tunsigned long n;\n\n\tp = strchr(arg, ':');\n\tif (p)\n\t\t*p++ = 0;\n\n\tif (arg[0] == '@') {\n\t\tFILE *fp = fopen(++arg, \"r\");\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"%s: cannot open \", progname);\n\t\t\tperror(arg);\n\t\t\texit(1);\n\t\t}\n\t\tif (fscanf(fp, \"%lu\", &n) != 1) {\n\t\t\tfprintf(stderr, \"%s: no PID found in %s\\n\", progname,\n\t\t\t\targ);\n\t\t\texit(1);\n\t\t}\n\t\tfclose(fp);\n\t\t*pid = n;\n\t} else {\n\t\t*pid = strtoul(arg, &end, 10);\n\t\tif (*end) {\n\t\t\tfprintf(stderr,\n\t\t\t\t\"%s: bad PID (near %s)\\n\", progname, end);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (p) {\n\t\t*sig = strtosig(p);\n\t\tp[-1] = ':';\n\t}\n}",
      "lines": 38,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        270,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tint i;\n\tchar *p;\n\tFILE *fp = NULL;\n\tchar *file;\n\tchar *mode = \"w\";\n\tint sortenv = 0;\n\tchar *include = NULL;\n\tchar **itab = NULL;\n\tpid_t pid = 0;\n\tint sig = SIGHUP;\n\t\n\tprogname = strrchr(argv[0], '/');\n\tif (progname)\n\t\tprogname++;\n\telse\n\t\tprogname = argv[0];\n\twhile ((i = getopt(argc, argv, \"af:hi:k:s\")) != EOF)\n\t\tswitch (i) {\n\t\tcase 'a':\n\t\t\tmode = \"a\";\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tfile = optarg;\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tprintf(\"usage: %s [-ahsx] [-f FILE] [-i INCLUDELIST] [-k [@]PID[:SIG]] [ARGS...]\\n\",\n\t\t\t       progname);\n\t\t\treturn 0;\n\t\tcase 's':\n\t\t\tsortenv = 1;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tinclude = optarg;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tread_pid_and_sig(optarg, &pid, &sig);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn 1;\n\t\t}\n\n\tif (file) {\n\t\tfp = fopen(file, mode);\n\t\tif (!fp) {\n\t\t\tfprintf(stderr, \"%s: \", progname);\n\t\t\tperror(file);\n\t\t\treturn 1;\n\t\t}\n\t} else\n\t\tfp = stderr;\n\t\n\tfprintf(fp, \"# Dump of execution environment\\n\");\n\tp = agetcwd();\n\tif (p) {\n\t\tfprintf(fp, \"cwd is %s\\n\", p);\n\t\tfree(p);\n\t}\n\tfprintf(fp, \"# Arguments\\n\");\n\tfor (i = 0; i < argc; i++)\n\t\tfprintf(fp, \"argv[%d]=%s\\n\", i, argv[i]);\n\n\tif (sortenv) {\n\t\tfor (i = 0; environ[i]; i++);\n\t\tqsort(environ, i, sizeof(environ[0]), compenv);\n\t}\n\tif (include) {\n\t\ti = 1;\n\t\tfor (p = include; *p; p++) {\n\t\t\tif (*p == ':')\n\t\t\t\ti++;\n\t\t}\n\t\titab = calloc(i + 1, sizeof(itab));\n\n\t\titab[0] = include;\n\t\tfor (p = include, i = 1; *p; p++) {\n\t\t\tif (*p == ':') {\n\t\t\t\t*p = 0;\n\t\t\t\titab[i++] = p + 1;\n\t\t\t}\n\t\t}\n\t\titab[i] = NULL;\n\t}\n\t\t\n\tfprintf(fp, \"# Environment\\n\");\n\tfor (i = 0; environ[i]; i++) {\n\t\tif (!itab || locate(itab, environ[i]))\n\t\t\tfprintf(fp, \"%s\\n\", environ[i]);\n\t}\n\tfprintf(fp, \"# End\\n\");\n\n\tif (pid)\n\t\tkill(pid, sig);\n\n\treturn 0;\n}",
      "lines": 98,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  }
}