{
  "nettle/nettle-3.4.1/aes-decrypt-internal.c": {
    "_nettle_aes_decrypt": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\n_nettle_aes_decrypt(unsigned rounds, const uint32_t *keys,\n\t\t    const struct aes_table *T,\n\t\t    size_t length, uint8_t *dst,\n\t\t    const uint8_t *src)\n{\n  FOR_BLOCKS(length, dst, src, AES_BLOCK_SIZE)\n    {\n      uint32_t w0, w1, w2, w3;\t\t/* working ciphertext */\n      uint32_t t0, t1, t2, t3;\n      unsigned i;\n      \n      /* Get clear text, using little-endian byte order.\n       * Also XOR with the first subkey. */\n\n      w0 = LE_READ_UINT32(src)      ^ keys[0];\n      w1 = LE_READ_UINT32(src + 4)  ^ keys[1];\n      w2 = LE_READ_UINT32(src + 8)  ^ keys[2];\n      w3 = LE_READ_UINT32(src + 12) ^ keys[3];\n\n      for (i = 1; i < rounds; i++)\n\t{\n\t  t0 = AES_ROUND(T, w0, w3, w2, w1, keys[4*i]);\n\t  t1 = AES_ROUND(T, w1, w0, w3, w2, keys[4*i + 1]);\n\t  t2 = AES_ROUND(T, w2, w1, w0, w3, keys[4*i + 2]);\n\t  t3 = AES_ROUND(T, w3, w2, w1, w0, keys[4*i + 3]);\n\n\t  /* We could unroll the loop twice, to avoid these\n\t     assignments. If all eight variables fit in registers,\n\t     that should give a slight speedup. */\n\t  w0 = t0;\n\t  w1 = t1;\n\t  w2 = t2;\n\t  w3 = t3;\n\t}\n\n      /* Final round */\n\n      t0 = AES_FINAL_ROUND(T, w0, w3, w2, w1, keys[4*i]);\n      t1 = AES_FINAL_ROUND(T, w1, w0, w3, w2, keys[4*i + 1]);\n      t2 = AES_FINAL_ROUND(T, w2, w1, w0, w3, keys[4*i + 2]);\n      t3 = AES_FINAL_ROUND(T, w3, w2, w1, w0, keys[4*i + 3]);\n\n      LE_WRITE_UINT32(dst, t0);\n      LE_WRITE_UINT32(dst + 4, t1);\n      LE_WRITE_UINT32(dst + 8, t2);\n      LE_WRITE_UINT32(dst + 12, t3);\n    }\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-decrypt.c": {
    "aes_decrypt": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        354,
        1
      ],
      "content": "void\naes_decrypt(const struct aes_ctx *ctx,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_decrypt(ctx->rounds, ctx->keys, &_aes_decrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes128_decrypt": {
      "start_point": [
        356,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "void\naes128_decrypt(const struct aes128_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_decrypt(_AES128_ROUNDS, ctx->keys, &_aes_decrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes192_decrypt": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "void\naes192_decrypt(const struct aes192_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_decrypt(_AES192_ROUNDS, ctx->keys, &_aes_decrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes256_decrypt": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        384,
        1
      ],
      "content": "void\naes256_decrypt(const struct aes256_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_decrypt(_AES256_ROUNDS, ctx->keys, &_aes_decrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-encrypt-internal.c": {
    "_nettle_aes_encrypt": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\n_nettle_aes_encrypt(unsigned rounds, const uint32_t *keys,\n\t\t    const struct aes_table *T,\n\t\t    size_t length, uint8_t *dst,\n\t\t    const uint8_t *src)\n{\n  FOR_BLOCKS(length, dst, src, AES_BLOCK_SIZE)\n    {\n      uint32_t w0, w1, w2, w3;\t\t/* working ciphertext */\n      uint32_t t0, t1, t2, t3;\n      unsigned i;\n      \n      /* Get clear text, using little-endian byte order.\n       * Also XOR with the first subkey. */\n\n      w0 = LE_READ_UINT32(src)      ^ keys[0];\n      w1 = LE_READ_UINT32(src + 4)  ^ keys[1];\n      w2 = LE_READ_UINT32(src + 8)  ^ keys[2];\n      w3 = LE_READ_UINT32(src + 12) ^ keys[3];\n\n      for (i = 1; i < rounds; i++)\n\t{\n\t  t0 = AES_ROUND(T, w0, w1, w2, w3, keys[4*i]);\n\t  t1 = AES_ROUND(T, w1, w2, w3, w0, keys[4*i + 1]);\n\t  t2 = AES_ROUND(T, w2, w3, w0, w1, keys[4*i + 2]);\n\t  t3 = AES_ROUND(T, w3, w0, w1, w2, keys[4*i + 3]);\n\n\t  /* We could unroll the loop twice, to avoid these\n\t     assignments. If all eight variables fit in registers,\n\t     that should give a slight speedup. */\n\t  w0 = t0;\n\t  w1 = t1;\n\t  w2 = t2;\n\t  w3 = t3;\n\t}\n\n      /* Final round */\n\n      t0 = AES_FINAL_ROUND(T, w0, w1, w2, w3, keys[4*i]);\n      t1 = AES_FINAL_ROUND(T, w1, w2, w3, w0, keys[4*i + 1]);\n      t2 = AES_FINAL_ROUND(T, w2, w3, w0, w1, keys[4*i + 2]);\n      t3 = AES_FINAL_ROUND(T, w3, w0, w1, w2, keys[4*i + 3]);\n\n      LE_WRITE_UINT32(dst, t0);\n      LE_WRITE_UINT32(dst + 4, t1);\n      LE_WRITE_UINT32(dst + 8, t2);\n      LE_WRITE_UINT32(dst + 12, t3);\n    }\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-encrypt-table.c": {},
  "nettle/nettle-3.4.1/aes-encrypt.c": {
    "aes_encrypt": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\naes_encrypt(const struct aes_ctx *ctx,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_encrypt(ctx->rounds, ctx->keys, &_aes_encrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes128_encrypt": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\naes128_encrypt(const struct aes128_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_encrypt(_AES128_ROUNDS, ctx->keys, &_aes_encrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes192_encrypt": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\naes192_encrypt(const struct aes192_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_encrypt(_AES192_ROUNDS, ctx->keys, &_aes_encrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "aes256_encrypt": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "void\naes256_encrypt(const struct aes256_ctx *ctx,\n\t       size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  assert(!(length % AES_BLOCK_SIZE) );\n  _aes_encrypt(_AES256_ROUNDS, ctx->keys, &_aes_encrypt_table,\n\t       length, dst, src);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-internal.h": {},
  "nettle/nettle-3.4.1/aes-invert-internal.c": {
    "_aes_invert": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "void\n_aes_invert(unsigned rounds, uint32_t *dst, const uint32_t *src)\n{\n  unsigned i;\n\n  /* Reverse the order of subkeys, in groups of 4. */\n  /* FIXME: Instead of reordering the subkeys, change the access order\n     of aes_decrypt, since it's a separate function anyway? */\n  if (src == dst)\n    {\n      unsigned j, k;\n\n      for (i = 0, j = rounds * 4;\n\t   i < j;\n\t   i += 4, j -= 4)\n\tfor (k = 0; k<4; k++)\n\t  SWAP(dst[i+k], dst[j+k]);\n    }\n  else\n    {\n      unsigned k;\n\n      for (i = 0; i <= rounds * 4; i += 4)\n\tfor (k = 0; k < 4; k++)\n\t  dst[i+k] = src[rounds * 4 - i + k];\n    }\n\n  /* Transform all subkeys but the first and last. */\n  for (i = 4; i < 4 * rounds; i++)\n    MIX_COLUMN (mtable, dst[i]);\n}",
      "lines": 31,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-set-decrypt-key.c": {
    "aes_invert_key": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\naes_invert_key(struct aes_ctx *dst,\n\t       const struct aes_ctx *src)\n{\n  _aes_invert (src->rounds, dst->keys, src->keys);\n  dst->rounds = src->rounds;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "aes_set_decrypt_key": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\naes_set_decrypt_key(struct aes_ctx *ctx,\n\t\t    size_t keysize, const uint8_t *key)\n{\n  /* We first create subkeys for encryption,\n   * then modify the subkeys for decryption. */\n  aes_set_encrypt_key(ctx, keysize, key);\n  aes_invert_key(ctx, ctx);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-set-encrypt-key.c": {
    "aes_set_encrypt_key": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\naes_set_encrypt_key(struct aes_ctx *ctx,\n\t\t    size_t keysize, const uint8_t *key)\n{\n  unsigned nk, nr;\n\n  assert(keysize >= AES_MIN_KEY_SIZE);\n  assert(keysize <= AES_MAX_KEY_SIZE);\n  \n  /* Truncate keysizes to the valid key sizes provided by Rijndael */\n  if (keysize == AES256_KEY_SIZE) {\n    nk = 8;\n    nr = _AES256_ROUNDS;\n  } else if (keysize >= AES192_KEY_SIZE) {\n    nk = 6;\n    nr = _AES192_ROUNDS;\n  } else { /* must be 16 or more */\n    nk = 4;\n    nr = _AES128_ROUNDS;\n  }\n\n  ctx->rounds = nr;\n  _aes_set_key (nr, nk, ctx->keys, key);\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes-set-key-internal.c": {
    "_aes_set_key": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\n_aes_set_key(unsigned nr, unsigned nk,\n\t     uint32_t *subkeys, const uint8_t *key)\n{\n  static const uint8_t rcon[10] = {\n    0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1b,0x36,\n  };\n  const uint8_t *rp;\n  unsigned lastkey, i;\n  uint32_t t;\n\n  assert(nk != 0);\n  lastkey = (AES_BLOCK_SIZE/4) * (nr + 1);\n  \n  for (i=0, rp = rcon; i<nk; i++)\n    subkeys[i] = LE_READ_UINT32(key + i*4);\n\n  for (i=nk; i<lastkey; i++)\n    {\n      t = subkeys[i-1];\n      if (i % nk == 0)\n\tt = SUBBYTE(ROTL32(24, t), aes_sbox) ^ *rp++;\n\n      else if (nk > 6 && (i%nk) == 4)\n\tt = SUBBYTE(t, aes_sbox);\n\n      subkeys[i] = subkeys[i-nk] ^ t;\n    }  \n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes.h": {},
  "nettle/nettle-3.4.1/aes128-meta.c": {},
  "nettle/nettle-3.4.1/aes128-set-decrypt-key.c": {
    "aes128_invert_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\naes128_invert_key (struct aes128_ctx *dst, const struct aes128_ctx *src)\n{\n  _aes_invert (_AES128_ROUNDS, dst->keys, src->keys); \n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "aes128_set_decrypt_key": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\naes128_set_decrypt_key(struct aes128_ctx *ctx, const uint8_t *key)\n{\n  aes128_set_encrypt_key (ctx, key);\n  aes128_invert_key (ctx, ctx);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes128-set-encrypt-key.c": {
    "aes128_set_encrypt_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\naes128_set_encrypt_key(struct aes128_ctx *ctx, const uint8_t *key)\n{\n  _aes_set_key (_AES128_ROUNDS, AES128_KEY_SIZE / 4, ctx->keys, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes192-meta.c": {},
  "nettle/nettle-3.4.1/aes192-set-decrypt-key.c": {
    "aes192_invert_key": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\naes192_invert_key (struct aes192_ctx *dst, const struct aes192_ctx *src)\n{\n  _aes_invert (_AES192_ROUNDS, dst->keys, src->keys); \n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "aes192_set_decrypt_key": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\naes192_set_decrypt_key(struct aes192_ctx *ctx, const uint8_t *key)\n{\n  aes192_set_encrypt_key (ctx, key);\n  aes192_invert_key (ctx, ctx);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes192-set-encrypt-key.c": {
    "aes192_set_encrypt_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\naes192_set_encrypt_key(struct aes192_ctx *ctx, const uint8_t *key)\n{\n  _aes_set_key (_AES192_ROUNDS, AES192_KEY_SIZE / 4, ctx->keys, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes256-meta.c": {},
  "nettle/nettle-3.4.1/aes256-set-decrypt-key.c": {
    "aes256_invert_key": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\naes256_invert_key (struct aes256_ctx *dst, const struct aes256_ctx *src)\n{\n  _aes_invert (_AES256_ROUNDS, dst->keys, src->keys); \n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "aes256_set_decrypt_key": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\naes256_set_decrypt_key(struct aes256_ctx *ctx, const uint8_t *key)\n{\n  aes256_set_encrypt_key (ctx, key);\n  aes256_invert_key (ctx, ctx);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aes256-set-encrypt-key.c": {
    "aes256_set_encrypt_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\naes256_set_encrypt_key(struct aes256_ctx *ctx, const uint8_t *key)\n{\n  _aes_set_key (_AES256_ROUNDS, AES256_KEY_SIZE / 4, ctx->keys, key);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/aesdata.c": {
    "xtime": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static unsigned\nxtime(unsigned x)\n{\n  assert (x < 0x100);\n\n  x <<= 1;\n  if (x & 0x100)\n    x ^= 0x11b;\n\n  assert (x < 0x100);\n\n  return x;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "compute_log": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void\ncompute_log(void)\n{\n  unsigned i = 0;\n  unsigned x = 1;\n\n  memset(gf2_log, 0, 0x100);\n  \n  for (i = 0; i < 0x100; i++, x = x ^ xtime(x))\n    {\n      gf2_exp[i] = x;\n      gf2_log[x] = i;\n    }\n  /* Invalid. */\n  gf2_log[0] = 0;\n  /* The loop above sets gf2_log[1] = 0xff, which is correct,\n   * but gf2_log[1] = 0 is nicer. */\n  gf2_log[1] = 0;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mult": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static unsigned\nmult(unsigned a, unsigned b)\n{\n  return (a && b) ? gf2_exp[ (gf2_log[a] + gf2_log[b]) % 255] : 0;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "invert": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static unsigned\ninvert(unsigned x)\n{\n  return x ? gf2_exp[0xff - gf2_log[x]] : 0;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "affine": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "static unsigned\naffine(unsigned x)\n{\n  return 0xff &\n    (0x63^x^(x>>4)^(x<<4)^(x>>5)^(x<<3)^(x>>6)^(x<<2)^(x>>7)^(x<<1));\n}",
      "lines": 6,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "compute_sbox": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ncompute_sbox(void)\n{\n  unsigned i;\n  for (i = 0; i<0x100; i++)\n    {\n      sbox[i] = affine(invert(i));\n      isbox[sbox[i]] = i;\n    }\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compute_dtable": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\ncompute_dtable(void)\n{\n  unsigned i;\n  for (i = 0; i<0x100; i++)\n    {\n      unsigned s = sbox[i];\n      unsigned j;\n      unsigned long t  =( ( (s ^ xtime(s)) << 24)\n\t\t     | (s << 16) | (s << 8)\n\t\t     | xtime(s) );\n\n      for (j = 0; j<4; j++, t = (t << 8) | (t >> 24))\n\tdtable[j][i] = t;\n    }\n}",
      "lines": 16,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compute_itable": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\ncompute_itable(void)\n{\n  unsigned i;\n  for (i = 0; i<0x100; i++)\n    {\n      unsigned s = isbox[i];\n      unsigned j;\n      unsigned long t = ( (mult(s, 0xb) << 24)\n\t\t\t| (mult(s, 0xd) << 16)\n\t\t\t| (mult(s, 0x9) << 8)\n\t\t\t| (mult(s, 0xe) ));\n      \n      for (j = 0; j<4; j++, t = (t << 8) | (t >> 24))\n\titable[j][i] = t;\n    }\n}",
      "lines": 17,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compute_mtable": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static void\ncompute_mtable(void)\n{\n  unsigned i;\n  for (i = 0; i<0x100; i++)\n    {\n      unsigned j;\n      unsigned long t = ( (mult(i, 0xb) << 24)\n\t\t\t| (mult(i, 0xd) << 16)\n\t\t\t| (mult(i, 0x9) << 8)\n\t\t\t| (mult(i, 0xe) ));\n      \n      for (j = 0; j<4; j++, t = (t << 8) | (t >> 24))\n\tmtable[j][i] = t;\n    }\n}",
      "lines": 16,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_byte_table": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\ndisplay_byte_table(const char *name, unsigned char *table)\n{\n  unsigned i, j;\n\n  printf(\"uint8_t %s[0x100] =\\n{\", name);\n\n  for (i = 0; i<0x100; i+= BYTE_COLUMNS)\n    {\n      printf(\"\\n  \");\n      for (j = 0; j<BYTE_COLUMNS; j++)\n\tprintf(BYTE_FORMAT \",\", table[i + j]);\n    }\n\n  printf(\"\\n};\\n\\n\");\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_table": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static void\ndisplay_table(const char *name, unsigned long table[][0x100])\n{\n  unsigned i, j, k;\n  \n  printf(\"uint32_t %s[4][0x100] =\\n{\\n  \", name);\n\n  for (k = 0; k<4; k++)\n    {\n      printf(\"{ \");\n      for (i = 0; i<0x100; i+= WORD_COLUMNS)\n\t{\n\t  printf(\"\\n    \");\n\t  for (j = 0; j<WORD_COLUMNS; j++)\n\t    printf(WORD_FORMAT \",\", table[k][i + j]);\n\t}\n      printf(\"\\n  },\");\n    }\n  printf(\"\\n};\\n\\n\");\n}",
      "lines": 20,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display_polynomial": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        195,
        1
      ],
      "content": "static void\ndisplay_polynomial(const unsigned *p)\n{\n  printf(\"(%x x^3 + %x x^2 + %x x + %x)\",\n\t p[3], p[2], p[1], p[0]);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        197,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  compute_log();\n  if (argc == 1)\n    {\n      display_byte_table(\"gf2_log\", gf2_log);\n      display_byte_table(\"gf2_exp\", gf2_exp);\n\n      compute_sbox();\n      display_byte_table(\"sbox\", sbox);\n      display_byte_table(\"isbox\", isbox);\n\n      compute_dtable();\n      display_table(\"dtable\", dtable);\n\n      compute_itable();\n      display_table(\"itable\", itable);\n\n      compute_mtable();\n      display_table(\"mtable\", mtable);\n\n      return 0;\n    }\n  else if (argc == 2)\n    {\n      unsigned a;\n      for (a = 1; a<0x100; a++)\n\t{\n\t  unsigned a1 = invert(a);\n\t  unsigned b;\n\t  unsigned u;\n\t  if (a1 == 0)\n\t    printf(\"invert(%x) = 0 !\\n\", a);\n\n\t  u = mult(a, a1);\n\t  if (u != 1)\n\t    printf(\"invert(%x) = %x; product = %x\\n\",\n\t\t   a, a1, u);\n\t  \n\t  for (b = 1; b<0x100; b++)\n\t    {\n\t      unsigned b1 = invert(b);\n\t      unsigned c = mult(a, b);\n\n\t      if (c == 0)\n\t\tprintf(\"%x x %x = 0\\n\", a, b);\n\n\t      u = mult(c, a1);\n\t      if (u != b)\n\t\tprintf(\"%x x %x = %x, invert(%x) = %x, %x x %x = %x\\n\",\n\t\t       a, b, c, a, a1, c, a1, u);\n\t      \n\t      u = mult(c, b1);\n\t      if (u != a)\n\t\tprintf(\"%x x %x = %x, invert(%x) = %x, %x x %x = %x\\n\",\n\t\t       a, b, c, b, b1, c, b1, u);\n\t    }\n\t}\n      return 0;\n    }\n  else if (argc == 4)\n    {\n      unsigned a, b, c;\n      int op = argv[2][0];\n      a = strtoul(argv[1], NULL, 16);\n      b = strtoul(argv[3], NULL, 16);\n      switch (op)\n\t{\n\tcase '+':\n\t  c = a ^ b;\n\t  break;\n\tcase '*':\n\tcase 'x':\n\t  c = mult(a,b);\n\t  break;\n\tcase '/':\n\t  c = mult(a, invert(b));\n\t  break;\n\tdefault:\n\t  return 1;\n\t}\n      printf(\"%x %c %x = %x\\n\", a, op, b, c);\n      return 0;\n    }\n#if 0\n  else if (argc == 5)\n    {\n      /* Compute gcd(a, x^4+1) */\n      unsigned d[4];\n      unsigned u[4];\n      \n      for (i = 0; i<4; i++)\n\ta[i] = strtoul(argv[1+i], NULL, 16);\n    }\n#endif\n  else if (argc == 9)\n    {\n      unsigned a[4];\n      unsigned b[4];\n      unsigned c[4];\n      unsigned i;\n      for (i = 0; i<4; i++)\n\t{\n\t  a[i] = strtoul(argv[1+i], NULL, 16);\n\t  b[i] = strtoul(argv[5+i], NULL, 16);\n\t}\n\n      c[0] = mult(a[0],b[0])^mult(a[3],b[1])^mult(a[2],b[2])^mult(a[1],b[3]);\n      c[1] = mult(a[1],b[0])^mult(a[0],b[1])^mult(a[3],b[2])^mult(a[2],b[3]);\n      c[2] = mult(a[2],b[0])^mult(a[1],b[1])^mult(a[0],b[2])^mult(a[3],b[3]);\n      c[3] = mult(a[3],b[0])^mult(a[2],b[1])^mult(a[1],b[2])^mult(a[0],b[3]);\n\n      display_polynomial(a); printf(\" * \"); display_polynomial(b);\n      printf(\" = \"); display_polynomial(c); printf(\"\\n\");\n    }\n  return 1;\n}",
      "lines": 118,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/arcfour-crypt.c": {
    "arcfour_crypt": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\narcfour_crypt(struct arcfour_ctx *ctx,\n\t      size_t length, uint8_t *dst,\n\t      const uint8_t *src)\n{\n  register uint8_t i, j;\n  register int si, sj;\n\n  i = ctx->i; j = ctx->j;\n  while(length--)\n    {\n      i++; i &= 0xff;\n      si = ctx->S[i];\n      j += si; j &= 0xff;\n      sj = ctx->S[i] = ctx->S[j];\n      ctx->S[j] = si;\n      *dst++ = *src++ ^ ctx->S[ (si + sj) & 0xff ];\n    }\n  ctx->i = i; ctx->j = j;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/arcfour.c": {
    "arcfour_set_key": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\narcfour_set_key(struct arcfour_ctx *ctx,\n\t\tsize_t length, const uint8_t *key)\n{\n  unsigned i, j, k;\n  \n  assert(length >= ARCFOUR_MIN_KEY_SIZE);\n  assert(length <= ARCFOUR_MAX_KEY_SIZE);\n\n  /* Initialize context */\n  for (i = 0; i<256; i++)\n    ctx->S[i] = i;\n\n  for (i = j = k = 0; i<256; i++)\n    {\n      j += ctx->S[i] + key[k]; j &= 0xff;\n      SWAP(ctx->S[i], ctx->S[j]);\n      /* Repeat key as needed */\n      k = (k + 1) % length;\n    }\n  ctx->i = ctx->j = 0;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "arcfour128_set_key": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\narcfour128_set_key(struct arcfour_ctx *ctx, const uint8_t *key)\n{\n  arcfour_set_key (ctx, ARCFOUR128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/arcfour.h": {},
  "nettle/nettle-3.4.1/arctwo-meta.c": {},
  "nettle/nettle-3.4.1/arctwo.c": {
    "arctwo_encrypt": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\narctwo_encrypt (struct arctwo_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  FOR_BLOCKS (length, dst, src, ARCTWO_BLOCK_SIZE)\n  {\n    register unsigned i;\n    uint16_t w0, w1, w2, w3;\n\n    w0 = LE_READ_UINT16 (&src[0]);\n    w1 = LE_READ_UINT16 (&src[2]);\n    w2 = LE_READ_UINT16 (&src[4]);\n    w3 = LE_READ_UINT16 (&src[6]);\n\n    for (i = 0; i < 16; i++)\n      {\n\tregister unsigned j = i * 4;\n\t/* For some reason I cannot combine those steps. */\n\tw0 += (w1 & ~w3) + (w2 & w3) + ctx->S[j];\n\tw0 = rotl16 (w0, 1);\n\n\tw1 += (w2 & ~w0) + (w3 & w0) + ctx->S[j + 1];\n\tw1 = rotl16 (w1, 2);\n\n\tw2 += (w3 & ~w1) + (w0 & w1) + ctx->S[j + 2];\n\tw2 = rotl16 (w2, 3);\n\n\tw3 += (w0 & ~w2) + (w1 & w2) + ctx->S[j + 3];\n\tw3 = rotl16 (w3, 5);\n\n\tif (i == 4 || i == 10)\n\t  {\n\t    w0 += ctx->S[w3 & 63];\n\t    w1 += ctx->S[w0 & 63];\n\t    w2 += ctx->S[w1 & 63];\n\t    w3 += ctx->S[w2 & 63];\n\t  }\n      }\n    LE_WRITE_UINT16 (&dst[0], w0);\n    LE_WRITE_UINT16 (&dst[2], w1);\n    LE_WRITE_UINT16 (&dst[4], w2);\n    LE_WRITE_UINT16 (&dst[6], w3);\n  }\n}",
      "lines": 44,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "arctwo_decrypt": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\narctwo_decrypt (struct arctwo_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  FOR_BLOCKS (length, dst, src, ARCTWO_BLOCK_SIZE)\n  {\n    register unsigned i;\n    uint16_t w0, w1, w2, w3;\n\n    w0 = LE_READ_UINT16 (&src[0]);\n    w1 = LE_READ_UINT16 (&src[2]);\n    w2 = LE_READ_UINT16 (&src[4]);\n    w3 = LE_READ_UINT16 (&src[6]);\n\n    for (i = 16; i-- > 0; )\n      {\n\tregister unsigned j = i * 4;\n\n\tw3 = rotr16 (w3, 5);\n\tw3 -= (w0 & ~w2) + (w1 & w2) + ctx->S[j + 3];\n\n\tw2 = rotr16 (w2, 3);\n\tw2 -= (w3 & ~w1) + (w0 & w1) + ctx->S[j + 2];\n\n\tw1 = rotr16 (w1, 2);\n\tw1 -= (w2 & ~w0) + (w3 & w0) + ctx->S[j + 1];\n\n\tw0 = rotr16 (w0, 1);\n\tw0 -= (w1 & ~w3) + (w2 & w3) + ctx->S[j];\n\n\tif (i == 5 || i == 11)\n\t  {\n\t    w3 = w3 - ctx->S[w2 & 63];\n\t    w2 = w2 - ctx->S[w1 & 63];\n\t    w1 = w1 - ctx->S[w0 & 63];\n\t    w0 = w0 - ctx->S[w3 & 63];\n\t  }\n\n      }\n    LE_WRITE_UINT16 (&dst[0], w0);\n    LE_WRITE_UINT16 (&dst[2], w1);\n    LE_WRITE_UINT16 (&dst[4], w2);\n    LE_WRITE_UINT16 (&dst[6], w3);\n  }\n}",
      "lines": 45,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "arctwo_set_key_ekb": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "void\narctwo_set_key_ekb (struct arctwo_ctx *ctx,\n\t\t    size_t length, const uint8_t *key, unsigned ekb)\n{\n  size_t i;\n  /* Expanded key, treated as octets */\n  uint8_t S[128];\n  uint8_t x;\n\n  assert (length >= ARCTWO_MIN_KEY_SIZE);\n  assert (length <= ARCTWO_MAX_KEY_SIZE);\n  assert (ekb <= 1024);\n\n  for (i = 0; i < length; i++)\n    S[i] = key[i];\n\n  /* Phase 1: Expand input key to 128 bytes */\n  for (i = length; i < ARCTWO_MAX_KEY_SIZE; i++)\n    S[i] = arctwo_sbox[(S[i - length] + S[i - 1]) & 255];\n\n  S[0] = arctwo_sbox[S[0]];\n\n  /* Reduce effective key size to ekb bits, if requested by caller. */\n  if (ekb > 0 && ekb < 1024)\n    {\n      int len = (ekb + 7) >> 3;\n      i = 128 - len;\n      x = arctwo_sbox[S[i] & (255 >> (7 & -ekb))];\n      S[i] = x;\n\n      while (i--)\n\t{\n\t  x = arctwo_sbox[x ^ S[i + len]];\n\t  S[i] = x;\n\t}\n    }\n\n  /* Make the expanded key endian independent. */\n  for (i = 0; i < 64; i++)\n    ctx->S[i] = LE_READ_UINT16(S + i * 2);\n}",
      "lines": 41,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "arctwo_set_key": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "void\narctwo_set_key (struct arctwo_ctx *ctx, size_t length, const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, length, key, 8 * length);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "arctwo_set_key_gutmann": {
      "start_point": [
        232,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "void\narctwo_set_key_gutmann (struct arctwo_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, length, key, 0);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "arctwo40_set_key": {
      "start_point": [
        239,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "void\narctwo40_set_key (struct arctwo_ctx *ctx, const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, 5, key, 40);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "arctwo64_set_key": {
      "start_point": [
        244,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "void\narctwo64_set_key (struct arctwo_ctx *ctx, const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, 8, key, 64);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "arctwo128_set_key": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void\narctwo128_set_key (struct arctwo_ctx *ctx, const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, 16, key, 128);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "arctwo128_set_key_gutmann": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        260,
        1
      ],
      "content": "void\narctwo128_set_key_gutmann (struct arctwo_ctx *ctx,\n\t\t\t   const uint8_t *key)\n{\n  arctwo_set_key_ekb (ctx, 16, key, 1024);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/arctwo.h": {},
  "nettle/nettle-3.4.1/asn1.h": {},
  "nettle/nettle-3.4.1/base16-decode.c": {
    "base16_decode_init": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\nbase16_decode_init(struct base16_decode_ctx *ctx)\n{\n  ctx->word = ctx->bits = 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "base16_decode_single": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "int\nbase16_decode_single(struct base16_decode_ctx *ctx,\n\t\t     uint8_t *dst,\n\t\t     char src)\n{\n  /* Avoid signed char for indexing. */\n  unsigned char usrc = src;\n  int digit;\n\n  if (usrc >= 0x80)\n    return -1;\n\n  digit = hex_decode_table[usrc];\n  switch (digit)\n    {\n    case -1:\n      return -1;\n    case -2:\n      return 0;\n    default:\n      assert(digit >= 0);\n      assert(digit < 0x10);\n\n      if (ctx->bits)\n\t{\n\t  *dst = (ctx->word << 4) | digit;\n\t  ctx->bits = 0;\n\t  return 1;\n\t}\n      else\n\t{\n\t  ctx->word = digit;\n\t  ctx->bits = 4;\n\t  return 0;\n\t}\n    }\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "base16_decode_update": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "int\nbase16_decode_update(struct base16_decode_ctx *ctx,\n\t\t     size_t *dst_length,\n\t\t     uint8_t *dst,\n\t\t     size_t src_length,\n\t\t     const char *src)\n{\n  size_t done;\n  size_t i;\n\n  for (i = done = 0; i<src_length; i++)\n    switch(base16_decode_single(ctx, dst + done, src[i]))\n      {\n      case -1:\n\treturn 0;\n      case 1:\n\tdone++;\n\t/* Fall through */\n      case 0:\n\tbreak;\n      default:\n\tabort();\n      }\n  \n  assert(done <= BASE16_DECODE_LENGTH(src_length));\n\n  *dst_length = done;\n  return 1;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "base16_decode_final": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "int\nbase16_decode_final(struct base16_decode_ctx *ctx)\n{\n  return ctx->bits == 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/base16-encode.c": {
    "base16_encode_single": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\nbase16_encode_single(char *dst,\n\t\t     uint8_t src)\n{\n  dst[0] = DIGIT(src/0x10);\n  dst[1] = DIGIT(src);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "base16_encode_update": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nbase16_encode_update(char *dst,\n\t\t     size_t length,\n\t\t     const uint8_t *src)\n{\n  size_t i;\n  \n  for (i = 0; i<length; i++, dst += 2)\n    base16_encode_single(dst, src[i]);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/base16-meta.c": {
    "base16_encode_length": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static size_t\nbase16_encode_length(size_t length)\n{\n  return BASE16_ENCODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "base16_decode_length": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static size_t\nbase16_decode_length(size_t length)\n{\n  return BASE16_DECODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "base16_encode_init": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        57,
        3
      ],
      "content": "static void\nbase16_encode_init(void *ctx UNUSED)\n{ }",
      "lines": 3,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base16_encode_update_wrapper": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static size_t\nbase16_encode_update_wrapper(void *ctx UNUSED, char *dst,\n\t\t\t     size_t length, const uint8_t *src)\n{\n  base16_encode_update(dst, length, src);\n  return BASE16_ENCODE_LENGTH(length);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "base16_encode_final": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static size_t\nbase16_encode_final(void *ctx UNUSED, char *dst UNUSED)\n{\n  return 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/base16.h": {},
  "nettle/nettle-3.4.1/base64-decode.c": {
    "base64_decode_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\nbase64_decode_init(struct base64_decode_ctx *ctx)\n{\n  static const signed char base64_decode_table[0x100] =\n    {\n      /* White space is HT, VT, FF, CR, LF and SPC */\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1, \n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63,\n      52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -3, -1, -1,\n      -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n      15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1,\n      -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n      41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    };\n\n  ctx->word = ctx->bits = ctx->padding = 0;\n  ctx->table = base64_decode_table;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "base64_decode_single": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "int\nbase64_decode_single(struct base64_decode_ctx *ctx,\n\t\t     uint8_t *dst,\n\t\t     char src)\n{\n  int data = ctx->table[(uint8_t) src];\n\n  switch(data)\n    {\n    default:\n      assert(data >= 0 && data < 0x40);\n\n      if (ctx->padding)\n\treturn -1;\n      \n      ctx->word = ctx->word << 6 | data;\n      ctx->bits += 6;\n\n      if (ctx->bits >= 8)\n\t{\n\t  ctx->bits -= 8;\n\t  dst[0] = ctx->word >> ctx->bits;\n\t  return 1;\n\t}\n      else return 0;\n\n    case TABLE_INVALID:\n      return -1;\n\n    case TABLE_SPACE:\n      return 0;\n      \n    case TABLE_END:\n      /* There can be at most two padding characters. */\n      if (!ctx->bits || ctx->padding > 2)\n\treturn -1;\n      \n      if (ctx->word & ( (1<<ctx->bits) - 1))\n\t/* We shouldn't have any leftover bits */\n\treturn -1;\n\n      ctx->padding++;\n      ctx->bits -= 2;\n      return 0;\n    }\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "base64_decode_update": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "int\nbase64_decode_update(struct base64_decode_ctx *ctx,\n\t\t     size_t *dst_length,\n\t\t     uint8_t *dst,\n\t\t     size_t src_length,\n\t\t     const char *src)\n{\n  size_t done;\n  size_t i;\n\n  for (i = 0, done = 0; i<src_length; i++)\n    switch(base64_decode_single(ctx, dst + done, src[i]))\n      {\n      case -1:\n\treturn 0;\n      case 1:\n\tdone++;\n\t/* Fall through */\n      case 0:\n\tbreak;\n      default:\n\tabort();\n      }\n  \n  assert(done <= BASE64_DECODE_LENGTH(src_length));\n\n  *dst_length = done;\n  return 1;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "base64_decode_final": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        153,
        1
      ],
      "content": "int\nbase64_decode_final(struct base64_decode_ctx *ctx)\n{\n  return ctx->bits == 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/base64-encode.c": {
    "encode_raw": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static void\nencode_raw(const char *alphabet,\n\t   char *dst, size_t length, const uint8_t *src)\n{\n  const uint8_t *in = src + length;\n  char *out = dst + BASE64_ENCODE_RAW_LENGTH(length);\n\n  unsigned left_over = length % 3;\n\n  if (left_over)\n    {\n      in -= left_over;\n      *--out = '=';\n      switch(left_over)\n\t{\n\tcase 1:\n\t  *--out = '=';\n\t  *--out = ENCODE(alphabet, (in[0] << 4));\n\t  break;\n\t  \n\tcase 2:\n\t  *--out = ENCODE(alphabet, (in[1] << 2));\n\t  *--out = ENCODE(alphabet, ((in[0] << 4) | (in[1] >> 4)));\n\t  break;\n\n\tdefault:\n\t  abort();\n\t}\n      *--out = ENCODE(alphabet, (in[0] >> 2));\n    }\n  \n  while (in > src)\n    {\n      in -= 3;\n      *--out = ENCODE(alphabet, (in[2]));\n      *--out = ENCODE(alphabet, ((in[1] << 2) | (in[2] >> 6)));\n      *--out = ENCODE(alphabet, ((in[0] << 4) | (in[1] >> 4)));\n      *--out = ENCODE(alphabet, (in[0] >> 2));\n    }\n  assert(in == src);\n  assert(out == dst);\n}",
      "lines": 42,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode_raw": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\nbase64_encode_raw(char *dst, size_t length, const uint8_t *src)\n{\n  encode_raw(base64_encode_table, dst, length, src);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_group": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "void\nbase64_encode_group(char *dst, uint32_t group)\n{\n  *dst++ = ENCODE(base64_encode_table, (group >> 18));\n  *dst++ = ENCODE(base64_encode_table, (group >> 12));\n  *dst++ = ENCODE(base64_encode_table, (group >> 6));\n  *dst++ = ENCODE(base64_encode_table, group);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_init": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\nbase64_encode_init(struct base64_encode_ctx *ctx)\n{\n  ctx->word = ctx->bits = 0;\n  ctx->alphabet = base64_encode_table;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "base64_encode_single": {
      "start_point": [
        113,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "size_t\nbase64_encode_single(struct base64_encode_ctx *ctx,\n\t\t     char *dst,\n\t\t     uint8_t src)\n{\n  unsigned done = 0;\n  unsigned word = ctx->word << 8 | src;\n  unsigned bits = ctx->bits + 8;\n  \n  while (bits >= 6)\n    {\n      bits -= 6;\n      dst[done++] = ENCODE(ctx->alphabet, (word >> bits));\n    }\n\n  ctx->bits = bits;\n  ctx->word = word;\n\n  assert(done <= 2);\n  \n  return done;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "base64_encode_update": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "size_t\nbase64_encode_update(struct base64_encode_ctx *ctx,\n\t\t     char *dst,\n\t\t     size_t length,\n\t\t     const uint8_t *src)\n{\n  size_t done = 0;\n  size_t left = length;\n  unsigned left_over;\n  size_t bulk;\n  \n  while (ctx->bits && left)\n    {\n      left--;\n      done += base64_encode_single(ctx, dst + done, *src++);\n    }\n  \n  left_over = left % 3;\n  bulk = left - left_over;\n  \n  if (bulk)\n    {\n      assert(!(bulk % 3));\n      \n      encode_raw(ctx->alphabet, dst + done, bulk, src);\n      done += BASE64_ENCODE_RAW_LENGTH(bulk);\n      src += bulk;\n      left = left_over;\n    }\n\n  while (left)\n    {\n      left--;\n      done += base64_encode_single(ctx, dst + done, *src++);\n    }\n\n  assert(done <= BASE64_ENCODE_LENGTH(length));\n\n  return done;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "base64_encode_final": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "size_t\nbase64_encode_final(struct base64_encode_ctx *ctx,\n\t\t    char *dst)\n{\n  unsigned done = 0;\n  unsigned bits = ctx->bits;\n  \n  if (bits)\n    {\n      dst[done++] = ENCODE(ctx->alphabet, (ctx->word << (6 - ctx->bits)));\n      for (; bits < 6; bits += 2)\n\tdst[done++] = '=';\n\n      ctx->bits = 0;\n    }\n\n  assert(done <= BASE64_ENCODE_FINAL_LENGTH);\n  return done;\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/base64-meta.c": {
    "base64_encode_length": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static size_t\nbase64_encode_length(size_t length)\n{\n  return BASE64_ENCODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "base64_decode_length": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static size_t\nbase64_decode_length(size_t length)\n{\n  return BASE64_DECODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/base64.h": {},
  "nettle/nettle-3.4.1/base64url-decode.c": {
    "base64url_decode_init": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\nbase64url_decode_init(struct base64_decode_ctx *ctx)\n{\n  static const signed char base64url_decode_table[0x100] =\n    {\n      /* White space is HT, VT, FF, CR, LF and SPC */\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -2, -2, -2, -2, -2, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1,\n      52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -3, -1, -1,\n      -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,\n      15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, 63,\n      -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,\n      41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n      -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n    };\n\n  ctx->word = ctx->bits = ctx->padding = 0;\n  ctx->table = base64url_decode_table;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/base64url-encode.c": {
    "base64url_encode_init": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nbase64url_encode_init(struct base64_encode_ctx *ctx)\n{\n  static const char base64url_encode_table[64] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"0123456789-_\";\n\n  ctx->word = ctx->bits = 0;\n  ctx->alphabet = base64url_encode_table;\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/base64url-meta.c": {
    "base64url_encode_length": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static size_t\nbase64url_encode_length(size_t length)\n{\n  return BASE64_ENCODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "base64url_decode_length": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static size_t\nbase64url_decode_length(size_t length)\n{\n  return BASE64_DECODE_LENGTH(length);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/bignum-random-prime.c": {
    "miller_rabin_pocklington": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        238,
        1
      ],
      "content": "static int\nmiller_rabin_pocklington(mpz_t n, mpz_t nm1, mpz_t nm1dq, mpz_t a)\n{\n  mpz_t r;\n  mpz_t y;\n  int is_prime = 0;\n\n  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n     versions. */\n  unsigned k;\n  unsigned j;\n\n  VERBOSE(\".\");\n\n  if (mpz_even_p(n) || mpz_cmp_ui(n, 3) < 0)\n    return 0;\n\n  mpz_init(r);\n  mpz_init(y);\n\n  k = mpz_scan1(nm1, 0);\n  assert(k > 0);\n\n  mpz_fdiv_q_2exp (r, nm1, k);\n\n  mpz_powm(y, a, r, n);\n\n  if (mpz_cmp_ui(y, 1) == 0 || mpz_cmp(y, nm1) == 0)\n    goto passed_miller_rabin;\n    \n  for (j = 1; j < k; j++)\n    {\n      mpz_powm_ui (y, y, 2, n);\n\n      if (mpz_cmp_ui (y, 1) == 0)\n\tbreak;\n\n      if (mpz_cmp (y, nm1) == 0)\n\t{\n\tpassed_miller_rabin:\n\t  /* We know that a^{n-1} = 1 (mod n)\n\n\t     Remains to check that gcd(a^{(n-1)/q} - 1, n) == 1 */      \n\t  VERBOSE(\"x\");\n\n\t  mpz_powm(y, a, nm1dq, n);\n\t  mpz_sub_ui(y, y, 1);\n\t  mpz_gcd(y, y, n);\n\t  is_prime = mpz_cmp_ui (y, 1) == 0;\n\t  VERBOSE(is_prime ? \"\\n\" : \"\");\n\t  break;\n\t}\n\n    }\n\n  mpz_clear(r);\n  mpz_clear(y);\n\n  return is_prime;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_nettle_generate_pocklington_prime": {
      "start_point": [
        328,
        0
      ],
      "end_point": [
        458,
        1
      ],
      "content": "void\n_nettle_generate_pocklington_prime (mpz_t p, mpz_t r,\n\t\t\t\t    unsigned bits, int top_bits_set, \n\t\t\t\t    void *ctx, nettle_random_func *random, \n\t\t\t\t    const mpz_t p0,\n\t\t\t\t    const mpz_t q,\n\t\t\t\t    const mpz_t p0q)\n{\n  mpz_t r_min, r_range, pm1, a, e;\n  int need_square_test;\n  unsigned p0_bits;\n  mpz_t x, y, p04;\n\n  p0_bits = mpz_sizeinbase (p0, 2);\n\n  assert (bits <= 3*p0_bits);\n  assert (bits > p0_bits);\n\n  need_square_test = (bits > 2 * p0_bits);\n\n  mpz_init (r_min);\n  mpz_init (r_range);\n  mpz_init (pm1);\n  mpz_init (a);\n\n  if (need_square_test)\n    {\n      mpz_init (x);\n      mpz_init (y);\n      mpz_init (p04);\n      mpz_mul_2exp (p04, p0, 2);\n    }\n\n  if (q)\n    mpz_init (e);\n\n  if (top_bits_set)\n    {\n      /* i = floor (2^{bits-3} / p0q), then 3I + 3 <= r <= 4I, with I\n\t - 2 possible values. */\n      mpz_set_ui (r_min, 1);\n      mpz_mul_2exp (r_min, r_min, bits-3);\n      mpz_fdiv_q (r_min, r_min, p0q);\n      mpz_sub_ui (r_range, r_min, 2);\n      mpz_mul_ui (r_min, r_min, 3);\n      mpz_add_ui (r_min, r_min, 3);\n    }\n  else\n    {\n      /* i = floor (2^{bits-2} / p0q), I + 1 <= r <= 2I */\n      mpz_set_ui (r_range, 1);\n      mpz_mul_2exp (r_range, r_range, bits-2);\n      mpz_fdiv_q (r_range, r_range, p0q);\n      mpz_add_ui (r_min, r_range, 1);\n    }\n\n  for (;;)\n    {\n      uint8_t buf[1];\n\n      nettle_mpz_random (r, ctx, random, r_range);\n      mpz_add (r, r, r_min);\n\n      /* Set p = 2*r*p0q + 1 */\n      mpz_mul_2exp(r, r, 1);\n      mpz_mul (pm1, r, p0q);\n      mpz_add_ui (p, pm1, 1);\n\n      assert(mpz_sizeinbase(p, 2) == bits);\n\n      /* Should use GMP trial division interface when that\n\t materializes, we don't need any testing beyond trial\n\t division. */\n      if (!mpz_probab_prime_p (p, 1))\n\tcontinue;\n\n      random(ctx, sizeof(buf), buf);\n\t  \n      mpz_set_ui (a, buf[0] + 2);\n\n      if (q)\n\t{\n\t  mpz_mul (e, r, q);\n\t  if (!miller_rabin_pocklington(p, pm1, e, a))\n\t    continue;\n\n\t  if (need_square_test)\n\t    {\n\t      /* Our e corresponds to 2r in the theorem */\n\t      mpz_tdiv_qr (x, y, e, p04);\n\t      goto square_test;\n\t    }\n\t}\n      else\n\t{\n\t  if (!miller_rabin_pocklington(p, pm1, r, a))\n\t    continue;\n\t  if (need_square_test)\n\t    {\n\t      mpz_tdiv_qr (x, y, r, p04);\n\t    square_test:\n\t      /* We have r' = 2r, x = floor (r/2q) = floor(r'/2q),\n\t\t and y' = r' - x 4q = 2 (r - x 2q) = 2y.\n\n\t\t Then y^2 - 4x is a square iff y'^2 - 16 x is a\n\t\t square. */\n\t\t \n\t      mpz_mul (y, y, y);\n\t      mpz_submul_ui (y, x, 16);\n\t      if (mpz_perfect_square_p (y))\n\t\tcontinue;\n\t    }\n\t}\n\n      /* If we passed all the tests, we have found a prime. */\n      break;\n    }\n  mpz_clear (r_min);\n  mpz_clear (r_range);\n  mpz_clear (pm1);\n  mpz_clear (a);\n\n  if (need_square_test)\n    {\n      mpz_clear (x);\n      mpz_clear (y);\n      mpz_clear (p04);\n    }\n  if (q)\n    mpz_clear (e);\n}",
      "lines": 131,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "nettle_random_prime": {
      "start_point": [
        463,
        0
      ],
      "end_point": [
        532,
        1
      ],
      "content": "void\nnettle_random_prime(mpz_t p, unsigned bits, int top_bits_set,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    void *progress_ctx, nettle_progress_func *progress)\n{\n  assert (bits >= 3);\n  if (bits <= 10)\n    {\n      unsigned first;\n      unsigned choices;\n      uint8_t buf;\n\n      assert (!top_bits_set);\n\n      random (random_ctx, sizeof(buf), &buf);\n\n      first = prime_by_size[bits-3];\n      choices = prime_by_size[bits-2] - first;\n      \n      mpz_set_ui (p, primes[first + buf % choices]);\n    }\n  else if (bits <= 20)\n    {\n      unsigned long highbit;\n      uint8_t buf[3];\n      unsigned long x;\n      unsigned j;\n      \n      assert (!top_bits_set);\n\n      highbit = 1L << (bits - 1);\n\n    again:\n      random (random_ctx, sizeof(buf), buf);\n      x = READ_UINT24(buf);\n      x &= (highbit - 1);\n      x |= highbit | 1;\n\n      for (j = 0; prime_square[j] <= x; j++)\n\t{\n\t  unsigned q = x * trial_div_table[j].inverse & TRIAL_DIV_MASK;\n\t  if (q <= trial_div_table[j].limit)\n\t    goto again;\n\t}\n      mpz_set_ui (p, x);\n    }\n  else\n    {\n      mpz_t q, r;\n\n      mpz_init (q);\n      mpz_init (r);\n\n     /* Bit size ceil(k/2) + 1, slightly larger than used in Alg. 4.62\n\tin Handbook of Applied Cryptography (which seems to be\n\tincorrect for odd k). */\n      nettle_random_prime (q, (bits+3)/2, 0, random_ctx, random,\n\t\t\t   progress_ctx, progress);\n\n      _nettle_generate_pocklington_prime (p, r, bits, top_bits_set,\n\t\t\t\t\t  random_ctx, random,\n\t\t\t\t\t  q, NULL, q);\n      \n      if (progress)\n\tprogress (progress_ctx, 'x');\n\n      mpz_clear (q);\n      mpz_clear (r);\n    }\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/bignum-random.c": {
    "nettle_mpz_random_size": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nnettle_mpz_random_size(mpz_t x,\n\t\t       void *ctx, nettle_random_func *random,\n\t\t       unsigned bits)\n{\n  unsigned length = (bits + 7) / 8;\n  TMP_GMP_DECL(data, uint8_t);\n\n  TMP_GMP_ALLOC(data, length);\n\n  random(ctx, length, data);\n  nettle_mpz_set_str_256_u(x, length, data);\n\n  if (bits % 8)\n    mpz_fdiv_r_2exp(x, x, bits);\n  \n  TMP_GMP_FREE(data);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "nettle_mpz_random": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\nnettle_mpz_random(mpz_t x,\n\t\t  void *ctx, nettle_random_func *random,\n\t\t  const mpz_t n)\n{\n  /* NOTE: This leaves some bias, which may be bad for DSA. A better\n   * way might be to generate a random number of mpz_sizeinbase(n, 2)\n   * bits, and loop until one smaller than n is found. */\n\n  /* From Daniel Bleichenbacher (via coderpunks):\n   *\n   * There is still a theoretical attack possible with 8 extra bits.\n   * But, the attack would need about 2^66 signatures 2^66 memory and\n   * 2^66 time (if I remember that correctly). Compare that to DSA,\n   * where the attack requires 2^22 signatures 2^40 memory and 2^64\n   * time. And of course, the numbers above are not a real threat for\n   * PGP. Using 16 extra bits (i.e. generating a 176 bit random number\n   * and reducing it modulo q) will defeat even this theoretical\n   * attack.\n   * \n   * More generally log_2(q)/8 extra bits are enough to defeat my\n   * attack. NIST also plans to update the standard.\n   */\n\n  /* Add a few bits extra, to decrease the bias from the final modulo\n   * operation. NIST FIPS 186-3 specifies 64 extra bits, for use with\n   * DSA. */\n\n  nettle_mpz_random_size(x, \n\t\t\t ctx, random,\n\t\t\t mpz_sizeinbase(n, 2) + 64);\n  \n  mpz_fdiv_r(x, x, n);\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/bignum.c": {
    "nettle_mpz_sizeinbase_256_s": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "size_t\nnettle_mpz_sizeinbase_256_s(const mpz_t x)\n{\n  if (mpz_sgn(x) >= 0)\n    return 1 + mpz_sizeinbase(x, 2) / 8;\n  else\n    {\n      /* We'll output ~~x, so we need as many bits as for ~x */\n      size_t size;\n      mpz_t c;\n\n      mpz_init(c);\n      mpz_com(c, x); /* Same as c = - x - 1 = |x| + 1 */\n      size = 1 + mpz_sizeinbase(c,2) / 8;\n      mpz_clear(c);\n\n      return size;\n    }\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "nettle_mpz_sizeinbase_256_u": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "size_t\nnettle_mpz_sizeinbase_256_u(const mpz_t x)\n{\n  return (mpz_sizeinbase(x,2) + 7) / 8;\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "nettle_mpz_to_octets": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "static void\nnettle_mpz_to_octets(size_t length, uint8_t *s,\n\t\t     const mpz_t x, uint8_t sign)\n{\n  uint8_t *dst = s + length - 1;\n  size_t size = mpz_size(x);\n  size_t i;\n  \n  for (i = 0; i<size; i++)\n    {\n      mp_limb_t limb = mpz_getlimbn(x, i);\n      size_t j;\n\n      for (j = 0; length && j < sizeof(mp_limb_t); j++)\n        {\n          *dst-- = sign ^ (limb & 0xff);\n          limb >>= 8;\n          length--;\n\t}\n    }\n  \n  if (length)\n    memset(s, sign, length);\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nettle_mpz_get_str_256": {
      "start_point": [
        107,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\nnettle_mpz_get_str_256(size_t length, uint8_t *s, const mpz_t x)\n{\n  if (!length)\n    {\n      /* x must be zero */\n      assert(!mpz_sgn(x));\n      return;\n    }\n\n  if (mpz_sgn(x) >= 0)\n    {\n      assert(nettle_mpz_sizeinbase_256_u(x) <= length);\n      nettle_mpz_to_octets(length, s, x, 0);\n    }\n  else\n    {\n      mpz_t c;\n      mpz_init(c);\n      mpz_com(c, x);\n\n      assert(nettle_mpz_sizeinbase_256_u(c) <= length);\n      nettle_mpz_to_octets(length, s, c, 0xff);\n\n      mpz_clear(c);\n    }\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "nettle_mpz_set_str_256_u": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\nnettle_mpz_set_str_256_u(mpz_t x,\n\t\t\t size_t length, const uint8_t *s)\n{\n  nettle_mpz_from_octets(x, length, s);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nettle_mpz_init_set_str_256_u": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "void\nnettle_mpz_init_set_str_256_u(mpz_t x,\n\t\t\t      size_t length, const uint8_t *s)\n{\n  mpz_init(x);\n  nettle_mpz_from_octets(x, length, s);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nettle_mpz_set_str_256_s": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "void\nnettle_mpz_set_str_256_s(mpz_t x,\n\t\t\t size_t length, const uint8_t *s)\n{\n  if (!length)\n    {\n      mpz_set_ui(x, 0);\n      return;\n    }\n  \n  nettle_mpz_from_octets(x, length, s);\n\n  if (s[0] & 0x80)\n    {\n      mpz_t t;\n\n      mpz_init_set_ui(t, 1);\n      mpz_mul_2exp(t, t, length*8);\n      mpz_sub(x, x, t);\n      mpz_clear(t);\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "nettle_mpz_init_set_str_256_s": {
      "start_point": [
        179,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "void\nnettle_mpz_init_set_str_256_s(mpz_t x,\n\t\t\t      size_t length, const uint8_t *s)\n{\n  mpz_init(x);\n  nettle_mpz_set_str_256_s(x, length, s);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/bignum.h": {},
  "nettle/nettle-3.4.1/blowfish.c": {
    "encrypt": {
      "start_point": [
        263,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void\nencrypt (const struct blowfish_ctx *ctx, uint32_t * ret_xl,\n\t    uint32_t * ret_xr)\n{\n  uint32_t xl, xr;\n\n  xl = *ret_xl;\n  xr = *ret_xr;\n\n  R (ctx, xl, xr, 0);\n  R (ctx, xr, xl, 1);\n  R (ctx, xl, xr, 2);\n  R (ctx, xr, xl, 3);\n  R (ctx, xl, xr, 4);\n  R (ctx, xr, xl, 5);\n  R (ctx, xl, xr, 6);\n  R (ctx, xr, xl, 7);\n  R (ctx, xl, xr, 8);\n  R (ctx, xr, xl, 9);\n  R (ctx, xl, xr, 10);\n  R (ctx, xr, xl, 11);\n  R (ctx, xl, xr, 12);\n  R (ctx, xr, xl, 13);\n  R (ctx, xl, xr, 14);\n  R (ctx, xr, xl, 15);\n\n  xl ^= ctx->p[_BLOWFISH_ROUNDS];\n  xr ^= ctx->p[_BLOWFISH_ROUNDS + 1];\n\n  *ret_xl = xr;\n  *ret_xr = xl;\n}",
      "lines": 32,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "decrypt": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        326,
        1
      ],
      "content": "static void\ndecrypt (const struct blowfish_ctx *ctx, uint32_t * ret_xl, uint32_t * ret_xr)\n{\n  uint32_t xl, xr;\n\n  xl = *ret_xl;\n  xr = *ret_xr;\n\n  R (ctx, xl, xr, 17);\n  R (ctx, xr, xl, 16);\n  R (ctx, xl, xr, 15);\n  R (ctx, xr, xl, 14);\n  R (ctx, xl, xr, 13);\n  R (ctx, xr, xl, 12);\n  R (ctx, xl, xr, 11);\n  R (ctx, xr, xl, 10);\n  R (ctx, xl, xr, 9);\n  R (ctx, xr, xl, 8);\n  R (ctx, xl, xr, 7);\n  R (ctx, xr, xl, 6);\n  R (ctx, xl, xr, 5);\n  R (ctx, xr, xl, 4);\n  R (ctx, xl, xr, 3);\n  R (ctx, xr, xl, 2);\n\n  xl ^= ctx->p[1];\n  xr ^= ctx->p[0];\n\n  *ret_xl = xr;\n  *ret_xr = xl;\n}",
      "lines": 31,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "blowfish_encrypt": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "void\nblowfish_encrypt (const struct blowfish_ctx *ctx,\n\t\t  size_t length, uint8_t * dst, const uint8_t * src)\n{\n  FOR_BLOCKS (length, dst, src, BLOWFISH_BLOCK_SIZE)\n    {\n      uint32_t d1, d2;\n\n      d1 = READ_UINT32(src);\n      d2 = READ_UINT32(src+4);\n      encrypt (ctx, &d1, &d2);\n      dst[0] = (d1 >> 24) & 0xff;\n      dst[1] = (d1 >> 16) & 0xff;\n      dst[2] = (d1 >> 8) & 0xff;\n      dst[3] = d1 & 0xff;\n      dst[4] = (d2 >> 24) & 0xff;\n      dst[5] = (d2 >> 16) & 0xff;\n      dst[6] = (d2 >> 8) & 0xff;\n      dst[7] = d2 & 0xff;\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "blowfish_decrypt": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "void\nblowfish_decrypt (const struct blowfish_ctx *ctx,\n\t\t  size_t length, uint8_t * dst, const uint8_t * src)\n{\n  FOR_BLOCKS (length, dst, src, BLOWFISH_BLOCK_SIZE)\n    {\n      uint32_t d1, d2;\n\n      d1 = READ_UINT32(src);\n      d2 = READ_UINT32(src+4);\n      decrypt (ctx, &d1, &d2);\n      dst[0] = (d1 >> 24) & 0xff;\n      dst[1] = (d1 >> 16) & 0xff;\n      dst[2] = (d1 >> 8) & 0xff;\n      dst[3] = d1 & 0xff;\n      dst[4] = (d2 >> 24) & 0xff;\n      dst[5] = (d2 >> 16) & 0xff;\n      dst[6] = (d2 >> 8) & 0xff;\n      dst[7] = d2 & 0xff;\n    }\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "blowfish_set_key": {
      "start_point": [
        375,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "int\nblowfish_set_key (struct blowfish_ctx *ctx,\n\t\t  size_t length, const uint8_t * key)\n{\n  int i, j;\n  uint32_t data, datal, datar;\n\n  *ctx = initial_ctx;\n\n  for (i = j = 0; i < _BLOWFISH_ROUNDS + 2; i++)\n    {\n      data = (key[j] << 24) | (key[(j+1) % length] << 16)\n\t| (key[(j+2) % length] << 8) | key[(j+3) % length];\n      ctx->p[i] ^= data;\n      j = (j + 4) % length;\n    }\n\n  datal = datar = 0;\n  for (i = 0; i < _BLOWFISH_ROUNDS + 2; i += 2)\n    {\n      encrypt (ctx, &datal, &datar);\n      ctx->p[i] = datal;\n      ctx->p[i + 1] = datar;\n    }\n  \n  for (j = 0; j < 4; j++)\n    for (i = 0; i < 256; i += 2)\n      {\n\tencrypt (ctx, &datal, &datar);\n\tctx->s[j][i] = datal;\n\tctx->s[j][i + 1] = datar;\n    }\n\n  /* Check for weak key.  A weak key is a key in which a value in\n     the P-array (here c) occurs more than once per table.  */\n  for (i = 0; i < 255; i++)\n    {\n      for (j = i + 1; j < 256; j++)\n\t{\n\t  if ((ctx->s[0][i] == ctx->s[0][j])\n\t      || (ctx->s[1][i] == ctx->s[1][j])\n\t      || (ctx->s[2][i] == ctx->s[2][j])\n\t      || (ctx->s[3][i] == ctx->s[3][j]))\n\t    return 0;\n\t}\n    }\n\n  return 1;\n}",
      "lines": 49,
      "depth": 17,
      "decorators": [
        "int"
      ]
    },
    "blowfish128_set_key": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        429,
        1
      ],
      "content": "int\nblowfish128_set_key(struct blowfish_ctx *ctx, const uint8_t *key)\n{\n  return blowfish_set_key (ctx, BLOWFISH128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/blowfish.h": {},
  "nettle/nettle-3.4.1/buffer-init.c": {
    "nettle_buffer_init": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nnettle_buffer_init(struct nettle_buffer *buffer)\n{\n  nettle_buffer_init_realloc(buffer, NULL, nettle_realloc);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/buffer.c": {
    "nettle_buffer_grow": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nnettle_buffer_grow(struct nettle_buffer *buffer,\n\t\t   size_t length)\n{\n  assert(buffer->size <= buffer->alloc);\n  \n  if (buffer->size + length > buffer->alloc)\n    {\n      size_t alloc;\n      uint8_t *p;\n      \n      if (!buffer->realloc)\n\treturn 0;\n      \n      alloc = buffer->alloc * 2 + length + 100;\n      p = buffer->realloc(buffer->realloc_ctx, buffer->contents, alloc);\n      if (!p)\n\treturn 0;\n      \n      buffer->contents = p;\n      buffer->alloc = alloc;\n    }\n  return 1;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "nettle_buffer_init_realloc": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\nnettle_buffer_init_realloc(struct nettle_buffer *buffer,\n\t\t\t   void *realloc_ctx,\n\t\t\t   nettle_realloc_func *realloc)\n{\n  buffer->contents = NULL;\n  buffer->alloc = 0;\n  buffer->realloc = realloc;\n  buffer->realloc_ctx = realloc_ctx;\n  buffer->size = 0;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nettle_buffer_init_size": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nnettle_buffer_init_size(struct nettle_buffer *buffer,\n\t\t\tsize_t length, uint8_t *space)\n{\n  buffer->contents = space;\n  buffer->alloc = length;\n  buffer->realloc = NULL;\n  buffer->realloc_ctx = NULL;\n  buffer->size = 0;\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nettle_buffer_clear": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nnettle_buffer_clear(struct nettle_buffer *buffer)\n{\n  if (buffer->realloc)\n    buffer->realloc(buffer->realloc_ctx, buffer->contents, 0);\n\n  buffer->contents = NULL;\n  buffer->alloc = 0;\n  buffer->size = 0;\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "nettle_buffer_reset": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\nnettle_buffer_reset(struct nettle_buffer *buffer)\n{\n  buffer->size = 0;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "nettle_buffer_space": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "uint8_t *\nnettle_buffer_space(struct nettle_buffer *buffer,\n\t\t    size_t length)\n{\n  uint8_t *p;\n\n  if (!nettle_buffer_grow(buffer, length))\n    return NULL;\n\n  p = buffer->contents + buffer->size;\n  buffer->size += length;\n  return p;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "uint8_t",
        "*\nnettle_buffer_space(struct nettle_buffer *buffer,\n\t\t    size_t length)",
        "*"
      ]
    },
    "nettle_buffer_write": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nnettle_buffer_write(struct nettle_buffer *buffer,\n\t\t    size_t length, const uint8_t *data)\n{\n  uint8_t *p = nettle_buffer_space(buffer, length);\n  if (p)\n    {\n      memcpy(p, data, length);\n      return 1;\n    }\n  else\n    return 0;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "nettle_buffer_copy": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "int\nnettle_buffer_copy(struct nettle_buffer *dst,\n\t\t   const struct nettle_buffer *src)\n{\n  return nettle_buffer_write(dst, src->size, src->contents);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/buffer.h": {},
  "nettle/nettle-3.4.1/camellia-absorb.c": {
    "_camellia_absorb": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\n_camellia_absorb(unsigned nkeys, uint64_t *dst, uint64_t *subkey)\n{\n  uint64_t kw2, kw4;\n  uint32_t dw, tl, tr;\n  unsigned i;\n  \n  /* At this point, the subkey array contains the subkeys as described\n     in the spec, 26 for short keys and 34 for large keys. */\n\n  /* absorb kw2 to other subkeys */\n  kw2 = subkey[1];\n\n  subkey[3] ^= kw2;\n  subkey[5] ^= kw2;\n  subkey[7] ^= kw2;\n  for (i = 8; i < nkeys; i += 8)\n    {\n      /* FIXME: gcc for x86_32 is smart enough to fetch the 32 low bits\n\t and xor the result into the 32 high bits, but it still generates\n\t worse code than for explicit 32-bit operations. */\n      kw2 ^= (kw2 & ~subkey[i+1]) << 32;\n      dw = (kw2 & subkey[i+1]) >> 32; kw2 ^= ROTL32(1, dw); \n\n      subkey[i+3] ^= kw2;\n      subkey[i+5] ^= kw2;\n      subkey[i+7] ^= kw2;\n    }\n  subkey[i] ^= kw2;\n  \n  /* absorb kw4 to other subkeys */  \n  kw4 = subkey[nkeys + 1];\n\n  for (i = nkeys - 8; i > 0; i -= 8)\n    {\n      subkey[i+6] ^= kw4;\n      subkey[i+4] ^= kw4;\n      subkey[i+2] ^= kw4;\n      kw4 ^= (kw4 & ~subkey[i]) << 32;\n      dw = (kw4 & subkey[i]) >> 32; kw4 ^= ROTL32(1, dw);      \n    }\n\n  subkey[6] ^= kw4;\n  subkey[4] ^= kw4;\n  subkey[2] ^= kw4;\n  subkey[0] ^= kw4;\n\n  /* key XOR is end of F-function */\n  dst[0] = subkey[0] ^ subkey[2];\n  dst[1] = subkey[3];\n\n  dst[2] = subkey[2] ^ subkey[4];\n  dst[3] = subkey[3] ^ subkey[5];\n  dst[4] = subkey[4] ^ subkey[6];\n  dst[5] = subkey[5] ^ subkey[7];\n\n  for (i = 8; i < nkeys; i += 8)\n    {\n      tl = (subkey[i+2] >> 32) ^ (subkey[i+2] & ~subkey[i]);\n      dw = tl & (subkey[i] >> 32);\n      tr = subkey[i+2] ^ ROTL32(1, dw);\n      dst[i-2] = subkey[i-2] ^ ( ((uint64_t) tl << 32) | tr);\n\n      dst[i-1] = subkey[i];\n      dst[i] = subkey[i+1];\n\n      tl = (subkey[i-1] >> 32) ^ (subkey[i-1] & ~subkey[i+1]);\n      dw = tl & (subkey[i+1] >> 32);\n      tr = subkey[i-1] ^ ROTL32(1, dw);\n      dst[i+1] = subkey[i+3] ^ ( ((uint64_t) tl << 32) | tr);\n\n      dst[i+2] = subkey[i+2] ^ subkey[i+4];\n      dst[i+3] = subkey[i+3] ^ subkey[i+5];\n      dst[i+4] = subkey[i+4] ^ subkey[i+6];\n      dst[i+5] = subkey[i+5] ^ subkey[i+7];\n    }\n  dst[i-2] = subkey[i-2];\n  dst[i-1] = subkey[i] ^ subkey[i-1];\n\n#if !HAVE_NATIVE_64_BIT\n  for (i = 0; i < nkeys; i += 8)\n    {\n      /* apply the inverse of the last half of F-function */\n      CAMELLIA_F_HALF_INV(dst[i+1]);\n      CAMELLIA_F_HALF_INV(dst[i+2]);\n      CAMELLIA_F_HALF_INV(dst[i+3]);\n      CAMELLIA_F_HALF_INV(dst[i+4]);\n      CAMELLIA_F_HALF_INV(dst[i+5]);\n      CAMELLIA_F_HALF_INV(dst[i+6]);\n    }\n#endif\n  \n}",
      "lines": 93,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia-crypt-internal.c": {
    "_camellia_crypt": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\n_camellia_crypt(unsigned nkeys,\n\t\tconst uint64_t *keys,\n\t\tconst struct camellia_table *T,\n\t\tsize_t length, uint8_t *dst,\n\t\tconst uint8_t *src)\n{\n  FOR_BLOCKS(length, dst, src, CAMELLIA_BLOCK_SIZE)\n    {\n      uint64_t i0,i1;\n      unsigned i;\n\n      i0 = READ_UINT64(src);\n      i1 = READ_UINT64(src +  8);\n      \n      /* pre whitening but absorb kw2*/\n      i0 ^= keys[0];\n\n      /* main iteration */\n\n      CAMELLIA_ROUNDSM(T, i0, keys[1], i1);\n      CAMELLIA_ROUNDSM(T, i1, keys[2], i0);\n      CAMELLIA_ROUNDSM(T, i0, keys[3], i1);\n      CAMELLIA_ROUNDSM(T, i1, keys[4], i0);\n      CAMELLIA_ROUNDSM(T, i0, keys[5], i1);\n      CAMELLIA_ROUNDSM(T, i1, keys[6], i0);\n      \n      for (i = 0; i < nkeys - 8; i+= 8)\n\t{\n\t  CAMELLIA_FL(i0, keys[i+7]);\n\t  CAMELLIA_FLINV(i1, keys[i+8]);\n\t  \n\t  CAMELLIA_ROUNDSM(T, i0, keys[i+9], i1);\n\t  CAMELLIA_ROUNDSM(T, i1, keys[i+10], i0);\n\t  CAMELLIA_ROUNDSM(T, i0, keys[i+11], i1);\n\t  CAMELLIA_ROUNDSM(T, i1, keys[i+12], i0);\n\t  CAMELLIA_ROUNDSM(T, i0, keys[i+13], i1);\n\t  CAMELLIA_ROUNDSM(T, i1, keys[i+14], i0);\n\t}\n\n      /* post whitening but kw4 */\n      i1 ^= keys[i+7];\n\n      WRITE_UINT64(dst     , i1);\n      WRITE_UINT64(dst +  8, i0);\n    }\n}",
      "lines": 47,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia-internal.h": {},
  "nettle/nettle-3.4.1/camellia-invert-key.c": {
    "_camellia_invert_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\n_camellia_invert_key(unsigned nkeys,\n\t\t     uint64_t *dst, const uint64_t *src)\n{\n  unsigned i;\n  if (dst == src)\n    for (i = 0; i < nkeys - 1 - i; i++)\n\tSWAP (dst[i], dst[nkeys - 1- i]);\n  else\n    for (i = 0; i < nkeys; i++)\n      dst[i] = src[nkeys - 1 - i];\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia-table.c": {},
  "nettle/nettle-3.4.1/camellia.h": {},
  "nettle/nettle-3.4.1/camellia128-crypt.c": {
    "camellia128_crypt": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ncamellia128_crypt(const struct camellia128_ctx *ctx,\n\t\t  size_t length, uint8_t *dst,\n\t\t  const uint8_t *src)\n{\n  assert(!(length % CAMELLIA_BLOCK_SIZE) );\n  _camellia_crypt(_CAMELLIA128_NKEYS, ctx->keys,\n\t\t  &_camellia_table,\n\t\t  length, dst, src);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia128-meta.c": {},
  "nettle/nettle-3.4.1/camellia128-set-decrypt-key.c": {
    "camellia128_invert_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\ncamellia128_invert_key(struct camellia128_ctx *dst,\n\t\t       const struct camellia128_ctx *src)\n{\n  _camellia_invert_key (_CAMELLIA128_NKEYS, dst->keys, src->keys);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "camellia128_set_decrypt_key": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ncamellia128_set_decrypt_key(struct camellia128_ctx *ctx,\n\t\t\t    const uint8_t *key)\n{\n  camellia128_set_encrypt_key(ctx, key);\n  camellia128_invert_key(ctx, ctx);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia128-set-encrypt-key.c": {
    "camellia128_set_encrypt_key": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "void\ncamellia128_set_encrypt_key (struct camellia128_ctx *ctx,\n\t\t\t     const uint8_t *key)\n{\n  uint64_t k0, k1;\n\n  uint64_t subkey[_CAMELLIA128_NKEYS + 2];\n  uint64_t w;\n\n  k0 = READ_UINT64(key);\n  k1 = READ_UINT64(key +  8);\n  \n  /**\n   * generate KL dependent subkeys\n   */\n  subkey[0] = k0; subkey[1] = k1;\n  ROTL128(15, k0, k1);\n  subkey[4] = k0; subkey[5] = k1;\n  ROTL128(30, k0, k1);\n  subkey[10] = k0; subkey[11] = k1;\n  ROTL128(15, k0, k1);\n  subkey[13] = k1;\n  ROTL128(17, k0, k1);\n  subkey[16] = k0; subkey[17] = k1;\n  ROTL128(17, k0, k1);\n  subkey[18] = k0; subkey[19] = k1;\n  ROTL128(17, k0, k1);\n  subkey[22] = k0; subkey[23] = k1;\n\n  /* generate KA. D1 is k0, d2 is k1. */\n  /* FIXME: Make notation match the spec better. */\n  /* For the 128-bit case, KR = 0, the construction of KA reduces to:\n\n     D1 = KL >> 64;\n     W = KL & MASK64;\n     D2 = F(D1, Sigma1);\n     W = D2 ^ W\n     D1 = F(W, Sigma2)\n     D2 = D2 ^ F(D1, Sigma3);\n     D1 = D1 ^ F(D2, Sigma4);\n     KA = (D1 << 64) | D2;\n  */\n  k0 = subkey[0]; w = subkey[1];\n  CAMELLIA_F(k0, SIGMA1, k1);\n  w ^= k1;\n  CAMELLIA_F(w, SIGMA2, k0);\n  CAMELLIA_F(k0, SIGMA3, w);\n  k1 ^= w;\n  CAMELLIA_F(k1, SIGMA4, w);\n  k0 ^= w;\n\n  /* generate KA dependent subkeys */\n  subkey[2] = k0; subkey[3] = k1;\n  ROTL128(15, k0, k1);\n  subkey[6] = k0; subkey[7] = k1;\n  ROTL128(15, k0, k1);\n  subkey[8] = k0; subkey[9] = k1;\n  ROTL128(15, k0, k1);\n  subkey[12] = k0;\n  ROTL128(15, k0, k1);\n  subkey[14] = k0; subkey[15] = k1;\n  ROTL128(34, k0, k1);\n  subkey[20] = k0; subkey[21] = k1;\n  ROTL128(17, k0, k1);\n  subkey[24] = k0; subkey[25] = k1;\n\n  /* Common final processing */\n  _camellia_absorb (_CAMELLIA128_NKEYS, ctx->keys, subkey);\n}",
      "lines": 69,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia192-meta.c": {},
  "nettle/nettle-3.4.1/camellia256-crypt.c": {
    "camellia256_crypt": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ncamellia256_crypt(const struct camellia256_ctx *ctx,\n\t\t  size_t length, uint8_t *dst,\n\t\t  const uint8_t *src)\n{\n  assert(!(length % CAMELLIA_BLOCK_SIZE) );\n  _camellia_crypt(_CAMELLIA256_NKEYS, ctx->keys,\n\t\t  &_camellia_table,\n\t\t  length, dst, src);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia256-meta.c": {},
  "nettle/nettle-3.4.1/camellia256-set-decrypt-key.c": {
    "camellia256_invert_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\ncamellia256_invert_key(struct camellia256_ctx *dst,\n\t\t       const struct camellia256_ctx *src)\n{\n  _camellia_invert_key (_CAMELLIA256_NKEYS, dst->keys, src->keys);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "camellia256_set_decrypt_key": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ncamellia256_set_decrypt_key(struct camellia256_ctx *ctx,\n\t\t\t    const uint8_t *key)\n{\n  camellia256_set_encrypt_key(ctx, key);\n  camellia256_invert_key(ctx, ctx);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "camellia192_set_decrypt_key": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ncamellia192_set_decrypt_key(struct camellia256_ctx *ctx,\n\t\t\t    const uint8_t *key)\n{\n  camellia192_set_encrypt_key(ctx, key);\n  camellia256_invert_key(ctx, ctx);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/camellia256-set-encrypt-key.c": {
    "_camellia256_set_encrypt_key": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static void\n_camellia256_set_encrypt_key (struct camellia256_ctx *ctx,\n\t\t\t      uint64_t k0, uint64_t k1,\n\t\t\t      uint64_t k2, uint64_t k3)\n{\n  uint64_t subkey[_CAMELLIA256_NKEYS + 2];\n  uint64_t w;\n  \n  /* generate KL dependent subkeys */\n  subkey[0] = k0; subkey[1] = k1;\n  ROTL128(45, k0, k1);\n  subkey[12] = k0; subkey[13] = k1;\n  ROTL128(15, k0, k1);\n  subkey[16] = k0; subkey[17] = k1;\n  ROTL128(17, k0, k1);\n  subkey[22] = k0; subkey[23] = k1;\n  ROTL128(34, k0, k1);\n  subkey[30] = k0; subkey[31] = k1;\n\n  /* generate KR dependent subkeys */\n  ROTL128(15, k2, k3);\n  subkey[4] = k2; subkey[5] = k3;\n  ROTL128(15, k2, k3);\n  subkey[8] = k2; subkey[9] = k3;\n  ROTL128(30, k2, k3);\n  subkey[18] = k2; subkey[19] = k3;\n  ROTL128(34, k2, k3);\n  subkey[26] = k2; subkey[27] = k3;\n  ROTL128(34, k2, k3);\n\n  /* generate KA */\n  /* The construction of KA is done as\n\n     D1 = (KL ^ KR) >> 64\n     D2 = (KL ^ KR) & MASK64\n     W = F(D1, SIGMA1)\n     D2 = D2 ^ W\n     D1 = F(D2, SIGMA2) ^ (KR >> 64)\n     D2 = F(D1, SIGMA3) ^ W ^ (KR & MASK64)\n     D1 = D1 ^ F(W, SIGMA2)\n     D2 = D2 ^ F(D1, SIGMA3)\n     D1 = D1 ^ F(D2, SIGMA4)\n  */\n\n  k0 = subkey[0] ^ k2;\n  k1 = subkey[1] ^ k3;\n\n  CAMELLIA_F(k0, SIGMA1, w);\n  k1 ^= w;\n\n  CAMELLIA_F(k1, SIGMA2, k0);\n  k0 ^= k2;\n\n  CAMELLIA_F(k0, SIGMA3, k1);\n  k1 ^= w ^ k3;\n\n  CAMELLIA_F(k1, SIGMA4, w);\n  k0 ^= w;\n\n  /* generate KB */\n  k2 ^= k0; k3 ^= k1;\n  CAMELLIA_F(k2, SIGMA5, w);\n  k3 ^= w;\n  CAMELLIA_F(k3, SIGMA6, w);\n  k2 ^= w;\n\n  /* generate KA dependent subkeys */\n  ROTL128(15, k0, k1);\n  subkey[6] = k0; subkey[7] = k1;\n  ROTL128(30, k0, k1);\n  subkey[14] = k0; subkey[15] = k1;\n  ROTL128(32, k0, k1);\n  subkey[24] = k0; subkey[25] = k1;\n  ROTL128(17, k0, k1);\n  subkey[28] = k0; subkey[29] = k1;\n\n  /* generate KB dependent subkeys */\n  subkey[2] = k2; subkey[3] = k3;\n  ROTL128(30, k2, k3);\n  subkey[10] = k2; subkey[11] = k3;\n  ROTL128(30, k2, k3);\n  subkey[20] = k2; subkey[21] = k3;\n  ROTL128(51, k2, k3);\n  subkey[32] = k2; subkey[33] = k3;\n\n  /* Common final processing */\n  _camellia_absorb (_CAMELLIA256_NKEYS, ctx->keys, subkey);\n}",
      "lines": 88,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "camellia256_set_encrypt_key": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "void\ncamellia256_set_encrypt_key(struct camellia256_ctx *ctx,\n\t\t\t    const uint8_t *key)\n{\n  uint64_t k0, k1, k2, k3;\n  k0 = READ_UINT64(key);\n  k1 = READ_UINT64(key +  8);\n  k2 = READ_UINT64(key + 16);\n  k3 = READ_UINT64(key + 24);\n\n  _camellia256_set_encrypt_key (ctx, k0, k1, k2, k3);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "camellia192_set_encrypt_key": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "void\ncamellia192_set_encrypt_key(struct camellia256_ctx *ctx,\n\t\t\t    const uint8_t *key)\n{\n  uint64_t k0, k1, k2;\n  k0 = READ_UINT64(key);\n  k1 = READ_UINT64(key +  8);\n  k2 = READ_UINT64(key + 16);\n\n  _camellia256_set_encrypt_key (ctx, k0, k1, k2, ~k2);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/cast128-meta.c": {},
  "nettle/nettle-3.4.1/cast128.c": {
    "cast128_encrypt": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        130,
        1
      ],
      "content": "void\ncast128_encrypt(const struct cast128_ctx *ctx,\n\t\tsize_t length, uint8_t *dst,\n\t\tconst uint8_t *src)\n{\n  FOR_BLOCKS(length, dst, src, CAST128_BLOCK_SIZE)\n    {\n      uint32_t t, l, r;\n\n      /* Get inblock into l,r */\n      l = READ_UINT32(src);\n      r = READ_UINT32(src+4);\n\n      /* Do the work */\n      F1(l, r,  0);\n      F2(r, l,  1);\n      F3(l, r,  2);\n      F1(r, l,  3);\n      F2(l, r,  4);\n      F3(r, l,  5);\n      F1(l, r,  6);\n      F2(r, l,  7);\n      F3(l, r,  8);\n      F1(r, l,  9);\n      F2(l, r, 10);\n      F3(r, l, 11);\n      /* Only do full 16 rounds if key length > 80 bits */\n      if (ctx->rounds & 16) {\n\tF1(l, r, 12);\n\tF2(r, l, 13);\n\tF3(l, r, 14);\n\tF1(r, l, 15);\n      }\n      /* Put l,r into outblock */\n      WRITE_UINT32(dst, r);\n      WRITE_UINT32(dst + 4, l);\n    }\n}",
      "lines": 38,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cast128_decrypt": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\ncast128_decrypt(const struct cast128_ctx *ctx,\n\t\tsize_t length, uint8_t *dst,\n\t\tconst uint8_t *src)\n{\n  FOR_BLOCKS(length, dst, src, CAST128_BLOCK_SIZE)\n    {\n      uint32_t t, l, r;\n\n      /* Get inblock into l,r */\n      r = READ_UINT32(src);\n      l = READ_UINT32(src+4);\n\n      /* Do the work */\n      /* Only do full 16 rounds if key length > 80 bits */\n      if (ctx->rounds & 16) {\n\tF1(r, l, 15);\n\tF3(l, r, 14);\n\tF2(r, l, 13);\n\tF1(l, r, 12);\n      }\n      F3(r, l, 11);\n      F2(l, r, 10);\n      F1(r, l,  9);\n      F3(l, r,  8);\n      F2(r, l,  7);\n      F1(l, r,  6);\n      F3(r, l,  5);\n      F2(l, r,  4);\n      F1(r, l,  3);\n      F3(l, r,  2);\n      F2(r, l,  1);\n      F1(l, r,  0);\n\n      /* Put l,r into outblock */\n      WRITE_UINT32(dst, l);\n      WRITE_UINT32(dst + 4, r);\n    }\n}",
      "lines": 39,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cast5_set_key": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        280,
        1
      ],
      "content": "void\ncast5_set_key(struct cast128_ctx *ctx,\n\t      size_t length, const uint8_t *key)\n{\n  uint32_t x0, x1, x2, x3, z0, z1, z2, z3;\n  uint32_t w;\n  int full;\n\n  assert (length >= CAST5_MIN_KEY_SIZE);\n  assert (length <= CAST5_MAX_KEY_SIZE);\n\n  full = (length > CAST_SMALL_KEY);\n\n  x0 = READ_UINT32 (key);\n\n  /* Read final word, possibly zero-padded. */\n  switch (length & 3)\n    {\n    case 0:\n      w = READ_UINT32 (key + length - 4);\n      break;\n    case 3:\n      w = READ_UINT24 (key + length - 3) << 8;\n      break;\n    case 2:\n      w = READ_UINT16 (key + length - 2) << 16;\n      break;\n    case 1:\n      w = (uint32_t) key[length - 1] << 24;\n      break;\n    }\n\n  if (length <= 8)\n    {\n      x1 = w;\n      x2 = x3 = 0;\n    }\n  else\n    {\n      x1 = READ_UINT32 (key + 4);\n      if (length <= 12)\n\t{\n\t  x2 = w;\n\t  x3 = 0;\n\t}\n      else\n\t{\n\t  x2 = READ_UINT32 (key + 8);\n\t  x3 = w;\n\t}\n    }\n\n  EXPAND(SET_KM, full);\n  EXPAND(SET_KR, full);\n\n  ctx->rounds = full ? 16 : 12;\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "cast128_set_key": {
      "start_point": [
        282,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "void\ncast128_set_key(struct cast128_ctx *ctx, const uint8_t *key)\n{\n  cast5_set_key (ctx, CAST128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/cast128.h": {},
  "nettle/nettle-3.4.1/cast128_sboxes.h": {},
  "nettle/nettle-3.4.1/cbc.c": {
    "cbc_encrypt": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ncbc_encrypt(const void *ctx, nettle_cipher_func *f,\n\t    size_t block_size, uint8_t *iv,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % block_size));\n\n  for ( ; length; length -= block_size, src += block_size, dst += block_size)\n    {\n      memxor(iv, src, block_size);\n      f(ctx, block_size, dst, iv);\n      memcpy(iv, dst, block_size);\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "cbc_decrypt": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\ncbc_decrypt(const void *ctx, nettle_cipher_func *f,\n\t    size_t block_size, uint8_t *iv,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % block_size));\n\n  if (!length)\n    return;\n\n  if (src != dst)\n    {\n      /* Decrypt in ECB mode */\n      f(ctx, length, dst, src);\n\n      /* XOR the cryptotext, shifted one block */\n      memxor(dst, iv, block_size);\n      memxor(dst + block_size, src, length - block_size);\n      memcpy(iv, src + length - block_size, block_size);\n    }\n\n  else\n    {\n      /* For in-place CBC, we decrypt into a temporary buffer of size\n       * at most CBC_BUFFER_LIMIT, and process that amount of data at\n       * a time. */\n      \n      /* NOTE: We assume that block_size <= CBC_BUFFER_LIMIT, and we\n\t depend on memxor3 working from the end of the area, allowing\n\t certain overlapping operands. */ \n\n      TMP_DECL(buffer, uint8_t, CBC_BUFFER_LIMIT);\n      TMP_DECL(initial_iv, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\n      size_t buffer_size;\n\n      if (length <= CBC_BUFFER_LIMIT)\n\tbuffer_size = length;\n      else\n\tbuffer_size\n\t  = CBC_BUFFER_LIMIT - (CBC_BUFFER_LIMIT % block_size);\n\n      TMP_ALLOC(buffer, buffer_size);\n      TMP_ALLOC(initial_iv, block_size);\n\n      for ( ; length > buffer_size;\n\t    length -= buffer_size, src += buffer_size, dst += buffer_size)\n\t{\n\t  f(ctx, buffer_size, buffer, src);\n\t  memcpy(initial_iv, iv, block_size);\n\t  memcpy(iv, src + buffer_size - block_size, block_size);\n\t  memxor3(dst + block_size, buffer + block_size, src,\n\t\t  buffer_size - block_size);\n\t  memxor3(dst, buffer, initial_iv, block_size);\n\t}\n\n      f(ctx, length, buffer, src);\n      memcpy(initial_iv, iv, block_size);\n      /* Copies last block */\n      memcpy(iv, src + length - block_size, block_size);\n      /* Writes all but first block, reads all but last block. */\n      memxor3(dst + block_size, buffer + block_size, src,\n\t      length - block_size);\n      /* Writes first block. */\n      memxor3(dst, buffer, initial_iv, block_size);\n    }\n}",
      "lines": 68,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "foo": {
      "start_point": [
        138,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static void foo(void)\n{\n  struct CBC_CTX(struct twofish_ctx, TWOFISH_BLOCK_SIZE) ctx;\n  uint8_t src[TWOFISH_BLOCK_SIZE];\n  uint8_t dst[TWOFISH_BLOCK_SIZE];\n  \n  CBC_ENCRYPT(&ctx, twofish_encrypt, TWOFISH_BLOCK_SIZE, dst, src);\n\n  /* Should result in a warning */\n  CBC_ENCRYPT(&ctx, aes_encrypt, TWOFISH_BLOCK_SIZE, dst, src);\n  \n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "foo2": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void foo2(void)\n{\n  struct twofish_ctx ctx;\n  uint8_t iv[TWOFISH_BLOCK_SIZE];\n  uint8_t src[TWOFISH_BLOCK_SIZE];\n  uint8_t dst[TWOFISH_BLOCK_SIZE];\n  \n  CBC_ENCRYPT2(&ctx, twofish_encrypt, TWOFISH_BLOCK_SIZE, iv, TWOFISH_BLOCK_SIZE, dst, src);\n  /* Should result in a warning */\n  CBC_ENCRYPT2(&ctx, aes_encrypt, TWOFISH_BLOCK_SIZE, iv, TWOFISH_BLOCK_SIZE, dst, src);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/cbc.h": {},
  "nettle/nettle-3.4.1/ccm-aes128.c": {
    "ccm_aes128_set_key": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nccm_aes128_set_key(struct ccm_aes128_ctx *ctx, const uint8_t *key)\n{\n  aes128_set_encrypt_key(&ctx->cipher, key);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_set_nonce": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nccm_aes128_set_nonce(struct ccm_aes128_ctx *ctx,\n\t\t     size_t length, const uint8_t *nonce,\n\t\t     size_t authlen, size_t msglen, size_t taglen)\n{\n  ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t\tlength, nonce, authlen, msglen, taglen);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_update": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nccm_aes128_update(struct ccm_aes128_ctx *ctx,\n\t\t  size_t length, const uint8_t *data)\n{\n  ccm_update(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t     length, data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_encrypt": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nccm_aes128_encrypt(struct ccm_aes128_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_decrypt": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nccm_aes128_decrypt(struct ccm_aes128_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_decrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_digest": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nccm_aes128_digest(struct ccm_aes128_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  ccm_digest(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t     length, digest);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_encrypt_message": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nccm_aes128_encrypt_message(struct ccm_aes128_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t clength, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt_message(&ctx->cipher, (nettle_cipher_func *) aes128_encrypt,\n\t\t      nlength, nonce, alength, adata,\n\t\t      tlength, clength, dst, src);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes128_decrypt_message": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nccm_aes128_decrypt_message(struct ccm_aes128_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t mlength, uint8_t *dst, const uint8_t *src)\n{\n  return ccm_decrypt_message(&ctx->cipher,\n\t\t\t     (nettle_cipher_func *) aes128_encrypt,\n\t\t\t     nlength, nonce, alength, adata,\n\t\t\t     tlength, mlength, dst, src);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ccm-aes192.c": {
    "ccm_aes192_set_key": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nccm_aes192_set_key(struct ccm_aes192_ctx *ctx, const uint8_t *key)\n{\n  aes192_set_encrypt_key(&ctx->cipher, key);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_set_nonce": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nccm_aes192_set_nonce(struct ccm_aes192_ctx *ctx, size_t length, const uint8_t *nonce,\n\t\t     size_t authlen, size_t msglen, size_t taglen)\n{\n  ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t\tlength, nonce, authlen, msglen, taglen);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_update": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nccm_aes192_update(struct ccm_aes192_ctx *ctx,\n\t\t  size_t length, const uint8_t *data)\n{\n  ccm_update(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t     length, data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_encrypt": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\nccm_aes192_encrypt(struct ccm_aes192_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_decrypt": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nccm_aes192_decrypt(struct ccm_aes192_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_decrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_digest": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nccm_aes192_digest(struct ccm_aes192_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  ccm_digest(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t     length, digest);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_encrypt_message": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nccm_aes192_encrypt_message(struct ccm_aes192_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t clength, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt_message(&ctx->cipher, (nettle_cipher_func *) aes192_encrypt,\n\t\t      nlength, nonce, alength, adata,\n\t\t      tlength, clength, dst, src);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes192_decrypt_message": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nccm_aes192_decrypt_message(struct ccm_aes192_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t mlength, uint8_t *dst, const uint8_t *src)\n{\n  return ccm_decrypt_message(&ctx->cipher,\n\t\t\t     (nettle_cipher_func *) aes192_encrypt,\n\t\t\t     nlength, nonce, alength, adata,\n\t\t\t     tlength, mlength, dst, src);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ccm-aes256.c": {
    "ccm_aes256_set_key": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nccm_aes256_set_key(struct ccm_aes256_ctx *ctx, const uint8_t *key)\n{\n  aes256_set_encrypt_key(&ctx->cipher, key);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_set_nonce": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nccm_aes256_set_nonce(struct ccm_aes256_ctx *ctx,\n\t\t     size_t length, const uint8_t *nonce,\n\t\t     size_t authlen, size_t msglen, size_t taglen)\n{\n  ccm_set_nonce(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t\tlength, nonce, authlen, msglen, taglen);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_update": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\nccm_aes256_update(struct ccm_aes256_ctx *ctx,\n\t\t  size_t length, const uint8_t *data)\n{\n  ccm_update(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t     length, data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_encrypt": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nccm_aes256_encrypt(struct ccm_aes256_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_decrypt": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nccm_aes256_decrypt(struct ccm_aes256_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_decrypt(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t      length, dst, src);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_digest": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\nccm_aes256_digest(struct ccm_aes256_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  ccm_digest(&ctx->ccm, &ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t     length, digest);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_encrypt_message": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nccm_aes256_encrypt_message(struct ccm_aes256_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t clength, uint8_t *dst, const uint8_t *src)\n{\n  ccm_encrypt_message(&ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t\t      nlength, nonce, alength, adata,\n\t\t      tlength, clength, dst, src);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ccm_aes256_decrypt_message": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "int\nccm_aes256_decrypt_message(struct ccm_aes256_ctx *ctx,\n\t\t\t   size_t nlength, const uint8_t *nonce,\n\t\t\t   size_t alength, const uint8_t *adata,\n\t\t\t   size_t tlength,\n\t\t\t   size_t mlength, uint8_t *dst, const uint8_t *src)\n{\n  return ccm_decrypt_message(&ctx->cipher, (nettle_cipher_func *) aes256_encrypt,\n\t\t\t     nlength, nonce, alength, adata,\n\t\t\t     tlength, mlength, dst, src);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ccm.c": {
    "ccm_pad": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "static void\nccm_pad(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f)\n{\n    if (ctx->blength) f(cipher, CCM_BLOCK_SIZE, ctx->tag.b, ctx->tag.b);\n    ctx->blength = 0;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ccm_build_iv": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static void\nccm_build_iv(uint8_t *iv, size_t noncelen, const uint8_t *nonce,\n\t     uint8_t flags, size_t count)\n{\n  unsigned int i;\n\n  /* Sanity check the nonce length. */\n  assert(noncelen >= CCM_MIN_NONCE_SIZE);\n  assert(noncelen <= CCM_MAX_NONCE_SIZE);\n\n  /* Generate the IV */\n  iv[CCM_OFFSET_FLAGS] = flags | CCM_FLAG_SET_L(CCM_L_SIZE(noncelen));\n  memcpy(&iv[CCM_OFFSET_NONCE], nonce, noncelen);\n  for (i=(CCM_BLOCK_SIZE - 1); i >= (CCM_OFFSET_NONCE + noncelen); i--) {\n    iv[i] = count & 0xff;\n    count >>= 8;\n  }\n\n  /* Ensure the count was not truncated. */\n  assert(!count);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ccm_set_nonce": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\nccm_set_nonce(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t      size_t length, const uint8_t *nonce,\n\t      size_t authlen, size_t msglen, size_t taglen)\n{\n  /* Generate the IV for the CTR and CBC-MAC */\n  ctx->blength = 0;\n  ccm_build_iv(ctx->tag.b, length, nonce, CCM_FLAG_SET_M(taglen), msglen);\n  ccm_build_iv(ctx->ctr.b, length, nonce, 0, 1);\n\n  /* If no auth data, encrypt B0 and skip L(a) */\n  if (!authlen) {\n    f(cipher, CCM_BLOCK_SIZE, ctx->tag.b, ctx->tag.b);\n    return;\n  }\n\n  /* Encrypt B0 (with the adata flag), and input L(a) to the CBC-MAC. */\n  ctx->tag.b[CCM_OFFSET_FLAGS] |= CCM_FLAG_ADATA;\n  f(cipher, CCM_BLOCK_SIZE, ctx->tag.b, ctx->tag.b);\n#if SIZEOF_SIZE_T > 4\n  if (authlen >= (0x01ULL << 32)) {\n    /* Encode L(a) as 0xff || 0xff || <64-bit integer> */\n    ctx->tag.b[ctx->blength++] ^= 0xff;\n    ctx->tag.b[ctx->blength++] ^= 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 56) & 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 48) & 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 40) & 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 32) & 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 24) & 0xff;\n    ctx->tag.b[ctx->blength++] ^= (authlen >> 16) & 0xff;\n  }\n  else\n#endif\n    if (authlen >= ((0x1ULL << 16) - (0x1ULL << 8))) {\n      /* Encode L(a) as 0xff || 0xfe || <32-bit integer> */\n      ctx->tag.b[ctx->blength++] ^= 0xff;\n      ctx->tag.b[ctx->blength++] ^= 0xfe;\n      ctx->tag.b[ctx->blength++] ^= (authlen >> 24) & 0xff;\n      ctx->tag.b[ctx->blength++] ^= (authlen >> 16) & 0xff;\n    }\n  ctx->tag.b[ctx->blength++] ^= (authlen >> 8) & 0xff;\n  ctx->tag.b[ctx->blength++] ^= (authlen >> 0) & 0xff;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ccm_update": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\nccm_update(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t   size_t length, const uint8_t *data)\n{\n  const uint8_t *end = data + length;\n\n  /* If we don't have enough to fill a block, save the data for later. */\n  if ((ctx->blength + length) < CCM_BLOCK_SIZE) {\n    memxor(&ctx->tag.b[ctx->blength], data, length);\n    ctx->blength += length;\n    return;\n  }\n\n  /* Process a partially filled block. */\n  if (ctx->blength) {\n    memxor(&ctx->tag.b[ctx->blength], data, CCM_BLOCK_SIZE - ctx->blength);\n    data += (CCM_BLOCK_SIZE - ctx->blength);\n    f(cipher, CCM_BLOCK_SIZE, ctx->tag.b, ctx->tag.b);\n  }\n\n  /* Process full blocks. */\n  while ((data + CCM_BLOCK_SIZE) < end) {\n    memxor(ctx->tag.b, data, CCM_BLOCK_SIZE);\n    f(cipher, CCM_BLOCK_SIZE, ctx->tag.b, ctx->tag.b);\n    data += CCM_BLOCK_SIZE;\n  } /* while */\n\n  /* Save leftovers for later. */\n  ctx->blength = (end - data);\n  if (ctx->blength) memxor(&ctx->tag.b, data, ctx->blength);\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "ccm_encrypt": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "void\nccm_encrypt(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t    size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ccm_pad(ctx, cipher, f);\n  ccm_update(ctx, cipher, f, length, src);\n  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx->ctr.b, length, dst, src);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_decrypt": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "void\nccm_decrypt(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t    size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx->ctr.b, length, dst, src);\n  ccm_pad(ctx, cipher, f);\n  ccm_update(ctx, cipher, f, length, dst);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_digest": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        231,
        1
      ],
      "content": "void\nccm_digest(struct ccm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t   size_t length, uint8_t *digest)\n{\n  int i = CCM_BLOCK_SIZE - CCM_FLAG_GET_L(ctx->ctr.b[CCM_OFFSET_FLAGS]);\n  assert(length <= CCM_BLOCK_SIZE);\n  while (i < CCM_BLOCK_SIZE)  ctx->ctr.b[i++] = 0;\n  ccm_pad(ctx, cipher, f);\n  ctr_crypt(cipher, f, CCM_BLOCK_SIZE, ctx->ctr.b, length, digest, ctx->tag.b);\n}",
      "lines": 10,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ccm_encrypt_message": {
      "start_point": [
        233,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\nccm_encrypt_message(const void *cipher, nettle_cipher_func *f,\n\t\t    size_t nlength, const uint8_t *nonce,\n\t\t    size_t alength, const uint8_t *adata, size_t tlength,\n\t\t    size_t clength, uint8_t *dst, const uint8_t *src)\n{\n  struct ccm_ctx ctx;\n  uint8_t *tag = dst + (clength-tlength);\n  assert(clength >= tlength);\n  ccm_set_nonce(&ctx, cipher, f, nlength, nonce, alength, clength-tlength, tlength);\n  ccm_update(&ctx, cipher, f, alength, adata);\n  ccm_encrypt(&ctx, cipher, f, clength-tlength, dst, src);\n  ccm_digest(&ctx, cipher, f, tlength, tag);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ccm_decrypt_message": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\nccm_decrypt_message(const void *cipher, nettle_cipher_func *f,\n\t\t    size_t nlength, const uint8_t *nonce,\n\t\t    size_t alength, const uint8_t *adata, size_t tlength,\n\t\t    size_t mlength, uint8_t *dst, const uint8_t *src)\n{\n  struct ccm_ctx ctx;\n  uint8_t tag[CCM_BLOCK_SIZE];\n  ccm_set_nonce(&ctx, cipher, f, nlength, nonce, alength, mlength, tlength);\n  ccm_update(&ctx, cipher, f, alength, adata);\n  ccm_decrypt(&ctx, cipher, f, mlength, dst, src);\n  ccm_digest(&ctx, cipher, f, tlength, tag);\n  return memeql_sec(tag, src + mlength, tlength);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ccm.h": {},
  "nettle/nettle-3.4.1/cfb.c": {
    "cfb_encrypt": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\ncfb_encrypt(const void *ctx, nettle_cipher_func *f,\n\t    size_t block_size, uint8_t *iv,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  uint8_t *p;\n  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\n  TMP_ALLOC(buffer, block_size);\n\n  if (src != dst)\n    {\n      for (p = iv; length >= block_size; p = dst, dst += block_size, src += block_size, length -= block_size)\n\t{\n\t  f(ctx, block_size, dst, p);\n\t  memxor(dst, src, block_size);\n\t}\n    }\n  else\n    {\n      for (p = iv; length >= block_size; p = dst, dst += block_size, src += block_size, length -= block_size)\n\t{\n\t  f(ctx, block_size, buffer, p);\n\t  memxor(dst, buffer, block_size);\n\t}\n    }\n\n  if (p != iv)\n    memcpy(iv, p, block_size);\n\n  if (length)\n    {\n      f(ctx, block_size, buffer, iv);\n      memxor3(dst, buffer, src, length);\n      /* We do not care about updating IV here. This is the last call in\n       * message sequence and one has to set IV afterwards anyway */\n    }\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "cfb_decrypt": {
      "start_point": [
        90,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ncfb_decrypt(const void *ctx, nettle_cipher_func *f,\n\t    size_t block_size, uint8_t *iv,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  if (src != dst)\n    {\n      size_t left = length % block_size;\n\n      length -= left;\n      if (length > 0)\n\t{\n\t  /* Decrypt in ECB mode */\n\t  f(ctx, block_size, dst, iv);\n\t  f(ctx, length - block_size, dst + block_size, src);\n\t  memcpy(iv, src + length - block_size, block_size);\n\t  memxor(dst, src, length);\n\t}\n\n      if (left > 0)\n\t{\n\t  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\t  TMP_ALLOC(buffer, block_size);\n\n\t  f(ctx, block_size, buffer, iv);\n\t  memxor3(dst + length, src + length, buffer, left);\n\t}\n    }\n  else\n    {\n      /* For in-place CFB, we decrypt into a temporary buffer of size\n       * at most CFB_BUFFER_LIMIT, and process that amount of data at\n       * a time. */\n\n      /* NOTE: We assume that block_size <= CFB_BUFFER_LIMIT */\n\n      TMP_DECL(buffer, uint8_t, CFB_BUFFER_LIMIT);\n      TMP_DECL(initial_iv, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\n      size_t buffer_size;\n      size_t left;\n\n      buffer_size = CFB_BUFFER_LIMIT - (CFB_BUFFER_LIMIT % block_size);\n\n      TMP_ALLOC(buffer, buffer_size);\n      TMP_ALLOC(initial_iv, block_size);\n\n      left = length % block_size;\n      length -= left;\n\n      while (length > 0)\n\t{\n\t  size_t part = length > buffer_size ? buffer_size : length;\n\n\t  /* length is greater that zero and is divided by block_size, so it is\n\t   * not less than block_size. So does part */\n\n\t  f(ctx, block_size, buffer, iv);\n\t  f(ctx, part - block_size, buffer + block_size, src);\n\t  memcpy(iv, src + part - block_size, block_size);\n\t  memxor(dst, buffer, part);\n\n\t  length -= part;\n\t  src += part;\n\t  dst += part;\n\t}\n\n      if (left > 0)\n\t{\n\t  f(ctx, block_size, buffer, iv);\n\t  memxor(dst, buffer, left);\n\t}\n    }\n}",
      "lines": 75,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/cfb.h": {},
  "nettle/nettle-3.4.1/chacha-core-internal.c": {
    "_chacha_core": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\n_chacha_core(uint32_t *dst, const uint32_t *src, unsigned rounds)\n{\n  uint32_t x[_CHACHA_STATE_LENGTH];\n  unsigned i;\n\n  assert ( (rounds & 1) == 0);\n\n  memcpy (x, src, sizeof(x));\n  for (i = 0; i < rounds;i += 2)\n    {\n      DEBUG (i);\n      QROUND(x[0], x[4], x[8],  x[12]);\n      QROUND(x[1], x[5], x[9],  x[13]);\n      QROUND(x[2], x[6], x[10], x[14]);\n      QROUND(x[3], x[7], x[11], x[15]);\n\n      DEBUG (i+1);\n      QROUND(x[0], x[5], x[10], x[15]);\n      QROUND(x[1], x[6], x[11], x[12]);\n      QROUND(x[2], x[7], x[8],  x[13]);\n      QROUND(x[3], x[4], x[9],  x[14]);\n    }\n  DEBUG (i);\n\n  for (i = 0; i < _CHACHA_STATE_LENGTH; i++)\n    {\n      uint32_t t = x[i] + src[i];\n      dst[i] = LE_SWAP32 (t);\n    }\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/chacha-crypt.c": {
    "chacha_crypt": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\nchacha_crypt(struct chacha_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *c,\n\t      const uint8_t *m)\n{\n  if (!length)\n    return;\n  \n  for (;;)\n    {\n      uint32_t x[_CHACHA_STATE_LENGTH];\n\n      _chacha_core (x, ctx->state, CHACHA_ROUNDS);\n\n      ctx->state[13] += (++ctx->state[12] == 0);\n\n      /* stopping at 2^70 length per nonce is user's responsibility */\n      \n      if (length <= CHACHA_BLOCK_SIZE)\n\t{\n\t  memxor3 (c, m, x, length);\n\t  return;\n\t}\n      memxor3 (c, m, x, CHACHA_BLOCK_SIZE);\n\n      length -= CHACHA_BLOCK_SIZE;\n      c += CHACHA_BLOCK_SIZE;\n      m += CHACHA_BLOCK_SIZE;\n  }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/chacha-poly1305-meta.c": {},
  "nettle/nettle-3.4.1/chacha-poly1305.c": {
    "chacha_poly1305_set_key": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nchacha_poly1305_set_key (struct chacha_poly1305_ctx *ctx,\n\t\t\t const uint8_t *key)\n{\n  chacha_set_key (&ctx->chacha, key);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "chacha_poly1305_set_nonce": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\nchacha_poly1305_set_nonce (struct chacha_poly1305_ctx *ctx,\n\t\t\t   const uint8_t *nonce)\n{\n  union {\n    uint32_t x[_CHACHA_STATE_LENGTH];\n    uint8_t subkey[32];\n  } u;\n\n  chacha_set_nonce96 (&ctx->chacha, nonce);\n  /* Generate authentication key */\n  _chacha_core (u.x, ctx->chacha.state, CHACHA_ROUNDS);\n  poly1305_set_key (&ctx->poly1305, u.subkey);  \n  /* For final poly1305 processing */\n  memcpy (ctx->s.b, u.subkey + 16, 16);\n  /* Increment block count */\n  ctx->chacha.state[12] = 1;\n\n  ctx->auth_size = ctx->data_size = ctx->index = 0;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "poly1305_update": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\npoly1305_update (struct chacha_poly1305_ctx *ctx,\n\t\t size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, COMPRESS, (void) 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "poly1305_pad": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static void\npoly1305_pad (struct chacha_poly1305_ctx *ctx)\n{\n  if (ctx->index)\n    {\n      memset (ctx->block + ctx->index, 0,\n\t      POLY1305_BLOCK_SIZE - ctx->index);\n      _poly1305_block(&ctx->poly1305, ctx->block, 1);\n      ctx->index = 0;\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "chacha_poly1305_update": {
      "start_point": [
        111,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\nchacha_poly1305_update (struct chacha_poly1305_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *data)\n{\n  assert (ctx->data_size == 0);  \n  poly1305_update (ctx, length, data);\n  ctx->auth_size += length;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "chacha_poly1305_encrypt": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "void\nchacha_poly1305_encrypt (struct chacha_poly1305_ctx *ctx,\n\t\t\t size_t length, uint8_t *dst, const uint8_t *src)\n{\n  if (!length)\n    return;\n\n  assert (ctx->data_size % CHACHA_POLY1305_BLOCK_SIZE == 0);\n  poly1305_pad (ctx);\n\n  chacha_crypt (&ctx->chacha, length, dst, src);\n  poly1305_update (ctx, length, dst);\n  ctx->data_size += length;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "chacha_poly1305_decrypt": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\nchacha_poly1305_decrypt (struct chacha_poly1305_ctx *ctx,\n\t\t\t size_t length, uint8_t *dst, const uint8_t *src)\n{\n  if (!length)\n    return;\n\n  assert (ctx->data_size % CHACHA_POLY1305_BLOCK_SIZE == 0);\n  poly1305_pad (ctx);\n\n  poly1305_update (ctx, length, src);\n  chacha_crypt (&ctx->chacha, length, dst, src);\n  ctx->data_size += length;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "chacha_poly1305_digest": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\nchacha_poly1305_digest (struct chacha_poly1305_ctx *ctx,\n\t\t\tsize_t length, uint8_t *digest)\n{\n  uint8_t buf[16];\n\n  poly1305_pad (ctx);\n  LE_WRITE_UINT64 (buf, ctx->auth_size);\n  LE_WRITE_UINT64 (buf + 8, ctx->data_size);\n\n  _poly1305_block (&ctx->poly1305, buf, 1);\n\n  poly1305_digest (&ctx->poly1305, &ctx->s);\n  memcpy (digest, &ctx->s.b, length);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/chacha-poly1305.h": {},
  "nettle/nettle-3.4.1/chacha-set-key.c": {
    "chacha_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nchacha_set_key(struct chacha_ctx *ctx, const uint8_t *key)\n{\n  static const uint32_t sigma[4] = {\n    /* \"expand 32-byte k\" */\n    0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n  };\n  ctx->state[4] = LE_READ_UINT32(key + 0);\n  ctx->state[5] = LE_READ_UINT32(key + 4);\n  ctx->state[6] = LE_READ_UINT32(key + 8);\n  ctx->state[7] = LE_READ_UINT32(key + 12);\n\n  ctx->state[8]  = LE_READ_UINT32(key + 16);\n  ctx->state[9]  = LE_READ_UINT32(key + 20);\n  ctx->state[10] = LE_READ_UINT32(key + 24);\n  ctx->state[11] = LE_READ_UINT32(key + 28);\n\n  memcpy (ctx->state, sigma, sizeof(sigma));\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/chacha-set-nonce.c": {
    "chacha_set_nonce": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\nchacha_set_nonce(struct chacha_ctx *ctx, const uint8_t *nonce)\n{\n  ctx->state[12] = 0;\n  ctx->state[13] = 0;\n  ctx->state[14] = LE_READ_UINT32(nonce + 0);\n  ctx->state[15] = LE_READ_UINT32(nonce + 4);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "chacha_set_nonce96": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\nchacha_set_nonce96(struct chacha_ctx *ctx, const uint8_t *nonce)\n{\n  ctx->state[12] = 0;\n  ctx->state[13] = LE_READ_UINT32(nonce + 0);\n  ctx->state[14] = LE_READ_UINT32(nonce + 4);\n  ctx->state[15] = LE_READ_UINT32(nonce + 8);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/chacha.h": {},
  "nettle/nettle-3.4.1/cnd-copy.c": {
    "cnd_copy": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ncnd_copy (int cnd, mp_limb_t *rp, const mp_limb_t *ap, mp_size_t n)\n{\n  mp_limb_t mask, keep;\n  mp_size_t i;\n\n  mask = -(mp_limb_t) (cnd !=0);\n  keep = ~mask;\n\n  for (i = 0; i < n; i++)\n    rp[i] = (rp[i] & keep) + (ap[i] & mask);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/cnd-memcpy.c": {
    "cnd_memcpy": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ncnd_memcpy(int cnd, volatile void *dst, const volatile void *src, size_t n)\n{\n  const volatile unsigned char *sp = src;\n  volatile unsigned char *dp = dst;\n  volatile unsigned char c;\n  volatile unsigned char m;\n  size_t i;\n\n  m = -(unsigned char) cnd;\n\n  for (i = 0; i < n; i++)\n    {\n      c = (sp[i] & m);\n      c |= (dp[i] & ~m);\n      dp[i] = c;\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ctr.c": {
    "ctr_crypt": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "void\nctr_crypt(const void *ctx, nettle_cipher_func *f,\n\t  size_t block_size, uint8_t *ctr,\n\t  size_t length, uint8_t *dst,\n\t  const uint8_t *src)\n{\n  if (src != dst)\n    {\n      if (length == block_size)\n\t{\n\t  f(ctx, block_size, dst, ctr);\n\t  INCREMENT(block_size, ctr);\n\t  memxor(dst, src, block_size);\n\t}\n      else\n\t{\n\t  size_t left;\n\t  uint8_t *p;\t  \n\n\t  for (p = dst, left = length;\n\t       left >= block_size;\n\t       left -= block_size, p += block_size)\n\t    {\n\t      memcpy (p, ctr, block_size);\n\t      INCREMENT(block_size, ctr);\n\t    }\n\n\t  f(ctx, length - left, dst, dst);\n\t  memxor(dst, src, length - left);\n\n\t  if (left)\n\t    {\n\t      TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\t      TMP_ALLOC(buffer, block_size);\n\n\t      f(ctx, block_size, buffer, ctr);\n\t      INCREMENT(block_size, ctr);\n\t      memxor3(dst + length - left, src + length - left, buffer, left);\n\t    }\n\t}\n    }\n  else\n    {\n      if (length > block_size)\n\t{\n\t  TMP_DECL(buffer, uint8_t, NBLOCKS * NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\t  size_t chunk = NBLOCKS * block_size;\n\n\t  TMP_ALLOC(buffer, chunk);\n\n\t  for (; length >= chunk;\n\t       length -= chunk, src += chunk, dst += chunk)\n\t    {\n\t      unsigned n;\n\t      uint8_t *p;\t  \n\t      for (n = 0, p = buffer; n < NBLOCKS; n++, p += block_size)\n\t\t{\n\t\t  memcpy (p, ctr, block_size);\n\t\t  INCREMENT(block_size, ctr);\n\t\t}\n\t      f(ctx, chunk, buffer, buffer);\n\t      memxor(dst, buffer, chunk);\n\t    }\n\n\t  if (length > 0)\n\t    {\n\t      /* Final, possibly partial, blocks */\n\t      for (chunk = 0; chunk < length; chunk += block_size)\n\t\t{\n\t\t  memcpy (buffer + chunk, ctr, block_size);\n\t\t  INCREMENT(block_size, ctr);\n\t\t}\n\t      f(ctx, chunk, buffer, buffer);\n\t      memxor3(dst, src, buffer, length);\n\t    }\n\t}\n      else if (length > 0)\n      \t{\n\t  TMP_DECL(buffer, uint8_t, NETTLE_MAX_CIPHER_BLOCK_SIZE);\n\t  TMP_ALLOC(buffer, block_size);\n\n\t  f(ctx, block_size, buffer, ctr);\n\t  INCREMENT(block_size, ctr);\n\t  memxor3(dst, src, buffer, length);\n\t}\n    }\n}",
      "lines": 87,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ctr.h": {},
  "nettle/nettle-3.4.1/curve25519-eh-to-x.c": {
    "curve25519_eh_to_x": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ncurve25519_eh_to_x (mp_limb_t *xp, const mp_limb_t *p,\n\t\t    mp_limb_t *scratch)\n{\n#define vp (p + ecc->p.size)\n#define wp (p + 2*ecc->p.size)\n#define t0 scratch\n#define t1 (scratch + ecc->p.size)\n#define t2 (scratch + 2*ecc->p.size)\n\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  mp_limb_t cy;\n\n  /* If u = U/W and v = V/W are the coordiantes of the point on the\n     Edwards curve we get the curve25519 x coordinate as\n\n     x = (1+v) / (1-v) = (W + V) / (W - V)\n  */\n  /* NOTE: For the infinity point, this subtraction gives zero (mod\n     p), which isn't invertible. For curve25519, the desired output is\n     x = 0, and we should be fine, since ecc_modp_inv returns 0\n     in this case. */\n  ecc_modp_sub (ecc, t0, wp, vp);\n  /* Needs a total of 5*size storage. */\n  ecc->p.invert (&ecc->p, t1, t0, t2 + ecc->p.size);\n  \n  ecc_modp_add (ecc, t0, wp, vp);\n  ecc_modp_mul (ecc, t2, t0, t1);\n\n  cy = mpn_sub_n (xp, t2, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, xp, t2, ecc->p.size);\n#undef vp\n#undef wp\n#undef t0\n#undef t1\n#undef t2\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/curve25519-mul-g.c": {
    "curve25519_mul_g": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\ncurve25519_mul_g (uint8_t *r, const uint8_t *n)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  uint8_t t[CURVE25519_SIZE];\n  mp_limb_t *scratch;\n  mp_size_t itch;\n\n#define ng scratch\n#define x (scratch + 3*ecc->p.size)\n#define scratch_out (scratch + 4*ecc->p.size)\n  \n  memcpy (t, n, sizeof(t));\n  t[0] &= ~7;\n  t[CURVE25519_SIZE-1] = (t[CURVE25519_SIZE-1] & 0x3f) | 0x40;\n\n  itch = 4*ecc->p.size + ecc->mul_g_itch;\n  scratch = gmp_alloc_limbs (itch);\n\n  mpn_set_base256_le (x, ecc->p.size, t, CURVE25519_SIZE);\n\n  ecc_mul_g_eh (ecc, ng, x, scratch_out);\n  curve25519_eh_to_x (x, ng, scratch_out);\n\n  mpn_get_base256_le (r, CURVE25519_SIZE, x, ecc->p.size);\n  gmp_free_limbs (scratch, itch);\n#undef p\n#undef x\n#undef scratch_out\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/curve25519-mul.c": {
    "curve25519_mul": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\ncurve25519_mul (uint8_t *q, const uint8_t *n, const uint8_t *p)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  mp_size_t itch;\n  mp_limb_t *scratch;\n  int i;\n  mp_limb_t cy;\n\n  /* FIXME: Could save some more scratch space, e.g., by letting BB\n     overlap C, D, and CB overlap A, D. And possibly reusing some of\n     x2, z2, x3, z3. */\n#define x1 scratch\n#define x2 (scratch + ecc->p.size)\n#define z2 (scratch + 2*ecc->p.size)\n#define x3 (scratch + 3*ecc->p.size)\n#define z3 (scratch + 4*ecc->p.size)\n\n#define A  (scratch + 5*ecc->p.size)\n#define B  (scratch + 6*ecc->p.size)\n#define C  (scratch + 7*ecc->p.size)\n#define D  (scratch + 8*ecc->p.size)\n#define AA  (scratch + 9*ecc->p.size)\n#define BB  (scratch +10*ecc->p.size)\n#define E  (scratch + 10*ecc->p.size) /* Overlap BB */\n#define DA  (scratch + 9*ecc->p.size) /* Overlap AA */\n#define CB  (scratch + 10*ecc->p.size) /* Overlap BB */\n\n  itch = ecc->p.size * 12;\n  scratch = gmp_alloc_limbs (itch);\n\n  /* Note that 255 % GMP_NUMB_BITS == 0 isn't supported, so x1 always\n     holds at least 256 bits. */\n  mpn_set_base256_le (x1, ecc->p.size, p, CURVE25519_SIZE);\n  /* Clear bit 255, as required by RFC 7748. */\n  x1[255/GMP_NUMB_BITS] &= ~((mp_limb_t) 1 << (255 % GMP_NUMB_BITS));\n\n  /* Initialize, x2 = x1, z2 = 1 */\n  mpn_copyi (x2, x1, ecc->p.size);\n  z2[0] = 1;\n  mpn_zero (z2+1, ecc->p.size - 1);\n\n  /* Get x3, z3 from doubling. Since bit 254 is forced to 1. */\n  ecc_modp_add (ecc, A, x2, z2);\n  ecc_modp_sub (ecc, B, x2, z2);\n  ecc_modp_sqr (ecc, AA, A);\n  ecc_modp_sqr (ecc, BB, B);\n  ecc_modp_mul (ecc, x3, AA, BB);\n  ecc_modp_sub (ecc, E, AA, BB);\n  ecc_modp_addmul_1 (ecc, AA, E, 121665);\n  ecc_modp_mul (ecc, z3, E, AA);      \n\n  for (i = 253; i >= 3; i--)\n    {\n      int bit = (n[i/8] >> (i & 7)) & 1;\n\n      cnd_swap (bit, x2, x3, 2*ecc->p.size);\n\n      /* Formulas from draft-turner-thecurve25519function-00-Mont. We\n\t compute new coordinates in memory-address order, since mul\n\t and sqr clobbers higher limbs. */\n      ecc_modp_add (ecc, A, x2, z2);\n      ecc_modp_sub (ecc, B, x2, z2);\n      ecc_modp_sqr (ecc, AA, A);\n      ecc_modp_sqr (ecc, BB, B);\n      ecc_modp_mul (ecc, x2, AA, BB); /* Last use of BB */\n      ecc_modp_sub (ecc, E, AA, BB);\n      ecc_modp_addmul_1 (ecc, AA, E, 121665);\n      ecc_modp_add (ecc, C, x3, z3);\n      ecc_modp_sub (ecc, D, x3, z3);\n      ecc_modp_mul (ecc, z2, E, AA); /* Last use of E and AA */\n      ecc_modp_mul (ecc, DA, D, A);  /* Last use of D, A. FIXME: could\n\t\t\t\t\tlet CB overlap. */\n      ecc_modp_mul (ecc, CB, C, B);\n\n      ecc_modp_add (ecc, C, DA, CB);\n      ecc_modp_sqr (ecc, x3, C);\n      ecc_modp_sub (ecc, C, DA, CB);\n      ecc_modp_sqr (ecc, DA, C);\n      ecc_modp_mul (ecc, z3, DA, x1);\n\n      /* FIXME: Could be combined with the loop's initial cnd_swap. */\n      cnd_swap (bit, x2, x3, 2*ecc->p.size);\n    }\n  /* Do the 3 low zero bits, just duplicating x2 */\n  for ( ; i >= 0; i--)\n    {\n      ecc_modp_add (ecc, A, x2, z2);\n      ecc_modp_sub (ecc, B, x2, z2);\n      ecc_modp_sqr (ecc, AA, A);\n      ecc_modp_sqr (ecc, BB, B);\n      ecc_modp_mul (ecc, x2, AA, BB);\n      ecc_modp_sub (ecc, E, AA, BB);\n      ecc_modp_addmul_1 (ecc, AA, E, 121665);\n      ecc_modp_mul (ecc, z2, E, AA);      \n    }\n  ecc->p.invert (&ecc->p, x3, z2, z3 + ecc->p.size);\n  ecc_modp_mul (ecc, z3, x2, x3);\n  cy = mpn_sub_n (x2, z3, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, x2, z3, ecc->p.size);\n  mpn_get_base256_le (q, CURVE25519_SIZE, x2, ecc->p.size);\n\n  gmp_free_limbs (scratch, itch);\n}",
      "lines": 104,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/curve25519.h": {},
  "nettle/nettle-3.4.1/der-iterator.c": {
    "asn1_der_iterator_init": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\nasn1_der_iterator_init(struct asn1_der_iterator *iterator,\n\t\t       size_t length, const uint8_t *input)\n{\n  iterator->buffer_length = length;\n  iterator->buffer = input;\n  iterator->pos = 0;\n  iterator->type = 0;\n  iterator->length = 0;\n  iterator->data = NULL;\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "asn1_der_iterator_next": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_iterator_next(struct asn1_der_iterator *i)\n{\n  uint8_t tag;\n  \n  if (!LEFT(i))\n    return ASN1_ITERATOR_END;\n\n  tag = NEXT(i);\n  if (!LEFT(i))\n    return ASN1_ITERATOR_ERROR;\n\n  if ( (tag & TAG_MASK) == TAG_MASK)\n    {\n      /* FIXME: Long tags not supported */\n      return ASN1_ITERATOR_ERROR;\n    }\n\n  i->length = NEXT(i);\n  if (i->length & 0x80)\n    {\n      unsigned k = i->length & 0x7f;\n      unsigned j;\n      const uint8_t *data = i->buffer + i->pos;\n      \n      if (k == 0)\n\t/* Indefinite encoding. Not supported. */\n\treturn ASN1_ITERATOR_ERROR;\n\n      if (LEFT(i) < k)\n\treturn ASN1_ITERATOR_ERROR;\n\n      if (k > sizeof(i->length))\n\treturn ASN1_ITERATOR_ERROR;\n\n      i->pos += k;\n      i->length = data[0];\n      if (i->length == 0\n\t  || (k == 1 && i->length < 0x80))\n\treturn ASN1_ITERATOR_ERROR;\n\n      for (j = 1; j < k; j++)\n\ti->length = (i->length << 8) | data[j];\n    }\n  if (LEFT(i) < i->length)\n    return ASN1_ITERATOR_ERROR;\n\n  i->data = i->buffer + i->pos;\n  i->pos += i->length;\n\n  i->type = tag & TAG_MASK;\n  i->type |= (tag & CLASS_MASK) << (ASN1_CLASS_SHIFT - 6);\n  if (tag & CONSTRUCTED_MASK)\n    {\n      i->type |= ASN1_TYPE_CONSTRUCTED;\n      return ASN1_ITERATOR_CONSTRUCTED;\n    }\n  else\n    return ASN1_ITERATOR_PRIMITIVE;\n}",
      "lines": 60,
      "depth": 12,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_iterator_first": {
      "start_point": [
        170,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_iterator_first(struct asn1_der_iterator *i,\n\t\t\tsize_t length, const uint8_t *input)\n{\n  asn1_der_iterator_init(i, length, input);\n  return asn1_der_iterator_next(i);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_decode_constructed": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_decode_constructed(struct asn1_der_iterator *i,\n\t\t\t    struct asn1_der_iterator *contents)\n{\n  assert(i->type & ASN1_TYPE_CONSTRUCTED);\n  return asn1_der_iterator_first(contents, i->length, i->data);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_decode_constructed_last": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_decode_constructed_last(struct asn1_der_iterator *i)\n{\n  if (LEFT(i) > 0)\n    return ASN1_ITERATOR_ERROR;\n\n  return asn1_der_decode_constructed(i, i);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_decode_bitstring": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_decode_bitstring(struct asn1_der_iterator *i,\n\t\t\t  struct asn1_der_iterator *contents)\n{\n  assert(i->type == ASN1_BITSTRING);\n  /* First byte is the number of padding bits, which must be zero. */\n  if (i->length == 0  || i->data[0] != 0)\n    return ASN1_ITERATOR_ERROR;\n\n  return asn1_der_iterator_first(contents, i->length - 1, i->data + 1);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_decode_bitstring_last": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        215,
        1
      ],
      "content": "enum asn1_iterator_result\nasn1_der_decode_bitstring_last(struct asn1_der_iterator *i)\n{\n  if (LEFT(i) > 0)\n    return ASN1_ITERATOR_ERROR;\n\n  return asn1_der_decode_bitstring(i, i);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "enum asn1_iterator_result",
        "enum",
        "asn1_iterator_result"
      ]
    },
    "asn1_der_get_uint32": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "int\nasn1_der_get_uint32(struct asn1_der_iterator *i,\n\t\t    uint32_t *x)\n{\n  /* Big endian, two's complement, minimum number of octets (except 0,\n     which is encoded as a single octet */\n  uint32_t value = 0;\n  size_t length = i->length;\n  unsigned k;\n\n  if (!length || length > 5)\n    return 0;\n\n  if (i->data[length - 1] >= 0x80)\n    /* Signed number */\n    return 0;\n\n  if (length > 1\n      && i->data[length -1] == 0\n      && i->data[length -2] < 0x80)\n    /* Non-minimal number of digits */\n    return 0;\n\n  if (length == 5)\n    {\n      if (i->data[4])\n\treturn 0;\n      length--;\n    }\n\n  for (value = k = 0; k < length; k++)\n    value = (value << 8) | i->data[k];\n\n  *x = value;\n  return 1;\n}",
      "lines": 36,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "asn1_der_get_bignum": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        278,
        1
      ],
      "content": "int\nasn1_der_get_bignum(struct asn1_der_iterator *i,\n\t\t    mpz_t x, unsigned max_bits)\n{\n  if (i->length > 1\n      && ((i->data[0] == 0 && i->data[1] < 0x80)\n\t  || (i->data[0] == 0xff && i->data[1] >= 0x80)))\n    /* Non-minimal number of digits */\n    return 0;\n\n  /* Allow some extra here, for leading sign octets. */\n  if (max_bits && (8 * i->length > (16 + max_bits)))\n    return 0;\n\n  nettle_mpz_set_str_256_s(x, i->length, i->data);\n\n  /* FIXME: How to interpret a max_bits for negative numbers? */\n  if (max_bits && mpz_sizeinbase(x, 2) > max_bits)\n    return 0;\n\n  return 1;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/der2dsa.c": {
    "dsa_params_from_der_iterator": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "int\ndsa_params_from_der_iterator(struct dsa_params *params,\n\t\t\t     unsigned max_bits, unsigned q_bits,\n\t\t\t     struct asn1_der_iterator *i)\n{\n  /* Dss-Parms ::= SEQUENCE {\n\t p  INTEGER,\n\t q  INTEGER,\n\t g  INTEGER\n     }\n  */\n  if (i->type == ASN1_INTEGER\n      && asn1_der_get_bignum(i, params->p, max_bits)\n      && mpz_sgn(params->p) > 0)\n    {\n      unsigned p_bits = mpz_sizeinbase (params->p, 2);\n      return (GET(i, params->q, q_bits ? q_bits : p_bits)\n\t      && (q_bits == 0 || mpz_sizeinbase(params->q, 2) == q_bits)\n\t      && mpz_cmp (params->q, params->p) < 0\n\t      && GET(i, params->g, p_bits)\n\t      && mpz_cmp (params->g, params->p) < 0\n\t      && asn1_der_iterator_next(i) == ASN1_ITERATOR_END);\n    }\n  else\n    return 0;\n}",
      "lines": 26,
      "depth": 18,
      "decorators": [
        "int"
      ]
    },
    "dsa_public_key_from_der_iterator": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\ndsa_public_key_from_der_iterator(const struct dsa_params *params,\n\t\t\t\t mpz_t pub,\n\t\t\t\t struct asn1_der_iterator *i)\n{\n  /* DSAPublicKey ::= INTEGER\n  */\n\n  return (i->type == ASN1_INTEGER\n\t  && asn1_der_get_bignum(i, pub,\n\t\t\t\t mpz_sizeinbase (params->p, 2))\n\t  && mpz_sgn(pub) > 0\n\t  && mpz_cmp(pub, params->p) < 0);\n}",
      "lines": 14,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "dsa_openssl_private_key_from_der_iterator": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\ndsa_openssl_private_key_from_der_iterator(struct dsa_params *params,\n\t\t\t\t\t  mpz_t pub,\n\t\t\t\t\t  mpz_t priv,\n\t\t\t\t\t  unsigned p_max_bits,\n\t\t\t\t\t  struct asn1_der_iterator *i)\n{\n  /* DSAPrivateKey ::= SEQUENCE {\n         version           Version,\n\t p                 INTEGER,\n\t q                 INTEGER,\n\t g                 INTEGER,\n\t pub_key           INTEGER,  -- y\n\t priv_key          INTEGER,  -- x\n    }\n  */\n\n  uint32_t version;\n\n  if (i->type == ASN1_SEQUENCE\n\t  && asn1_der_decode_constructed_last(i) == ASN1_ITERATOR_PRIMITIVE\n\t  && i->type == ASN1_INTEGER\n\t  && asn1_der_get_uint32(i, &version)\n\t  && version == 0\n      && GET(i, params->p, p_max_bits))\n    {\n      unsigned p_bits = mpz_sizeinbase (params->p, 2);\n      return (GET(i, params->q, DSA_SHA1_Q_BITS)\n\t      && GET(i, params->g, p_bits)\n\t      && mpz_cmp (params->g, params->p) < 0\n\t      && GET(i, pub, p_bits)\n\t      && mpz_cmp (pub, params->p) < 0\n\t      && GET(i, priv, DSA_SHA1_Q_BITS)\n\t      && asn1_der_iterator_next(i) == ASN1_ITERATOR_END);\n    }\n  else\n    return 0;\n}",
      "lines": 38,
      "depth": 16,
      "decorators": [
        "int"
      ]
    },
    "dsa_openssl_private_key_from_der": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "int\ndsa_openssl_private_key_from_der(struct dsa_params *params,\n\t\t\t\t mpz_t pub,\n\t\t\t\t mpz_t priv,\n\t\t\t\t unsigned p_max_bits,\n\t\t\t\t size_t length, const uint8_t *data)\n{\n  struct asn1_der_iterator i;\n  enum asn1_iterator_result res;\n\n  res = asn1_der_iterator_first(&i, length, data);\n\n  return (res == ASN1_ITERATOR_CONSTRUCTED\n\t  && dsa_openssl_private_key_from_der_iterator(params, pub, priv,\n\t\t\t\t\t\t       p_max_bits, &i));\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/der2rsa.c": {
    "rsa_public_key_from_der_iterator": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "int\nrsa_public_key_from_der_iterator(struct rsa_public_key *pub,\n\t\t\t\t unsigned limit,\n\t\t\t\t struct asn1_der_iterator *i)\n{\n  /* RSAPublicKey ::= SEQUENCE {\n         modulus           INTEGER,  -- n\n\t publicExponent    INTEGER   -- e\n      }\n  */\n\n  return (i->type == ASN1_SEQUENCE\n\t  && asn1_der_decode_constructed_last(i) == ASN1_ITERATOR_PRIMITIVE\n\t  && asn1_der_get_bignum(i, pub->n, limit) \n\t  && mpz_sgn(pub->n) > 0\n\t  && GET(i, pub->e, limit)\n\t  && asn1_der_iterator_next(i) == ASN1_ITERATOR_END\n\t  && rsa_public_key_prepare(pub));\n}",
      "lines": 19,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "rsa_private_key_from_der_iterator": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "int\nrsa_private_key_from_der_iterator(struct rsa_public_key *pub,\n\t\t\t\t  struct rsa_private_key *priv,\n\t\t\t\t  unsigned limit,\n\t\t\t\t  struct asn1_der_iterator *i)\n{\n  /* RSAPrivateKey ::= SEQUENCE {\n         version           Version,\n\t modulus           INTEGER,  -- n\n\t publicExponent    INTEGER,  -- e\n\t privateExponent   INTEGER,  -- d\n\t prime1            INTEGER,  -- p\n\t prime2            INTEGER,  -- q\n\t exponent1         INTEGER,  -- d mod (p-1)\n\t exponent2         INTEGER,  -- d mod (q-1)\n\t coefficient       INTEGER,  -- (inverse of q) mod p\n\t otherPrimeInfos   OtherPrimeInfos OPTIONAL\n    }\n  */\n\n  uint32_t version;\n  \n  if (i->type != ASN1_SEQUENCE)\n    return 0;\n\n  if (asn1_der_decode_constructed_last(i) == ASN1_ITERATOR_PRIMITIVE\n      && i->type == ASN1_INTEGER\n      && asn1_der_get_uint32(i, &version)\n      && version <= 1\n      && GET(i, pub->n, limit)\n      && GET(i, pub->e, limit)\n      && rsa_public_key_prepare(pub)\n      && GET(i, priv->d, limit)\n      && GET(i, priv->p, limit)\n      && GET(i, priv->q, limit)\n      && GET(i, priv->a, limit)\n      && GET(i, priv->b, limit)\n      && GET(i, priv->c, limit)\n      && rsa_private_key_prepare(priv))\n    {\n      if (version == 1)\n\t{\n\t  /* otherPrimeInfos must be present. We ignore the contents */\n\t  if (!(asn1_der_iterator_next(i) == ASN1_ITERATOR_CONSTRUCTED\n\t\t&& i->type == ASN1_SEQUENCE))\n\t    return 0;\n\t}\n\n      return (asn1_der_iterator_next(i) == ASN1_ITERATOR_END);\n    }\n  \n  return 0;\n}",
      "lines": 53,
      "depth": 21,
      "decorators": [
        "int"
      ]
    },
    "rsa_keypair_from_der": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\nrsa_keypair_from_der(struct rsa_public_key *pub,\n\t\t     struct rsa_private_key *priv,\n\t\t     unsigned limit, \n\t\t     size_t length, const uint8_t *data)\n{\n  struct asn1_der_iterator i;\n  enum asn1_iterator_result res;\n\n  res = asn1_der_iterator_first(&i, length, data);\n\n  if (res != ASN1_ITERATOR_CONSTRUCTED)\n    return 0;\n\n  if (priv)\n    return rsa_private_key_from_der_iterator(pub, priv, limit, &i);\n  else\n    return rsa_public_key_from_der_iterator(pub, limit, &i);    \n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/des-compat.c": {
    "des_compat_des3_encrypt": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\ndes_compat_des3_encrypt(struct des_compat_des3 *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  nettle_des_encrypt(ctx->keys[0], length, dst, src);\n  nettle_des_decrypt(ctx->keys[1], length, dst, dst);\n  nettle_des_encrypt(ctx->keys[2], length, dst, dst);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "des_compat_des3_decrypt": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "static void\ndes_compat_des3_decrypt(struct des_compat_des3 *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  nettle_des_decrypt(ctx->keys[2], length, dst, src);\n  nettle_des_encrypt(ctx->keys[1], length, dst, dst);\n  nettle_des_decrypt(ctx->keys[0], length, dst, dst);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "des_ecb3_encrypt": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ndes_ecb3_encrypt(const_des_cblock *src, des_cblock *dst,\n\t\t des_key_schedule k1,\n\t\t des_key_schedule k2,\n\t\t des_key_schedule k3, int enc)\n{\n  struct des_compat_des3 keys;\n  keys.keys[0] = k1;\n  keys.keys[1] = k2;\n  keys.keys[2] = k3;\n\n  ((enc == DES_ENCRYPT) ? des_compat_des3_encrypt : des_compat_des3_decrypt)\n    (&keys, DES_BLOCK_SIZE, *dst, *src);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "des_cbc_cksum": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "uint32_t\ndes_cbc_cksum(const uint8_t *src, des_cblock *dst,\n\t      long length, des_key_schedule ctx,\n\t      const_des_cblock *iv)\n{\n  /* FIXME: I'm not entirely sure how this function is supposed to\n   * work, in particular what it should return, and if iv can be\n   * modified. */\n  uint8_t block[DES_BLOCK_SIZE];\n\n  memcpy(block, *iv, DES_BLOCK_SIZE);\n\n  while (length >= DES_BLOCK_SIZE)\n    {\n      memxor(block, src, DES_BLOCK_SIZE);\n      nettle_des_encrypt(ctx, DES_BLOCK_SIZE, block, block);\n\n      src += DES_BLOCK_SIZE;\n      length -= DES_BLOCK_SIZE;\t  \n    }\n  if (length > 0)\n    {\n      memxor(block, src, length);\n      nettle_des_encrypt(ctx, DES_BLOCK_SIZE, block, block);\t  \n    }\n  memcpy(*dst, block, DES_BLOCK_SIZE);\n\n  return LE_READ_UINT32(block + 4);\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "uint32_t"
      ]
    },
    "des_ncbc_encrypt": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        137,
        1
      ],
      "content": "void\ndes_ncbc_encrypt(const_des_cblock *src, des_cblock *dst, long length,\n                 des_key_schedule ctx, des_cblock *iv,\n                 int enc)\n{\n  switch (enc)\n    {\n    case DES_ENCRYPT:\n      nettle_cbc_encrypt(ctx, (nettle_cipher_func *) des_encrypt,\n\t\t\t DES_BLOCK_SIZE, *iv,\n\t\t\t length, *dst, *src);\n      break;\n    case DES_DECRYPT:\n      nettle_cbc_decrypt(ctx,\n\t\t\t (nettle_cipher_func *) des_decrypt,\n\t\t\t DES_BLOCK_SIZE, *iv,\n\t\t\t length, *dst, *src);\n      break;\n    default:\n      abort();\n    }\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "des_cbc_encrypt": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\ndes_cbc_encrypt(const_des_cblock *src, des_cblock *dst, long length,\n\t\tdes_key_schedule ctx, const_des_cblock *civ,\n\t\tint enc)\n{\n  des_cblock iv;\n\n  memcpy(iv, civ, DES_BLOCK_SIZE);\n\n  des_ncbc_encrypt(src, dst, length, ctx, &iv, enc);\n}",
      "lines": 11,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "des_ecb_encrypt": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\ndes_ecb_encrypt(const_des_cblock *src, des_cblock *dst,\n\t\tdes_key_schedule ctx,\n\t\tint enc)\n{\n  ((enc == DES_ENCRYPT) ? nettle_des_encrypt : nettle_des_decrypt)\n    (ctx, DES_BLOCK_SIZE, *dst, *src);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "des_ede3_cbc_encrypt": {
      "start_point": [
        161,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\ndes_ede3_cbc_encrypt(const_des_cblock *src, des_cblock *dst, long length,\n\t\t     des_key_schedule k1,\n\t\t     des_key_schedule k2,\n\t\t     des_key_schedule k3,\n\t\t     des_cblock *iv,\n\t\t     int enc)\n{\n  struct des_compat_des3 keys;\n  keys.keys[0] = k1;\n  keys.keys[1] = k2;\n  keys.keys[2] = k3;\n\n  switch (enc)\n    {\n    case DES_ENCRYPT:\n      nettle_cbc_encrypt(&keys, (nettle_cipher_func *) des_compat_des3_encrypt,\n\t\t\t DES_BLOCK_SIZE, *iv,\n\t\t\t length, *dst, *src);\n      break;\n    case DES_DECRYPT:\n      nettle_cbc_decrypt(&keys, (nettle_cipher_func *) des_compat_des3_decrypt,\n\t\t\t DES_BLOCK_SIZE, *iv,\n\t\t\t length, *dst, *src);\n      break;\n    default:\n      abort();\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "des_set_odd_parity": {
      "start_point": [
        191,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "int\ndes_set_odd_parity(des_cblock *key)\n{\n  nettle_des_fix_parity(DES_KEY_SIZE, *key, *key);\n\n  /* FIXME: What to return? */\n  return 0;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "des_key_sched": {
      "start_point": [
        210,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\ndes_key_sched(const_des_cblock *key, des_key_schedule ctx)\n{\n  if (des_check_key && !des_check_parity (DES_KEY_SIZE, *key))\n    /* Bad parity */\n    return -1;\n  \n  if (!nettle_des_set_key(ctx, *key) && des_check_key)\n    /* Weak key */\n    return -2;\n\n  return 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "des_is_weak_key": {
      "start_point": [
        224,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "int\ndes_is_weak_key(const_des_cblock *key)\n{\n  struct des_ctx ctx;\n\n  return !nettle_des_set_key(&ctx, *key);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/des-compat.h": {},
  "nettle/nettle-3.4.1/des.c": {
    "des_check_parity": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\ndes_check_parity(size_t length, const uint8_t *key)\n{\n  size_t i;\n  for (i = 0; i<length; i++)\n    if (!PARITY(key[i]))\n      return 0;\n\n  return 1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "des_fix_parity": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ndes_fix_parity(size_t length, uint8_t *dst,\n\t       const uint8_t *src)\n{\n  size_t i;\n  for (i = 0; i<length; i++)\n    dst[i] = src[i] ^ PARITY(src[i]) ^ 1;\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "des_weak_p": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static int\ndes_weak_p(const uint8_t *key)\n{\n  /* Hash function generated using gperf. */\n  static const unsigned char asso_values[0x81] =\n    {\n      16,  9, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26,  6,  2, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26, 26, 26, 26,\n      26, 26,  3,  1, 26, 26, 26, 26, 26, 26,\n      26, 26, 26, 26, 26, 26, 26,  0,  0\n    };\n\n  static const int8_t weak_key_hash[26][4] =\n    {\n      /*  0 */ {0x7f,0x7f, 0x7f,0x7f},\n      /*  1 */ {0x7f,0x70, 0x7f,0x78},\n      /*  2 */ {0x7f,0x0f, 0x7f,0x07},\n      /*  3 */ {0x70,0x7f, 0x78,0x7f},\n      /*  4 */ {0x70,0x70, 0x78,0x78},\n      /*  5 */ {0x70,0x0f, 0x78,0x07},\n      /*  6 */ {0x0f,0x7f, 0x07,0x7f},\n      /*  7 */ {0x0f,0x70, 0x07,0x78},\n      /*  8 */ {0x0f,0x0f, 0x07,0x07},\n      /*  9 */ {0x7f,0x00, 0x7f,0x00},\n      /* 10 */ {-1,-1,-1,-1},\n      /* 11 */ {-1,-1,-1,-1},\n      /* 12 */ {0x70,0x00, 0x78,0x00},\n      /* 13 */ {-1,-1,-1,-1},\n      /* 14 */ {-1,-1,-1,-1},\n      /* 15 */ {0x0f,0x00, 0x07,0x00},\n      /* 16 */ {0x00,0x7f, 0x00,0x7f},\n      /* 17 */ {0x00,0x70, 0x00,0x78},\n      /* 18 */ {0x00,0x0f, 0x00,0x07},\n      /* 19 */ {-1,-1,-1,-1},\n      /* 20 */ {-1,-1,-1,-1},\n      /* 21 */ {-1,-1,-1,-1},\n      /* 22 */ {-1,-1,-1,-1},\n      /* 23 */ {-1,-1,-1,-1},\n      /* 24 */ {-1,-1,-1,-1},\n      /* 25 */ {0x00,0x00, 0x00,0x00}\n    };\n\n  int8_t k0 = key[0] >> 1;\n  int8_t k1 = key[1] >> 1;\n\n  unsigned hash = asso_values[k1 + 1] + asso_values[k0];\n  const int8_t *candidate;\n\n  if (hash > 25)\n    return 0;\n\n  candidate = weak_key_hash[hash];\n\n  if (k0 != candidate[0]\n      || k1 != candidate[1])\n    return 0;\n  \n  if ( (key[2] >> 1) != k0\n       || (key[3] >> 1) != k1)\n    return 0;\n\n  k0 = key[4] >> 1;\n  k1 = key[5] >> 1;\n  if (k0 != candidate[2]\n      || k1 != candidate[3])\n    return 0;\n  if ( (key[6] >> 1) != k0\n       || (key[7] >> 1) != k1)\n    return 0;\n\n  return 1;\n}",
      "lines": 81,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "des_set_key": {
      "start_point": [
        202,
        0
      ],
      "end_point": [
        274,
        1
      ],
      "content": "int\ndes_set_key(struct des_ctx *ctx, const uint8_t *key)\n{\n  register uint32_t n, w;\n  register char * b0, * b1;\n  char bits0[56], bits1[56];\n  uint32_t *method;\n  const uint8_t *k;\n\n  /* explode the bits */\n  n = 56;\n  b0 = bits0;\n  b1 = bits1;\n  k = key;\n  do {\n    w = (256 | *k++) << 2;\n    do {\n      --n;\n      b1[n] = 8 & w;\n      w >>= 1;\n      b0[n] = 4 & w;\n    } while ( w >= 16 );\n  } while ( n );\n\n  /* put the bits in the correct places */\n  n = 16;\n  k = rotors;\n  method = ctx->key;\n  \n  do {\n    w   = (b1[k[ 0   ]] | b0[k[ 1   ]]) << 4;\n    w  |= (b1[k[ 2   ]] | b0[k[ 3   ]]) << 2;\n    w  |=  b1[k[ 4   ]] | b0[k[ 5   ]];\n    w <<= 8;\n    w  |= (b1[k[ 6   ]] | b0[k[ 7   ]]) << 4;\n    w  |= (b1[k[ 8   ]] | b0[k[ 9   ]]) << 2;\n    w  |=  b1[k[10   ]] | b0[k[11   ]];\n    w <<= 8;\n    w  |= (b1[k[12   ]] | b0[k[13   ]]) << 4;\n    w  |= (b1[k[14   ]] | b0[k[15   ]]) << 2;\n    w  |=  b1[k[16   ]] | b0[k[17   ]];\n    w <<= 8;\n    w  |= (b1[k[18   ]] | b0[k[19   ]]) << 4;\n    w  |= (b1[k[20   ]] | b0[k[21   ]]) << 2;\n    w  |=  b1[k[22   ]] | b0[k[23   ]];\n\n    method[0] = w;\n\n    w   = (b1[k[ 0+24]] | b0[k[ 1+24]]) << 4;\n    w  |= (b1[k[ 2+24]] | b0[k[ 3+24]]) << 2;\n    w  |=  b1[k[ 4+24]] | b0[k[ 5+24]];\n    w <<= 8;\n    w  |= (b1[k[ 6+24]] | b0[k[ 7+24]]) << 4;\n    w  |= (b1[k[ 8+24]] | b0[k[ 9+24]]) << 2;\n    w  |=  b1[k[10+24]] | b0[k[11+24]];\n    w <<= 8;\n    w  |= (b1[k[12+24]] | b0[k[13+24]]) << 4;\n    w  |= (b1[k[14+24]] | b0[k[15+24]]) << 2;\n    w  |=  b1[k[16+24]] | b0[k[17+24]];\n    w <<= 8;\n    w  |= (b1[k[18+24]] | b0[k[19+24]]) << 4;\n    w  |= (b1[k[20+24]] | b0[k[21+24]]) << 2;\n    w  |=  b1[k[22+24]] | b0[k[23+24]];\n\n    ROR(w, 4, 28);\t\t/* could be eliminated */\n    method[1] = w;\n\n    k\t+= 48;\n    method\t+= 2;\n  } while ( --n );\n\n  return !des_weak_p (key);\n}",
      "lines": 73,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "des_encrypt": {
      "start_point": [
        276,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "void\ndes_encrypt(const struct des_ctx *ctx,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % DES_BLOCK_SIZE));\n  \n  while (length)\n    {\n      DesSmallFipsEncrypt(dst, ctx->key, src);\n      length -= DES_BLOCK_SIZE;\n      src += DES_BLOCK_SIZE;\n      dst += DES_BLOCK_SIZE;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "des_decrypt": {
      "start_point": [
        292,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "void\ndes_decrypt(const struct des_ctx *ctx,\n\t    size_t length, uint8_t *dst,\n\t    const uint8_t *src)\n{\n  assert(!(length % DES_BLOCK_SIZE));\n\n  while (length)\n    {\n      DesSmallFipsDecrypt(dst, ctx->key, src);\n      length -= DES_BLOCK_SIZE;\n      src += DES_BLOCK_SIZE;\n      dst += DES_BLOCK_SIZE;\n    }\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/des.h": {},
  "nettle/nettle-3.4.1/des3.c": {
    "des3_set_key": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\ndes3_set_key(struct des3_ctx *ctx, const uint8_t *key)\n{\n  unsigned i;\n  int is_good = 1;\n  \n  for (i = 0; i<3; i++, key += DES_KEY_SIZE)\n    if (!des_set_key(&ctx->des[i], key))\n      is_good = 0;\n\n  return is_good;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "des3_encrypt": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ndes3_encrypt(const struct des3_ctx *ctx,\n\t     size_t length, uint8_t *dst,\n\t     const uint8_t *src)\n{\n  des_encrypt(&ctx->des[0],\n\t      length, dst, src);\n  des_decrypt(&ctx->des[1],\n\t      length, dst, dst);\n  des_encrypt(&ctx->des[2],\n\t      length, dst, dst);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "des3_decrypt": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\ndes3_decrypt(const struct des3_ctx *ctx,\n\t     size_t length, uint8_t *dst,\n\t     const uint8_t *src)\n{\n  des_decrypt(&ctx->des[2],\n\t      length, dst, src);\n  des_encrypt(&ctx->des[1],\n\t      length, dst, dst);\n  des_decrypt(&ctx->des[0],\n\t      length, dst, dst);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/desCode.h": {},
  "nettle/nettle-3.4.1/desdata.c": {
    "main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n\tunsigned long d, i, j, k, l, m, n, s; /* Always at least 32 bits */\n\tchar b[256], ksr[56];\n\n\tif (argc <= 1)\n\t\treturn 1;\n\n\tswitch ( argv[1][0] ) {\n\ndefault: \n\treturn 1;\n\t/*\n\t * <<< make the key parity table >>>\n\t */\n\ncase 'p':\n\tprintf(\n\"/* automagically produced - do not fuss with this information */\\n\\n\");\n\n\t/* store parity information */\n\tfor ( i = 0; i < 256; i++ ) {\n\t\tj  = i;\n\t\tj ^= j >> 4;\t/* bits 3-0 have pairs */\n\t\tj ^= j << 2;\t/* bits 3-2 have quads */\n\t\tj ^= j << 1;\t/* bit  3 has the entire eight (no cox) */\n\t\tb[i] = 8 & ~j;\t/* 0 is okay and 8 is bad parity */\n\t}\n\n\t/* only these characters can appear in a weak key */\n\tb[0x01] = 1;\n\tb[0x0e] = 2;\n\tb[0x1f] = 3;\n\tb[0xe0] = 4;\n\tb[0xf1] = 5;\n\tb[0xfe] = 6;\n\n\t/* print it out */\n\tfor ( i = 0; i < 256; i++ ) {\n\t\tprintf(\"%d,\", b[i]);\n\t\tif ( (i & 31) == 31 )\n\t\t\tprintf(\"\\n\");\n\t}\n\n\tbreak;\n\n\n\t/*\n\t * <<< make the key usage table >>>\n\t */\n\ncase 'r':\n\tprintf(\"/* automagically made - do not fuss with this */\\n\\n\");\n\n\t/* KL specifies the initial key bit positions */\n\tfor (i = 0; i < 56; i++)\n\t\tksr[i] = (KL[i] - 1) ^ 7;\n\n\tfor (i = 0; i < 16; i++) {\n\n\t\t/* apply the appropriate number of left shifts */\n\t\tfor (j = 0; j < KS[i]; j++) {\n\t\t\tm = ksr[ 0];\n\t\t\tn = ksr[28];\n\t\t\tfor (k = 0; k < 27; k++)\n\t\t\t\tksr[k     ] = ksr[k +  1],\n\t\t\t\tksr[k + 28] = ksr[k + 29];\n\t\t\tksr[27] = m;\n\t\t\tksr[55] = n;\n\t\t}\n\n\t\t/* output the key bit numbers */\n\t\tfor (j = 0; j < 48; j++) {\n\t\t\tm = ksr[KC[korder[j]] - 1];\n\t\t\tm = (m / 8) * 7 + (m % 8) - 1;\n\t\t\tm = 55 - m;\n\t\t\tprintf(\" %2ld,\", (long) m);\n\t\t\tif ((j % 12) == 11)\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tbreak;\n\n\n\t/*\n\t * <<< make the keymap table >>>\n\t */\n\ncase 'k':\n\tprintf(\"/* automagically made - do not fuss with this */\\n\\n\");\n\n\tfor ( i = 0; i <= 7 ; i++ ) {\n\t\ts = sorder[i];\n\t\tfor ( d = 0; d <= 63; d++ ) {\n\t\t\t/* flip bits */\n\t\t\tk =\t((d << 5) & 32) |\n\t\t\t\t((d << 3) & 16) |\n\t\t\t\t((d << 1) &  8) |\n\t\t\t\t((d >> 1) &  4) |\n\t\t\t\t((d >> 3) &  2) |\n\t\t\t\t((d >> 5) &  1) ;\n\t\t\t/* more bit twiddling */\n\t\t\tl =\t((k << 0) & 32) |\t/* overlap bit */\n\t\t\t\t((k << 4) & 16) |\t/* overlap bit */\n\t\t\t\t((k >> 1) & 15) ;\t/* unique bits */\n\t\t\t/* look up s box value */\n\t\t\tm = SB[s][l];\n\t\t\t/* flip bits */\n\t\t\tn =\t((m << 3) &  8) |\n\t\t\t\t((m << 1) &  4) |\n\t\t\t\t((m >> 1) &  2) |\n\t\t\t\t((m >> 3) &  1) ;\n\t\t\t/* put in correct nybble */\n\t\t\tn <<= (s << 2);\n\t\t\t/* perform p permutation */\n\t\t\tfor ( m = j = 0; j < 32; j++ )\n\t\t\t\tif ( n & (1 << (SP[j] - 1)) )\n\t\t\t\t\tm |= (1UL << j);\n\t\t\t/* rotate right (alg keeps everything rotated by 1) */\n\t\t\tm = (m >> 1) | ((m & 1) << 31);\n\t\t\t/* print it out */\n\t\t\tprintf(\" 0x%08lx,\", m);\n\t\t\tif ( ( d & 3 ) == 3 )\n\t\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\tbreak;\n\n\t}\n\n\treturn 0;\n}",
      "lines": 137,
      "depth": 21,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/desinfo.h": {},
  "nettle/nettle-3.4.1/dsa-compat-keygen.c": {
    "dsa_compat_generate_keypair": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\ndsa_compat_generate_keypair(struct dsa_public_key *pub,\n\t\t\t    struct dsa_private_key *key,\n\t\t\t    void *random_ctx, nettle_random_func *random,\n\t\t\t    void *progress_ctx, nettle_progress_func *progress,\n\t\t\t    unsigned p_bits, unsigned q_bits)\n{\n  struct dsa_params *params;\n\n  switch (q_bits)\n    {\n    case 160:\n      if (p_bits < DSA_SHA1_MIN_P_BITS)\n\treturn 0;\n      break;\n    case 224:\n    case 256:\n      if (p_bits < DSA_SHA256_MIN_P_BITS)\n\treturn 0;\n      break;\n    default:\n      return 0;\n    }\n\n  /* NOTE: Depends on identical layout! */\n  params = (struct dsa_params *) pub;\n\n  if (!dsa_generate_params (params,\n\t\t\t    random_ctx, random,\n\t\t\t    progress_ctx, progress,\n\t\t\t    p_bits, q_bits))\n    return 0;\n\n  dsa_generate_keypair (params, pub->y, key->x, random_ctx, random);\n\n  return 1;\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-compat.c": {
    "dsa_public_key_init": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\ndsa_public_key_init(struct dsa_public_key *key)\n{\n  dsa_params_init ((struct dsa_params *) key);\n  mpz_init(key->y);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dsa_public_key_clear": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ndsa_public_key_clear(struct dsa_public_key *key)\n{\n  dsa_params_clear ((struct dsa_params *) key);\n  mpz_clear(key->y);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "dsa_private_key_init": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ndsa_private_key_init(struct dsa_private_key *key)\n{\n  mpz_init(key->x);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dsa_private_key_clear": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\ndsa_private_key_clear(struct dsa_private_key *key)\n{\n  mpz_clear(key->x);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-compat.h": {},
  "nettle/nettle-3.4.1/dsa-gen-params.c": {
    "dsa_generate_params": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\ndsa_generate_params(struct dsa_params *params,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    void *progress_ctx, nettle_progress_func *progress,\n\t\t    unsigned p_bits, unsigned q_bits)\n{\n  mpz_t r;\n  unsigned p0_bits;\n  unsigned a;\n\n  if (q_bits < 30 || p_bits < q_bits + 30)\n    return 0;\n\n  mpz_init (r);\n\n  nettle_random_prime (params->q, q_bits, 0, random_ctx, random,\n\t\t       progress_ctx, progress);\n\n  if (q_bits >= (p_bits + 2)/3)\n    _nettle_generate_pocklington_prime (params->p, r, p_bits, 0,\n\t\t\t\t\trandom_ctx, random,\n\t\t\t\t\tparams->q, NULL, params->q);\n  else\n    {\n      mpz_t p0, p0q;\n      mpz_init (p0);\n      mpz_init (p0q);\n\n      p0_bits = (p_bits + 3)/2;\n  \n      nettle_random_prime (p0, p0_bits, 0,\n\t\t\t   random_ctx, random,\n\t\t\t   progress_ctx, progress);\n\n      if (progress)\n\tprogress (progress_ctx, 'q');\n\n      /* Generate p = 2 r q p0 + 1, such that 2^{n-1} < p < 2^n. */\n      mpz_mul (p0q, p0, params->q);\n\n      _nettle_generate_pocklington_prime (params->p, r, p_bits, 0,\n\t\t\t\t\t  random_ctx, random,\n\t\t\t\t\t  p0, params->q, p0q);\n\n      mpz_mul (r, r, p0);\n\n      mpz_clear (p0);\n      mpz_clear (p0q);\n    }\n  if (progress)\n    progress (progress_ctx, 'p');\n\n  for (a = 2; ; a++)\n    {\n      mpz_set_ui (params->g, a);\n      mpz_powm (params->g, params->g, r, params->p);\n      if (mpz_cmp_ui (params->g, 1) != 0)\n\tbreak;\n    }\n\n  mpz_clear (r);\n  \n  if (progress)\n    progress (progress_ctx, 'g');\n\n  return 1;\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-hash.c": {
    "_dsa_hash": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\n_dsa_hash (mpz_t h, unsigned bit_size,\n\t   size_t length, const uint8_t *digest)\n{\n  \n  if (length > (bit_size + 7) / 8)\n    length = (bit_size + 7) / 8;\n\n  nettle_mpz_set_str_256_u(h, length, digest);\n\n  if (8 * length > bit_size)\n    /* We got a few extra bits, at the low end. Discard them. */\n    mpz_tdiv_q_2exp (h, h, 8*length - bit_size);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-keygen.c": {
    "dsa_generate_keypair": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ndsa_generate_keypair (const struct dsa_params *params,\n\t\t      mpz_t pub, mpz_t key,\n\n\t\t      void *random_ctx, nettle_random_func *random)\n{\n  mpz_t r;\n\n  mpz_init_set(r, params->q);\n  mpz_sub_ui(r, r, 2);\n  nettle_mpz_random(key, random_ctx, random, r);\n\n  mpz_add_ui(key, key, 1);\n  mpz_powm(pub, params->g, key, params->p);\n  mpz_clear (r);\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-sha1-sign.c": {
    "dsa_sha1_sign_digest": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\ndsa_sha1_sign_digest(const struct dsa_public_key *pub,\n\t\t     const struct dsa_private_key *key,\n\t\t     void *random_ctx, nettle_random_func *random,\n\t\t     const uint8_t *digest,\n\t\t     struct dsa_signature *signature)\n{\n  return dsa_sign((const struct dsa_params *) pub, key->x,\n\t\t  random_ctx, random,\n\t\t  SHA1_DIGEST_SIZE, digest, signature);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha1_sign": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\ndsa_sha1_sign(const struct dsa_public_key *pub,\n\t      const struct dsa_private_key *key,\n\t      void *random_ctx, nettle_random_func *random,\n\t      struct sha1_ctx *hash,\n\t      struct dsa_signature *signature)\n{\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  sha1_digest(hash, sizeof(digest), digest);\n  \n  return dsa_sign((const struct dsa_params *) pub, key->x,\n\t\t  random_ctx, random,\n\t\t  sizeof(digest), digest, signature);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-sha1-verify.c": {
    "dsa_sha1_verify_digest": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\ndsa_sha1_verify_digest(const struct dsa_public_key *key,\n\t\t       const uint8_t *digest,\n\t\t       const struct dsa_signature *signature)\n{\n  return dsa_verify((const struct dsa_params *) key, key->y,\n\t\t    SHA1_DIGEST_SIZE, digest, signature);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha1_verify": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\ndsa_sha1_verify(const struct dsa_public_key *key,\n\t\tstruct sha1_ctx *hash,\n\t\tconst struct dsa_signature *signature)\n{\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  sha1_digest(hash, sizeof(digest), digest);\n\n  return dsa_verify((const struct dsa_params *) key, key->y,\n\t\t    sizeof(digest), digest, signature);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-sha256-sign.c": {
    "dsa_sha256_sign_digest": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "int\ndsa_sha256_sign_digest(const struct dsa_public_key *pub,\n\t\t       const struct dsa_private_key *key,\n\t\t       void *random_ctx, nettle_random_func *random,\n\t\t       const uint8_t *digest,\n\t\t       struct dsa_signature *signature)\n{\n  return dsa_sign((const struct dsa_params *) pub, key->x,\n\t\t  random_ctx, random,\n\t\t  SHA256_DIGEST_SIZE, digest, signature);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha256_sign": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\ndsa_sha256_sign(const struct dsa_public_key *pub,\n\t\tconst struct dsa_private_key *key,\n\t\tvoid *random_ctx, nettle_random_func *random,\n\t\tstruct sha256_ctx *hash,\n\t\tstruct dsa_signature *signature)\n{\n  uint8_t digest[SHA256_DIGEST_SIZE];\n  sha256_digest(hash, sizeof(digest), digest);\n\n  return dsa_sign((const struct dsa_params *) pub, key->x,\n\t\t  random_ctx, random,\n\t\t  sizeof(digest), digest, signature);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-sha256-verify.c": {
    "dsa_sha256_verify_digest": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "int\ndsa_sha256_verify_digest(const struct dsa_public_key *key,\n\t\t\t const uint8_t *digest,\n\t\t\t const struct dsa_signature *signature)\n{\n  return dsa_verify((const struct dsa_params *) key, key->y,\n\t\t    SHA256_DIGEST_SIZE, digest, signature);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha256_verify": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\ndsa_sha256_verify(const struct dsa_public_key *key,\n\t\t  struct sha256_ctx *hash,\n\t\t  const struct dsa_signature *signature)\n{\n  uint8_t digest[SHA256_DIGEST_SIZE];\n  sha256_digest(hash, sizeof(digest), digest);\n\n  return dsa_verify((const struct dsa_params *) key, key->y,\n\t\t    sizeof(digest), digest, signature);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-sign.c": {
    "dsa_sign": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "int\ndsa_sign(const struct dsa_params *params,\n\t const mpz_t x,\n\t void *random_ctx, nettle_random_func *random,\n\t size_t digest_size,\n\t const uint8_t *digest,\n\t struct dsa_signature *signature)\n{\n  mpz_t k;\n  mpz_t h;\n  mpz_t tmp;\n  int res;\n  \n  /* Check that p is odd, so that invalid keys don't result in a crash\n     inside mpz_powm_sec. */\n  if (mpz_even_p (params->p))\n    return 0;\n\n  /* Select k, 0<k<q, randomly */\n  mpz_init_set(tmp, params->q);\n  mpz_sub_ui(tmp, tmp, 1);\n\n  mpz_init(k);\n  nettle_mpz_random(k, random_ctx, random, tmp);\n  mpz_add_ui(k, k, 1);\n\n  /* Compute r = (g^k (mod p)) (mod q) */\n  mpz_powm_sec(tmp, params->g, k, params->p);\n  mpz_fdiv_r(signature->r, tmp, params->q);\n\n  /* Compute hash */\n  mpz_init(h);\n  _dsa_hash (h, mpz_sizeinbase(params->q, 2), digest_size, digest);\n\n  /* Compute k^-1 (mod q) */\n  if (mpz_invert(k, k, params->q))\n    {\n      /* Compute signature s = k^-1 (h + xr) (mod q) */\n      mpz_mul(tmp, signature->r, x);\n      mpz_fdiv_r(tmp, tmp, params->q);\n      mpz_add(tmp, tmp, h);\n      mpz_mul(tmp, tmp, k);\n      mpz_fdiv_r(signature->s, tmp, params->q);\n      res = 1;\n    }\n  else\n    /* What do we do now? The key is invalid. */\n    res = 0;\n\n  mpz_clear(k);\n  mpz_clear(h);\n  mpz_clear(tmp);\n\n  return res;\n}",
      "lines": 55,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa-verify.c": {
    "dsa_verify": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "int\ndsa_verify(const struct dsa_params *params,\n\t   const mpz_t y,\n\t   size_t digest_size,\n\t   const uint8_t *digest,\n\t   const struct dsa_signature *signature)\n{\n  mpz_t w;\n  mpz_t tmp;\n  mpz_t v;\n\n  int res;\n\n  /* Check that r and s are in the proper range */\n  if (mpz_sgn(signature->r) <= 0 || mpz_cmp(signature->r, params->q) >= 0)\n    return 0;\n\n  if (mpz_sgn(signature->s) <= 0 || mpz_cmp(signature->s, params->q) >= 0)\n    return 0;\n\n  mpz_init(w);\n\n  /* Compute w = s^-1 (mod q) */\n\n  /* NOTE: In gmp-2, mpz_invert sometimes generates negative inverses,\n   * so we need gmp-3 or better. */\n  if (!mpz_invert(w, signature->s, params->q))\n    {\n      mpz_clear(w);\n      return 0;\n    }\n\n  mpz_init(tmp);\n  mpz_init(v);\n\n  /* The message digest */\n  _dsa_hash (tmp, mpz_sizeinbase (params->q, 2), digest_size, digest);\n  \n  /* v = g^{w * h (mod q)} (mod p)  */\n  mpz_mul(tmp, tmp, w);\n  mpz_fdiv_r(tmp, tmp, params->q);\n\n  mpz_powm(v, params->g, tmp, params->p);\n\n  /* y^{w * r (mod q) } (mod p) */\n  mpz_mul(tmp, signature->r, w);\n  mpz_fdiv_r(tmp, tmp, params->q);\n\n  mpz_powm(tmp, y, tmp, params->p);\n\n  /* v = (g^{w * h} * y^{w * r} (mod p) ) (mod q) */\n  mpz_mul(v, v, tmp);\n  mpz_fdiv_r(v, v, params->p);\n\n  mpz_fdiv_r(v, v, params->q);\n\n  res = !mpz_cmp(v, signature->r);\n\n  mpz_clear(w);\n  mpz_clear(tmp);\n  mpz_clear(v);\n\n  return res;\n}",
      "lines": 64,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa.c": {
    "dsa_params_init": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ndsa_params_init (struct dsa_params *params)\n{\n  mpz_init(params->p);\n  mpz_init(params->q);\n  mpz_init(params->g);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dsa_params_clear": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\ndsa_params_clear (struct dsa_params *params)\n{\n  mpz_clear(params->p);\n  mpz_clear(params->q);\n  mpz_clear(params->g);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dsa_signature_init": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ndsa_signature_init(struct dsa_signature *signature)\n{\n  mpz_init(signature->r);\n  mpz_init(signature->s);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "dsa_signature_clear": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\ndsa_signature_clear(struct dsa_signature *signature)\n{\n  mpz_clear(signature->r);\n  mpz_clear(signature->s);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/dsa.h": {},
  "nettle/nettle-3.4.1/dsa2sexp.c": {
    "dsa_keypair_to_sexp": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "int\ndsa_keypair_to_sexp(struct nettle_buffer *buffer,\n\t\t    const char *algorithm_name,\n\t\t    const struct dsa_params *params,\n\t\t    const mpz_t pub,\n\t\t    const mpz_t priv)\n{\n  if (!algorithm_name)\n    algorithm_name = \"dsa\";\n\n  if (priv)\n    return sexp_format(buffer,\n\t\t       \"(private-key(%0s(p%b)(q%b)\"\n\t\t       \"(g%b)(y%b)(x%b)))\",\n\t\t       algorithm_name, params->p, params->q,\n\t\t       params->g, pub, priv);\n\n  else\n    return sexp_format(buffer,\n\t\t       \"(public-key(%0s(p%b)(q%b)\"\n\t\t       \"(g%b)(y%b)))\",\n\t\t       algorithm_name, params->p, params->q,\n\t\t       params->g, pub);\n}",
      "lines": 24,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/eax-aes128-meta.c": {
    "eax_aes128_set_nonce_wrapper": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "static void\neax_aes128_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  eax_aes128_set_nonce (ctx, EAX_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eax-aes128.c": {
    "eax_aes128_set_key": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\neax_aes128_set_key(struct eax_aes128_ctx *ctx, const uint8_t *key)\n{\n  EAX_SET_KEY(ctx,\n\t      aes128_set_encrypt_key, aes128_encrypt,\n\t      key);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "eax_aes128_set_nonce": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\neax_aes128_set_nonce(struct eax_aes128_ctx *ctx,\n\t\t     size_t length, const uint8_t *iv)\n{\n  EAX_SET_NONCE(ctx, aes128_encrypt, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "eax_aes128_update": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\neax_aes128_update(struct eax_aes128_ctx *ctx, size_t length, const uint8_t *data)\n{\n  EAX_UPDATE(ctx, aes128_encrypt, length, data);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "eax_aes128_encrypt": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\neax_aes128_encrypt(struct eax_aes128_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  EAX_ENCRYPT(ctx, aes128_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "eax_aes128_decrypt": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\neax_aes128_decrypt(struct eax_aes128_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  EAX_DECRYPT(ctx, aes128_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "eax_aes128_digest": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\neax_aes128_digest(struct eax_aes128_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  EAX_DIGEST(ctx, aes128_encrypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eax.c": {
    "omac_init": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "static void\nomac_init (union nettle_block16 *state, unsigned t)\n{\n  memset (state->b, 0, EAX_BLOCK_SIZE - 1);\n  state->b[EAX_BLOCK_SIZE - 1] = t;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "block16_xor": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\nblock16_xor (union nettle_block16 *dst, const union nettle_block16 *src)\n{\n  dst->w[0] ^= src->w[0];\n  dst->w[1] ^= src->w[1];\n#if SIZEOF_LONG == 4\n  dst->w[2] ^= src->w[2];\n  dst->w[3] ^= src->w[3];\n#endif\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "omac_update": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\nomac_update (union nettle_block16 *state, const struct eax_key *key,\n\t     const void *cipher, nettle_cipher_func *f,\n\t     size_t length, const uint8_t *data)\n{\n  for (; length >= EAX_BLOCK_SIZE;\n       length -= EAX_BLOCK_SIZE, data += EAX_BLOCK_SIZE)\n    {\n      f (cipher, EAX_BLOCK_SIZE, state->b, state->b);\n      memxor (state->b, data, EAX_BLOCK_SIZE);\n    }\n  if (length > 0)\n    {\n      /* Allowed only for the last call */\n      f (cipher, EAX_BLOCK_SIZE, state->b, state->b);\n      memxor (state->b, data, length);\n      state->b[length] ^= 0x80;\n      /* XOR with (P ^ B), since the digest processing\n       * unconditionally XORs with B */\n      block16_xor (state, &key->pad_partial);\n    }\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "omac_final": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nomac_final (union nettle_block16 *state, const struct eax_key *key,\n\t    const void *cipher, nettle_cipher_func *f)\n{\n  block16_xor (state, &key->pad_block);\n  f (cipher, EAX_BLOCK_SIZE, state->b, state->b);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gf2_double": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "static void\ngf2_double (uint8_t *r, const uint8_t *a)\n{\n  unsigned high = - (a[0] >> 7);\n  unsigned i;\n  /* Shift left */\n  for (i = 0; i < EAX_BLOCK_SIZE - 1; i++)\n    r[i] = (a[i] << 1) + (a[i+1] >> 7);\n\n  /* Wrap around for x^{128} = x^7 + x^2 + x + 1 */\n  r[EAX_BLOCK_SIZE - 1] = (a[EAX_BLOCK_SIZE - 1] << 1) ^ (high & 0x87);\n}",
      "lines": 12,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "eax_set_key": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        117,
        1
      ],
      "content": "void\neax_set_key (struct eax_key *key, const void *cipher, nettle_cipher_func *f)\n{\n  static const union nettle_block16 zero_block;\n  f (cipher, EAX_BLOCK_SIZE, key->pad_block.b, zero_block.b);\n  gf2_double (key->pad_block.b, key->pad_block.b);\n  gf2_double (key->pad_partial.b, key->pad_block.b);\n  block16_xor (&key->pad_partial, &key->pad_block);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "eax_set_nonce": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\neax_set_nonce (struct eax_ctx *eax, const struct eax_key *key,\n\t       const void *cipher, nettle_cipher_func *f,\n\t       size_t nonce_length, const uint8_t *nonce)\n{\n  omac_init (&eax->omac_nonce, 0);\n  omac_update (&eax->omac_nonce, key, cipher, f, nonce_length, nonce);\n  omac_final (&eax->omac_nonce, key, cipher, f);\n  memcpy (eax->ctr.b, eax->omac_nonce.b, EAX_BLOCK_SIZE);\n\n  omac_init (&eax->omac_data, 1);\n  omac_init (&eax->omac_message, 2);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "eax_update": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\neax_update (struct eax_ctx *eax, const struct eax_key *key,\n\t    const void *cipher, nettle_cipher_func *f,\n\t    size_t data_length, const uint8_t *data)\n{\n  omac_update (&eax->omac_data, key, cipher, f, data_length, data);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "eax_encrypt": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "void\neax_encrypt (struct eax_ctx *eax, const struct eax_key *key,\n\t     const void *cipher, nettle_cipher_func *f,\n\t     size_t length, uint8_t *dst, const uint8_t *src)\n{\n  ctr_crypt (cipher, f, EAX_BLOCK_SIZE, eax->ctr.b, length, dst, src);\n  omac_update (&eax->omac_message, key, cipher, f, length, dst);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "eax_decrypt": {
      "start_point": [
        150,
        0
      ],
      "end_point": [
        157,
        1
      ],
      "content": "void\neax_decrypt (struct eax_ctx *eax, const struct eax_key *key,\n\t     const void *cipher, nettle_cipher_func *f,\n\t     size_t length, uint8_t *dst, const uint8_t *src)\n{\n  omac_update (&eax->omac_message, key, cipher, f, length, src);\n  ctr_crypt (cipher, f, EAX_BLOCK_SIZE, eax->ctr.b, length, dst, src);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "eax_digest": {
      "start_point": [
        159,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\neax_digest (struct eax_ctx *eax, const struct eax_key *key,\n\t    const void *cipher, nettle_cipher_func *f,\n\t    size_t length, uint8_t *digest)\n{\n  assert (length > 0);\n  assert (length <= EAX_BLOCK_SIZE);\n  omac_final (&eax->omac_data, key, cipher, f);\n  omac_final (&eax->omac_message, key, cipher, f);\n\n  block16_xor (&eax->omac_nonce, &eax->omac_data);\n  memxor3 (digest, eax->omac_nonce.b, eax->omac_message.b, length);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eax.h": {},
  "nettle/nettle-3.4.1/ecc-192.c": {
    "ecc_192_modp": [
      {
        "start_point": [
          60,
          0
        ],
        "end_point": [
          82,
          1
        ],
        "content": "static void\necc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)\n{\n  mp_limb_t cy;\n\n  /* Reduce from 12 to 9 limbs (top limb small)*/\n  cy = mpn_add_n (rp + 2, rp + 2, rp + 8, 4);\n  cy = sec_add_1 (rp + 6, rp + 6, 2, cy);\n  cy += mpn_add_n (rp + 4, rp + 4, rp + 8, 4);\n  assert (cy <= 2);\n\n  rp[8] = cy;\n\n  /* Reduce from 9 to 6 limbs */\n  cy = mpn_add_n (rp, rp, rp + 6, 3);\n  cy = sec_add_1 (rp + 3, rp + 3, 2, cy);\n  cy += mpn_add_n (rp + 2, rp + 2, rp + 6, 3);\n  cy = sec_add_1 (rp + 5, rp + 5, 1, cy);\n  \n  assert (cy <= 1);\n  cy = cnd_add_n (cy, rp, ecc_Bmodp, 6);\n  assert (cy == 0);  \n}",
        "lines": 23,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          85,
          0
        ],
        "end_point": [
          106,
          1
        ],
        "content": "static void\necc_192_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)\n{\n  mp_limb_t cy;\n\n  /* Reduce from 6 to 5 limbs (top limb small)*/\n  cy = mpn_add_n (rp + 1, rp + 1, rp + 4, 2);\n  cy = sec_add_1 (rp + 3, rp + 3, 1, cy);\n  cy += mpn_add_n (rp + 2, rp + 2, rp + 4, 2);\n  assert (cy <= 2);\n\n  rp[4] = cy;\n\n  /* Reduce from 5 to 4 limbs (high limb small) */\n  cy = mpn_add_n (rp, rp, rp + 3, 2);\n  cy = sec_add_1 (rp + 2, rp + 2, 1, cy);\n  cy += mpn_add_n (rp + 1, rp + 1, rp + 3, 2);\n\n  assert (cy <= 1);\n  cy = cnd_add_n (cy, rp, ecc_Bmodp, 3);\n  assert (cy == 0);  \n}",
        "lines": 22,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "nettle_get_secp_192r1": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "const struct ecc_curve *nettle_get_secp_192r1(void)\n{\n  return &nettle_secp_192r1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "struct ecc_curve",
        "struct",
        "ecc_curve",
        "*nettle_get_secp_192r1(void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-224.c": {
    "nettle_get_secp_224r1": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "const struct ecc_curve *nettle_get_secp_224r1(void)\n{\n  return &nettle_secp_224r1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "struct ecc_curve",
        "struct",
        "ecc_curve",
        "*nettle_get_secp_224r1(void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-25519.c": {
    "ecc_25519_modp": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\necc_25519_modp(const struct ecc_modulo *m UNUSED, mp_limb_t *rp)\n{\n  mp_limb_t hi, cy;\n\n  cy = mpn_addmul_1 (rp, rp + ECC_LIMB_SIZE, ECC_LIMB_SIZE,\n\t\t     (mp_limb_t) 19 << PHIGH_BITS);\n  hi = rp[ECC_LIMB_SIZE-1];\n  cy = (cy << PHIGH_BITS) + (hi >> (GMP_NUMB_BITS - PHIGH_BITS));\n  rp[ECC_LIMB_SIZE-1] = (hi & (GMP_NUMB_MASK >> PHIGH_BITS))\n    + sec_add_1 (rp, rp, ECC_LIMB_SIZE - 1, 19 * cy);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_25519_modq": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\necc_25519_modq (const struct ecc_modulo *q, mp_limb_t *rp)\n{\n  mp_size_t n;\n  mp_limb_t cy;\n\n  /* n is the offset where we add in the next term */\n  for (n = ECC_LIMB_SIZE; n-- > 0;)\n    {\n      cy = mpn_submul_1 (rp + n,\n\t\t\t q->B_shifted, ECC_LIMB_SIZE,\n\t\t\t rp[n + ECC_LIMB_SIZE]);\n      /* Top limb of mBmodq_shifted is zero, so we get cy == 0 or 1 */\n      assert (cy < 2);\n      cnd_add_n (cy, rp+n, q->m, ECC_LIMB_SIZE);\n    }\n\n  cy = mpn_submul_1 (rp, q->m, ECC_LIMB_SIZE,\n\t\t     rp[ECC_LIMB_SIZE-1] >> (GMP_NUMB_BITS - QHIGH_BITS));\n  assert (cy < 2);\n  cnd_add_n (cy, rp, q->m, ECC_LIMB_SIZE);\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_mod_pow_2kp1": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "static void\necc_mod_pow_2kp1 (const struct ecc_modulo *m,\n\t\t  mp_limb_t *rp, const mp_limb_t *xp,\n\t\t  unsigned k, mp_limb_t *tp)\n{\n  if (k & 1)\n    {\n      ecc_mod_sqr (m, tp, xp);\n      k--;\n    }\n  else\n    {\n      ecc_mod_sqr (m, rp, xp);\n      ecc_mod_sqr (m, tp, rp);\n      k -= 2;\n    }\n  while (k > 0)\n    {\n      ecc_mod_sqr (m, rp, tp);\n      ecc_mod_sqr (m, tp, rp);\n      k -= 2;\n    }\n  ecc_mod_mul (m, rp, tp, xp);\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_mod_pow_252m3": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        177,
        1
      ],
      "content": "static void\necc_mod_pow_252m3 (const struct ecc_modulo *m,\n\t\t   mp_limb_t *rp, const mp_limb_t *ap, mp_limb_t *scratch)\n{\n#define a7 scratch\n#define t0 (scratch + ECC_LIMB_SIZE)\n#define t1 (scratch + 3*ECC_LIMB_SIZE)\n\n  /* a^{2^252 - 3} = a^{(p-5)/8}, using the addition chain\n     2^252 - 3\n     = 1 + (2^252-4)\n     = 1 + 4 (2^250-1)\n     = 1 + 4 (2^125+1)(2^125-1)\n     = 1 + 4 (2^125+1)(1+2(2^124-1))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^62-1))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(2^31-1))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(7+8(2^28-1)))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(7+8(2^14+1)(2^14-1)))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(7+8(2^14+1)(2^7+1)(2^7-1)))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(7+8(2^14+1)(2^7+1)(1+2(2^6-1))))\n     = 1 + 4 (2^125+1)(1+2(2^62+1)(2^31+1)(7+8(2^14+1)(2^7+1)(1+2(2^3+1)*7)))\n  */ \n     \n  ecc_mod_pow_2kp1 (m, t0, ap, 1, t1);\t/* a^3 */\n  ecc_mod_sqr (m, rp, t0);\t\t/* a^6 */\n  ecc_mod_mul (m, a7, rp, ap);\t\t/* a^7 */\n  ecc_mod_pow_2kp1 (m, rp, a7, 3, t0);\t/* a^63 = a^{2^6-1} */\n  ecc_mod_sqr (m, t0, rp);\t\t/* a^{2^7-2} */\n  ecc_mod_mul (m, rp, t0, ap);\t\t/* a^{2^7-1} */\n  ecc_mod_pow_2kp1 (m, t0, rp, 7, t1);\t/* a^{2^14-1}*/\n  ecc_mod_pow_2kp1 (m, rp, t0, 14, t1);\t/* a^{2^28-1} */\n  ecc_mod_sqr (m, t0, rp);\t\t/* a^{2^29-2} */\n  ecc_mod_sqr (m, t1, t0);\t\t/* a^{2^30-4} */\n  ecc_mod_sqr (m, t0, t1);\t\t/* a^{2^31-8} */\n  ecc_mod_mul (m, rp, t0, a7);\t\t/* a^{2^31-1} */\n  ecc_mod_pow_2kp1 (m, t0, rp, 31, t1);\t/* a^{2^62-1} */  \n  ecc_mod_pow_2kp1 (m, rp, t0, 62, t1);\t/* a^{2^124-1}*/\n  ecc_mod_sqr (m, t0, rp);\t\t/* a^{2^125-2} */\n  ecc_mod_mul (m, rp, t0, ap);\t\t/* a^{2^125-1} */\n  ecc_mod_pow_2kp1 (m, t0, rp, 125, t1);/* a^{2^250-1} */\n  ecc_mod_sqr (m, rp, t0);\t\t/* a^{2^251-2} */\n  ecc_mod_sqr (m, t0, rp);\t\t/* a^{2^252-4} */\n  ecc_mod_mul (m, rp, t0, ap);\t    \t/* a^{2^252-3} */\n#undef t0\n#undef t1\n#undef a7\n}",
      "lines": 47,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_25519_inv": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "static void ecc_25519_inv (const struct ecc_modulo *p,\n\t\t\t   mp_limb_t *rp, const mp_limb_t *ap,\n\t\t\t   mp_limb_t *scratch)\n{\n#define t0 scratch\n\n  /* Addition chain\n\n       p - 2 = 2^{255} - 21\n             = 1 + 2 (1 + 4 (2^{252}-3))\n  */\n  ecc_mod_pow_252m3 (p, rp, ap, t0);\n  ecc_mod_sqr (p, t0, rp);\n  ecc_mod_sqr (p, rp, t0);\n  ecc_mod_mul (p, t0, ap, rp);\n  ecc_mod_sqr (p, rp, t0);\n  ecc_mod_mul (p, t0, ap, rp);\n  mpn_copyi (rp, t0, ECC_LIMB_SIZE); /* FIXME: Eliminate copy? */\n#undef t0\n}",
      "lines": 20,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_25519_zero_p": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        221,
        1
      ],
      "content": "static int\necc_25519_zero_p (const struct ecc_modulo *p, mp_limb_t *xp)\n{\n  mp_limb_t cy;\n  mp_limb_t w;\n  mp_size_t i;\n#if PHIGH_BITS > 0\n  mp_limb_t hi = xp[ECC_LIMB_SIZE-1];\n  xp[ECC_LIMB_SIZE-1] = (hi & (GMP_NUMB_MASK >> PHIGH_BITS))\n    + sec_add_1 (xp, xp, ECC_LIMB_SIZE - 1, 19 * (hi >> (GMP_NUMB_BITS - PHIGH_BITS)));\n#endif\n  cy = mpn_sub_n (xp, xp, p->m, ECC_LIMB_SIZE);\n  cnd_add_n (cy, xp, p->m, ECC_LIMB_SIZE);\n\n  for (i = 0, w = 0; i < ECC_LIMB_SIZE; i++)\n    w |= xp[i];\n  return w == 0;\n}",
      "lines": 18,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecc_25519_sqrt": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        290,
        1
      ],
      "content": "static int\necc_25519_sqrt(const struct ecc_modulo *p, mp_limb_t *rp,\n\t       const mp_limb_t *up, const mp_limb_t *vp,\n\t       mp_limb_t *scratch)\n{\n  int pos, neg;\n\n#define uv3 scratch\n#define uv7 (scratch + ECC_LIMB_SIZE)\n#define uv7p (scratch + 2*ECC_LIMB_SIZE)\n#define v2 (scratch + 2*ECC_LIMB_SIZE)\n#define uv (scratch + 3*ECC_LIMB_SIZE)\n#define v4 (scratch + 3*ECC_LIMB_SIZE)\n\n#define scratch_out (scratch + 4 * ECC_LIMB_SIZE)\n\n#define x2 scratch\n#define vx2 (scratch + ECC_LIMB_SIZE)\n#define t0 (scratch + 2*ECC_LIMB_SIZE)\n\n\t\t\t\t\t/* Live values */\n  ecc_mod_sqr (p, v2, vp);\t\t/* v2 */\n  ecc_mod_mul (p, uv, up, vp);\t\t/* uv, v2 */\n  ecc_mod_mul (p, uv3, uv, v2);\t\t/* uv3, v2 */\n  ecc_mod_sqr (p, v4, v2);\t\t/* uv3, v4 */\n  ecc_mod_mul (p, uv7, uv3, v4);\t/* uv3, uv7 */\n  ecc_mod_pow_252m3 (p, uv7p, uv7, scratch_out); /* uv3, uv7p */\n  ecc_mod_mul (p, rp, uv7p, uv3);\t/* none */\n\n  /* Check sign. If square root exists, have v x^2 = \u00c2\u00b1u */\n  ecc_mod_sqr (p, x2, rp);\n  ecc_mod_mul (p, vx2, x2, vp);\n  ecc_mod_add (p, t0, vx2, up);\n  neg = ecc_25519_zero_p (p, t0);\n  ecc_mod_sub (p, t0, up, vx2);\n  pos = ecc_25519_zero_p (p, t0);\n\n  ecc_mod_mul (p, t0, rp, ecc_sqrt_z);\n  cnd_copy (neg, rp, t0, ECC_LIMB_SIZE);\n  return pos | neg;\n\n#undef uv3\n#undef uv7\n#undef uv7p\n#undef v2\n#undef v4\n#undef scratch_out\n#undef x2\n#undef vx2\n#undef t0\n}",
      "lines": 51,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-256.c": {
    "ecc_256_modp": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\necc_256_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t u1, u0;\n  mp_size_t n;\n\n  n = 2*p->size;\n  u1 = rp[--n];\n  u0 = rp[n-1];\n\n  /* This is not particularly fast, but should work well with assembly implementation. */\n  for (; n >= p->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, cy;\n\n      /* <q2, q1, q0> = v * u1 + <u1,u0>, with v = 2^32 - 1:\n\n\t   +---+---+\n\t   | u1| u0|\n\t   +---+---+\n\t       |-u1|\n\t     +-+-+-+\n\t     | u1|\n       +---+-+-+-+-+\n       | q2| q1| q0|\n       +---+---+---+\n      */\n      q1 = u1 - (u1 > u0);\n      q0 = u0 - u1;\n      t = u1 << 32;\n      q0 += t;\n      t = (u1 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n\n      /* Compute candidate remainder */\n      u1 = u0 + (q1 << 32) - q1;\n      t = -(mp_limb_t) (u1 > q0);\n      u1 -= t & 0xffffffff;\n      q1 += t;\n      q2 += t + (q1 < t);\n\n      assert (q2 < 2);\n\n      /*\n\t n-1 n-2 n-3 n-4\n        +---+---+---+---+\n        | u1| u0| u low |\n        +---+---+---+---+\n          - | q1(2^96-1)|\n            +-------+---+\n            |q2(2^.)|\n            +-------+\n\n\t We multiply by two low limbs of p, 2^96 - 1, so we could use\n\t shifts rather than mul.\n      */\n      t = mpn_submul_1 (rp + n - 4, p->m, 2, q1);\n      t += cnd_sub_n (q2, rp + n - 3, p->m, 1);\n      t += (-q2) & 0xffffffff;\n\n      u0 = rp[n-2];\n      cy = (u0 < t);\n      u0 -= t;\n      t = (u1 < cy);\n      u1 -= cy;\n\n      cy = cnd_add_n (t, rp + n - 4, p->m, 2);\n      u0 += cy;\n      u1 += (u0 < cy);\n      u1 -= (-t) & 0xffffffff;\n    }\n  rp[2] = u0;\n  rp[3] = u1;\n}",
      "lines": 75,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_256_modq": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\necc_256_modq (const struct ecc_modulo *q, mp_limb_t *rp)\n{\n  mp_limb_t u2, u1, u0;\n  mp_size_t n;\n\n  n = 2*q->size;\n  u2 = rp[--n];\n  u1 = rp[n-1];\n\n  /* This is not particularly fast, but should work well with assembly implementation. */\n  for (; n >= q->size; n--)\n    {\n      mp_limb_t q2, q1, q0, t, c1, c0;\n\n      u0 = rp[n-2];\n      \n      /* <q2, q1, q0> = v * u2 + <u2,u1>, same method as above.\n\n\t   +---+---+\n\t   | u2| u1|\n\t   +---+---+\n\t       |-u2|\n\t     +-+-+-+\n\t     | u2|\n       +---+-+-+-+-+\n       | q2| q1| q0|\n       +---+---+---+\n      */\n      q1 = u2 - (u2 > u1);\n      q0 = u1 - u2;\n      t = u2 << 32;\n      q0 += t;\n      t = (u2 >> 32) + (q0 < t) + 1;\n      q1 += t;\n      q2 = q1 < t;\n\n      /* Compute candidate remainder, <u1, u0> - <q2, q1> * (2^128 - 2^96 + 2^64 - 1)\n         <u1, u0> + 2^64 q2 + (2^96 - 2^64 + 1) q1 (mod 2^128)\n\n\t   +---+---+\n\t   | u1| u0|\n\t   +---+---+\n\t   | q2| q1|\n\t   +---+---+\n\t   |-q1|\n\t +-+-+-+\n\t | q1|\n       --+-+-+-+---+\n           | u2| u1|\n\t   +---+---+\n      */\t \n      u2 = u1 + q2 - q1;\n      u1 = u0 + q1;\n      u2 += (u1 < q1);\n      u2 += (q1 << 32);\n\n      t = -(mp_limb_t) (u2 >= q0);\n      q1 += t;\n      q2 += t + (q1 < t);\n      u1 += t;\n      u2 += (t << 32) + (u1 < t);\n\n      assert (q2 < 2);\n\n      c0 = cnd_sub_n (q2, rp + n - 3, q->m, 1);\n      c0 += (-q2) & q->m[1];\n      t = mpn_submul_1 (rp + n - 4, q->m, 2, q1);\n      c0 += t;\n      c1 = c0 < t;\n      \n      /* Construct underflow condition. */\n      c1 += (u1 < c0);\n      t = - (mp_limb_t) (u2 < c1);\n\n      u1 -= c0;\n      u2 -= c1;\n\n      /* Conditional add of p */\n      u1 += t;\n      u2 += (t<<32) + (u1 < t);\n\n      t = cnd_add_n (t, rp + n - 4, q->m, 2);\n      u1 += t;\n      u2 += (u1 < t);\n    }\n  rp[2] = u1;\n  rp[3] = u2;\n}",
      "lines": 89,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nettle_get_secp_256r1": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        306,
        1
      ],
      "content": "const struct ecc_curve *nettle_get_secp_256r1(void)\n{\n  return &nettle_secp_256r1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "struct ecc_curve",
        "struct",
        "ecc_curve",
        "*nettle_get_secp_256r1(void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-384.c": {
    "ecc_384_modp": [
      {
        "start_point": [
          63,
          0
        ],
        "end_point": [
          103,
          1
        ],
        "content": "static void\necc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t cy, bw;\n\n  /* Reduce from 24 to 17 limbs. */\n  cy = mpn_add_n (rp + 4, rp + 4, rp + 16, 8);\n  cy = sec_add_1 (rp + 12, rp + 12, 3, cy);\n\n  bw = mpn_sub_n (rp + 5, rp + 5, rp + 16, 8);\n  bw = sec_sub_1 (rp + 13, rp + 13, 3, bw);\n\n  cy += mpn_add_n (rp + 7, rp + 7, rp + 16, 8);\n  cy = sec_add_1 (rp + 15, rp + 15, 1, cy);\n\n  cy += mpn_add_n (rp + 8, rp + 8, rp + 16, 8);\n  assert (bw <= cy);\n  cy -= bw;\n\n  assert (cy <= 2);  \n  rp[16] = cy;\n\n  /* Reduce from 17 to 12 limbs */\n  cy = mpn_add_n (rp, rp, rp + 12, 5);\n  cy = sec_add_1 (rp + 5, rp + 5, 3, cy);\n  \n  bw = mpn_sub_n (rp + 1, rp + 1, rp + 12, 5);\n  bw = sec_sub_1 (rp + 6, rp + 6, 6, bw);\n  \n  cy += mpn_add_n (rp + 3, rp + 3, rp + 12, 5);\n  cy = sec_add_1 (rp + 8, rp + 8, 1, cy);\n\n  cy += mpn_add_n (rp + 4, rp + 4, rp + 12, 5);\n  cy = sec_add_1 (rp + 9, rp + 9, 3, cy);\n\n  assert (cy >= bw);\n  cy -= bw;\n  assert (cy <= 1);\n  cy = cnd_add_n (cy, rp, p->B, ECC_LIMB_SIZE);\n  assert (cy == 0);\n}",
        "lines": 41,
        "depth": 8,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          107,
          0
        ],
        "end_point": [
          144,
          1
        ],
        "content": "static void\necc_384_modp (const struct ecc_modulo *p, mp_limb_t *rp)\n{\n  mp_limb_t tp[6];\n  mp_limb_t cy;\n\n  /* Reduce from 12 to 9 limbs */\n  tp[0] = 0; /* FIXME: Could use mpn_sub_nc */\n  mpn_copyi (tp + 1, rp + 8, 3);\n  tp[4] = rp[11] - mpn_sub_n (tp, tp, rp + 8, 4);\n  tp[5] = mpn_lshift (tp, tp, 5, 32);\n\n  cy = mpn_add_n (rp + 2, rp + 2, rp + 8, 4);\n  cy = sec_add_1 (rp + 6, rp + 6, 2, cy);\n\n  cy += mpn_add_n (rp + 2, rp + 2, tp, 6);\n  cy += mpn_add_n (rp + 4, rp + 4, rp + 8, 4);\n\n  assert (cy <= 2);\n  rp[8] = cy;\n\n  /* Reduce from 9 to 6 limbs */\n  tp[0] = 0;\n  mpn_copyi (tp + 1, rp + 6, 2);\n  tp[3] = rp[8] - mpn_sub_n (tp, tp, rp + 6, 3);\n  tp[4] = mpn_lshift (tp, tp, 4, 32);\n\n  cy = mpn_add_n (rp, rp, rp + 6, 3);\n  cy = sec_add_1 (rp + 3, rp + 3, 2, cy);\n  cy += mpn_add_n (rp, rp, tp, 5);\n  cy += mpn_add_n (rp + 2, rp + 2, rp + 6, 3);\n\n  cy = sec_add_1 (rp + 5, rp + 5, 1, cy);\n  assert (cy <= 1);\n\n  cy = cnd_add_n (cy, rp, p->B, ECC_LIMB_SIZE);\n  assert (cy == 0);  \n}",
        "lines": 38,
        "depth": 9,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "nettle_get_secp_384r1": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        214,
        1
      ],
      "content": "const struct ecc_curve *nettle_get_secp_384r1(void)\n{\n  return &nettle_secp_384r1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "struct ecc_curve",
        "struct",
        "ecc_curve",
        "*nettle_get_secp_384r1(void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-521.c": {
    "ecc_521_modp": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static void\necc_521_modp (const struct ecc_modulo *m UNUSED, mp_limb_t *rp)\n{\n  /* FIXME: Should use mpn_addlsh_n_ip1 */\n  mp_limb_t hi;\n  /* Reduce from 2*ECC_LIMB_SIZE to ECC_LIMB_SIZE + 1 */\n  rp[ECC_LIMB_SIZE]\n    = mpn_addmul_1 (rp, rp + ECC_LIMB_SIZE, ECC_LIMB_SIZE, BMODP);\n  hi = mpn_addmul_1 (rp, rp + ECC_LIMB_SIZE, 1, BMODP);\n  hi = sec_add_1 (rp + 1, rp + 1, ECC_LIMB_SIZE - 1, hi);\n\n  /* Combine hi with top bits, and add in. */\n  hi = (hi << BMODP_SHIFT) | (rp[ECC_LIMB_SIZE-1] >> B_SHIFT);\n  rp[ECC_LIMB_SIZE-1] = (rp[ECC_LIMB_SIZE-1]\n\t\t\t & (((mp_limb_t) 1 << B_SHIFT)-1))\n    + sec_add_1 (rp, rp, ECC_LIMB_SIZE - 1, hi);\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "nettle_get_secp_521r1": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "const struct ecc_curve *nettle_get_secp_521r1(void)\n{\n  return &nettle_secp_521r1;\n}",
      "lines": 4,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "struct ecc_curve",
        "struct",
        "ecc_curve",
        "*nettle_get_secp_521r1(void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-a-to-j.c": {
    "ecc_a_to_j": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\necc_a_to_j (const struct ecc_curve *ecc,\n\t    mp_limb_t *r, const mp_limb_t *p)\n{\n  if (ecc->use_redc)\n    {\n      mpn_copyd (r + ecc->p.size, p, 2*ecc->p.size);\n\n      mpn_zero (r, ecc->p.size);\n      ecc->p.mod (&ecc->p, r);\n\n      mpn_zero (r + ecc->p.size, ecc->p.size);\n      ecc->p.mod (&ecc->p, r + ecc->p.size);\n    }\n  else if (r != p)\n    mpn_copyi (r, p, 2*ecc->p.size);\n\n  mpn_copyi (r + 2*ecc->p.size, ecc->unit, ecc->p.size);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-add-eh.c": {
    "ecc_add_eh": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\necc_add_eh (const struct ecc_curve *ecc,\n\t    mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,\n\t    mp_limb_t *scratch)\n{\n#define x1 p\n#define y1 (p + ecc->p.size)\n#define z1 (p + 2*ecc->p.size)\n\n#define x2 q\n#define y2 (q + ecc->p.size)\n\n#define x3 r\n#define y3 (r + ecc->p.size)\n#define z3 (r + 2*ecc->p.size)\n\n  /* Formulas (from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl):\n\n     Computation\tOperation\tLive variables\n\n     C = x1*x2\t\tmul\t\tC\n     D = y1*y2\t\tmul\t\tC, D\n     T = (x1+y1)(x2+y2) - C - D\t\tC, D, T\n     E = b*C*D\t\t2 mul\t\tC, E, T  (Replace C <-- D - C)\n     B = z1^2\t\tsqr\t\tB, C, E, T\n     F = B - E\t\t\t\tB, C, E, F, T\n     G = B + E     \t\t\tC, F, G, T\n     x3 = z1*F*T\t3 mul\t\tC, F, G, T\n     y3 = z1*G*(D-C)\t2 mul\t\tF, G\n     z3 = F*G\t\tmul\n  */\n#define C (scratch)\n#define D (scratch + 1*ecc->p.size)\n#define T (scratch + 2*ecc->p.size)\n#define E (scratch + 3*ecc->p.size) \n#define B (scratch + 4*ecc->p.size)\n#define F D\n#define G E\n  \n  ecc_modp_mul (ecc, C, x1, x2);\n  ecc_modp_mul (ecc, D, y1, y2);\n  ecc_modp_add (ecc, x3, x1, y1);\n  ecc_modp_add (ecc, y3, x2, y2);\n  ecc_modp_mul (ecc, T, x3, y3);\n  ecc_modp_sub (ecc, T, T, C);\n  ecc_modp_sub (ecc, T, T, D);\n  ecc_modp_mul (ecc, x3, C, D);\n  ecc_modp_mul (ecc, E, x3, ecc->b);\n\n  ecc_modp_add (ecc, C, D, C); /* ! */\n  ecc_modp_sqr (ecc, B, z1);\n  ecc_modp_sub (ecc, F, B, E);\n  ecc_modp_add (ecc, G, B, E);  \n\n  /* x3 */\n  ecc_modp_mul (ecc, B, G, T); /* ! */\n  ecc_modp_mul (ecc, x3, B, z1);\n\n  /* y3 */\n  ecc_modp_mul (ecc, B, F, z1); /* ! */\n  ecc_modp_mul (ecc, y3, B, C); /* Clobbers z1 in case r == p. */\n\n  /* z3 */\n  ecc_modp_mul (ecc, B, F, G);\n  mpn_copyi (z3, B, ecc->p.size);\n}",
      "lines": 67,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-add-ehh.c": {
    "ecc_add_ehh": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\necc_add_ehh (const struct ecc_curve *ecc,\n\t     mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,\n\t     mp_limb_t *scratch)\n{\n#define x1 p\n#define y1 (p + ecc->p.size)\n#define z1 (p + 2*ecc->p.size)\n\n#define x2 q\n#define y2 (q + ecc->p.size)\n#define z2 (q + 2*ecc->p.size)\n\n#define x3 r\n#define y3 (r + ecc->p.size)\n#define z3 (r + 2*ecc->p.size)\n\n  /* Formulas (from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#addition-add-2007-bl):\n\n     Computation\tOperation\tLive variables\n\n     C = x1*x2\t\tmul\t\tC\n     D = y1*y2\t\tmul\t\tC, D\n     T = (x1+y1)(x2+y2) - C - D, mul\tC, D, T\n     E = b*C*D\t\t2 mul\t\tC, E, T (Replace C <-- D - C)\n     A = z1*z2\t\tmul\t\tA, C, E, T\n     B = A^2\t\tsqr\t\tA, B, C, E, T\n     F = B - E\t\t\t\tA, B, C, E, F, T\n     G = B + E     \t\t\tA, C, F, G, T\n     x3 = A*F*T\t\t2 mul\t\tA, C, G\n     y3 = A*G*(D-C)\t2 mul\t\tF, G\n     z3 = F*G\t\tmul\n\n     But when working with the twist curve, we have to negate the\n     factor C = x1*x2. We change subtract to add in the y3\n     expression, and swap F and G.\n  */\n#define C scratch\n#define D (scratch + ecc->p.size)\n#define T (scratch + 2*ecc->p.size)\n#define E (scratch + 3*ecc->p.size) \n#define A (scratch + 4*ecc->p.size)\n#define B (scratch + 5*ecc->p.size)\n#define F D\n#define G E\n\n  ecc_modp_mul (ecc, C, x1, x2);\n  ecc_modp_mul (ecc, D, y1, y2);\n  ecc_modp_add (ecc, A, x1, y1);\n  ecc_modp_add (ecc, B, x2, y2);\n  ecc_modp_mul (ecc, T, A, B);\n  ecc_modp_sub (ecc, T, T, C);\n  ecc_modp_sub (ecc, T, T, D);\n  ecc_modp_mul (ecc, x3, C, D);\n  ecc_modp_mul (ecc, E, x3, ecc->b);\n  ecc_modp_add (ecc, C, D, C);\t/* ! */\n  \n  ecc_modp_mul (ecc, A, z1, z2);\n  ecc_modp_sqr (ecc, B, A);\n\n  ecc_modp_sub (ecc, F, B, E);\n  ecc_modp_add (ecc, G, B, E);\n\n  /* x3 */\n  ecc_modp_mul (ecc, B, G, T); /* ! */\n  ecc_modp_mul (ecc, x3, B, A);\n\n  /* y3 */\n  ecc_modp_mul (ecc, B, F, C); /* ! */\n  ecc_modp_mul (ecc, y3, B, A);\n\n  /* z3 */\n  ecc_modp_mul (ecc, B, F, G);\n  mpn_copyi (z3, B, ecc->p.size);\n}",
      "lines": 76,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-add-jja.c": {
    "ecc_add_jja": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\necc_add_jja (const struct ecc_curve *ecc,\n\t     mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,\n\t     mp_limb_t *scratch)\n{\n  /* Formulas, from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b):\n\n     Computation\t\tOperation\tLive variables\n     \n      ZZ = Z_1^2\t\tsqr\t\tZZ\n      H = X_2*ZZ - X_1\t\tmul (djb: U_2)\tZZ, H\n      HH = H^2\t\t\tsqr\t\tZZ, H, HH\n      ZZZ = ZZ*Z_1\t\tmul\t\tZZ, H, HH, ZZZ\n      Z_3 = (Z_1+H)^2-ZZ-HH\tsqr\t\tH, HH, ZZZ\n      W = 2 (Y_2*ZZZ - Y_1)\tmul (djb: S_2)\tH, HH, W\n      I = 4*HH\t\t\t\t\tH, W, I\n      J = H*I\t\t\tmul\t\tW, I, J\n      V = X_1*I\t\t\tmul\t\tW, J, V\n      X_3 = W^2-J-2*V\t\tsqr\t\tW, J, V\n      Y_3 = W*(V-X_3)-2*Y_1*J\tmul, mul\n  */\n#define zz  scratch\n#define h  (scratch + ecc->p.size)\n#define hh (scratch + 2*ecc->p.size)\n#define w  (scratch + 3*ecc->p.size)\n#define j  (scratch + 4*ecc->p.size)\n#define v   scratch\n\n#define x1  p\n#define y1 (p + ecc->p.size)\n#define z1 (p + 2*ecc->p.size)\n#define x2  q\n#define y2 (q + ecc->p.size)\n\n  /* zz */\n  ecc_modp_sqr (ecc, zz, z1);\n  /* h*/\n  ecc_modp_mul (ecc, h, x2, zz);\n  ecc_modp_sub (ecc, h, h, x1);\n  /* hh */\n  ecc_modp_sqr (ecc, hh, h);\n  /* Do z^3 early, store at w. */\n  ecc_modp_mul (ecc, w, zz, z1);\n  /* z_3, use j area for scratch */\n  ecc_modp_add (ecc, r + 2*ecc->p.size, p + 2*ecc->p.size, h);\n  ecc_modp_sqr (ecc, j, r + 2*ecc->p.size);\n  ecc_modp_sub (ecc, j, j, zz);\n  ecc_modp_sub (ecc, r + 2*ecc->p.size, j, hh);\n  \n  /* w */\n  ecc_modp_mul (ecc, j, y2, w);\n  ecc_modp_sub (ecc, w, j, y1);\n  ecc_modp_mul_1 (ecc, w, w, 2);\n  \n  /* i replaces hh, j */\n  ecc_modp_mul_1 (ecc, hh, hh, 4);\n  ecc_modp_mul (ecc, j, hh, h);\n\n  /* v */\n  ecc_modp_mul (ecc, v, x1, hh);\n\n  /* x_3, use (h, hh) as sqratch */  \n  ecc_modp_sqr (ecc, h, w);\n  ecc_modp_sub (ecc, r, h, j);\n  ecc_modp_submul_1 (ecc, r, v, 2);\n\n  /* y_3, use (h, hh) as sqratch */\n  ecc_modp_mul (ecc, h, y1, j); /* frees j */\n  ecc_modp_sub (ecc, r + ecc->p.size, v, r);\n  ecc_modp_mul (ecc, j, r + ecc->p.size, w);\n  ecc_modp_submul_1 (ecc, j, h, 2);\n  mpn_copyi (r + ecc->p.size, j, ecc->p.size);\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-add-jjj.c": {
    "ecc_add_jjj": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "void\necc_add_jjj (const struct ecc_curve *ecc,\n\t     mp_limb_t *r, const mp_limb_t *p, const mp_limb_t *q,\n\t     mp_limb_t *scratch)\n{\n  /* Formulas, from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#addition-add-2007-bl:\n\n     Computation\t\tOperation\tLive variables\n\n      Z1Z1 = Z1^2\t\tsqr\t\tZ1Z1\n      Z2Z2 = Z2^2\t\tsqr\t\tZ1Z1, Z2Z2\n      U1 = X1*Z2Z2\t\tmul\t\tZ1Z1, Z2Z2, U1\n      U2 = X2*Z1Z1\t\tmul\t\tZ1Z1, Z2Z2, U1, U2\n      H = U2-U1\t\t\t\t\tZ1Z1, Z2Z2, U1, H\n      Z3 = ((Z1+Z2)^2-Z1Z1-Z2Z2)*H sqr, mul\tZ1Z1, Z2Z2, U1, H\n      S1 = Y1*Z2*Z2Z2\t\tmul, mul\tZ1Z1, U1, H, S1\n      S2 = Y2*Z1*Z1Z1\t\tmul, mul\tU1, H, S1, S2\n      W = 2*(S2-S1)\t(djb: r)\t\tU1, H, S1, W\n      I = (2*H)^2\t\tsqr\t\tU1, H, S1, W, I\n      J = H*I\t\t\tmul\t\tU1, S1, W, J, V\n      V = U1*I\t\t\tmul\t\tS1, W, J, V\n      X3 = W^2-J-2*V\t\tsqr\t\tS1, W, J, V\n      Y3 = W*(V-X3)-2*S1*J\tmul, mul\n  */\n  mp_limb_t *z1z1 = scratch;\n  mp_limb_t *z2z2 = scratch + ecc->p.size;\n  mp_limb_t *u1   = scratch + 2*ecc->p.size;\n  mp_limb_t *u2   = scratch + 3*ecc->p.size;\n  mp_limb_t *s1   = scratch; /* overlap z1z1 */\n  mp_limb_t *s2   = scratch + ecc->p.size; /* overlap z2z2 */\n  mp_limb_t *i    = scratch + 4*ecc->p.size;\n  mp_limb_t *j    = scratch + 5*ecc->p.size;\n  mp_limb_t *v    = scratch + 6*ecc->p.size;\n\n  /* z1^2, z2^2, u1 = x1 x2^2, u2 = x2 z1^2 - u1 */\n  ecc_modp_sqr (ecc, z1z1, p + 2*ecc->p.size);\n  ecc_modp_sqr (ecc, z2z2, q + 2*ecc->p.size);\n  ecc_modp_mul (ecc, u1, p, z2z2);\n  ecc_modp_mul (ecc, u2, q, z1z1);\n  ecc_modp_sub (ecc, u2, u2, u1);  /* Store h in u2 */\n\n  /* z3, use i, j, v as scratch, result at i. */\n  ecc_modp_add (ecc, i, p + 2*ecc->p.size, q + 2*ecc->p.size);\n  ecc_modp_sqr (ecc, v, i);\n  ecc_modp_sub (ecc, v, v, z1z1);\n  ecc_modp_sub (ecc, v, v, z2z2);\n  ecc_modp_mul (ecc, i, v, u2);\n  /* Delayed write, to support in-place operation. */\n\n  /* s1 = y1 z2^3, s2 = y2 z1^3, scratch at j and v */\n  ecc_modp_mul (ecc, j, z1z1, p + 2*ecc->p.size); /* z1^3 */\n  ecc_modp_mul (ecc, v, z2z2, q + 2*ecc->p.size); /* z2^3 */\n  ecc_modp_mul (ecc, s1, p + ecc->p.size, v);\n  ecc_modp_mul (ecc, v, j, q + ecc->p.size);\n  ecc_modp_sub (ecc, s2, v, s1);\n  ecc_modp_mul_1 (ecc, s2, s2, 2);\n\n  /* Store z3 */\n  mpn_copyi (r + 2*ecc->p.size, i, ecc->p.size);\n\n  /* i, j, v */\n  ecc_modp_sqr (ecc, i, u2);\n  ecc_modp_mul_1 (ecc, i, i, 4);\n  ecc_modp_mul (ecc, j, u2, i);\n  ecc_modp_mul (ecc, v, u1, i);\n\n  /* now, u1, u2 and i are free for reuse .*/\n  /* x3, use u1, u2 as scratch */\n  ecc_modp_sqr (ecc, u1, s2);\n  ecc_modp_sub (ecc, r, u1, j);\n  ecc_modp_submul_1 (ecc, r, v, 2);\n\n  /* y3 */\n  ecc_modp_mul (ecc, u1, s1, j); /* Frees j */\n  ecc_modp_sub (ecc, u2, v, r);  /* Frees v */\n  ecc_modp_mul (ecc, i, s2, u2);\n  ecc_modp_submul_1 (ecc, i, u1, 2);\n  mpn_copyi (r + ecc->p.size, i, ecc->p.size);\n}",
      "lines": 80,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-curve.h": {},
  "nettle/nettle-3.4.1/ecc-dup-eh.c": {
    "ecc_dup_eh": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        104,
        1
      ],
      "content": "void\necc_dup_eh (const struct ecc_curve *ecc,\n\t    mp_limb_t *r, const mp_limb_t *p,\n\t    mp_limb_t *scratch)\n{\n  /* Formulas (from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-edwards-projective.html#doubling-dbl-2007-bl):\n\n     Computation\tOperation\tLive variables\n     \n     b = (x+y)^2\tsqr\t\tb\n     c = x^2\t\tsqr\t\tb, c\n     d = y^2\t\tsqr\t\tb, c, d\n     e = c+d\t\t\t\tb, c, d, e\n     h = z^2\t\tsqr\t\tb, c, d, e, h\n     j = e-2*h\t\t\t\tb, c, d, e, j\n     x' = (b-e)*j\tmul\t\tc, d, e, j\n     y' = e*(c-d)\tmul\t\te, j\n     z' = e*j\t\tmul\n\n     But for the twisted curve, we need some sign changes.\n\n     b = (x+y)^2\tsqr\t\tb\n     c = x^2\t\tsqr\t\tb, c\n     d = y^2\t\tsqr\t\tb, c, d\n   ! e = -c+d\t\t\t\tb, c, d, e\n     h = z^2\t\tsqr\t\tb, c, d, e, h\n   ! j = -e+2*h\t\t\t\tb, c, d, e, j\n   ! x' = (b-c-d)*j\tmul\t\tc, d, e, j\n   ! y' = e*(c+d)\tmul\t\te, j\n     z' = e*j\t\tmul\n  */\n#define b scratch \n#define c (scratch  + ecc->p.size)\n#define d (scratch  + 2*ecc->p.size)\n#define e (scratch  + 3*ecc->p.size)\n#define j (scratch  + 4*ecc->p.size)\n\n  /* b */\n  ecc_modp_add (ecc, e, p, p + ecc->p.size);\n  ecc_modp_sqr (ecc, b, e);\n\n  /* c */\n  ecc_modp_sqr (ecc, c, p);\n  /* d */\n  ecc_modp_sqr (ecc, d, p + ecc->p.size);\n  /* h, can use r as scratch, even for in-place operation. */\n  ecc_modp_sqr (ecc, r, p + 2*ecc->p.size);\n  /* e, */\n  ecc_modp_sub (ecc, e, d, c);\n  /* b - c - d */\n  ecc_modp_sub (ecc, b, b, c);\n  ecc_modp_sub (ecc, b, b, d);\n  /* j */\n  ecc_modp_add (ecc, r, r, r);\n  ecc_modp_sub (ecc, j, r, e);\n\n  /* x' */\n  ecc_modp_mul (ecc, r, b, j);\n  /* y' */\n  ecc_modp_add (ecc, c, c, d); /* Redundant */\n  ecc_modp_mul (ecc, r + ecc->p.size, e, c);\n  /* z' */\n  ecc_modp_mul (ecc, b, e, j);\n  mpn_copyi (r + 2*ecc->p.size, b, ecc->p.size);\n}",
      "lines": 66,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-dup-jj.c": {
    "ecc_dup_jj": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\necc_dup_jj (const struct ecc_curve *ecc,\n\t    mp_limb_t *r, const mp_limb_t *p,\n\t    mp_limb_t *scratch)\n{\n  /* Formulas (from djb,\n     http://www.hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b):\n\n     Computation\t\t\tOperation\tLive variables\n     delta = z^2\t\t\tsqr\t\tdelta\n     gamma = y^2\t\t\tsqr\t\tdelta, gamma\n     z' = (y+z)^2-gamma-delta\t\tsqr\t\tdelta, gamma\n     alpha = 3*(x-delta)*(x+delta)\tmul\t\tgamma, beta, alpha\n     beta = x*gamma\t\t\tmul\t\tgamma, beta, alpha\n     x' = alpha^2-8*beta\t\tsqr\t\tgamma, beta, alpha\n     y' = alpha*(4*beta-x')-8*gamma^2\tmul, sqr\n  */\n\n#define delta  scratch\n#define gamma (scratch + ecc->p.size)\n#define beta  (scratch + 2*ecc->p.size)\n#define g2    (scratch + 3*ecc->p.size)\n#define sum   (scratch + 4*ecc->p.size)\n#define alpha  scratch /* Overlap delta */\n  \n#define xp p\n#define yp (p + ecc->p.size)\n#define zp (p + 2*ecc->p.size)\n  \n  /* delta */\n  ecc_modp_sqr (ecc, delta, zp);\n\n  /* gamma */\n  ecc_modp_sqr (ecc, gamma, yp);\n\n  /* z'. Can use beta area as scratch. */\n  ecc_modp_add (ecc, r + 2*ecc->p.size, yp, zp);\n  ecc_modp_sqr (ecc, beta, r + 2*ecc->p.size);\n  ecc_modp_sub (ecc, beta, beta, gamma);\n  ecc_modp_sub (ecc, r + 2*ecc->p.size, beta, delta);\n  \n  /* alpha. Can use beta area as scratch, and overwrite delta. */\n  ecc_modp_add (ecc, sum, xp, delta);\n  ecc_modp_sub (ecc, delta, xp, delta);\n  ecc_modp_mul (ecc, beta, sum, delta);\n  ecc_modp_mul_1 (ecc, alpha, beta, 3);\n\n  /* beta */\n  ecc_modp_mul (ecc, beta, xp, gamma);\n\n  /* Do gamma^2 and 4*beta early, to get them out of the way. We can\n     then use the old area at gamma as scratch. */\n  ecc_modp_sqr (ecc, g2, gamma);\n  ecc_modp_mul_1 (ecc, sum, beta, 4);\n  \n  /* x' */\n  ecc_modp_sqr (ecc, gamma, alpha);   /* Overwrites gamma and beta */\n  ecc_modp_submul_1 (ecc, gamma, sum, 2);\n  mpn_copyi (r, gamma, ecc->p.size);\n\n  /* y' */\n  ecc_modp_sub (ecc, sum, sum, r);\n  ecc_modp_mul (ecc, gamma, sum, alpha);\n  ecc_modp_submul_1 (ecc, gamma, g2, 8);\n  mpn_copyi (r + ecc->p.size, gamma, ecc->p.size);\n}",
      "lines": 66,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-ecdsa-sign.c": {
    "ecc_ecdsa_sign_itch": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "mp_size_t\necc_ecdsa_sign_itch (const struct ecc_curve *ecc)\n{\n  /* Needs 3*ecc->p.size + scratch for ecc->mul_g. Currently same for\n     ecc_mul_g and ecc_mul_g_eh. */\n  return ECC_ECDSA_SIGN_ITCH (ecc->p.size);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "ecc_ecdsa_sign": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\necc_ecdsa_sign (const struct ecc_curve *ecc,\n\t\tconst mp_limb_t *zp,\n\t\t/* Random nonce, must be invertible mod ecc group\n\t\t   order. */\n\t\tconst mp_limb_t *kp,\n\t\tsize_t length, const uint8_t *digest,\n\t\tmp_limb_t *rp, mp_limb_t *sp,\n\t\tmp_limb_t *scratch)\n{\n#define P\t    scratch\n#define kinv\t    scratch                /* Needs 5*ecc->p.size for computation */\n#define hp\t    (scratch  + ecc->p.size) /* NOTE: ecc->p.size + 1 limbs! */\n#define tp\t    (scratch + 2*ecc->p.size)\n  /* Procedure, according to RFC 6090, \"KT-I\". q denotes the group\n     order.\n\n     1. k <-- uniformly random, 0 < k < q\n\n     2. R <-- (r_x, r_y) = k g\n\n     3. s1 <-- r_x mod q\n\n     4. s2 <-- (h + z*s1)/k mod q.\n  */\n\n  ecc->mul_g (ecc, P, kp, P + 3*ecc->p.size);\n  /* x coordinate only, modulo q */\n  ecc->h_to_a (ecc, 2, rp, P, P + 3*ecc->p.size);\n\n  /* Invert k, uses 4 * ecc->p.size including scratch */\n  ecc->q.invert (&ecc->q, kinv, kp, tp); /* NOTE: Also clobbers hp */\n  \n  /* Process hash digest */\n  ecc_hash (&ecc->q, hp, length, digest);\n\n  ecc_modq_mul (ecc, tp, zp, rp);\n  ecc_modq_add (ecc, hp, hp, tp);\n  ecc_modq_mul (ecc, tp, hp, kinv);\n\n  mpn_copyi (sp, tp, ecc->p.size);\n#undef P\n#undef hp\n#undef kinv\n#undef tp\n}",
      "lines": 46,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-ecdsa-verify.c": {
    "zero_p": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static int\nzero_p (const mp_limb_t *xp, mp_size_t n)\n{\n  while (n > 0)\n    if (xp[--n] > 0)\n      return 0;\n  return 1;\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecdsa_in_range": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static int\necdsa_in_range (const struct ecc_curve *ecc, const mp_limb_t *xp)\n{\n  return !zero_p (xp, ecc->p.size)\n    && mpn_cmp (xp, ecc->q.m, ecc->p.size) < 0;\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecc_ecdsa_verify_itch": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "mp_size_t\necc_ecdsa_verify_itch (const struct ecc_curve *ecc)\n{\n  /* Largest storage need is for the ecc->mul call. */\n  return 5*ecc->p.size + ecc->mul_itch;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "ecc_ecdsa_verify": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "int\necc_ecdsa_verify (const struct ecc_curve *ecc,\n\t\t  const mp_limb_t *pp, /* Public key */\n\t\t  size_t length, const uint8_t *digest,\n\t\t  const mp_limb_t *rp, const mp_limb_t *sp,\n\t\t  mp_limb_t *scratch)\n{\n  /* Procedure, according to RFC 6090, \"KT-I\". q denotes the group\n     order.\n\n     1. Check 0 < r, s < q.\n\n     2. s' <-- s^{-1}  (mod q)\n\n     3. u1  <-- h * s' (mod q)\n\n     4. u2  <-- r * s' (mod q)\n\n     5. R = u1 G + u2 Y\n\n     6. Signature is valid if R_x = r (mod q).\n  */\n\n#define P2 scratch\n#define u1 (scratch + 3*ecc->p.size)\n#define u2 (scratch + 4*ecc->p.size)\n\n#define P1 (scratch + 4*ecc->p.size)\n#define sinv (scratch)\n#define hp (scratch + ecc->p.size)\n\n  if (! (ecdsa_in_range (ecc, rp)\n\t && ecdsa_in_range (ecc, sp)))\n    return 0;\n\n  /* FIXME: Micro optimizations: Either simultaneous multiplication.\n     Or convert to projective coordinates (can be done without\n     division, I think), and write an ecc_add_ppp. */\n\n  /* Compute sinv */\n  ecc->q.invert (&ecc->q, sinv, sp, sinv + 2*ecc->p.size);\n\n  /* u1 = h / s, P1 = u1 * G */\n  ecc_hash (&ecc->q, hp, length, digest);\n  ecc_modq_mul (ecc, u1, hp, sinv);\n\n  /* u2 = r / s, P2 = u2 * Y */\n  ecc_modq_mul (ecc, u2, rp, sinv);\n\n   /* Total storage: 5*ecc->p.size + ecc->mul_itch */\n  ecc->mul (ecc, P2, u2, pp, u2 + ecc->p.size);\n\n  /* u = 0 can happen only if h = 0 or h = q, which is extremely\n     unlikely. */\n  if (!zero_p (u1, ecc->p.size))\n    {\n      /* Total storage: 7*ecc->p.size + ecc->mul_g_itch (ecc->p.size) */\n      ecc->mul_g (ecc, P1, u1, P1 + 3*ecc->p.size);\n\n      /* NOTE: ecc_add_jjj and/or ecc_j_to_a will produce garbage in\n\t case u1 G = +/- u2 V. However, anyone who gets his or her\n\t hands on a signature where this happens during verification,\n\t can also get the private key as z = +/- u1 / u_2 (mod q). And\n\t then it doesn't matter very much if verification of\n\t signatures with that key succeeds or fails.\n\n\t u1 G = - u2 V can never happen for a correctly generated\n\t signature, since it implies k = 0.\n\n\t u1 G = u2 V is possible, if we are unlucky enough to get h /\n\t s_1 = z. Hitting that is about as unlikely as finding the\n\t private key by guessing.\n       */\n      /* Total storage: 6*ecc->p.size + ecc->add_hhh_itch */\n      ecc->add_hhh (ecc, P1, P1, P2, P1 + 3*ecc->p.size);\n    }\n  /* x coordinate only, modulo q */\n  ecc->h_to_a (ecc, 2, P2, P1, P1 + 3*ecc->p.size);\n\n  return (mpn_cmp (rp, P2, ecc->p.size) == 0);\n#undef P2\n#undef P1\n#undef sinv\n#undef u2\n#undef hp\n#undef u1\n}",
      "lines": 87,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-eh-to-a.c": {
    "ecc_eh_to_a": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "void\necc_eh_to_a (const struct ecc_curve *ecc,\n\t     int op,\n\t     mp_limb_t *r, const mp_limb_t *p,\n\t     mp_limb_t *scratch)\n{\n#define izp scratch\n#define tp (scratch + ecc->p.size)\n\n\n#define xp p\n#define yp (p + ecc->p.size)\n#define zp (p + 2*ecc->p.size)\n\n  mp_limb_t cy;\n\n  /* Needs 2*size + scratch for the invert call. */\n  ecc->p.invert (&ecc->p, izp, zp, tp + ecc->p.size);\n\n  ecc_modp_mul (ecc, tp, xp, izp);\n  cy = mpn_sub_n (r, tp, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, r, tp, ecc->p.size);\n\n  if (op)\n    {\n      /* Skip y coordinate */\n      if (op > 1)\n\t{\n\t  /* Reduce modulo q. FIXME: Hardcoded for curve25519,\n\t     duplicates end of ecc_25519_modq. FIXME: Is this needed\n\t     at all? Full reduction mod p is maybe sufficient. */\n\t  unsigned shift;\n\t  assert (ecc->p.bit_size == 255);\n\t  shift = 252 - GMP_NUMB_BITS * (ecc->p.size - 1);\n\t  cy = mpn_submul_1 (r, ecc->q.m, ecc->p.size,\n\t\t\t     r[ecc->p.size-1] >> shift);\n\t  assert (cy < 2);\n\t  cnd_add_n (cy, r, ecc->q.m, ecc->p.size);\n\t}\n      return;\n    }\n  ecc_modp_mul (ecc, tp, yp, izp);\n  cy = mpn_sub_n (r + ecc->p.size, tp, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, r + ecc->p.size, tp, ecc->p.size);\n}",
      "lines": 45,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-hash.c": {
    "ecc_hash": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\necc_hash (const struct ecc_modulo *m,\n\t  mp_limb_t *hp,\n\t  size_t length, const uint8_t *digest)\n{\n  if (length > ((size_t) m->bit_size + 7) / 8)\n    length = (m->bit_size + 7) / 8;\n\n  mpn_set_base256 (hp, m->size + 1, digest, length);\n\n  if (8 * length > m->bit_size)\n    /* We got a few extra bits, at the low end. Discard them. */\n    mpn_rshift (hp, hp, m->size + 1, 8*length - m->bit_size);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-internal.h": {},
  "nettle/nettle-3.4.1/ecc-j-to-a.c": {
    "ecc_j_to_a": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\necc_j_to_a (const struct ecc_curve *ecc,\n\t    int op,\n\t    mp_limb_t *r, const mp_limb_t *p,\n\t    mp_limb_t *scratch)\n{\n#define izp   scratch\n#define up   (scratch + 2*ecc->p.size)\n#define iz2p (scratch + ecc->p.size)\n#define iz3p (scratch + 2*ecc->p.size)\n#define izBp (scratch + 3*ecc->p.size)\n#define tp    scratch\n\n  mp_limb_t cy;\n\n  if (ecc->use_redc)\n    {\n      /* Set v = (r_z / B^2)^-1,\n\n\t r_x = p_x v^2 / B^3 =  ((v/B * v)/B * p_x)/B\n\t r_y = p_y v^3 / B^4 = (((v/B * v)/B * v)/B * p_y)/B\n      */\n\n      mpn_copyi (up, p + 2*ecc->p.size, ecc->p.size);\n      mpn_zero (up + ecc->p.size, ecc->p.size);\n      ecc->p.reduce (&ecc->p, up);\n      mpn_zero (up + ecc->p.size, ecc->p.size);\n      ecc->p.reduce (&ecc->p, up);\n\n      ecc->p.invert (&ecc->p, izp, up, up + ecc->p.size);\n\n      /* Divide this common factor by B */\n      mpn_copyi (izBp, izp, ecc->p.size);\n      mpn_zero (izBp + ecc->p.size, ecc->p.size);\n      ecc->p.reduce (&ecc->p, izBp);\n\n      ecc_modp_mul (ecc, iz2p, izp, izBp);\n    }\n  else\n    {\n      /* Set s = p_z^{-1}, r_x = p_x s^2, r_y = p_y s^3 */\n\n      mpn_copyi (up, p+2*ecc->p.size, ecc->p.size); /* p_z */\n      ecc->p.invert (&ecc->p, izp, up, up + ecc->p.size);\n\n      ecc_modp_sqr (ecc, iz2p, izp);\n    }\n\n  ecc_modp_mul (ecc, iz3p, iz2p, p);\n  /* ecc_modp (and ecc_modp_mul) may return a value up to 2p - 1, so\n     do a conditional subtraction. */\n  cy = mpn_sub_n (r, iz3p, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, r, iz3p, ecc->p.size);\n\n  if (op)\n    {\n      /* Skip y coordinate */\n      if (op > 1)\n\t{\n\t  /* Also reduce the x coordinate mod ecc->q. It should\n\t     already be < 2*ecc->q, so one subtraction should\n\t     suffice. */\n\t  cy = mpn_sub_n (scratch, r, ecc->q.m, ecc->p.size);\n\t  cnd_copy (cy == 0, r, scratch, ecc->p.size);\n\t}\n      return;\n    }\n  ecc_modp_mul (ecc, iz3p, iz2p, izp);\n  ecc_modp_mul (ecc, tp, iz3p, p + ecc->p.size);\n  /* And a similar subtraction. */\n  cy = mpn_sub_n (r + ecc->p.size, tp, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, r + ecc->p.size, tp, ecc->p.size);\n\n#undef izp\n#undef up\n#undef iz2p\n#undef iz3p\n#undef tp\n}",
      "lines": 79,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mod-arith.c": {
    "ecc_mod_add": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\necc_mod_add (const struct ecc_modulo *m, mp_limb_t *rp,\n\t     const mp_limb_t *ap, const mp_limb_t *bp)\n{\n  mp_limb_t cy;\n  cy = mpn_add_n (rp, ap, bp, m->size);\n  cy = cnd_add_n (cy, rp, m->B, m->size);\n  cy = cnd_add_n (cy, rp, m->B, m->size);\n  assert (cy == 0);  \n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_sub": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\necc_mod_sub (const struct ecc_modulo *m, mp_limb_t *rp,\n\t     const mp_limb_t *ap, const mp_limb_t *bp)\n{\n  mp_limb_t cy;\n  cy = mpn_sub_n (rp, ap, bp, m->size);\n  cy = cnd_sub_n (cy, rp, m->B, m->size);\n  cy = cnd_sub_n (cy, rp, m->B, m->size);\n  assert (cy == 0);  \n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_mul_1": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\necc_mod_mul_1 (const struct ecc_modulo *m, mp_limb_t *rp,\n\t       const mp_limb_t *ap, mp_limb_t b)\n{\n  mp_limb_t hi;\n\n  assert (b <= 0xffffffff);\n  hi = mpn_mul_1 (rp, ap, m->size, b);\n  hi = mpn_addmul_1 (rp, m->B, m->size, hi);\n  assert (hi <= 1);\n  hi = cnd_add_n (hi, rp, m->B, m->size);\n  /* Sufficient if b < B^size / p */\n  assert (hi == 0);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_addmul_1": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\necc_mod_addmul_1 (const struct ecc_modulo *m, mp_limb_t *rp,\n\t\t  const mp_limb_t *ap, mp_limb_t b)\n{\n  mp_limb_t hi;\n\n  assert (b <= 0xffffffff);\n  hi = mpn_addmul_1 (rp, ap, m->size, b);\n  hi = mpn_addmul_1 (rp, m->B, m->size, hi);\n  assert (hi <= 1);\n  hi = cnd_add_n (hi, rp, m->B, m->size);\n  /* Sufficient roughly if b < B^size / p */\n  assert (hi == 0);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_submul_1": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "void\necc_mod_submul_1 (const struct ecc_modulo *m, mp_limb_t *rp,\n\t\t  const mp_limb_t *ap, mp_limb_t b)\n{\n  mp_limb_t hi;\n\n  assert (b <= 0xffffffff);\n  hi = mpn_submul_1 (rp, ap, m->size, b);\n  hi = mpn_submul_1 (rp, m->B, m->size, hi);\n  assert (hi <= 1);\n  hi = cnd_sub_n (hi, rp, m->B, m->size);\n  /* Sufficient roughly if b < B^size / p */\n  assert (hi == 0);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_mul": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\necc_mod_mul (const struct ecc_modulo *m, mp_limb_t *rp,\n\t     const mp_limb_t *ap, const mp_limb_t *bp)\n{\n  mpn_mul_n (rp, ap, bp, m->size);\n  m->reduce (m, rp);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "ecc_mod_sqr": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\necc_mod_sqr (const struct ecc_modulo *m, mp_limb_t *rp,\n\t     const mp_limb_t *ap)\n{\n  mpn_sqr (rp, ap, m->size);\n  m->reduce (m, rp);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mod-inv.c": {
    "cnd_neg": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ncnd_neg (int cnd, mp_limb_t *rp, const mp_limb_t *ap, mp_size_t n)\n{\n  mp_limb_t cy = (cnd != 0);\n  mp_limb_t mask = -cy;\n  mp_size_t i;\n\n  for (i = 0; i < n; i++)\n    {\n      mp_limb_t r = (ap[i] ^ mask) + cy;\n      cy = r < cy;\n      rp[i] = r;\n    }\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_mod_inv": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\necc_mod_inv (const struct ecc_modulo *m,\n\t     mp_limb_t *vp, const mp_limb_t *in_ap,\n\t     mp_limb_t *scratch)\n{\n#define ap scratch\n#define bp (scratch + n)\n#define up (vp + n)\n\n  mp_size_t n = m->size;\n  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n     versions. */  \n  unsigned i;\n\n  /* Maintain\n\n       a = u * orig_a (mod m)\n       b = v * orig_a (mod m)\n\n     and b odd at all times. Initially,\n\n       a = a_orig, u = 1\n       b = m,      v = 0\n     */\n\n  assert (ap != vp);\n\n  up[0] = 1;\n  mpn_zero (up+1, n - 1);\n  mpn_copyi (bp, m->m, n);\n  mpn_zero (vp, n);\n  mpn_copyi (ap, in_ap, n);\n\n  for (i = m->bit_size + GMP_NUMB_BITS * n; i-- > 0; )\n    {\n      mp_limb_t odd, swap, cy;\n      \n      /* Always maintain b odd. The logic of the iteration is as\n\t follows. For a, b:\n\n\t   odd = a & 1\n\t   a -= odd * b\n\t   if (underflow from a-b)\n\t     {\n\t       b += a, assigns old a\n\t       a = B^n-a\n\t     }\n\t   \n\t   a /= 2\n\n\t For u, v:\n\n\t   if (underflow from a - b)\n\t     swap u, v\n\t   u -= odd * v\n\t   if (underflow from u - v)\n\t     u += m\n\n\t   u /= 2\n\t   if (a one bit was shifted out)\n\t     u += (m+1)/2\n\n\t As long as a > 0, the quantity\n\n\t   (bitsize of a) + (bitsize of b)\n\n\t is reduced by at least one bit per iteration, hence after\n         (bit_size of orig_a) + (bit_size of m) - 1 iterations we\n         surely have a = 0. Then b = gcd(orig_a, m) and if b = 1 then\n         also v = orig_a^{-1} (mod m)\n      */\n\n      assert (bp[0] & 1);\n      odd = ap[0] & 1;\n\n      swap = cnd_sub_n (odd, ap, bp, n);\n      cnd_add_n (swap, bp, ap, n);\n      cnd_neg (swap, ap, ap, n);\n\n      cnd_swap (swap, up, vp, n);\n      cy = cnd_sub_n (odd, up, vp, n);\n      cy -= cnd_add_n (cy, up, m->m, n);\n      assert (cy == 0);\n\n      cy = mpn_rshift (ap, ap, n, 1);\n      assert (cy == 0);\n      cy = mpn_rshift (up, up, n, 1);\n      cy = cnd_add_n (cy, up, m->mp1h, n);\n      assert (cy == 0);\n    }\n  assert ( (ap[0] | ap[n-1]) == 0);\n#undef ap\n#undef bp\n#undef up\n}",
      "lines": 95,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mod.c": {
    "ecc_mod": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\necc_mod (const struct ecc_modulo *m, mp_limb_t *rp)\n{\n  mp_limb_t hi;\n  mp_size_t mn = m->size;\n  mp_size_t bn = m->B_size;\n  mp_size_t sn = mn - bn;\n  mp_size_t rn = 2*mn;\n  mp_size_t i;\n  unsigned shift;\n\n  assert (bn < mn);\n\n  /* FIXME: Could use mpn_addmul_2. */\n  /* Eliminate sn limbs at a time */\n  if (m->B[bn-1] < ((mp_limb_t) 1 << (GMP_NUMB_BITS - 1)))\n    {\n      /* Multiply sn + 1 limbs at a time, so we get a mn+1 limb\n\t product. Then we can absorb the carry in the high limb */\n      while (rn > 2 * mn - bn)\n\t{\n\t  rn -= sn;\n\n\t  for (i = 0; i <= sn; i++)\n\t    rp[rn+i-1] = mpn_addmul_1 (rp + rn - mn - 1 + i, m->B, bn, rp[rn+i-1]);\n\t  rp[rn-1] = rp[rn+sn-1]\n\t    + mpn_add_n (rp + rn - sn - 1, rp + rn - sn - 1, rp + rn - 1, sn);\n\t}\n      goto final_limbs;\n    }\n  else\n    {\n      /* The loop below always runs at least once. But the analyzer\n\t doesn't realize that, and complains about hi being used later\n\t on without a well defined value. */\n#ifdef __clang_analyzer__\n      hi = 0;\n#endif\n      while (rn >= 2 * mn - bn)\n\t{\n\t  rn -= sn;\n\n\t  for (i = 0; i < sn; i++)\n\t    rp[rn+i] = mpn_addmul_1 (rp + rn - mn + i, m->B, bn, rp[rn+i]);\n\t\t\t\t     \n\t  hi = mpn_add_n (rp + rn - sn, rp + rn - sn, rp + rn, sn);\n\t  hi = cnd_add_n (hi, rp + rn - mn, m->B, mn);\n\t  assert (hi == 0);\n\t}\n    }\n\n  if (rn > mn)\n    {\n    final_limbs:\n      sn = rn - mn;\n      \n      for (i = 0; i < sn; i++)\n\trp[mn+i] = mpn_addmul_1 (rp + i, m->B, bn, rp[mn+i]);\n\n      hi = mpn_add_n (rp + bn, rp + bn, rp + mn, sn);\n      hi = sec_add_1 (rp + bn + sn, rp + bn + sn, mn - bn - sn, hi);\n    }\n\n  shift = m->size * GMP_NUMB_BITS - m->bit_size;\n  if (shift > 0)\n    {\n      /* Combine hi with top bits, add in */\n      hi = (hi << shift) | (rp[mn-1] >> (GMP_NUMB_BITS - shift));\n      rp[mn-1] = (rp[mn-1] & (((mp_limb_t) 1 << (GMP_NUMB_BITS - shift)) - 1))\n\t+ mpn_addmul_1 (rp, m->B_shifted, mn-1, hi);\n    }\n  else\n    {\n      hi = cnd_add_n (hi, rp, m->B_shifted, mn);\n      assert (hi == 0);\n    }\n}",
      "lines": 77,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mul-a-eh.c": {
    "ecc_mul_a_eh": [
      {
        "start_point": [
          48,
          0
        ],
        "end_point": [
          85,
          1
        ],
        "content": "void\necc_mul_a_eh (const struct ecc_curve *ecc,\n\t      mp_limb_t *r,\n\t      const mp_limb_t *np, const mp_limb_t *p,\n\t      mp_limb_t *scratch)\n{\n#define pe scratch\n#define tp (scratch + 3*ecc->p.size)\n#define scratch_out (scratch + 6*ecc->p.size)\n\n  unsigned i;\n\n  ecc_a_to_j (ecc, pe, p);\n\n  /* x = 0, y = 1, z = 1 */\n  mpn_zero (r, 3*ecc->p.size);\n  r[ecc->p.size] = r[2*ecc->p.size] = 1;\n  \n  for (i = ecc->p.size; i-- > 0; )\n    {\n      mp_limb_t w = np[i];\n      mp_limb_t bit;\n\n      for (bit = (mp_limb_t) 1 << (GMP_NUMB_BITS - 1);\n\t   bit > 0;\n\t   bit >>= 1)\n\t{\n\t  int digit;\n\n\t  ecc_dup_eh (ecc, r, r, scratch_out);\n\t  ecc_add_ehh (ecc, tp, r, pe, scratch_out);\n\n\t  digit = (w & bit) > 0;\n\t  /* If we had a one-bit, use the sum. */\n\t  cnd_copy (digit, r, tp, 3*ecc->p.size);\n\t}\n    }\n}",
        "lines": 38,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          114,
          0
        ],
        "end_point": [
          173,
          1
        ],
        "content": "void\necc_mul_a_eh (const struct ecc_curve *ecc,\n\t      mp_limb_t *r,\n\t      const mp_limb_t *np, const mp_limb_t *p,\n\t      mp_limb_t *scratch)\n{\n#define tp scratch\n#define table (scratch + 3*ecc->p.size)\n  mp_limb_t *scratch_out = table + (3*ecc->p.size << ECC_MUL_A_EH_WBITS);\n\n  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n     versions. */\n  unsigned blocks = (ecc->p.bit_size + ECC_MUL_A_EH_WBITS - 1) / ECC_MUL_A_EH_WBITS;\n  unsigned bit_index = (blocks-1) * ECC_MUL_A_EH_WBITS;\n\n  mp_size_t limb_index = bit_index / GMP_NUMB_BITS;\n  unsigned shift = bit_index % GMP_NUMB_BITS;\n  mp_limb_t w, bits;\n\n  table_init (ecc, table, ECC_MUL_A_EH_WBITS, p, scratch_out);\n\n  w = np[limb_index];\n  bits = w >> shift;\n  if (limb_index < ecc->p.size - 1)\n    bits |= np[limb_index + 1] << (GMP_NUMB_BITS - shift);\n\n  assert (bits < TABLE_SIZE);\n\n  sec_tabselect (r, 3*ecc->p.size, table, TABLE_SIZE, bits);\n\n  for (;;)\n    {\n      unsigned j;\n      if (shift >= ECC_MUL_A_EH_WBITS)\n\t{\n\t  shift -= ECC_MUL_A_EH_WBITS;\n\t  bits = w >> shift;\n\t}\n      else\n\t{\n\t  if (limb_index == 0)\n\t    {\n\t      assert (shift == 0);\n\t      break;\n\t    }\n\t  bits = w << (ECC_MUL_A_EH_WBITS - shift);\n\t  w = np[--limb_index];\n\t  shift = shift + GMP_NUMB_BITS - ECC_MUL_A_EH_WBITS;\n\t  bits |= w >> shift;\n\t}\n      for (j = 0; j < ECC_MUL_A_EH_WBITS; j++)\n\tecc_dup_eh (ecc, r, r, scratch_out);\n\n      bits &= TABLE_MASK;\n      sec_tabselect (tp, 3*ecc->p.size, table, TABLE_SIZE, bits);\n      ecc_add_ehh (ecc, r, tp, r, scratch_out);\n    }\n#undef table\n#undef tp\n}",
        "lines": 60,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "table_init": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\ntable_init (const struct ecc_curve *ecc,\n\t    mp_limb_t *table, unsigned bits,\n\t    const mp_limb_t *p,\n\t    mp_limb_t *scratch)\n{\n  unsigned size = 1 << bits;\n  unsigned j;\n\n  mpn_zero (TABLE(0), 3*ecc->p.size);\n  TABLE(0)[ecc->p.size] = TABLE(0)[2*ecc->p.size] = 1;\n\n  ecc_a_to_j (ecc, TABLE(1), p);\n\n  for (j = 2; j < size; j += 2)\n    {\n      ecc_dup_eh (ecc, TABLE(j), TABLE(j/2), scratch);\n      ecc_add_ehh (ecc, TABLE(j+1), TABLE(j), TABLE(1), scratch);\n    }\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mul-a.c": {
    "ecc_mul_a": [
      {
        "start_point": [
          50,
          0
        ],
        "end_point": [
          90,
          1
        ],
        "content": "void\necc_mul_a (const struct ecc_curve *ecc,\n\t   mp_limb_t *r,\n\t   const mp_limb_t *np, const mp_limb_t *p,\n\t   mp_limb_t *scratch)\n{\n#define tp scratch\n#define pj (scratch + 3*ecc->p.size)\n#define scratch_out (scratch + 6*ecc->p.size)\n\n  int is_zero;\n\n  unsigned i;\n\n  ecc_a_to_j (ecc, pj, p);\n  mpn_zero (r, 3*ecc->p.size);\n  \n  for (i = ecc->p.size, is_zero = 1; i-- > 0; )\n    {\n      mp_limb_t w = np[i];\n      mp_limb_t bit;\n\n      for (bit = (mp_limb_t) 1 << (GMP_NUMB_BITS - 1);\n\t   bit > 0;\n\t   bit >>= 1)\n\t{\n\t  int digit;\n\n\t  ecc_dup_jj (ecc, r, r, scratch_out);\n\t  ecc_add_jja (ecc, tp, r, pj, scratch_out);\n\n\t  digit = (w & bit) > 0;\n\t  /* If is_zero is set, r is the zero point,\n\t     and ecc_add_jja produced garbage. */\n\t  cnd_copy (is_zero, tp, pj, 3*ecc->p.size);\n\t  is_zero &= ~digit;\n\t  /* If we had a one-bit, use the sum. */\n\t  cnd_copy (digit, r, tp, 3*ecc->p.size);\n\t}\n    }\n}",
        "lines": 41,
        "depth": 13,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          117,
          0
        ],
        "end_point": [
          184,
          1
        ],
        "content": "void\necc_mul_a (const struct ecc_curve *ecc,\n\t   mp_limb_t *r,\n\t   const mp_limb_t *np, const mp_limb_t *p,\n\t   mp_limb_t *scratch)\n{\n#define tp scratch\n#define table (scratch + 3*ecc->p.size)\n  mp_limb_t *scratch_out = table + (3*ecc->p.size << ECC_MUL_A_WBITS);\n  int is_zero = 0;\n\n  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n     versions. */\n  unsigned blocks = (ecc->p.bit_size + ECC_MUL_A_WBITS - 1) / ECC_MUL_A_WBITS;\n  unsigned bit_index = (blocks-1) * ECC_MUL_A_WBITS;\n\n  mp_size_t limb_index = bit_index / GMP_NUMB_BITS;\n  unsigned shift = bit_index % GMP_NUMB_BITS;\n  mp_limb_t w, bits;\n\n  table_init (ecc, table, ECC_MUL_A_WBITS, p, scratch_out);\n\n  w = np[limb_index];\n  bits = w >> shift;\n  if (limb_index < ecc->p.size - 1)\n    bits |= np[limb_index + 1] << (GMP_NUMB_BITS - shift);\n\n  assert (bits < TABLE_SIZE);\n\n  sec_tabselect (r, 3*ecc->p.size, table, TABLE_SIZE, bits);\n  is_zero = (bits == 0);\n\n  for (;;)\n    {\n      unsigned j;\n      if (shift >= ECC_MUL_A_WBITS)\n\t{\n\t  shift -= ECC_MUL_A_WBITS;\n\t  bits = w >> shift;\n\t}\n      else\n\t{\n\t  if (limb_index == 0)\n\t    {\n\t      assert (shift == 0);\n\t      break;\n\t    }\n\t  bits = w << (ECC_MUL_A_WBITS - shift);\n\t  w = np[--limb_index];\n\t  shift = shift + GMP_NUMB_BITS - ECC_MUL_A_WBITS;\n\t  bits |= w >> shift;\n\t}\n      for (j = 0; j < ECC_MUL_A_WBITS; j++)\n\tecc_dup_jj (ecc, r, r, scratch_out);\n\n      bits &= TABLE_MASK;\n      sec_tabselect (tp, 3*ecc->p.size, table, TABLE_SIZE, bits);\n      cnd_copy (is_zero, r, tp, 3*ecc->p.size);\n      ecc_add_jjj (ecc, tp, tp, r, scratch_out);\n\n      /* Use the sum when valid. ecc_add_jja produced garbage if\n\t is_zero != 0 or bits == 0, . */\t  \n      cnd_copy (bits & (is_zero - 1), r, tp, 3*ecc->p.size);\n      is_zero &= (bits == 0);\n    }\n#undef table\n#undef tp\n}",
        "lines": 68,
        "depth": 13,
        "decorators": [
          "void"
        ]
      }
    ],
    "table_init": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void\ntable_init (const struct ecc_curve *ecc,\n\t    mp_limb_t *table, unsigned bits,\n\t    const mp_limb_t *p,\n\t    mp_limb_t *scratch)\n{\n  unsigned size = 1 << bits;\n  unsigned j;\n\n  mpn_zero (TABLE(0), 3*ecc->p.size);\n  ecc_a_to_j (ecc, TABLE(1), p);\n\n  for (j = 2; j < size; j += 2)\n    {\n      ecc_dup_jj (ecc, TABLE(j), TABLE(j/2), scratch);\n      ecc_add_jja (ecc, TABLE(j+1), TABLE(j), TABLE(1), scratch);\n    }  \n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mul-g-eh.c": {
    "ecc_mul_g_eh": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\necc_mul_g_eh (const struct ecc_curve *ecc, mp_limb_t *r,\n\t      const mp_limb_t *np, mp_limb_t *scratch)\n{\n  /* Scratch need determined by the ecc_add_eh call. Current total is\n     9 * ecc->p.size, at most 648 bytes. */\n#define tp scratch\n#define scratch_out (scratch + 3*ecc->p.size)\n\n  unsigned k, c;\n  unsigned i, j;\n  unsigned bit_rows;\n\n  k = ecc->pippenger_k;\n  c = ecc->pippenger_c;\n\n  bit_rows = (ecc->p.bit_size + k - 1) / k;\n\n  /* x = 0, y = 1, z = 1 */\n  mpn_zero (r, 3*ecc->p.size);\n  r[ecc->p.size] = r[2*ecc->p.size] = 1;\n\n  for (i = k; i-- > 0; )\n    {\n      ecc_dup_eh (ecc, r, r, scratch);\n      for (j = 0; j * c < bit_rows; j++)\n\t{\n\t  unsigned bits;\n\t  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n\t     versions. */\n\t  unsigned bit_index;\n\t  \n\t  /* Extract c bits from n, stride k, starting at i + kcj,\n\t     ending at i + k (cj + c - 1)*/\n\t  for (bits = 0, bit_index = i + k*(c*j+c); bit_index > i + k*c*j; )\n\t    {\n\t      mp_size_t limb_index;\n\t      unsigned shift;\n\t      \n\t      bit_index -= k;\n\n\t      limb_index = bit_index / GMP_NUMB_BITS;\n\t      if (limb_index >= ecc->p.size)\n\t\tcontinue;\n\n\t      shift = bit_index % GMP_NUMB_BITS;\n\t      bits = (bits << 1) | ((np[limb_index] >> shift) & 1);\n\t    }\n\t  sec_tabselect (tp, 2*ecc->p.size,\n\t\t\t (ecc->pippenger_table\n\t\t\t  + (2*ecc->p.size * (mp_size_t) j << c)),\n\t\t\t 1<<c, bits);\n\n\t  ecc_add_eh (ecc, r, r, tp, scratch_out);\n\t}\n    }\n#undef tp\n#undef scratch_out\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-mul-g.c": {
    "ecc_mul_g": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\necc_mul_g (const struct ecc_curve *ecc, mp_limb_t *r,\n\t   const mp_limb_t *np, mp_limb_t *scratch)\n{\n  /* Scratch need determined by the ecc_add_jja call. Current total is\n     9 * ecc->p.size, at most 648 bytes. */\n#define tp scratch\n#define scratch_out (scratch + 3*ecc->p.size)\n\n  unsigned k, c;\n  unsigned i, j;\n  unsigned bit_rows;\n\n  int is_zero;\n\n  k = ecc->pippenger_k;\n  c = ecc->pippenger_c;\n\n  bit_rows = (ecc->p.bit_size + k - 1) / k;\n  \n  mpn_zero (r, 3*ecc->p.size);\n  \n  for (i = k, is_zero = 1; i-- > 0; )\n    {\n      ecc_dup_jj (ecc, r, r, scratch);\n      for (j = 0; j * c < bit_rows; j++)\n\t{\n\t  unsigned bits;\n\t  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n\t     versions. */\n\t  unsigned bit_index;\n\t  \n\t  /* Extract c bits from n, stride k, starting at i + kcj,\n\t     ending at i + k (cj + c - 1)*/\n\t  for (bits = 0, bit_index = i + k*(c*j+c); bit_index > i + k*c*j; )\n\t    {\n\t      mp_size_t limb_index;\n\t      unsigned shift;\n\t      \n\t      bit_index -= k;\n\n\t      limb_index = bit_index / GMP_NUMB_BITS;\n\t      if (limb_index >= ecc->p.size)\n\t\tcontinue;\n\n\t      shift = bit_index % GMP_NUMB_BITS;\n\t      bits = (bits << 1) | ((np[limb_index] >> shift) & 1);\n\t    }\n\t  sec_tabselect (tp, 2*ecc->p.size,\n\t\t\t (ecc->pippenger_table\n\t\t\t  + (2*ecc->p.size * (mp_size_t) j << c)),\n\t\t\t 1<<c, bits);\n\t  cnd_copy (is_zero, r, tp, 2*ecc->p.size);\n\t  cnd_copy (is_zero, r + 2*ecc->p.size, ecc->unit, ecc->p.size);\n\t  \n\t  ecc_add_jja (ecc, tp, r, tp, scratch_out);\n\t  /* Use the sum when valid. ecc_add_jja produced garbage if\n\t     is_zero != 0 or bits == 0, . */\t  \n\t  cnd_copy (bits & (is_zero - 1), r, tp, 3*ecc->p.size);\n\t  is_zero &= (bits == 0);\n\t}\n    }\n#undef tp\n#undef scratch_out\n}",
      "lines": 65,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-pm1-redc.c": {
    "ecc_pm1_redc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\necc_pm1_redc (const struct ecc_modulo *m, mp_limb_t *rp)\n{\n  unsigned i;\n  mp_limb_t hi, cy;\n  unsigned shift = m->size * GMP_NUMB_BITS - m->bit_size;\n  mp_size_t k = m->redc_size;\n  \n  for (i = 0; i < m->size; i++)\n    rp[i] = mpn_submul_1 (rp + i + k,\n\t\t\t  m->redc_mpm1, m->size - k, rp[i]);\n  hi = mpn_sub_n (rp, rp + m->size, rp, m->size);\n  cy = cnd_add_n (hi, rp, m->m, m->size);\n  assert (cy == hi);\n\n  if (shift > 0)\n    {\n      /* Result is always < 2p, provided that\n\t 2^shift * Bmodp_shifted <= p */\n      hi = (rp[m->size - 1] >> (GMP_NUMB_BITS - shift));\n      rp[m->size - 1] = (rp[m->size - 1]\n\t\t\t   & (((mp_limb_t) 1 << (GMP_NUMB_BITS - shift)) - 1))\n\t+ mpn_addmul_1 (rp, m->B_shifted, m->size-1, hi);\n    }\n}",
      "lines": 25,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-point-mul-g.c": {
    "ecc_point_mul_g": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\necc_point_mul_g (struct ecc_point *r, const struct ecc_scalar *n)\n{\n  TMP_DECL(scratch, mp_limb_t, 3*ECC_MAX_SIZE + ECC_MUL_G_ITCH (ECC_MAX_SIZE));\n  const struct ecc_curve *ecc = r->ecc;\n  mp_limb_t size = ecc->p.size;\n  mp_size_t itch = 3*size + ecc->mul_g_itch;\n\n  assert (n->ecc == ecc);\n\n  TMP_ALLOC (scratch, itch);\n\n  ecc->mul_g (ecc, scratch, n->p, scratch + 3*size);\n  ecc->h_to_a (ecc, 0, r->p, scratch, scratch + 3*size);\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-point-mul.c": {
    "ecc_point_mul": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\necc_point_mul (struct ecc_point *r, const struct ecc_scalar *n,\n\t       const struct ecc_point *p)\n{\n  const struct ecc_curve *ecc = r->ecc;\n  mp_limb_t size = ecc->p.size;\n  mp_size_t itch = 3*size + ecc->mul_itch;\n  mp_limb_t *scratch = gmp_alloc_limbs (itch);\n\n  assert (n->ecc == ecc);\n  assert (p->ecc == ecc);\n\n  ecc->mul (ecc, scratch, n->p, p->p, scratch + 3*size);\n  ecc->h_to_a (ecc, 0, r->p, scratch, scratch + 3*size);\n  gmp_free_limbs (scratch, itch);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-point.c": {
    "ecc_point_init": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\necc_point_init (struct ecc_point *p, const struct ecc_curve *ecc)\n{\n  p->ecc = ecc;\n  p->p = gmp_alloc_limbs (2*ecc->p.size);\n}",
      "lines": 6,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ecc_point_clear": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\necc_point_clear (struct ecc_point *p)\n{\n  gmp_free_limbs (p->p, 2*p->ecc->p.size);\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "ecc_point_set": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\necc_point_set (struct ecc_point *p, const mpz_t x, const mpz_t y)\n{\n  mp_size_t size;  \n  mpz_t lhs, rhs;\n  mpz_t t;\n  int res;\n\n  size = p->ecc->p.size;\n  \n  if (mpz_sgn (x) < 0 || mpz_limbs_cmp (x, p->ecc->p.m, size) >= 0\n      || mpz_sgn (y) < 0 || mpz_limbs_cmp (y, p->ecc->p.m, size) >= 0)\n    return 0;\n\n  mpz_init (lhs);\n  mpz_init (rhs);\n\n  mpz_mul (lhs, y, y);\n  \n  if (p->ecc->p.bit_size == 255)\n    {\n      /* ed25519 special case. FIXME: Do in some cleaner way? */\n      mpz_t x2;\n      mpz_init (x2);\n      mpz_mul (x2, x, x);\n      mpz_mul (rhs, x2, lhs);\n      /* Check that -x^2 + y^2 = 1 - (121665/121666) x^2 y^2\n\t or 121666 (1 + x^2 - y^2) = 121665 x^2 y^2 */\n      mpz_sub (lhs, x2, lhs);\n      mpz_add_ui (lhs, lhs, 1);\n      mpz_mul_ui (lhs, lhs, 121666);\n      mpz_mul_ui (rhs, rhs, 121665);\n      mpz_clear (x2);\n    }\n  else\n    {\n      /* Check that y^2 = x^3 - 3*x + b (mod p) */\n      mpz_mul (rhs, x, x);\n      mpz_sub_ui (rhs, rhs, 3);\n      mpz_mul (rhs, rhs, x);\n      mpz_add (rhs, rhs, mpz_roinit_n (t, p->ecc->b, size));\n    }\n\n  res = mpz_congruent_p (lhs, rhs, mpz_roinit_n (t, p->ecc->p.m, size));\n\n  mpz_clear (lhs);\n  mpz_clear (rhs);\n\n  if (!res)\n    return 0;\n\n  mpz_limbs_copy (p->p, x, size);\n  mpz_limbs_copy (p->p + size, y, size);\n\n  return 1;\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "ecc_point_get": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\necc_point_get (const struct ecc_point *p, mpz_t x, mpz_t y)\n{\n  mp_size_t size = p->ecc->p.size;\n  if (x)\n    mpz_set_n (x, p->p, size);\n  if (y)\n    mpz_set_n (y, p->p + size, size);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-pp1-redc.c": {
    "ecc_pp1_redc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\necc_pp1_redc (const struct ecc_modulo *m, mp_limb_t *rp)\n{\n  unsigned i;\n  mp_limb_t hi, cy;\n  unsigned shift = m->size * GMP_NUMB_BITS - m->bit_size;\n  mp_size_t k = m->redc_size;\n  \n  for (i = 0; i < m->size; i++)\n    rp[i] = mpn_addmul_1 (rp + i + k,\n\t\t\t  m->redc_mpm1, m->size - k, rp[i]);\n  hi = mpn_add_n (rp, rp, rp + m->size, m->size);\n  if (shift > 0)\n    {\n      hi = (hi << shift) | (rp[m->size - 1] >> (GMP_NUMB_BITS - shift));\n      rp[m->size - 1] = (rp[m->size - 1]\n\t\t\t   & (((mp_limb_t) 1 << (GMP_NUMB_BITS - shift)) - 1))\n\t+ mpn_addmul_1 (rp, m->B_shifted, m->size-1, hi);\n\t  \n    }\n  else\n    {\n      cy = cnd_sub_n (hi, rp, m->m, m->size);\n      assert (cy == hi);      \n    }\n}",
      "lines": 26,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-random.c": {
    "zero_p": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static int\nzero_p (const struct ecc_modulo *m,\n\tconst mp_limb_t *xp)\n{\n  mp_limb_t t;\n  mp_size_t i;\n\n  for (i = t = 0; i < m->size; i++)\n    t |= xp[i];\n\n  return t == 0;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecdsa_in_range": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static int\necdsa_in_range (const struct ecc_modulo *m,\n\t\tconst mp_limb_t *xp, mp_limb_t *scratch)\n{\n  /* Check if 0 < x < q, with data independent timing. */\n  return !zero_p (m, xp)\n    & (mpn_sub_n (scratch, xp, m->m, m->size) != 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecc_mod_random": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\necc_mod_random (const struct ecc_modulo *m, mp_limb_t *xp,\n\t\tvoid *ctx, nettle_random_func *random, mp_limb_t *scratch)\n{\n  uint8_t *buf = (uint8_t *) scratch;\n  unsigned nbytes = (m->bit_size + 7)/8;\n\n  /* The bytes ought to fit in the scratch area, unless we have very\n     unusual limb and byte sizes. */\n  assert (nbytes <= m->size * sizeof (mp_limb_t));\n\n  do\n    {\n      random (ctx, nbytes, buf);\n      buf[0] &= 0xff >> (nbytes * 8 - m->bit_size);\n\n      mpn_set_base256 (xp, m->size, buf, nbytes);\n    }\n  while (!ecdsa_in_range (m, xp, scratch));\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "ecc_scalar_random": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "void\necc_scalar_random (struct ecc_scalar *x,\n\t\t   void *random_ctx, nettle_random_func *random)\n{\n  TMP_DECL (scratch, mp_limb_t, ECC_MOD_RANDOM_ITCH (ECC_MAX_SIZE));\n  TMP_ALLOC (scratch, ECC_MOD_RANDOM_ITCH (x->ecc->q.size));\n\n  ecc_mod_random (&x->ecc->q, x->p, random_ctx, random, scratch);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-scalar.c": {
    "ecc_scalar_init": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\necc_scalar_init (struct ecc_scalar *s, const struct ecc_curve *ecc)\n{\n  s->ecc = ecc;\n  s->p = gmp_alloc_limbs (ecc->p.size);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ecc_scalar_clear": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\necc_scalar_clear (struct ecc_scalar *s)\n{\n  gmp_free_limbs (s->p, s->ecc->p.size);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ecc_scalar_set": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\necc_scalar_set (struct ecc_scalar *s, const mpz_t z)\n{\n  mp_size_t size = s->ecc->p.size;\n\n  if (mpz_sgn (z) <= 0 || mpz_limbs_cmp (z, s->ecc->q.m, size) >= 0)\n    return 0;\n\n  mpz_limbs_copy (s->p, z, size);\n  return 1;\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "ecc_scalar_get": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\necc_scalar_get (const struct ecc_scalar *s, mpz_t z)\n{\n  mpz_set_n (z, s->p, s->ecc->p.size);  \n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc-size.c": {
    "ecc_bit_size": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "unsigned\necc_bit_size (const struct ecc_curve *ecc)\n{\n  return ecc->p.bit_size;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "ecc_size": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "mp_size_t\necc_size (const struct ecc_curve *ecc)\n{\n  return ecc->p.size;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_size_t"
      ]
    },
    "ecc_size_a": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "mp_size_t\necc_size_a (const struct ecc_curve *ecc)\n{\n  return 2*ecc->p.size;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "mp_size_t"
      ]
    },
    "ecc_size_j": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "mp_size_t\necc_size_j (const struct ecc_curve *ecc)\n{\n  return 3*ecc->p.size;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "mp_size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecc.h": {},
  "nettle/nettle-3.4.1/eccdata.c": {
    "ecc_init": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\necc_init (struct ecc_point *p)\n{\n  mpz_init (p->x);\n  mpz_init (p->y);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_clear": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\necc_clear (struct ecc_point *p)\n{\n  mpz_clear (p->x);\n  mpz_clear (p->y);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_zero_p": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "static int\necc_zero_p (const struct ecc_point *p)\n{\n  return p->is_zero;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecc_equal_p": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static int\necc_equal_p (const struct ecc_point *p, const struct ecc_point *q)\n{\n  return p->is_zero ? q->is_zero\n    : !q->is_zero && mpz_cmp (p->x, q->x) == 0 && mpz_cmp (p->y, q->y) == 0;\n}",
      "lines": 6,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "ecc_set_zero": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\necc_set_zero (struct ecc_point *r)\n{\n  r->is_zero = 1;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_set": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static void\necc_set (struct ecc_point *r, const struct ecc_point *p)\n{\n  r->is_zero = p->is_zero;\n  mpz_set (r->x, p->x);\n  mpz_set (r->y, p->y);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_dup": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static void\necc_dup (const struct ecc_curve *ecc,\n\t struct ecc_point *r, const struct ecc_point *p)\n{\n  if (ecc_zero_p (p))\n    ecc_set_zero (r);\n\n  else\n    {\n      mpz_t m, t, x, y;\n\n      mpz_init (m);\n      mpz_init (t);\n      mpz_init (x);\n      mpz_init (y);\n\n      /* m = (2 y)^-1 */\n      mpz_mul_ui (m, p->y, 2);\n      mpz_invert (m, m, ecc->p);\n\n      switch (ecc->type)\n\t{\n\tcase ECC_TYPE_WEIERSTRASS:\n\t  /* t = 3 (x^2 - 1) * m */\n\t  mpz_mul (t, p->x, p->x);\n\t  mpz_mod (t, t, ecc->p);\n\t  mpz_sub_ui (t, t, 1);\n\t  mpz_mul_ui (t, t, 3);\n\t  break;\n\tcase ECC_TYPE_MONTGOMERY:\n\t  /* t = (3 x^2 + 2 b x + 1) m = [x(3x+2b)+1] m */\n\t  mpz_mul_ui (t, ecc->b, 2);\n\t  mpz_addmul_ui (t, p->x, 3);\n\t  mpz_mul (t, t, p->x);\n\t  mpz_mod (t, t, ecc->p);\n\t  mpz_add_ui (t, t, 1);\n\t  break;\n\t}\n      mpz_mul (t, t, m);\n      mpz_mod (t, t, ecc->p);\n\n      /* x' = t^2 - 2 x */\n      mpz_mul (x, t, t);\n      mpz_submul_ui (x, p->x, 2);\n      if (ecc->type == ECC_TYPE_MONTGOMERY)\n\tmpz_sub (x, x, ecc->b);\n\n      mpz_mod (x, x, ecc->p);\n\n      /* y' = (x - x') * t - y */\n      mpz_sub (y, p->x, x);\n      mpz_mul (y, y, t);\n      mpz_sub (y, y, p->y);\n      mpz_mod (y, y, ecc->p);\n\n      r->is_zero = 0;\n      mpz_swap (x, r->x);\n      mpz_swap (y, r->y);\n\n      mpz_clear (m);\n      mpz_clear (t);\n      mpz_clear (x);\n      mpz_clear (y);\n    }\n}",
      "lines": 65,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_add": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        265,
        1
      ],
      "content": "static void\necc_add (const struct ecc_curve *ecc,\n\t struct ecc_point *r, const struct ecc_point *p, const struct ecc_point *q)\n{\n  if (ecc_zero_p (p))\n    ecc_set (r, q);\n\n  else if (ecc_zero_p (q))\n    ecc_set (r, p);\n\n  else if (mpz_cmp (p->x, q->x) == 0)\n    {\n      if (mpz_cmp (p->y, q->y) == 0)\n\tecc_dup (ecc, r, p);\n      else\n\tecc_set_zero (r);\n    }\n  else\n    {\n      mpz_t s, t, x, y;\n      mpz_init (s);\n      mpz_init (t);\n      mpz_init (x);\n      mpz_init (y);\n\n      /* t = (q_y - p_y) / (q_x - p_x) */\n      mpz_sub (t, q->x, p->x);\n      mpz_invert (t, t, ecc->p);\n      mpz_sub (s, q->y, p->y);\n      mpz_mul (t, t, s);\n      mpz_mod (t, t, ecc->p);\n\n      /* x' = t^2 - p_x - q_x */\n      mpz_mul (x, t, t);\n      mpz_sub (x, x, p->x);\n      mpz_sub (x, x, q->x);\n      /* This appears to be the only difference between formulas. */\n      if (ecc->type == ECC_TYPE_MONTGOMERY)\n\tmpz_sub (x, x, ecc->b);\n      mpz_mod (x, x, ecc->p);\n\n      /* y' = (x - x') * t - y */\n      mpz_sub (y, p->x, x);\n      mpz_mul (y, y, t);\n      mpz_sub (y, y, p->y);\n      mpz_mod (y, y, ecc->p);\n\n      r->is_zero = 0;\n      mpz_swap (x, r->x);\n      mpz_swap (y, r->y);\n\n      mpz_clear (s);\n      mpz_clear (t);\n      mpz_clear (x);\n      mpz_clear (y);\n    }\n}",
      "lines": 57,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_mul_binary": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        287,
        1
      ],
      "content": "static void \necc_mul_binary (const struct ecc_curve *ecc,\n\t\tstruct ecc_point *r, const mpz_t n, const struct ecc_point *p)\n{\n  /* Avoid the mp_bitcnt_t type for compatibility with older GMP\n     versions. */\n  unsigned k;\n\n  assert (r != p);\n  assert (mpz_sgn (n) > 0);\n\n  ecc_set (r, p);\n\n  /* Index of highest one bit */\n  for (k = mpz_sizeinbase (n, 2) - 1; k-- > 0; )\n    {\n      ecc_dup (ecc, r, r);\n      if (mpz_tstbit (n, k))\n\tecc_add (ecc, r, r, p);\n    }  \n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_alloc": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        304,
        1
      ],
      "content": "static struct ecc_point *\necc_alloc (size_t n)\n{\n  struct ecc_point *p = malloc (n * sizeof(*p));\n  size_t i;\n\n  if (!p)\n    {\n      fprintf (stderr, \"Virtual memory exhausted.\\n\");\n      exit (EXIT_FAILURE);\n    }\n  for (i = 0; i < n; i++)\n    ecc_init (&p[i]);\n\n  return p;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "struct ecc_point",
        "struct",
        "ecc_point",
        "*\necc_alloc (size_t n)",
        "*"
      ]
    },
    "ecc_set_str": {
      "start_point": [
        306,
        0
      ],
      "end_point": [
        313,
        1
      ],
      "content": "static void\necc_set_str (struct ecc_point *p,\n\t     const char *x, const char *y)\n{\n  p->is_zero = 0;\n  mpz_set_str (p->x, x, 16);\n  mpz_set_str (p->y, y, 16);  \n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_curve_init_str": {
      "start_point": [
        315,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "static void\necc_curve_init_str (struct ecc_curve *ecc, enum ecc_type type,\n\t\t    const char *p, const char *b, const char *q,\n\t\t    const char *gx, const char *gy,\n\t\t    const char *d, const char *t)\n{\n  ecc->type = type;\n\n  mpz_init_set_str (ecc->p, p, 16);\n  mpz_init_set_str (ecc->b, b, 16);\n  mpz_init_set_str (ecc->q, q, 16);\n  ecc_init (&ecc->g);\n  ecc_set_str (&ecc->g, gx, gy);\n\n  ecc->pippenger_k = 0;\n  ecc->pippenger_c = 0;\n  ecc->table = NULL;\n\n  ecc->ref = NULL;\n\n  mpz_init (ecc->d);\n  mpz_init (ecc->t);\n\n  ecc->use_edwards = (t != NULL);\n  if (ecc->use_edwards)\n    {\n      mpz_set_str (ecc->t, t, 16);\n      mpz_set_str (ecc->d, d, 16);\n    }\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_curve_init": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        611,
        1
      ],
      "content": "static void\necc_curve_init (struct ecc_curve *ecc, unsigned bit_size)\n{\n  switch (bit_size)\n    {\n    case 192:      \n      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,\n\t\t\t  /* p = 2^{192} - 2^{64} - 1 */\n\t\t\t  \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE\"\n\t\t\t  \"FFFFFFFFFFFFFFFF\",\n\n\t\t\t  \"64210519e59c80e70fa7e9ab72243049\"\n\t\t\t  \"feb8deecc146b9b1\", \n\n\t\t\t  \"ffffffffffffffffffffffff99def836\"\n\t\t\t  \"146bc9b1b4d22831\",\n\n\t\t\t  \"188da80eb03090f67cbf20eb43a18800\"\n\t\t\t  \"f4ff0afd82ff1012\",\n\n\t\t\t  \"07192b95ffc8da78631011ed6b24cdd5\"\n\t\t\t  \"73f977a11e794811\",\n\t\t\t  NULL, NULL);\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"dafebf5828783f2ad35534631588a3f629a70fb16982a888\",\n\t\t   \"dd6bda0d993da0fa46b27bbc141b868f59331afa5c7e93ab\");\n      \n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"76e32a2557599e6edcd283201fb2b9aadfd0d359cbb263da\",\n\t\t   \"782c37e372ba4520aa62e0fed121d49ef3b543660cfd05fd\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"35433907297cc378b0015703374729d7a4fe46647084e4ba\",\n\t\t   \"a2649984f2135c301ea3acb0776cd4f125389b311db3be32\");\n\n      break;\n    case 224:\n      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,\n\t\t\t  /* p = 2^{224} - 2^{96} + 1 */\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"000000000000000000000001\",\n\n\t\t\t  \"b4050a850c04b3abf54132565044b0b7\"\n\t\t\t  \"d7bfd8ba270b39432355ffb4\",\n\n\t\t\t  \"ffffffffffffffffffffffffffff16a2\"\n\t\t\t  \"e0b8f03e13dd29455c5c2a3d\",\n\n\t\t\t  \"b70e0cbd6bb4bf7f321390b94a03c1d3\"\n\t\t\t  \"56c21122343280d6115c1d21\",\n\n\t\t\t  \"bd376388b5f723fb4c22dfe6cd4375a0\"\n\t\t\t  \"5a07476444d5819985007e34\",\n\t\t\t  NULL, NULL);\n\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"706a46dc76dcb76798e60e6d89474788d16dc18032d268fd1a704fa6\",\n\t\t   \"1c2b76a7bc25e7702a704fa986892849fca629487acf3709d2e4e8bb\");\n      \n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"df1b1d66a551d0d31eff822558b9d2cc75c2180279fe0d08fd896d04\",\n\t\t   \"a3f7f03cadd0be444c0aa56830130ddf77d317344e1af3591981a925\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301\",\n\t\t   \"482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9\");\n\n      break;\n    case 256:\n      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,\n\t\t\t  /* p = 2^{256} - 2^{224} + 2^{192} + 2^{96} - 1 */\n\t\t\t  \"FFFFFFFF000000010000000000000000\"\n\t\t\t  \"00000000FFFFFFFFFFFFFFFFFFFFFFFF\",\n\n\t\t\t  \"5AC635D8AA3A93E7B3EBBD55769886BC\"\n\t\t\t  \"651D06B0CC53B0F63BCE3C3E27D2604B\",\n\n\t\t\t  \"FFFFFFFF00000000FFFFFFFFFFFFFFFF\"\n\t\t\t  \"BCE6FAADA7179E84F3B9CAC2FC632551\",\n\n\t\t\t  \"6B17D1F2E12C4247F8BCE6E563A440F2\"\n\t\t\t  \"77037D812DEB33A0F4A13945D898C296\",\n\n\t\t\t  \"4FE342E2FE1A7F9B8EE7EB4A7C0F9E16\"\n\t\t\t  \"2BCE33576B315ECECBB6406837BF51F5\",\n\t\t\t  NULL, NULL);\n\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"7cf27b188d034f7e8a52380304b51ac3c08969e277f21b35a60b48fc47669978\",\n\t\t   \"7775510db8ed040293d9ac69f7430dbba7dade63ce982299e04b79d227873d1\");\n      \n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"5ecbe4d1a6330a44c8f7ef951d4bf165e6c6b721efada985fb41661bc6e7fd6c\",\n\t\t   \"8734640c4998ff7e374b06ce1a64a2ecd82ab036384fb83d9a79b127a27d5032\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852\",\n\t\t   \"e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6\");\n\n      break;\n    case 384:\n      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,\n\t\t\t  /* p = 2^{384} - 2^{128} - 2^{96} + 2^{32} - 1 */\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"fffffffffffffffffffffffffffffffe\"\n\t\t\t  \"ffffffff0000000000000000ffffffff\",\n\t\t\t  \n\t\t\t  \"b3312fa7e23ee7e4988e056be3f82d19\"\n\t\t\t  \"181d9c6efe8141120314088f5013875a\"\n\t\t\t  \"c656398d8a2ed19d2a85c8edd3ec2aef\",\n\t\t\t  \n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"ffffffffffffffffc7634d81f4372ddf\"\n\t\t\t  \"581a0db248b0a77aecec196accc52973\",\n\t\t\t  \n\t\t\t  \"aa87ca22be8b05378eb1c71ef320ad74\"\n\t\t\t  \"6e1d3b628ba79b9859f741e082542a38\"\n\t\t\t  \"5502f25dbf55296c3a545e3872760ab7\",\n\t\t\t  \n\t\t\t  \"3617de4a96262c6f5d9e98bf9292dc29\"\n\t\t\t  \"f8f41dbd289a147ce9da3113b5f0b8c0\"\n\t\t\t  \"0a60b1ce1d7e819d7a431d7c90ea0e5f\",\n\t\t\t  NULL, NULL);\n\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"8d999057ba3d2d969260045c55b97f089025959a6f434d651d207d19fb96e9e4fe0e86ebe0e64f85b96a9c75295df61\",\n\t\t   \"8e80f1fa5b1b3cedb7bfe8dffd6dba74b275d875bc6cc43e904e505f256ab4255ffd43e94d39e22d61501e700a940e80\");\n\n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"77a41d4606ffa1464793c7e5fdc7d98cb9d3910202dcd06bea4f240d3566da6b408bbae5026580d02d7e5c70500c831\",\n\t\t   \"c995f7ca0b0c42837d0bbe9602a9fc998520b41c85115aa5f7684c0edc111eacc24abd6be4b5d298b65f28600a2f1df1\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d1589a1597e3a5120e1efd631c63e1835\",\n\t\t   \"cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dced7387be37bba569549f1c02b270ed67\");\n\n      break;\n    case 521:\n      ecc_curve_init_str (ecc, ECC_TYPE_WEIERSTRASS,\n\t\t\t  \"1ff\" /* p = 2^{521} - 1 */\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"ffffffffffffffffffffffffffffffff\",\n\n\t\t\t  \"051\"\n\t\t\t  \"953eb9618e1c9a1f929a21a0b68540ee\"\n\t\t\t  \"a2da725b99b315f3b8b489918ef109e1\"\n\t\t\t  \"56193951ec7e937b1652c0bd3bb1bf07\"\n\t\t\t  \"3573df883d2c34f1ef451fd46b503f00\",\n\n\t\t\t  \"1ff\"\n\t\t\t  \"ffffffffffffffffffffffffffffffff\"\n\t\t\t  \"fffffffffffffffffffffffffffffffa\"\n\t\t\t  \"51868783bf2f966b7fcc0148f709a5d0\"\n\t\t\t  \"3bb5c9b8899c47aebb6fb71e91386409\",\n\n\t\t\t  \"c6\"\n\t\t\t  \"858e06b70404e9cd9e3ecb662395b442\"\n\t\t\t  \"9c648139053fb521f828af606b4d3dba\"\n\t\t\t  \"a14b5e77efe75928fe1dc127a2ffa8de\"\n\t\t\t  \"3348b3c1856a429bf97e7e31c2e5bd66\",\n\n\t\t\t  \"118\"\n\t\t\t  \"39296a789a3bc0045c8a5fb42c7d1bd9\"\n\t\t\t  \"98f54449579b446817afbd17273e662c\"\n\t\t\t  \"97ee72995ef42640c550b9013fad0761\"\n\t\t\t  \"353c7086a272c24088be94769fd16650\",\n\t\t\t  NULL, NULL);\n\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"433c219024277e7e682fcb288148c282747403279b1ccc06352c6e5505d769be97b3b204da6ef55507aa104a3a35c5af41cf2fa364d60fd967f43e3933ba6d783d\",\n\t\t   \"f4bb8cc7f86db26700a7f3eceeeed3f0b5c6b5107c4da97740ab21a29906c42dbbb3e377de9f251f6b93937fa99a3248f4eafcbe95edc0f4f71be356d661f41b02\");\n      \n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"1a73d352443de29195dd91d6a64b5959479b52a6e5b123d9ab9e5ad7a112d7a8dd1ad3f164a3a4832051da6bd16b59fe21baeb490862c32ea05a5919d2ede37ad7d\",\n\t\t   \"13e9b03b97dfa62ddd9979f86c6cab814f2f1557fa82a9d0317d2f8ab1fa355ceec2e2dd4cf8dc575b02d5aced1dec3c70cf105c9bc93a590425f588ca1ee86c0e5\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"35b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3\",\n\t\t   \"82096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f279f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d\");\n\n      break;\n    case 255:\n      /* curve25519, y^2 = x^3 + 486662 x^2 + x (mod p), with p = 2^{255} - 19.\n\n\t According to http://cr.yp.to/papers.html#newelliptic, this\n\t is birationally equivalent to the Edwards curve\n\n\t   x^2 + y^2 = 1 + (121665/121666) x^2 y^2 (mod p).\n\n\t And since the constant is not a square, the Edwards formulas\n\t should be \"complete\", with no special cases needed for\n\t doubling, neutral element, negatives, etc.\n\n\t Generator is x = 9, with y coordinate\n\t 14781619447589544791020593568409986887264606134616475288964881837755586237401,\n\t according to\n\n\t   x = Mod(9, 2^255-19); sqrt(x^3 + 486662*x^2 + x)\n\n\t in PARI/GP. Also, in PARI notation,\n\n\t   curve25519 = Mod([0, 486662, 0, 1, 0], 2^255-19)\n       */\n      ecc_curve_init_str (ecc, ECC_TYPE_MONTGOMERY,\n\t\t\t  \"7fffffffffffffffffffffffffffffff\"\n\t\t\t  \"ffffffffffffffffffffffffffffffed\",\n\t\t\t  \"76d06\",\n\t\t\t  /* Order of the subgroup is 2^252 + q_0, where\n\t\t\t     q_0 = 27742317777372353535851937790883648493,\n\t\t\t     125 bits.\n\t\t\t  */\n\t\t\t  \"10000000000000000000000000000000\"\n\t\t\t  \"14def9dea2f79cd65812631a5cf5d3ed\",\n\t\t\t  \"9\",\n\t\t\t  /* y coordinate from PARI/GP\n\t\t\t     x = Mod(9, 2^255-19); sqrt(x^3 + 486662*x^2 + x)\n\t\t\t  */\n\t\t\t  \"20ae19a1b8a086b4e01edd2c7748d14c\"\n\t\t\t  \"923d4d7e6d7c61b229e9c5a27eced3d9\",\n\t\t\t  /* (121665/121666) mod p, from PARI/GP\n\t\t\t     c = Mod(121665, p); c / (c+1)\n\t\t\t  */\n\t\t\t  \"2dfc9311d490018c7338bf8688861767\"\n\t\t\t  \"ff8ff5b2bebe27548a14b235eca6874a\",\n\t\t\t  /* A square root of -486664 mod p, PARI/GP\n\t\t\t     -sqrt(Mod(-486664, p)) in PARI/GP.\n\n\t\t\t     Sign is important to map to the right\n\t\t\t     generator on the twisted edwards curve\n\t\t\t     used for EdDSA. */\n\t\t\t  \"70d9120b9f5ff9442d84f723fc03b081\"\n\t\t\t  \"3a5e2c2eb482e57d3391fb5500ba81e7\"\n\t\t\t  );\n      ecc->ref = ecc_alloc (3);\n      ecc_set_str (&ecc->ref[0], /* 2 g */\n\t\t   \"20d342d51873f1b7d9750c687d157114\"\n\t\t   \"8f3f5ced1e350b5c5cae469cdd684efb\",\n\t\t   \"13b57e011700e8ae050a00945d2ba2f3\"\n\t\t   \"77659eb28d8d391ebcd70465c72df563\");\n      ecc_set_str (&ecc->ref[1], /* 3 g */\n\t\t   \"1c12bc1a6d57abe645534d91c21bba64\"\n\t\t   \"f8824e67621c0859c00a03affb713c12\",\n\t\t   \"2986855cbe387eaeaceea446532c338c\"\n\t\t   \"536af570f71ef7cf75c665019c41222b\");\n\n      ecc_set_str (&ecc->ref[2], /* 4 g */\n\t\t   \"79ce98b7e0689d7de7d1d074a15b315f\"\n\t\t   \"fe1805dfcd5d2a230fee85e4550013ef\",\n\t\t   \"75af5bf4ebdc75c8fe26873427d275d7\"\n\t\t   \"3c0fb13da361077a565539f46de1c30\");\n\n      break;\n\n    default:\n      fprintf (stderr, \"No known curve for size %d\\n\", bit_size);\n      exit(EXIT_FAILURE);     \n    }\n  ecc->bit_size = bit_size;\n}",
      "lines": 266,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_pippenger_precompute": {
      "start_point": [
        613,
        0
      ],
      "end_point": [
        646,
        1
      ],
      "content": "static void\necc_pippenger_precompute (struct ecc_curve *ecc, unsigned k, unsigned c)\n{\n  unsigned p = (ecc->bit_size + k-1) / k;\n  unsigned M = (p + c-1)/c;\n  unsigned i, j;\n\n  ecc->pippenger_k = k;\n  ecc->pippenger_c = c;\n  ecc->table_size = M << c;\n  ecc->table = ecc_alloc (ecc->table_size);\n  \n  /* Compute the first 2^c entries */\n  ecc_set_zero (&ecc->table[0]);\n  ecc_set (&ecc->table[1], &ecc->g);\n\n  for (j = 2; j < (1U<<c); j <<= 1)\n    {\n      /* T[j] = 2^k T[j/2] */\n      ecc_dup (ecc, &ecc->table[j], &ecc->table[j/2]);\n      for (i = 1; i < k; i++)\n\tecc_dup (ecc, &ecc->table[j], &ecc->table[j]);\n\n      for (i = 1; i < j; i++)\n\tecc_add (ecc, &ecc->table[j + i], &ecc->table[j], &ecc->table[i]);\n    }\n  for (j = 1<<c; j < ecc->table_size; j++)\n    {\n      /* T[j] = 2^{kc} T[j-2^c] */\n      ecc_dup (ecc, &ecc->table[j], &ecc->table[j - (1<<c)]);\n      for (i = 1; i < k*c; i++)\n\tecc_dup (ecc, &ecc->table[j], &ecc->table[j]);\n    }\n}",
      "lines": 34,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_mul_pippenger": {
      "start_point": [
        648,
        0
      ],
      "end_point": [
        687,
        1
      ],
      "content": "static void\necc_mul_pippenger (const struct ecc_curve *ecc,\n\t\t   struct ecc_point *r, const mpz_t n_input)\n{\n  mpz_t n;\n  unsigned k, c;\n  unsigned i, j;\n  unsigned bit_rows;\n\n  mpz_init (n);\n  \n  mpz_mod (n, n_input, ecc->q);\n  ecc_set_zero (r);\n\n  k = ecc->pippenger_k;\n  c = ecc->pippenger_c;\n\n  bit_rows = (ecc->bit_size + k - 1) / k;\n\n  for (i = k; i-- > 0; )\n    {\n      ecc_dup (ecc, r, r);\n      for (j = 0; j * c < bit_rows; j++)\n\t{\n\t  unsigned bits;\n\t  mp_size_t bit_index;\n\t  \n\t  /* Extract c bits of the exponent, stride k, starting at i + kcj, ending at\n\t    i + k (cj + c - 1)*/\n\t  for (bits = 0, bit_index = i + k*(c*j+c); bit_index > i + k*c*j; )\n\t    {\n\t      bit_index -= k;\n\t      bits = (bits << 1) | mpz_tstbit (n, bit_index);\n\t    }\n\n\t  ecc_add (ecc, r, r, &ecc->table[(j << c) | bits]);\n\t}\n    }\n  mpz_clear (n);\n}",
      "lines": 40,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_point_out": {
      "start_point": [
        689,
        0
      ],
      "end_point": [
        702,
        1
      ],
      "content": "static void\necc_point_out (FILE *f, const struct ecc_point *p)\n{\n  if (p->is_zero)\n    fprintf (f, \"zero\");\n  else\n    {\n\tfprintf (f, \"(\");\n\tmpz_out_str (f, 16, p->x);\n\tfprintf (f, \",\\n     \");\n\tmpz_out_str (f, 16, (p)->y);\n\tfprintf (f, \")\");\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "ecc_curve_check": {
      "start_point": [
        729,
        0
      ],
      "end_point": [
        795,
        1
      ],
      "content": "static void\necc_curve_check (const struct ecc_curve *ecc)\n{\n  struct ecc_point p, q;\n  mpz_t n;\n\n  ecc_init (&p);\n  ecc_init (&q);\n  mpz_init (n);\n\n  ecc_dup (ecc, &p, &ecc->g);\n  if (ecc->ref)\n    ASSERT_EQUAL (&p, &ecc->ref[0]);\n  else\n    {\n      fprintf (stderr, \"g2 = \");\n      mpz_out_str (stderr, 16, p.x);\n      fprintf (stderr, \"\\n     \");\n      mpz_out_str (stderr, 16, p.y);\n      fprintf (stderr, \"\\n\");\n    }\n  ecc_add (ecc, &q, &p, &ecc->g);\n  if (ecc->ref)\n    ASSERT_EQUAL (&q, &ecc->ref[1]);\n  else\n    {\n      fprintf (stderr, \"g3 = \");\n      mpz_out_str (stderr, 16, q.x);\n      fprintf (stderr, \"\\n     \");\n      mpz_out_str (stderr, 16, q.y);\n      fprintf (stderr, \"\\n\");\n    }\n\n  ecc_add (ecc, &q, &q, &ecc->g);\n  if (ecc->ref)\n    ASSERT_EQUAL (&q, &ecc->ref[2]);\n  else\n    {\n      fprintf (stderr, \"g4 = \");\n      mpz_out_str (stderr, 16, q.x);\n      fprintf (stderr, \"\\n     \");\n      mpz_out_str (stderr, 16, q.y);\n      fprintf (stderr, \"\\n\");\n    }\n\n  ecc_dup (ecc, &q, &p);\n  if (ecc->ref)\n    ASSERT_EQUAL (&q, &ecc->ref[2]);\n  else\n    {\n      fprintf (stderr, \"g4 = \");\n      mpz_out_str (stderr, 16, q.x);\n      fprintf (stderr, \"\\n     \");\n      mpz_out_str (stderr, 16, q.y);\n      fprintf (stderr, \"\\n\");\n    }\n\n  ecc_mul_binary (ecc, &p, ecc->q, &ecc->g);\n  ASSERT_ZERO (&p);\n\n  ecc_mul_pippenger (ecc, &q, ecc->q);\n  ASSERT_ZERO (&q);\n\n  ecc_clear (&p);\n  ecc_clear (&q);\n  mpz_clear (n);\n}",
      "lines": 67,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_digits": {
      "start_point": [
        797,
        0
      ],
      "end_point": [
        833,
        1
      ],
      "content": "static void\noutput_digits (const mpz_t x,\n\t       unsigned size, unsigned bits_per_limb)\n{  \n  mpz_t t;\n  mpz_t mask;\n  mpz_t limb;\n  unsigned i;\n  const char *suffix;\n\n  mpz_init (t);\n  mpz_init (mask);\n  mpz_init (limb);\n\n  mpz_setbit (mask, bits_per_limb);\n  mpz_sub_ui (mask, mask, 1);\n\n  suffix = bits_per_limb > 32 ? \"ULL\" : \"UL\";\n\n  mpz_init_set (t, x);\n\n  for (i = 0; i < size; i++)\n    {\n      if ( (i % 8) == 0)\n\tprintf(\"\\n \");\n      \n      mpz_and (limb, mask, t);\n      printf (\" 0x\");\n      mpz_out_str (stdout, 16, limb);\n      printf (\"%s,\", suffix);\n      mpz_tdiv_q_2exp (t, t, bits_per_limb);\n    }\n\n  mpz_clear (t);\n  mpz_clear (mask);\n  mpz_clear (limb);\n}",
      "lines": 37,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_bignum": {
      "start_point": [
        835,
        0
      ],
      "end_point": [
        842,
        1
      ],
      "content": "static void\noutput_bignum (const char *name, const mpz_t x,\n\t       unsigned size, unsigned bits_per_limb)\n{  \n  printf (\"static const mp_limb_t %s[%d] = {\", name, size);\n  output_digits (x, size, bits_per_limb);\n  printf(\"\\n};\\n\");\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_point": {
      "start_point": [
        844,
        0
      ],
      "end_point": [
        907,
        1
      ],
      "content": "static void\noutput_point (const char *name, const struct ecc_curve *ecc,\n\t      const struct ecc_point *p, int use_redc,\n\t      unsigned size, unsigned bits_per_limb)\n{\n  mpz_t x, y, t;\n\n  mpz_init (x);\n  mpz_init (y);\n  mpz_init (t);\n \n  if (name)\n    printf(\"static const mp_limb_t %s[%u] = {\", name, 2*size);\n\n  if (ecc->use_edwards)\n    {\n      if (ecc_zero_p (p))\n\t{\n\t  mpz_set_si (x, 0);\n\t  mpz_set_si (y, 1);\n\t}\n      else if (!mpz_sgn (p->y))\n\t{\n\t  assert (!mpz_sgn (p->x));\n\t  mpz_set_si (x, 0);\n\t  mpz_set_si (y, -1);\n\t}\n      else\n\t{\n\t  mpz_invert (x, p->y, ecc->p);\n\t  mpz_mul (x, x, p->x);\n\t  mpz_mul (x, x, ecc->t);\t \n\t  mpz_mod (x, x, ecc->p);\n\n\t  mpz_sub_ui (y, p->x, 1);\n\t  mpz_add_ui (t, p->x, 1);\n\t  mpz_invert (t, t, ecc->p);\n\t  mpz_mul (y, y, t);\n\t  mpz_mod (y, y, ecc->p);\n\t}\n    }\n  else\n    {\n      mpz_set (x, p->x);\n      mpz_set (y, p->y);\n    }\n  if (use_redc)\n    {\n      mpz_mul_2exp (x, x, size * bits_per_limb);\n      mpz_mod (x, x, ecc->p);\n      mpz_mul_2exp (y, y, size * bits_per_limb);\n      mpz_mod (y, y, ecc->p);\n    }\n      \n  output_digits (x, size, bits_per_limb);\n  output_digits (y, size, bits_per_limb);\n\n  if (name)\n    printf(\"\\n};\\n\");\n\n  mpz_clear (x);\n  mpz_clear (y);\n  mpz_clear (t);\n}",
      "lines": 64,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "output_modulo": {
      "start_point": [
        909,
        0
      ],
      "end_point": [
        926,
        1
      ],
      "content": "static unsigned\noutput_modulo (const char *name, const mpz_t x,\n\t       unsigned size, unsigned bits_per_limb)\n{\n  mpz_t mod;\n  unsigned bits;\n\n  mpz_init (mod);\n\n  mpz_setbit (mod, bits_per_limb * size);\n  mpz_mod (mod, mod, x);\n\n  bits = mpz_sizeinbase (mod, 2);\n  output_bignum (name, mod, size, bits_per_limb);\n  \n  mpz_clear (mod);\n  return bits;\n}",
      "lines": 18,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "output_curve": {
      "start_point": [
        928,
        0
      ],
      "end_point": [
        1145,
        1
      ],
      "content": "static void\noutput_curve (const struct ecc_curve *ecc, unsigned bits_per_limb)\n{\n  unsigned limb_size = (ecc->bit_size + bits_per_limb - 1)/bits_per_limb;\n  unsigned i;\n  unsigned bits, e;\n  int redc_limbs;\n  mpz_t t;\n\n  mpz_init (t);\n\n  printf (\"/* For NULL. */\\n#include <stddef.h>\\n\");\n\n  printf (\"#define ECC_LIMB_SIZE %u\\n\", limb_size);\n  printf (\"#define ECC_PIPPENGER_K %u\\n\", ecc->pippenger_k);\n  printf (\"#define ECC_PIPPENGER_C %u\\n\", ecc->pippenger_c);\n\n  output_bignum (\"ecc_p\", ecc->p, limb_size, bits_per_limb);\n  output_bignum (\"ecc_b\", ecc->b, limb_size, bits_per_limb);\n  if (ecc->use_edwards)\n    output_bignum (\"ecc_d\", ecc->d, limb_size, bits_per_limb);\n  output_bignum (\"ecc_q\", ecc->q, limb_size, bits_per_limb);\n  output_point (\"ecc_g\", ecc, &ecc->g, 0, limb_size, bits_per_limb);\n  \n  bits = output_modulo (\"ecc_Bmodp\", ecc->p, limb_size, bits_per_limb);\n  printf (\"#define ECC_BMODP_SIZE %u\\n\",\n\t  (bits + bits_per_limb - 1) / bits_per_limb);\n  bits = output_modulo (\"ecc_Bmodq\", ecc->q, limb_size, bits_per_limb);\n  printf (\"#define ECC_BMODQ_SIZE %u\\n\",\n\t  (bits + bits_per_limb - 1) / bits_per_limb);\n  bits = mpz_sizeinbase (ecc->q, 2);\n  if (bits < ecc->bit_size)\n    {\n      /* for curve25519, with q = 2^k + q', with a much smaller q' */\n      unsigned mbits;\n      unsigned shift;\n\n      /* Shift to align the one bit at B */\n      shift = bits_per_limb * limb_size + 1 - bits;\n      \n      mpz_set (t, ecc->q);\n      mpz_clrbit (t, bits-1);\n      mbits = mpz_sizeinbase (t, 2);\n\n      /* The shifted value must be a limb smaller than q. */\n      if (mbits + shift + bits_per_limb <= bits)\n\t{\n\t  /* q of the form 2^k + q', with q' a limb smaller */\n\t  mpz_mul_2exp (t, t, shift);\n\t  output_bignum (\"ecc_mBmodq_shifted\", t, limb_size, bits_per_limb);\n\t}\n    }\n\n  if (ecc->bit_size < limb_size * bits_per_limb)\n    {\n      int shift;\n\n      mpz_set_ui (t, 0);\n      mpz_setbit (t, ecc->bit_size);\n      mpz_sub (t, t, ecc->p);      \n      output_bignum (\"ecc_Bmodp_shifted\", t, limb_size, bits_per_limb);\n\n      shift = limb_size * bits_per_limb - ecc->bit_size;\n      if (shift > 0)\n\t{\n\t  /* Check condition for reducing hi limbs. If s is the\n\t     normalization shift and n is the bit size (so that s + n\n\t     = limb_size * bite_per_limb), then we need\n\n\t       (2^n - 1) + (2^s - 1) (2^n - p) < 2p\n\n\t     or equivalently,\n\n\t       2^s (2^n - p) <= p\n\n\t     To a allow a carry limb to be added in at the same time,\n\t     substitute s+1 for s.\n\t  */\n\t  /* FIXME: For ecdsa verify, we actually need the stricter\n\t     inequality < 2 q. */\n\t  mpz_mul_2exp (t, t, shift + 1);\n\t  if (mpz_cmp (t, ecc->p) > 0)\n\t    {\n\t      fprintf (stderr, \"Reduction condition failed for %u-bit curve.\\n\",\n\t\t       ecc->bit_size);\n\t      exit (EXIT_FAILURE);\n\t    }\n\t}\n    }\n  else\n    printf (\"#define ecc_Bmodp_shifted ecc_Bmodp\\n\");\n\n  if (bits < limb_size * bits_per_limb)\n    {\n      mpz_set_ui (t, 0);\n      mpz_setbit (t, bits);\n      mpz_sub (t, t, ecc->q);      \n      output_bignum (\"ecc_Bmodq_shifted\", t, limb_size, bits_per_limb);      \n    }\n  else\n    printf (\"#define ecc_Bmodq_shifted ecc_Bmodq\\n\");\n\n  mpz_add_ui (t, ecc->p, 1);\n  mpz_fdiv_q_2exp (t, t, 1);\n  output_bignum (\"ecc_pp1h\", t, limb_size, bits_per_limb);      \n\n  mpz_add_ui (t, ecc->q, 1);\n  mpz_fdiv_q_2exp (t, t, 1);\n  output_bignum (\"ecc_qp1h\", t, limb_size, bits_per_limb);  \n\n  if (ecc->use_edwards)\n    output_bignum (\"ecc_edwards\", ecc->t, limb_size, bits_per_limb);\n\n  /* Trailing zeros in p+1 correspond to trailing ones in p. */\n  redc_limbs = mpz_scan0 (ecc->p, 0) / bits_per_limb;\n  if (redc_limbs > 0)\n    {\n      mpz_add_ui (t, ecc->p, 1);\n      mpz_fdiv_q_2exp (t, t, redc_limbs * bits_per_limb);\n      output_bignum (\"ecc_redc_ppm1\", t, limb_size - redc_limbs, bits_per_limb);\n    }\n  else\n    {    \n      /* Trailing zeros in p-1 correspond to zeros just above the low\n\t bit of p */\n      redc_limbs = mpz_scan1 (ecc->p, 1) / bits_per_limb;\n      if (redc_limbs > 0)\n\t{\n\t  printf (\"#define ecc_redc_ppm1 (ecc_p + %d)\\n\",\n\t\t  redc_limbs);\n\t  redc_limbs = -redc_limbs;\n\t}\n      else\n\tprintf (\"#define ecc_redc_ppm1 NULL\\n\");\n    }\n  printf (\"#define ECC_REDC_SIZE %d\\n\", redc_limbs);\n\n  /* For mod p square root computation. */\n  if (mpz_fdiv_ui (ecc->p, 4) == 3)\n    {\n      /* x = a^{(p+1)/4} gives square root of a (if it exists,\n\t otherwise the square root of -a). */\n      e = 1;\n      mpz_add_ui (t, ecc->p, 1);\n      mpz_fdiv_q_2exp (t, t, 2); \n    }\n  else\n    {\n      /* p-1 = 2^e s, s odd, t = (s-1)/2*/\n      unsigned g, i;\n      mpz_t s;\n      mpz_t z;\n\n      mpz_init (s);\n      mpz_init (z);\n\n      mpz_sub_ui (s, ecc->p, 1);\n      e = mpz_scan1 (s, 0);\n      assert (e > 1);\n\n      mpz_fdiv_q_2exp (s, s, e);\n\n      /* Find a non-square g, g^{(p-1)/2} = -1,\n\t and z = g^{(p-1)/4 */\n      for (g = 2; ; g++)\n\t{\n\t  mpz_set_ui (z, g);\n\t  mpz_powm (z, z, s, ecc->p);\n\t  mpz_mul (t, z, z);\n\t  mpz_mod (t, t, ecc->p);\n\n\t  for (i = 2; i < e; i++)\n\t    {\n\t      mpz_mul (t, t, t);\n\t      mpz_mod (t, t, ecc->p);\n\t    }\n\t  if (mpz_cmp_ui (t, 1) != 0)\n\t    break;\n\t}\n      mpz_add_ui (t, t, 1);\n      assert (mpz_cmp (t, ecc->p) == 0);\n      output_bignum (\"ecc_sqrt_z\", z, limb_size, bits_per_limb);\n\n      mpz_fdiv_q_2exp (t, s, 1);\n\n      mpz_clear (s);\n      mpz_clear (z);\n    }\n  printf (\"#define ECC_SQRT_E %u\\n\", e);\n  printf (\"#define ECC_SQRT_T_BITS %u\\n\",\n\t  (unsigned) mpz_sizeinbase (t, 2));\n  output_bignum (\"ecc_sqrt_t\", t, limb_size, bits_per_limb);      \n\n  printf (\"#if USE_REDC\\n\");\n  printf (\"#define ecc_unit ecc_Bmodp\\n\");\n\n  printf (\"static const mp_limb_t ecc_table[%lu] = {\",\n\t (unsigned long) (2*ecc->table_size * limb_size));\n  for (i = 0; i < ecc->table_size; i++)\n    output_point (NULL, ecc, &ecc->table[i], 1, limb_size, bits_per_limb);\n\n  printf(\"\\n};\\n\");\n\n  printf (\"#else\\n\");\n\n  mpz_init_set_ui (t, 1);\n  output_bignum (\"ecc_unit\", t, limb_size, bits_per_limb);\n  \n  printf (\"static const mp_limb_t ecc_table[%lu] = {\",\n\t (unsigned long) (2*ecc->table_size * limb_size));\n  for (i = 0; i < ecc->table_size; i++)\n    output_point (NULL, ecc, &ecc->table[i], 0, limb_size, bits_per_limb);\n\n  printf(\"\\n};\\n\");\n  printf (\"#endif\\n\");\n  \n  mpz_clear (t);\n}",
      "lines": 218,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        1147,
        0
      ],
      "end_point": [
        1171,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  struct ecc_curve ecc;\n\n  if (argc < 4)\n    {\n      fprintf (stderr, \"Usage: %s CURVE-BITS K C [BITS-PER-LIMB]\\n\", argv[0]);\n      return EXIT_FAILURE;\n    }\n\n  ecc_curve_init (&ecc, atoi(argv[1]));\n\n  ecc_pippenger_precompute (&ecc, atoi(argv[2]), atoi(argv[3]));\n\n  fprintf (stderr, \"Table size: %lu entries\\n\",\n\t   (unsigned long) ecc.table_size);\n\n  ecc_curve_check (&ecc);\n\n  if (argc > 4)\n    output_curve (&ecc, atoi(argv[4]));\n\n  return EXIT_SUCCESS;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecdsa-keygen.c": {
    "ecdsa_generate_keypair": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\necdsa_generate_keypair (struct ecc_point *pub,\n\t\t\tstruct ecc_scalar *key,\n\t\t\tvoid *random_ctx, nettle_random_func *random)\n{\n  TMP_DECL(p, mp_limb_t, 3*ECC_MAX_SIZE + ECC_MUL_G_ITCH (ECC_MAX_SIZE));\n  const struct ecc_curve *ecc = pub->ecc;\n  mp_size_t itch = 3*ecc->p.size + ecc->mul_g_itch;\n\n  assert (key->ecc == ecc);\n\n  TMP_ALLOC (p, itch);\n\n  ecc_mod_random (&ecc->q, key->p, random_ctx, random, p);\n  ecc->mul_g (ecc, p, key->p, p + 3*ecc->p.size);\n  ecc->h_to_a (ecc, 0, pub->p, p, p + 3*ecc->p.size);\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecdsa-sign.c": {
    "ecdsa_sign": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\necdsa_sign (const struct ecc_scalar *key,\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t digest_length,\n\t    const uint8_t *digest,\n\t    struct dsa_signature *signature)\n{\n  /* At most 936 bytes. */\n  TMP_DECL(k, mp_limb_t, ECC_MAX_SIZE + ECC_ECDSA_SIGN_ITCH (ECC_MAX_SIZE));\n  mp_limb_t size = key->ecc->p.size;\n  mp_limb_t *rp = mpz_limbs_write (signature->r, size);\n  mp_limb_t *sp = mpz_limbs_write (signature->s, size);\n\n  TMP_ALLOC (k, size + ECC_ECDSA_SIGN_ITCH (size));\n\n  /* Timing reveals the number of rounds through this loop, but the\n     timing is still independent of the secret k finally used. */\n  do\n    {\n      ecc_mod_random (&key->ecc->q, k, random_ctx, random, k + size);\n      ecc_ecdsa_sign (key->ecc, key->p, k, digest_length, digest,\n\t\t   rp, sp, k + size);\n      mpz_limbs_finish (signature->r, size);\n      mpz_limbs_finish (signature->s, size);\n    }\n  while (mpz_sgn (signature->r) == 0 || mpz_sgn (signature->s) == 0);\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecdsa-verify.c": {
    "ecdsa_verify": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\necdsa_verify (const struct ecc_point *pub,\n\t      size_t length, const uint8_t *digest,\n\t      const struct dsa_signature *signature)\n{\n  mp_limb_t size = ecc_size (pub->ecc);\n  mp_size_t itch = 2*size + ecc_ecdsa_verify_itch (pub->ecc);\n  /* For ECC_MUL_A_WBITS == 0, at most 1512 bytes. With\n     ECC_MUL_A_WBITS == 4, currently needs 67 * ecc->size, at most\n     4824 bytes. Don't use stack allocation for this. */\n  mp_limb_t *scratch;\n  int res;\n\n#define rp scratch\n#define sp (scratch + size)\n#define scratch_out (scratch + 2*size)\n\n  if (mpz_sgn (signature->r) <= 0 || mpz_size (signature->r) > size\n      || mpz_sgn (signature->s) <= 0 || mpz_size (signature->s) > size)\n    return 0;\n\n  scratch = gmp_alloc_limbs (itch);\n  \n  mpz_limbs_copy (rp, signature->r, size);\n  mpz_limbs_copy (sp, signature->s, size);\n\n  res = ecc_ecdsa_verify (pub->ecc, pub->p, length, digest, rp, sp, scratch_out);\n\n  gmp_free_limbs (scratch, itch);\n\n  return res;\n#undef rp\n#undef sp\n#undef scratch_out\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/ecdsa.h": {},
  "nettle/nettle-3.4.1/ed25519-sha512-pubkey.c": {
    "ed25519_sha512_public_key": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ned25519_sha512_public_key (uint8_t *pub, const uint8_t *priv)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  struct sha512_ctx ctx;\n  uint8_t digest[SHA512_DIGEST_SIZE];\n  mp_size_t itch = ecc->q.size + _eddsa_public_key_itch (ecc);\n  mp_limb_t *scratch = gmp_alloc_limbs (itch);\n\n#define k scratch\n#define scratch_out (scratch + ecc->q.size)\n\n  _eddsa_expand_key (ecc, &nettle_sha512, &ctx, priv, digest, k);\n  _eddsa_public_key (ecc, k, pub, scratch_out);\n\n  gmp_free_limbs (scratch, itch);\n#undef k\n#undef scratch_out\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ed25519-sha512-sign.c": {
    "ed25519_sha512_sign": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ned25519_sha512_sign (const uint8_t *pub,\n\t\t     const uint8_t *priv,\n\t\t     size_t length, const uint8_t *msg,\n\t\t     uint8_t *signature)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  mp_size_t itch = ecc->q.size + _eddsa_sign_itch (ecc);\n  mp_limb_t *scratch = gmp_alloc_limbs (itch);\n#define k2 scratch\n#define scratch_out (scratch + ecc->q.size)\n  struct sha512_ctx ctx;\n  uint8_t digest[SHA512_DIGEST_SIZE];\n#define k1 (digest + ED25519_KEY_SIZE)\n\n  _eddsa_expand_key (ecc, &nettle_sha512, &ctx, priv, digest, k2);\n\n  sha512_update (&ctx, ED25519_KEY_SIZE, k1);\n  _eddsa_sign (ecc, &nettle_sha512, pub,\n\t       &ctx,\n\t       k2, length, msg, signature, scratch_out);\n\n  gmp_free_limbs (scratch, itch);\n#undef k1\n#undef k2\n#undef scratch_out\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ed25519-sha512-verify.c": {
    "ed25519_sha512_verify": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "int\ned25519_sha512_verify (const uint8_t *pub,\n\t\t       size_t length, const uint8_t *msg,\n\t\t       const uint8_t *signature)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  mp_size_t itch = 3*ecc->p.size + _eddsa_verify_itch (ecc);\n  mp_limb_t *scratch = gmp_alloc_limbs (itch);\n  struct sha512_ctx ctx;\n  int res;\n#define A scratch\n#define scratch_out (scratch + 3*ecc->p.size)\n  res = (_eddsa_decompress (ecc,\n\t\t\t    A, pub, scratch_out)\n\t && _eddsa_verify (ecc, &nettle_sha512,\n\t\t\t   pub, A, &ctx,\n\t\t\t   length, msg, signature,\n\t\t\t   scratch_out));\n  gmp_free_limbs (scratch, itch);\n  return res;\n#undef A\n#undef scratch_out\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-compress.c": {
    "_eddsa_compress_itch": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "mp_size_t\n_eddsa_compress_itch (const struct ecc_curve *ecc)\n{\n  return 2*ecc->p.size + ecc->h_to_a_itch;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_eddsa_compress": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\n_eddsa_compress (const struct ecc_curve *ecc, uint8_t *r, mp_limb_t *p,\n\t\t mp_limb_t *scratch)\n{\n#define xp scratch\n#define yp (scratch + ecc->p.size)\n#define scratch_out (scratch + 2*ecc->p.size)\n\n  ecc->h_to_a (ecc, 0, xp, p, scratch_out);\n  /* Encoding is the y coordinate and an appended \"sign\" bit, which is\n     the low bit of x. Bit order is not specified explicitly, but for\n     little-endian encoding, it makes most sense to append the bit\n     after the most significant bit of y. */\n  mpn_get_base256_le (r, 1 + ecc->p.bit_size / 8, yp, ecc->p.size);\n  r[ecc->p.bit_size / 8] += (xp[0] & 1) << (ecc->p.bit_size & 7);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-decompress.c": {
    "_eddsa_decompress_itch": {
      "start_point": [
        40,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "mp_size_t\n_eddsa_decompress_itch (const struct ecc_curve *ecc)\n{\n  return 4*ecc->p.size + ecc->p.sqrt_itch;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_eddsa_decompress": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\n_eddsa_decompress (const struct ecc_curve *ecc, mp_limb_t *p,\n\t\t   const uint8_t *cp,\n\t\t   mp_limb_t *scratch)\n{\n  mp_limb_t sign, cy;\n  int res;\n\n#define xp p\n#define yp (p + ecc->p.size)\n\n#define y2 scratch\n#define vp (scratch + ecc->p.size)\n#define up scratch\n#define tp (scratch + 2*ecc->p.size)\n#define scratch_out (scratch + 4*ecc->p.size)\n\n  sign = cp[ecc->p.bit_size / 8] >> (ecc->p.bit_size & 7);\n  if (sign > 1)\n    return 0;\n  mpn_set_base256_le (yp, ecc->p.size, cp, 1 + ecc->p.bit_size / 8);\n  /* Clear out the sign bit (if it fits) */\n  yp[ecc->p.size - 1] &= ~(mp_limb_t) 0\n    >> (ecc->p.size * GMP_NUMB_BITS - ecc->p.bit_size);\n  ecc_modp_sqr (ecc, y2, yp);\n  ecc_modp_mul (ecc, vp, y2, ecc->b);\n  ecc_modp_sub (ecc, vp, vp, ecc->unit);\n  ecc_modp_sub (ecc, up, ecc->unit, y2);\n  res = ecc->p.sqrt (&ecc->p, tp, up, vp, scratch_out);\n\n  cy = mpn_sub_n (xp, tp, ecc->p.m, ecc->p.size);\n  cnd_copy (cy, xp, tp, ecc->p.size);\n  sign ^= xp[0] & 1;\n  mpn_sub_n (tp, ecc->p.m, xp, ecc->p.size);\n  cnd_copy (sign, xp, tp, ecc->p.size);\n  return res;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-expand.c": {
    "_eddsa_expand_key": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\n_eddsa_expand_key (const struct ecc_curve *ecc,\n\t\t   const struct nettle_hash *H,\n\t\t   void *ctx,\n\t\t   const uint8_t *key,\n\t\t   uint8_t *digest,\n\t\t   mp_limb_t *k2)\n{\n  size_t nbytes = 1 + ecc->p.bit_size / 8;\n\n  assert (H->digest_size >= 2*nbytes);\n\n  H->init (ctx);\n  H->update (ctx, nbytes, key);\n  H->digest (ctx, 2*nbytes, digest);\n\n  mpn_set_base256_le (k2, ecc->p.size, digest, nbytes);\n  /* Clear low 3 bits */\n  k2[0] &= ~(mp_limb_t) 7;\n  /* Set bit number bit_size - 1 (bit 254 for curve25519) */\n  k2[(ecc->p.bit_size - 1) / GMP_NUMB_BITS]\n    |= (mp_limb_t) 1 << ((ecc->p.bit_size - 1) % GMP_NUMB_BITS);\n  /* Clear any higher bits. */\n  k2[ecc->p.size - 1] &= ~(mp_limb_t) 0\n    >> (GMP_NUMB_BITS * ecc->p.size - ecc->p.bit_size);\n}",
      "lines": 26,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-hash.c": {
    "_eddsa_hash": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\n_eddsa_hash (const struct ecc_modulo *m,\n\t     mp_limb_t *rp, const uint8_t *digest)\n{\n  size_t nbytes = 1 + m->bit_size / 8;\n  mpn_set_base256_le (rp, 2*m->size, digest, 2*nbytes);\n  m->mod (m, rp);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-pubkey.c": {
    "_eddsa_public_key_itch": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "mp_size_t\n_eddsa_public_key_itch (const struct ecc_curve *ecc)\n{\n  return 3*ecc->p.size + ecc->mul_g_itch;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_eddsa_public_key": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\n_eddsa_public_key (const struct ecc_curve *ecc,\n\t\t   const mp_limb_t *k, uint8_t *pub, mp_limb_t *scratch)\n{\n#define P scratch\n#define scratch_out (scratch + 3*ecc->p.size)\n  ecc->mul_g (ecc, P, k, scratch_out);\n  _eddsa_compress (ecc, pub, P, scratch_out);\n#undef P\n#undef scratch_out\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-sign.c": {
    "_eddsa_sign_itch": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "mp_size_t\n_eddsa_sign_itch (const struct ecc_curve *ecc)\n{\n  return 5*ecc->p.size + ecc->mul_g_itch;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_eddsa_sign": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "void\n_eddsa_sign (const struct ecc_curve *ecc,\n\t     const struct nettle_hash *H,\n\t     const uint8_t *pub,\n\t     void *ctx,\n\t     const mp_limb_t *k2,\n\t     size_t length,\n\t     const uint8_t *msg,\n\t     uint8_t *signature,\n\t     mp_limb_t *scratch)\n{\n  mp_size_t size;\n  size_t nbytes;\n#define rp scratch\n#define hp (scratch + size)\n#define P (scratch + 2*size)\n#define sp (scratch + 2*size)\n#define hash ((uint8_t *) (scratch + 3*size))\n#define scratch_out (scratch + 5*size)\n\n  size = ecc->p.size;\n  nbytes = 1 + ecc->p.bit_size / 8;\n\n  assert (H->digest_size >= 2 * nbytes);\n\n  H->update (ctx, length, msg);\n  H->digest (ctx, 2*nbytes, hash);\n  _eddsa_hash (&ecc->q, rp, hash);\n  ecc->mul_g (ecc, P, rp, scratch_out);\n  _eddsa_compress (ecc, signature, P, scratch_out);\n\n  H->update (ctx, nbytes, signature);\n  H->update (ctx, nbytes, pub);\n  H->update (ctx, length, msg);\n  H->digest (ctx, 2*nbytes, hash);\n  _eddsa_hash (&ecc->q, hp, hash);\n\n  ecc_modq_mul (ecc, sp, hp, k2);\n  ecc_modq_add (ecc, sp, sp, rp); /* FIXME: Can be plain add */\n  /* FIXME: Special code duplicated in ecc_25519_modq and ecc_eh_to_a.\n     Define a suitable method? */\n  {\n    unsigned shift;\n    mp_limb_t cy;\n    assert (ecc->p.bit_size == 255);\n    shift = 252 - GMP_NUMB_BITS * (ecc->p.size - 1);\n    cy = mpn_submul_1 (sp, ecc->q.m, ecc->p.size,\n\t\t       sp[ecc->p.size-1] >> shift);\n    assert (cy < 2);\n    cnd_add_n (cy, sp, ecc->q.m, ecc->p.size);\n  }\n  mpn_get_base256_le (signature + nbytes, nbytes, sp, ecc->q.size);\n#undef rp\n#undef hp\n#undef P\n#undef sp\n#undef hash\n}",
      "lines": 58,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa-verify.c": {
    "equal_h": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static int\nequal_h (const struct ecc_modulo *p,\n\t const mp_limb_t *x1, const mp_limb_t *z1,\n\t const mp_limb_t *x2, const mp_limb_t *z2,\n\t mp_limb_t *scratch)\n{\n#define t0 scratch\n#define t1 (scratch + p->size)\n\n  ecc_mod_mul (p, t0, x1, z2);\n  if (mpn_cmp (t0, p->m, p->size) >= 0)\n    mpn_sub_n (t0, t0, p->m, p->size);\n\n  ecc_mod_mul (p, t1, x2, z1);\n  if (mpn_cmp (t1, p->m, p->size) >= 0)\n    mpn_sub_n (t1, t1, p->m, p->size);\n\n  return mpn_cmp (t0, t1, p->size) == 0;\n\n#undef t0\n#undef t1\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "_eddsa_verify_itch": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "mp_size_t\n_eddsa_verify_itch (const struct ecc_curve *ecc)\n{\n  return 8*ecc->p.size + ecc->mul_itch;\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_eddsa_verify": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "int\n_eddsa_verify (const struct ecc_curve *ecc,\n\t       const struct nettle_hash *H,\n\t       const uint8_t *pub,\n\t       const mp_limb_t *A,\n\t       void *ctx,\n\t       size_t length,\n\t       const uint8_t *msg,\n\t       const uint8_t *signature,\n\t       mp_limb_t *scratch)\n{\n  size_t nbytes;\n#define R scratch\n#define sp (scratch + 2*ecc->p.size)\n#define hp (scratch + 3*ecc->p.size)\n#define P (scratch + 5*ecc->p.size)\n#define scratch_out (scratch + 8*ecc->p.size)\n#define S R\n#define hash ((uint8_t *) P)\n\n  nbytes = 1 + ecc->p.bit_size / 8;\n\n  /* Could maybe save some storage by delaying the R and S operations,\n     but it makes sense to check them for validity up front. */\n  if (!_eddsa_decompress (ecc, R, signature, R+2*ecc->p.size))\n    return 0;\n\n  mpn_set_base256_le (sp, ecc->q.size, signature + nbytes, nbytes);\n  /* Check that s < q */\n  if (mpn_cmp (sp, ecc->q.m, ecc->q.size) >= 0)\n    return 0;\n\n  H->init (ctx);\n  H->update (ctx, nbytes, signature);\n  H->update (ctx, nbytes, pub);\n  H->update (ctx, length, msg);\n  H->digest (ctx, 2*nbytes, hash);\n  _eddsa_hash (&ecc->q, hp, hash);\n\n  /* Compute h A + R - s G, which should be the neutral point */\n  ecc->mul (ecc, P, hp, A, scratch_out);\n  ecc_add_eh (ecc, P, P, R, scratch_out);\n  /* Move out of the way. */\n  mpn_copyi (hp, sp, ecc->q.size);\n  ecc->mul_g (ecc, S, hp, scratch_out);\n\n  return equal_h (&ecc->p,\n\t\t   P, P + 2*ecc->p.size,\n\t\t   S, S + 2*ecc->p.size, scratch_out)\n    && equal_h (&ecc->p,\n\t\tP + ecc->p.size, P + 2*ecc->p.size,\n\t\tS + ecc->p.size, S + 2*ecc->p.size, scratch_out);\n\n#undef R\n#undef sp\n#undef hp\n#undef P\n#undef S\n}",
      "lines": 59,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/eddsa.h": {},
  "nettle/nettle-3.4.1/fat-arm.c": {
    "get_arm_features": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\nget_arm_features (struct arm_features *features)\n{\n  const char *s;\n  features->arch_version = 5;\n  features->have_neon = 0;\n\n  s = secure_getenv (ENV_OVERRIDE);\n  if (s)\n    for (;;)\n      {\n\tconst char *sep = strchr (s, ',');\n\tsize_t length = sep ? (size_t) (sep - s) : strlen(s);\n\n\tif (SKIP (s, length, \"arch:\", 5))\n\t  {\n\t    if (length == 1 && *s >= '0' && *s <= '9')\n\t      features->arch_version = *s - '0';\n\t  }\n\telse if (MATCH (s, length, \"neon\", 4))\n\t  features->have_neon = 1;\n\tif (!sep)\n\t  break;\n\ts = sep + 1;\n      }\n  else\n    {\n      FILE *f;\n      char line[200];\n      int seen_arch = 0;\n      int seen_features = 0;\n\n      f = fopen (\"/proc/cpuinfo\", \"r\");\n      if (!f)\n\treturn;\n      while (seen_features + seen_arch < 2\n\t     && fgets (line, sizeof(line), f))\n\t{\n\t  char *sep;\n\t  char *p;\n\t  sep = strchr (line, ':');\n\t  if (!sep)\n\t    continue;\n\t  for (p = sep; p - line > 0 && p[-1] == '\\t'; p--)\n\t    ;\n\n\t  *p = '\\0';\n\t  p = sep+1;\n\n\t  if (strcmp (line, \"Features\") == 0)\n\t    {\n\t      features->have_neon = (strstr (p, \" neon \") != NULL);\n\t      seen_features = 1;\n\t    }\n\t  else if (strcmp (line, \"CPU architecture\") == 0)\n\t    {\n\t      /* Don't use strtol, since it's locale dependent. */\n\t      while (p[0] == ' ')\n\t\tp++;\n\t      if (p[0] > '5' && p[0] <= '9')\n\t\tfeatures->arch_version = p[0] - '0';\n\t      else if (strcmp (p, \"AArch64\") == 0)\n\t\tfeatures->arch_version = 8;\n\t      seen_arch = 1;\n\t    }\n\t}\n      if (features->arch_version >= 8)\n\t{\n\t  /* Neon is not required, and maybe not listed in feature flags */\n\t  features->have_neon = 1;\n\t}\n      fclose (f);\n    }\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "CONSTRUCTOR": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void CONSTRUCTOR\nfat_init (void)\n{\n  struct arm_features features;\n  int verbose;\n\n  get_arm_features (&features);\n\n  verbose = getenv (ENV_VERBOSE) != NULL;\n  if (verbose)\n    fprintf (stderr, \"libnettle: cpu features: arch:%d%s\\n\",\n\t     features.arch_version,\n\t     features.have_neon ? \",neon\" : \"\");\n\n  if (features.arch_version >= 6)\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: enabling armv6 code.\\n\");\n      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_armv6;\n      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_armv6;\n      _nettle_sha1_compress_vec = _nettle_sha1_compress_armv6;\n      _nettle_sha256_compress_vec = _nettle_sha256_compress_armv6;\n    }\n  else\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: not enabling armv6 code.\\n\");\n      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_arm;\n      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_arm;\n      _nettle_sha1_compress_vec = _nettle_sha1_compress_c;\n      _nettle_sha256_compress_vec = _nettle_sha256_compress_c;\n    }\n  if (features.have_neon)\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: enabling neon code.\\n\");\n      _nettle_salsa20_core_vec = _nettle_salsa20_core_neon;\n      _nettle_sha512_compress_vec = _nettle_sha512_compress_neon;\n      nettle_sha3_permute_vec = _nettle_sha3_permute_neon;\n      _nettle_umac_nh_vec = _nettle_umac_nh_neon;\n      _nettle_umac_nh_n_vec = _nettle_umac_nh_n_neon;\n    }\n  else\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: not enabling neon code.\\n\");\n      _nettle_salsa20_core_vec = _nettle_salsa20_core_c;\n      _nettle_sha512_compress_vec = _nettle_sha512_compress_c;\n      nettle_sha3_permute_vec = _nettle_sha3_permute_c;\n      _nettle_umac_nh_vec = _nettle_umac_nh_c;\n      _nettle_umac_nh_n_vec = _nettle_umac_nh_n_c;\n    }\n}",
      "lines": 53,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/fat-setup.h": {},
  "nettle/nettle-3.4.1/fat-x86_64.c": {
    "get_x86_features": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\nget_x86_features (struct x86_features *features)\n{\n  const char *s;\n  features->vendor = X86_OTHER;\n  features->have_aesni = 0;\n\n  s = secure_getenv (ENV_OVERRIDE);\n  if (s)\n    for (;;)\n      {\n\tconst char *sep = strchr (s, ',');\n\tsize_t length = sep ? (size_t) (sep - s) : strlen(s);\n\n\tif (SKIP (s, length, \"vendor:\", 7))\n\t  {\n\t    if (MATCH(s, length, \"intel\", 5))\n\t      features->vendor = X86_INTEL;\n\t    else if (MATCH(s, length, \"amd\", 3))\n\t      features->vendor = X86_AMD;\n\t    \n\t  }\n\telse if (MATCH (s, length, \"aesni\", 5))\n\t  features->have_aesni = 1;\n\tif (!sep)\n\t  break;\n\ts = sep + 1;\t\n      }\n  else\n    {\n      uint32_t cpuid_data[4];\n      _nettle_cpuid (0, cpuid_data);\n      if (memcmp (cpuid_data + 1, \"Genu\" \"ntel\" \"ineI\", 12) == 0)\n\tfeatures->vendor = X86_INTEL;\n      else if (memcmp (cpuid_data + 1, \"Auth\" \"cAMD\" \"enti\", 12) == 0)\n\tfeatures->vendor = X86_AMD;\n\n      _nettle_cpuid (1, cpuid_data);\n      if (cpuid_data[2] & 0x02000000)\n\tfeatures->have_aesni = 1;      \n    }\n}",
      "lines": 42,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "CONSTRUCTOR": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        168,
        1
      ],
      "content": "static void CONSTRUCTOR\nfat_init (void)\n{\n  struct x86_features features;\n  int verbose;\n\n  /* FIXME: Replace all getenv calls by getenv_secure? */\n  verbose = getenv (ENV_VERBOSE) != NULL;\n  if (verbose)\n    fprintf (stderr, \"libnettle: fat library initialization.\\n\");\n\n  get_x86_features (&features);\n  if (verbose)\n    {\n      const char * const vendor_names[3] =\n\t{ \"other\", \"intel\", \"amd\" };\n      fprintf (stderr, \"libnettle: cpu features: vendor:%s%s\\n\",\n\t       vendor_names[features.vendor],\n\t       features.have_aesni ? \",aesni\" : \"\");\n    }\n  if (features.have_aesni)\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: using aes instructions.\\n\");\n      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_aesni;\n      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_aesni;\n    }\n  else\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: not using aes instructions.\\n\");\n      _nettle_aes_encrypt_vec = _nettle_aes_encrypt_x86_64;\n      _nettle_aes_decrypt_vec = _nettle_aes_decrypt_x86_64;\n    }\n\n  if (features.vendor == X86_INTEL)\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: intel SSE2 will be used for memxor.\\n\");\n      nettle_memxor_vec = _nettle_memxor_sse2;\n    }\n  else\n    {\n      if (verbose)\n\tfprintf (stderr, \"libnettle: intel SSE2 will not be used for memxor.\\n\");\n      nettle_memxor_vec = _nettle_memxor_x86_64;\n    }\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes.c": {
    "gcm_aes_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ngcm_aes_set_key(struct gcm_aes_ctx *ctx, size_t length, const uint8_t *key)\n{\n  aes_set_encrypt_key (&ctx->cipher, length, key);\n  gcm_set_key (&ctx->key, &ctx->cipher,\n\t       (nettle_cipher_func *) aes_encrypt);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes_set_iv": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngcm_aes_set_iv(struct gcm_aes_ctx *ctx,\n\t       size_t length, const uint8_t *iv)\n{\n  GCM_SET_IV(ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes_update": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\ngcm_aes_update(struct gcm_aes_ctx *ctx, size_t length, const uint8_t *data)\n{\n  GCM_UPDATE(ctx, length, data);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes_encrypt": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "void\ngcm_aes_encrypt(struct gcm_aes_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, aes_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes_decrypt": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\ngcm_aes_decrypt(struct gcm_aes_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, aes_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes_digest": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        79,
        1
      ],
      "content": "void\ngcm_aes_digest(struct gcm_aes_ctx *ctx,\n\t       size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, aes_encrypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes128-meta.c": {
    "gcm_aes128_set_nonce_wrapper": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ngcm_aes128_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  gcm_aes128_set_iv (ctx, GCM_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes128.c": {
    "gcm_aes128_set_key": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ngcm_aes128_set_key(struct gcm_aes128_ctx *ctx, const uint8_t *key)\n{\n  GCM_SET_KEY(ctx, aes128_set_encrypt_key, aes128_encrypt, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes128_set_iv": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngcm_aes128_set_iv (struct gcm_aes128_ctx *ctx,\n\t\t      size_t length, const uint8_t *iv)\n{\n  GCM_SET_IV (ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes128_update": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\ngcm_aes128_update (struct gcm_aes128_ctx *ctx,\n\t\t   size_t length, const uint8_t *data)\n{\n  GCM_UPDATE (ctx, length, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes128_encrypt": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ngcm_aes128_encrypt(struct gcm_aes128_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, aes128_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes128_decrypt": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ngcm_aes128_decrypt(struct gcm_aes128_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, aes128_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes128_digest": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ngcm_aes128_digest(struct gcm_aes128_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, aes128_encrypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes192-meta.c": {
    "gcm_aes192_set_nonce_wrapper": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ngcm_aes192_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  gcm_aes192_set_iv (ctx, GCM_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes192.c": {
    "gcm_aes192_set_key": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ngcm_aes192_set_key(struct gcm_aes192_ctx *ctx, const uint8_t *key)\n{\n  GCM_SET_KEY(ctx, aes192_set_encrypt_key, aes192_encrypt, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes192_set_iv": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngcm_aes192_set_iv (struct gcm_aes192_ctx *ctx,\n\t\t      size_t length, const uint8_t *iv)\n{\n  GCM_SET_IV (ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes192_update": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\ngcm_aes192_update (struct gcm_aes192_ctx *ctx,\n\t\t   size_t length, const uint8_t *data)\n{\n  GCM_UPDATE (ctx, length, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes192_encrypt": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ngcm_aes192_encrypt(struct gcm_aes192_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, aes192_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes192_decrypt": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ngcm_aes192_decrypt(struct gcm_aes192_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, aes192_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes192_digest": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ngcm_aes192_digest(struct gcm_aes192_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, aes192_encrypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes256-meta.c": {
    "gcm_aes256_set_nonce_wrapper": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ngcm_aes256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  gcm_aes256_set_iv (ctx, GCM_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-aes256.c": {
    "gcm_aes256_set_key": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "void\ngcm_aes256_set_key(struct gcm_aes256_ctx *ctx, const uint8_t *key)\n{\n  GCM_SET_KEY(ctx, aes256_set_encrypt_key, aes256_encrypt, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes256_set_iv": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ngcm_aes256_set_iv (struct gcm_aes256_ctx *ctx,\n\t\t   size_t length, const uint8_t *iv)\n{\n  GCM_SET_IV (ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes256_update": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\ngcm_aes256_update (struct gcm_aes256_ctx *ctx,\n\t\t   size_t length, const uint8_t *data)\n{\n  GCM_UPDATE (ctx, length, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes256_encrypt": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\ngcm_aes256_encrypt(struct gcm_aes256_ctx *ctx,\n\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, aes256_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes256_decrypt": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\ngcm_aes256_decrypt(struct gcm_aes256_ctx *ctx,\n\t\t   size_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, aes256_encrypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_aes256_digest": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\ngcm_aes256_digest(struct gcm_aes256_ctx *ctx,\n\t\t  size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, aes256_encrypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-camellia128-meta.c": {
    "gcm_camellia128_set_nonce_wrapper": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ngcm_camellia128_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  gcm_camellia128_set_iv (ctx, GCM_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-camellia128.c": {
    "gcm_camellia128_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\ngcm_camellia128_set_key(struct gcm_camellia128_ctx *ctx, const uint8_t *key)\n{\n  GCM_SET_KEY(ctx, camellia128_set_encrypt_key, camellia128_crypt, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia128_set_iv": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ngcm_camellia128_set_iv (struct gcm_camellia128_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *iv)\n{\n  GCM_SET_IV (ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia128_update": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\ngcm_camellia128_update (struct gcm_camellia128_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *data)\n{\n  GCM_UPDATE (ctx, length, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia128_encrypt": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\ngcm_camellia128_encrypt(struct gcm_camellia128_ctx *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, camellia128_crypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia128_decrypt": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ngcm_camellia128_decrypt(struct gcm_camellia128_ctx *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, camellia128_crypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia128_digest": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ngcm_camellia128_digest(struct gcm_camellia128_ctx *ctx,\n\t\t       size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, camellia128_crypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-camellia256-meta.c": {
    "gcm_camellia256_set_nonce_wrapper": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ngcm_camellia256_set_nonce_wrapper (void *ctx, const uint8_t *nonce)\n{\n  gcm_camellia256_set_iv (ctx, GCM_IV_SIZE, nonce);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm-camellia256.c": {
    "gcm_camellia256_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\ngcm_camellia256_set_key(struct gcm_camellia256_ctx *ctx, const uint8_t *key)\n{\n  GCM_SET_KEY(ctx, camellia256_set_encrypt_key, camellia256_crypt, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia256_set_iv": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ngcm_camellia256_set_iv (struct gcm_camellia256_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *iv)\n{\n  GCM_SET_IV (ctx, length, iv);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia256_update": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\ngcm_camellia256_update (struct gcm_camellia256_ctx *ctx,\n\t\t\tsize_t length, const uint8_t *data)\n{\n  GCM_UPDATE (ctx, length, data);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia256_encrypt": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\ngcm_camellia256_encrypt(struct gcm_camellia256_ctx *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_ENCRYPT(ctx, camellia256_crypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia256_decrypt": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\ngcm_camellia256_decrypt(struct gcm_camellia256_ctx *ctx,\n\t\t\tsize_t length, uint8_t *dst, const uint8_t *src)\n{\n  GCM_DECRYPT(ctx, camellia256_crypt, length, dst, src);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "gcm_camellia256_digest": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\ngcm_camellia256_digest(struct gcm_camellia256_ctx *ctx,\n\t\t       size_t length, uint8_t *digest)\n{\n  GCM_DIGEST(ctx, camellia256_crypt, length, digest);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm.c": {
    "gcm_gf_add": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ngcm_gf_add (union nettle_block16 *r,\n\t    const union nettle_block16 *x, const union nettle_block16 *y)\n{\n  r->w[0] = x->w[0] ^ y->w[0];\n  r->w[1] = x->w[1] ^ y->w[1];\n#if SIZEOF_LONG == 4\n  r->w[2] = x->w[2] ^ y->w[2];\n  r->w[3] = x->w[3] ^ y->w[3];\n#endif      \n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_gf_shift": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\ngcm_gf_shift (union nettle_block16 *r, const union nettle_block16 *x)\n{\n  long mask;\n\n  /* Shift uses big-endian representation. */\n#if WORDS_BIGENDIAN\n# if SIZEOF_LONG == 4\n  mask = - (x->w[3] & 1);\n  r->w[3] = (x->w[3] >> 1) | ((x->w[2] & 1) << 31);\n  r->w[2] = (x->w[2] >> 1) | ((x->w[1] & 1) << 31);\n  r->w[1] = (x->w[1] >> 1) | ((x->w[0] & 1) << 31);\n  r->w[0] = (x->w[0] >> 1) ^ (mask & (GHASH_POLYNOMIAL << 24)); \n# elif SIZEOF_LONG == 8\n  mask = - (x->w[1] & 1);\n  r->w[1] = (x->w[1] >> 1) | ((x->w[0] & 1) << 63);\n  r->w[0] = (x->w[0] >> 1) ^ (mask & (GHASH_POLYNOMIAL << 56));\n# else\n#  error Unsupported word size. */\n#endif\n#else /* ! WORDS_BIGENDIAN */\n# if SIZEOF_LONG == 4\n#define RSHIFT_WORD(x) \\\n  ((((x) & 0xfefefefeUL) >> 1) \\\n   | (((x) & 0x00010101) << 15))\n  mask = - ((x->w[3] >> 24) & 1);\n  r->w[3] = RSHIFT_WORD(x->w[3]) | ((x->w[2] >> 17) & 0x80);\n  r->w[2] = RSHIFT_WORD(x->w[2]) | ((x->w[1] >> 17) & 0x80);\n  r->w[1] = RSHIFT_WORD(x->w[1]) | ((x->w[0] >> 17) & 0x80);\n  r->w[0] = RSHIFT_WORD(x->w[0]) ^ (mask & GHASH_POLYNOMIAL);\n# elif SIZEOF_LONG == 8\n#define RSHIFT_WORD(x) \\\n  ((((x) & 0xfefefefefefefefeUL) >> 1) \\\n   | (((x) & 0x0001010101010101UL) << 15))\n  mask = - ((x->w[1] >> 56) & 1);\n  r->w[1] = RSHIFT_WORD(x->w[1]) | ((x->w[0] >> 49) & 0x80);\n  r->w[0] = RSHIFT_WORD(x->w[0]) ^ (mask & GHASH_POLYNOMIAL);\n# else\n#  error Unsupported word size. */\n# endif\n# undef RSHIFT_WORD\n#endif /* ! WORDS_BIGENDIAN */\n}",
      "lines": 43,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_gf_mul": [
      {
        "start_point": [
          118,
          0
        ],
        "end_point": [
          141,
          1
        ],
        "content": "static void\ngcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *y)\n{\n  union nettle_block16 V;\n  union nettle_block16 Z;\n  unsigned i;\n\n  memcpy(V.b, x, sizeof(V));\n  memset(Z.b, 0, sizeof(Z));\n\n  for (i = 0; i < GCM_BLOCK_SIZE; i++)\n    {\n      uint8_t b = y->b[i];\n      unsigned j;\n      for (j = 0; j < 8; j++, b <<= 1)\n\t{\n\t  if (b & 0x80)\n\t    gcm_gf_add(&Z, &Z, &V);\n\t  \n\t  gcm_gf_shift(&V, &V);\n\t}\n    }\n  memcpy (x->b, Z.b, sizeof(Z));\n}",
        "lines": 24,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          202,
          0
        ],
        "end_point": [
          220,
          1
        ],
        "content": "static void\ngcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)\n{\n  union nettle_block16 Z;\n  unsigned i;\n\n  memset(Z.b, 0, sizeof(Z));\n\n  for (i = GCM_BLOCK_SIZE; i-- > 0;)\n    {\n      uint8_t b = x->b[i];\n\n      gcm_gf_shift_4(&Z);\n      gcm_gf_add(&Z, &Z, &table[b & 0xf]);\n      gcm_gf_shift_4(&Z);\n      gcm_gf_add(&Z, &Z, &table[b >> 4]);\n    }\n  memcpy (x->b, Z.b, sizeof(Z));\n}",
        "lines": 19,
        "depth": 11,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      },
      {
        "start_point": [
          303,
          0
        ],
        "end_point": [
          318,
          1
        ],
        "content": "static void\ngcm_gf_mul (union nettle_block16 *x, const union nettle_block16 *table)\n{\n  union nettle_block16 Z;\n  unsigned i;\n\n  memcpy(Z.b, table[x->b[GCM_BLOCK_SIZE-1]].b, GCM_BLOCK_SIZE);\n\n  for (i = GCM_BLOCK_SIZE-2; i > 0; i--)\n    {\n      gcm_gf_shift_8(&Z);\n      gcm_gf_add(&Z, &Z, &table[x->b[i]]);\n    }\n  gcm_gf_shift_8(&Z);\n  gcm_gf_add(x, &Z, &table[x->b[0]]);\n}",
        "lines": 16,
        "depth": 12,
        "decorators": [
          "static",
          "static",
          "void"
        ]
      }
    ],
    "gcm_gf_shift_4": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "static void\ngcm_gf_shift_4(union nettle_block16 *x)\n{\n  unsigned long *w = x->w;\n  unsigned long reduce;\n\n  /* Shift uses big-endian representation. */\n#if WORDS_BIGENDIAN\n# if SIZEOF_LONG == 4\n  reduce = shift_table[w[3] & 0xf];\n  w[3] = (w[3] >> 4) | ((w[2] & 0xf) << 28);\n  w[2] = (w[2] >> 4) | ((w[1] & 0xf) << 28);\n  w[1] = (w[1] >> 4) | ((w[0] & 0xf) << 28);\n  w[0] = (w[0] >> 4) ^ (reduce << 16);\n# elif SIZEOF_LONG == 8\n  reduce = shift_table[w[1] & 0xf];\n  w[1] = (w[1] >> 4) | ((w[0] & 0xf) << 60);\n  w[0] = (w[0] >> 4) ^ (reduce << 48);\n# else\n#  error Unsupported word size. */\n#endif\n#else /* ! WORDS_BIGENDIAN */\n# if SIZEOF_LONG == 4\n#define RSHIFT_WORD(x) \\\n  ((((x) & 0xf0f0f0f0UL) >> 4)\t\t\t\\\n   | (((x) & 0x000f0f0f) << 12))\n  reduce = shift_table[(w[3] >> 24) & 0xf];\n  w[3] = RSHIFT_WORD(w[3]) | ((w[2] >> 20) & 0xf0);\n  w[2] = RSHIFT_WORD(w[2]) | ((w[1] >> 20) & 0xf0);\n  w[1] = RSHIFT_WORD(w[1]) | ((w[0] >> 20) & 0xf0);\n  w[0] = RSHIFT_WORD(w[0]) ^ reduce;\n# elif SIZEOF_LONG == 8\n#define RSHIFT_WORD(x) \\\n  ((((x) & 0xf0f0f0f0f0f0f0f0UL) >> 4) \\\n   | (((x) & 0x000f0f0f0f0f0f0fUL) << 12))\n  reduce = shift_table[(w[1] >> 56) & 0xf];\n  w[1] = RSHIFT_WORD(w[1]) | ((w[0] >> 52) & 0xf0);\n  w[0] = RSHIFT_WORD(w[0]) ^ reduce;\n# else\n#  error Unsupported word size. */\n# endif\n# undef RSHIFT_WORD\n#endif /* ! WORDS_BIGENDIAN */\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_gf_shift_8": {
      "start_point": [
        265,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "static void\ngcm_gf_shift_8(union nettle_block16 *x)\n{\n  unsigned long *w = x->w;\n  unsigned long reduce;\n\n  /* Shift uses big-endian representation. */\n#if WORDS_BIGENDIAN\n# if SIZEOF_LONG == 4\n  reduce = shift_table[w[3] & 0xff];\n  w[3] = (w[3] >> 8) | ((w[2] & 0xff) << 24);\n  w[2] = (w[2] >> 8) | ((w[1] & 0xff) << 24);\n  w[1] = (w[1] >> 8) | ((w[0] & 0xff) << 24);\n  w[0] = (w[0] >> 8) ^ (reduce << 16);\n# elif SIZEOF_LONG == 8\n  reduce = shift_table[w[1] & 0xff];\n  w[1] = (w[1] >> 8) | ((w[0] & 0xff) << 56);\n  w[0] = (w[0] >> 8) ^ (reduce << 48);\n# else\n#  error Unsupported word size. */\n#endif\n#else /* ! WORDS_BIGENDIAN */\n# if SIZEOF_LONG == 4\n  reduce = shift_table[(w[3] >> 24) & 0xff];\n  w[3] = (w[3] << 8) | (w[2] >> 24);\n  w[2] = (w[2] << 8) | (w[1] >> 24);\n  w[1] = (w[1] << 8) | (w[0] >> 24);\n  w[0] = (w[0] << 8) ^ reduce;\n# elif SIZEOF_LONG == 8\n  reduce = shift_table[(w[1] >> 56) & 0xff];\n  w[1] = (w[1] << 8) | (w[0] >> 56);\n  w[0] = (w[0] << 8) ^ reduce;\n# else\n#  error Unsupported word size. */\n# endif\n#endif /* ! WORDS_BIGENDIAN */\n}",
      "lines": 37,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_set_key": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        360,
        1
      ],
      "content": "void\ngcm_set_key(struct gcm_key *key,\n\t    const void *cipher, nettle_cipher_func *f)\n{\n  /* Middle element if GCM_TABLE_BITS > 0, otherwise the first\n     element */\n  unsigned i = (1<<GCM_TABLE_BITS)/2;\n\n  /* H */  \n  memset(key->h[0].b, 0, GCM_BLOCK_SIZE);\n  f (cipher, GCM_BLOCK_SIZE, key->h[i].b, key->h[0].b);\n  \n#if GCM_TABLE_BITS\n  /* Algorithm 3 from the gcm paper. First do powers of two, then do\n     the rest by adding. */\n  while (i /= 2)\n    gcm_gf_shift(&key->h[i], &key->h[2*i]);\n  for (i = 2; i < 1<<GCM_TABLE_BITS; i *= 2)\n    {\n      unsigned j;\n      for (j = 1; j < i; j++)\n\tgcm_gf_add(&key->h[i+j], &key->h[i],&key->h[j]);\n    }\n#endif\n}",
      "lines": 25,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "gcm_hash": {
      "start_point": [
        363,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static void\ngcm_hash(const struct gcm_key *key, union nettle_block16 *x,\n\t size_t length, const uint8_t *data)\n{\n  for (; length >= GCM_BLOCK_SIZE;\n       length -= GCM_BLOCK_SIZE, data += GCM_BLOCK_SIZE)\n    {\n      memxor (x->b, data, GCM_BLOCK_SIZE);\n      gcm_gf_mul (x, key->h);\n    }\n  if (length > 0)\n    {\n      memxor (x->b, data, length);\n      gcm_gf_mul (x, key->h);\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_hash_sizes": {
      "start_point": [
        381,
        0
      ],
      "end_point": [
        394,
        1
      ],
      "content": "static void\ngcm_hash_sizes(const struct gcm_key *key, union nettle_block16 *x,\n\t       uint64_t auth_size, uint64_t data_size)\n{\n  uint8_t buffer[GCM_BLOCK_SIZE];\n\n  data_size *= 8;\n  auth_size *= 8;\n\n  WRITE_UINT64 (buffer, auth_size);\n  WRITE_UINT64 (buffer + 8, data_size);\n\n  gcm_hash(key, x, GCM_BLOCK_SIZE, buffer);\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_set_iv": {
      "start_point": [
        397,
        0
      ],
      "end_point": [
        422,
        1
      ],
      "content": "void\ngcm_set_iv(struct gcm_ctx *ctx, const struct gcm_key *key,\n\t   size_t length, const uint8_t *iv)\n{\n  if (length == GCM_IV_SIZE)\n    {\n      memcpy (ctx->iv.b, iv, GCM_BLOCK_SIZE - 4);\n      ctx->iv.b[GCM_BLOCK_SIZE - 4] = 0;\n      ctx->iv.b[GCM_BLOCK_SIZE - 3] = 0;\n      ctx->iv.b[GCM_BLOCK_SIZE - 2] = 0;\n      ctx->iv.b[GCM_BLOCK_SIZE - 1] = 1;\n    }\n  else\n    {\n      memset(ctx->iv.b, 0, GCM_BLOCK_SIZE);\n      gcm_hash(key, &ctx->iv, length, iv);\n      gcm_hash_sizes(key, &ctx->iv, 0, length);\n    }\n\n  memcpy (ctx->ctr.b, ctx->iv.b, GCM_BLOCK_SIZE);\n  INC32 (ctx->ctr);\n\n  /* Reset the rest of the message-dependent state. */\n  memset(ctx->x.b, 0, sizeof(ctx->x));\n  ctx->auth_size = ctx->data_size = 0;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "gcm_update": {
      "start_point": [
        424,
        0
      ],
      "end_point": [
        434,
        1
      ],
      "content": "void\ngcm_update(struct gcm_ctx *ctx, const struct gcm_key *key,\n\t   size_t length, const uint8_t *data)\n{\n  assert(ctx->auth_size % GCM_BLOCK_SIZE == 0);\n  assert(ctx->data_size == 0);\n\n  gcm_hash(key, &ctx->x, length, data);\n\n  ctx->auth_size += length;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gcm_crypt": {
      "start_point": [
        436,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "static void\ngcm_crypt(struct gcm_ctx *ctx, const void *cipher, nettle_cipher_func *f,\n\t  size_t length, uint8_t *dst, const uint8_t *src)\n{\n  uint8_t buffer[GCM_BLOCK_SIZE];\n\n  if (src != dst)\n    {\n      for (; length >= GCM_BLOCK_SIZE;\n           (length -= GCM_BLOCK_SIZE,\n\t    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))\n        {\n          f (cipher, GCM_BLOCK_SIZE, dst, ctx->ctr.b);\n          memxor (dst, src, GCM_BLOCK_SIZE);\n          INC32 (ctx->ctr);\n        }\n    }\n  else\n    {\n      for (; length >= GCM_BLOCK_SIZE;\n           (length -= GCM_BLOCK_SIZE,\n\t    src += GCM_BLOCK_SIZE, dst += GCM_BLOCK_SIZE))\n        {\n          f (cipher, GCM_BLOCK_SIZE, buffer, ctx->ctr.b);\n          memxor3 (dst, src, buffer, GCM_BLOCK_SIZE);\n          INC32 (ctx->ctr);\n        }\n    }\n  if (length > 0)\n    {\n      /* A final partial block */\n      f (cipher, GCM_BLOCK_SIZE, buffer, ctx->ctr.b);\n      memxor3 (dst, src, buffer, length);\n      INC32 (ctx->ctr);\n    }\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_encrypt": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "void\ngcm_encrypt (struct gcm_ctx *ctx, const struct gcm_key *key,\n\t     const void *cipher, nettle_cipher_func *f,\n\t     size_t length, uint8_t *dst, const uint8_t *src)\n{\n  assert(ctx->data_size % GCM_BLOCK_SIZE == 0);\n\n  gcm_crypt(ctx, cipher, f, length, dst, src);\n  gcm_hash(key, &ctx->x, length, dst);\n\n  ctx->data_size += length;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gcm_decrypt": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        497,
        1
      ],
      "content": "void\ngcm_decrypt(struct gcm_ctx *ctx, const struct gcm_key *key,\n\t    const void *cipher, nettle_cipher_func *f,\n\t    size_t length, uint8_t *dst, const uint8_t *src)\n{\n  assert(ctx->data_size % GCM_BLOCK_SIZE == 0);\n\n  gcm_hash(key, &ctx->x, length, src);\n  gcm_crypt(ctx, cipher, f, length, dst, src);\n\n  ctx->data_size += length;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gcm_digest": {
      "start_point": [
        499,
        0
      ],
      "end_point": [
        514,
        1
      ],
      "content": "void\ngcm_digest(struct gcm_ctx *ctx, const struct gcm_key *key,\n\t   const void *cipher, nettle_cipher_func *f,\n\t   size_t length, uint8_t *digest)\n{\n  uint8_t buffer[GCM_BLOCK_SIZE];\n\n  assert (length <= GCM_BLOCK_SIZE);\n\n  gcm_hash_sizes(key, &ctx->x, ctx->auth_size, ctx->data_size);\n\n  f (cipher, GCM_BLOCK_SIZE, buffer, ctx->iv.b);\n  memxor3 (digest, ctx->x.b, buffer, length);\n\n  return;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gcm.h": {},
  "nettle/nettle-3.4.1/gcmdata.c": {
    "reduce": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static unsigned\nreduce(unsigned x)\n{\n  unsigned p = GHASH_POLYNOMIAL << 1;\n  unsigned y = 0;\n  for (; x; x >>= 1, p <<= 1)\n    if (x & 1)\n      y ^= p;\n  return y;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "main": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  unsigned i;\n  printf(\"4-bit table:\\n\");\n  \n  for (i = 0; i<16; i++)\n    {\n      unsigned x;\n      if (i && !(i%8))\n\tprintf(\"\\n\");\n\n      x = reduce(i << 4);\n      printf(\"W(%02x,%02x),\", x >> 8, x & 0xff);\n    }\n  printf(\"\\n\\n\");\n  printf(\"8-bit table:\\n\");\n  for (i = 0; i<256; i++)\n    {\n      unsigned x;\n      if (i && !(i%8))\n\tprintf(\"\\n\");\n\n      x = reduce(i);\n      printf(\"W(%02x,%02x),\", x >> 8, x & 0xff);\n    }\n  printf(\"\\n\");\n  return EXIT_SUCCESS;\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/getopt.c": {
    "exchange": {
      "start_point": [
        189,
        0
      ],
      "end_point": [
        266,
        1
      ],
      "content": "static void\nexchange (char **argv, struct _getopt_data *d)\n{\n  int bottom = d->__first_nonopt;\n  int middle = d->__last_nonopt;\n  int top = d->optind;\n  char *tem;\n\n  /* Exchange the shorter segment with the far end of the longer segment.\n     That puts the shorter segment into the right place.\n     It leaves the longer segment in the right place overall,\n     but it consists of two parts that need to be swapped next.  */\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  /* First make sure the handling of the `__getopt_nonoption_flags'\n     string can work normally.  Our top argument must be in the range\n     of the string.  */\n  if (d->__nonoption_flags_len > 0 && top >= d->__nonoption_flags_max_len)\n    {\n      /* We must extend the array.  The user plays games with us and\n\t presents new arguments.  */\n      char *new_str = malloc (top + 1);\n      if (new_str == NULL)\n\td->__nonoption_flags_len = d->__nonoption_flags_max_len = 0;\n      else\n\t{\n\t  memset (__mempcpy (new_str, __getopt_nonoption_flags,\n\t\t\t     d->__nonoption_flags_max_len),\n\t\t  '\\0', top + 1 - d->__nonoption_flags_max_len);\n\t  d->__nonoption_flags_max_len = top + 1;\n\t  __getopt_nonoption_flags = new_str;\n\t}\n    }\n#endif\n\n  while (top > middle && middle > bottom)\n    {\n      if (top - middle > middle - bottom)\n\t{\n\t  /* Bottom segment is the short one.  */\n\t  int len = middle - bottom;\n\t  int i;\n\n\t  /* Swap it with the top part of the top segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[top - (middle - bottom) + i];\n\t      argv[top - (middle - bottom) + i] = tem;\n\t      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);\n\t    }\n\t  /* Exclude the moved bottom segment from further swapping.  */\n\t  top -= len;\n\t}\n      else\n\t{\n\t  /* Top segment is the short one.  */\n\t  int len = top - middle;\n\t  int i;\n\n\t  /* Swap it with the bottom part of the bottom segment.  */\n\t  for (i = 0; i < len; i++)\n\t    {\n\t      tem = argv[bottom + i];\n\t      argv[bottom + i] = argv[middle + i];\n\t      argv[middle + i] = tem;\n\t      SWAP_FLAGS (bottom + i, middle + i);\n\t    }\n\t  /* Exclude the moved top segment from further swapping.  */\n\t  bottom += len;\n\t}\n    }\n\n  /* Update records for the slots the non-options now occupy.  */\n\n  d->__first_nonopt += (d->optind - d->__last_nonopt);\n  d->__last_nonopt = d->optind;\n}",
      "lines": 78,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_getopt_initialize": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static const char *\n_getopt_initialize (int argc, char *const *argv, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)\n{\n  /* Start processing options with ARGV-element 1 (since ARGV-element 0\n     is the program name); the sequence of previously skipped\n     non-option ARGV-elements is empty.  */\n\n  d->__first_nonopt = d->__last_nonopt = d->optind;\n\n  d->__nextchar = NULL;\n\n  d->__posixly_correct = posixly_correct | !!getenv (\"POSIXLY_CORRECT\");\n\n  /* Determine how to handle the ordering of options and nonoptions.  */\n\n  if (optstring[0] == '-')\n    {\n      d->__ordering = RETURN_IN_ORDER;\n      ++optstring;\n    }\n  else if (optstring[0] == '+')\n    {\n      d->__ordering = REQUIRE_ORDER;\n      ++optstring;\n    }\n  else if (d->__posixly_correct)\n    d->__ordering = REQUIRE_ORDER;\n  else\n    d->__ordering = PERMUTE;\n\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n  if (!d->__posixly_correct\n      && argc == __libc_argc && argv == __libc_argv)\n    {\n      if (d->__nonoption_flags_max_len == 0)\n\t{\n\t  if (__getopt_nonoption_flags == NULL\n\t      || __getopt_nonoption_flags[0] == '\\0')\n\t    d->__nonoption_flags_max_len = -1;\n\t  else\n\t    {\n\t      const char *orig_str = __getopt_nonoption_flags;\n\t      int len = d->__nonoption_flags_max_len = strlen (orig_str);\n\t      if (d->__nonoption_flags_max_len < argc)\n\t\td->__nonoption_flags_max_len = argc;\n\t      __getopt_nonoption_flags =\n\t\t(char *) malloc (d->__nonoption_flags_max_len);\n\t      if (__getopt_nonoption_flags == NULL)\n\t\td->__nonoption_flags_max_len = -1;\n\t      else\n\t\tmemset (__mempcpy (__getopt_nonoption_flags, orig_str, len),\n\t\t\t'\\0', d->__nonoption_flags_max_len - len);\n\t    }\n\t}\n      d->__nonoption_flags_len = d->__nonoption_flags_max_len;\n    }\n  else\n    d->__nonoption_flags_len = 0;\n#endif\n\n  return optstring;\n}",
      "lines": 63,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "char",
        "*\n_getopt_initialize (int argc, char *const *argv, const char *optstring,\n\t\t    struct _getopt_data *d, int posixly_correct)",
        "*"
      ]
    },
    "_getopt_internal_r": {
      "start_point": [
        390,
        0
      ],
      "end_point": [
        1163,
        1
      ],
      "content": "int\n_getopt_internal_r (int argc, char *const *argv, const char *optstring,\n\t\t    const struct option *longopts, int *longind,\n\t\t    int long_only, struct _getopt_data *d, int posixly_correct)\n{\n  int print_errors = d->opterr;\n\n  if (argc < 1)\n    return -1;\n\n  d->optarg = NULL;\n\n  if (d->optind == 0 || !d->__initialized)\n    {\n      if (d->optind == 0)\n\td->optind = 1;\t/* Don't scan ARGV[0], the program name.  */\n      optstring = _getopt_initialize (argc, argv, optstring, d,\n\t\t\t\t      posixly_correct);\n      d->__initialized = 1;\n    }\n  else if (optstring[0] == '-' || optstring[0] == '+')\n    optstring++;\n  if (optstring[0] == ':')\n    print_errors = 0;\n\n  /* Test whether ARGV[optind] points to a non-option argument.\n     Either it does not have option syntax, or there is an environment flag\n     from the shell indicating it is not an option.  The later information\n     is only used when the used in the GNU libc.  */\n#if defined _LIBC && defined USE_NONOPTION_FLAGS\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0' \\\n\t\t      || (d->optind < d->__nonoption_flags_len\t\t      \\\n\t\t\t  && __getopt_nonoption_flags[d->optind] == '1'))\n#else\n# define NONOPTION_P (argv[d->optind][0] != '-' || argv[d->optind][1] == '\\0')\n#endif\n\n  if (d->__nextchar == NULL || *d->__nextchar == '\\0')\n    {\n      /* Advance to the next ARGV-element.  */\n\n      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been\n\t moved back by the user (who may also have changed the arguments).  */\n      if (d->__last_nonopt > d->optind)\n\td->__last_nonopt = d->optind;\n      if (d->__first_nonopt > d->optind)\n\td->__first_nonopt = d->optind;\n\n      if (d->__ordering == PERMUTE)\n\t{\n\t  /* If we have just processed some options following some non-options,\n\t     exchange them so that the options come first.  */\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__last_nonopt != d->optind)\n\t    d->__first_nonopt = d->optind;\n\n\t  /* Skip any additional non-options\n\t     and extend the range of non-options previously skipped.  */\n\n\t  while (d->optind < argc && NONOPTION_P)\n\t    d->optind++;\n\t  d->__last_nonopt = d->optind;\n\t}\n\n      /* The special ARGV-element `--' means premature end of options.\n\t Skip it like a null option,\n\t then exchange with previous non-options as if it were an option,\n\t then skip everything else like a non-option.  */\n\n      if (d->optind != argc && !strcmp (argv[d->optind], \"--\"))\n\t{\n\t  d->optind++;\n\n\t  if (d->__first_nonopt != d->__last_nonopt\n\t      && d->__last_nonopt != d->optind)\n\t    exchange ((char **) argv, d);\n\t  else if (d->__first_nonopt == d->__last_nonopt)\n\t    d->__first_nonopt = d->optind;\n\t  d->__last_nonopt = argc;\n\n\t  d->optind = argc;\n\t}\n\n      /* If we have done all the ARGV-elements, stop the scan\n\t and back over any non-options that we skipped and permuted.  */\n\n      if (d->optind == argc)\n\t{\n\t  /* Set the next-arg-index to point at the non-options\n\t     that we previously skipped, so the caller will digest them.  */\n\t  if (d->__first_nonopt != d->__last_nonopt)\n\t    d->optind = d->__first_nonopt;\n\t  return -1;\n\t}\n\n      /* If we have come to a non-option and did not permute it,\n\t either stop the scan or describe it to the caller and pass it by.  */\n\n      if (NONOPTION_P)\n\t{\n\t  if (d->__ordering == REQUIRE_ORDER)\n\t    return -1;\n\t  d->optarg = argv[d->optind++];\n\t  return 1;\n\t}\n\n      /* We have found another option-ARGV-element.\n\t Skip the initial punctuation.  */\n\n      d->__nextchar = (argv[d->optind] + 1\n\t\t  + (longopts != NULL && argv[d->optind][1] == '-'));\n    }\n\n  /* Decode the current option-ARGV-element.  */\n\n  /* Check whether the ARGV-element is a long option.\n\n     If long_only and the ARGV-element has the form \"-f\", where f is\n     a valid short option, don't consider it an abbreviated form of\n     a long option that starts with f.  Otherwise there would be no\n     way to give the -f short option.\n\n     On the other hand, if there's a long option \"fubar\" and\n     the ARGV-element is \"-fu\", do consider that an abbreviation of\n     the long option, just like \"--fu\", and not \"-f\" with arg \"u\".\n\n     This distinction seems to be the most useful approach.  */\n\n  if (longopts != NULL\n      && (argv[d->optind][1] == '-'\n\t  || (long_only && (argv[d->optind][2]\n\t\t\t    || !strchr (optstring, argv[d->optind][1])))))\n    {\n      char *nameend;\n      unsigned int namelen;\n      const struct option *p;\n      const struct option *pfound = NULL;\n      struct option_list\n      {\n\tconst struct option *p;\n\tstruct option_list *next;\n      } *ambig_list = NULL;\n      int exact = 0;\n      int indfound = -1;\n      int option_index;\n\n      for (nameend = d->__nextchar; *nameend && *nameend != '='; nameend++)\n\t/* Do nothing.  */ ;\n      namelen = nameend - d->__nextchar;\n\n      /* Test all long options for either exact match\n\t or abbreviated matches.  */\n      for (p = longopts, option_index = 0; p->name; p++, option_index++)\n\tif (!strncmp (p->name, d->__nextchar, namelen))\n\t  {\n\t    if (namelen == (unsigned int) strlen (p->name))\n\t      {\n\t\t/* Exact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t\texact = 1;\n\t\tbreak;\n\t      }\n\t    else if (pfound == NULL)\n\t      {\n\t\t/* First nonexact match found.  */\n\t\tpfound = p;\n\t\tindfound = option_index;\n\t      }\n\t    else if (long_only\n\t\t     || pfound->has_arg != p->has_arg\n\t\t     || pfound->flag != p->flag\n\t\t     || pfound->val != p->val)\n\t      {\n\t\t/* Second or later nonexact match found.  */\n\t\tstruct option_list *newp = alloca (sizeof (*newp));\n\t\tnewp->p = p;\n\t\tnewp->next = ambig_list;\n\t\tambig_list = newp;\n\t      }\n\t  }\n\n      if (ambig_list != NULL && !exact)\n\t{\n\t  if (print_errors)\n\t    {\n\t      struct option_list first;\n\t      first.p = pfound;\n\t      first.next = ambig_list;\n\t      ambig_list = &first;\n\n#if defined _LIBC\n\t      char *buf = NULL;\n\t      size_t buflen = 0;\n\n\t      FILE *fp = open_memstream (&buf, &buflen);\n\t      if (fp != NULL)\n\t\t{\n\t\t  fprintf (fp,\n\t\t\t   _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t\t   argv[0], argv[d->optind]);\n\n\t\t  do\n\t\t    {\n\t\t      fprintf (fp, \" '--%s'\", ambig_list->p->name);\n\t\t      ambig_list = ambig_list->next;\n\t\t    }\n\t\t  while (ambig_list != NULL);\n\n\t\t  fputc_unlocked ('\\n', fp);\n\n\t\t  if (__builtin_expect (fclose (fp) != EOF, 1))\n\t\t    {\n\t\t      _IO_flockfile (stderr);\n\n\t\t      int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t      ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t      __fxprintf (NULL, \"%s\", buf);\n\n\t\t      ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t      _IO_funlockfile (stderr);\n\n\t\t      free (buf);\n\t\t    }\n\t\t}\n#else\n\t      fprintf (stderr,\n\t\t       _(\"%s: option '%s' is ambiguous; possibilities:\"),\n\t\t       argv[0], argv[d->optind]);\n\t      do\n\t\t{\n\t\t  fprintf (stderr, \" '--%s'\", ambig_list->p->name);\n\t\t  ambig_list = ambig_list->next;\n\t\t}\n\t      while (ambig_list != NULL);\n\n\t      fputc ('\\n', stderr);\n#endif\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n\n      if (pfound != NULL)\n\t{\n\t  option_index = indfound;\n\t  d->optind++;\n\t  if (*nameend)\n\t    {\n\t      /* Don't test has_arg with >, because some C compilers don't\n\t\t allow it to be used on enums.  */\n\t      if (pfound->has_arg)\n\t\td->optarg = nameend + 1;\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\t\t      int n;\n#endif\n\n\t\t      if (argv[d->optind - 1][1] == '-')\n\t\t\t{\n\t\t\t  /* --option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '--%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], pfound->name);\n#endif\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t\t  n = __asprintf (&buf, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t\t  argv[0], argv[d->optind - 1][0],\n\t\t\t\t\t  pfound->name);\n#else\n\t\t\t  fprintf (stderr, _(\"\\\n%s: option '%c%s' doesn't allow an argument\\n\"),\n\t\t\t\t   argv[0], argv[d->optind - 1][0],\n\t\t\t\t   pfound->name);\n#endif\n\t\t\t}\n\n#if defined _LIBC\n\t\t      if (n >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#endif\n\t\t    }\n\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\n\t\t  d->optopt = pfound->val;\n\t\t  return '?';\n\t\t}\n\t    }\n\t  else if (pfound->has_arg == 1)\n\t    {\n\t      if (d->optind < argc)\n\t\td->optarg = argv[d->optind++];\n\t      else\n\t\t{\n\t\t  if (print_errors)\n\t\t    {\n#if defined _LIBC\n\t\t      char *buf;\n\n\t\t      if (__asprintf (&buf, _(\"\\\n%s: option '--%s' requires an argument\\n\"),\n\t\t\t\t      argv[0], pfound->name) >= 0)\n\t\t\t{\n\t\t\t  _IO_flockfile (stderr);\n\n\t\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t  ((_IO_FILE *) stderr)->_flags2\n\t\t\t    |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t  _IO_funlockfile (stderr);\n\n\t\t\t  free (buf);\n\t\t\t}\n#else\n\t\t      fprintf (stderr,\n\t\t\t       _(\"%s: option '--%s' requires an argument\\n\"),\n\t\t\t       argv[0], pfound->name);\n#endif\n\t\t    }\n\t\t  d->__nextchar += strlen (d->__nextchar);\n\t\t  d->optopt = pfound->val;\n\t\t  return optstring[0] == ':' ? ':' : '?';\n\t\t}\n\t    }\n\t  d->__nextchar += strlen (d->__nextchar);\n\t  if (longind != NULL)\n\t    *longind = option_index;\n\t  if (pfound->flag)\n\t    {\n\t      *(pfound->flag) = pfound->val;\n\t      return 0;\n\t    }\n\t  return pfound->val;\n\t}\n\n      /* Can't find it as a long option.  If this is not getopt_long_only,\n\t or the option starts with '--' or is not a valid short\n\t option, then it's an error.\n\t Otherwise interpret it as a short option.  */\n      if (!long_only || argv[d->optind][1] == '-'\n\t  || strchr (optstring, *d->__nextchar) == NULL)\n\t{\n\t  if (print_errors)\n\t    {\n#if defined _LIBC\n\t      char *buf;\n\t      int n;\n#endif\n\n\t      if (argv[d->optind][1] == '-')\n\t\t{\n\t\t  /* --option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t\t  argv[0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '--%s'\\n\"),\n\t\t\t   argv[0], d->__nextchar);\n#endif\n\t\t}\n\t      else\n\t\t{\n\t\t  /* +option or -option */\n#if defined _LIBC\n\t\t  n = __asprintf (&buf, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t\t  argv[0], argv[d->optind][0], d->__nextchar);\n#else\n\t\t  fprintf (stderr, _(\"%s: unrecognized option '%c%s'\\n\"),\n\t\t\t   argv[0], argv[d->optind][0], d->__nextchar);\n#endif\n\t\t}\n\n#if defined _LIBC\n\t      if (n >= 0)\n\t\t{\n\t\t  _IO_flockfile (stderr);\n\n\t\t  int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t  ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t  __fxprintf (NULL, \"%s\", buf);\n\n\t\t  ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t  _IO_funlockfile (stderr);\n\n\t\t  free (buf);\n\t\t}\n#endif\n\t    }\n\t  d->__nextchar = (char *) \"\";\n\t  d->optind++;\n\t  d->optopt = 0;\n\t  return '?';\n\t}\n    }\n\n  /* Look at and handle the next short option-character.  */\n\n  {\n    char c = *d->__nextchar++;\n    char *temp = strchr (optstring, c);\n\n    /* Increment `optind' when we start to process its last character.  */\n    if (*d->__nextchar == '\\0')\n      ++d->optind;\n\n    if (temp == NULL || c == ':' || c == ';')\n      {\n\tif (print_errors)\n\t  {\n#if defined _LIBC\n\t    char *buf;\n\t    int n;\n#endif\n\n#if defined _LIBC\n\t    n = __asprintf (&buf, _(\"%s: invalid option -- '%c'\\n\"),\n\t\t\t    argv[0], c);\n#else\n\t    fprintf (stderr, _(\"%s: invalid option -- '%c'\\n\"), argv[0], c);\n#endif\n\n#if defined _LIBC\n\t    if (n >= 0)\n\t      {\n\t\t_IO_flockfile (stderr);\n\n\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t_IO_funlockfile (stderr);\n\n\t\tfree (buf);\n\t      }\n#endif\n\t  }\n\td->optopt = c;\n\treturn '?';\n      }\n    /* Convenience. Treat POSIX -W foo same as long option --foo */\n    if (temp[0] == 'W' && temp[1] == ';')\n      {\n\tchar *nameend;\n\tconst struct option *p;\n\tconst struct option *pfound = NULL;\n\tint exact = 0;\n\tint ambig = 0;\n\tint indfound = 0;\n\tint option_index;\n\n\tif (longopts == NULL)\n\t  goto no_longs;\n\n\t/* This is an option that requires an argument.  */\n\tif (*d->__nextchar != '\\0')\n\t  {\n\t    d->optarg = d->__nextchar;\n\t    /* If we end this ARGV-element by taking the rest as an arg,\n\t       we must advance to the next element now.  */\n\t    d->optind++;\n\t  }\n\telse if (d->optind == argc)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf,\n\t\t\t\t_(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\targv[0], c) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr,\n\t\t\t _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t argv[0], c);\n#endif\n\t      }\n\t    d->optopt = c;\n\t    if (optstring[0] == ':')\n\t      c = ':';\n\t    else\n\t      c = '?';\n\t    return c;\n\t  }\n\telse\n\t  /* We already incremented `d->optind' once;\n\t     increment it again when taking next ARGV-elt as argument.  */\n\t  d->optarg = argv[d->optind++];\n\n\t/* optarg is now the argument, see if it's in the\n\t   table of longopts.  */\n\n\tfor (d->__nextchar = nameend = d->optarg; *nameend && *nameend != '=';\n\t     nameend++)\n\t  /* Do nothing.  */ ;\n\n\t/* Test all long options for either exact match\n\t   or abbreviated matches.  */\n\tfor (p = longopts, option_index = 0; p->name; p++, option_index++)\n\t  if (!strncmp (p->name, d->__nextchar, nameend - d->__nextchar))\n\t    {\n\t      if ((unsigned int) (nameend - d->__nextchar) == strlen (p->name))\n\t\t{\n\t\t  /* Exact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t  exact = 1;\n\t\t  break;\n\t\t}\n\t      else if (pfound == NULL)\n\t\t{\n\t\t  /* First nonexact match found.  */\n\t\t  pfound = p;\n\t\t  indfound = option_index;\n\t\t}\n\t      else if (long_only\n\t\t       || pfound->has_arg != p->has_arg\n\t\t       || pfound->flag != p->flag\n\t\t       || pfound->val != p->val)\n\t\t/* Second or later nonexact match found.  */\n\t\tambig = 1;\n\t    }\n\tif (ambig && !exact)\n\t  {\n\t    if (print_errors)\n\t      {\n#if defined _LIBC\n\t\tchar *buf;\n\n\t\tif (__asprintf (&buf, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t\targv[0], d->optarg) >= 0)\n\t\t  {\n\t\t    _IO_flockfile (stderr);\n\n\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t    ((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t    _IO_funlockfile (stderr);\n\n\t\t    free (buf);\n\t\t  }\n#else\n\t\tfprintf (stderr, _(\"%s: option '-W %s' is ambiguous\\n\"),\n\t\t\t argv[0], d->optarg);\n#endif\n\t      }\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    d->optind++;\n\t    return '?';\n\t  }\n\tif (pfound != NULL)\n\t  {\n\t    option_index = indfound;\n\t    if (*nameend)\n\t      {\n\t\t/* Don't test has_arg with >, because some C compilers don't\n\t\t   allow it to be used on enums.  */\n\t\tif (pfound->has_arg)\n\t\t  d->optarg = nameend + 1;\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' doesn't allow an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return '?';\n\t\t  }\n\t      }\n\t    else if (pfound->has_arg == 1)\n\t      {\n\t\tif (d->optind < argc)\n\t\t  d->optarg = argv[d->optind++];\n\t\telse\n\t\t  {\n\t\t    if (print_errors)\n\t\t      {\n#if defined _LIBC\n\t\t\tchar *buf;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t\targv[0], pfound->name) >= 0)\n\t\t\t  {\n\t\t\t    _IO_flockfile (stderr);\n\n\t\t\t    int old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t    ((_IO_FILE *) stderr)->_flags2\n\t\t\t      |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\n\t\t\t    ((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t    _IO_funlockfile (stderr);\n\n\t\t\t    free (buf);\n\t\t\t  }\n#else\n\t\t\tfprintf (stderr, _(\"\\\n%s: option '-W %s' requires an argument\\n\"),\n\t\t\t\t argv[0], pfound->name);\n#endif\n\t\t      }\n\t\t    d->__nextchar += strlen (d->__nextchar);\n\t\t    return optstring[0] == ':' ? ':' : '?';\n\t\t  }\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar += strlen (d->__nextchar);\n\t    if (longind != NULL)\n\t      *longind = option_index;\n\t    if (pfound->flag)\n\t      {\n\t\t*(pfound->flag) = pfound->val;\n\t\treturn 0;\n\t      }\n\t    return pfound->val;\n\t  }\n\n      no_longs:\n\td->__nextchar = NULL;\n\treturn 'W';\t/* Let the application handle it.   */\n      }\n    if (temp[1] == ':')\n      {\n\tif (temp[2] == ':')\n\t  {\n\t    /* This is an option that accepts an argument optionally.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\td->optind++;\n\t      }\n\t    else\n\t      d->optarg = NULL;\n\t    d->__nextchar = NULL;\n\t  }\n\telse\n\t  {\n\t    /* This is an option that requires an argument.  */\n\t    if (*d->__nextchar != '\\0')\n\t      {\n\t\td->optarg = d->__nextchar;\n\t\t/* If we end this ARGV-element by taking the rest as an arg,\n\t\t   we must advance to the next element now.  */\n\t\td->optind++;\n\t      }\n\t    else if (d->optind == argc)\n\t      {\n\t\tif (print_errors)\n\t\t  {\n#if defined _LIBC\n\t\t    char *buf;\n\n\t\t    if (__asprintf (&buf, _(\"\\\n%s: option requires an argument -- '%c'\\n\"),\n\t\t\t\t    argv[0], c) >= 0)\n\t\t      {\n\t\t\t_IO_flockfile (stderr);\n\n\t\t\tint old_flags2 = ((_IO_FILE *) stderr)->_flags2;\n\t\t\t((_IO_FILE *) stderr)->_flags2 |= _IO_FLAGS2_NOTCANCEL;\n\n\t\t\t__fxprintf (NULL, \"%s\", buf);\n\n\t\t\t((_IO_FILE *) stderr)->_flags2 = old_flags2;\n\t\t\t_IO_funlockfile (stderr);\n\n\t\t\tfree (buf);\n\t\t      }\n#else\n\t\t    fprintf (stderr,\n\t\t\t     _(\"%s: option requires an argument -- '%c'\\n\"),\n\t\t\t     argv[0], c);\n#endif\n\t\t  }\n\t\td->optopt = c;\n\t\tif (optstring[0] == ':')\n\t\t  c = ':';\n\t\telse\n\t\t  c = '?';\n\t      }\n\t    else\n\t      /* We already incremented `optind' once;\n\t\t increment it again when taking next ARGV-elt as argument.  */\n\t      d->optarg = argv[d->optind++];\n\t    d->__nextchar = NULL;\n\t  }\n      }\n    return c;\n  }\n}",
      "lines": 774,
      "depth": 25,
      "decorators": [
        "int"
      ]
    },
    "_getopt_internal": {
      "start_point": [
        1165,
        0
      ],
      "end_point": [
        1184,
        1
      ],
      "content": "int\n_getopt_internal (int argc, char *const *argv, const char *optstring,\n\t\t  const struct option *longopts, int *longind, int long_only,\n\t\t  int posixly_correct)\n{\n  int result;\n\n  getopt_data.optind = optind;\n  getopt_data.opterr = opterr;\n\n  result = _getopt_internal_r (argc, argv, optstring, longopts,\n\t\t\t       longind, long_only, &getopt_data,\n\t\t\t       posixly_correct);\n\n  optind = getopt_data.optind;\n  optarg = getopt_data.optarg;\n  optopt = getopt_data.optopt;\n\n  return result;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "getopt": {
      "start_point": [
        1186,
        0
      ],
      "end_point": [
        1193,
        1
      ],
      "content": "int\ngetopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0, 0);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "__posix_getopt": {
      "start_point": [
        1196,
        0
      ],
      "end_point": [
        1203,
        1
      ],
      "content": "int\n__posix_getopt (int argc, char *const *argv, const char *optstring)\n{\n  return _getopt_internal (argc, argv, optstring,\n\t\t\t   (const struct option *) 0,\n\t\t\t   (int *) 0,\n\t\t\t   0, 1);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        1213,
        0
      ],
      "end_point": [
        1274,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n\n      c = getopt (argc, argv, \"abc:d:0123456789\");\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value '%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/getopt.h": {},
  "nettle/nettle-3.4.1/getopt1.c": {
    "getopt_long": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "int\ngetopt_long (int argc, char *const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 0, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_r": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "int\n_getopt_long_r (int argc, char *const *argv, const char *options,\n\t\tconst struct option *long_options, int *opt_index,\n\t\tstruct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     0, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "getopt_long_only": {
      "start_point": [
        81,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\ngetopt_long_only (int argc, char *const *argv, const char *options,\n\t\t  const struct option *long_options, int *opt_index)\n{\n  return _getopt_internal (argc, argv, options, long_options, opt_index, 1, 0);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "_getopt_long_only_r": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\n_getopt_long_only_r (int argc, char *const *argv, const char *options,\n\t\t     const struct option *long_options, int *opt_index,\n\t\t     struct _getopt_data *d)\n{\n  return _getopt_internal_r (argc, argv, options, long_options, opt_index,\n\t\t\t     1, d, 0);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "main": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        187,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  int c;\n  int digit_optind = 0;\n\n  while (1)\n    {\n      int this_option_optind = optind ? optind : 1;\n      int option_index = 0;\n      static struct option long_options[] =\n      {\n\t{\"add\", 1, 0, 0},\n\t{\"append\", 0, 0, 0},\n\t{\"delete\", 1, 0, 0},\n\t{\"verbose\", 0, 0, 0},\n\t{\"create\", 0, 0, 0},\n\t{\"file\", 1, 0, 0},\n\t{0, 0, 0, 0}\n      };\n\n      c = getopt_long (argc, argv, \"abc:d:0123456789\",\n\t\t       long_options, &option_index);\n      if (c == -1)\n\tbreak;\n\n      switch (c)\n\t{\n\tcase 0:\n\t  printf (\"option %s\", long_options[option_index].name);\n\t  if (optarg)\n\t    printf (\" with arg %s\", optarg);\n\t  printf (\"\\n\");\n\t  break;\n\n\tcase '0':\n\tcase '1':\n\tcase '2':\n\tcase '3':\n\tcase '4':\n\tcase '5':\n\tcase '6':\n\tcase '7':\n\tcase '8':\n\tcase '9':\n\t  if (digit_optind != 0 && digit_optind != this_option_optind)\n\t    printf (\"digits occur in two different argv-elements.\\n\");\n\t  digit_optind = this_option_optind;\n\t  printf (\"option %c\\n\", c);\n\t  break;\n\n\tcase 'a':\n\t  printf (\"option a\\n\");\n\t  break;\n\n\tcase 'b':\n\t  printf (\"option b\\n\");\n\t  break;\n\n\tcase 'c':\n\t  printf (\"option c with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase 'd':\n\t  printf (\"option d with value `%s'\\n\", optarg);\n\t  break;\n\n\tcase '?':\n\t  break;\n\n\tdefault:\n\t  printf (\"?? getopt returned character code 0%o ??\\n\", c);\n\t}\n    }\n\n  if (optind < argc)\n    {\n      printf (\"non-option ARGV-elements: \");\n      while (optind < argc)\n\tprintf (\"%s \", argv[optind++]);\n      printf (\"\\n\");\n    }\n\n  exit (0);\n}",
      "lines": 85,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/getopt_int.h": {},
  "nettle/nettle-3.4.1/gmp-glue.c": {
    "mpz_limbs_read": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "const mp_limb_t *\nmpz_limbs_read (mpz_srcptr x)\n{\n  return PTR (x);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "const",
        "const",
        "mp_limb_t",
        "*\nmpz_limbs_read (mpz_srcptr x)",
        "*"
      ]
    },
    "mpz_limbs_write": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "mp_limb_t *\nmpz_limbs_write (mpz_ptr x, mp_size_t n)\n{\n  assert (n > 0);\n  return MPZ_NEWALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_limb_t",
        "*\nmpz_limbs_write (mpz_ptr x, mp_size_t n)",
        "*"
      ]
    },
    "mpz_limbs_modify": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "mp_limb_t *\nmpz_limbs_modify (mpz_ptr x, mp_size_t n)\n{\n  assert (n > 0);\n  return MPZ_REALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_limb_t",
        "*\nmpz_limbs_modify (mpz_ptr x, mp_size_t n)",
        "*"
      ]
    },
    "mpz_limbs_finish": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\nmpz_limbs_finish (mpz_ptr x, mp_size_t n)\n{\n  assert (n >= 0);\n  MPN_NORMALIZE (PTR(x), n);\n\n  SIZ (x) = n;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_roinit_n": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "mpz_srcptr\nmpz_roinit_n (mpz_ptr x, const mp_limb_t *xp, mp_size_t xs)\n{\n  mp_size_t xn = ABS (xs);\n  \n  MPN_NORMALIZE (xp, xn);\n\n  x->_mp_size = xs < 0 ? -xn : xn;\n  x->_mp_alloc = 0;\n  x->_mp_d = (mp_limb_t *) xp;\n  return x;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mpz_srcptr"
      ]
    },
    "cnd_swap": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "void\ncnd_swap (mp_limb_t cnd, mp_limb_t *ap, mp_limb_t *bp, mp_size_t n)\n{\n  mp_limb_t mask = - (mp_limb_t) (cnd != 0);\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    {\n      mp_limb_t a, b, t;\n      a = ap[i];\n      b = bp[i];\n      t = (a ^ b) & mask;\n      ap[i] = a ^ t;\n      bp[i] = b ^ t;\n    }\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_limbs_cmp": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "int\nmpz_limbs_cmp (mpz_srcptr a, const mp_limb_t *bp, mp_size_t bn)\n{\n  mp_size_t an = mpz_size (a);\n  assert (mpz_sgn (a) >= 0);\n  assert (bn >= 0);\n\n  if (an < bn)\n    return -1;\n  if (an > bn)\n    return 1;\n  if (an == 0)\n    return 0;\n\n  return mpn_cmp (mpz_limbs_read(a), bp, an);\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_limbs_read_n": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "const mp_limb_t *\nmpz_limbs_read_n (mpz_ptr x, mp_size_t n)\n{\n  mp_size_t xn = mpz_size (x);\n  mp_ptr xp;\n  \n  assert (xn <= n);\n\n  xp = mpz_limbs_modify (x, n);\n\n  if (xn < n)\n    mpn_zero (xp + xn, n - xn);\n\n  return xp;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "mp_limb_t",
        "*\nmpz_limbs_read_n (mpz_ptr x, mp_size_t n)",
        "*"
      ]
    },
    "mpz_limbs_copy": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nmpz_limbs_copy (mp_limb_t *xp, mpz_srcptr x, mp_size_t n)\n{\n  mp_size_t xn = mpz_size (x);\n\n  assert (xn <= n);\n  mpn_copyi (xp, mpz_limbs_read (x), xn);\n  if (xn < n)\n    mpn_zero (xp + xn, n - xn);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_set_n": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "void\nmpz_set_n (mpz_t r, const mp_limb_t *xp, mp_size_t xn)\n{\n  mpn_copyi (mpz_limbs_write (r, xn), xp, xn);\n  mpz_limbs_finish (r, xn);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpn_set_base256": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        217,
        1
      ],
      "content": "void\nmpn_set_base256 (mp_limb_t *rp, mp_size_t rn,\n\t\t const uint8_t *xp, size_t xn)\n{\n  size_t xi;\n  mp_limb_t out;\n  unsigned bits;\n  for (xi = xn, out = bits = 0; xi > 0 && rn > 0; )\n    {\n      mp_limb_t in = xp[--xi];\n      out |= (in << bits) & GMP_NUMB_MASK;\n      bits += 8;\n      if (bits >= GMP_NUMB_BITS)\n\t{\n\t  *rp++ = out;\n\t  rn--;\n\n\t  bits -= GMP_NUMB_BITS;\n\t  out = in >> (8 - bits);\n\t}\n    }\n  if (rn > 0)\n    {\n      *rp++ = out;\n      if (--rn > 0)\n\tmpn_zero (rp, rn);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_set_base256_le": {
      "start_point": [
        219,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\nmpn_set_base256_le (mp_limb_t *rp, mp_size_t rn,\n\t\t    const uint8_t *xp, size_t xn)\n{\n  size_t xi;\n  mp_limb_t out;\n  unsigned bits;\n  for (xi = 0, out = bits = 0; xi < xn && rn > 0; )\n    {\n      mp_limb_t in = xp[xi++];\n      out |= (in << bits) & GMP_NUMB_MASK;\n      bits += 8;\n      if (bits >= GMP_NUMB_BITS)\n\t{\n\t  *rp++ = out;\n\t  rn--;\n\n\t  bits -= GMP_NUMB_BITS;\n\t  out = in >> (8 - bits);\n\t}\n    }\n  if (rn > 0)\n    {\n      *rp++ = out;\n      if (--rn > 0)\n\tmpn_zero (rp, rn);\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_get_base256": {
      "start_point": [
        248,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "void\nmpn_get_base256 (uint8_t *rp, size_t rn,\n\t\t const mp_limb_t *xp, mp_size_t xn)\n{\n  unsigned bits;\n  mp_limb_t in;\n  for (bits = in = 0; xn > 0 && rn > 0; )\n    {\n      if (bits >= 8)\n\t{\n\t  rp[--rn] = in;\n\t  in >>= 8;\n\t  bits -= 8;\n\t}\n      else\n\t{\n\t  uint8_t old = in;\n\t  in = *xp++;\n\t  xn--;\n\t  rp[--rn] = old | (in << bits);\n\t  in >>= (8 - bits);\n\t  bits += GMP_NUMB_BITS - 8;\n\t}\n    }\n  while (rn > 0)\n    {\n      rp[--rn] = in;\n      in >>= 8;\n    }\n}",
      "lines": 30,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpn_get_base256_le": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "void\nmpn_get_base256_le (uint8_t *rp, size_t rn,\n\t\t    const mp_limb_t *xp, mp_size_t xn)\n{\n  unsigned bits;\n  mp_limb_t in;\n  for (bits = in = 0; xn > 0 && rn > 0; )\n    {\n      if (bits >= 8)\n\t{\n\t  *rp++ = in;\n\t  rn--;\n\t  in >>= 8;\n\t  bits -= 8;\n\t}\n      else\n\t{\n\t  uint8_t old = in;\n\t  in = *xp++;\n\t  xn--;\n\t  *rp++ = old | (in << bits);\n\t  rn--;\n\t  in >>= (8 - bits);\n\t  bits += GMP_NUMB_BITS - 8;\n\t}\n    }\n  while (rn > 0)\n    {\n      *rp++ = in;\n      rn--;\n      in >>= 8;\n    }\n}",
      "lines": 33,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "gmp_alloc_limbs": {
      "start_point": [
        313,
        0
      ],
      "end_point": [
        323,
        1
      ],
      "content": "mp_limb_t *\ngmp_alloc_limbs (mp_size_t n)\n{\n\n  void *(*alloc_func)(size_t);\n\n  assert (n > 0);\n\n  mp_get_memory_functions (&alloc_func, NULL, NULL);\n  return (mp_limb_t *) alloc_func ( (size_t) n * sizeof(mp_limb_t));\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "mp_limb_t",
        "*\ngmp_alloc_limbs (mp_size_t n)",
        "*"
      ]
    },
    "gmp_free_limbs": {
      "start_point": [
        325,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "void\ngmp_free_limbs (mp_limb_t *p, mp_size_t n)\n{\n  void (*free_func)(void *, size_t);\n  assert (n > 0);\n  assert (p != 0);\n  mp_get_memory_functions (NULL, NULL, &free_func);\n\n  free_func (p, (size_t) n * sizeof(mp_limb_t));\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gmp_alloc": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "void *\ngmp_alloc(size_t n)\n{\n  void *(*alloc_func)(size_t);\n  assert (n > 0);\n\n  mp_get_memory_functions(&alloc_func, NULL, NULL);\n\n  return alloc_func (n);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void",
        "*\ngmp_alloc(size_t n)",
        "*"
      ]
    },
    "gmp_free": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "void\ngmp_free(void *p, size_t n)\n{\n  void (*free_func)(void *, size_t);\n  assert (n > 0);\n  assert (p != 0);\n  mp_get_memory_functions (NULL, NULL, &free_func);\n\n  free_func (p, (size_t) n);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gmp-glue.h": {},
  "nettle/nettle-3.4.1/gosthash94-meta.c": {},
  "nettle/nettle-3.4.1/gosthash94.c": {
    "gosthash94_init": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        254,
        1
      ],
      "content": "void\ngosthash94_init (struct gosthash94_ctx *ctx)\n{\n    memset (ctx, 0, sizeof (struct gosthash94_ctx));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gost_block_compress": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        485,
        1
      ],
      "content": "static void\ngost_block_compress (struct gosthash94_ctx *ctx, const uint32_t *block)\n{\n    unsigned i;\n    uint32_t key[8], u[8], v[8], w[8], s[8];\n    uint32_t l, r, tmp;\n\n    /* u := hash, v := <256-bit message block> */\n    memcpy (u, ctx->hash, sizeof (u));\n    memcpy (v, block, sizeof (v));\n\n    /* w := u xor v */\n    w[0] = u[0] ^ v[0], w[1] = u[1] ^ v[1];\n    w[2] = u[2] ^ v[2], w[3] = u[3] ^ v[3];\n    w[4] = u[4] ^ v[4], w[5] = u[5] ^ v[5];\n    w[6] = u[6] ^ v[6], w[7] = u[7] ^ v[7];\n\n    /* calculate keys, encrypt hash and store result to the s[] array */\n    for (i = 0;; i += 2)\n      {\n          /* key generation: key_i := P(w) */\n          key[0] =\n              (w[0] & 0x000000ff) | ((w[2] & 0x000000ff) << 8) |\n              ((w[4] & 0x000000ff) << 16) | ((w[6] & 0x000000ff) << 24);\n          key[1] =\n              ((w[0] & 0x0000ff00) >> 8) | (w[2] & 0x0000ff00) |\n              ((w[4] & 0x0000ff00) << 8) | ((w[6] & 0x0000ff00) << 16);\n          key[2] =\n              ((w[0] & 0x00ff0000) >> 16) | ((w[2] & 0x00ff0000) >> 8) |\n              (w[4] & 0x00ff0000) | ((w[6] & 0x00ff0000) << 8);\n          key[3] =\n              ((w[0] & 0xff000000) >> 24) | ((w[2] & 0xff000000) >> 16) |\n              ((w[4] & 0xff000000) >> 8) | (w[6] & 0xff000000);\n          key[4] =\n              (w[1] & 0x000000ff) | ((w[3] & 0x000000ff) << 8) |\n              ((w[5] & 0x000000ff) << 16) | ((w[7] & 0x000000ff) << 24);\n          key[5] =\n              ((w[1] & 0x0000ff00) >> 8) | (w[3] & 0x0000ff00) |\n              ((w[5] & 0x0000ff00) << 8) | ((w[7] & 0x0000ff00) << 16);\n          key[6] =\n              ((w[1] & 0x00ff0000) >> 16) | ((w[3] & 0x00ff0000) >> 8) |\n              (w[5] & 0x00ff0000) | ((w[7] & 0x00ff0000) << 8);\n          key[7] =\n              ((w[1] & 0xff000000) >> 24) | ((w[3] & 0xff000000) >> 16) |\n              ((w[5] & 0xff000000) >> 8) | (w[7] & 0xff000000);\n\n          /* encryption: s_i := E_{key_i} (h_i) */\n          GOST_ENCRYPT (s, i, key, ctx->hash, gosthash94_sbox);\n\n          if (i == 0)\n            {\n                /* w:= A(u) ^ A^2(v) */\n                w[0] = u[2] ^ v[4], w[1] = u[3] ^ v[5];\n                w[2] = u[4] ^ v[6], w[3] = u[5] ^ v[7];\n                w[4] = u[6] ^ (v[0] ^= v[2]);\n                w[5] = u[7] ^ (v[1] ^= v[3]);\n                w[6] = (u[0] ^= u[2]) ^ (v[2] ^= v[4]);\n                w[7] = (u[1] ^= u[3]) ^ (v[3] ^= v[5]);\n            }\n          else if ((i & 2) != 0)\n            {\n                if (i == 6)\n                    break;\n\n                /* w := A^2(u) xor A^4(v) xor C_3; u := A(u) xor C_3 */\n                /* C_3=0xff00ffff000000ffff0000ff00ffff0000ff00ff00ff00ffff00ff00ff00ff00 */\n                u[2] ^= u[4] ^ 0x000000ff;\n                u[3] ^= u[5] ^ 0xff00ffff;\n                u[4] ^= 0xff00ff00;\n                u[5] ^= 0xff00ff00;\n                u[6] ^= 0x00ff00ff;\n                u[7] ^= 0x00ff00ff;\n                u[0] ^= 0x00ffff00;\n                u[1] ^= 0xff0000ff;\n\n                w[0] = u[4] ^ v[0];\n                w[2] = u[6] ^ v[2];\n                w[4] = u[0] ^ (v[4] ^= v[6]);\n                w[6] = u[2] ^ (v[6] ^= v[0]);\n                w[1] = u[5] ^ v[1];\n                w[3] = u[7] ^ v[3];\n                w[5] = u[1] ^ (v[5] ^= v[7]);\n                w[7] = u[3] ^ (v[7] ^= v[1]);\n            }\n          else\n            {\n                /* i==4 here */\n                /* w:= A( A^2(u) xor C_3 ) xor A^6(v) */\n                w[0] = u[6] ^ v[4], w[1] = u[7] ^ v[5];\n                w[2] = u[0] ^ v[6], w[3] = u[1] ^ v[7];\n                w[4] = u[2] ^ (v[0] ^= v[2]);\n                w[5] = u[3] ^ (v[1] ^= v[3]);\n                w[6] = (u[4] ^= u[6]) ^ (v[2] ^= v[4]);\n                w[7] = (u[5] ^= u[7]) ^ (v[3] ^= v[5]);\n            }\n      }\n\n    /* step hash function: x(block, hash) := psi^61(hash xor psi(block xor psi^12(S))) */\n\n    /* 12 rounds of the LFSR and xor in <message block> */\n    u[0] = block[0] ^ s[6];\n    u[1] = block[1] ^ s[7];\n    u[2] =\n        block[2] ^ (s[0] << 16) ^ (s[0] >> 16) ^ (s[0] & 0xffff) ^ (s[1] &\n                                                                    0xffff)\n        ^ (s[1] >> 16) ^ (s[2] << 16) ^ s[6] ^ (s[6] << 16) ^ (s[7] &\n                                                               0xffff0000)\n        ^ (s[7] >> 16);\n    u[3] =\n        block[3] ^ (s[0] & 0xffff) ^ (s[0] << 16) ^ (s[1] & 0xffff) ^ (s[1]\n                                                                       <<\n                                                                       16)\n        ^ (s[1] >> 16) ^ (s[2] << 16) ^ (s[2] >> 16) ^ (s[3] << 16) ^ s[6]\n        ^ (s[6] << 16) ^ (s[6] >> 16) ^ (s[7] & 0xffff) ^ (s[7] << 16) ^\n        (s[7] >> 16);\n    u[4] =\n        block[4] ^ (s[0] & 0xffff0000) ^ (s[0] << 16) ^ (s[0] >> 16) ^\n        (s[1] & 0xffff0000) ^ (s[1] >> 16) ^ (s[2] << 16) ^ (s[2] >> 16) ^\n        (s[3] << 16) ^ (s[3] >> 16) ^ (s[4] << 16) ^ (s[6] << 16) ^ (s[6]\n                                                                     >> 16)\n        ^ (s[7] & 0xffff) ^ (s[7] << 16) ^ (s[7] >> 16);\n    u[5] =\n        block[5] ^ (s[0] << 16) ^ (s[0] >> 16) ^ (s[0] & 0xffff0000) ^\n        (s[1] & 0xffff) ^ s[2] ^ (s[2] >> 16) ^ (s[3] << 16) ^ (s[3] >> 16)\n        ^ (s[4] << 16) ^ (s[4] >> 16) ^ (s[5] << 16) ^ (s[6] << 16) ^ (s[6]\n                                                                       >>\n                                                                       16)\n        ^ (s[7] & 0xffff0000) ^ (s[7] << 16) ^ (s[7] >> 16);\n    u[6] =\n        block[6] ^ s[0] ^ (s[1] >> 16) ^ (s[2] << 16) ^ s[3] ^ (s[3] >> 16)\n        ^ (s[4] << 16) ^ (s[4] >> 16) ^ (s[5] << 16) ^ (s[5] >> 16) ^ s[6]\n        ^ (s[6] << 16) ^ (s[6] >> 16) ^ (s[7] << 16);\n    u[7] =\n        block[7] ^ (s[0] & 0xffff0000) ^ (s[0] << 16) ^ (s[1] & 0xffff) ^\n        (s[1] << 16) ^ (s[2] >> 16) ^ (s[3] << 16) ^ s[4] ^ (s[4] >> 16) ^\n        (s[5] << 16) ^ (s[5] >> 16) ^ (s[6] >> 16) ^ (s[7] & 0xffff) ^\n        (s[7] << 16) ^ (s[7] >> 16);\n\n    /* 1 round of the LFSR (a mixing transformation) and xor with <hash> */\n    v[0] = ctx->hash[0] ^ (u[1] << 16) ^ (u[0] >> 16);\n    v[1] = ctx->hash[1] ^ (u[2] << 16) ^ (u[1] >> 16);\n    v[2] = ctx->hash[2] ^ (u[3] << 16) ^ (u[2] >> 16);\n    v[3] = ctx->hash[3] ^ (u[4] << 16) ^ (u[3] >> 16);\n    v[4] = ctx->hash[4] ^ (u[5] << 16) ^ (u[4] >> 16);\n    v[5] = ctx->hash[5] ^ (u[6] << 16) ^ (u[5] >> 16);\n    v[6] = ctx->hash[6] ^ (u[7] << 16) ^ (u[6] >> 16);\n    v[7] =\n        ctx->\n        hash[7] ^ (u[0] & 0xffff0000) ^ (u[0] << 16) ^ (u[1] & 0xffff0000)\n        ^ (u[1] << 16) ^ (u[6] << 16) ^ (u[7] & 0xffff0000) ^ (u[7] >> 16);\n\n    /* 61 rounds of LFSR, mixing up hash */\n    ctx->hash[0] = (v[0] & 0xffff0000) ^ (v[0] << 16) ^ (v[0] >> 16) ^\n        (v[1] >> 16) ^ (v[1] & 0xffff0000) ^ (v[2] << 16) ^\n        (v[3] >> 16) ^ (v[4] << 16) ^ (v[5] >> 16) ^ v[5] ^\n        (v[6] >> 16) ^ (v[7] << 16) ^ (v[7] >> 16) ^ (v[7] & 0xffff);\n    ctx->hash[1] = (v[0] << 16) ^ (v[0] >> 16) ^ (v[0] & 0xffff0000) ^\n        (v[1] & 0xffff) ^ v[2] ^ (v[2] >> 16) ^ (v[3] << 16) ^\n        (v[4] >> 16) ^ (v[5] << 16) ^ (v[6] << 16) ^ v[6] ^\n        (v[7] & 0xffff0000) ^ (v[7] >> 16);\n    ctx->hash[2] = (v[0] & 0xffff) ^ (v[0] << 16) ^ (v[1] << 16) ^\n        (v[1] >> 16) ^ (v[1] & 0xffff0000) ^ (v[2] << 16) ^ (v[3] >> 16) ^\n        v[3] ^ (v[4] << 16) ^ (v[5] >> 16) ^ v[6] ^ (v[6] >> 16) ^\n        (v[7] & 0xffff) ^ (v[7] << 16) ^ (v[7] >> 16);\n    ctx->hash[3] = (v[0] << 16) ^ (v[0] >> 16) ^ (v[0] & 0xffff0000) ^\n        (v[1] & 0xffff0000) ^ (v[1] >> 16) ^ (v[2] << 16) ^\n        (v[2] >> 16) ^ v[2] ^ (v[3] << 16) ^ (v[4] >> 16) ^ v[4] ^\n        (v[5] << 16) ^ (v[6] << 16) ^ (v[7] & 0xffff) ^ (v[7] >> 16);\n    ctx->hash[4] =\n        (v[0] >> 16) ^ (v[1] << 16) ^ v[1] ^ (v[2] >> 16) ^ v[2] ^ (v[3] <<\n                                                                    16) ^\n        (v[3] >> 16) ^ v[3] ^ (v[4] << 16) ^ (v[5] >> 16) ^ v[5] ^ (v[6] <<\n                                                                    16) ^\n        (v[6] >> 16) ^ (v[7] << 16);\n    ctx->hash[5] =\n        (v[0] << 16) ^ (v[0] & 0xffff0000) ^ (v[1] << 16) ^ (v[1] >> 16) ^\n        (v[1] & 0xffff0000) ^ (v[2] << 16) ^ v[2] ^ (v[3] >> 16) ^ v[3] ^\n        (v[4] << 16) ^ (v[4] >> 16) ^ v[4] ^ (v[5] << 16) ^ (v[6] << 16) ^\n        (v[6] >> 16) ^ v[6] ^ (v[7] << 16) ^ (v[7] >> 16) ^ (v[7] &\n                                                             0xffff0000);\n    ctx->hash[6] =\n        v[0] ^ v[2] ^ (v[2] >> 16) ^ v[3] ^ (v[3] << 16) ^ v[4] ^ (v[4] >>\n                                                                   16) ^\n        (v[5] << 16) ^ (v[5] >> 16) ^ v[5] ^ (v[6] << 16) ^ (v[6] >> 16) ^\n        v[6] ^ (v[7] << 16) ^ v[7];\n    ctx->hash[7] =\n        v[0] ^ (v[0] >> 16) ^ (v[1] << 16) ^ (v[1] >> 16) ^ (v[2] << 16) ^\n        (v[3] >> 16) ^ v[3] ^ (v[4] << 16) ^ v[4] ^ (v[5] >> 16) ^ v[5] ^\n        (v[6] << 16) ^ (v[6] >> 16) ^ (v[7] << 16) ^ v[7];\n}",
      "lines": 190,
      "depth": 26,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gost_compute_sum_and_hash": {
      "start_point": [
        497,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static void\ngost_compute_sum_and_hash (struct gosthash94_ctx *ctx, const uint8_t *block)\n{\n    uint32_t block_le[8];\n    unsigned i, carry;\n\n    /* compute the 256-bit sum */\n    for (i = carry = 0; i < 8; i++, block += 4)\n      {\n\t  block_le[i] = LE_READ_UINT32(block);\n          ctx->sum[i] += carry;\n\t  carry = (ctx->sum[i] < carry);\n          ctx->sum[i] += block_le[i];\n          carry += (ctx->sum[i] < block_le[i]);\n      }\n\n    /* update message hash */\n    gost_block_compress (ctx, block_le);\n}",
      "lines": 19,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gosthash94_update": {
      "start_point": [
        525,
        0
      ],
      "end_point": [
        556,
        1
      ],
      "content": "void\ngosthash94_update (struct gosthash94_ctx *ctx,\n\t\t   size_t length, const uint8_t *msg)\n{\n    unsigned index = (unsigned) ctx->length & 31;\n    ctx->length += length;\n\n    /* fill partial block */\n    if (index)\n      {\n          unsigned left = GOSTHASH94_BLOCK_SIZE - index;\n          memcpy (ctx->message + index, msg, (length < left ? length : left));\n          if (length < left)\n              return;\n\n          /* process partial block */\n          gost_compute_sum_and_hash (ctx, ctx->message);\n          msg += left;\n          length -= left;\n      }\n    while (length >= GOSTHASH94_BLOCK_SIZE)\n      {\n          gost_compute_sum_and_hash (ctx, msg);\n          msg += GOSTHASH94_BLOCK_SIZE;\n          length -= GOSTHASH94_BLOCK_SIZE;\n      }\n    if (length)\n      {\n          /* save leftovers */\n          memcpy (ctx->message, msg, length);\n      }\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gosthash94_digest": {
      "start_point": [
        564,
        0
      ],
      "end_point": [
        591,
        1
      ],
      "content": "void\ngosthash94_digest (struct gosthash94_ctx *ctx,\n\t\t   size_t length, uint8_t *result)\n{\n    unsigned index = ctx->length & 31;\n    uint32_t msg32[8];\n\n    assert(length <= GOSTHASH94_DIGEST_SIZE);\n\n    /* pad the last block with zeroes and hash it */\n    if (index > 0)\n      {\n          memset (ctx->message + index, 0, 32 - index);\n          gost_compute_sum_and_hash (ctx, ctx->message);\n      }\n\n    /* hash the message length and the sum */\n    msg32[0] = ctx->length << 3;\n    msg32[1] = ctx->length >> 29;\n    memset (msg32 + 2, 0, sizeof (uint32_t) * 6);\n\n    gost_block_compress (ctx, msg32);\n    gost_block_compress (ctx, ctx->sum);\n\n    /* convert hash state to result bytes */\n    _nettle_write_le32(length, result, ctx->hash);\n    gosthash94_init (ctx);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/gosthash94.h": {},
  "nettle/nettle-3.4.1/hkdf.c": {
    "hkdf_extract": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\nhkdf_extract(void *mac_ctx,\n\t     nettle_hash_update_func *update,\n\t     nettle_hash_digest_func *digest,\n\t     size_t digest_size,\n\t     size_t secret_size, const uint8_t *secret,\n\t     uint8_t *dst)\n{\n  update(mac_ctx, secret_size, secret);\n  digest(mac_ctx, digest_size, dst);\n}",
      "lines": 11,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "hkdf_expand": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\nhkdf_expand(void *mac_ctx,\n\t    nettle_hash_update_func *update,\n\t    nettle_hash_digest_func *digest,\n\t    size_t digest_size,\n\t    size_t info_size, const uint8_t *info,\n\t    size_t length, uint8_t *dst)\n{\n  uint8_t i = 1;\n\n  if (!length)\n    return;\n\n  for (;; dst += digest_size, length -= digest_size, i++)\n    {\n      update(mac_ctx, info_size, info);\n      update(mac_ctx, 1, &i);\n      if (length <= digest_size)\n\tbreak;\n\n      digest(mac_ctx, digest_size, dst);\n      update(mac_ctx, digest_size, dst);\n    }\n\n  digest(mac_ctx, length, dst);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hkdf.h": {},
  "nettle/nettle-3.4.1/hmac-md5.c": {
    "hmac_md5_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_md5_set_key(struct hmac_md5_ctx *ctx,\n\t\t size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_md5, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_md5_update": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_md5_update(struct hmac_md5_ctx *ctx,\n\t\tsize_t length, const uint8_t *data)\n{\n  md5_update(&ctx->state, length, data);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hmac_md5_digest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nhmac_md5_digest(struct hmac_md5_ctx *ctx,\n\t\tsize_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_md5, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-ripemd160.c": {
    "hmac_ripemd160_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_ripemd160_set_key(struct hmac_ripemd160_ctx *ctx,\n\t\t       size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_ripemd160, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_ripemd160_update": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_ripemd160_update(struct hmac_ripemd160_ctx *ctx,\n\t\t      size_t length, const uint8_t *data)\n{\n  ripemd160_update(&ctx->state, length, data);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hmac_ripemd160_digest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nhmac_ripemd160_digest(struct hmac_ripemd160_ctx *ctx,\n\t\t      size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_ripemd160, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-sha1.c": {
    "hmac_sha1_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_sha1_set_key(struct hmac_sha1_ctx *ctx,\n\t\t  size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_sha1, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha1_update": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_sha1_update(struct hmac_sha1_ctx *ctx,\n\t\t size_t length, const uint8_t *data)\n{\n  sha1_update(&ctx->state, length, data);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha1_digest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nhmac_sha1_digest(struct hmac_sha1_ctx *ctx,\n\t\t size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_sha1, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-sha224.c": {
    "hmac_sha224_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_sha224_set_key(struct hmac_sha224_ctx *ctx,\n\t\t    size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_sha224, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha224_digest": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_sha224_digest(struct hmac_sha224_ctx *ctx,\n\t\t   size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_sha224, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-sha256.c": {
    "hmac_sha256_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_sha256_set_key(struct hmac_sha256_ctx *ctx,\n\t\t    size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_sha256, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha256_update": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_sha256_update(struct hmac_sha256_ctx *ctx,\n\t\t   size_t length, const uint8_t *data)\n{\n  sha256_update(&ctx->state, length, data);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha256_digest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nhmac_sha256_digest(struct hmac_sha256_ctx *ctx,\n\t\t   size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_sha256, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-sha384.c": {
    "hmac_sha384_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_sha384_set_key(struct hmac_sha512_ctx *ctx,\n\t\t    size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_sha384, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha384_digest": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_sha384_digest(struct hmac_sha512_ctx *ctx,\n\t\t   size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_sha384, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac-sha512.c": {
    "hmac_sha512_set_key": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\nhmac_sha512_set_key(struct hmac_sha512_ctx *ctx,\n\t\t    size_t key_length, const uint8_t *key)\n{\n  HMAC_SET_KEY(ctx, &nettle_sha512, key_length, key);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha512_update": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\nhmac_sha512_update(struct hmac_sha512_ctx *ctx,\n\t\t   size_t length, const uint8_t *data)\n{\n  sha512_update(&ctx->state, length, data);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "hmac_sha512_digest": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "void\nhmac_sha512_digest(struct hmac_sha512_ctx *ctx,\n\t\t   size_t length, uint8_t *digest)\n{\n  HMAC_DIGEST(ctx, &nettle_sha512, length, digest);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac.c": {
    "hmac_set_key": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "void\nhmac_set_key(void *outer, void *inner, void *state,\n\t     const struct nettle_hash *hash,\n\t     size_t key_length, const uint8_t *key)\n{\n  TMP_DECL(pad, uint8_t, NETTLE_MAX_HASH_BLOCK_SIZE);\n  TMP_ALLOC(pad, hash->block_size);\n  \n  hash->init(outer);\n  hash->init(inner);\n\n  if (key_length > hash->block_size)\n    {\n      /* Reduce key to the algorithm's hash size. Use the area pointed\n       * to by state for the temporary state. */\n\n      TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n      TMP_ALLOC(digest, hash->digest_size);\n\n      hash->init(state);\n      hash->update(state, key_length, key);\n      hash->digest(state, hash->digest_size, digest);\n\n      key = digest;\n      key_length = hash->digest_size;\n    }\n\n  assert(key_length <= hash->block_size);\n  \n  memset(pad, OPAD, hash->block_size);\n  memxor(pad, key, key_length);\n\n  hash->update(outer, hash->block_size, pad);\n\n  memset(pad, IPAD, hash->block_size);\n  memxor(pad, key, key_length);\n\n  hash->update(inner, hash->block_size, pad);\n\n  memcpy(state, inner, hash->context_size);\n}",
      "lines": 41,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "hmac_update": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nhmac_update(void *state,\n\t    const struct nettle_hash *hash,\n\t    size_t length, const uint8_t *data)\n{\n  hash->update(state, length, data);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "hmac_digest": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\nhmac_digest(const void *outer, const void *inner, void *state,\n\t    const struct nettle_hash *hash, \t    \n\t    size_t length, uint8_t *dst)\n{\n  TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  TMP_ALLOC(digest, hash->digest_size);\n\n  hash->digest(state, hash->digest_size, digest);\n\n  memcpy(state, outer, hash->context_size);\n\n  hash->update(state, hash->digest_size, digest);\n  hash->digest(state, length, dst);\n\n  memcpy(state, inner, hash->context_size);\n}",
      "lines": 17,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/hmac.h": {},
  "nettle/nettle-3.4.1/keymap.h": {},
  "nettle/nettle-3.4.1/knuth-lfib.c": {
    "knuth_lfib_init": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void\nknuth_lfib_init(struct knuth_lfib_ctx *ctx, uint32_t seed)\n{\n  uint32_t t,j;\n  uint32_t x[2*KK - 1];\n  uint32_t ss = (seed + 2) & (MM-2);\n\n  for (j = 0; j<KK; j++)\n    {\n      x[j] = ss;\n      ss <<= 1;  if (ss >= MM) ss -= (MM-2);\n    }\n  for (;j< 2*KK-1; j++)\n    x[j] = 0;\n\n  x[1]++;\n\n  ss = seed & (MM-1);\n  for (t = TT-1; t; )\n    {\n      for (j = KK-1; j>0; j--)\n        x[j+j] = x[j];\n      for (j = 2*KK-2; j > KK-LL; j-= 2)\n        x[2*KK-1-j] = x[j] & ~1;\n      for (j = 2*KK-2; j>=KK; j--)\n        if (x[j] & 1)\n          {\n            x[j-(KK-LL)] = (x[j - (KK-LL)] - x[j]) & (MM-1);\n            x[j-KK] = (x[j-KK] - x[j]) & (MM-1);\n          }\n      if (ss & 1)\n        {\n          for (j=KK; j>0; j--)\n            x[j] = x[j-1];\n          x[0] = x[KK];\n          if (x[KK] & 1)\n            x[LL] = (x[LL] - x[KK]) & (MM-1);\n        }\n      if (ss)\n        ss >>= 1;\n      else\n        t--;\n    }\n  for (j=0; j<LL; j++)\n    ctx->x[j+KK-LL] = x[j];\n  for (; j<KK; j++)\n    ctx->x[j-LL] = x[j];\n\n  ctx->index = 0;\n}",
      "lines": 50,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "knuth_lfib_get": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "uint32_t\nknuth_lfib_get(struct knuth_lfib_ctx *ctx)\n{\n  uint32_t value;\n  assert(ctx->index < KK);\n  \n  value = ctx->x[ctx->index];\n  ctx->x[ctx->index] -= ctx->x[(ctx->index + KK - LL) % KK];\n  ctx->x[ctx->index] &= (MM-1);\n  \n  ctx->index = (ctx->index + 1) % KK;\n\n  return value;\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "uint32_t"
      ]
    },
    "knuth_lfib_get_array": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nknuth_lfib_get_array(struct knuth_lfib_ctx *ctx,\n\t\t     size_t n, uint32_t *a)\n{\n  unsigned i;\n  \n  for (i = 0; i<n; i++)\n    a[i] = knuth_lfib_get(ctx);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "knuth_lfib_random": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "void\nknuth_lfib_random(struct knuth_lfib_ctx *ctx,\n\t\t  size_t n, uint8_t *dst)\n{\n  /* Use 24 bits from each number, xoring together some of the\n     bits. */\n  \n  for (; n >= 3; n-=3, dst += 3)\n    {\n      uint32_t value = knuth_lfib_get(ctx);\n\n      /* Xor the most significant octet (containing 6 significant bits)\n       * into the lower octet. */\n      value ^= (value >> 24);\n\n      WRITE_UINT24(dst, value);\n    }\n  if (n)\n    {\n      /* We need one or two octets more */\n      uint32_t value = knuth_lfib_get(ctx);\n      switch (n)\n\t{\n\tcase 1:\n\t  *dst++ = value & 0xff;\n\t  break;\n\tcase 2:\n\t  WRITE_UINT16(dst, value);\n\t  break;\n\tdefault:\n\t  abort();\n\t}\n    }\n}",
      "lines": 34,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/knuth-lfib.h": {},
  "nettle/nettle-3.4.1/macros.h": {},
  "nettle/nettle-3.4.1/md2-meta.c": {},
  "nettle/nettle-3.4.1/md2.c": {
    "md2_transform": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        106,
        1
      ],
      "content": "static void\nmd2_transform(struct md2_ctx *ctx, const uint8_t *data)\n{\n  unsigned i;\n  uint8_t t;\n  \n  memcpy(ctx->X + 16, data, MD2_BLOCK_SIZE);\n\n  for (i = 0, t = ctx->C[15];\n       i<MD2_BLOCK_SIZE; i++)\n    {\n      ctx->X[2 * MD2_BLOCK_SIZE + i]\n\t= ctx->X[i] ^ ctx->X[MD2_BLOCK_SIZE + i];\n      t = (ctx->C[i] ^= S[data[i]^t]);\n    }\n  for (i = t = 0;\n       i< MD2_BLOCK_SIZE + 2;\n       t = (t + i) & 0xff, i++)\n    {\n      unsigned j;\n      for (j = 0; j < 3 * MD2_BLOCK_SIZE; j++)\n\tt = (ctx->X[j] ^= S[t]);\n    }\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "md2_init": {
      "start_point": [
        108,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\nmd2_init(struct md2_ctx *ctx)\n{\n  memset(ctx, 0, sizeof(*ctx));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "md2_update": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "void\nmd2_update(struct md2_ctx *ctx,\n\t   size_t length,\n\t   const uint8_t *data)\n{\n  MD_UPDATE(ctx, length, data, md2_transform, (void)0);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "md2_digest": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\nmd2_digest(struct md2_ctx *ctx,\n\t   size_t length,\n\t   uint8_t *digest)\n{\n  unsigned left;\n  \n  assert(length <= MD2_DIGEST_SIZE);\n\n  left = MD2_BLOCK_SIZE - ctx->index;\n  memset(ctx->block + ctx->index, left, left);\n  md2_transform(ctx, ctx->block);\n  \n  md2_transform(ctx, ctx->C);\n  memcpy(digest, ctx->X, length);\n  md2_init(ctx);\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/md2.h": {},
  "nettle/nettle-3.4.1/md4-meta.c": {},
  "nettle/nettle-3.4.1/md4.c": {
    "md4_init": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "void\nmd4_init(struct md4_ctx *ctx)\n{\n  /* Same constants as for md5. */\n  const uint32_t iv[_MD4_DIGEST_LENGTH] =\n    {\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    };\n  memcpy(ctx->state, iv, sizeof(ctx->state));\n  \n  ctx->count = 0;\n  ctx->index = 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "md4_update": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nmd4_update(struct md4_ctx *ctx,\n\t   size_t length,\n\t   const uint8_t *data)\n{\n  MD_UPDATE(ctx, length, data, md4_compress, ctx->count++);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "md4_digest": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nmd4_digest(struct md4_ctx *ctx,\n\t   size_t length,\n\t   uint8_t *digest)\n{\n  uint64_t bit_count;\n  uint32_t data[MD4_DATA_LENGTH];\n  unsigned i;\n\n  assert(length <= MD4_DIGEST_SIZE);\n\n  MD_PAD(ctx, 8, md4_compress);\n  for (i = 0; i < MD4_DATA_LENGTH - 2; i++)\n    data[i] = LE_READ_UINT32(ctx->block + 4*i);\n\n  /* There are 512 = 2^9 bits in one block \n   * Little-endian order => Least significant word first */\n  bit_count = (ctx->count << 9) | (ctx->index << 3);\n  data[MD4_DATA_LENGTH-2] = bit_count;\n  data[MD4_DATA_LENGTH-1] = bit_count >> 32;\n  md4_transform(ctx->state, data);\n\n  _nettle_write_le32(length, digest, ctx->state);\n  md4_init(ctx);\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "md4_transform": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        183,
        1
      ],
      "content": "static void\nmd4_transform(uint32_t *digest, const uint32_t *data)\n{\n  uint32_t a, b, c, d;\n  a = digest[0];\n  b = digest[1];\n  c = digest[2];\n  d = digest[3];\n\n  ROUND(F, a, b, c, d, data[ 0], 3);\n  ROUND(F, d, a, b, c, data[ 1], 7);\n  ROUND(F, c, d, a, b, data[ 2], 11);\n  ROUND(F, b, c, d, a, data[ 3], 19);\n  ROUND(F, a, b, c, d, data[ 4], 3);\n  ROUND(F, d, a, b, c, data[ 5], 7);\n  ROUND(F, c, d, a, b, data[ 6], 11);\n  ROUND(F, b, c, d, a, data[ 7], 19);\n  ROUND(F, a, b, c, d, data[ 8], 3);\n  ROUND(F, d, a, b, c, data[ 9], 7);\n  ROUND(F, c, d, a, b, data[10], 11);\n  ROUND(F, b, c, d, a, data[11], 19);\n  ROUND(F, a, b, c, d, data[12], 3);\n  ROUND(F, d, a, b, c, data[13], 7);\n  ROUND(F, c, d, a, b, data[14], 11);\n  ROUND(F, b, c, d, a, data[15], 19);\n\n  ROUND(G, a, b, c, d, data[ 0] + 0x5a827999, 3);\n  ROUND(G, d, a, b, c, data[ 4] + 0x5a827999, 5);\n  ROUND(G, c, d, a, b, data[ 8] + 0x5a827999, 9);\n  ROUND(G, b, c, d, a, data[12] + 0x5a827999, 13);\n  ROUND(G, a, b, c, d, data[ 1] + 0x5a827999, 3);\n  ROUND(G, d, a, b, c, data[ 5] + 0x5a827999, 5);\n  ROUND(G, c, d, a, b, data[ 9] + 0x5a827999, 9);\n  ROUND(G, b, c, d, a, data[13] + 0x5a827999, 13);\n  ROUND(G, a, b, c, d, data[ 2] + 0x5a827999, 3);\n  ROUND(G, d, a, b, c, data[ 6] + 0x5a827999, 5);\n  ROUND(G, c, d, a, b, data[10] + 0x5a827999, 9);\n  ROUND(G, b, c, d, a, data[14] + 0x5a827999, 13);\n  ROUND(G, a, b, c, d, data[ 3] + 0x5a827999, 3);\n  ROUND(G, d, a, b, c, data[ 7] + 0x5a827999, 5);\n  ROUND(G, c, d, a, b, data[11] + 0x5a827999, 9);\n  ROUND(G, b, c, d, a, data[15] + 0x5a827999, 13);\n\n  ROUND(H, a, b, c, d, data[ 0] + 0x6ed9eba1, 3);\n  ROUND(H, d, a, b, c, data[ 8] + 0x6ed9eba1, 9);\n  ROUND(H, c, d, a, b, data[ 4] + 0x6ed9eba1, 11);\n  ROUND(H, b, c, d, a, data[12] + 0x6ed9eba1, 15);\n  ROUND(H, a, b, c, d, data[ 2] + 0x6ed9eba1, 3);\n  ROUND(H, d, a, b, c, data[10] + 0x6ed9eba1, 9);\n  ROUND(H, c, d, a, b, data[ 6] + 0x6ed9eba1, 11);\n  ROUND(H, b, c, d, a, data[14] + 0x6ed9eba1, 15);\n  ROUND(H, a, b, c, d, data[ 1] + 0x6ed9eba1, 3);\n  ROUND(H, d, a, b, c, data[ 9] + 0x6ed9eba1, 9);\n  ROUND(H, c, d, a, b, data[ 5] + 0x6ed9eba1, 11);\n  ROUND(H, b, c, d, a, data[13] + 0x6ed9eba1, 15);\n  ROUND(H, a, b, c, d, data[ 3] + 0x6ed9eba1, 3);\n  ROUND(H, d, a, b, c, data[11] + 0x6ed9eba1, 9);\n  ROUND(H, c, d, a, b, data[ 7] + 0x6ed9eba1, 11);\n  ROUND(H, b, c, d, a, data[15] + 0x6ed9eba1, 15);\n\n  digest[0] += a;\n  digest[1] += b;\n  digest[2] += c;\n  digest[3] += d;\n}",
      "lines": 65,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "md4_compress": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        196,
        1
      ],
      "content": "static void\nmd4_compress(struct md4_ctx *ctx, const uint8_t *block)\n{\n  uint32_t data[MD4_DATA_LENGTH];\n  unsigned i;\n  \n  /* Endian independent conversion */\n  for (i = 0; i<16; i++, block += 4)\n    data[i] = LE_READ_UINT32(block);\n\n  md4_transform(ctx->state, data);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/md4.h": {},
  "nettle/nettle-3.4.1/md5-compat.c": {
    "MD5Init": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\nMD5Init(MD5_CTX *ctx)\n{\n  md5_init(ctx);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MD5Update": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nMD5Update(MD5_CTX *ctx, const unsigned char *data, unsigned int length)\n{\n  md5_update(ctx, length, data);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "MD5Final": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nMD5Final(unsigned char *out, MD5_CTX *ctx)\n{\n  md5_digest(ctx, MD5_DIGEST_SIZE, out);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/md5-compat.h": {},
  "nettle/nettle-3.4.1/md5-compress.c": {
    "_nettle_md5_compress": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        173,
        1
      ],
      "content": "void\n_nettle_md5_compress(uint32_t *digest, const uint8_t *input)\n{\n  uint32_t data[MD5_DATA_LENGTH];\n  uint32_t a, b, c, d;\n  unsigned i;\n\n  for (i = 0; i < MD5_DATA_LENGTH; i++, input += 4)\n    data[i] = LE_READ_UINT32(input);\n\n  a = digest[0];\n  b = digest[1];\n  c = digest[2];\n  d = digest[3];\n\n  DEBUG(-1);\n  ROUND(F1, a, b, c, d, data[ 0] + 0xd76aa478, 7); DEBUG(0);\n  ROUND(F1, d, a, b, c, data[ 1] + 0xe8c7b756, 12); DEBUG(1);\n  ROUND(F1, c, d, a, b, data[ 2] + 0x242070db, 17);\n  ROUND(F1, b, c, d, a, data[ 3] + 0xc1bdceee, 22);\n  ROUND(F1, a, b, c, d, data[ 4] + 0xf57c0faf, 7);\n  ROUND(F1, d, a, b, c, data[ 5] + 0x4787c62a, 12);\n  ROUND(F1, c, d, a, b, data[ 6] + 0xa8304613, 17);\n  ROUND(F1, b, c, d, a, data[ 7] + 0xfd469501, 22);\n  ROUND(F1, a, b, c, d, data[ 8] + 0x698098d8, 7);\n  ROUND(F1, d, a, b, c, data[ 9] + 0x8b44f7af, 12);\n  ROUND(F1, c, d, a, b, data[10] + 0xffff5bb1, 17);\n  ROUND(F1, b, c, d, a, data[11] + 0x895cd7be, 22);\n  ROUND(F1, a, b, c, d, data[12] + 0x6b901122, 7);\n  ROUND(F1, d, a, b, c, data[13] + 0xfd987193, 12);\n  ROUND(F1, c, d, a, b, data[14] + 0xa679438e, 17);\n  ROUND(F1, b, c, d, a, data[15] + 0x49b40821, 22); DEBUG(15);\n\n  ROUND(F2, a, b, c, d, data[ 1] + 0xf61e2562, 5); DEBUG(16);\n  ROUND(F2, d, a, b, c, data[ 6] + 0xc040b340, 9); DEBUG(17);\n  ROUND(F2, c, d, a, b, data[11] + 0x265e5a51, 14);\n  ROUND(F2, b, c, d, a, data[ 0] + 0xe9b6c7aa, 20);\n  ROUND(F2, a, b, c, d, data[ 5] + 0xd62f105d, 5);\n  ROUND(F2, d, a, b, c, data[10] + 0x02441453, 9);\n  ROUND(F2, c, d, a, b, data[15] + 0xd8a1e681, 14);\n  ROUND(F2, b, c, d, a, data[ 4] + 0xe7d3fbc8, 20);\n  ROUND(F2, a, b, c, d, data[ 9] + 0x21e1cde6, 5);\n  ROUND(F2, d, a, b, c, data[14] + 0xc33707d6, 9);\n  ROUND(F2, c, d, a, b, data[ 3] + 0xf4d50d87, 14);\n  ROUND(F2, b, c, d, a, data[ 8] + 0x455a14ed, 20);\n  ROUND(F2, a, b, c, d, data[13] + 0xa9e3e905, 5);\n  ROUND(F2, d, a, b, c, data[ 2] + 0xfcefa3f8, 9);\n  ROUND(F2, c, d, a, b, data[ 7] + 0x676f02d9, 14);\n  ROUND(F2, b, c, d, a, data[12] + 0x8d2a4c8a, 20); DEBUG(31);\n\n  ROUND(F3, a, b, c, d, data[ 5] + 0xfffa3942, 4); DEBUG(32);\n  ROUND(F3, d, a, b, c, data[ 8] + 0x8771f681, 11); DEBUG(33);\n  ROUND(F3, c, d, a, b, data[11] + 0x6d9d6122, 16);\n  ROUND(F3, b, c, d, a, data[14] + 0xfde5380c, 23);\n  ROUND(F3, a, b, c, d, data[ 1] + 0xa4beea44, 4);\n  ROUND(F3, d, a, b, c, data[ 4] + 0x4bdecfa9, 11);\n  ROUND(F3, c, d, a, b, data[ 7] + 0xf6bb4b60, 16);\n  ROUND(F3, b, c, d, a, data[10] + 0xbebfbc70, 23);\n  ROUND(F3, a, b, c, d, data[13] + 0x289b7ec6, 4);\n  ROUND(F3, d, a, b, c, data[ 0] + 0xeaa127fa, 11);\n  ROUND(F3, c, d, a, b, data[ 3] + 0xd4ef3085, 16);\n  ROUND(F3, b, c, d, a, data[ 6] + 0x04881d05, 23);\n  ROUND(F3, a, b, c, d, data[ 9] + 0xd9d4d039, 4);\n  ROUND(F3, d, a, b, c, data[12] + 0xe6db99e5, 11);\n  ROUND(F3, c, d, a, b, data[15] + 0x1fa27cf8, 16);\n  ROUND(F3, b, c, d, a, data[ 2] + 0xc4ac5665, 23); DEBUG(47);\n\n  ROUND(F4, a, b, c, d, data[ 0] + 0xf4292244, 6); DEBUG(48);\n  ROUND(F4, d, a, b, c, data[ 7] + 0x432aff97, 10); DEBUG(49);\n  ROUND(F4, c, d, a, b, data[14] + 0xab9423a7, 15);\n  ROUND(F4, b, c, d, a, data[ 5] + 0xfc93a039, 21);\n  ROUND(F4, a, b, c, d, data[12] + 0x655b59c3, 6);\n  ROUND(F4, d, a, b, c, data[ 3] + 0x8f0ccc92, 10);\n  ROUND(F4, c, d, a, b, data[10] + 0xffeff47d, 15);\n  ROUND(F4, b, c, d, a, data[ 1] + 0x85845dd1, 21);\n  ROUND(F4, a, b, c, d, data[ 8] + 0x6fa87e4f, 6);\n  ROUND(F4, d, a, b, c, data[15] + 0xfe2ce6e0, 10);\n  ROUND(F4, c, d, a, b, data[ 6] + 0xa3014314, 15);\n  ROUND(F4, b, c, d, a, data[13] + 0x4e0811a1, 21);\n  ROUND(F4, a, b, c, d, data[ 4] + 0xf7537e82, 6);\n  ROUND(F4, d, a, b, c, data[11] + 0xbd3af235, 10);\n  ROUND(F4, c, d, a, b, data[ 2] + 0x2ad7d2bb, 15);\n  ROUND(F4, b, c, d, a, data[ 9] + 0xeb86d391, 21); DEBUG(63);\n\n  digest[0] += a;\n  digest[1] += b;\n  digest[2] += c;\n  digest[3] += d;\n#if MD5_DEBUG\n  fprintf(stderr, \"99: %8x %8x %8x %8x\\n\",\n\t  digest[0], digest[1], digest[2], digest[3]);\n#endif\n  \n}",
      "lines": 94,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/md5-meta.c": {},
  "nettle/nettle-3.4.1/md5.c": {
    "md5_init": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nmd5_init(struct md5_ctx *ctx)\n{\n  const uint32_t iv[_MD5_DIGEST_LENGTH] =\n    {\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    };\n  memcpy(ctx->state, iv, sizeof(ctx->state));\n  ctx->count = 0;\n  ctx->index = 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "md5_update": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nmd5_update(struct md5_ctx *ctx,\n\t   size_t length,\n\t   const uint8_t *data)\n{\n  MD_UPDATE(ctx, length, data, COMPRESS, ctx->count++);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "md5_digest": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\nmd5_digest(struct md5_ctx *ctx,\n\t   size_t length,\n\t   uint8_t *digest)\n{\n  uint64_t bit_count;\n  \n  assert(length <= MD5_DIGEST_SIZE);\n\n  MD_PAD(ctx, 8, COMPRESS);\n\n  /* There are 512 = 2^9 bits in one block */\n  bit_count = (ctx->count << 9) | (ctx->index << 3);\n\n  LE_WRITE_UINT64(ctx->block + (MD5_BLOCK_SIZE - 8), bit_count);\n  _nettle_md5_compress(ctx->state, ctx->block);\n\n  _nettle_write_le32(length, digest, ctx->state);\n  md5_init(ctx);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/md5.h": {},
  "nettle/nettle-3.4.1/memeql-sec.c": {
    "memeql_sec": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "int\nmemeql_sec (const void *a, const void *b, size_t n)\n{\n  volatile const unsigned char *ap = (const unsigned char *) a;\n  volatile const unsigned char *bp = (const unsigned char *) b;\n\n  volatile unsigned char diff;\n  size_t i;\n\n  for (i = diff = 0; i < n; i++)\n    diff |= (ap[i] ^ bp[i]);\n\n  return diff == 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/memops.h": {},
  "nettle/nettle-3.4.1/memxor-internal.h": {},
  "nettle/nettle-3.4.1/memxor.c": {
    "memxor_common_alignment": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nmemxor_common_alignment (word_t *dst, const word_t *src, size_t n)\n{\n  /* FIXME: Require n > 0? */\n  /* FIXME: Unroll four times, like memcmp? Probably not worth the\n     effort. */\n\n  if (n & 1)\n    {\n      n--;\n      dst[n] ^= src[n];\n    }\n  while (n >= 2)\n    {\n      n -= 2;\n      dst[n+1] ^= src[n+1];\n      dst[n] ^= src[n];\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor_different_alignment": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static void\nmemxor_different_alignment (word_t *dst, const unsigned char *src, size_t n)\n{\n  int shl, shr;\n  const word_t *src_word;\n  unsigned offset = ALIGN_OFFSET (src);\n  word_t s0, s1;\n\n  assert (n > 0);\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  src_word = (const word_t *) ((uintptr_t) src & -sizeof(word_t));\n\n  /* Read top offset bytes, in native byte order. */\n  READ_PARTIAL (s0, (unsigned char *) &src_word[n], offset);\n#ifdef WORDS_BIGENDIAN\n  s0 <<= shr; /* FIXME: Eliminate this shift? */\n#endif\n\n  /* Do n-1 regular iterations */\n  if (n & 1)\n    s1 = s0;\n  else\n    {\n      n--;\n      s1 = src_word[n];\n      dst[n] ^= MERGE (s1, shl, s0, shr);\n    }\n\n  assert (n & 1);\n  while (n > 2)\n    {\n      n -= 2;\n      s0 = src_word[n+1];\n      dst[n+1] ^= MERGE(s0, shl, s1, shr);\n      s1 = src_word[n]; /* FIXME: Overread on last iteration */\n      dst[n] ^= MERGE(s1, shl, s0, shr);\n    }\n  assert (n == 1);\n  /* Read low wordsize - offset bytes */\n  READ_PARTIAL (s0, src, sizeof(word_t) - offset);\n#ifndef WORDS_BIGENDIAN\n  s0 <<= shl; /* FIXME: eliminate shift? */\n#endif /* !WORDS_BIGENDIAN */\n\n  dst[0] ^= MERGE(s0, shl, s1, shr);\n}",
      "lines": 48,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void *\nmemxor(void *dst_in, const void *src_in, size_t n)\n{\n  unsigned char *dst = dst_in;\n  const unsigned char *src = src_in;\n\n  if (n >= WORD_T_THRESH)\n    {\n      unsigned i;\n      unsigned offset;\n      size_t nwords;\n      /* There are at least some bytes to compare.  No need to test\n\t for N == 0 in this alignment loop.  */\n      for (i = ALIGN_OFFSET(dst + n); i > 0; i--)\n\t{\n\t  n--;\n\t  dst[n] ^= src[n];\n\t}\n      offset = ALIGN_OFFSET(src + n);\n      nwords = n / sizeof (word_t);\n      n %= sizeof (word_t);\n\n      if (offset)\n\tmemxor_different_alignment ((word_t *) (dst+n), src+n, nwords);\n      else\n\tmemxor_common_alignment ((word_t *) (dst+n),\n\t\t\t\t (const word_t *) (src+n), nwords);\n    }\n  while (n > 0)\n    {\n      n--;\n      dst[n] ^= src[n];\n    }\n\n  return dst;\n}",
      "lines": 36,
      "depth": 12,
      "decorators": [
        "void",
        "*\nmemxor(void *dst_in, const void *src_in, size_t n)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/memxor.h": {},
  "nettle/nettle-3.4.1/memxor3.c": {
    "memxor3_common_alignment": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\nmemxor3_common_alignment (word_t *dst,\n\t\t\t  const word_t *a, const word_t *b, size_t n)\n{\n  /* FIXME: Require n > 0? */\n  if (n & 1)\n    {\n      n--;\n      dst[n] = a[n] ^ b[n];\n    }\n  while (n > 0)\n    {\n      n -= 2;\n      dst[n+1] = a[n+1] ^ b[n+1];\n      dst[n] = a[n] ^ b[n];\n    }\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor3_different_alignment_b": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "static void\nmemxor3_different_alignment_b (word_t *dst,\n\t\t\t       const word_t *a, const unsigned char *b,\n\t\t\t       unsigned offset, size_t n)\n{\n  int shl, shr;\n  const word_t *b_word;\n\n  word_t s0, s1;\n\n  assert (n > 0);\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  b_word = (const word_t *) ((uintptr_t) b & -sizeof(word_t));\n\n  /* Read top offset bytes, in native byte order. */\n  READ_PARTIAL (s0, (unsigned char *) &b_word[n], offset);\n#ifdef WORDS_BIGENDIAN\n  s0 <<= shr;\n#endif\n\n  if (n & 1)\n    s1 = s0;\n  else\n    {\n      n--;\n      s1 = b_word[n];\n      dst[n] = a[n] ^ MERGE (s1, shl, s0, shr);\n    }\n\n  while (n > 2)\n    {\n      n -= 2;\n      s0 = b_word[n+1];\n      dst[n+1] = a[n+1] ^ MERGE(s0, shl, s1, shr);\n      s1 = b_word[n];\n      dst[n] = a[n] ^ MERGE(s1, shl, s0, shr);\n    }\n  assert (n == 1);\n  /* Read low wordsize - offset bytes */\n  READ_PARTIAL (s0, b, sizeof(word_t) - offset);\n#ifndef WORDS_BIGENDIAN\n  s0 <<= shl;\n#endif /* !WORDS_BIGENDIAN */\n\n  dst[0] = a[0] ^ MERGE(s0, shl, s1, shr);\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor3_different_alignment_ab": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "static void\nmemxor3_different_alignment_ab (word_t *dst,\n\t\t\t\tconst unsigned char *a, const unsigned char *b,\n\t\t\t\tunsigned offset, size_t n)\n{\n  int shl, shr;\n  const word_t *a_word;\n  const word_t *b_word;\n\n  word_t s0, s1, t;\n\n  assert (n > 0);\n\n  shl = CHAR_BIT * offset;\n  shr = CHAR_BIT * (sizeof(word_t) - offset);\n\n  a_word = (const word_t *) ((uintptr_t) a & -sizeof(word_t));\n  b_word = (const word_t *) ((uintptr_t) b & -sizeof(word_t));\n\n  /* Read top offset bytes, in native byte order. */\n  READ_PARTIAL (s0, (unsigned char *) &a_word[n], offset);\n  READ_PARTIAL (t,  (unsigned char *) &b_word[n], offset);\n  s0 ^= t;\n#ifdef WORDS_BIGENDIAN\n  s0 <<= shr;\n#endif\n\n  if (n & 1)\n    s1 = s0;\n  else\n    {\n      n--;\n      s1 = a_word[n] ^ b_word[n];\n      dst[n] = MERGE (s1, shl, s0, shr);\n    }\n\n  while (n > 2)\n    {\n      n -= 2;\n      s0 = a_word[n+1] ^ b_word[n+1];\n      dst[n+1] = MERGE(s0, shl, s1, shr);\n      s1 = a_word[n] ^ b_word[n];\n      dst[n] = MERGE(s1, shl, s0, shr);\n    }\n  assert (n == 1);\n  /* Read low wordsize - offset bytes */\n  READ_PARTIAL (s0, a, sizeof(word_t) - offset);\n  READ_PARTIAL (t,  b, sizeof(word_t) - offset);\n  s0 ^= t;\n#ifndef WORDS_BIGENDIAN\n  s0 <<= shl;\n#endif /* !WORDS_BIGENDIAN */\n\n  dst[0] = MERGE(s0, shl, s1, shr);\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor3_different_alignment_all": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        230,
        1
      ],
      "content": "static void\nmemxor3_different_alignment_all (word_t *dst,\n\t\t\t\t const unsigned char *a, const unsigned char *b,\n\t\t\t\t unsigned a_offset, unsigned b_offset,\n\t\t\t\t size_t n)\n{\n  int al, ar, bl, br;\n  const word_t *a_word;\n  const word_t *b_word;\n\n  word_t a0, a1, b0, b1;\n\n  al = CHAR_BIT * a_offset;\n  ar = CHAR_BIT * (sizeof(word_t) - a_offset);\n  bl = CHAR_BIT * b_offset;\n  br = CHAR_BIT * (sizeof(word_t) - b_offset);\n\n  a_word = (const word_t *) ((uintptr_t) a & -sizeof(word_t));\n  b_word = (const word_t *) ((uintptr_t) b & -sizeof(word_t));\n\n  /* Read top offset bytes, in native byte order. */\n  READ_PARTIAL (a0, (unsigned char *) &a_word[n], a_offset);\n  READ_PARTIAL (b0, (unsigned char *) &b_word[n], b_offset);\n#ifdef WORDS_BIGENDIAN\n  a0 <<= ar;\n  b0 <<= br;\n#endif\n\n  if (n & 1)\n    {\n      a1 = a0; b1 = b0;\n    }\n  else\n    {\n      n--;\n      a1 = a_word[n];\n      b1 = b_word[n];\n\n      dst[n] = MERGE (a1, al, a0, ar) ^ MERGE (b1, bl, b0, br);\n    }\n  while (n > 2)\n    {\n      n -= 2;\n      a0 = a_word[n+1]; b0 = b_word[n+1];\n      dst[n+1] = MERGE(a0, al, a1, ar) ^ MERGE(b0, bl, b1, br);\n      a1 = a_word[n]; b1 = b_word[n];\n      dst[n] = MERGE(a1, al, a0, ar) ^ MERGE(b1, bl, b0, br);\n    }\n  assert (n == 1);\n  /* Read low wordsize - offset bytes */\n  READ_PARTIAL (a0, a, sizeof(word_t) - a_offset);\n  READ_PARTIAL (b0, b, sizeof(word_t) - b_offset);\n#ifndef WORDS_BIGENDIAN\n  a0 <<= al;\n  b0 <<= bl;\n#endif /* !WORDS_BIGENDIAN */\n\n  dst[0] = MERGE(a0, al, a1, ar) ^ MERGE(b0, bl, b1, br);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "memxor3": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        291,
        1
      ],
      "content": "void *\nmemxor3(void *dst_in, const void *a_in, const void *b_in, size_t n)\n{\n  unsigned char *dst = dst_in;\n  const unsigned char *a = a_in;\n  const unsigned char *b = b_in;\n\n  if (n >= WORD_T_THRESH)\n    {\n      unsigned i;\n      unsigned a_offset;\n      unsigned b_offset;\n      size_t nwords;\n\n      for (i = ALIGN_OFFSET(dst + n); i > 0; i--)\n\t{\n\t  n--;\n\t  dst[n] = a[n] ^ b[n];\n\t}\n\n      a_offset = ALIGN_OFFSET(a + n);\n      b_offset = ALIGN_OFFSET(b + n);\n\n      nwords = n / sizeof (word_t);\n      n %= sizeof (word_t);\n\n      if (a_offset == b_offset)\n\t{\n\t  if (!a_offset)\n\t    memxor3_common_alignment((word_t *) (dst + n),\n\t\t\t\t     (const word_t *) (a + n),\n\t\t\t\t     (const word_t *) (b + n), nwords);\n\t  else\n\t    memxor3_different_alignment_ab((word_t *) (dst + n),\n\t\t\t\t\t   a + n, b + n, a_offset,\n\t\t\t\t\t   nwords);\n\t}\n      else if (!a_offset)\n\tmemxor3_different_alignment_b((word_t *) (dst + n),\n\t\t\t\t      (const word_t *) (a + n), b + n,\n\t\t\t\t      b_offset, nwords);\n      else if (!b_offset)\n\tmemxor3_different_alignment_b((word_t *) (dst + n),\n\t\t\t\t      (const word_t *) (b + n), a + n,\n\t\t\t\t      a_offset, nwords);\n      else\n\tmemxor3_different_alignment_all((word_t *) (dst + n), a + n, b + n,\n\t\t\t\t\ta_offset, b_offset, nwords);\n\n    }\n  while (n-- > 0)\n    dst[n] = a[n] ^ b[n];\n\n  return dst;\n}",
      "lines": 55,
      "depth": 14,
      "decorators": [
        "void",
        "*\nmemxor3(void *dst_in, const void *a_in, const void *b_in, size_t n)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/mini-gmp.c": {
    "gmp_die": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\ngmp_die (const char *msg)\n{\n  fprintf (stderr, \"%s\\n\", msg);\n  abort();\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gmp_default_alloc": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        269,
        1
      ],
      "content": "static void *\ngmp_default_alloc (size_t size)\n{\n  void *p;\n\n  assert (size > 0);\n\n  p = malloc (size);\n  if (!p)\n    gmp_die(\"gmp_default_alloc: Virtual memory exhausted.\");\n\n  return p;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ngmp_default_alloc (size_t size)",
        "*"
      ]
    },
    "gmp_default_realloc": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        282,
        1
      ],
      "content": "static void *\ngmp_default_realloc (void *old, size_t old_size, size_t new_size)\n{\n  void * p;\n\n  p = realloc (old, new_size);\n\n  if (!p)\n    gmp_die(\"gmp_default_realloc: Virtual memory exhausted.\");\n\n  return p;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\ngmp_default_realloc (void *old, size_t old_size, size_t new_size)",
        "*"
      ]
    },
    "gmp_default_free": {
      "start_point": [
        284,
        0
      ],
      "end_point": [
        288,
        1
      ],
      "content": "static void\ngmp_default_free (void *p, size_t size)\n{\n  free (p);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mp_get_memory_functions": {
      "start_point": [
        294,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\nmp_get_memory_functions (void *(**alloc_func) (size_t),\n\t\t\t void *(**realloc_func) (void *, size_t, size_t),\n\t\t\t void (**free_func) (void *, size_t))\n{\n  if (alloc_func)\n    *alloc_func = gmp_allocate_func;\n\n  if (realloc_func)\n    *realloc_func = gmp_reallocate_func;\n\n  if (free_func)\n    *free_func = gmp_free_func;\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mp_set_memory_functions": {
      "start_point": [
        309,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "void\nmp_set_memory_functions (void *(*alloc_func) (size_t),\n\t\t\t void *(*realloc_func) (void *, size_t, size_t),\n\t\t\t void (*free_func) (void *, size_t))\n{\n  if (!alloc_func)\n    alloc_func = gmp_default_alloc;\n  if (!realloc_func)\n    realloc_func = gmp_default_realloc;\n  if (!free_func)\n    free_func = gmp_default_free;\n\n  gmp_allocate_func = alloc_func;\n  gmp_reallocate_func = realloc_func;\n  gmp_free_func = free_func;\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "gmp_xalloc_limbs": {
      "start_point": [
        329,
        0
      ],
      "end_point": [
        333,
        1
      ],
      "content": "static mp_ptr\ngmp_xalloc_limbs (mp_size_t size)\n{\n  return (mp_ptr) gmp_xalloc (size * sizeof (mp_limb_t));\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "gmp_xrealloc_limbs": {
      "start_point": [
        335,
        0
      ],
      "end_point": [
        340,
        1
      ],
      "content": "static mp_ptr\ngmp_xrealloc_limbs (mp_ptr old, mp_size_t size)\n{\n  assert (size > 0);\n  return (mp_ptr) (*gmp_reallocate_func) (old, 0, size * sizeof (mp_limb_t));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "mpn_copyi": {
      "start_point": [
        345,
        0
      ],
      "end_point": [
        351,
        1
      ],
      "content": "void\nmpn_copyi (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    d[i] = s[i];\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_copyd": {
      "start_point": [
        353,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void\nmpn_copyd (mp_ptr d, mp_srcptr s, mp_size_t n)\n{\n  while (--n >= 0)\n    d[n] = s[n];\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_cmp": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        369,
        1
      ],
      "content": "int\nmpn_cmp (mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  while (--n >= 0)\n    {\n      if (ap[n] != bp[n])\n\treturn ap[n] > bp[n] ? 1 : -1;\n    }\n  return 0;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpn_cmp4": {
      "start_point": [
        371,
        0
      ],
      "end_point": [
        378,
        1
      ],
      "content": "static int\nmpn_cmp4 (mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  if (an != bn)\n    return an < bn ? -1 : 1;\n  else\n    return mpn_cmp (ap, bp, an);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpn_normalized_size": {
      "start_point": [
        380,
        0
      ],
      "end_point": [
        386,
        1
      ],
      "content": "static mp_size_t\nmpn_normalized_size (mp_srcptr xp, mp_size_t n)\n{\n  while (n > 0 && xp[n-1] == 0)\n    --n;\n  return n;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_zero_p": {
      "start_point": [
        388,
        0
      ],
      "end_point": [
        392,
        1
      ],
      "content": "int\nmpn_zero_p(mp_srcptr rp, mp_size_t n)\n{\n  return mpn_normalized_size (rp, n) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpn_zero": {
      "start_point": [
        394,
        0
      ],
      "end_point": [
        399,
        1
      ],
      "content": "void\nmpn_zero (mp_ptr rp, mp_size_t n)\n{\n  while (--n >= 0)\n    rp[n] = 0;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpn_add_1": {
      "start_point": [
        401,
        0
      ],
      "end_point": [
        418,
        1
      ],
      "content": "mp_limb_t\nmpn_add_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n  i = 0;\n  do\n    {\n      mp_limb_t r = ap[i] + b;\n      /* Carry out */\n      b = (r < b);\n      rp[i] = r;\n    }\n  while (++i < n);\n\n  return b;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_add_n": {
      "start_point": [
        420,
        0
      ],
      "end_point": [
        437,
        1
      ],
      "content": "mp_limb_t\nmpn_add_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b, r;\n      a = ap[i]; b = bp[i];\n      r = a + cy;\n      cy = (r < cy);\n      r += b;\n      cy += (r < b);\n      rp[i] = r;\n    }\n  return cy;\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_add": {
      "start_point": [
        439,
        0
      ],
      "end_point": [
        450,
        1
      ],
      "content": "mp_limb_t\nmpn_add (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_add_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_add_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub_1": {
      "start_point": [
        452,
        0
      ],
      "end_point": [
        471,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_1 (mp_ptr rp, mp_srcptr ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n\n  assert (n > 0);\n\n  i = 0;\n  do\n    {\n      mp_limb_t a = ap[i];\n      /* Carry out */\n      mp_limb_t cy = a < b;\n      rp[i] = a - b;\n      b = cy;\n    }\n  while (++i < n);\n\n  return b;\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub_n": {
      "start_point": [
        473,
        0
      ],
      "end_point": [
        489,
        1
      ],
      "content": "mp_limb_t\nmpn_sub_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mp_size_t i;\n  mp_limb_t cy;\n\n  for (i = 0, cy = 0; i < n; i++)\n    {\n      mp_limb_t a, b;\n      a = ap[i]; b = bp[i];\n      b += cy;\n      cy = (b < cy);\n      cy += (a < b);\n      rp[i] = a - b;\n    }\n  return cy;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_sub": {
      "start_point": [
        491,
        0
      ],
      "end_point": [
        502,
        1
      ],
      "content": "mp_limb_t\nmpn_sub (mp_ptr rp, mp_srcptr ap, mp_size_t an, mp_srcptr bp, mp_size_t bn)\n{\n  mp_limb_t cy;\n\n  assert (an >= bn);\n\n  cy = mpn_sub_n (rp, ap, bp, bn);\n  if (an > bn)\n    cy = mpn_sub_1 (rp + bn, ap + bn, an - bn, cy);\n  return cy;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul_1": {
      "start_point": [
        504,
        0
      ],
      "end_point": [
        525,
        1
      ],
      "content": "mp_limb_t\nmpn_mul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_addmul_1": {
      "start_point": [
        527,
        0
      ],
      "end_point": [
        551,
        1
      ],
      "content": "mp_limb_t\nmpn_addmul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl + lpl;\n      cl += lpl < rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_submul_1": {
      "start_point": [
        553,
        0
      ],
      "end_point": [
        577,
        1
      ],
      "content": "mp_limb_t\nmpn_submul_1 (mp_ptr rp, mp_srcptr up, mp_size_t n, mp_limb_t vl)\n{\n  mp_limb_t ul, cl, hpl, lpl, rl;\n\n  assert (n >= 1);\n\n  cl = 0;\n  do\n    {\n      ul = *up++;\n      gmp_umul_ppmm (hpl, lpl, ul, vl);\n\n      lpl += cl;\n      cl = (lpl < cl) + hpl;\n\n      rl = *rp;\n      lpl = rl - lpl;\n      cl += lpl > rl;\n      *rp++ = lpl;\n    }\n  while (--n != 0);\n\n  return cl;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul": {
      "start_point": [
        579,
        0
      ],
      "end_point": [
        602,
        1
      ],
      "content": "mp_limb_t\nmpn_mul (mp_ptr rp, mp_srcptr up, mp_size_t un, mp_srcptr vp, mp_size_t vn)\n{\n  assert (un >= vn);\n  assert (vn >= 1);\n  assert (!GMP_MPN_OVERLAP_P(rp, un + vn, up, un));\n  assert (!GMP_MPN_OVERLAP_P(rp, un + vn, vp, vn));\n\n  /* We first multiply by the low order limb. This result can be\n     stored, not added, to rp. We also avoid a loop for zeroing this\n     way. */\n\n  rp[un] = mpn_mul_1 (rp, up, un, vp[0]);\n\n  /* Now accumulate the product of up[] and the next higher limb from\n     vp[]. */\n\n  while (--vn >= 1)\n    {\n      rp += 1, vp += 1;\n      rp[un] = mpn_addmul_1 (rp, up, un, vp[0]);\n    }\n  return rp[un];\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_mul_n": {
      "start_point": [
        604,
        0
      ],
      "end_point": [
        608,
        1
      ],
      "content": "void\nmpn_mul_n (mp_ptr rp, mp_srcptr ap, mp_srcptr bp, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, bp, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_sqr": {
      "start_point": [
        610,
        0
      ],
      "end_point": [
        614,
        1
      ],
      "content": "void\nmpn_sqr (mp_ptr rp, mp_srcptr ap, mp_size_t n)\n{\n  mpn_mul (rp, ap, n, ap, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpn_lshift": {
      "start_point": [
        616,
        0
      ],
      "end_point": [
        644,
        1
      ],
      "content": "mp_limb_t\nmpn_lshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  up += n;\n  rp += n;\n\n  tnc = GMP_LIMB_BITS - cnt;\n  low_limb = *--up;\n  retval = low_limb >> tnc;\n  high_limb = (low_limb << cnt);\n\n  while (--n != 0)\n    {\n      low_limb = *--up;\n      *--rp = high_limb | (low_limb >> tnc);\n      high_limb = (low_limb << cnt);\n    }\n  *--rp = high_limb;\n\n  return retval;\n}",
      "lines": 29,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_rshift": {
      "start_point": [
        646,
        0
      ],
      "end_point": [
        671,
        1
      ],
      "content": "mp_limb_t\nmpn_rshift (mp_ptr rp, mp_srcptr up, mp_size_t n, unsigned int cnt)\n{\n  mp_limb_t high_limb, low_limb;\n  unsigned int tnc;\n  mp_limb_t retval;\n\n  assert (n >= 1);\n  assert (cnt >= 1);\n  assert (cnt < GMP_LIMB_BITS);\n\n  tnc = GMP_LIMB_BITS - cnt;\n  high_limb = *up++;\n  retval = (high_limb << tnc);\n  low_limb = high_limb >> cnt;\n\n  while (--n != 0)\n    {\n      high_limb = *up++;\n      *rp++ = low_limb | (high_limb << tnc);\n      low_limb = high_limb >> cnt;\n    }\n  *rp = low_limb;\n\n  return retval;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_common_scan": {
      "start_point": [
        673,
        0
      ],
      "end_point": [
        691,
        1
      ],
      "content": "static mp_bitcnt_t\nmpn_common_scan (mp_limb_t limb, mp_size_t i, mp_srcptr up, mp_size_t un,\n\t\t mp_limb_t ux)\n{\n  unsigned cnt;\n\n  assert (ux == 0 || ux == GMP_LIMB_MAX);\n  assert (0 <= i && i <= un );\n\n  while (limb == 0)\n    {\n      i++;\n      if (i == un)\n\treturn (ux == 0 ? ~(mp_bitcnt_t) 0 : un * GMP_LIMB_BITS);\n      limb = ux ^ up[i];\n    }\n  gmp_ctz (cnt, limb);\n  return (mp_bitcnt_t) i * GMP_LIMB_BITS + cnt;\n}",
      "lines": 19,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpn_scan1": {
      "start_point": [
        693,
        0
      ],
      "end_point": [
        701,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan1 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan ( ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, 0);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpn_scan0": {
      "start_point": [
        703,
        0
      ],
      "end_point": [
        711,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_scan0 (mp_srcptr ptr, mp_bitcnt_t bit)\n{\n  mp_size_t i;\n  i = bit / GMP_LIMB_BITS;\n\n  return mpn_common_scan (~ptr[i] & (GMP_LIMB_MAX << (bit % GMP_LIMB_BITS)),\n\t\t\t  i, ptr, i, GMP_LIMB_MAX);\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpn_com": {
      "start_point": [
        713,
        0
      ],
      "end_point": [
        718,
        1
      ],
      "content": "void\nmpn_com (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (--n >= 0)\n    *rp++ = ~ *up++;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpn_neg": {
      "start_point": [
        720,
        0
      ],
      "end_point": [
        733,
        1
      ],
      "content": "mp_limb_t\nmpn_neg (mp_ptr rp, mp_srcptr up, mp_size_t n)\n{\n  while (*up == 0)\n    {\n      *rp = 0;\n      if (!--n)\n\treturn 0;\n      ++up; ++rp;\n    }\n  *rp = - *up;\n  mpn_com (++rp, ++up, --n);\n  return 1;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_invert_3by2": {
      "start_point": [
        742,
        0
      ],
      "end_point": [
        846,
        1
      ],
      "content": "mp_limb_t\nmpn_invert_3by2 (mp_limb_t u1, mp_limb_t u0)\n{\n  mp_limb_t r, p, m, ql;\n  unsigned ul, uh, qh;\n\n  assert (u1 >= GMP_LIMB_HIGHBIT);\n\n  /* For notation, let b denote the half-limb base, so that B = b^2.\n     Split u1 = b uh + ul. */\n  ul = u1 & GMP_LLIMB_MASK;\n  uh = u1 >> (GMP_LIMB_BITS / 2);\n\n  /* Approximation of the high half of quotient. Differs from the 2/1\n     inverse of the half limb uh, since we have already subtracted\n     u0. */\n  qh = ~u1 / uh;\n\n  /* Adjust to get a half-limb 3/2 inverse, i.e., we want\n\n     qh' = floor( (b^3 - 1) / u) - b = floor ((b^3 - b u - 1) / u\n         = floor( (b (~u) + b-1) / u),\n\n     and the remainder\n\n     r = b (~u) + b-1 - qh (b uh + ul)\n       = b (~u - qh uh) + b-1 - qh ul\n\n     Subtraction of qh ul may underflow, which implies adjustments.\n     But by normalization, 2 u >= B > qh ul, so we need to adjust by\n     at most 2.\n  */\n\n  r = ((~u1 - (mp_limb_t) qh * uh) << (GMP_LIMB_BITS / 2)) | GMP_LLIMB_MASK;\n\n  p = (mp_limb_t) qh * ul;\n  /* Adjustment steps taken from udiv_qrnnd_c */\n  if (r < p)\n    {\n      qh--;\n      r += u1;\n      if (r >= u1) /* i.e. we didn't get carry when adding to r */\n\tif (r < p)\n\t  {\n\t    qh--;\n\t    r += u1;\n\t  }\n    }\n  r -= p;\n\n  /* Low half of the quotient is\n\n       ql = floor ( (b r + b-1) / u1).\n\n     This is a 3/2 division (on half-limbs), for which qh is a\n     suitable inverse. */\n\n  p = (r >> (GMP_LIMB_BITS / 2)) * qh + r;\n  /* Unlike full-limb 3/2, we can add 1 without overflow. For this to\n     work, it is essential that ql is a full mp_limb_t. */\n  ql = (p >> (GMP_LIMB_BITS / 2)) + 1;\n\n  /* By the 3/2 trick, we don't need the high half limb. */\n  r = (r << (GMP_LIMB_BITS / 2)) + GMP_LLIMB_MASK - ql * u1;\n\n  if (r >= (p << (GMP_LIMB_BITS / 2)))\n    {\n      ql--;\n      r += u1;\n    }\n  m = ((mp_limb_t) qh << (GMP_LIMB_BITS / 2)) + ql;\n  if (r >= u1)\n    {\n      m++;\n      r -= u1;\n    }\n\n  /* Now m is the 2/1 invers of u1. If u0 > 0, adjust it to become a\n     3/2 inverse. */\n  if (u0 > 0)\n    {\n      mp_limb_t th, tl;\n      r = ~r;\n      r += u0;\n      if (r < u0)\n\t{\n\t  m--;\n\t  if (r >= u1)\n\t    {\n\t      m--;\n\t      r -= u1;\n\t    }\n\t  r -= u1;\n\t}\n      gmp_umul_ppmm (th, tl, u0, m);\n      r += th;\n      if (r < th)\n\t{\n\t  m--;\n\t  m -= ((r > u1) | ((r == u1) & (tl > u0)));\n\t}\n    }\n\n  return m;\n}",
      "lines": 105,
      "depth": 15,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_1_invert": {
      "start_point": [
        858,
        0
      ],
      "end_point": [
        868,
        1
      ],
      "content": "static void\nmpn_div_qr_1_invert (struct gmp_div_inverse *inv, mp_limb_t d)\n{\n  unsigned shift;\n\n  assert (d > 0);\n  gmp_clz (shift, d);\n  inv->shift = shift;\n  inv->d1 = d << shift;\n  inv->di = mpn_invert_limb (inv->d1);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_2_invert": {
      "start_point": [
        870,
        0
      ],
      "end_point": [
        887,
        1
      ],
      "content": "static void\nmpn_div_qr_2_invert (struct gmp_div_inverse *inv,\n\t\t     mp_limb_t d1, mp_limb_t d0)\n{\n  unsigned shift;\n\n  assert (d1 > 0);\n  gmp_clz (shift, d1);\n  inv->shift = shift;\n  if (shift > 0)\n    {\n      d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n      d0 <<= shift;\n    }\n  inv->d1 = d1;\n  inv->d0 = d0;\n  inv->di = mpn_invert_3by2 (d1, d0);\n}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_invert": {
      "start_point": [
        889,
        0
      ],
      "end_point": [
        918,
        1
      ],
      "content": "static void\nmpn_div_qr_invert (struct gmp_div_inverse *inv,\n\t\t   mp_srcptr dp, mp_size_t dn)\n{\n  assert (dn > 0);\n\n  if (dn == 1)\n    mpn_div_qr_1_invert (inv, dp[0]);\n  else if (dn == 2)\n    mpn_div_qr_2_invert (inv, dp[1], dp[0]);\n  else\n    {\n      unsigned shift;\n      mp_limb_t d1, d0;\n\n      d1 = dp[dn-1];\n      d0 = dp[dn-2];\n      assert (d1 > 0);\n      gmp_clz (shift, d1);\n      inv->shift = shift;\n      if (shift > 0)\n\t{\n\t  d1 = (d1 << shift) | (d0 >> (GMP_LIMB_BITS - shift));\n\t  d0 = (d0 << shift) | (dp[dn-3] >> (GMP_LIMB_BITS - shift));\n\t}\n      inv->d1 = d1;\n      inv->d0 = d0;\n      inv->di = mpn_invert_3by2 (d1, d0);\n    }\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_1_preinv": {
      "start_point": [
        922,
        0
      ],
      "end_point": [
        953,
        1
      ],
      "content": "static mp_limb_t\nmpn_div_qr_1_preinv (mp_ptr qp, mp_srcptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  mp_limb_t d, di;\n  mp_limb_t r;\n  mp_ptr tp = NULL;\n\n  if (inv->shift > 0)\n    {\n      tp = gmp_xalloc_limbs (nn);\n      r = mpn_lshift (tp, np, nn, inv->shift);\n      np = tp;\n    }\n  else\n    r = 0;\n\n  d = inv->d1;\n  di = inv->di;\n  while (--nn >= 0)\n    {\n      mp_limb_t q;\n\n      gmp_udiv_qrnnd_preinv (q, r, r, np[nn], d, di);\n      if (qp)\n\tqp[nn] = q;\n    }\n  if (inv->shift > 0)\n    gmp_free (tp);\n\n  return r >> inv->shift;\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_1": {
      "start_point": [
        955,
        0
      ],
      "end_point": [
        983,
        1
      ],
      "content": "static mp_limb_t\nmpn_div_qr_1 (mp_ptr qp, mp_srcptr np, mp_size_t nn, mp_limb_t d)\n{\n  assert (d > 0);\n\n  /* Special case for powers of two. */\n  if ((d & (d-1)) == 0)\n    {\n      mp_limb_t r = np[0] & (d-1);\n      if (qp)\n\t{\n\t  if (d <= 1)\n\t    mpn_copyi (qp, np, nn);\n\t  else\n\t    {\n\t      unsigned shift;\n\t      gmp_ctz (shift, d);\n\t      mpn_rshift (qp, np, nn, shift);\n\t    }\n\t}\n      return r;\n    }\n  else\n    {\n      struct gmp_div_inverse inv;\n      mpn_div_qr_1_invert (&inv, d);\n      return mpn_div_qr_1_preinv (qp, np, nn, &inv);\n    }\n}",
      "lines": 29,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpn_div_qr_2_preinv": {
      "start_point": [
        985,
        0
      ],
      "end_point": [
        1034,
        1
      ],
      "content": "static void\nmpn_div_qr_2_preinv (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t\t     const struct gmp_div_inverse *inv)\n{\n  unsigned shift;\n  mp_size_t i;\n  mp_limb_t d1, d0, di, r1, r0;\n  mp_ptr tp;\n\n  assert (nn >= 2);\n  shift = inv->shift;\n  d1 = inv->d1;\n  d0 = inv->d0;\n  di = inv->di;\n\n  if (shift > 0)\n    {\n      tp = gmp_xalloc_limbs (nn);\n      r1 = mpn_lshift (tp, np, nn, shift);\n      np = tp;\n    }\n  else\n    r1 = 0;\n\n  r0 = np[nn - 1];\n\n  i = nn - 2;\n  do\n    {\n      mp_limb_t n0, q;\n      n0 = np[i];\n      gmp_udiv_qr_3by2 (q, r1, r0, r1, r0, n0, d1, d0, di);\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  if (shift > 0)\n    {\n      assert ((r0 << (GMP_LIMB_BITS - shift)) == 0);\n      r0 = (r0 >> shift) | (r1 << (GMP_LIMB_BITS - shift));\n      r1 >>= shift;\n\n      gmp_free (tp);\n    }\n\n  rp[1] = r1;\n  rp[0] = r0;\n}",
      "lines": 50,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_2": {
      "start_point": [
        1037,
        0
      ],
      "end_point": [
        1046,
        1
      ],
      "content": "static void\nmpn_div_qr_2 (mp_ptr qp, mp_ptr rp, mp_srcptr np, mp_size_t nn,\n\t      mp_limb_t d1, mp_limb_t d0)\n{\n  struct gmp_div_inverse inv;\n  assert (nn >= 2);\n\n  mpn_div_qr_2_invert (&inv, d1, d0);\n  mpn_div_qr_2_preinv (qp, rp, np, nn, &inv);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_pi1": {
      "start_point": [
        1049,
        0
      ],
      "end_point": [
        1110,
        1
      ],
      "content": "static void\nmpn_div_qr_pi1 (mp_ptr qp,\n\t\tmp_ptr np, mp_size_t nn, mp_limb_t n1,\n\t\tmp_srcptr dp, mp_size_t dn,\n\t\tmp_limb_t dinv)\n{\n  mp_size_t i;\n\n  mp_limb_t d1, d0;\n  mp_limb_t cy, cy1;\n  mp_limb_t q;\n\n  assert (dn > 2);\n  assert (nn >= dn);\n\n  d1 = dp[dn - 1];\n  d0 = dp[dn - 2];\n\n  assert ((d1 & GMP_LIMB_HIGHBIT) != 0);\n  /* Iteration variable is the index of the q limb.\n   *\n   * We divide <n1, np[dn-1+i], np[dn-2+i], np[dn-3+i],..., np[i]>\n   * by            <d1,          d0,        dp[dn-3],  ..., dp[0] >\n   */\n\n  i = nn - dn;\n  do\n    {\n      mp_limb_t n0 = np[dn-1+i];\n\n      if (n1 == d1 && n0 == d0)\n\t{\n\t  q = GMP_LIMB_MAX;\n\t  mpn_submul_1 (np+i, dp, dn, q);\n\t  n1 = np[dn-1+i];\t/* update n1, last loop's value will now be invalid */\n\t}\n      else\n\t{\n\t  gmp_udiv_qr_3by2 (q, n1, n0, n1, n0, np[dn-2+i], d1, d0, dinv);\n\n\t  cy = mpn_submul_1 (np + i, dp, dn-2, q);\n\n\t  cy1 = n0 < cy;\n\t  n0 = n0 - cy;\n\t  cy = n1 < cy1;\n\t  n1 = n1 - cy1;\n\t  np[dn-2+i] = n0;\n\n\t  if (cy != 0)\n\t    {\n\t      n1 += d1 + mpn_add_n (np + i, np + i, dp, dn - 1);\n\t      q--;\n\t    }\n\t}\n\n      if (qp)\n\tqp[i] = q;\n    }\n  while (--i >= 0);\n\n  np[dn - 1] = n1;\n}",
      "lines": 62,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr_preinv": {
      "start_point": [
        1112,
        0
      ],
      "end_point": [
        1144,
        1
      ],
      "content": "static void\nmpn_div_qr_preinv (mp_ptr qp, mp_ptr np, mp_size_t nn,\n\t\t   mp_srcptr dp, mp_size_t dn,\n\t\t   const struct gmp_div_inverse *inv)\n{\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  if (dn == 1)\n    np[0] = mpn_div_qr_1_preinv (qp, np, nn, inv);\n  else if (dn == 2)\n    mpn_div_qr_2_preinv (qp, np, np, nn, inv);\n  else\n    {\n      mp_limb_t nh;\n      unsigned shift;\n\n      assert (inv->d1 == dp[dn-1]);\n      assert (inv->d0 == dp[dn-2]);\n      assert ((inv->d1 & GMP_LIMB_HIGHBIT) != 0);\n\n      shift = inv->shift;\n      if (shift > 0)\n\tnh = mpn_lshift (np, np, nn, shift);\n      else\n\tnh = 0;\n\n      mpn_div_qr_pi1 (qp, np, nn, nh, dp, dn, inv->di);\n\n      if (shift > 0)\n\tgmp_assert_nocarry (mpn_rshift (np, np, dn, shift));\n    }\n}",
      "lines": 33,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_div_qr": {
      "start_point": [
        1146,
        0
      ],
      "end_point": [
        1165,
        1
      ],
      "content": "static void\nmpn_div_qr (mp_ptr qp, mp_ptr np, mp_size_t nn, mp_srcptr dp, mp_size_t dn)\n{\n  struct gmp_div_inverse inv;\n  mp_ptr tp = NULL;\n\n  assert (dn > 0);\n  assert (nn >= dn);\n\n  mpn_div_qr_invert (&inv, dp, dn);\n  if (dn > 2 && inv.shift > 0)\n    {\n      tp = gmp_xalloc_limbs (dn);\n      gmp_assert_nocarry (mpn_lshift (tp, dp, dn, inv.shift));\n      dp = tp;\n    }\n  mpn_div_qr_preinv (qp, np, nn, dp, dn, &inv);\n  if (tp)\n    gmp_free (tp);\n}",
      "lines": 20,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_base_power_of_two_p": {
      "start_point": [
        1169,
        0
      ],
      "end_point": [
        1184,
        1
      ],
      "content": "static unsigned\nmpn_base_power_of_two_p (unsigned b)\n{\n  switch (b)\n    {\n    case 2: return 1;\n    case 4: return 2;\n    case 8: return 3;\n    case 16: return 4;\n    case 32: return 5;\n    case 64: return 6;\n    case 128: return 7;\n    case 256: return 8;\n    default: return 0;\n    }\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_get_base_info": {
      "start_point": [
        1194,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "static void\nmpn_get_base_info (struct mpn_base_info *info, mp_limb_t b)\n{\n  mp_limb_t m;\n  mp_limb_t p;\n  unsigned exp;\n\n  m = GMP_LIMB_MAX / b;\n  for (exp = 1, p = b; p <= m; exp++)\n    p *= b;\n\n  info->exp = exp;\n  info->bb = p;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_limb_size_in_base_2": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1217,
        1
      ],
      "content": "static mp_bitcnt_t\nmpn_limb_size_in_base_2 (mp_limb_t u)\n{\n  unsigned shift;\n\n  assert (u > 0);\n  gmp_clz (shift, u);\n  return GMP_LIMB_BITS - shift;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpn_get_str_bits": {
      "start_point": [
        1219,
        0
      ],
      "end_point": [
        1246,
        1
      ],
      "content": "static size_t\nmpn_get_str_bits (unsigned char *sp, unsigned bits, mp_srcptr up, mp_size_t un)\n{\n  unsigned char mask;\n  size_t sn, j;\n  mp_size_t i;\n  unsigned shift;\n\n  sn = ((un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1])\n\t+ bits - 1) / bits;\n\n  mask = (1U << bits) - 1;\n\n  for (i = 0, j = sn, shift = 0; j-- > 0;)\n    {\n      unsigned char digit = up[i] >> shift;\n\n      shift += bits;\n\n      if (shift >= GMP_LIMB_BITS && ++i < un)\n\t{\n\t  shift -= GMP_LIMB_BITS;\n\t  digit |= up[i] << (bits - shift);\n\t}\n      sp[j] = digit & mask;\n    }\n  return sn;\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_limb_get_str": {
      "start_point": [
        1250,
        0
      ],
      "end_point": [
        1269,
        1
      ],
      "content": "static size_t\nmpn_limb_get_str (unsigned char *sp, mp_limb_t w,\n\t\t  const struct gmp_div_inverse *binv)\n{\n  mp_size_t i;\n  for (i = 0; w > 0; i++)\n    {\n      mp_limb_t h, l, r;\n\n      h = w >> (GMP_LIMB_BITS - binv->shift);\n      l = w << binv->shift;\n\n      gmp_udiv_qrnnd_preinv (w, r, h, l, binv->d1, binv->di);\n      assert ( (r << (GMP_LIMB_BITS - binv->shift)) == 0);\n      r >>= binv->shift;\n\n      sp[i] = r;\n    }\n  return i;\n}",
      "lines": 20,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_get_str_other": {
      "start_point": [
        1271,
        0
      ],
      "end_point": [
        1313,
        1
      ],
      "content": "static size_t\nmpn_get_str_other (unsigned char *sp,\n\t\t   int base, const struct mpn_base_info *info,\n\t\t   mp_ptr up, mp_size_t un)\n{\n  struct gmp_div_inverse binv;\n  size_t sn;\n  size_t i;\n\n  mpn_div_qr_1_invert (&binv, base);\n\n  sn = 0;\n\n  if (un > 1)\n    {\n      struct gmp_div_inverse bbinv;\n      mpn_div_qr_1_invert (&bbinv, info->bb);\n\n      do\n\t{\n\t  mp_limb_t w;\n\t  size_t done;\n\t  w = mpn_div_qr_1_preinv (up, up, un, &bbinv);\n\t  un -= (up[un-1] == 0);\n\t  done = mpn_limb_get_str (sp + sn, w, &binv);\n\n\t  for (sn += done; done < info->exp; done++)\n\t    sp[sn++] = 0;\n\t}\n      while (un > 1);\n    }\n  sn += mpn_limb_get_str (sp + sn, up[0], &binv);\n\n  /* Reverse order */\n  for (i = 0; 2*i + 1 < sn; i++)\n    {\n      unsigned char t = sp[i];\n      sp[i] = sp[sn - i - 1];\n      sp[sn - i - 1] = t;\n    }\n\n  return sn;\n}",
      "lines": 43,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "mpn_get_str": {
      "start_point": [
        1315,
        0
      ],
      "end_point": [
        1333,
        1
      ],
      "content": "size_t\nmpn_get_str (unsigned char *sp, int base, mp_ptr up, mp_size_t un)\n{\n  unsigned bits;\n\n  assert (un > 0);\n  assert (up[un-1] > 0);\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_get_str_bits (sp, bits, up, un);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_get_str_other (sp, base, &info, up, un);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "size_t"
      ]
    },
    "mpn_set_str_bits": {
      "start_point": [
        1335,
        0
      ],
      "end_point": [
        1364,
        1
      ],
      "content": "static mp_size_t\nmpn_set_str_bits (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t  unsigned bits)\n{\n  mp_size_t rn;\n  size_t j;\n  unsigned shift;\n\n  for (j = sn, rn = 0, shift = 0; j-- > 0; )\n    {\n      if (shift == 0)\n\t{\n\t  rp[rn++] = sp[j];\n\t  shift += bits;\n\t}\n      else\n\t{\n\t  rp[rn-1] |= (mp_limb_t) sp[j] << shift;\n\t  shift += bits;\n\t  if (shift >= GMP_LIMB_BITS)\n\t    {\n\t      shift -= GMP_LIMB_BITS;\n\t      if (shift > 0)\n\t\trp[rn++] = (mp_limb_t) sp[j] >> (bits - shift);\n\t    }\n\t}\n    }\n  rn = mpn_normalized_size (rp, rn);\n  return rn;\n}",
      "lines": 30,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_set_str_other": {
      "start_point": [
        1368,
        0
      ],
      "end_point": [
        1404,
        1
      ],
      "content": "static mp_size_t\nmpn_set_str_other (mp_ptr rp, const unsigned char *sp, size_t sn,\n\t\t   mp_limb_t b, const struct mpn_base_info *info)\n{\n  mp_size_t rn;\n  mp_limb_t w;\n  unsigned k;\n  size_t j;\n\n  assert (sn > 0);\n\n  k = 1 + (sn - 1) % info->exp;\n\n  j = 0;\n  w = sp[j++];\n  while (--k != 0)\n    w = w * b + sp[j++];\n\n  rp[0] = w;\n\n  for (rn = 1; j < sn;)\n    {\n      mp_limb_t cy;\n\n      w = sp[j++];\n      for (k = 1; k < info->exp; k++)\n\tw = w * b + sp[j++];\n\n      cy = mpn_mul_1 (rp, rp, rn, info->bb);\n      cy += mpn_add_1 (rp, rp, rn, w);\n      if (cy > 0)\n\trp[rn++] = cy;\n    }\n  assert (j == sn);\n\n  return rn;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpn_set_str": {
      "start_point": [
        1406,
        0
      ],
      "end_point": [
        1424,
        1
      ],
      "content": "mp_size_t\nmpn_set_str (mp_ptr rp, const unsigned char *sp, size_t sn, int base)\n{\n  unsigned bits;\n\n  if (sn == 0)\n    return 0;\n\n  bits = mpn_base_power_of_two_p (base);\n  if (bits)\n    return mpn_set_str_bits (rp, sp, sn, bits);\n  else\n    {\n      struct mpn_base_info info;\n\n      mpn_get_base_info (&info, base);\n      return mpn_set_str_other (rp, sp, sn, base, &info);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpz_init": {
      "start_point": [
        1428,
        0
      ],
      "end_point": [
        1436,
        1
      ],
      "content": "void\nmpz_init (mpz_t r)\n{\n  static const mp_limb_t dummy_limb = 0xc1a0;\n\n  r->_mp_alloc = 0;\n  r->_mp_size = 0;\n  r->_mp_d = (mp_ptr) &dummy_limb;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_init2": {
      "start_point": [
        1440,
        0
      ],
      "end_point": [
        1451,
        1
      ],
      "content": "void\nmpz_init2 (mpz_t r, mp_bitcnt_t bits)\n{\n  mp_size_t rn;\n\n  bits -= (bits != 0);\t\t/* Round down, except if 0 */\n  rn = 1 + bits / GMP_LIMB_BITS;\n\n  r->_mp_alloc = rn;\n  r->_mp_size = 0;\n  r->_mp_d = gmp_xalloc_limbs (rn);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_clear": {
      "start_point": [
        1453,
        0
      ],
      "end_point": [
        1458,
        1
      ],
      "content": "void\nmpz_clear (mpz_t r)\n{\n  if (r->_mp_alloc)\n    gmp_free (r->_mp_d);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_realloc": {
      "start_point": [
        1460,
        0
      ],
      "end_point": [
        1475,
        1
      ],
      "content": "static mp_ptr\nmpz_realloc (mpz_t r, mp_size_t size)\n{\n  size = GMP_MAX (size, 1);\n\n  if (r->_mp_alloc)\n    r->_mp_d = gmp_xrealloc_limbs (r->_mp_d, size);\n  else\n    r->_mp_d = gmp_xalloc_limbs (size);\n  r->_mp_alloc = size;\n\n  if (GMP_ABS (r->_mp_size) > size)\n    r->_mp_size = 0;\n\n  return r->_mp_d;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_ptr"
      ]
    },
    "mpz_set_si": {
      "start_point": [
        1483,
        0
      ],
      "end_point": [
        1493,
        1
      ],
      "content": "void\nmpz_set_si (mpz_t r, signed long int x)\n{\n  if (x >= 0)\n    mpz_set_ui (r, x);\n  else /* (x < 0) */\n    {\n      r->_mp_size = -1;\n      MPZ_REALLOC (r, 1)[0] = GMP_NEG_CAST (unsigned long int, x);\n    }\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_set_ui": {
      "start_point": [
        1495,
        0
      ],
      "end_point": [
        1505,
        1
      ],
      "content": "void\nmpz_set_ui (mpz_t r, unsigned long int x)\n{\n  if (x > 0)\n    {\n      r->_mp_size = 1;\n      MPZ_REALLOC (r, 1)[0] = x;\n    }\n  else\n    r->_mp_size = 0;\n}",
      "lines": 11,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_set": {
      "start_point": [
        1507,
        0
      ],
      "end_point": [
        1522,
        1
      ],
      "content": "void\nmpz_set (mpz_t r, const mpz_t x)\n{\n  /* Allow the NOP r == x */\n  if (r != x)\n    {\n      mp_size_t n;\n      mp_ptr rp;\n\n      n = GMP_ABS (x->_mp_size);\n      rp = MPZ_REALLOC (r, n);\n\n      mpn_copyi (rp, x->_mp_d, n);\n      r->_mp_size = x->_mp_size;\n    }\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_si": {
      "start_point": [
        1524,
        0
      ],
      "end_point": [
        1529,
        1
      ],
      "content": "void\nmpz_init_set_si (mpz_t r, signed long int x)\n{\n  mpz_init (r);\n  mpz_set_si (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_ui": {
      "start_point": [
        1531,
        0
      ],
      "end_point": [
        1536,
        1
      ],
      "content": "void\nmpz_init_set_ui (mpz_t r, unsigned long int x)\n{\n  mpz_init (r);\n  mpz_set_ui (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set": {
      "start_point": [
        1538,
        0
      ],
      "end_point": [
        1543,
        1
      ],
      "content": "void\nmpz_init_set (mpz_t r, const mpz_t x)\n{\n  mpz_init (r);\n  mpz_set (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fits_slong_p": {
      "start_point": [
        1545,
        0
      ],
      "end_point": [
        1556,
        1
      ],
      "content": "int\nmpz_fits_slong_p (const mpz_t u)\n{\n  mp_size_t us = u->_mp_size;\n\n  if (us == 1)\n    return u->_mp_d[0] < GMP_LIMB_HIGHBIT;\n  else if (us == -1)\n    return u->_mp_d[0] <= GMP_LIMB_HIGHBIT;\n  else\n    return (us == 0);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_fits_ulong_p": {
      "start_point": [
        1558,
        0
      ],
      "end_point": [
        1564,
        1
      ],
      "content": "int\nmpz_fits_ulong_p (const mpz_t u)\n{\n  mp_size_t us = u->_mp_size;\n\n  return (us == (us > 0));\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpz_get_si": {
      "start_point": [
        1566,
        0
      ],
      "end_point": [
        1574,
        1
      ],
      "content": "long int\nmpz_get_si (const mpz_t u)\n{\n  if (u->_mp_size < 0)\n    /* This expression is necessary to properly handle 0x80000000 */\n    return -1 - (long) ((u->_mp_d[0] - 1) & ~GMP_LIMB_HIGHBIT);\n  else\n    return (long) (mpz_get_ui (u) & ~GMP_LIMB_HIGHBIT);\n}",
      "lines": 9,
      "depth": 13,
      "decorators": [
        "long int",
        "long",
        "int"
      ]
    },
    "mpz_get_ui": {
      "start_point": [
        1576,
        0
      ],
      "end_point": [
        1580,
        1
      ],
      "content": "unsigned long int\nmpz_get_ui (const mpz_t u)\n{\n  return u->_mp_size == 0 ? 0 : u->_mp_d[0];\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "unsigned long int",
        "unsigned",
        "long",
        "int"
      ]
    },
    "mpz_size": {
      "start_point": [
        1582,
        0
      ],
      "end_point": [
        1586,
        1
      ],
      "content": "size_t\nmpz_size (const mpz_t u)\n{\n  return GMP_ABS (u->_mp_size);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "mpz_getlimbn": {
      "start_point": [
        1588,
        0
      ],
      "end_point": [
        1595,
        1
      ],
      "content": "mp_limb_t\nmpz_getlimbn (const mpz_t u, mp_size_t n)\n{\n  if (n >= 0 && n < GMP_ABS (u->_mp_size))\n    return u->_mp_d[n];\n  else\n    return 0;\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "mp_limb_t"
      ]
    },
    "mpz_realloc2": {
      "start_point": [
        1597,
        0
      ],
      "end_point": [
        1601,
        1
      ],
      "content": "void\nmpz_realloc2 (mpz_t x, mp_bitcnt_t n)\n{\n  mpz_realloc (x, 1 + (n - (n != 0)) / GMP_LIMB_BITS);\n}",
      "lines": 5,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_limbs_read": {
      "start_point": [
        1603,
        0
      ],
      "end_point": [
        1607,
        1
      ],
      "content": "mp_srcptr\nmpz_limbs_read (mpz_srcptr x)\n{\n  return x->_mp_d;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "mp_srcptr"
      ]
    },
    "mpz_limbs_modify": {
      "start_point": [
        1609,
        0
      ],
      "end_point": [
        1614,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_modify (mpz_t x, mp_size_t n)\n{\n  assert (n > 0);\n  return MPZ_REALLOC (x, n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "mp_ptr"
      ]
    },
    "mpz_limbs_write": {
      "start_point": [
        1616,
        0
      ],
      "end_point": [
        1620,
        1
      ],
      "content": "mp_ptr\nmpz_limbs_write (mpz_t x, mp_size_t n)\n{\n  return mpz_limbs_modify (x, n);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "mp_ptr"
      ]
    },
    "mpz_limbs_finish": {
      "start_point": [
        1622,
        0
      ],
      "end_point": [
        1628,
        1
      ],
      "content": "void\nmpz_limbs_finish (mpz_t x, mp_size_t xs)\n{\n  mp_size_t xn;\n  xn = mpn_normalized_size (x->_mp_d, GMP_ABS (xs));\n  x->_mp_size = xs < 0 ? -xn : xn;\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_roinit_n": {
      "start_point": [
        1630,
        0
      ],
      "end_point": [
        1637,
        1
      ],
      "content": "mpz_srcptr\nmpz_roinit_n (mpz_t x, mp_srcptr xp, mp_size_t xs)\n{\n  x->_mp_alloc = 0;\n  x->_mp_d = (mp_ptr) xp;\n  mpz_limbs_finish (x, xs);\n  return x;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "mpz_srcptr"
      ]
    },
    "mpz_set_d": {
      "start_point": [
        1641,
        0
      ],
      "end_point": [
        1690,
        1
      ],
      "content": "void\nmpz_set_d (mpz_t r, double x)\n{\n  int sign;\n  mp_ptr rp;\n  mp_size_t rn, i;\n  double B;\n  double Bi;\n  mp_limb_t f;\n\n  /* x != x is true when x is a NaN, and x == x * 0.5 is true when x is\n     zero or infinity. */\n  if (x != x || x == x * 0.5)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = x < 0.0 ;\n  if (sign)\n    x = - x;\n\n  if (x < 1.0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n  Bi = 1.0 / B;\n  for (rn = 1; x >= B; rn++)\n    x *= Bi;\n\n  rp = MPZ_REALLOC (r, rn);\n\n  f = (mp_limb_t) x;\n  x -= f;\n  assert (x < 1.0);\n  i = rn-1;\n  rp[i] = f;\n  while (--i >= 0)\n    {\n      x = B * x;\n      f = (mp_limb_t) x;\n      x -= f;\n      assert (x < 1.0);\n      rp[i] = f;\n    }\n\n  r->_mp_size = sign ? - rn : rn;\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_init_set_d": {
      "start_point": [
        1692,
        0
      ],
      "end_point": [
        1697,
        1
      ],
      "content": "void\nmpz_init_set_d (mpz_t r, double x)\n{\n  mpz_init (r);\n  mpz_set_d (r, x);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_get_d": {
      "start_point": [
        1699,
        0
      ],
      "end_point": [
        1719,
        1
      ],
      "content": "double\nmpz_get_d (const mpz_t u)\n{\n  mp_size_t un;\n  double x;\n  double B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    return 0.0;\n\n  x = u->_mp_d[--un];\n  while (un > 0)\n    x = B*x + u->_mp_d[--un];\n\n  if (u->_mp_size < 0)\n    x = -x;\n\n  return x;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "double"
      ]
    },
    "mpz_cmpabs_d": {
      "start_point": [
        1721,
        0
      ],
      "end_point": [
        1760,
        1
      ],
      "content": "int\nmpz_cmpabs_d (const mpz_t x, double d)\n{\n  mp_size_t xn;\n  double B, Bi;\n  mp_size_t i;\n\n  xn = x->_mp_size;\n  d = GMP_ABS (d);\n\n  if (xn != 0)\n    {\n      xn = GMP_ABS (xn);\n\n      B = 2.0 * (double) GMP_LIMB_HIGHBIT;\n      Bi = 1.0 / B;\n\n      /* Scale d so it can be compared with the top limb. */\n      for (i = 1; i < xn; i++)\n\td *= Bi;\n\n      if (d >= B)\n\treturn -1;\n\n      /* Compare floor(d) to top limb, subtract and cancel when equal. */\n      for (i = xn; i-- > 0;)\n\t{\n\t  mp_limb_t f, xl;\n\n\t  f = (mp_limb_t) d;\n\t  xl = x->_mp_d[i];\n\t  if (xl > f)\n\t    return 1;\n\t  else if (xl < f)\n\t    return -1;\n\t  d = B * (d - f);\n\t}\n    }\n  return - (d > 0.0);\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_d": {
      "start_point": [
        1762,
        0
      ],
      "end_point": [
        1779,
        1
      ],
      "content": "int\nmpz_cmp_d (const mpz_t x, double d)\n{\n  if (x->_mp_size < 0)\n    {\n      if (d >= 0.0)\n\treturn -1;\n      else\n\treturn -mpz_cmpabs_d (x, d);\n    }\n  else\n    {\n      if (d < 0.0)\n\treturn 1;\n      else\n\treturn mpz_cmpabs_d (x, d);\n    }\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpz_sgn": {
      "start_point": [
        1783,
        0
      ],
      "end_point": [
        1787,
        1
      ],
      "content": "int\nmpz_sgn (const mpz_t u)\n{\n  return GMP_CMP (u->_mp_size, 0);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_si": {
      "start_point": [
        1789,
        0
      ],
      "end_point": [
        1802,
        1
      ],
      "content": "int\nmpz_cmp_si (const mpz_t u, long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (usize < -1)\n    return -1;\n  else if (v >= 0)\n    return mpz_cmp_ui (u, v);\n  else if (usize >= 0)\n    return 1;\n  else /* usize == -1 */\n    return GMP_CMP (GMP_NEG_CAST (mp_limb_t, v), u->_mp_d[0]);\n}",
      "lines": 14,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp_ui": {
      "start_point": [
        1804,
        0
      ],
      "end_point": [
        1815,
        1
      ],
      "content": "int\nmpz_cmp_ui (const mpz_t u, unsigned long v)\n{\n  mp_size_t usize = u->_mp_size;\n\n  if (usize > 1)\n    return 1;\n  else if (usize < 0)\n    return -1;\n  else\n    return GMP_CMP (mpz_get_ui (u), v);\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmp": {
      "start_point": [
        1817,
        0
      ],
      "end_point": [
        1829,
        1
      ],
      "content": "int\nmpz_cmp (const mpz_t a, const mpz_t b)\n{\n  mp_size_t asize = a->_mp_size;\n  mp_size_t bsize = b->_mp_size;\n\n  if (asize != bsize)\n    return (asize < bsize) ? -1 : 1;\n  else if (asize >= 0)\n    return mpn_cmp (a->_mp_d, b->_mp_d, asize);\n  else\n    return mpn_cmp (b->_mp_d, a->_mp_d, -asize);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmpabs_ui": {
      "start_point": [
        1831,
        0
      ],
      "end_point": [
        1838,
        1
      ],
      "content": "int\nmpz_cmpabs_ui (const mpz_t u, unsigned long v)\n{\n  if (GMP_ABS (u->_mp_size) > 1)\n    return 1;\n  else\n    return GMP_CMP (mpz_get_ui (u), v);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_cmpabs": {
      "start_point": [
        1840,
        0
      ],
      "end_point": [
        1845,
        1
      ],
      "content": "int\nmpz_cmpabs (const mpz_t u, const mpz_t v)\n{\n  return mpn_cmp4 (u->_mp_d, GMP_ABS (u->_mp_size),\n\t\t   v->_mp_d, GMP_ABS (v->_mp_size));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_abs": {
      "start_point": [
        1847,
        0
      ],
      "end_point": [
        1852,
        1
      ],
      "content": "void\nmpz_abs (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = GMP_ABS (r->_mp_size);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_neg": {
      "start_point": [
        1854,
        0
      ],
      "end_point": [
        1859,
        1
      ],
      "content": "void\nmpz_neg (mpz_t r, const mpz_t u)\n{\n  mpz_set (r, u);\n  r->_mp_size = -r->_mp_size;\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_swap": {
      "start_point": [
        1861,
        0
      ],
      "end_point": [
        1867,
        1
      ],
      "content": "void\nmpz_swap (mpz_t u, mpz_t v)\n{\n  MP_SIZE_T_SWAP (u->_mp_size, v->_mp_size);\n  MP_SIZE_T_SWAP (u->_mp_alloc, v->_mp_alloc);\n  MP_PTR_SWAP (u->_mp_d, v->_mp_d);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "mpz_abs_add_ui": {
      "start_point": [
        1873,
        0
      ],
      "end_point": [
        1894,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_add_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mp_size_t an;\n  mp_ptr rp;\n  mp_limb_t cy;\n\n  an = GMP_ABS (a->_mp_size);\n  if (an == 0)\n    {\n      MPZ_REALLOC (r, 1)[0] = b;\n      return b > 0;\n    }\n\n  rp = MPZ_REALLOC (r, an + 1);\n\n  cy = mpn_add_1 (rp, a->_mp_d, an, b);\n  rp[an] = cy;\n  an += cy;\n\n  return an;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_abs_sub_ui": {
      "start_point": [
        1898,
        0
      ],
      "end_point": [
        1920,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_sub_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_ptr rp;\n\n  if (an == 0)\n    {\n      MPZ_REALLOC (r, 1)[0] = b;\n      return -(b > 0);\n    }\n  rp = MPZ_REALLOC (r, an);\n  if (an == 1 && a->_mp_d[0] < b)\n    {\n      rp[0] = b - a->_mp_d[0];\n      return -1;\n    }\n  else\n    {\n      gmp_assert_nocarry (mpn_sub_1 (rp, a->_mp_d, an, b));\n      return mpn_normalized_size (rp, an);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_add_ui": {
      "start_point": [
        1922,
        0
      ],
      "end_point": [
        1929,
        1
      ],
      "content": "void\nmpz_add_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  if (a->_mp_size >= 0)\n    r->_mp_size = mpz_abs_add_ui (r, a, b);\n  else\n    r->_mp_size = -mpz_abs_sub_ui (r, a, b);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_sub_ui": {
      "start_point": [
        1931,
        0
      ],
      "end_point": [
        1938,
        1
      ],
      "content": "void\nmpz_sub_ui (mpz_t r, const mpz_t a, unsigned long b)\n{\n  if (a->_mp_size < 0)\n    r->_mp_size = -mpz_abs_add_ui (r, a, b);\n  else\n    r->_mp_size = mpz_abs_sub_ui (r, a, b);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_ui_sub": {
      "start_point": [
        1940,
        0
      ],
      "end_point": [
        1947,
        1
      ],
      "content": "void\nmpz_ui_sub (mpz_t r, unsigned long a, const mpz_t b)\n{\n  if (b->_mp_size < 0)\n    r->_mp_size = mpz_abs_add_ui (r, b, a);\n  else\n    r->_mp_size = -mpz_abs_sub_ui (r, b, a);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_abs_add": {
      "start_point": [
        1949,
        0
      ],
      "end_point": [
        1969,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  mp_ptr rp;\n  mp_limb_t cy;\n\n  if (an < bn)\n    {\n      MPZ_SRCPTR_SWAP (a, b);\n      MP_SIZE_T_SWAP (an, bn);\n    }\n\n  rp = MPZ_REALLOC (r, an + 1);\n  cy = mpn_add (rp, a->_mp_d, an, b->_mp_d, bn);\n\n  rp[an] = cy;\n\n  return an + cy;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_abs_sub": {
      "start_point": [
        1971,
        0
      ],
      "end_point": [
        1994,
        1
      ],
      "content": "static mp_size_t\nmpz_abs_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t an = GMP_ABS (a->_mp_size);\n  mp_size_t bn = GMP_ABS (b->_mp_size);\n  int cmp;\n  mp_ptr rp;\n\n  cmp = mpn_cmp4 (a->_mp_d, an, b->_mp_d, bn);\n  if (cmp > 0)\n    {\n      rp = MPZ_REALLOC (r, an);\n      gmp_assert_nocarry (mpn_sub (rp, a->_mp_d, an, b->_mp_d, bn));\n      return mpn_normalized_size (rp, an);\n    }\n  else if (cmp < 0)\n    {\n      rp = MPZ_REALLOC (r, bn);\n      gmp_assert_nocarry (mpn_sub (rp, b->_mp_d, bn, a->_mp_d, an));\n      return -mpn_normalized_size (rp, bn);\n    }\n  else\n    return 0;\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "mpz_add": {
      "start_point": [
        1996,
        0
      ],
      "end_point": [
        2007,
        1
      ],
      "content": "void\nmpz_add (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_add (r, a, b);\n  else\n    rn = mpz_abs_sub (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_sub": {
      "start_point": [
        2009,
        0
      ],
      "end_point": [
        2020,
        1
      ],
      "content": "void\nmpz_sub (mpz_t r, const mpz_t a, const mpz_t b)\n{\n  mp_size_t rn;\n\n  if ( (a->_mp_size ^ b->_mp_size) >= 0)\n    rn = mpz_abs_sub (r, a, b);\n  else\n    rn = mpz_abs_add (r, a, b);\n\n  r->_mp_size = a->_mp_size >= 0 ? rn : - rn;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_si": {
      "start_point": [
        2024,
        0
      ],
      "end_point": [
        2034,
        1
      ],
      "content": "void\nmpz_mul_si (mpz_t r, const mpz_t u, long int v)\n{\n  if (v < 0)\n    {\n      mpz_mul_ui (r, u, GMP_NEG_CAST (unsigned long int, v));\n      mpz_neg (r, r);\n    }\n  else\n    mpz_mul_ui (r, u, (unsigned long int) v);\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_ui": {
      "start_point": [
        2036,
        0
      ],
      "end_point": [
        2059,
        1
      ],
      "content": "void\nmpz_mul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mp_size_t un, us;\n  mp_ptr tp;\n  mp_limb_t cy;\n\n  us = u->_mp_size;\n\n  if (us == 0 || v == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  un = GMP_ABS (us);\n\n  tp = MPZ_REALLOC (r, un + 1);\n  cy = mpn_mul_1 (tp, u->_mp_d, un, v);\n  tp[un] = cy;\n\n  un += (cy > 0);\n  r->_mp_size = (us < 0) ? - un : un;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul": {
      "start_point": [
        2061,
        0
      ],
      "end_point": [
        2097,
        1
      ],
      "content": "void\nmpz_mul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  int sign;\n  mp_size_t un, vn, rn;\n  mpz_t t;\n  mp_ptr tp;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if (un == 0 || vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  sign = (un ^ vn) < 0;\n\n  un = GMP_ABS (un);\n  vn = GMP_ABS (vn);\n\n  mpz_init2 (t, (un + vn) * GMP_LIMB_BITS);\n\n  tp = t->_mp_d;\n  if (un >= vn)\n    mpn_mul (tp, u->_mp_d, un, v->_mp_d, vn);\n  else\n    mpn_mul (tp, v->_mp_d, vn, u->_mp_d, un);\n\n  rn = un + vn;\n  rn -= tp[rn-1] == 0;\n\n  t->_mp_size = sign ? - rn : rn;\n  mpz_swap (r, t);\n  mpz_clear (t);\n}",
      "lines": 37,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_mul_2exp": {
      "start_point": [
        2099,
        0
      ],
      "end_point": [
        2131,
        1
      ],
      "content": "void\nmpz_mul_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bits)\n{\n  mp_size_t un, rn;\n  mp_size_t limbs;\n  unsigned shift;\n  mp_ptr rp;\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  limbs = bits / GMP_LIMB_BITS;\n  shift = bits % GMP_LIMB_BITS;\n\n  rn = un + limbs + (shift > 0);\n  rp = MPZ_REALLOC (r, rn);\n  if (shift > 0)\n    {\n      mp_limb_t cy = mpn_lshift (rp + limbs, u->_mp_d, un, shift);\n      rp[rn-1] = cy;\n      rn -= (cy == 0);\n    }\n  else\n    mpn_copyd (rp + limbs, u->_mp_d, un);\n\n  mpn_zero (rp, limbs);\n\n  r->_mp_size = (u->_mp_size < 0) ? - rn : rn;\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "mpz_addmul_ui": {
      "start_point": [
        2133,
        0
      ],
      "end_point": [
        2141,
        1
      ],
      "content": "void\nmpz_addmul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul_ui (t, u, v);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul_ui": {
      "start_point": [
        2143,
        0
      ],
      "end_point": [
        2151,
        1
      ],
      "content": "void\nmpz_submul_ui (mpz_t r, const mpz_t u, unsigned long int v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul_ui (t, u, v);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_addmul": {
      "start_point": [
        2153,
        0
      ],
      "end_point": [
        2161,
        1
      ],
      "content": "void\nmpz_addmul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_add (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_submul": {
      "start_point": [
        2163,
        0
      ],
      "end_point": [
        2171,
        1
      ],
      "content": "void\nmpz_submul (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t t;\n  mpz_init (t);\n  mpz_mul (t, u, v);\n  mpz_sub (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_div_qr": {
      "start_point": [
        2178,
        0
      ],
      "end_point": [
        2288,
        1
      ],
      "content": "static int\nmpz_div_qr (mpz_t q, mpz_t r,\n\t    const mpz_t n, const mpz_t d, enum mpz_div_round_mode mode)\n{\n  mp_size_t ns, ds, nn, dn, qs;\n  ns = n->_mp_size;\n  ds = d->_mp_size;\n\n  if (ds == 0)\n    gmp_die(\"mpz_div_qr: Divide by zero.\");\n\n  if (ns == 0)\n    {\n      if (q)\n\tq->_mp_size = 0;\n      if (r)\n\tr->_mp_size = 0;\n      return 0;\n    }\n\n  nn = GMP_ABS (ns);\n  dn = GMP_ABS (ds);\n\n  qs = ds ^ ns;\n\n  if (nn < dn)\n    {\n      if (mode == GMP_DIV_CEIL && qs >= 0)\n\t{\n\t  /* q = 1, r = n - d */\n\t  if (r)\n\t    mpz_sub (r, n, d);\n\t  if (q)\n\t    mpz_set_ui (q, 1);\n\t}\n      else if (mode == GMP_DIV_FLOOR && qs < 0)\n\t{\n\t  /* q = -1, r = n + d */\n\t  if (r)\n\t    mpz_add (r, n, d);\n\t  if (q)\n\t    mpz_set_si (q, -1);\n\t}\n      else\n\t{\n\t  /* q = 0, r = d */\n\t  if (r)\n\t    mpz_set (r, n);\n\t  if (q)\n\t    q->_mp_size = 0;\n\t}\n      return 1;\n    }\n  else\n    {\n      mp_ptr np, qp;\n      mp_size_t qn, rn;\n      mpz_t tq, tr;\n\n      mpz_init_set (tr, n);\n      np = tr->_mp_d;\n\n      qn = nn - dn + 1;\n\n      if (q)\n\t{\n\t  mpz_init2 (tq, qn * GMP_LIMB_BITS);\n\t  qp = tq->_mp_d;\n\t}\n      else\n\tqp = NULL;\n\n      mpn_div_qr (qp, np, nn, d->_mp_d, dn);\n\n      if (qp)\n\t{\n\t  qn -= (qp[qn-1] == 0);\n\n\t  tq->_mp_size = qs < 0 ? -qn : qn;\n\t}\n      rn = mpn_normalized_size (np, dn);\n      tr->_mp_size = ns < 0 ? - rn : rn;\n\n      if (mode == GMP_DIV_FLOOR && qs < 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_sub_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_add (tr, tr, d);\n\t}\n      else if (mode == GMP_DIV_CEIL && qs >= 0 && rn != 0)\n\t{\n\t  if (q)\n\t    mpz_add_ui (tq, tq, 1);\n\t  if (r)\n\t    mpz_sub (tr, tr, d);\n\t}\n\n      if (q)\n\t{\n\t  mpz_swap (tq, q);\n\t  mpz_clear (tq);\n\t}\n      if (r)\n\tmpz_swap (tr, r);\n\n      mpz_clear (tr);\n\n      return rn != 0;\n    }\n}",
      "lines": 111,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_cdiv_qr": {
      "start_point": [
        2290,
        0
      ],
      "end_point": [
        2294,
        1
      ],
      "content": "void\nmpz_cdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_qr": {
      "start_point": [
        2296,
        0
      ],
      "end_point": [
        2300,
        1
      ],
      "content": "void\nmpz_fdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_qr": {
      "start_point": [
        2302,
        0
      ],
      "end_point": [
        2306,
        1
      ],
      "content": "void\nmpz_tdiv_qr (mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_q": {
      "start_point": [
        2308,
        0
      ],
      "end_point": [
        2312,
        1
      ],
      "content": "void\nmpz_cdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_q": {
      "start_point": [
        2314,
        0
      ],
      "end_point": [
        2318,
        1
      ],
      "content": "void\nmpz_fdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_q": {
      "start_point": [
        2320,
        0
      ],
      "end_point": [
        2324,
        1
      ],
      "content": "void\nmpz_tdiv_q (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_r": {
      "start_point": [
        2326,
        0
      ],
      "end_point": [
        2330,
        1
      ],
      "content": "void\nmpz_cdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_r": {
      "start_point": [
        2332,
        0
      ],
      "end_point": [
        2336,
        1
      ],
      "content": "void\nmpz_fdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_r": {
      "start_point": [
        2338,
        0
      ],
      "end_point": [
        2342,
        1
      ],
      "content": "void\nmpz_tdiv_r (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_mod": {
      "start_point": [
        2344,
        0
      ],
      "end_point": [
        2348,
        1
      ],
      "content": "void\nmpz_mod (mpz_t r, const mpz_t n, const mpz_t d)\n{\n  mpz_div_qr (NULL, r, n, d, d->_mp_size >= 0 ? GMP_DIV_FLOOR : GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_div_q_2exp": {
      "start_point": [
        2350,
        0
      ],
      "end_point": [
        2402,
        1
      ],
      "content": "static void\nmpz_div_q_2exp (mpz_t q, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t un, qn;\n  mp_size_t limb_cnt;\n  mp_ptr qp;\n  int adjust;\n\n  un = u->_mp_size;\n  if (un == 0)\n    {\n      q->_mp_size = 0;\n      return;\n    }\n  limb_cnt = bit_index / GMP_LIMB_BITS;\n  qn = GMP_ABS (un) - limb_cnt;\n  bit_index %= GMP_LIMB_BITS;\n\n  if (mode == ((un > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* un != 0 here. */\n    /* Note: Below, the final indexing at limb_cnt is valid because at\n       that point we have qn > 0. */\n    adjust = (qn <= 0\n\t      || !mpn_zero_p (u->_mp_d, limb_cnt)\n\t      || (u->_mp_d[limb_cnt]\n\t\t  & (((mp_limb_t) 1 << bit_index) - 1)));\n  else\n    adjust = 0;\n\n  if (qn <= 0)\n    qn = 0;\n  else\n    {\n      qp = MPZ_REALLOC (q, qn);\n\n      if (bit_index != 0)\n\t{\n\t  mpn_rshift (qp, u->_mp_d + limb_cnt, qn, bit_index);\n\t  qn -= qp[qn - 1] == 0;\n\t}\n      else\n\t{\n\t  mpn_copyi (qp, u->_mp_d + limb_cnt, qn);\n\t}\n    }\n\n  q->_mp_size = qn;\n\n  if (adjust)\n    mpz_add_ui (q, q, 1);\n  if (un < 0)\n    mpz_neg (q, q);\n}",
      "lines": 53,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_div_r_2exp": {
      "start_point": [
        2404,
        0
      ],
      "end_point": [
        2472,
        1
      ],
      "content": "static void\nmpz_div_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t bit_index,\n\t\tenum mpz_div_round_mode mode)\n{\n  mp_size_t us, un, rn;\n  mp_ptr rp;\n  mp_limb_t mask;\n\n  us = u->_mp_size;\n  if (us == 0 || bit_index == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n  rn = (bit_index + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n  assert (rn > 0);\n\n  rp = MPZ_REALLOC (r, rn);\n  un = GMP_ABS (us);\n\n  mask = GMP_LIMB_MAX >> (rn * GMP_LIMB_BITS - bit_index);\n\n  if (rn > un)\n    {\n      /* Quotient (with truncation) is zero, and remainder is\n\t non-zero */\n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */\n\t{\n\t  /* Have to negate and sign extend. */\n\t  mp_size_t i;\n\n\t  gmp_assert_nocarry (! mpn_neg (rp, u->_mp_d, un));\n\t  for (i = un; i < rn - 1; i++)\n\t    rp[i] = GMP_LIMB_MAX;\n\n\t  rp[rn-1] = mask;\n\t  us = -us;\n\t}\n      else\n\t{\n\t  /* Just copy */\n\t  if (r != u)\n\t    mpn_copyi (rp, u->_mp_d, un);\n\n\t  rn = un;\n\t}\n    }\n  else\n    {\n      if (r != u)\n\tmpn_copyi (rp, u->_mp_d, rn - 1);\n\n      rp[rn-1] = u->_mp_d[rn-1] & mask;\n\n      if (mode == ((us > 0) ? GMP_DIV_CEIL : GMP_DIV_FLOOR)) /* us != 0 here. */\n\t{\n\t  /* If r != 0, compute 2^{bit_count} - r. */\n\t  mpn_neg (rp, rp, rn);\n\n\t  rp[rn-1] &= mask;\n\n\t  /* us is not used for anything else, so we can modify it\n\t     here to indicate flipped sign. */\n\t  us = -us;\n\t}\n    }\n  rn = mpn_normalized_size (rp, rn);\n  r->_mp_size = us < 0 ? -rn : rn;\n}",
      "lines": 69,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_cdiv_q_2exp": {
      "start_point": [
        2474,
        0
      ],
      "end_point": [
        2478,
        1
      ],
      "content": "void\nmpz_cdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_q_2exp": {
      "start_point": [
        2480,
        0
      ],
      "end_point": [
        2484,
        1
      ],
      "content": "void\nmpz_fdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_q_2exp": {
      "start_point": [
        2486,
        0
      ],
      "end_point": [
        2490,
        1
      ],
      "content": "void\nmpz_tdiv_q_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_q_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_cdiv_r_2exp": {
      "start_point": [
        2492,
        0
      ],
      "end_point": [
        2496,
        1
      ],
      "content": "void\nmpz_cdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_fdiv_r_2exp": {
      "start_point": [
        2498,
        0
      ],
      "end_point": [
        2502,
        1
      ],
      "content": "void\nmpz_fdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_tdiv_r_2exp": {
      "start_point": [
        2504,
        0
      ],
      "end_point": [
        2508,
        1
      ],
      "content": "void\nmpz_tdiv_r_2exp (mpz_t r, const mpz_t u, mp_bitcnt_t cnt)\n{\n  mpz_div_r_2exp (r, u, cnt, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_divexact": {
      "start_point": [
        2510,
        0
      ],
      "end_point": [
        2514,
        1
      ],
      "content": "void\nmpz_divexact (mpz_t q, const mpz_t n, const mpz_t d)\n{\n  gmp_assert_nocarry (mpz_div_qr (q, NULL, n, d, GMP_DIV_TRUNC));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_divisible_p": {
      "start_point": [
        2516,
        0
      ],
      "end_point": [
        2520,
        1
      ],
      "content": "int\nmpz_divisible_p (const mpz_t n, const mpz_t d)\n{\n  return mpz_div_qr (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_congruent_p": {
      "start_point": [
        2522,
        0
      ],
      "end_point": [
        2538,
        1
      ],
      "content": "int\nmpz_congruent_p (const mpz_t a, const mpz_t b, const mpz_t m)\n{\n  mpz_t t;\n  int res;\n\n  /* a == b (mod 0) iff a == b */\n  if (mpz_sgn (m) == 0)\n    return (mpz_cmp (a, b) == 0);\n\n  mpz_init (t);\n  mpz_sub (t, a, b);\n  res = mpz_divisible_p (t, m);\n  mpz_clear (t);\n\n  return res;\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpz_div_qr_ui": {
      "start_point": [
        2540,
        0
      ],
      "end_point": [
        2594,
        1
      ],
      "content": "static unsigned long\nmpz_div_qr_ui (mpz_t q, mpz_t r,\n\t       const mpz_t n, unsigned long d, enum mpz_div_round_mode mode)\n{\n  mp_size_t ns, qn;\n  mp_ptr qp;\n  mp_limb_t rl;\n  mp_size_t rs;\n\n  ns = n->_mp_size;\n  if (ns == 0)\n    {\n      if (q)\n\tq->_mp_size = 0;\n      if (r)\n\tr->_mp_size = 0;\n      return 0;\n    }\n\n  qn = GMP_ABS (ns);\n  if (q)\n    qp = MPZ_REALLOC (q, qn);\n  else\n    qp = NULL;\n\n  rl = mpn_div_qr_1 (qp, n->_mp_d, qn, d);\n  assert (rl < d);\n\n  rs = rl > 0;\n  rs = (ns < 0) ? -rs : rs;\n\n  if (rl > 0 && ( (mode == GMP_DIV_FLOOR && ns < 0)\n\t\t  || (mode == GMP_DIV_CEIL && ns >= 0)))\n    {\n      if (q)\n\tgmp_assert_nocarry (mpn_add_1 (qp, qp, qn, 1));\n      rl = d - rl;\n      rs = -rs;\n    }\n\n  if (r)\n    {\n      MPZ_REALLOC (r, 1)[0] = rl;\n      r->_mp_size = rs;\n    }\n  if (q)\n    {\n      qn -= (qp[qn-1] == 0);\n      assert (qn == 0 || qp[qn-1] > 0);\n\n      q->_mp_size = (ns < 0) ? - qn : qn;\n    }\n\n  return rl;\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_qr_ui": {
      "start_point": [
        2596,
        0
      ],
      "end_point": [
        2600,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_qr_ui": {
      "start_point": [
        2602,
        0
      ],
      "end_point": [
        2606,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_qr_ui": {
      "start_point": [
        2608,
        0
      ],
      "end_point": [
        2612,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_qr_ui (mpz_t q, mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_q_ui": {
      "start_point": [
        2614,
        0
      ],
      "end_point": [
        2618,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_q_ui": {
      "start_point": [
        2620,
        0
      ],
      "end_point": [
        2624,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_q_ui": {
      "start_point": [
        2626,
        0
      ],
      "end_point": [
        2630,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_q_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_r_ui": {
      "start_point": [
        2632,
        0
      ],
      "end_point": [
        2636,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_r_ui": {
      "start_point": [
        2637,
        0
      ],
      "end_point": [
        2641,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_r_ui": {
      "start_point": [
        2642,
        0
      ],
      "end_point": [
        2646,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_r_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_cdiv_ui": {
      "start_point": [
        2648,
        0
      ],
      "end_point": [
        2652,
        1
      ],
      "content": "unsigned long\nmpz_cdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_CEIL);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_fdiv_ui": {
      "start_point": [
        2654,
        0
      ],
      "end_point": [
        2658,
        1
      ],
      "content": "unsigned long\nmpz_fdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_tdiv_ui": {
      "start_point": [
        2660,
        0
      ],
      "end_point": [
        2664,
        1
      ],
      "content": "unsigned long\nmpz_tdiv_ui (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_mod_ui": {
      "start_point": [
        2666,
        0
      ],
      "end_point": [
        2670,
        1
      ],
      "content": "unsigned long\nmpz_mod_ui (mpz_t r, const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, r, n, d, GMP_DIV_FLOOR);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_divexact_ui": {
      "start_point": [
        2672,
        0
      ],
      "end_point": [
        2676,
        1
      ],
      "content": "void\nmpz_divexact_ui (mpz_t q, const mpz_t n, unsigned long d)\n{\n  gmp_assert_nocarry (mpz_div_qr_ui (q, NULL, n, d, GMP_DIV_TRUNC));\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_divisible_ui_p": {
      "start_point": [
        2678,
        0
      ],
      "end_point": [
        2682,
        1
      ],
      "content": "int\nmpz_divisible_ui_p (const mpz_t n, unsigned long d)\n{\n  return mpz_div_qr_ui (NULL, NULL, n, d, GMP_DIV_TRUNC) == 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpn_gcd_11": {
      "start_point": [
        2686,
        0
      ],
      "end_point": [
        2727,
        1
      ],
      "content": "static mp_limb_t\nmpn_gcd_11 (mp_limb_t u, mp_limb_t v)\n{\n  unsigned shift;\n\n  assert ( (u | v) > 0);\n\n  if (u == 0)\n    return v;\n  else if (v == 0)\n    return u;\n\n  gmp_ctz (shift, u | v);\n\n  u >>= shift;\n  v >>= shift;\n\n  if ( (u & 1) == 0)\n    MP_LIMB_T_SWAP (u, v);\n\n  while ( (v & 1) == 0)\n    v >>= 1;\n\n  while (u != v)\n    {\n      if (u > v)\n\t{\n\t  u -= v;\n\t  do\n\t    u >>= 1;\n\t  while ( (u & 1) == 0);\n\t}\n      else\n\t{\n\t  v -= u;\n\t  do\n\t    v >>= 1;\n\t  while ( (v & 1) == 0);\n\t}\n    }\n  return u << shift;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "mp_limb_t"
      ]
    },
    "mpz_gcd_ui": {
      "start_point": [
        2729,
        0
      ],
      "end_point": [
        2750,
        1
      ],
      "content": "unsigned long\nmpz_gcd_ui (mpz_t g, const mpz_t u, unsigned long v)\n{\n  mp_size_t un;\n\n  if (v == 0)\n    {\n      if (g)\n\tmpz_abs (g, u);\n    }\n  else\n    {\n      un = GMP_ABS (u->_mp_size);\n      if (un != 0)\n\tv = mpn_gcd_11 (mpn_div_qr_1 (NULL, u->_mp_d, un, v), v);\n\n      if (g)\n\tmpz_set_ui (g, v);\n    }\n\n  return v;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "mpz_make_odd": {
      "start_point": [
        2752,
        0
      ],
      "end_point": [
        2763,
        1
      ],
      "content": "static mp_bitcnt_t\nmpz_make_odd (mpz_t r)\n{\n  mp_bitcnt_t shift;\n\n  assert (r->_mp_size > 0);\n  /* Count trailing zeros, equivalent to mpn_scan1, because we know that there is a 1 */\n  shift = mpn_common_scan (r->_mp_d[0], 0, r->_mp_d, 0, 0);\n  mpz_tdiv_q_2exp (r, r, shift);\n\n  return shift;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_bitcnt_t"
      ]
    },
    "mpz_gcd": {
      "start_point": [
        2765,
        0
      ],
      "end_point": [
        2826,
        1
      ],
      "content": "void\nmpz_gcd (mpz_t g, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv;\n  mp_bitcnt_t uz, vz, gz;\n\n  if (u->_mp_size == 0)\n    {\n      mpz_abs (g, v);\n      return;\n    }\n  if (v->_mp_size == 0)\n    {\n      mpz_abs (g, u);\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  if (tu->_mp_size < tv->_mp_size)\n    mpz_swap (tu, tv);\n\n  mpz_tdiv_r (tu, tu, tv);\n  if (tu->_mp_size == 0)\n    {\n      mpz_swap (g, tv);\n    }\n  else\n    for (;;)\n      {\n\tint c;\n\n\tmpz_make_odd (tu);\n\tc = mpz_cmp (tu, tv);\n\tif (c == 0)\n\t  {\n\t    mpz_swap (g, tu);\n\t    break;\n\t  }\n\tif (c < 0)\n\t  mpz_swap (tu, tv);\n\n\tif (tv->_mp_size == 1)\n\t  {\n\t    mp_limb_t vl = tv->_mp_d[0];\n\t    mp_limb_t ul = mpz_tdiv_ui (tu, vl);\n\t    mpz_set_ui (g, mpn_gcd_11 (ul, vl));\n\t    break;\n\t  }\n\tmpz_sub (tu, tu, tv);\n      }\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_mul_2exp (g, g, gz);\n}",
      "lines": 62,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_gcdext": {
      "start_point": [
        2828,
        0
      ],
      "end_point": [
        3008,
        1
      ],
      "content": "void\nmpz_gcdext (mpz_t g, mpz_t s, mpz_t t, const mpz_t u, const mpz_t v)\n{\n  mpz_t tu, tv, s0, s1, t0, t1;\n  mp_bitcnt_t uz, vz, gz;\n  mp_bitcnt_t power;\n\n  if (u->_mp_size == 0)\n    {\n      /* g = 0 u + sgn(v) v */\n      signed long sign = mpz_sgn (v);\n      mpz_abs (g, v);\n      if (s)\n\tmpz_set_ui (s, 0);\n      if (t)\n\tmpz_set_si (t, sign);\n      return;\n    }\n\n  if (v->_mp_size == 0)\n    {\n      /* g = sgn(u) u + 0 v */\n      signed long sign = mpz_sgn (u);\n      mpz_abs (g, u);\n      if (s)\n\tmpz_set_si (s, sign);\n      if (t)\n\tmpz_set_ui (t, 0);\n      return;\n    }\n\n  mpz_init (tu);\n  mpz_init (tv);\n  mpz_init (s0);\n  mpz_init (s1);\n  mpz_init (t0);\n  mpz_init (t1);\n\n  mpz_abs (tu, u);\n  uz = mpz_make_odd (tu);\n  mpz_abs (tv, v);\n  vz = mpz_make_odd (tv);\n  gz = GMP_MIN (uz, vz);\n\n  uz -= gz;\n  vz -= gz;\n\n  /* Cofactors corresponding to odd gcd. gz handled later. */\n  if (tu->_mp_size < tv->_mp_size)\n    {\n      mpz_swap (tu, tv);\n      MPZ_SRCPTR_SWAP (u, v);\n      MPZ_PTR_SWAP (s, t);\n      MP_BITCNT_T_SWAP (uz, vz);\n    }\n\n  /* Maintain\n   *\n   * u = t0 tu + t1 tv\n   * v = s0 tu + s1 tv\n   *\n   * where u and v denote the inputs with common factors of two\n   * eliminated, and det (s0, t0; s1, t1) = 2^p. Then\n   *\n   * 2^p tu =  s1 u - t1 v\n   * 2^p tv = -s0 u + t0 v\n   */\n\n  /* After initial division, tu = q tv + tu', we have\n   *\n   * u = 2^uz (tu' + q tv)\n   * v = 2^vz tv\n   *\n   * or\n   *\n   * t0 = 2^uz, t1 = 2^uz q\n   * s0 = 0,    s1 = 2^vz\n   */\n\n  mpz_setbit (t0, uz);\n  mpz_tdiv_qr (t1, tu, tu, tv);\n  mpz_mul_2exp (t1, t1, uz);\n\n  mpz_setbit (s1, vz);\n  power = uz + vz;\n\n  if (tu->_mp_size > 0)\n    {\n      mp_bitcnt_t shift;\n      shift = mpz_make_odd (tu);\n      mpz_mul_2exp (t0, t0, shift);\n      mpz_mul_2exp (s0, s0, shift);\n      power += shift;\n\n      for (;;)\n\t{\n\t  int c;\n\t  c = mpz_cmp (tu, tv);\n\t  if (c == 0)\n\t    break;\n\n\t  if (c < 0)\n\t    {\n\t      /* tv = tv' + tu\n\t       *\n\t       * u = t0 tu + t1 (tv' + tu) = (t0 + t1) tu + t1 tv'\n\t       * v = s0 tu + s1 (tv' + tu) = (s0 + s1) tu + s1 tv' */\n\n\t      mpz_sub (tv, tv, tu);\n\t      mpz_add (t0, t0, t1);\n\t      mpz_add (s0, s0, s1);\n\n\t      shift = mpz_make_odd (tv);\n\t      mpz_mul_2exp (t1, t1, shift);\n\t      mpz_mul_2exp (s1, s1, shift);\n\t    }\n\t  else\n\t    {\n\t      mpz_sub (tu, tu, tv);\n\t      mpz_add (t1, t0, t1);\n\t      mpz_add (s1, s0, s1);\n\n\t      shift = mpz_make_odd (tu);\n\t      mpz_mul_2exp (t0, t0, shift);\n\t      mpz_mul_2exp (s0, s0, shift);\n\t    }\n\t  power += shift;\n\t}\n    }\n\n  /* Now tv = odd part of gcd, and -s0 and t0 are corresponding\n     cofactors. */\n\n  mpz_mul_2exp (tv, tv, gz);\n  mpz_neg (s0, s0);\n\n  /* 2^p g = s0 u + t0 v. Eliminate one factor of two at a time. To\n     adjust cofactors, we need u / g and v / g */\n\n  mpz_divexact (s1, v, tv);\n  mpz_abs (s1, s1);\n  mpz_divexact (t1, u, tv);\n  mpz_abs (t1, t1);\n\n  while (power-- > 0)\n    {\n      /* s0 u + t0 v = (s0 - v/g) u - (t0 + u/g) v */\n      if (mpz_odd_p (s0) || mpz_odd_p (t0))\n\t{\n\t  mpz_sub (s0, s0, s1);\n\t  mpz_add (t0, t0, t1);\n\t}\n      mpz_divexact_ui (s0, s0, 2);\n      mpz_divexact_ui (t0, t0, 2);\n    }\n\n  /* Arrange so that |s| < |u| / 2g */\n  mpz_add (s1, s0, s1);\n  if (mpz_cmpabs (s0, s1) > 0)\n    {\n      mpz_swap (s0, s1);\n      mpz_sub (t0, t0, t1);\n    }\n  if (u->_mp_size < 0)\n    mpz_neg (s0, s0);\n  if (v->_mp_size < 0)\n    mpz_neg (t0, t0);\n\n  mpz_swap (g, tv);\n  if (s)\n    mpz_swap (s, s0);\n  if (t)\n    mpz_swap (t, t0);\n\n  mpz_clear (tu);\n  mpz_clear (tv);\n  mpz_clear (s0);\n  mpz_clear (s1);\n  mpz_clear (t0);\n  mpz_clear (t1);\n}",
      "lines": 181,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_lcm": {
      "start_point": [
        3010,
        0
      ],
      "end_point": [
        3029,
        1
      ],
      "content": "void\nmpz_lcm (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mpz_t g;\n\n  if (u->_mp_size == 0 || v->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  mpz_init (g);\n\n  mpz_gcd (g, u, v);\n  mpz_divexact (g, u, g);\n  mpz_mul (r, g, v);\n\n  mpz_clear (g);\n  mpz_abs (r, r);\n}",
      "lines": 20,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_lcm_ui": {
      "start_point": [
        3031,
        0
      ],
      "end_point": [
        3044,
        1
      ],
      "content": "void\nmpz_lcm_ui (mpz_t r, const mpz_t u, unsigned long v)\n{\n  if (v == 0 || u->_mp_size == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  v /= mpz_gcd_ui (NULL, u, v);\n  mpz_mul_ui (r, u, v);\n\n  mpz_abs (r, r);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "mpz_invert": {
      "start_point": [
        3046,
        0
      ],
      "end_point": [
        3076,
        1
      ],
      "content": "int\nmpz_invert (mpz_t r, const mpz_t u, const mpz_t m)\n{\n  mpz_t g, tr;\n  int invertible;\n\n  if (u->_mp_size == 0 || mpz_cmpabs_ui (m, 1) <= 0)\n    return 0;\n\n  mpz_init (g);\n  mpz_init (tr);\n\n  mpz_gcdext (g, tr, NULL, u, m);\n  invertible = (mpz_cmp_ui (g, 1) == 0);\n\n  if (invertible)\n    {\n      if (tr->_mp_size < 0)\n\t{\n\t  if (m->_mp_size >= 0)\n\t    mpz_add (tr, tr, m);\n\t  else\n\t    mpz_sub (tr, tr, m);\n\t}\n      mpz_swap (r, tr);\n    }\n\n  mpz_clear (g);\n  mpz_clear (tr);\n  return invertible;\n}",
      "lines": 31,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "mpz_pow_ui": {
      "start_point": [
        3081,
        0
      ],
      "end_point": [
        3100,
        1
      ],
      "content": "void\nmpz_pow_ui (mpz_t r, const mpz_t b, unsigned long e)\n{\n  unsigned long bit;\n  mpz_t tr;\n  mpz_init_set_ui (tr, 1);\n\n  bit = GMP_ULONG_HIGHBIT;\n  do\n    {\n      mpz_mul (tr, tr, tr);\n      if (e & bit)\n\tmpz_mul (tr, tr, b);\n      bit >>= 1;\n    }\n  while (bit > 0);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_ui_pow_ui": {
      "start_point": [
        3102,
        0
      ],
      "end_point": [
        3107,
        1
      ],
      "content": "void\nmpz_ui_pow_ui (mpz_t r, unsigned long blimb, unsigned long e)\n{\n  mpz_t b;\n  mpz_pow_ui (r, mpz_roinit_n (b, &blimb, 1), e);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_powm": {
      "start_point": [
        3109,
        0
      ],
      "end_point": [
        3212,
        1
      ],
      "content": "void\nmpz_powm (mpz_t r, const mpz_t b, const mpz_t e, const mpz_t m)\n{\n  mpz_t tr;\n  mpz_t base;\n  mp_size_t en, mn;\n  mp_srcptr mp;\n  struct gmp_div_inverse minv;\n  unsigned shift;\n  mp_ptr tp = NULL;\n\n  en = GMP_ABS (e->_mp_size);\n  mn = GMP_ABS (m->_mp_size);\n  if (mn == 0)\n    gmp_die (\"mpz_powm: Zero modulo.\");\n\n  if (en == 0)\n    {\n      mpz_set_ui (r, 1);\n      return;\n    }\n\n  mp = m->_mp_d;\n  mpn_div_qr_invert (&minv, mp, mn);\n  shift = minv.shift;\n\n  if (shift > 0)\n    {\n      /* To avoid shifts, we do all our reductions, except the final\n\t one, using a *normalized* m. */\n      minv.shift = 0;\n\n      tp = gmp_xalloc_limbs (mn);\n      gmp_assert_nocarry (mpn_lshift (tp, mp, mn, shift));\n      mp = tp;\n    }\n\n  mpz_init (base);\n\n  if (e->_mp_size < 0)\n    {\n      if (!mpz_invert (base, b, m))\n\tgmp_die (\"mpz_powm: Negative exponent and non-invertible base.\");\n    }\n  else\n    {\n      mp_size_t bn;\n      mpz_abs (base, b);\n\n      bn = base->_mp_size;\n      if (bn >= mn)\n\t{\n\t  mpn_div_qr_preinv (NULL, base->_mp_d, base->_mp_size, mp, mn, &minv);\n\t  bn = mn;\n\t}\n\n      /* We have reduced the absolute value. Now take care of the\n\t sign. Note that we get zero represented non-canonically as\n\t m. */\n      if (b->_mp_size < 0)\n\t{\n\t  mp_ptr bp = MPZ_REALLOC (base, mn);\n\t  gmp_assert_nocarry (mpn_sub (bp, mp, mn, bp, bn));\n\t  bn = mn;\n\t}\n      base->_mp_size = mpn_normalized_size (base->_mp_d, bn);\n    }\n  mpz_init_set_ui (tr, 1);\n\n  while (--en >= 0)\n    {\n      mp_limb_t w = e->_mp_d[en];\n      mp_limb_t bit;\n\n      bit = GMP_LIMB_HIGHBIT;\n      do\n\t{\n\t  mpz_mul (tr, tr, tr);\n\t  if (w & bit)\n\t    mpz_mul (tr, tr, base);\n\t  if (tr->_mp_size > mn)\n\t    {\n\t      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n\t      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n\t    }\n\t  bit >>= 1;\n\t}\n      while (bit > 0);\n    }\n\n  /* Final reduction */\n  if (tr->_mp_size >= mn)\n    {\n      minv.shift = shift;\n      mpn_div_qr_preinv (NULL, tr->_mp_d, tr->_mp_size, mp, mn, &minv);\n      tr->_mp_size = mpn_normalized_size (tr->_mp_d, mn);\n    }\n  if (tp)\n    gmp_free (tp);\n\n  mpz_swap (r, tr);\n  mpz_clear (tr);\n  mpz_clear (base);\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "mpz_powm_ui": {
      "start_point": [
        3214,
        0
      ],
      "end_point": [
        3219,
        1
      ],
      "content": "void\nmpz_powm_ui (mpz_t r, const mpz_t b, unsigned long elimb, const mpz_t m)\n{\n  mpz_t e;\n  mpz_powm (r, b, mpz_roinit_n (e, &elimb, 1), m);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_rootrem": {
      "start_point": [
        3222,
        0
      ],
      "end_point": [
        3280,
        1
      ],
      "content": "void\nmpz_rootrem (mpz_t x, mpz_t r, const mpz_t y, unsigned long z)\n{\n  int sgn;\n  mpz_t t, u;\n\n  sgn = y->_mp_size < 0;\n  if ((~z & sgn) != 0)\n    gmp_die (\"mpz_rootrem: Negative argument, with even root.\");\n  if (z == 0)\n    gmp_die (\"mpz_rootrem: Zeroth root.\");\n\n  if (mpz_cmpabs_ui (y, 1) <= 0) {\n    if (x)\n      mpz_set (x, y);\n    if (r)\n      r->_mp_size = 0;\n    return;\n  }\n\n  mpz_init (u);\n  mpz_init (t);\n  mpz_setbit (t, mpz_sizeinbase (y, 2) / z + 1);\n\n  if (z == 2) /* simplify sqrt loop: z-1 == 1 */\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_tdiv_q (t, y, u);\t\t/* t = y/x */\n      mpz_add (t, t, u);\t\t/* t = y/x + x */\n      mpz_tdiv_q_2exp (t, t, 1);\t/* x'= (y/x + x)/2 */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n  else /* z != 2 */ {\n    mpz_t v;\n\n    mpz_init (v);\n    if (sgn)\n      mpz_neg (t, t);\n\n    do {\n      mpz_swap (u, t);\t\t\t/* u = x */\n      mpz_pow_ui (t, u, z - 1);\t\t/* t = x^(z-1) */\n      mpz_tdiv_q (t, y, t);\t\t/* t = y/x^(z-1) */\n      mpz_mul_ui (v, u, z - 1);\t\t/* v = x*(z-1) */\n      mpz_add (t, t, v);\t\t/* t = y/x^(z-1) + x*(z-1) */\n      mpz_tdiv_q_ui (t, t, z);\t\t/* x'=(y/x^(z-1) + x*(z-1))/z */\n    } while (mpz_cmpabs (t, u) < 0);\t/* |x'| < |x| */\n\n    mpz_clear (v);\n  }\n\n  if (r) {\n    mpz_pow_ui (t, u, z);\n    mpz_sub (r, y, t);\n  }\n  if (x)\n    mpz_swap (x, u);\n  mpz_clear (u);\n  mpz_clear (t);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpz_root": {
      "start_point": [
        3282,
        0
      ],
      "end_point": [
        3294,
        1
      ],
      "content": "int\nmpz_root (mpz_t x, const mpz_t y, unsigned long z)\n{\n  int res;\n  mpz_t r;\n\n  mpz_init (r);\n  mpz_rootrem (x, r, y, z);\n  res = r->_mp_size == 0;\n  mpz_clear (r);\n\n  return res;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "mpz_sqrtrem": {
      "start_point": [
        3297,
        0
      ],
      "end_point": [
        3301,
        1
      ],
      "content": "void\nmpz_sqrtrem (mpz_t s, mpz_t r, const mpz_t u)\n{\n  mpz_rootrem (s, r, u, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_sqrt": {
      "start_point": [
        3303,
        0
      ],
      "end_point": [
        3307,
        1
      ],
      "content": "void\nmpz_sqrt (mpz_t s, const mpz_t u)\n{\n  mpz_rootrem (s, NULL, u, 2);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_perfect_square_p": {
      "start_point": [
        3309,
        0
      ],
      "end_point": [
        3316,
        1
      ],
      "content": "int\nmpz_perfect_square_p (const mpz_t u)\n{\n  if (u->_mp_size <= 0)\n    return (u->_mp_size == 0);\n  else\n    return mpz_root (NULL, u, 2);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "mpn_perfect_square_p": {
      "start_point": [
        3318,
        0
      ],
      "end_point": [
        3326,
        1
      ],
      "content": "int\nmpn_perfect_square_p (mp_srcptr p, mp_size_t n)\n{\n  mpz_t t;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n  return mpz_root (NULL, mpz_roinit_n (t, p, n), 2);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpn_sqrtrem": {
      "start_point": [
        3328,
        0
      ],
      "end_point": [
        3349,
        1
      ],
      "content": "mp_size_t\nmpn_sqrtrem (mp_ptr sp, mp_ptr rp, mp_srcptr p, mp_size_t n)\n{\n  mpz_t s, r, u;\n  mp_size_t res;\n\n  assert (n > 0);\n  assert (p [n-1] != 0);\n\n  mpz_init (r);\n  mpz_init (s);\n  mpz_rootrem (s, r, mpz_roinit_n (u, p, n), 2);\n\n  assert (s->_mp_size == (n+1)/2);\n  mpn_copyd (sp, s->_mp_d, s->_mp_size);\n  mpz_clear (s);\n  res = r->_mp_size;\n  if (rp)\n    mpn_copyd (rp, r->_mp_d, res);\n  mpz_clear (r);\n  return res;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "mpz_fac_ui": {
      "start_point": [
        3353,
        0
      ],
      "end_point": [
        3359,
        1
      ],
      "content": "void\nmpz_fac_ui (mpz_t x, unsigned long n)\n{\n  mpz_set_ui (x, n + (n == 0));\n  while (n > 2)\n    mpz_mul_ui (x, x, --n);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_bin_uiui": {
      "start_point": [
        3361,
        0
      ],
      "end_point": [
        3379,
        1
      ],
      "content": "void\nmpz_bin_uiui (mpz_t r, unsigned long n, unsigned long k)\n{\n  mpz_t t;\n\n  mpz_set_ui (r, k <= n);\n\n  if (k > (n >> 1))\n    k = (k <= n) ? n - k : 0;\n\n  mpz_init (t);\n  mpz_fac_ui (t, k);\n\n  for (; k > 0; k--)\n      mpz_mul_ui (r, r, n--);\n\n  mpz_divexact (r, r, t);\n  mpz_clear (t);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "gmp_millerrabin": {
      "start_point": [
        3383,
        0
      ],
      "end_point": [
        3407,
        1
      ],
      "content": "static int\ngmp_millerrabin (const mpz_t n, const mpz_t nm1, mpz_t y,\n\t\t const mpz_t q, mp_bitcnt_t k)\n{\n  assert (k > 0);\n\n  /* Caller must initialize y to the base. */\n  mpz_powm (y, y, q, n);\n\n  if (mpz_cmp_ui (y, 1) == 0 || mpz_cmp (y, nm1) == 0)\n    return 1;\n\n  while (--k > 0)\n    {\n      mpz_powm_ui (y, y, 2, n);\n      if (mpz_cmp (y, nm1) == 0)\n\treturn 1;\n      /* y == 1 means that the previous y was a non-trivial square root\n\t of 1 (mod n). y == 0 means that n is a power of the base.\n\t In either case, n is not prime. */\n      if (mpz_cmp_ui (y, 1) <= 0)\n\treturn 0;\n    }\n  return 0;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_probab_prime_p": {
      "start_point": [
        3416,
        0
      ],
      "end_point": [
        3475,
        1
      ],
      "content": "int\nmpz_probab_prime_p (const mpz_t n, int reps)\n{\n  mpz_t nm1;\n  mpz_t q;\n  mpz_t y;\n  mp_bitcnt_t k;\n  int is_prime;\n  int j;\n\n  /* Note that we use the absolute value of n only, for compatibility\n     with the real GMP. */\n  if (mpz_even_p (n))\n    return (mpz_cmpabs_ui (n, 2) == 0) ? 2 : 0;\n\n  /* Above test excludes n == 0 */\n  assert (n->_mp_size != 0);\n\n  if (mpz_cmpabs_ui (n, 64) < 0)\n    return (GMP_PRIME_MASK >> (n->_mp_d[0] >> 1)) & 2;\n\n  if (mpz_gcd_ui (NULL, n, GMP_PRIME_PRODUCT) != 1)\n    return 0;\n\n  /* All prime factors are >= 31. */\n  if (mpz_cmpabs_ui (n, 31*31) < 0)\n    return 2;\n\n  /* Use Miller-Rabin, with a deterministic sequence of bases, a[j] =\n     j^2 + j + 41 using Euler's polynomial. We potentially stop early,\n     if a[j] >= n - 1. Since n >= 31*31, this can happen only if reps >\n     30 (a[30] == 971 > 31*31 == 961). */\n\n  mpz_init (nm1);\n  mpz_init (q);\n  mpz_init (y);\n\n  /* Find q and k, where q is odd and n = 1 + 2**k * q.  */\n  nm1->_mp_size = mpz_abs_sub_ui (nm1, n, 1);\n  k = mpz_scan1 (nm1, 0);\n  mpz_tdiv_q_2exp (q, nm1, k);\n\n  for (j = 0, is_prime = 1; is_prime & (j < reps); j++)\n    {\n      mpz_set_ui (y, (unsigned long) j*j+j+41);\n      if (mpz_cmp (y, nm1) >= 0)\n\t{\n\t  /* Don't try any further bases. This \"early\" break does not affect\n\t     the result for any reasonable reps value (<=5000 was tested) */\n\t  assert (j >= 30);\n\t  break;\n\t}\n      is_prime = gmp_millerrabin (n, nm1, y, q, k);\n    }\n  mpz_clear (nm1);\n  mpz_clear (q);\n  mpz_clear (y);\n\n  return is_prime;\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "mpz_tstbit": {
      "start_point": [
        3502,
        0
      ],
      "end_point": [
        3533,
        1
      ],
      "content": "int\nmpz_tstbit (const mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t limb_index;\n  unsigned shift;\n  mp_size_t ds;\n  mp_size_t dn;\n  mp_limb_t w;\n  int bit;\n\n  ds = d->_mp_size;\n  dn = GMP_ABS (ds);\n  limb_index = bit_index / GMP_LIMB_BITS;\n  if (limb_index >= dn)\n    return ds < 0;\n\n  shift = bit_index % GMP_LIMB_BITS;\n  w = d->_mp_d[limb_index];\n  bit = (w >> shift) & 1;\n\n  if (ds < 0)\n    {\n      /* d < 0. Check if any of the bits below is set: If so, our bit\n\t must be complemented. */\n      if (shift > 0 && (w << (GMP_LIMB_BITS - shift)) > 0)\n\treturn bit ^ 1;\n      while (--limb_index >= 0)\n\tif (d->_mp_d[limb_index] > 0)\n\t  return bit ^ 1;\n    }\n  return bit;\n}",
      "lines": 32,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "mpz_abs_add_bit": {
      "start_point": [
        3535,
        0
      ],
      "end_point": [
        3574,
        1
      ],
      "content": "static void\nmpz_abs_add_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_limb_t bit;\n  mp_ptr dp;\n\n  dn = GMP_ABS (d->_mp_size);\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  if (limb_index >= dn)\n    {\n      mp_size_t i;\n      /* The bit should be set outside of the end of the number.\n\t We have to increase the size of the number. */\n      dp = MPZ_REALLOC (d, limb_index + 1);\n\n      dp[limb_index] = bit;\n      for (i = dn; i < limb_index; i++)\n\tdp[i] = 0;\n      dn = limb_index + 1;\n    }\n  else\n    {\n      mp_limb_t cy;\n\n      dp = d->_mp_d;\n\n      cy = mpn_add_1 (dp + limb_index, dp + limb_index, dn - limb_index, bit);\n      if (cy > 0)\n\t{\n\t  dp = MPZ_REALLOC (d, dn + 1);\n\t  dp[dn++] = cy;\n\t}\n    }\n\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}",
      "lines": 40,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_abs_sub_bit": {
      "start_point": [
        3576,
        0
      ],
      "end_point": [
        3595,
        1
      ],
      "content": "static void\nmpz_abs_sub_bit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  mp_size_t dn, limb_index;\n  mp_ptr dp;\n  mp_limb_t bit;\n\n  dn = GMP_ABS (d->_mp_size);\n  dp = d->_mp_d;\n\n  limb_index = bit_index / GMP_LIMB_BITS;\n  bit = (mp_limb_t) 1 << (bit_index % GMP_LIMB_BITS);\n\n  assert (limb_index < dn);\n\n  gmp_assert_nocarry (mpn_sub_1 (dp + limb_index, dp + limb_index,\n\t\t\t\t dn - limb_index, bit));\n  dn = mpn_normalized_size (dp, dn);\n  d->_mp_size = (d->_mp_size < 0) ? - dn : dn;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpz_setbit": {
      "start_point": [
        3597,
        0
      ],
      "end_point": [
        3607,
        1
      ],
      "content": "void\nmpz_setbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (!mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_add_bit (d, bit_index);\n      else\n\tmpz_abs_sub_bit (d, bit_index);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_clrbit": {
      "start_point": [
        3609,
        0
      ],
      "end_point": [
        3619,
        1
      ],
      "content": "void\nmpz_clrbit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index))\n    {\n      if (d->_mp_size >= 0)\n\tmpz_abs_sub_bit (d, bit_index);\n      else\n\tmpz_abs_add_bit (d, bit_index);\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_combit": {
      "start_point": [
        3621,
        0
      ],
      "end_point": [
        3628,
        1
      ],
      "content": "void\nmpz_combit (mpz_t d, mp_bitcnt_t bit_index)\n{\n  if (mpz_tstbit (d, bit_index) ^ (d->_mp_size < 0))\n    mpz_abs_sub_bit (d, bit_index);\n  else\n    mpz_abs_add_bit (d, bit_index);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "mpz_com": {
      "start_point": [
        3630,
        0
      ],
      "end_point": [
        3635,
        1
      ],
      "content": "void\nmpz_com (mpz_t r, const mpz_t u)\n{\n  mpz_neg (r, u);\n  mpz_sub_ui (r, r, 1);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_and": {
      "start_point": [
        3637,
        0
      ],
      "end_point": [
        3707,
        1
      ],
      "content": "void\nmpz_and (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      r->_mp_size = 0;\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc & vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  /* If the smaller input is positive, higher limbs don't matter. */\n  rn = vx ? un : vn;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul & vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul & vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}",
      "lines": 71,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_ior": {
      "start_point": [
        3709,
        0
      ],
      "end_point": [
        3780,
        1
      ],
      "content": "void\nmpz_ior (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, rn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc | vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  /* If the smaller input is negative, by sign extension higher limbs\n     don't matter. */\n  rn = vx ? vn : un;\n\n  rp = MPZ_REALLOC (r, rn + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = ( (ul | vl) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < rn; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = ( (ul | vx) ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[rn++] = rc;\n  else\n    rn = mpn_normalized_size (rp, rn);\n\n  r->_mp_size = rx ? -rn : rn;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "mpz_xor": {
      "start_point": [
        3782,
        0
      ],
      "end_point": [
        3849,
        1
      ],
      "content": "void\nmpz_xor (mpz_t r, const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_ptr up, vp, rp;\n\n  mp_limb_t ux, vx, rx;\n  mp_limb_t uc, vc, rc;\n  mp_limb_t ul, vl, rl;\n\n  un = GMP_ABS (u->_mp_size);\n  vn = GMP_ABS (v->_mp_size);\n  if (un < vn)\n    {\n      MPZ_SRCPTR_SWAP (u, v);\n      MP_SIZE_T_SWAP (un, vn);\n    }\n  if (vn == 0)\n    {\n      mpz_set (r, u);\n      return;\n    }\n\n  uc = u->_mp_size < 0;\n  vc = v->_mp_size < 0;\n  rc = uc ^ vc;\n\n  ux = -uc;\n  vx = -vc;\n  rx = -rc;\n\n  rp = MPZ_REALLOC (r, un + (mp_size_t) rc);\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  i = 0;\n  do\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ vx) + vc;\n      vc = vl < vc;\n\n      rl = (ul ^ vl ^ rx) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  while (++i < vn);\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ ux) + uc;\n      uc = ul < uc;\n\n      rl = (ul ^ ux) + rc;\n      rc = rl < rc;\n      rp[i] = rl;\n    }\n  if (rc)\n    rp[un++] = rc;\n  else\n    un = mpn_normalized_size (rp, un);\n\n  r->_mp_size = rx ? -un : un;\n}",
      "lines": 68,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "gmp_popcount_limb": {
      "start_point": [
        3851,
        0
      ],
      "end_point": [
        3866,
        1
      ],
      "content": "static unsigned\ngmp_popcount_limb (mp_limb_t x)\n{\n  unsigned c;\n\n  /* Do 16 bits at a time, to avoid limb-sized constants. */\n  for (c = 0; x > 0; x >>= 16)\n    {\n      unsigned w = ((x >> 1) & 0x5555) + (x & 0x5555);\n      w = ((w >> 2) & 0x3333) + (w & 0x3333);\n      w = ((w >> 4) & 0x0f0f) + (w & 0x0f0f);\n      w = (w >> 8) + (w & 0x00ff);\n      c += w;\n    }\n  return c;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "mpn_popcount": {
      "start_point": [
        3868,
        0
      ],
      "end_point": [
        3878,
        1
      ],
      "content": "mp_bitcnt_t\nmpn_popcount (mp_srcptr p, mp_size_t n)\n{\n  mp_size_t i;\n  mp_bitcnt_t c;\n\n  for (c = 0, i = 0; i < n; i++)\n    c += gmp_popcount_limb (p[i]);\n\n  return c;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_popcount": {
      "start_point": [
        3880,
        0
      ],
      "end_point": [
        3891,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_popcount (const mpz_t u)\n{\n  mp_size_t un;\n\n  un = u->_mp_size;\n\n  if (un < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  return mpn_popcount (u->_mp_d, un);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_hamdist": {
      "start_point": [
        3893,
        0
      ],
      "end_point": [
        3942,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_hamdist (const mpz_t u, const mpz_t v)\n{\n  mp_size_t un, vn, i;\n  mp_limb_t uc, vc, ul, vl, comp;\n  mp_srcptr up, vp;\n  mp_bitcnt_t c;\n\n  un = u->_mp_size;\n  vn = v->_mp_size;\n\n  if ( (un ^ vn) < 0)\n    return ~(mp_bitcnt_t) 0;\n\n  comp = - (uc = vc = (un < 0));\n  if (uc)\n    {\n      assert (vn < 0);\n      un = -un;\n      vn = -vn;\n    }\n\n  up = u->_mp_d;\n  vp = v->_mp_d;\n\n  if (un < vn)\n    MPN_SRCPTR_SWAP (up, un, vp, vn);\n\n  for (i = 0, c = 0; i < vn; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      vl = (vp[i] ^ comp) + vc;\n      vc = vl < vc;\n\n      c += gmp_popcount_limb (ul ^ vl);\n    }\n  assert (vc == 0);\n\n  for (; i < un; i++)\n    {\n      ul = (up[i] ^ comp) + uc;\n      uc = ul < uc;\n\n      c += gmp_popcount_limb (ul ^ comp);\n    }\n\n  return c;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_scan1": {
      "start_point": [
        3944,
        0
      ],
      "end_point": [
        3978,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan1 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n  /* Past the end there's no 1 bits for u>=0, or an immediate 1 bit\n     for u<0. Notice this test picks up any u==0 too. */\n  if (i >= un)\n    return (us >= 0 ? ~(mp_bitcnt_t) 0 : starting_bit);\n\n  up = u->_mp_d;\n  ux = 0;\n  limb = up[i];\n\n  if (starting_bit != 0)\n    {\n      if (us < 0)\n\t{\n\t  ux = mpn_zero_p (up, i);\n\t  limb = ~ limb + ux;\n\t  ux = - (mp_limb_t) (limb >= ux);\n\t}\n\n      /* Mask to 0 all bits before starting_bit, thus ignoring them. */\n      limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));\n    }\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}",
      "lines": 35,
      "depth": 13,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_scan0": {
      "start_point": [
        3980,
        0
      ],
      "end_point": [
        4007,
        1
      ],
      "content": "mp_bitcnt_t\nmpz_scan0 (const mpz_t u, mp_bitcnt_t starting_bit)\n{\n  mp_ptr up;\n  mp_size_t us, un, i;\n  mp_limb_t limb, ux;\n\n  us = u->_mp_size;\n  ux = - (mp_limb_t) (us >= 0);\n  un = GMP_ABS (us);\n  i = starting_bit / GMP_LIMB_BITS;\n\n  /* When past end, there's an immediate 0 bit for u>=0, or no 0 bits for\n     u<0.  Notice this test picks up all cases of u==0 too. */\n  if (i >= un)\n    return (ux ? starting_bit : ~(mp_bitcnt_t) 0);\n\n  up = u->_mp_d;\n  limb = up[i] ^ ux;\n\n  if (ux == 0)\n    limb -= mpn_zero_p (up, i); /* limb = ~(~limb + zero_p) */\n\n  /* Mask all bits before starting_bit, thus ignoring them. */\n  limb &= (GMP_LIMB_MAX << (starting_bit % GMP_LIMB_BITS));\n\n  return mpn_common_scan (limb, i, up, un, ux);\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "mp_bitcnt_t"
      ]
    },
    "mpz_sizeinbase": {
      "start_point": [
        4012,
        0
      ],
      "end_point": [
        4063,
        1
      ],
      "content": "size_t\nmpz_sizeinbase (const mpz_t u, int base)\n{\n  mp_size_t un;\n  mp_srcptr up;\n  mp_ptr tp;\n  mp_bitcnt_t bits;\n  struct gmp_div_inverse bi;\n  size_t ndigits;\n\n  assert (base >= 2);\n  assert (base <= 62);\n\n  un = GMP_ABS (u->_mp_size);\n  if (un == 0)\n    return 1;\n\n  up = u->_mp_d;\n\n  bits = (un - 1) * GMP_LIMB_BITS + mpn_limb_size_in_base_2 (up[un-1]);\n  switch (base)\n    {\n    case 2:\n      return bits;\n    case 4:\n      return (bits + 1) / 2;\n    case 8:\n      return (bits + 2) / 3;\n    case 16:\n      return (bits + 3) / 4;\n    case 32:\n      return (bits + 4) / 5;\n      /* FIXME: Do something more clever for the common case of base\n\t 10. */\n    }\n\n  tp = gmp_xalloc_limbs (un);\n  mpn_copyi (tp, up, un);\n  mpn_div_qr_1_invert (&bi, base);\n\n  ndigits = 0;\n  do\n    {\n      ndigits++;\n      mpn_div_qr_1_preinv (tp, tp, un, &bi);\n      un -= (tp[un-1] == 0);\n    }\n  while (un > 0);\n\n  gmp_free (tp);\n  return ndigits;\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "mpz_get_str": {
      "start_point": [
        4065,
        0
      ],
      "end_point": [
        4131,
        1
      ],
      "content": "char *\nmpz_get_str (char *sp, int base, const mpz_t u)\n{\n  unsigned bits;\n  const char *digits;\n  mp_size_t un;\n  size_t i, sn;\n\n  digits = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n  if (base > 1)\n    {\n      if (base <= 36)\n\tdigits = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n      else if (base > 62)\n\treturn NULL;\n    }\n  else if (base >= -1)\n    base = 10;\n  else\n    {\n      base = -base;\n      if (base > 36)\n\treturn NULL;\n    }\n\n  sn = 1 + mpz_sizeinbase (u, base);\n  if (!sp)\n    sp = (char *) gmp_xalloc (1 + sn);\n\n  un = GMP_ABS (u->_mp_size);\n\n  if (un == 0)\n    {\n      sp[0] = '0';\n      sp[1] = '\\0';\n      return sp;\n    }\n\n  i = 0;\n\n  if (u->_mp_size < 0)\n    sp[i++] = '-';\n\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits)\n    /* Not modified in this case. */\n    sn = i + mpn_get_str_bits ((unsigned char *) sp + i, bits, u->_mp_d, un);\n  else\n    {\n      struct mpn_base_info info;\n      mp_ptr tp;\n\n      mpn_get_base_info (&info, base);\n      tp = gmp_xalloc_limbs (un);\n      mpn_copyi (tp, u->_mp_d, un);\n\n      sn = i + mpn_get_str_other ((unsigned char *) sp + i, base, &info, tp, un);\n      gmp_free (tp);\n    }\n\n  for (; i < sn; i++)\n    sp[i] = digits[(unsigned char) sp[i]];\n\n  sp[sn] = '\\0';\n  return sp;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "char",
        "*\nmpz_get_str (char *sp, int base, const mpz_t u)",
        "*"
      ]
    },
    "mpz_set_str": {
      "start_point": [
        4133,
        0
      ],
      "end_point": [
        4236,
        1
      ],
      "content": "int\nmpz_set_str (mpz_t r, const char *sp, int base)\n{\n  unsigned bits, value_of_a;\n  mp_size_t rn, alloc;\n  mp_ptr rp;\n  size_t dn;\n  int sign;\n  unsigned char *dp;\n\n  assert (base == 0 || (base >= 2 && base <= 62));\n\n  while (isspace( (unsigned char) *sp))\n    sp++;\n\n  sign = (*sp == '-');\n  sp += sign;\n\n  if (base == 0)\n    {\n      if (sp[0] == '0')\n\t{\n\t  if (sp[1] == 'x' || sp[1] == 'X')\n\t    {\n\t      base = 16;\n\t      sp += 2;\n\t    }\n\t  else if (sp[1] == 'b' || sp[1] == 'B')\n\t    {\n\t      base = 2;\n\t      sp += 2;\n\t    }\n\t  else\n\t    base = 8;\n\t}\n      else\n\tbase = 10;\n    }\n\n  if (!*sp)\n    {\n      r->_mp_size = 0;\n      return -1;\n    }\n  dp = (unsigned char *) gmp_xalloc (strlen (sp));\n\n  value_of_a = (base > 36) ? 36 : 10;\n  for (dn = 0; *sp; sp++)\n    {\n      unsigned digit;\n\n      if (isspace ((unsigned char) *sp))\n\tcontinue;\n      else if (*sp >= '0' && *sp <= '9')\n\tdigit = *sp - '0';\n      else if (*sp >= 'a' && *sp <= 'z')\n\tdigit = *sp - 'a' + value_of_a;\n      else if (*sp >= 'A' && *sp <= 'Z')\n\tdigit = *sp - 'A' + 10;\n      else\n\tdigit = base; /* fail */\n\n      if (digit >= (unsigned) base)\n\t{\n\t  gmp_free (dp);\n\t  r->_mp_size = 0;\n\t  return -1;\n\t}\n\n      dp[dn++] = digit;\n    }\n\n  if (!dn)\n    {\n      gmp_free (dp);\n      r->_mp_size = 0;\n      return -1;\n    }\n  bits = mpn_base_power_of_two_p (base);\n\n  if (bits > 0)\n    {\n      alloc = (dn * bits + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_bits (rp, dp, dn, bits);\n    }\n  else\n    {\n      struct mpn_base_info info;\n      mpn_get_base_info (&info, base);\n      alloc = (dn + info.exp - 1) / info.exp;\n      rp = MPZ_REALLOC (r, alloc);\n      rn = mpn_set_str_other (rp, dp, dn, base, &info);\n      /* Normalization, needed for all-zero input. */\n      assert (rn > 0);\n      rn -= rp[rn-1] == 0;\n    }\n  assert (rn <= alloc);\n  gmp_free (dp);\n\n  r->_mp_size = sign ? - rn : rn;\n\n  return 0;\n}",
      "lines": 104,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "mpz_init_set_str": {
      "start_point": [
        4238,
        0
      ],
      "end_point": [
        4243,
        1
      ],
      "content": "int\nmpz_init_set_str (mpz_t r, const char *sp, int base)\n{\n  mpz_init (r);\n  return mpz_set_str (r, sp, base);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "mpz_out_str": {
      "start_point": [
        4245,
        0
      ],
      "end_point": [
        4256,
        1
      ],
      "content": "size_t\nmpz_out_str (FILE *stream, int base, const mpz_t x)\n{\n  char *str;\n  size_t len;\n\n  str = mpz_get_str (NULL, base, x);\n  len = strlen (str);\n  len = fwrite (str, 1, len, stream);\n  gmp_free (str);\n  return len;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    },
    "gmp_detect_endian": {
      "start_point": [
        4259,
        0
      ],
      "end_point": [
        4265,
        1
      ],
      "content": "static int\ngmp_detect_endian (void)\n{\n  static const int i = 2;\n  const unsigned char *p = (const unsigned char *) &i;\n  return 1 - *p;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "mpz_import": {
      "start_point": [
        4268,
        0
      ],
      "end_point": [
        4334,
        1
      ],
      "content": "void\nmpz_import (mpz_t r, size_t count, int order, size_t size, int endian,\n\t    size_t nails, const void *src)\n{\n  const unsigned char *p;\n  ptrdiff_t word_step;\n  mp_ptr rp;\n  mp_size_t rn;\n\n  /* The current (partial) limb. */\n  mp_limb_t limb;\n  /* The number of bytes already copied to this limb (starting from\n     the low end). */\n  size_t bytes;\n  /* The index where the limb should be stored, when completed. */\n  mp_size_t i;\n\n  if (nails != 0)\n    gmp_die (\"mpz_import: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n\n  if (endian == 0)\n    endian = gmp_detect_endian ();\n\n  p = (unsigned char *) src;\n\n  word_step = (order != endian) ? 2 * size : 0;\n\n  /* Process bytes from the least significant end, so point p at the\n     least significant word. */\n  if (order == 1)\n    {\n      p += size * (count - 1);\n      word_step = - word_step;\n    }\n\n  /* And at least significant byte of that word. */\n  if (endian == 1)\n    p += (size - 1);\n\n  rn = (size * count + sizeof(mp_limb_t) - 1) / sizeof(mp_limb_t);\n  rp = MPZ_REALLOC (r, rn);\n\n  for (limb = 0, bytes = 0, i = 0; count > 0; count--, p += word_step)\n    {\n      size_t j;\n      for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)\n\t{\n\t  limb |= (mp_limb_t) *p << (bytes++ * CHAR_BIT);\n\t  if (bytes == sizeof(mp_limb_t))\n\t    {\n\t      rp[i++] = limb;\n\t      bytes = 0;\n\t      limb = 0;\n\t    }\n\t}\n    }\n  assert (i + (bytes > 0) == rn);\n  if (limb != 0)\n    rp[i++] = limb;\n  else\n    i = mpn_normalized_size (rp, i);\n\n  r->_mp_size = i;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "mpz_export": {
      "start_point": [
        4336,
        0
      ],
      "end_point": [
        4423,
        1
      ],
      "content": "void *\nmpz_export (void *r, size_t *countp, int order, size_t size, int endian,\n\t    size_t nails, const mpz_t u)\n{\n  size_t count;\n  mp_size_t un;\n\n  if (nails != 0)\n    gmp_die (\"mpz_import: Nails not supported.\");\n\n  assert (order == 1 || order == -1);\n  assert (endian >= -1 && endian <= 1);\n  assert (size > 0 || u->_mp_size == 0);\n\n  un = u->_mp_size;\n  count = 0;\n  if (un != 0)\n    {\n      size_t k;\n      unsigned char *p;\n      ptrdiff_t word_step;\n      /* The current (partial) limb. */\n      mp_limb_t limb;\n      /* The number of bytes left to to in this limb. */\n      size_t bytes;\n      /* The index where the limb was read. */\n      mp_size_t i;\n\n      un = GMP_ABS (un);\n\n      /* Count bytes in top limb. */\n      limb = u->_mp_d[un-1];\n      assert (limb != 0);\n\n      k = 0;\n      do {\n\tk++; limb >>= CHAR_BIT;\n      } while (limb != 0);\n\n      count = (k + (un-1) * sizeof (mp_limb_t) + size - 1) / size;\n\n      if (!r)\n\tr = gmp_xalloc (count * size);\n\n      if (endian == 0)\n\tendian = gmp_detect_endian ();\n\n      p = (unsigned char *) r;\n\n      word_step = (order != endian) ? 2 * size : 0;\n\n      /* Process bytes from the least significant end, so point p at the\n\t least significant word. */\n      if (order == 1)\n\t{\n\t  p += size * (count - 1);\n\t  word_step = - word_step;\n\t}\n\n      /* And at least significant byte of that word. */\n      if (endian == 1)\n\tp += (size - 1);\n\n      for (bytes = 0, i = 0, k = 0; k < count; k++, p += word_step)\n\t{\n\t  size_t j;\n\t  for (j = 0; j < size; j++, p -= (ptrdiff_t) endian)\n\t    {\n\t      if (bytes == 0)\n\t\t{\n\t\t  if (i < un)\n\t\t    limb = u->_mp_d[i++];\n\t\t  bytes = sizeof (mp_limb_t);\n\t\t}\n\t      *p = limb;\n\t      limb >>= CHAR_BIT;\n\t      bytes--;\n\t    }\n\t}\n      assert (i == un);\n      assert (k == count);\n    }\n\n  if (countp)\n    *countp = count;\n\n  return r;\n}",
      "lines": 88,
      "depth": 16,
      "decorators": [
        "void",
        "*\nmpz_export (void *r, size_t *countp, int order, size_t size, int endian,\n\t    size_t nails, const mpz_t u)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/mini-gmp.h": {},
  "nettle/nettle-3.4.1/nettle-internal.c": {
    "des_set_key_wrapper": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "static void\ndes_set_key_wrapper (void *ctx, const uint8_t *key)\n{\n  des_set_key (ctx, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "des3_set_key_wrapper": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void\ndes3_set_key_wrapper (void *ctx, const uint8_t *key)\n{\n  des3_set_key (ctx, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "blowfish128_set_key_wrapper": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nblowfish128_set_key_wrapper (void *ctx, const uint8_t *key)\n{\n  blowfish128_set_key (ctx, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-internal.h": {},
  "nettle/nettle-3.4.1/nettle-lookup-hash.c": {
    "nettle_lookup_hash": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "const struct nettle_hash *\nnettle_lookup_hash (const char *name)\n{\n  unsigned i;\n  for (i = 0; nettle_hashes[i]; i++)\n    if (!strcmp (name, nettle_hashes[i]->name))\n      return nettle_hashes[i];\n  return NULL;\n}",
      "lines": 9,
      "depth": 11,
      "decorators": [
        "const",
        "const",
        "struct nettle_hash",
        "struct",
        "nettle_hash",
        "*\nnettle_lookup_hash (const char *name)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-meta-aeads.c": {
    "nettle_get_aeads": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "const struct nettle_aead * const *\nnettle_get_aeads (void)\n{\n  return nettle_aeads;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "struct nettle_aead",
        "struct",
        "nettle_aead",
        "* const *\nnettle_get_aeads (void)",
        "*",
        "const",
        "const",
        "*\nnettle_get_aeads (void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-meta-armors.c": {
    "nettle_get_armors": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "const struct nettle_armor * const *\nnettle_get_armors (void)\n{\n  return nettle_armors;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "struct nettle_armor",
        "struct",
        "nettle_armor",
        "* const *\nnettle_get_armors (void)",
        "*",
        "const",
        "const",
        "*\nnettle_get_armors (void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-meta-ciphers.c": {
    "nettle_get_ciphers": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        65,
        1
      ],
      "content": "const struct nettle_cipher * const *\nnettle_get_ciphers (void)\n{\n  return nettle_ciphers;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "struct nettle_cipher",
        "struct",
        "nettle_cipher",
        "* const *\nnettle_get_ciphers (void)",
        "*",
        "const",
        "const",
        "*\nnettle_get_ciphers (void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-meta-hashes.c": {
    "nettle_get_hashes": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "const struct nettle_hash * const *\nnettle_get_hashes (void)\n{\n  return nettle_hashes;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "const",
        "const",
        "struct nettle_hash",
        "struct",
        "nettle_hash",
        "* const *\nnettle_get_hashes (void)",
        "*",
        "const",
        "const",
        "*\nnettle_get_hashes (void)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/nettle-meta.h": {},
  "nettle/nettle-3.4.1/nettle-types.h": {},
  "nettle/nettle-3.4.1/nettle-write.h": {},
  "nettle/nettle-3.4.1/pbkdf2-hmac-sha1.c": {
    "pbkdf2_hmac_sha1": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\npbkdf2_hmac_sha1 (size_t key_length, const uint8_t *key,\n\t\t  unsigned iterations,\n\t\t  size_t salt_length, const uint8_t *salt,\n\t\t  size_t length, uint8_t *dst)\n{\n  struct hmac_sha1_ctx sha1ctx;\n\n  hmac_sha1_set_key (&sha1ctx, key_length, key);\n  PBKDF2 (&sha1ctx, hmac_sha1_update, hmac_sha1_digest,\n\t  SHA1_DIGEST_SIZE, iterations, salt_length, salt, length, dst);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/pbkdf2-hmac-sha256.c": {
    "pbkdf2_hmac_sha256": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\npbkdf2_hmac_sha256 (size_t key_length, const uint8_t *key,\n\t\t    unsigned iterations,\n\t\t    size_t salt_length, const uint8_t *salt,\n\t\t    size_t length, uint8_t *dst)\n{\n  struct hmac_sha256_ctx sha256ctx;\n\n  hmac_sha256_set_key (&sha256ctx, key_length, key);\n  PBKDF2 (&sha256ctx, hmac_sha256_update, hmac_sha256_digest,\n\t  SHA256_DIGEST_SIZE, iterations, salt_length, salt, length, dst);\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/pbkdf2.c": {
    "pbkdf2": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\npbkdf2 (void *mac_ctx,\n\tnettle_hash_update_func *update,\n\tnettle_hash_digest_func *digest,\n\tsize_t digest_size, unsigned iterations,\n\tsize_t salt_length, const uint8_t *salt,\n\tsize_t length, uint8_t *dst)\n{\n  TMP_DECL(U, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  TMP_DECL(T, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  \n  unsigned i;\n\n  assert (iterations > 0);\n\n  if (length == 0)\n    return;\n\n  TMP_ALLOC (U, digest_size);\n  TMP_ALLOC (T, digest_size);\n\n  for (i = 1;;\n       i++, dst += digest_size, length -= digest_size)\n    {\n      uint8_t tmp[4];\n      uint8_t *prev;\n      unsigned u;\n      \n      WRITE_UINT32 (tmp, i);\n      \n      update (mac_ctx, salt_length, salt);\n      update (mac_ctx, sizeof(tmp), tmp);\n      digest (mac_ctx, digest_size, T);\n\n      prev = T;\n      \n      for (u = 1; u < iterations; u++, prev = U)\n\t{\n\t  update (mac_ctx, digest_size, prev);\n\t  digest (mac_ctx, digest_size, U);\n\n\t  memxor (T, U, digest_size);\n\t}\n\n      if (length <= digest_size)\n\t{\n\t  memcpy (dst, T, length);\n\t  return;\n\t}\n      memcpy (dst, T, digest_size);\n    }\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/pbkdf2.h": {},
  "nettle/nettle-3.4.1/pgp-encode.c": {
    "pgp_put_uint32": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\npgp_put_uint32(struct nettle_buffer *buffer, uint32_t i)\n{\n  uint8_t *p = nettle_buffer_space(buffer, 4);\n  if (!p)\n    return 0;\n  \n  WRITE_UINT32(p, i);\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_uint16": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "int\npgp_put_uint16(struct nettle_buffer *buffer, unsigned i)\n{\n  uint8_t *p = nettle_buffer_space(buffer, 2);\n  if (!p)\n    return 0;\n  \n  WRITE_UINT16(p, i);\n  return 1;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_mpi": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\npgp_put_mpi(struct nettle_buffer *buffer, const mpz_t x)\n{\n  unsigned bits = mpz_sizeinbase(x, 2);\n  unsigned octets = (bits + 7) / 8;\n\n  uint8_t *p;\n\n  /* FIXME: What's the correct representation of zero? */\n  if (!pgp_put_uint16(buffer, bits))\n    return 0;\n  \n  p = nettle_buffer_space(buffer, octets);\n\n  if (!p)\n    return 0;\n  \n  nettle_mpz_get_str_256(octets, p, x);\n\n  return 1;\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_string": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "int\npgp_put_string(struct nettle_buffer *buffer,\n\t       unsigned length,\n\t       const uint8_t *s)\n{\n  return nettle_buffer_write(buffer, length, s);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "length_field": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static unsigned\nlength_field(unsigned length)\n{\n  if (length < PGP_LENGTH_TWO_OCTET)\n    return 1;\n  else if (length < PGP_LENGTH_FOUR_OCTETS)\n    return 2;\n  else return 4;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "pgp_put_length": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "int\npgp_put_length(struct nettle_buffer *buffer,\n\t       unsigned length)\n{\n  if (length < PGP_LENGTH_TWO_OCTETS)\n    return NETTLE_BUFFER_PUTC(buffer, length);\n\n  else if (length < PGP_LENGTH_FOUR_OCTETS)\n    return pgp_put_uint16(buffer, length + LENGTH_TWO_OFFSET);\n  else\n    return NETTLE_BUFFER_PUTC(buffer, 0xff) && pgp_put_uint32(buffer, length);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_header": {
      "start_point": [
        132,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "int\npgp_put_header(struct nettle_buffer *buffer,\n\t       unsigned tag, unsigned length)\n{\n  assert(tag < 0x40);\n\n  return (NETTLE_BUFFER_PUTC(buffer, 0xC0 | tag)\n\t  && pgp_put_length(buffer, length));  \n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_header_length": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\npgp_put_header_length(struct nettle_buffer *buffer,\n\t\t      /* start of the header */\n\t\t      unsigned start,\n\t\t      unsigned field_size)\n{\n  unsigned length;\n  switch (field_size)\n    {\n    case 1:\n      length = buffer->size - (start + 2);\n      assert(length < PGP_LENGTH_TWO_OCTETS);\n      buffer->contents[start + 1] = length;\n      break;\n    case 2:\n      length = buffer->size - (start + 3);\n      assert(length < PGP_LENGTH_FOUR_OCTETS\n\t     && length >= PGP_LENGTH_TWO_OCTETS);\n      WRITE_UINT16(buffer->contents + start + 1, length + LENGTH_TWO_OFFSET);\n      break;\n    case 4:\n      length = buffer->size - (start + 5);\n      WRITE_UINT32(buffer->contents + start + 2, length);\n      break;\n    default:\n      abort();\n    }\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "pgp_put_userid": {
      "start_point": [
        173,
        0
      ],
      "end_point": [
        180,
        1
      ],
      "content": "int\npgp_put_userid(struct nettle_buffer *buffer,\n\t       unsigned length,\n\t       const uint8_t *name)\n{\n  return (pgp_put_header(buffer, PGP_TAG_USERID, length)\n\t  && pgp_put_string(buffer, length, name));\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "pgp_sub_packet_start": {
      "start_point": [
        182,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "unsigned\npgp_sub_packet_start(struct nettle_buffer *buffer)\n{\n  return nettle_buffer_space(buffer, 2) ? buffer->size : 0;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "pgp_put_sub_packet": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\npgp_put_sub_packet(struct nettle_buffer *buffer,\n\t\t   unsigned type,\n\t\t   unsigned length,\n\t\t   const uint8_t *data)\n{\n  return (pgp_put_length(buffer, length + 1)\n\t  && NETTLE_BUFFER_PUTC(buffer, type)\n\t  && pgp_put_string(buffer, length, data));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "pgp_sub_packet_end": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        209,
        1
      ],
      "content": "void\npgp_sub_packet_end(struct nettle_buffer *buffer, unsigned start)\n{\n  unsigned length;\n  \n  assert(start >= 2);\n  assert(start <= buffer->size);\n\n  length = buffer->size - start;\n  WRITE_UINT32(buffer->contents + start - 2, length);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "pgp_put_public_rsa_key": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        243,
        1
      ],
      "content": "int\npgp_put_public_rsa_key(struct nettle_buffer *buffer,\n\t\t       const struct rsa_public_key *pub,\n\t\t       time_t timestamp)\n{\n  /* Public key packet, version 4 */\n  unsigned start;\n  unsigned length;\n\n  /* Size of packet is 16 + the size of e and n */\n  length = (4 * 4\n\t  + nettle_mpz_sizeinbase_256_u(pub->n)\n\t  + nettle_mpz_sizeinbase_256_u(pub->e));\n\n  if (!pgp_put_header(buffer, PGP_TAG_PUBLIC_KEY, length))\n    return 0;\n\n  start = buffer->size;\n  \n  if (! (pgp_put_header(buffer, PGP_TAG_PUBLIC_KEY,\n\t\t\t/* Assume that we need two octets */\n\t\t\tPGP_LENGTH_TWO_OCTETS)\n\t && pgp_put_uint32(buffer, 4)        /* Version */  \n\t && pgp_put_uint32(buffer, timestamp)/* Time stamp */\n\t && pgp_put_uint32(buffer, PGP_RSA)  /* Algorithm */\n\t && pgp_put_mpi(buffer, pub->n)\n\t && pgp_put_mpi(buffer, pub->e)) )\n    return 0;\n\n  assert(buffer->size == start + length);\n\n  return 1;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "pgp_put_rsa_sha1_signature": {
      "start_point": [
        245,
        0
      ],
      "end_point": [
        314,
        1
      ],
      "content": "int\npgp_put_rsa_sha1_signature(struct nettle_buffer *buffer,\n\t\t\t   const struct rsa_private_key *key,\n\t\t\t   const uint8_t *keyid,\n\t\t\t   unsigned type,\n\t\t\t   struct sha1_ctx *hash)\n{\n  unsigned signature_start = buffer->size;\n  unsigned hash_end;\n  unsigned sub_packet_start;\n  uint8_t trailer[6];\n  mpz_t s;\n  \n  /* Signature packet. The packet could reasonably be both smaller and\n   * larger than 192, so for simplicity we use the 4 octet header\n   * form. */\n\n  if (! (pgp_put_header(buffer, PGP_TAG_SIGNATURE, PGP_LENGTH_FOUR_OCTETS)\n\t && NETTLE_BUFFER_PUTC(buffer, 4)  /* Version */\n\t && NETTLE_BUFFER_PUTC(buffer, type)\n\t /* Could also be PGP_RSA_SIGN */\n\t && NETTLE_BUFFER_PUTC(buffer, PGP_RSA)\n\t && NETTLE_BUFFER_PUTC(buffer, PGP_SHA1)\n\t && pgp_put_uint16(buffer, 0)))  /* Hashed subpacket length */\n    return 0;\n\n  hash_end = buffer->size;\n\n  sha1_update(hash,\n\t      hash_end - signature_start,\n\t      buffer->contents + signature_start);\n\n  trailer[0] = 4; trailer[1] = 0xff;\n  WRITE_UINT32(trailer + 2, buffer->size - signature_start);\n\n  sha1_update(hash, sizeof(trailer), trailer);\n\n  {\n    struct sha1_ctx hcopy = *hash;\n    uint8_t *p = nettle_buffer_space(buffer, 2);\n    if (!p)\n      return 0;\n    \n    sha1_digest(&hcopy, 2, p);\n  }\n\n  /* One \"sub-packet\" field with the issuer keyid */\n  sub_packet_start = pgp_sub_packet_start(buffer);\n  if (!sub_packet_start)\n    return 0;\n\n  if (pgp_put_sub_packet(buffer, PGP_SUBPACKET_ISSUER_KEY_ID, 8, keyid))\n    {\n      pgp_sub_packet_end(buffer, sub_packet_start);\n      return 0;\n    }\n    \n  mpz_init(s);\n  if (!(rsa_sha1_sign(key, hash, s)\n\t&& pgp_put_mpi(buffer, s)))\n    {\n      mpz_clear(s);\n      return 0;\n    }\n\n  mpz_clear(s);\n  pgp_put_header_length(buffer, signature_start, 4);\n\n  return 1;\n}",
      "lines": 70,
      "depth": 14,
      "decorators": [
        "int"
      ]
    },
    "pgp_crc24": {
      "start_point": [
        319,
        0
      ],
      "end_point": [
        338,
        1
      ],
      "content": "uint32_t\npgp_crc24(unsigned length, const uint8_t *data)\n{\n  uint32_t crc = CRC24_INIT;\n\n  unsigned i;\n  for (i = 0; i<length; i++)\n    {\n      unsigned j;\n      crc ^= ((unsigned) (data[i]) << 16);\n      for (j = 0; j<8; j++)\n\t{\n\t  crc <<= 1;\n\t  if (crc & 0x1000000)\n\t    crc ^= CRC24_POLY;\n\t}\n    }\n  assert(crc < 0x1000000);\n  return crc;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "uint32_t"
      ]
    },
    "write_string": {
      "start_point": [
        341,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static int\nwrite_string (struct nettle_buffer *buffer, const char *s)\n{\n  return nettle_buffer_write(buffer, strlen((s)), (const uint8_t *) (s));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "pgp_armor": {
      "start_point": [
        351,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "int\npgp_armor(struct nettle_buffer *buffer,\n\t  const char *tag,\n\t  unsigned length,\n\t  const uint8_t *data)\n{\n  struct base64_encode_ctx ctx;\n  \n  unsigned crc = pgp_crc24(length, data);\n\n  base64_encode_init(&ctx);\n  \n  if (! (write_string(buffer, \"BEGIN PGP \")\n\t && write_string(buffer, tag)\n\t && write_string(buffer, \"\\nComment: Nettle\\n\\n\")))\n    return 0;\n\n  for (;\n       length >= BINARY_PER_LINE;\n       length -= BINARY_PER_LINE, data += BINARY_PER_LINE)\n    {\n      unsigned done;\n      char *p\n\t= (char *) nettle_buffer_space(buffer, TEXT_PER_LINE);\n      \n      if (!p)\n\treturn 0;\n\n      done = base64_encode_update(&ctx, p, BINARY_PER_LINE, data);\n      assert(done <= TEXT_PER_LINE);\n\n      /* FIXME: Create some official way to do this */\n      buffer->size -= (TEXT_PER_LINE - done);\n      \n      if (!NETTLE_BUFFER_PUTC(buffer, '\\n'))\n\treturn 0;\n    }\n\n  if (length)\n    {\n      unsigned text_size = BASE64_ENCODE_LENGTH(length)\n\t+ BASE64_ENCODE_FINAL_LENGTH;\n      unsigned done;\n      \n      char *p\n\t= (char *) nettle_buffer_space(buffer, text_size);\n      if (!p)\n\treturn 0;\n\n      done = base64_encode_update(&ctx, p, length, data);\n      done += base64_encode_final(&ctx, p + done);\n\n      /* FIXME: Create some official way to do this */\n      buffer->size -= (text_size - done);\n      \n      if (!NETTLE_BUFFER_PUTC(buffer, '\\n'))\n\treturn 0;\n    }\n  /* Checksum */\n  if (!NETTLE_BUFFER_PUTC(buffer, '='))\n    return 0;\n\n  {\n    char *p = (char *) nettle_buffer_space(buffer, 4);\n    if (!p)\n      return 0;\n    base64_encode_group(p, crc);\n  }\n  \n  return (write_string(buffer, \"\\nBEGIN PGP \")\n\t  && write_string(buffer, tag)\n\t  && NETTLE_BUFFER_PUTC(buffer, '\\n'));\n}",
      "lines": 73,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pgp.h": {},
  "nettle/nettle-3.4.1/pkcs1-decrypt.c": {
    "pkcs1_decrypt": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\npkcs1_decrypt (size_t key_size,\n\t       const mpz_t m,\n\t       size_t *length, uint8_t *message)\n{\n  TMP_GMP_DECL(em, uint8_t);\n  int ret;\n\n  TMP_GMP_ALLOC(em, key_size);\n  nettle_mpz_get_str_256(key_size, em, m);\n\n  ret = _pkcs1_sec_decrypt_variable (length, message, key_size, em);\n\n  TMP_GMP_FREE(em);\n  return ret;\n}",
      "lines": 16,
      "depth": 7,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-encrypt.c": {
    "pkcs1_encrypt": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "int\npkcs1_encrypt (size_t key_size,\n\t       /* For padding */\n\t       void *random_ctx, nettle_random_func *random,\n\t       size_t length, const uint8_t *message,\n\t       mpz_t m)\n{\n  TMP_GMP_DECL(em, uint8_t);\n  size_t padding;\n  size_t i;\n\n  /* The message is encoded as a string of the same length as the\n   * modulo n, of the form\n   *\n   *   00 02 pad 00 message\n   *\n   * where padding should be at least 8 pseudorandomly generated\n   * *non-zero* octets. */\n     \n  if (length + 11 > key_size)\n    /* Message too long for this key. */\n    return 0;\n\n  /* At least 8 octets of random padding */\n  padding = key_size - length - 3;\n  assert(padding >= 8);\n  \n  TMP_GMP_ALLOC(em, key_size - 1);\n  em[0] = 2;\n\n  random(random_ctx, padding, em + 1);\n\n  /* Replace 0-octets with 1 */\n  for (i = 0; i<padding; i++)\n    if (!em[i+1])\n      em[i+1] = 1;\n\n  em[padding+1] = 0;\n  memcpy(em + padding + 2, message, length);\n\n  nettle_mpz_set_str_256_u(m, key_size - 1, em);\n\n  TMP_GMP_FREE(em);\n  return 1;\n}",
      "lines": 45,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-rsa-digest.c": {
    "pkcs1_rsa_digest_encode": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\npkcs1_rsa_digest_encode(mpz_t m, size_t key_size,\n\t\t\tsize_t di_length, const uint8_t *digest_info)\n{\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  if (_pkcs1_signature_prefix(key_size, em,\n\t\t\t      di_length, digest_info, 0))\n    {\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 21,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-rsa-md5.c": {
    "pkcs1_rsa_md5_encode": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\npkcs1_rsa_md5_encode(mpz_t m, size_t key_size, struct md5_ctx *hash)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(md5_prefix),\n\t\t\t      md5_prefix,\n\t\t\t      MD5_DIGEST_SIZE);\n  if (p)\n    {\n      md5_digest(hash, MD5_DIGEST_SIZE, p);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pkcs1_rsa_md5_encode_digest": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\npkcs1_rsa_md5_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(md5_prefix),\n\t\t\t      md5_prefix,\n\t\t\t      MD5_DIGEST_SIZE);\n  if (p)\n    {\n      memcpy(p, digest, MD5_DIGEST_SIZE);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-rsa-sha1.c": {
    "pkcs1_rsa_sha1_encode": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "int\npkcs1_rsa_sha1_encode(mpz_t m, size_t key_size, struct sha1_ctx *hash)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha1_prefix),\n\t\t\t      sha1_prefix,\n\t\t\t      SHA1_DIGEST_SIZE);\n  if (p)\n    {\n      sha1_digest(hash, SHA1_DIGEST_SIZE, p);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pkcs1_rsa_sha1_encode_digest": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "int\npkcs1_rsa_sha1_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha1_prefix),\n\t\t\t      sha1_prefix,\n\t\t\t      SHA1_DIGEST_SIZE);\n  if (p)\n    {\n      memcpy(p, digest, SHA1_DIGEST_SIZE);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-rsa-sha256.c": {
    "pkcs1_rsa_sha256_encode": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\npkcs1_rsa_sha256_encode(mpz_t m, size_t key_size, struct sha256_ctx *hash)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha256_prefix),\n\t\t\t      sha256_prefix,\n\t\t\t      SHA256_DIGEST_SIZE);\n  if (p)\n    {\n      sha256_digest(hash, SHA256_DIGEST_SIZE, p);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pkcs1_rsa_sha256_encode_digest": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\npkcs1_rsa_sha256_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha256_prefix),\n\t\t\t      sha256_prefix,\n\t\t\t      SHA256_DIGEST_SIZE);\n  if (p)\n    {\n      memcpy(p, digest, SHA256_DIGEST_SIZE);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-rsa-sha512.c": {
    "pkcs1_rsa_sha512_encode": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\npkcs1_rsa_sha512_encode(mpz_t m, size_t key_size, struct sha512_ctx *hash)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha512_prefix),\n\t\t\t      sha512_prefix,\n\t\t\t      SHA512_DIGEST_SIZE);\n  if (p)\n    {\n      sha512_digest(hash, SHA512_DIGEST_SIZE, p);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pkcs1_rsa_sha512_encode_digest": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        119,
        1
      ],
      "content": "int\npkcs1_rsa_sha512_encode_digest(mpz_t m, size_t key_size, const uint8_t *digest)\n{\n  uint8_t *p;\n  TMP_GMP_DECL(em, uint8_t);\n\n  TMP_GMP_ALLOC(em, key_size);\n\n  p = _pkcs1_signature_prefix(key_size, em,\n\t\t\t      sizeof(sha512_prefix),\n\t\t\t      sha512_prefix,\n\t\t\t      SHA512_DIGEST_SIZE);\n  if (p)\n    {\n      memcpy(p, digest, SHA512_DIGEST_SIZE);\n      nettle_mpz_set_str_256_u(m, key_size, em);\n      TMP_GMP_FREE(em);\n      return 1;\n    }\n  else\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n}",
      "lines": 25,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1-sec-decrypt.c": {
    "_pkcs1_sec_decrypt": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "int\n_pkcs1_sec_decrypt (size_t length, uint8_t *message,\n                    size_t padded_message_length,\n                    const volatile uint8_t *padded_message)\n{\n  volatile int ok;\n  size_t i, t;\n\n  assert (padded_message_length >= length);\n\n  t = padded_message_length - length - 1;\n\n  /* Check format, padding, message_size */\n  ok = EQUAL(padded_message[0], 0);       /* ok if padded_message[0] == 0 */\n  ok &= EQUAL(padded_message[1], 2);      /* ok if padded_message[1] == 2 */\n  for (i = 2; i < t; i++)      /* check padding has no zeros */\n    {\n      ok &= NOT_EQUAL(padded_message[i], 0);\n    }\n  ok &= EQUAL(padded_message[t], 0);      /* ok if terminator == 0 */\n\n  /* fill destination buffer regardless of outcome */\n  cnd_memcpy(ok, message, padded_message + t + 1, length);\n\n  return ok;\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "_pkcs1_sec_decrypt_variable": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        148,
        1
      ],
      "content": "int\n_pkcs1_sec_decrypt_variable(size_t *length, uint8_t *message,\n                            size_t padded_message_length,\n                            const volatile uint8_t *padded_message)\n{\n  volatile int not_found = 1;\n  volatile int ok;\n  volatile size_t offset;\n  size_t buflen, msglen;\n  size_t shift, i;\n\n  /* Check format, padding, message_size */\n  ok = EQUAL(padded_message[0], 0);\n  ok &= EQUAL(padded_message[1], 2);\n\n  /* length is discovered in a side-channel silent way.\n   * not_found goes to 0 when the terminator is found.\n   * offset strts at 3 as it includes the terminator and\n   * the fomat bytes already */\n  offset = 3;\n  for (i = 2; i < padded_message_length; i++)\n    {\n      not_found &= NOT_EQUAL(padded_message[i], 0);\n      offset += not_found;\n    }\n  /* check if we ran out of buffer */\n  ok &= NOT_EQUAL(not_found, 1);\n  /* padding must be >= 11 (2 format bytes + 8 pad bytes min. + terminator) */\n  ok &= GREATER_OR_EQUAL(offset, 11);\n\n  /* offset can vary between 3 and padded_message_length, due to the loop\n   * above, therefore msglen can't underflow */\n  msglen = padded_message_length - offset;\n\n  /* we always fill the whole buffer but only up to\n   * padded_message_length length */\n  buflen = *length;\n  if (buflen > padded_message_length) { /* input independent branch */\n    buflen = padded_message_length;\n  }\n\n  /* if the message length is larger than the buffer we must fail */\n  ok &= GREATER_OR_EQUAL(buflen, msglen);\n\n  /* fill destination buffer fully regardless of outcome. Copies the message\n   * in a memory access independent way. The destination message buffer will\n   * be clobbered past the message length. */\n  shift = padded_message_length - buflen;\n  cnd_memcpy(ok, message, padded_message + shift, buflen);\n  offset -= shift;\n  /* In this loop, the bits of the 'offset' variable are used as shifting\n   * conditions, starting from the least significant bit. The end result is\n   * that the buffer is shifted left exactly 'offset' bytes. */\n  for (shift = 1; shift < buflen; shift <<= 1, offset >>= 1)\n    {\n      /* 'ok' is both a least significant bit mask and a condition */\n      cnd_memcpy(offset & ok, message, message + shift, buflen - shift);\n    }\n\n  /* update length only if we succeeded, otherwise leave unchanged */\n  *length = (msglen & (-(size_t) ok)) + (*length & ((size_t) ok - 1));\n\n  return ok;\n}",
      "lines": 64,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1.c": {
    "_pkcs1_signature_prefix": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "uint8_t *\n_pkcs1_signature_prefix(unsigned key_size,\n\t\t\tuint8_t *buffer,\n\t\t\tunsigned id_size,\n\t\t\tconst uint8_t *id,\n\t\t\tunsigned digest_size)\n{\n  unsigned j;\n  \n  if (key_size < 11 + id_size + digest_size)\n    return NULL;\n\n  j = key_size - digest_size - id_size;\n\n  memcpy (buffer + j, id, id_size);\n  buffer[0] = 0;\n  buffer[1] = 1;\n  buffer[j-1] = 0;\n\n  assert(j >= 11);\n  memset(buffer + 2, 0xff, j - 3);\n\n  return buffer + j + id_size;\n}",
      "lines": 24,
      "depth": 8,
      "decorators": [
        "uint8_t",
        "*\n_pkcs1_signature_prefix(unsigned key_size,\n\t\t\tuint8_t *buffer,\n\t\t\tunsigned id_size,\n\t\t\tconst uint8_t *id,\n\t\t\tunsigned digest_size)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/pkcs1.h": {},
  "nettle/nettle-3.4.1/poly1305-aes.c": {
    "poly1305_aes_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\npoly1305_aes_set_key (struct poly1305_aes_ctx *ctx, const uint8_t * key)\n{\n  aes128_set_encrypt_key(&ctx->aes, (key));\n  poly1305_set_key(&ctx->pctx, (key+16));\n  ctx->index = 0;\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "poly1305_aes_set_nonce": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\npoly1305_aes_set_nonce (struct poly1305_aes_ctx *ctx,\n\t\t\tconst uint8_t * nonce)\n{\n  memcpy (ctx->nonce, nonce, POLY1305_AES_NONCE_SIZE);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "poly1305_aes_update": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\npoly1305_aes_update (struct poly1305_aes_ctx *ctx,\n\t\t     size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, COMPRESS, (void) 0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "poly1305_aes_digest": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "void\npoly1305_aes_digest (struct poly1305_aes_ctx *ctx,\n\t\t     size_t length, uint8_t *digest)\n{\n  union nettle_block16 s;\n  /* final bytes */\n  if (ctx->index > 0)\n    {\n      assert (ctx->index < POLY1305_BLOCK_SIZE);\n\n      ctx->block[ctx->index] = 1;\n      memset (ctx->block + ctx->index + 1,\n\t      0, POLY1305_BLOCK_SIZE - 1 - ctx->index);\n\n      _poly1305_block (&ctx->pctx, ctx->block, 0);\n    }\n  aes128_encrypt(&ctx->aes, POLY1305_BLOCK_SIZE, s.b, ctx->nonce);\n  \n  poly1305_digest (&ctx->pctx, &s);\n  memcpy (digest, s.b, length);\n\n  INCREMENT (16, ctx->nonce);\n  ctx->index = 0;\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/poly1305-internal.c": {
    "poly1305_set_key": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\npoly1305_set_key(struct poly1305_ctx *ctx, const uint8_t key[16])\n{\n  uint32_t t0,t1,t2,t3;\n\n  t0 = LE_READ_UINT32(key);\n  t1 = LE_READ_UINT32(key+4);\n  t2 = LE_READ_UINT32(key+8);\n  t3 = LE_READ_UINT32(key+12);\n\n  ctx->r0 = t0 & 0x3ffffff; t0 >>= 26; t0 |= t1 << 6;\n  ctx->r1 = t0 & 0x3ffff03; t1 >>= 20; t1 |= t2 << 12;\n  ctx->r2 = t1 & 0x3ffc0ff; t2 >>= 14; t2 |= t3 << 18;\n  ctx->r3 = t2 & 0x3f03fff; t3 >>= 8;\n  ctx->r4 = t3 & 0x00fffff;\n\n  ctx->s1 = ctx->r1 * 5;\n  ctx->s2 = ctx->r2 * 5;\n  ctx->s3 = ctx->r3 * 5;\n  ctx->s4 = ctx->r4 * 5;\n\n  ctx->h0 = 0;\n  ctx->h1 = 0;\n  ctx->h2 = 0;\n  ctx->h3 = 0;\n  ctx->h4 = 0;\n}",
      "lines": 27,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "_poly1305_block": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "void\n_poly1305_block (struct poly1305_ctx *ctx, const uint8_t *m, unsigned t4)\n{\n  uint32_t t0,t1,t2,t3;\n  uint32_t b;\n  uint64_t t[5];\n  uint64_t c;\n\n  t0 = LE_READ_UINT32(m);\n  t1 = LE_READ_UINT32(m+4);\n  t2 = LE_READ_UINT32(m+8);\n  t3 = LE_READ_UINT32(m+12);\n\n  ctx->h0 += t0 & 0x3ffffff;\n  ctx->h1 += ((((uint64_t)t1 << 32) | t0) >> 26) & 0x3ffffff;\n  ctx->h2 += ((((uint64_t)t2 << 32) | t1) >> 20) & 0x3ffffff;\n  ctx->h3 += ((((uint64_t)t3 << 32) | t2) >> 14) & 0x3ffffff;\n  ctx->h4 += (t3 >> 8) | ((uint32_t) t4 << 24);\n\n  /* poly1305_donna_mul: */\n  t[0]  = mul32x32_64(ctx->h0,ctx->r0) + mul32x32_64(ctx->h1,ctx->s4) + mul32x32_64(ctx->h2,ctx->s3) + mul32x32_64(ctx->h3,ctx->s2) + mul32x32_64(ctx->h4,ctx->s1);\n  t[1]  = mul32x32_64(ctx->h0,ctx->r1) + mul32x32_64(ctx->h1,ctx->r0) + mul32x32_64(ctx->h2,ctx->s4) + mul32x32_64(ctx->h3,ctx->s3) + mul32x32_64(ctx->h4,ctx->s2);\n  t[2]  = mul32x32_64(ctx->h0,ctx->r2) + mul32x32_64(ctx->h1,ctx->r1) + mul32x32_64(ctx->h2,ctx->r0) + mul32x32_64(ctx->h3,ctx->s4) + mul32x32_64(ctx->h4,ctx->s3);\n  t[3]  = mul32x32_64(ctx->h0,ctx->r3) + mul32x32_64(ctx->h1,ctx->r2) + mul32x32_64(ctx->h2,ctx->r1) + mul32x32_64(ctx->h3,ctx->r0) + mul32x32_64(ctx->h4,ctx->s4);\n  t[4]  = mul32x32_64(ctx->h0,ctx->r4) + mul32x32_64(ctx->h1,ctx->r3) + mul32x32_64(ctx->h2,ctx->r2) + mul32x32_64(ctx->h3,ctx->r1) + mul32x32_64(ctx->h4,ctx->r0);\n\n  ctx->h0 = (uint32_t)t[0] & 0x3ffffff; c =           (t[0] >> 26);\n  t[1] += c;      ctx->h1 = (uint32_t)t[1] & 0x3ffffff; b = (uint32_t)(t[1] >> 26);\n  t[2] += b;      ctx->h2 = (uint32_t)t[2] & 0x3ffffff; b = (uint32_t)(t[2] >> 26);\n  t[3] += b;      ctx->h3 = (uint32_t)t[3] & 0x3ffffff; b = (uint32_t)(t[3] >> 26);\n  t[4] += b;      ctx->h4 = (uint32_t)t[4] & 0x3ffffff; b = (uint32_t)(t[4] >> 26);\n  ctx->h0 += b * 5;\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "poly1305_digest": {
      "start_point": [
        149,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void\npoly1305_digest (struct poly1305_ctx *ctx, union nettle_block16 *s)\n{\n  uint32_t b, nb;\n  uint64_t f0,f1,f2,f3;\n  uint32_t g0,g1,g2,g3,g4;\n\n  b = ctx->h0 >> 26; ctx->h0 = ctx->h0 & 0x3ffffff;\n  ctx->h1 +=     b; b = ctx->h1 >> 26; ctx->h1 = ctx->h1 & 0x3ffffff;\n  ctx->h2 +=     b; b = ctx->h2 >> 26; ctx->h2 = ctx->h2 & 0x3ffffff;\n  ctx->h3 +=     b; b = ctx->h3 >> 26; ctx->h3 = ctx->h3 & 0x3ffffff;\n  ctx->h4 +=     b; b = ctx->h4 >> 26; ctx->h4 = ctx->h4 & 0x3ffffff;\n  ctx->h0 += b * 5; b = ctx->h0 >> 26; ctx->h0 = ctx->h0 & 0x3ffffff;\n  ctx->h1 +=     b;\n\n  g0 = ctx->h0 + 5; b = g0 >> 26; g0 &= 0x3ffffff;\n  g1 = ctx->h1 + b; b = g1 >> 26; g1 &= 0x3ffffff;\n  g2 = ctx->h2 + b; b = g2 >> 26; g2 &= 0x3ffffff;\n  g3 = ctx->h3 + b; b = g3 >> 26; g3 &= 0x3ffffff;\n  g4 = ctx->h4 + b - (1 << 26);\n\n  b = (g4 >> 31) - 1;\n  nb = ~b;\n  ctx->h0 = (ctx->h0 & nb) | (g0 & b);\n  ctx->h1 = (ctx->h1 & nb) | (g1 & b);\n  ctx->h2 = (ctx->h2 & nb) | (g2 & b);\n  ctx->h3 = (ctx->h3 & nb) | (g3 & b);\n  ctx->h4 = (ctx->h4 & nb) | (g4 & b);\n\n  /* FIXME: Take advantage of s being aligned as an unsigned long. */\n  f0 = ((ctx->h0    )|(ctx->h1<<26)) + (uint64_t)LE_READ_UINT32(s->b);\n  f1 = ((ctx->h1>> 6)|(ctx->h2<<20)) + (uint64_t)LE_READ_UINT32(s->b+4);\n  f2 = ((ctx->h2>>12)|(ctx->h3<<14)) + (uint64_t)LE_READ_UINT32(s->b+8);\n  f3 = ((ctx->h3>>18)|(ctx->h4<< 8)) + (uint64_t)LE_READ_UINT32(s->b+12);\n\n  LE_WRITE_UINT32(s->b, f0);\n  f1 += (f0 >> 32);\n  LE_WRITE_UINT32(s->b+4, f1);\n  f2 += (f1 >> 32);\n  LE_WRITE_UINT32(s->b+8, f2);\n  f3 += (f2 >> 32);\n  LE_WRITE_UINT32(s->b+12, f3);\n\n  ctx->h0 = 0;\n  ctx->h1 = 0;\n  ctx->h2 = 0;\n  ctx->h3 = 0;\n  ctx->h4 = 0;\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/poly1305.h": {},
  "nettle/nettle-3.4.1/pss-mgf1.c": {
    "pss_mgf1": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void\npss_mgf1(const void *seed, const struct nettle_hash *hash,\n\t size_t length, uint8_t *mask)\n{\n  TMP_DECL(h, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);\n  size_t i;\n  uint8_t c[4];\n\n  TMP_ALLOC(h, hash->digest_size);\n  TMP_ALLOC(state, hash->context_size);\n\n  for (i = 0;;\n       i++, mask += hash->digest_size, length -= hash->digest_size)\n    {\n      WRITE_UINT32(c, i);\n\n      memcpy(state, seed, hash->context_size);\n      hash->update(state, 4, c);\n\n      if (length <= hash->digest_size)\n\t{\n\t  hash->digest(state, length, mask);\n\t  return;\n\t}\n      hash->digest(state, hash->digest_size, mask);\n    }\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/pss-mgf1.h": {},
  "nettle/nettle-3.4.1/pss.c": {
    "pss_encode_mgf1": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\npss_encode_mgf1(mpz_t m, size_t bits,\n\t\tconst struct nettle_hash *hash,\n\t\tsize_t salt_length, const uint8_t *salt,\n\t\tconst uint8_t *digest)\n{\n  TMP_GMP_DECL(em, uint8_t);\n  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);\n  size_t key_size = (bits + 7) / 8;\n  size_t j;\n\n  TMP_GMP_ALLOC(em, key_size);\n  TMP_ALLOC(state, hash->context_size);\n\n  if (key_size < hash->digest_size + salt_length + 2)\n    {\n      TMP_GMP_FREE(em);\n      return 0;\n    }\n\n  /* Compute M'.  */\n  hash->init(state);\n  hash->update(state, sizeof(pss_pad), pss_pad);\n  hash->update(state, hash->digest_size, digest);\n  hash->update(state, salt_length, salt);\n\n  /* Store H in EM, right after maskedDB.  */\n  hash->digest(state, hash->digest_size, em + key_size - hash->digest_size - 1);\n\n  /* Compute dbMask.  */\n  hash->init(state);\n  hash->update(state, hash->digest_size, em + key_size - hash->digest_size - 1);\n\n  pss_mgf1(state, hash, key_size - hash->digest_size - 1, em);\n\n  /* Compute maskedDB and store it in front of H in EM.  */\n  j = key_size - salt_length - hash->digest_size - 2;\n\n  em[j++] ^= 1;\n  memxor(em + j, salt, salt_length);\n  j += salt_length;\n\n  /* Store the trailer field following H.  */\n  j += hash->digest_size;\n  em[j] = 0xbc;\n\n  /* Clear the leftmost 8 * emLen - emBits of the leftmost octet in EM.  */\n  *em &= pss_masks[(8 * key_size - bits)];\n\n  nettle_mpz_set_str_256_u(m, key_size, em);\n  TMP_GMP_FREE(em);\n  return 1;\n}",
      "lines": 53,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "pss_verify_mgf1": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "int\npss_verify_mgf1(const mpz_t m, size_t bits,\n\t\tconst struct nettle_hash *hash,\n\t\tsize_t salt_length,\n\t\tconst uint8_t *digest)\n{\n  TMP_GMP_DECL(em, uint8_t);\n  TMP_DECL(h2, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  TMP_DECL(state, uint8_t, NETTLE_MAX_HASH_CONTEXT_SIZE);\n  uint8_t *h, *db, *salt;\n  size_t key_size = (bits + 7) / 8;\n  size_t j;\n  int ret = 0;\n\n  /* Allocate twice the key size to store the intermediate data DB\n   * following the EM value.  */\n  TMP_GMP_ALLOC(em, key_size * 2);\n\n  TMP_ALLOC(h2, hash->digest_size);\n  TMP_ALLOC(state, hash->context_size);\n\n  if (key_size < hash->digest_size + salt_length + 2)\n    goto cleanup;\n\n  if (mpz_sizeinbase(m, 2) > bits)\n    goto cleanup;\n\n  nettle_mpz_get_str_256(key_size, em, m);\n\n  /* Check the trailer field.  */\n  if (em[key_size - 1] != 0xbc)\n    goto cleanup;\n\n  /* Extract H.  */\n  h = em + (key_size - hash->digest_size - 1);\n\n  /* The leftmost 8 * emLen - emBits bits of the leftmost octet of EM\n   * must all equal to zero. Always true here, thanks to the above\n   * check on the bit size of m. */\n  assert((*em & ~pss_masks[(8 * key_size - bits)]) == 0);\n\n  /* Compute dbMask.  */\n  hash->init(state);\n  hash->update(state, hash->digest_size, h);\n\n  db = em + key_size;\n  pss_mgf1(state, hash, key_size - hash->digest_size - 1, db);\n\n  /* Compute DB.  */\n  memxor(db, em, key_size - hash->digest_size - 1);\n\n  *db &= pss_masks[(8 * key_size - bits)];\n  for (j = 0; j < key_size - salt_length - hash->digest_size - 2; j++)\n    if (db[j] != 0)\n      goto cleanup;\n\n  /* Check the octet right after PS is 0x1.  */\n  if (db[j] != 0x1)\n    goto cleanup;\n  salt = db + j + 1;\n\n  /* Compute H'.  */\n  hash->init(state);\n  hash->update(state, sizeof(pss_pad), pss_pad);\n  hash->update(state, hash->digest_size, digest);\n  hash->update(state, salt_length, salt);\n  hash->digest(state, hash->digest_size, h2);\n\n  /* Check if H' = H.  */\n  if (memcmp(h2, h, hash->digest_size) != 0)\n    goto cleanup;\n\n  ret = 1;\n cleanup:\n  TMP_GMP_FREE(em);\n  return ret;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/pss.h": {},
  "nettle/nettle-3.4.1/realloc.c": {
    "nettle_realloc": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void *\nnettle_realloc(void *ctx UNUSED, void *p, size_t length)\n{\n  if (length > 0)\n    return realloc(p, length);\n\n  free(p);\n  return NULL;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void",
        "*\nnettle_realloc(void *ctx UNUSED, void *p, size_t length)",
        "*"
      ]
    },
    "nettle_xrealloc": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void *\nnettle_xrealloc(void *ctx UNUSED, void *p, size_t length)\n{\n  if (length > 0)\n    {\n      void *n = realloc(p, length);\n      if (!n)\n\t{\n\t  fprintf(stderr, \"Virtual memory exhausted.\\n\");\n\t  abort();\n\t}\n      return n;\n    }\n  free(p);\n  return NULL;\n}",
      "lines": 16,
      "depth": 11,
      "decorators": [
        "void",
        "*\nnettle_xrealloc(void *ctx UNUSED, void *p, size_t length)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/realloc.h": {},
  "nettle/nettle-3.4.1/ripemd160-compress.c": {
    "_nettle_ripemd160_compress": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "void\n_nettle_ripemd160_compress(uint32_t *state, const uint8_t *data)\n{\n  register uint32_t a,b,c,d,e;\n  uint32_t aa,bb,cc,dd,ee,t;\n  uint32_t x[16];\n\n#ifdef WORDS_BIGENDIAN\n  {\n    int i;\n    for (i=0; i < 16; i++, data += 4 )\n      x[i] = LE_READ_UINT32(data);\n  }\n#else\n  /* memcpy seems a bit faster. Benchmarked on Intel SU4100, it makes\n     the entire update function roughly 6% faster. */\n  memcpy(x, data, sizeof(x));\n#endif\n\n\n#define K0  0x00000000\n#define K1  0x5A827999\n#define K2  0x6ED9EBA1\n#define K3  0x8F1BBCDC\n#define K4  0xA953FD4E\n#define KK0 0x50A28BE6\n#define KK1 0x5C4DD124\n#define KK2 0x6D703EF3\n#define KK3 0x7A6D76E9\n#define KK4 0x00000000\n#define F0(x,y,z)   ( (x) ^ (y) ^ (z) )\n#define F1(x,y,z)   ( ((x) & (y)) | (~(x) & (z)) )\n#define F2(x,y,z)   ( ((x) | ~(y)) ^ (z) )\n#define F3(x,y,z)   ( ((x) & (z)) | ((y) & ~(z)) )\n#define F4(x,y,z)   ( (x) ^ ((y) | ~(z)) )\n#define R(a,b,c,d,e,f,k,r,s) do { t = a + f(b,c,d) + k + x[r]; \\\n          a = ROTL32(s,t) + e;        \\\n          c = ROTL32(10,c);         \\\n        } while(0)\n\n  /* left lane */\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R( a, b, c, d, e, F0, K0,  0, 11 );\n  R( e, a, b, c, d, F0, K0,  1, 14 );\n  R( d, e, a, b, c, F0, K0,  2, 15 );\n  R( c, d, e, a, b, F0, K0,  3, 12 );\n  R( b, c, d, e, a, F0, K0,  4,  5 );\n  R( a, b, c, d, e, F0, K0,  5,  8 );\n  R( e, a, b, c, d, F0, K0,  6,  7 );\n  R( d, e, a, b, c, F0, K0,  7,  9 );\n  R( c, d, e, a, b, F0, K0,  8, 11 );\n  R( b, c, d, e, a, F0, K0,  9, 13 );\n  R( a, b, c, d, e, F0, K0, 10, 14 );\n  R( e, a, b, c, d, F0, K0, 11, 15 );\n  R( d, e, a, b, c, F0, K0, 12,  6 );\n  R( c, d, e, a, b, F0, K0, 13,  7 );\n  R( b, c, d, e, a, F0, K0, 14,  9 );\n  R( a, b, c, d, e, F0, K0, 15,  8 );\n  R( e, a, b, c, d, F1, K1,  7,  7 );\n  R( d, e, a, b, c, F1, K1,  4,  6 );\n  R( c, d, e, a, b, F1, K1, 13,  8 );\n  R( b, c, d, e, a, F1, K1,  1, 13 );\n  R( a, b, c, d, e, F1, K1, 10, 11 );\n  R( e, a, b, c, d, F1, K1,  6,  9 );\n  R( d, e, a, b, c, F1, K1, 15,  7 );\n  R( c, d, e, a, b, F1, K1,  3, 15 );\n  R( b, c, d, e, a, F1, K1, 12,  7 );\n  R( a, b, c, d, e, F1, K1,  0, 12 );\n  R( e, a, b, c, d, F1, K1,  9, 15 );\n  R( d, e, a, b, c, F1, K1,  5,  9 );\n  R( c, d, e, a, b, F1, K1,  2, 11 );\n  R( b, c, d, e, a, F1, K1, 14,  7 );\n  R( a, b, c, d, e, F1, K1, 11, 13 );\n  R( e, a, b, c, d, F1, K1,  8, 12 );\n  R( d, e, a, b, c, F2, K2,  3, 11 );\n  R( c, d, e, a, b, F2, K2, 10, 13 );\n  R( b, c, d, e, a, F2, K2, 14,  6 );\n  R( a, b, c, d, e, F2, K2,  4,  7 );\n  R( e, a, b, c, d, F2, K2,  9, 14 );\n  R( d, e, a, b, c, F2, K2, 15,  9 );\n  R( c, d, e, a, b, F2, K2,  8, 13 );\n  R( b, c, d, e, a, F2, K2,  1, 15 );\n  R( a, b, c, d, e, F2, K2,  2, 14 );\n  R( e, a, b, c, d, F2, K2,  7,  8 );\n  R( d, e, a, b, c, F2, K2,  0, 13 );\n  R( c, d, e, a, b, F2, K2,  6,  6 );\n  R( b, c, d, e, a, F2, K2, 13,  5 );\n  R( a, b, c, d, e, F2, K2, 11, 12 );\n  R( e, a, b, c, d, F2, K2,  5,  7 );\n  R( d, e, a, b, c, F2, K2, 12,  5 );\n  R( c, d, e, a, b, F3, K3,  1, 11 );\n  R( b, c, d, e, a, F3, K3,  9, 12 );\n  R( a, b, c, d, e, F3, K3, 11, 14 );\n  R( e, a, b, c, d, F3, K3, 10, 15 );\n  R( d, e, a, b, c, F3, K3,  0, 14 );\n  R( c, d, e, a, b, F3, K3,  8, 15 );\n  R( b, c, d, e, a, F3, K3, 12,  9 );\n  R( a, b, c, d, e, F3, K3,  4,  8 );\n  R( e, a, b, c, d, F3, K3, 13,  9 );\n  R( d, e, a, b, c, F3, K3,  3, 14 );\n  R( c, d, e, a, b, F3, K3,  7,  5 );\n  R( b, c, d, e, a, F3, K3, 15,  6 );\n  R( a, b, c, d, e, F3, K3, 14,  8 );\n  R( e, a, b, c, d, F3, K3,  5,  6 );\n  R( d, e, a, b, c, F3, K3,  6,  5 );\n  R( c, d, e, a, b, F3, K3,  2, 12 );\n  R( b, c, d, e, a, F4, K4,  4,  9 );\n  R( a, b, c, d, e, F4, K4,  0, 15 );\n  R( e, a, b, c, d, F4, K4,  5,  5 );\n  R( d, e, a, b, c, F4, K4,  9, 11 );\n  R( c, d, e, a, b, F4, K4,  7,  6 );\n  R( b, c, d, e, a, F4, K4, 12,  8 );\n  R( a, b, c, d, e, F4, K4,  2, 13 );\n  R( e, a, b, c, d, F4, K4, 10, 12 );\n  R( d, e, a, b, c, F4, K4, 14,  5 );\n  R( c, d, e, a, b, F4, K4,  1, 12 );\n  R( b, c, d, e, a, F4, K4,  3, 13 );\n  R( a, b, c, d, e, F4, K4,  8, 14 );\n  R( e, a, b, c, d, F4, K4, 11, 11 );\n  R( d, e, a, b, c, F4, K4,  6,  8 );\n  R( c, d, e, a, b, F4, K4, 15,  5 );\n  R( b, c, d, e, a, F4, K4, 13,  6 );\n\n  aa = a; bb = b; cc = c; dd = d; ee = e;\n\n  /* right lane */\n  a = state[0];\n  b = state[1];\n  c = state[2];\n  d = state[3];\n  e = state[4];\n  R( a, b, c, d, e, F4, KK0,  5,  8);\n  R( e, a, b, c, d, F4, KK0, 14,  9);\n  R( d, e, a, b, c, F4, KK0,  7,  9);\n  R( c, d, e, a, b, F4, KK0,  0, 11);\n  R( b, c, d, e, a, F4, KK0,  9, 13);\n  R( a, b, c, d, e, F4, KK0,  2, 15);\n  R( e, a, b, c, d, F4, KK0, 11, 15);\n  R( d, e, a, b, c, F4, KK0,  4,  5);\n  R( c, d, e, a, b, F4, KK0, 13,  7);\n  R( b, c, d, e, a, F4, KK0,  6,  7);\n  R( a, b, c, d, e, F4, KK0, 15,  8);\n  R( e, a, b, c, d, F4, KK0,  8, 11);\n  R( d, e, a, b, c, F4, KK0,  1, 14);\n  R( c, d, e, a, b, F4, KK0, 10, 14);\n  R( b, c, d, e, a, F4, KK0,  3, 12);\n  R( a, b, c, d, e, F4, KK0, 12,  6);\n  R( e, a, b, c, d, F3, KK1,  6,  9);\n  R( d, e, a, b, c, F3, KK1, 11, 13);\n  R( c, d, e, a, b, F3, KK1,  3, 15);\n  R( b, c, d, e, a, F3, KK1,  7,  7);\n  R( a, b, c, d, e, F3, KK1,  0, 12);\n  R( e, a, b, c, d, F3, KK1, 13,  8);\n  R( d, e, a, b, c, F3, KK1,  5,  9);\n  R( c, d, e, a, b, F3, KK1, 10, 11);\n  R( b, c, d, e, a, F3, KK1, 14,  7);\n  R( a, b, c, d, e, F3, KK1, 15,  7);\n  R( e, a, b, c, d, F3, KK1,  8, 12);\n  R( d, e, a, b, c, F3, KK1, 12,  7);\n  R( c, d, e, a, b, F3, KK1,  4,  6);\n  R( b, c, d, e, a, F3, KK1,  9, 15);\n  R( a, b, c, d, e, F3, KK1,  1, 13);\n  R( e, a, b, c, d, F3, KK1,  2, 11);\n  R( d, e, a, b, c, F2, KK2, 15,  9);\n  R( c, d, e, a, b, F2, KK2,  5,  7);\n  R( b, c, d, e, a, F2, KK2,  1, 15);\n  R( a, b, c, d, e, F2, KK2,  3, 11);\n  R( e, a, b, c, d, F2, KK2,  7,  8);\n  R( d, e, a, b, c, F2, KK2, 14,  6);\n  R( c, d, e, a, b, F2, KK2,  6,  6);\n  R( b, c, d, e, a, F2, KK2,  9, 14);\n  R( a, b, c, d, e, F2, KK2, 11, 12);\n  R( e, a, b, c, d, F2, KK2,  8, 13);\n  R( d, e, a, b, c, F2, KK2, 12,  5);\n  R( c, d, e, a, b, F2, KK2,  2, 14);\n  R( b, c, d, e, a, F2, KK2, 10, 13);\n  R( a, b, c, d, e, F2, KK2,  0, 13);\n  R( e, a, b, c, d, F2, KK2,  4,  7);\n  R( d, e, a, b, c, F2, KK2, 13,  5);\n  R( c, d, e, a, b, F1, KK3,  8, 15);\n  R( b, c, d, e, a, F1, KK3,  6,  5);\n  R( a, b, c, d, e, F1, KK3,  4,  8);\n  R( e, a, b, c, d, F1, KK3,  1, 11);\n  R( d, e, a, b, c, F1, KK3,  3, 14);\n  R( c, d, e, a, b, F1, KK3, 11, 14);\n  R( b, c, d, e, a, F1, KK3, 15,  6);\n  R( a, b, c, d, e, F1, KK3,  0, 14);\n  R( e, a, b, c, d, F1, KK3,  5,  6);\n  R( d, e, a, b, c, F1, KK3, 12,  9);\n  R( c, d, e, a, b, F1, KK3,  2, 12);\n  R( b, c, d, e, a, F1, KK3, 13,  9);\n  R( a, b, c, d, e, F1, KK3,  9, 12);\n  R( e, a, b, c, d, F1, KK3,  7,  5);\n  R( d, e, a, b, c, F1, KK3, 10, 15);\n  R( c, d, e, a, b, F1, KK3, 14,  8);\n  R( b, c, d, e, a, F0, KK4, 12,  8);\n  R( a, b, c, d, e, F0, KK4, 15,  5);\n  R( e, a, b, c, d, F0, KK4, 10, 12);\n  R( d, e, a, b, c, F0, KK4,  4,  9);\n  R( c, d, e, a, b, F0, KK4,  1, 12);\n  R( b, c, d, e, a, F0, KK4,  5,  5);\n  R( a, b, c, d, e, F0, KK4,  8, 14);\n  R( e, a, b, c, d, F0, KK4,  7,  6);\n  R( d, e, a, b, c, F0, KK4,  6,  8);\n  R( c, d, e, a, b, F0, KK4,  2, 13);\n  R( b, c, d, e, a, F0, KK4, 13,  6);\n  R( a, b, c, d, e, F0, KK4, 14,  5);\n  R( e, a, b, c, d, F0, KK4,  0, 15);\n  R( d, e, a, b, c, F0, KK4,  3, 13);\n  R( c, d, e, a, b, F0, KK4,  9, 11);\n  R( b, c, d, e, a, F0, KK4, 11, 11);\n\n\n  t    = state[1] + d + cc;\n  state[1] = state[2] + e + dd;\n  state[2] = state[3] + a + ee;\n  state[3] = state[4] + b + aa;\n  state[4] = state[0] + c + bb;\n  state[0] = t;\n}",
      "lines": 224,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ripemd160-meta.c": {},
  "nettle/nettle-3.4.1/ripemd160.c": {
    "ripemd160_init": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "void\nripemd160_init(struct ripemd160_ctx *ctx)\n{\n  static const uint32_t iv[_RIPEMD160_DIGEST_LENGTH] =\n    {\n      0x67452301,\n      0xEFCDAB89,\n      0x98BADCFE,\n      0x10325476,\n      0xC3D2E1F0,\n    };\n  memcpy(ctx->state, iv, sizeof(ctx->state));\n  ctx->count = 0;\n  ctx->index = 0;\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "ripemd160_update": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "void\nripemd160_update(struct ripemd160_ctx *ctx, size_t length, const uint8_t *data)\n{\n  MD_UPDATE(ctx, length, data, COMPRESS, ctx->count++);\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "ripemd160_digest": {
      "start_point": [
        183,
        0
      ],
      "end_point": [
        201,
        1
      ],
      "content": "void\nripemd160_digest(struct ripemd160_ctx *ctx, size_t length, uint8_t *digest)\n{\n  uint64_t bit_count;\n\n  assert(length <= RIPEMD160_DIGEST_SIZE);\n\n  MD_PAD(ctx, 8, COMPRESS);\n\n  /* There are 2^9 bits in one block */\n  bit_count = (ctx->count << 9) | (ctx->index << 3);\n\t\t\t\t\t\t\t\t\t\\\n  /* append the 64 bit count */\n  LE_WRITE_UINT64(ctx->block + 56, bit_count);\n  _nettle_ripemd160_compress(ctx->state, ctx->block);\n\n  _nettle_write_le32(length, digest, ctx->state);\n  ripemd160_init(ctx);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/ripemd160.h": {},
  "nettle/nettle-3.4.1/rotors.h": {},
  "nettle/nettle-3.4.1/rsa-blind.c": {
    "_rsa_blind": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\n_rsa_blind (const struct rsa_public_key *pub,\n\t    void *random_ctx, nettle_random_func *random,\n\t    mpz_t c, mpz_t ri)\n{\n  mpz_t r;\n\n  mpz_init(r);\n\n  /* c = c*(r^e)\n   * ri = r^(-1)\n   */\n  do \n    {\n      nettle_mpz_random(r, random_ctx, random, pub->n);\n      /* invert r */\n    }\n  while (!mpz_invert (ri, r, pub->n));\n\n  /* c = c*(r^e) mod n */\n  mpz_powm_sec(r, r, pub->e, pub->n);\n  mpz_mul(c, c, r);\n  mpz_fdiv_r(c, c, pub->n);\n\n  mpz_clear(r);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_rsa_unblind": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\n_rsa_unblind (const struct rsa_public_key *pub, mpz_t c, const mpz_t ri)\n{\n  mpz_mul(c, c, ri);\n  mpz_fdiv_r(c, c, pub->n);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-decrypt-tr.c": {
    "rsa_decrypt_tr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrsa_decrypt_tr(const struct rsa_public_key *pub,\n\t       const struct rsa_private_key *key,\n\t       void *random_ctx, nettle_random_func *random,\n\t       size_t *length, uint8_t *message,\n\t       const mpz_t gibberish)\n{\n  TMP_GMP_DECL (m, mp_limb_t);\n  TMP_GMP_DECL (em, uint8_t);\n  mp_size_t key_limb_size;\n  int res;\n\n  key_limb_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);\n\n  TMP_GMP_ALLOC (m, key_limb_size);\n  TMP_GMP_ALLOC (em, key->size);\n\n  res = _rsa_sec_compute_root_tr (pub, key, random_ctx, random, m,\n\t\t\t\t  mpz_limbs_read(gibberish),\n\t\t\t\t  mpz_size(gibberish));\n\n  mpn_get_base256 (em, key->size, m, key_limb_size);\n\n  res &= _pkcs1_sec_decrypt_variable (length, message, key->size, em);\n\n  TMP_GMP_FREE (em);\n  TMP_GMP_FREE (m);\n  return res;\n}",
      "lines": 29,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-decrypt.c": {
    "rsa_decrypt": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "int\nrsa_decrypt(const struct rsa_private_key *key,\n\t    size_t *length, uint8_t *message,\n\t    const mpz_t gibberish)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init(m);\n  rsa_compute_root(key, m, gibberish);\n\n  res = pkcs1_decrypt (key->size, m, length, message);\n  mpz_clear(m);\n  return res;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-encrypt.c": {
    "rsa_encrypt": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nrsa_encrypt(const struct rsa_public_key *key,\n\t    /* For padding */\n\t    void *random_ctx, nettle_random_func *random,\n\t    size_t length, const uint8_t *message,\n\t    mpz_t gibberish)\n{\n  if (pkcs1_encrypt (key->size, random_ctx, random,\n\t\t     length, message, gibberish))\n    {\n      mpz_powm(gibberish, gibberish, key->e, key->n);\n      return 1;\n    }\n  else\n    return 0;\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-internal.h": {},
  "nettle/nettle-3.4.1/rsa-keygen.c": {
    "rsa_generate_keypair": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "int\nrsa_generate_keypair(struct rsa_public_key *pub,\n\t\t     struct rsa_private_key *key,\n\t\t     void *random_ctx, nettle_random_func *random,\n\t\t     void *progress_ctx, nettle_progress_func *progress,\n\t\t     unsigned n_size,\n\t\t     unsigned e_size)\n{\n  mpz_t p1;\n  mpz_t q1;\n  mpz_t phi;\n  mpz_t tmp;\n\n  if (e_size)\n    {\n      /* We should choose e randomly. Is the size reasonable? */\n      if ((e_size < 16) || (e_size >= n_size) )\n\treturn 0;\n    }\n  else\n    {\n      /* We have a fixed e. Check that it makes sense */\n\n      /* It must be odd */\n      if (!mpz_tstbit(pub->e, 0))\n\treturn 0;\n\n      /* And 3 or larger */\n      if (mpz_cmp_ui(pub->e, 3) < 0)\n\treturn 0;\n\n      /* And size less than n */\n      if (mpz_sizeinbase(pub->e, 2) >= n_size)\n\treturn 0;\n    }\n\n  if (n_size < RSA_MINIMUM_N_BITS)\n    return 0;\n  \n  mpz_init(p1); mpz_init(q1); mpz_init(phi); mpz_init(tmp);\n\n  /* Generate primes */\n  for (;;)\n    {\n      /* Generate p, such that gcd(p-1, e) = 1 */\n      for (;;)\n\t{\n\t  nettle_random_prime(key->p, (n_size+1)/2, 1,\n\t\t\t      random_ctx, random,\n\t\t\t      progress_ctx, progress);\n\n\t  mpz_sub_ui(p1, key->p, 1);\n      \n\t  /* If e was given, we must chose p such that p-1 has no factors in\n\t   * common with e. */\n\t  if (e_size)\n\t    break;\n\t  \n\t  mpz_gcd(tmp, pub->e, p1);\n\n\t  if (mpz_cmp_ui(tmp, 1) == 0)\n\t    break;\n\t  else if (progress) progress(progress_ctx, 'c');\n\t} \n\n      if (progress)\n\tprogress(progress_ctx, '\\n');\n      \n      /* Generate q, such that gcd(q-1, e) = 1 */\n      for (;;)\n\t{\n\t  nettle_random_prime(key->q, n_size/2, 1,\n\t\t\t      random_ctx, random,\n\t\t\t      progress_ctx, progress);\n\n\t  /* Very unlikely. */\n\t  if (mpz_cmp (key->q, key->p) == 0)\n\t    continue;\n\n\t  mpz_sub_ui(q1, key->q, 1);\n      \n\t  /* If e was given, we must chose q such that q-1 has no factors in\n\t   * common with e. */\n\t  if (e_size)\n\t    break;\n\t  \n\t  mpz_gcd(tmp, pub->e, q1);\n\n\t  if (mpz_cmp_ui(tmp, 1) == 0)\n\t    break;\n\t  else if (progress) progress(progress_ctx, 'c');\n\t}\n\n      /* Now we have the primes. Is the product of the right size? */\n      mpz_mul(pub->n, key->p, key->q);\n\n      assert (mpz_sizeinbase(pub->n, 2) == n_size);\n\n      if (progress)\n\tprogress(progress_ctx, '\\n');\n\n      /* c = q^{-1} (mod p) */\n      if (mpz_invert(key->c, key->q, key->p))\n\t/* This should succeed everytime. But if it doesn't,\n\t * we try again. */\n\tbreak;\n      else if (progress) progress(progress_ctx, '?');\n    }\n\n  mpz_mul(phi, p1, q1);\n  \n  /* If we didn't have a given e, generate one now. */\n  if (e_size)\n    {\n      int retried = 0;\n      for (;;)\n\t{\n\t  nettle_mpz_random_size(pub->e,\n\t\t\t\t random_ctx, random,\n\t\t\t\t e_size);\n\t\n\t  /* Make sure it's odd and that the most significant bit is\n\t   * set */\n\t  mpz_setbit(pub->e, 0);\n\t  mpz_setbit(pub->e, e_size - 1);\n\n\t  /* Needs gmp-3, or inverse might be negative. */\n\t  if (mpz_invert(key->d, pub->e, phi))\n\t    break;\n\n\t  if (progress) progress(progress_ctx, 'e');\n\t  retried = 1;\n\t}\n      if (retried && progress)\n\tprogress(progress_ctx, '\\n');\t\n    }\n  else\n    {\n      /* Must always succeed, as we already that e\n       * doesn't have any common factor with p-1 or q-1. */\n      int res = mpz_invert(key->d, pub->e, phi);\n      assert(res);\n    }\n\n  /* Done! Almost, we must compute the auxillary private values. */\n  /* a = d % (p-1) */\n  mpz_fdiv_r(key->a, key->d, p1);\n\n  /* b = d % (q-1) */\n  mpz_fdiv_r(key->b, key->d, q1);\n\n  /* c was computed earlier */\n\n  pub->size = key->size = (n_size + 7) / 8;\n  assert(pub->size >= RSA_MINIMUM_N_OCTETS);\n  \n  mpz_clear(p1); mpz_clear(q1); mpz_clear(phi); mpz_clear(tmp);\n\n  return 1;\n}",
      "lines": 160,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-md5-sign-tr.c": {
    "rsa_md5_sign_tr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrsa_md5_sign_tr(const struct rsa_public_key *pub,\n\t\tconst struct rsa_private_key *key,\n\t\tvoid *random_ctx, nettle_random_func *random,\n\t\tstruct md5_ctx *hash, mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n  res = (pkcs1_rsa_md5_encode(m, key->size, hash)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n  mpz_clear (m);\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_md5_sign_digest_tr": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "int\nrsa_md5_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t       const struct rsa_private_key *key,\n\t\t       void *random_ctx, nettle_random_func *random,\n\t\t       const uint8_t *digest, mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pkcs1_rsa_md5_encode_digest(m, key->size, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-md5-sign.c": {
    "rsa_md5_sign": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_md5_sign(const struct rsa_private_key *key,\n             struct md5_ctx *hash,\n             mpz_t s)\n{\n  if (pkcs1_rsa_md5_encode(s, key->size, hash))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rsa_md5_sign_digest": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nrsa_md5_sign_digest(const struct rsa_private_key *key,\n\t\t    const uint8_t *digest,\n\t\t    mpz_t s)\n{\n  if (pkcs1_rsa_md5_encode_digest(s, key->size, digest))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }  \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-md5-verify.c": {
    "rsa_md5_verify": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrsa_md5_verify(const struct rsa_public_key *key,\n               struct md5_ctx *hash,\n               const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n\n  res = (pkcs1_rsa_md5_encode(m, key->size, hash)\n\t && _rsa_verify(key, m, s));\n\n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_md5_verify_digest": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrsa_md5_verify_digest(const struct rsa_public_key *key,\n\t\t      const uint8_t *digest,\n\t\t      const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_md5_encode_digest(m, key->size, digest)\n\t && _rsa_verify(key, m, s));\n\n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pkcs1-sign-tr.c": {
    "rsa_pkcs1_sign_tr": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nrsa_pkcs1_sign_tr(const struct rsa_public_key *pub,\n  \t          const struct rsa_private_key *key,\n\t          void *random_ctx, nettle_random_func *random,\n\t          size_t length, const uint8_t *digest_info,\n   \t          mpz_t s)\n{\n  mpz_t m;\n  int ret;\n\n  mpz_init(m);\n\n  ret = (pkcs1_rsa_digest_encode (m, key->size, length, digest_info)\n\t && rsa_compute_root_tr (pub, key, random_ctx, random,\n\t\t\t\t s, m));\n  mpz_clear(m);\n  return ret;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pkcs1-sign.c": {
    "rsa_pkcs1_sign": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "int\nrsa_pkcs1_sign(const struct rsa_private_key *key,\n\t       size_t length, const uint8_t *digest_info,\n\t       mpz_t s)\n{  \n  if (pkcs1_rsa_digest_encode (s, key->size, length, digest_info))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }    \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pkcs1-verify.c": {
    "rsa_pkcs1_verify": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "int\nrsa_pkcs1_verify(const struct rsa_public_key *key,\n\t\t size_t length, const uint8_t *digest_info,\n\t\t const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init (m);\n\n  res = (pkcs1_rsa_digest_encode (m, key->size, length, digest_info)\n\t && _rsa_verify (key, m, s));\n\n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pss-sha256-sign-tr.c": {
    "rsa_pss_sha256_sign_digest_tr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nrsa_pss_sha256_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\t      const struct rsa_private_key *key,\n\t\t\t      void *random_ctx, nettle_random_func *random,\n\t\t\t      size_t salt_length, const uint8_t *salt,\n\t\t\t      const uint8_t *digest,\n\t\t\t      mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pss_encode_mgf1(m, mpz_sizeinbase(pub->n, 2) - 1, &nettle_sha256,\n\t\t\t salt_length, salt, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pss-sha256-verify.c": {
    "rsa_pss_sha256_verify_digest": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_pss_sha256_verify_digest(const struct rsa_public_key *key,\n\t\t\t     size_t salt_length,\n\t\t\t     const uint8_t *digest,\n\t\t\t     const mpz_t signature)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init (m);\n\n  res = (_rsa_verify_recover(key, m, signature) &&\n\t pss_verify_mgf1(m, mpz_sizeinbase(key->n, 2) - 1, &nettle_sha256,\n\t\t\t salt_length, digest));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pss-sha512-sign-tr.c": {
    "rsa_pss_sha384_sign_digest_tr": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\nrsa_pss_sha384_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\t      const struct rsa_private_key *key,\n\t\t\t      void *random_ctx, nettle_random_func *random,\n\t\t\t      size_t salt_length, const uint8_t *salt,\n\t\t\t      const uint8_t *digest,\n\t\t\t      mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pss_encode_mgf1(m, mpz_sizeinbase(pub->n, 2) - 1, &nettle_sha384,\n\t\t\t salt_length, salt, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rsa_pss_sha512_sign_digest_tr": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "int\nrsa_pss_sha512_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\t      const struct rsa_private_key *key,\n\t\t\t      void *random_ctx, nettle_random_func *random,\n\t\t\t      size_t salt_length, const uint8_t *salt,\n\t\t\t      const uint8_t *digest,\n\t\t\t      mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pss_encode_mgf1(m, mpz_sizeinbase(pub->n, 2) - 1, &nettle_sha512,\n\t\t\t salt_length, salt, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 22,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-pss-sha512-verify.c": {
    "rsa_pss_sha384_verify_digest": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_pss_sha384_verify_digest(const struct rsa_public_key *key,\n\t\t\t     size_t salt_length,\n\t\t\t     const uint8_t *digest,\n\t\t\t     const mpz_t signature)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init (m);\n\n  res = (_rsa_verify_recover(key, m, signature) &&\n\t pss_verify_mgf1(m, mpz_sizeinbase(key->n, 2) - 1, &nettle_sha384,\n\t\t\t salt_length, digest));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    },
    "rsa_pss_sha512_verify_digest": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrsa_pss_sha512_verify_digest(const struct rsa_public_key *key,\n\t\t\t     size_t salt_length,\n\t\t\t     const uint8_t *digest,\n\t\t\t     const mpz_t signature)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init (m);\n\n  res = (_rsa_verify_recover(key, m, signature) &&\n\t pss_verify_mgf1(m, mpz_sizeinbase(key->n, 2) - 1, &nettle_sha512,\n\t\t\t salt_length, digest));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sec-compute-root.c": {
    "sec_mul_itch": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static mp_size_t\nsec_mul_itch (mp_size_t an, mp_size_t bn)\n{\n  if (an >= bn)\n    return mpn_sec_mul_itch (an, bn);\n  else\n    return mpn_sec_mul_itch (bn, an);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "sec_mul": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\nsec_mul (mp_limb_t *rp,\n\t const mp_limb_t *ap, mp_size_t an,\n\t const mp_limb_t *bp, mp_size_t bn, mp_limb_t *scratch)\n{\n  if (an >= bn)\n    mpn_sec_mul (rp, ap, an, bp, bn, scratch);\n  else\n    mpn_sec_mul (rp, bp, bn, ap, an, scratch);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sec_mod_mul_itch": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static mp_size_t\nsec_mod_mul_itch (mp_size_t an, mp_size_t bn, mp_size_t mn)\n{\n  mp_size_t mul_itch = sec_mul_itch (an, bn);\n  mp_size_t mod_itch = mpn_sec_div_r_itch (an + bn, mn);\n  return MAX(mul_itch, mod_itch);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "sec_mod_mul": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void\nsec_mod_mul (mp_limb_t *rp,\n\t     const mp_limb_t *ap, mp_size_t an,\n\t     const mp_limb_t *bp, mp_size_t bn,\n\t     const mp_limb_t *mp, mp_size_t mn,\n\t     mp_limb_t *scratch)\n{\n  assert (an + bn >= mn);\n  sec_mul (rp, ap, an, bp, bn, scratch);\n  mpn_sec_div_r (rp, an + bn, mp, mn, scratch);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sec_powm_itch": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static mp_size_t\nsec_powm_itch (mp_size_t bn, mp_size_t en, mp_size_t mn)\n{\n  mp_size_t mod_itch = bn + mpn_sec_div_r_itch (bn, mn);\n  mp_size_t pow_itch = mn + mpn_sec_powm_itch (mn, en * GMP_NUMB_BITS, mn);\n  return MAX (mod_itch, pow_itch);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_size_t"
      ]
    },
    "sec_powm": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nsec_powm (mp_limb_t *rp,\n\t  const mp_limb_t *bp, mp_size_t bn,\n\t  const mp_limb_t *ep, mp_size_t en,\n\t  const mp_limb_t *mp, mp_size_t mn, mp_limb_t *scratch)\n{\n  assert (bn >= mn);\n  assert (en <= mn);\n  mpn_copyi (scratch, bp, bn);\n  mpn_sec_div_r (scratch, bn, mp, mn, scratch + bn);\n  mpn_sec_powm (rp, scratch, mn, ep, en * GMP_NUMB_BITS, mp, mn,\n\t\tscratch + mn);\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_rsa_sec_compute_root_itch": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "mp_size_t\n_rsa_sec_compute_root_itch (const struct rsa_private_key *key)\n{\n  mp_size_t nn = NETTLE_OCTET_SIZE_TO_LIMB_SIZE (key->size);\n  mp_size_t pn = mpz_size (key->p);\n  mp_size_t qn = mpz_size (key->q);\n  mp_size_t an = mpz_size (key->a);\n  mp_size_t bn = mpz_size (key->b);\n  mp_size_t cn = mpz_size (key->c);\n\n  mp_size_t powm_p_itch = sec_powm_itch (nn, an, pn);\n  mp_size_t powm_q_itch = sec_powm_itch (nn, bn, qn);\n  mp_size_t mod_mul_itch = cn + MAX(pn, qn) \n    + sec_mod_mul_itch (MAX(pn, qn), cn, pn);\n\n  mp_size_t mul_itch = sec_mul_itch (qn, pn);\n  mp_size_t add_1_itch = mpn_sec_add_1_itch (nn - qn);\n\n  /* pn + qn for the product q * r_mod_p' */\n  mp_size_t itch = pn + qn + MAX (mul_itch, add_1_itch);\n\n  itch = MAX (itch, powm_p_itch);\n  itch = MAX (itch, powm_q_itch);\n  itch = MAX (itch, mod_mul_itch);\n\n  /* pn + qn for the r_mod_p and r_mod_q temporaries. */\n  return pn + qn + itch;\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "mp_size_t"
      ]
    },
    "_rsa_sec_compute_root": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        193,
        1
      ],
      "content": "void\n_rsa_sec_compute_root (const struct rsa_private_key *key,\n\t\t       mp_limb_t *rp, const mp_limb_t *mp,\n\t\t       mp_limb_t *scratch)\n{\n  mp_size_t nn = NETTLE_OCTET_SIZE_TO_LIMB_SIZE (key->size);\n\n  /* The common case is pn = qn. This function would be simpler if we\n   * could require that pn >= qn. */\n  const mp_limb_t *pp = mpz_limbs_read (key->p);\n  const mp_limb_t *qp = mpz_limbs_read (key->q);\n\n  mp_size_t pn = mpz_size (key->p);\n  mp_size_t qn = mpz_size (key->q);\n  mp_size_t an = mpz_size (key->a);\n  mp_size_t bn = mpz_size (key->b);\n  mp_size_t cn = mpz_size (key->c);\n\n  mp_limb_t *r_mod_p = scratch;\n  mp_limb_t *r_mod_q = scratch + pn;\n  mp_limb_t *scratch_out = r_mod_q + qn;\n  mp_limb_t cy;\n\n  assert (pn <= nn);\n  assert (qn <= nn);\n  assert (an <= pn);\n  assert (bn <= qn);\n  assert (cn <= pn);\n\n  /* Compute r_mod_p = m^d % p = (m%p)^a % p */\n  sec_powm (r_mod_p, mp, nn, mpz_limbs_read (key->a), an, pp, pn, scratch_out);\n  /* Compute r_mod_q = m^d % q = (m%q)^b % q */\n  sec_powm (r_mod_q, mp, nn, mpz_limbs_read (key->b), bn, qp, qn, scratch_out);\n\n  /* Set r_mod_p' = r_mod_p * c % p - r_mod_q * c % p . */\n  sec_mod_mul (scratch_out, r_mod_p, pn, mpz_limbs_read (key->c), cn, pp, pn,\n\t       scratch_out + cn + pn);\n  mpn_copyi (r_mod_p, scratch_out, pn);\n\n  sec_mod_mul (scratch_out, r_mod_q, qn, mpz_limbs_read (key->c), cn, pp, pn,\n\t       scratch_out + cn + qn);\n  cy = mpn_sub_n (r_mod_p, r_mod_p, scratch_out, pn);\n  cnd_add_n (cy, r_mod_p, pp, pn);\n\n  /* Finally, compute x = r_mod_q + q r_mod_p' */\n  sec_mul (scratch_out, qp, qn, r_mod_p, pn, scratch_out + pn + qn);\n\n  cy = mpn_add_n (rp, scratch_out, r_mod_q, qn);\n  mpn_sec_add_1 (rp + qn, scratch_out + qn, nn - qn, cy, scratch_out + pn + qn);\n}",
      "lines": 50,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sec-decrypt.c": {
    "rsa_sec_decrypt": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "int\nrsa_sec_decrypt(const struct rsa_public_key *pub,\n\t        const struct rsa_private_key *key,\n\t        void *random_ctx, nettle_random_func *random,\n\t        size_t length, uint8_t *message,\n\t        const mpz_t gibberish)\n{\n  TMP_GMP_DECL (m, mp_limb_t);\n  TMP_GMP_DECL (em, uint8_t);\n  int res;\n\n  TMP_GMP_ALLOC (m, mpz_size(pub->n));\n  TMP_GMP_ALLOC (em, key->size);\n\n  res = _rsa_sec_compute_root_tr (pub, key, random_ctx, random, m,\n\t\t\t\t  mpz_limbs_read(gibberish),\n\t\t\t\t  mpz_size(gibberish));\n\n  mpn_get_base256 (em, key->size, m, mpz_size(pub->n));\n\n  res &= _pkcs1_sec_decrypt (length, message, key->size, em);\n\n  TMP_GMP_FREE (em);\n  TMP_GMP_FREE (m);\n  return res;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha1-sign-tr.c": {
    "rsa_sha1_sign_tr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nrsa_sha1_sign_tr(const struct rsa_public_key *pub,\n\t\t const struct rsa_private_key *key,\n\t\t void *random_ctx, nettle_random_func *random,\n\t\t struct sha1_ctx *hash,\n\t\t mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n  res = (pkcs1_rsa_sha1_encode(m, key->size, hash)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha1_sign_digest_tr": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nrsa_sha1_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\tconst struct rsa_private_key *key,\n\t\t\tvoid *random_ctx, nettle_random_func *random,\n\t\t\tconst uint8_t *digest,\n\t\t\tmpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pkcs1_rsa_sha1_encode_digest(m, key->size, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha1-sign.c": {
    "rsa_sha1_sign": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_sha1_sign(const struct rsa_private_key *key,\n              struct sha1_ctx *hash,\n              mpz_t s)\n{\n  if (pkcs1_rsa_sha1_encode(s, key->size, hash))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha1_sign_digest": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nrsa_sha1_sign_digest(const struct rsa_private_key *key,\n\t\t     const uint8_t *digest,\n\t\t     mpz_t s)\n{\n  if (pkcs1_rsa_sha1_encode_digest(s, key->size, digest))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha1-verify.c": {
    "rsa_sha1_verify": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrsa_sha1_verify(const struct rsa_public_key *key,\n                struct sha1_ctx *hash,\n                const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_sha1_encode(m, key->size, hash)\n\t && _rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha1_verify_digest": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrsa_sha1_verify_digest(const struct rsa_public_key *key,\n\t\t       const uint8_t *digest,\n\t\t       const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_sha1_encode_digest(m, key->size, digest)\n\t && _rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha256-sign-tr.c": {
    "rsa_sha256_sign_tr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nrsa_sha256_sign_tr(const struct rsa_public_key *pub,\n\t\t   const struct rsa_private_key *key,\n\t\t   void *random_ctx, nettle_random_func *random,\n\t\t   struct sha256_ctx *hash,\n\t\t   mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n  res = (pkcs1_rsa_sha256_encode(m, key->size, hash)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha256_sign_digest_tr": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nrsa_sha256_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\t  const struct rsa_private_key *key,\n\t\t\t  void *random_ctx, nettle_random_func *random,\n\t\t\t  const uint8_t *digest,\n\t\t\t  mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pkcs1_rsa_sha256_encode_digest(m, key->size, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha256-sign.c": {
    "rsa_sha256_sign": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_sha256_sign(const struct rsa_private_key *key,\n\t\tstruct sha256_ctx *hash,\n\t\tmpz_t s)\n{\n  if (pkcs1_rsa_sha256_encode(s, key->size, hash))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }  \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha256_sign_digest": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nrsa_sha256_sign_digest(const struct rsa_private_key *key,\n\t\t       const uint8_t *digest,\n\t\t       mpz_t s)\n{\n  if (pkcs1_rsa_sha256_encode_digest(s, key->size, digest))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }  \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha256-verify.c": {
    "rsa_sha256_verify": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrsa_sha256_verify(const struct rsa_public_key *key,\n\t\t  struct sha256_ctx *hash,\n\t\t  const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n\n  res = (pkcs1_rsa_sha256_encode(m, key->size, hash)\n\t &&_rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha256_verify_digest": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrsa_sha256_verify_digest(const struct rsa_public_key *key,\n\t\t\t const uint8_t *digest,\n\t\t\t const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_sha256_encode_digest(m, key->size, digest)\n\t && _rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha512-sign-tr.c": {
    "rsa_sha512_sign_tr": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "int\nrsa_sha512_sign_tr(const struct rsa_public_key *pub,\n\t\t   const struct rsa_private_key *key,\n\t\t   void *random_ctx, nettle_random_func *random,\n\t\t   struct sha512_ctx *hash,\n\t\t   mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n  res = (pkcs1_rsa_sha512_encode(m, key->size, hash)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n  mpz_clear (m);\n  return res;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha512_sign_digest_tr": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "int\nrsa_sha512_sign_digest_tr(const struct rsa_public_key *pub,\n\t\t\t  const struct rsa_private_key *key,\n\t\t\t  void *random_ctx, nettle_random_func *random,\n\t\t\t  const uint8_t *digest,\n\t\t\t  mpz_t s)\n{\n  mpz_t m;\n  int res;\n\n  mpz_init (m);\n\n  res = (pkcs1_rsa_sha512_encode_digest(m, key->size, digest)\n\t && rsa_compute_root_tr (pub, key,\n\t\t\t\t random_ctx, random,\n\t\t\t\t s, m));\n\n  mpz_clear (m);\n  return res;\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha512-sign.c": {
    "rsa_sha512_sign": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nrsa_sha512_sign(const struct rsa_private_key *key,\n\t\tstruct sha512_ctx *hash,\n\t\tmpz_t s)\n{\n  if (pkcs1_rsa_sha512_encode(s, key->size, hash))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }  \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha512_sign_digest": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "int\nrsa_sha512_sign_digest(const struct rsa_private_key *key,\n\t\t       const uint8_t *digest,\n\t\t       mpz_t s)\n{\n  if (pkcs1_rsa_sha512_encode_digest(s, key->size, digest))\n    {\n      rsa_compute_root(key, s, s);\n      return 1;\n    }\n  else\n    {\n      mpz_set_ui(s, 0);\n      return 0;\n    }  \n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sha512-verify.c": {
    "rsa_sha512_verify": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nrsa_sha512_verify(const struct rsa_public_key *key,\n\t\t  struct sha512_ctx *hash,\n\t\t  const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_sha512_encode(m, key->size, hash) \n\t && _rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_sha512_verify_digest": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "int\nrsa_sha512_verify_digest(const struct rsa_public_key *key,\n\t\t\t const uint8_t *digest,\n\t\t\t const mpz_t s)\n{\n  int res;\n  mpz_t m;\n\n  mpz_init(m);\n  \n  res = (pkcs1_rsa_sha512_encode_digest(m, key->size, digest)\n\t && _rsa_verify(key, m, s));\n  \n  mpz_clear(m);\n\n  return res;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sign-tr.c": {
    "rsa_blind": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\nrsa_blind (const struct rsa_public_key *pub,\n\t   void *random_ctx, nettle_random_func *random,\n\t   mpz_t c, mpz_t ri, const mpz_t m)\n{\n  mpz_t r;\n\n  mpz_init(r);\n\n  /* c = m*(r^e)\n   * ri = r^(-1)\n   */\n  do\n    {\n      nettle_mpz_random(r, random_ctx, random, pub->n);\n      /* invert r */\n    }\n  while (!mpz_invert (ri, r, pub->n));\n\n  /* c = c*(r^e) mod n */\n  mpz_powm_sec(r, r, pub->e, pub->n);\n  mpz_mul(c, m, r);\n  mpz_fdiv_r(c, c, pub->n);\n\n  mpz_clear(r);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rsa_unblind": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void\nrsa_unblind (const struct rsa_public_key *pub,\n\t     mpz_t m, const mpz_t ri, const mpz_t c)\n{\n  mpz_mul(m, c, ri);\n  mpz_fdiv_r(m, m, pub->n);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rsa_compute_root_tr": [
      {
        "start_point": [
          89,
          0
        ],
        "end_point": [
          127,
          1
        ],
        "content": "int\nrsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  int res;\n  mpz_t t, mb, xb, ri;\n\n  /* mpz_powm_sec handles only odd moduli. If p, q or n is even, the\n     key is invalid and rejected by rsa_private_key_prepare. However,\n     some applications, notably gnutls, don't use this function, and\n     we don't want an invalid key to lead to a crash down inside\n     mpz_powm_sec. So do an additional check here. */\n  if (mpz_even_p (pub->n) || mpz_even_p (key->p) || mpz_even_p (key->q))\n    return 0;\n\n  mpz_init (mb);\n  mpz_init (xb);\n  mpz_init (ri);\n  mpz_init (t);\n\n  rsa_blind (pub, random_ctx, random, mb, ri, m);\n\n  rsa_compute_root (key, xb, mb);\n\n  mpz_powm_sec(t, xb, pub->e, pub->n);\n  res = (mpz_cmp(mb, t) == 0);\n\n  if (res)\n    rsa_unblind (pub, x, ri, xb);\n\n  mpz_clear (mb);\n  mpz_clear (xb);\n  mpz_clear (ri);\n  mpz_clear (t);\n\n  return res;\n}",
        "lines": 39,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          351,
          0
        ],
        "end_point": [
          373,
          1
        ],
        "content": "int\nrsa_compute_root_tr(const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *key,\n\t\t    void *random_ctx, nettle_random_func *random,\n\t\t    mpz_t x, const mpz_t m)\n{\n  TMP_GMP_DECL (l, mp_limb_t);\n  int res;\n\n  mp_size_t l_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);\n  TMP_GMP_ALLOC (l, l_size);\n\n  res = _rsa_sec_compute_root_tr (pub, key, random_ctx, random, l,\n\t\t\t\t  mpz_limbs_read(m), mpz_size(m));\n  if (res) {\n    mp_limb_t *xp = mpz_limbs_write (x, l_size);\n    mpn_copyi (xp, l, l_size);\n    mpz_limbs_finish (x, l_size);\n  }\n\n  TMP_GMP_FREE (l);\n  return res;\n}",
        "lines": 23,
        "depth": 9,
        "decorators": [
          "int"
        ]
      }
    ],
    "_rsa_sec_compute_root_tr": [
      {
        "start_point": [
          129,
          0
        ],
        "end_point": [
          153,
          1
        ],
        "content": "int\n_rsa_sec_compute_root_tr(const struct rsa_public_key *pub,\n\t\t\t const struct rsa_private_key *key,\n\t\t\t void *random_ctx, nettle_random_func *random,\n\t\t\t mp_limb_t *x, const mp_limb_t *m, size_t mn)\n{\n  mpz_t mz;\n  mpz_t xz;\n  int res;\n\n  mpz_init(mz);\n  mpz_init(xz);\n\n  mpn_copyi(mpz_limbs_write(mz, mn), m, mn);\n  mpz_limbs_finish(mz, mn);\n\n  res = rsa_compute_root_tr(pub, key, random_ctx, random, xz, mz);\n\n  if (res)\n    mpz_limbs_copy(x, xz, mpz_size(pub->n));\n\n  mpz_clear(mz);\n  mpz_clear(xz);\n  return res;\n}",
        "lines": 25,
        "depth": 10,
        "decorators": [
          "int"
        ]
      },
      {
        "start_point": [
          296,
          0
        ],
        "end_point": [
          342,
          1
        ],
        "content": "int\n_rsa_sec_compute_root_tr(const struct rsa_public_key *pub,\n\t\t\t const struct rsa_private_key *key,\n\t\t\t void *random_ctx, nettle_random_func *random,\n\t\t\t mp_limb_t *x, const mp_limb_t *m, size_t mn)\n{\n  TMP_GMP_DECL (c, mp_limb_t);\n  TMP_GMP_DECL (ri, mp_limb_t);\n  TMP_GMP_DECL (scratch, mp_limb_t);\n  size_t key_limb_size;\n  int ret;\n\n  key_limb_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);\n\n  /* mpz_powm_sec handles only odd moduli. If p, q or n is even, the\n     key is invalid and rejected by rsa_private_key_prepare. However,\n     some applications, notably gnutls, don't use this function, and\n     we don't want an invalid key to lead to a crash down inside\n     mpz_powm_sec. So do an additional check here. */\n  if (mpz_even_p (pub->n) || mpz_even_p (key->p) || mpz_even_p (key->q))\n    {\n      mpn_zero(x, key_limb_size);\n      return 0;\n    }\n\n  assert(mpz_size(pub->n) == key_limb_size);\n  assert(mn <= key_limb_size);\n\n  TMP_GMP_ALLOC (c, key_limb_size);\n  TMP_GMP_ALLOC (ri, key_limb_size);\n  TMP_GMP_ALLOC (scratch, _rsa_sec_compute_root_itch(key));\n\n  rsa_sec_blind (pub, random_ctx, random, x, ri, m, mn);\n\n  _rsa_sec_compute_root(key, c, x, scratch);\n\n  ret = rsa_sec_check_root(pub, c, x);\n\n  rsa_sec_unblind(pub, x, ri, c);\n\n  cnd_mpn_zero(1 - ret, x, key_limb_size);\n\n  TMP_GMP_FREE (scratch);\n  TMP_GMP_FREE (ri);\n  TMP_GMP_FREE (c);\n  return ret;\n}",
        "lines": 47,
        "depth": 10,
        "decorators": [
          "int"
        ]
      }
    ],
    "rsa_sec_blind": {
      "start_point": [
        157,
        0
      ],
      "end_point": [
        208,
        1
      ],
      "content": "static void\nrsa_sec_blind (const struct rsa_public_key *pub,\n               void *random_ctx, nettle_random_func *random,\n               mp_limb_t *c, mp_limb_t *ri, const mp_limb_t *m,\n               mp_size_t mn)\n{\n  const mp_limb_t *ep = mpz_limbs_read (pub->e);\n  const mp_limb_t *np = mpz_limbs_read (pub->n);\n  mp_bitcnt_t ebn = mpz_sizeinbase (pub->e, 2);\n  mp_size_t nn = mpz_size (pub->n);\n  size_t itch;\n  size_t i2;\n  mp_limb_t *scratch;\n  TMP_GMP_DECL (tp, mp_limb_t);\n  TMP_GMP_DECL (rp, mp_limb_t);\n  TMP_GMP_DECL (r, uint8_t);\n\n  TMP_GMP_ALLOC (rp, nn);\n  TMP_GMP_ALLOC (r, nn * sizeof(mp_limb_t));\n\n  /* c = m*(r^e) mod n */\n  itch = mpn_sec_powm_itch(nn, ebn, nn);\n  i2 = mpn_sec_mul_itch(nn, mn);\n  itch = MAX(itch, i2);\n  i2 = mpn_sec_div_r_itch(nn + mn, nn);\n  itch = MAX(itch, i2);\n  i2 = mpn_sec_invert_itch(nn);\n  itch = MAX(itch, i2);\n\n  TMP_GMP_ALLOC (tp, nn + mn + itch);\n  scratch = tp + nn + mn;\n\n  /* ri = r^(-1) */\n  do\n    {\n      random(random_ctx, nn * sizeof(mp_limb_t), (uint8_t *)r);\n      mpn_set_base256(rp, nn, r, nn * sizeof(mp_limb_t));\n      mpn_copyi(tp, rp, nn);\n      /* invert r */\n    }\n  while (!mpn_sec_invert (ri, tp, np, nn, 2 * nn * GMP_NUMB_BITS, scratch));\n\n  mpn_sec_powm (c, rp, nn, ep, ebn, np, nn, scratch);\n  /* normally mn == nn, but m can be smaller in some cases */\n  mpn_sec_mul (tp, c, nn, m, mn, scratch);\n  mpn_sec_div_r (tp, nn + mn, np, nn, scratch);\n  mpn_copyi(c, tp, nn);\n\n  TMP_GMP_FREE (r);\n  TMP_GMP_FREE (rp);\n  TMP_GMP_FREE (tp);\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "rsa_sec_unblind": {
      "start_point": [
        211,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\nrsa_sec_unblind (const struct rsa_public_key *pub,\n                 mp_limb_t *x, mp_limb_t *ri, const mp_limb_t *c)\n{\n  const mp_limb_t *np = mpz_limbs_read (pub->n);\n  mp_size_t nn = mpz_size (pub->n);\n\n  size_t itch;\n  size_t i2;\n  mp_limb_t *scratch;\n  TMP_GMP_DECL(tp, mp_limb_t);\n\n  itch = mpn_sec_mul_itch(nn, nn);\n  i2 = mpn_sec_div_r_itch(nn + nn, nn);\n  itch = MAX(itch, i2);\n\n  TMP_GMP_ALLOC (tp, nn + nn + itch);\n  scratch = tp + nn + nn;\n\n  mpn_sec_mul (tp, c, nn, ri, nn, scratch);\n  mpn_sec_div_r (tp, nn + nn, np, nn, scratch);\n  mpn_copyi(x, tp, nn);\n\n  TMP_GMP_FREE (tp);\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sec_equal": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        249,
        1
      ],
      "content": "static int\nsec_equal(const mp_limb_t *a, const mp_limb_t *b, size_t limbs)\n{\n  volatile mp_limb_t z = 0;\n\n  for (size_t i = 0; i < limbs; i++)\n    {\n      z |= (a[i] ^ b[i]);\n    }\n\n  /* FIXME: Might compile to a branch instruction on some platforms. */\n  return z == 0;\n}",
      "lines": 13,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "rsa_sec_check_root": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static int\nrsa_sec_check_root(const struct rsa_public_key *pub,\n                   const mp_limb_t *x, const mp_limb_t *m)\n{\n  mp_size_t nn = mpz_size (pub->n);\n  mp_size_t ebn = mpz_sizeinbase (pub->e, 2);\n  const mp_limb_t *np = mpz_limbs_read (pub->n);\n  const mp_limb_t *ep = mpz_limbs_read (pub->e);\n  int ret;\n\n  mp_size_t itch;\n\n  mp_limb_t *scratch;\n  TMP_GMP_DECL(tp, mp_limb_t);\n\n  itch = mpn_sec_powm_itch (nn, ebn, nn);\n  TMP_GMP_ALLOC (tp, nn + itch);\n  scratch = tp + nn;\n\n  mpn_sec_powm(tp, x, nn, ep, ebn, np, nn, scratch);\n  ret = sec_equal(tp, m, nn);\n\n  TMP_GMP_FREE (tp);\n  return ret;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cnd_mpn_zero": {
      "start_point": [
        277,
        0
      ],
      "end_point": [
        289,
        1
      ],
      "content": "static void\ncnd_mpn_zero (int cnd, volatile mp_ptr rp, mp_size_t n)\n{\n  volatile mp_limb_t c;\n  volatile mp_limb_t mask = (mp_limb_t) cnd - 1;\n\n  while (--n >= 0)\n    {\n      c = rp[n];\n      c &= mask;\n      rp[n] = c;\n    }\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa-sign.c": {
    "rsa_private_key_init": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "void\nrsa_private_key_init(struct rsa_private_key *key)\n{\n  mpz_init(key->d);\n  mpz_init(key->p);\n  mpz_init(key->q);\n  mpz_init(key->a);\n  mpz_init(key->b);\n  mpz_init(key->c);\n\n  /* Not really necessary, but it seems cleaner to initialize all the\n   * storage. */\n  key->size = 0;\n}",
      "lines": 14,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rsa_private_key_clear": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nrsa_private_key_clear(struct rsa_private_key *key)\n{\n  mpz_clear(key->d);\n  mpz_clear(key->p);\n  mpz_clear(key->q);\n  mpz_clear(key->a);\n  mpz_clear(key->b);\n  mpz_clear(key->c);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rsa_private_key_prepare": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nrsa_private_key_prepare(struct rsa_private_key *key)\n{\n  mpz_t n;\n\n  /* A key is invalid if the sizes of q and c are smaller than\n   * the size of n, we rely on that property in calculations so\n   * fail early if that happens. */\n  if (mpz_size (key->q) + mpz_size (key->c) < mpz_size(key->p))\n    return 0;\n\n  /* The size of the product is the sum of the sizes of the factors,\n   * or sometimes one less. It's possible but tricky to compute the\n   * size without computing the full product. */\n\n  mpz_init(n);\n  mpz_mul(n, key->p, key->q);\n\n  key->size = _rsa_check_size(n);\n\n  mpz_clear(n);\n\n  return (key->size > 0);\n}",
      "lines": 24,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_compute_root": [
      {
        "start_point": [
          97,
          0
        ],
        "end_point": [
          153,
          1
        ],
        "content": "void\nrsa_compute_root(const struct rsa_private_key *key,\n\t\t mpz_t x, const mpz_t m)\n{\n  mpz_t xp; /* modulo p */\n  mpz_t xq; /* modulo q */\n\n  mpz_init(xp); mpz_init(xq);    \n\n  /* Compute xq = m^d % q = (m%q)^b % q */\n  mpz_fdiv_r(xq, m, key->q);\n  mpz_powm_sec(xq, xq, key->b, key->q);\n\n  /* Compute xp = m^d % p = (m%p)^a % p */\n  mpz_fdiv_r(xp, m, key->p);\n  mpz_powm_sec(xp, xp, key->a, key->p);\n\n  /* Set xp' = (xp - xq) c % p. */\n  mpz_sub(xp, xp, xq);\n  mpz_mul(xp, xp, key->c);\n  mpz_fdiv_r(xp, xp, key->p);\n\n  /* Finally, compute x = xq + q xp'\n   *\n   * To prove that this works, note that\n   *\n   *   xp  = x + i p,\n   *   xq  = x + j q,\n   *   c q = 1 + k p\n   *\n   * for some integers i, j and k. Now, for some integer l,\n   *\n   *   xp' = (xp - xq) c + l p\n   *       = (x + i p - (x + j q)) c + l p\n   *       = (i p - j q) c + l p\n   *       = (i c + l) p - j (c q)\n   *       = (i c + l) p - j (1 + kp)\n   *       = (i c + l - j k) p - j\n   *\n   * which shows that xp' = -j (mod p). We get\n   *\n   *   xq + q xp' = x + j q + (i c + l - j k) p q - j q\n   *              = x + (i c + l - j k) p q\n   *\n   * so that\n   *\n   *   xq + q xp' = x (mod pq)\n   *\n   * We also get 0 <= xq + q xp' < p q, because\n   *\n   *   0 <= xq < q and 0 <= xp' < p.\n   */\n  mpz_mul(x, key->q, xp);\n  mpz_add(x, x, xq);\n\n  mpz_clear(xp); mpz_clear(xq);\n}",
        "lines": 57,
        "depth": 7,
        "decorators": [
          "void"
        ]
      },
      {
        "start_point": [
          158,
          0
        ],
        "end_point": [
          184,
          1
        ],
        "content": "void\nrsa_compute_root(const struct rsa_private_key *key,\n\t\t mpz_t x, const mpz_t m)\n{\n  TMP_GMP_DECL (scratch, mp_limb_t);\n  TMP_GMP_DECL (ml, mp_limb_t);\n  mp_limb_t *xl;\n  size_t key_size;\n\n  key_size = NETTLE_OCTET_SIZE_TO_LIMB_SIZE(key->size);\n  assert(mpz_size (m) <= key_size);\n\n  /* we need a copy because m can be shorter than key_size,\n   * but _rsa_sec_compute_root expect all inputs to be\n   * normalized to a key_size long buffer length */\n  TMP_GMP_ALLOC (ml, key_size);\n  mpz_limbs_copy(ml, m, key_size);\n\n  TMP_GMP_ALLOC (scratch, _rsa_sec_compute_root_itch(key));\n\n  xl = mpz_limbs_write (x, key_size);\n  _rsa_sec_compute_root (key, xl, ml, scratch);\n  mpz_limbs_finish (x, key_size);\n\n  TMP_GMP_FREE (ml);\n  TMP_GMP_FREE (scratch);\n}",
        "lines": 27,
        "depth": 9,
        "decorators": [
          "void"
        ]
      }
    ]
  },
  "nettle/nettle-3.4.1/rsa-verify.c": {
    "_rsa_verify": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "int\n_rsa_verify(const struct rsa_public_key *key,\n\t    const mpz_t m,\n\t    const mpz_t s)\n{\n  int res;\n  \n  mpz_t m1;\n  \n  if ( (mpz_sgn(s) <= 0)\n       || (mpz_cmp(s, key->n) >= 0) )\n    return 0;\n       \n  mpz_init(m1);\n  \n  mpz_powm(m1, s, key->e, key->n);\n\n  res = !mpz_cmp(m, m1);\n\n  mpz_clear(m1);\n\n  return res;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "_rsa_verify_recover": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "int\n_rsa_verify_recover(const struct rsa_public_key *key,\n\t\t    mpz_t m,\n\t\t    const mpz_t s)\n{\n  if ( (mpz_sgn(s) <= 0)\n       || (mpz_cmp(s, key->n) >= 0) )\n    return 0;\n\n  mpz_powm(m, s, key->e, key->n);\n\n  return 1;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa.c": {
    "rsa_public_key_init": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\nrsa_public_key_init(struct rsa_public_key *key)\n{\n  mpz_init(key->n);\n  mpz_init(key->e);\n\n  /* Not really necessary, but it seems cleaner to initialize all the\n   * storage. */\n  key->size = 0;\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "rsa_public_key_clear": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nrsa_public_key_clear(struct rsa_public_key *key)\n{\n  mpz_clear(key->n);\n  mpz_clear(key->e);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "_rsa_check_size": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "size_t\n_rsa_check_size(mpz_t n)\n{\n  /* Round upwards */\n  size_t size;\n\n  /* Even moduli are invalid, and not supported by mpz_powm_sec. */\n  if (mpz_even_p (n))\n    return 0;\n\n  size = (mpz_sizeinbase(n, 2) + 7) / 8;\n\n  if (size < RSA_MINIMUM_N_OCTETS)\n    return 0;\n\n  return size;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "size_t"
      ]
    },
    "rsa_public_key_prepare": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "int\nrsa_public_key_prepare(struct rsa_public_key *key)\n{\n  key->size = _rsa_check_size(key->n);\n  \n  return (key->size > 0);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa.h": {},
  "nettle/nettle-3.4.1/rsa2openpgp.c": {
    "rsa_keypair_to_openpgp": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nrsa_keypair_to_openpgp(struct nettle_buffer *buffer,\n\t\t       const struct rsa_public_key *pub,\n\t\t       const struct rsa_private_key *priv,\n\t\t       /* A single user id. NUL-terminated utf8. */\n\t\t       const char *userid)\n{\n  time_t now = time(NULL);\n\n  unsigned key_start;\n  unsigned userid_start;\n  \n  struct sha1_ctx key_hash;\n  struct sha1_ctx signature_hash;\n  uint8_t fingerprint[SHA1_DIGEST_SIZE];\n  \n  key_start = buffer->size;\n  \n  if (!pgp_put_public_rsa_key(buffer, pub, now))\n    return 0;\n\n  /* userid packet */\n  userid_start = buffer->size;\n  if (!pgp_put_userid(buffer, strlen(userid), (const uint8_t *) userid))\n    return 0;\n\n  /* FIXME: We hash the key first, and then the user id. Is this right? */\n  sha1_init(&key_hash);\n  sha1_update(&key_hash,\n\t      userid_start - key_start,\n\t      buffer->contents + key_start);\n\n  signature_hash = key_hash;\n  sha1_digest(&key_hash, sizeof(fingerprint), fingerprint);\n\n  sha1_update(&signature_hash,\n\t      buffer->size - userid_start,\n\t      buffer->contents + userid_start);\n  \n  return pgp_put_rsa_sha1_signature(buffer,\n\t\t\t\t    priv,\n\t\t\t\t    fingerprint + SHA1_DIGEST_SIZE - 8,\n\t\t\t\t    PGP_SIGN_CERTIFICATION,\n\t\t\t\t    &signature_hash);\n}",
      "lines": 45,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/rsa2sexp.c": {
    "rsa_keypair_to_sexp": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "int\nrsa_keypair_to_sexp(struct nettle_buffer *buffer,\n\t\t    const char *algorithm_name,\n\t\t    const struct rsa_public_key *pub,\n\t\t    const struct rsa_private_key *priv)\n{\n  if (!algorithm_name)\n    algorithm_name = \"rsa-pkcs1\";\n  \n  if (priv)\n    return sexp_format(buffer,\n\t\t       \"(private-key(%0s(n%b)(e%b)\"\n\t\t       \"(d%b)(p%b)(q%b)(a%b)(b%b)(c%b)))\",\n\t\t       algorithm_name, pub->n, pub->e,\n\t\t       priv->d, priv->p, priv->q,\n\t\t       priv->a, priv->b, priv->c);\n  else\n    return sexp_format(buffer, \"(public-key(%0s(n%b)(e%b)))\",\n\t\t       algorithm_name, pub->n, pub->e);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-128-set-key.c": {
    "salsa20_128_set_key": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nsalsa20_128_set_key(struct salsa20_ctx *ctx, const uint8_t *key)\n{\n  ctx->input[11] = ctx->input[1] = LE_READ_UINT32(key + 0);\n  ctx->input[12] = ctx->input[2] = LE_READ_UINT32(key + 4);\n  ctx->input[13] = ctx->input[3] = LE_READ_UINT32(key + 8);\n  ctx->input[14] = ctx->input[4] = LE_READ_UINT32(key + 12);\n\n  /* \"expand 16-byte k\" */\n  ctx->input[0]  = 0x61707865;\n  ctx->input[5]  = 0x3120646e;\n  ctx->input[10] = 0x79622d36;\n  ctx->input[15] = 0x6b206574;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-256-set-key.c": {
    "salsa20_256_set_key": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\nsalsa20_256_set_key(struct salsa20_ctx *ctx, const uint8_t *key)\n{\n  ctx->input[1] = LE_READ_UINT32(key + 0);\n  ctx->input[2] = LE_READ_UINT32(key + 4);\n  ctx->input[3] = LE_READ_UINT32(key + 8);\n  ctx->input[4] = LE_READ_UINT32(key + 12);\n\n  ctx->input[11] = LE_READ_UINT32(key + 16);\n  ctx->input[12] = LE_READ_UINT32(key + 20);\n  ctx->input[13] = LE_READ_UINT32(key + 24);\n  ctx->input[14] = LE_READ_UINT32(key + 28);\n\n  /* \"expand 32-byte k\" */\n  ctx->input[0]  = 0x61707865;\n  ctx->input[5]  = 0x3320646e;\n  ctx->input[10] = 0x79622d32;\n  ctx->input[15] = 0x6b206574;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-core-internal.c": {
    "_salsa20_core": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "void\n_salsa20_core(uint32_t *dst, const uint32_t *src, unsigned rounds)\n{\n  uint32_t x[_SALSA20_INPUT_LENGTH];\n  unsigned i;\n\n  assert ( (rounds & 1) == 0);\n\n  memcpy (x, src, sizeof(x));\n  for (i = 0; i < rounds;i += 2)\n    {\n      DEBUG (i);\n      QROUND(x[0], x[4], x[8], x[12]);\n      QROUND(x[5], x[9], x[13], x[1]);\n      QROUND(x[10], x[14], x[2], x[6]);\n      QROUND(x[15], x[3], x[7], x[11]);\n\n      DEBUG (i+1);\n      QROUND(x[0], x[1], x[2], x[3]);\n      QROUND(x[5], x[6], x[7], x[4]);\n      QROUND(x[10], x[11], x[8], x[9]);\n      QROUND(x[15], x[12], x[13], x[14]);\n    }\n  DEBUG (i);\n\n  for (i = 0; i < _SALSA20_INPUT_LENGTH; i++)\n    {\n      uint32_t t = x[i] + src[i];\n      dst[i] = LE_SWAP32 (t);\n    }\n}",
      "lines": 31,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-crypt.c": {
    "salsa20_crypt": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "void\nsalsa20_crypt(struct salsa20_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *c,\n\t      const uint8_t *m)\n{\n  if (!length)\n    return;\n  \n  for (;;)\n    {\n      uint32_t x[_SALSA20_INPUT_LENGTH];\n\n      _salsa20_core (x, ctx->input, 20);\n\n      ctx->input[9] += (++ctx->input[8] == 0);\n\n      /* stopping at 2^70 length per nonce is user's responsibility */\n      \n      if (length <= SALSA20_BLOCK_SIZE)\n\t{\n\t  memxor3 (c, m, x, length);\n\t  return;\n\t}\n      memxor3 (c, m, x, SALSA20_BLOCK_SIZE);\n\n      length -= SALSA20_BLOCK_SIZE;\n      c += SALSA20_BLOCK_SIZE;\n      m += SALSA20_BLOCK_SIZE;\n  }\n}",
      "lines": 31,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-set-key.c": {
    "salsa20_set_key": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "void\nsalsa20_set_key(struct salsa20_ctx *ctx,\n\t\tsize_t length, const uint8_t *key)\n{\n  switch (length)\n    {\n    case SALSA20_128_KEY_SIZE:\n      salsa20_128_set_key (ctx, key);\n      break;\n    case SALSA20_256_KEY_SIZE:\n      salsa20_256_set_key (ctx, key);\n      break;\n    default:\n      abort();\n    }\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20-set-nonce.c": {
    "salsa20_set_nonce": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\nsalsa20_set_nonce(struct salsa20_ctx *ctx, const uint8_t *nonce)\n{\n  ctx->input[6] = LE_READ_UINT32(nonce + 0);\n  ctx->input[7] = LE_READ_UINT32(nonce + 4);\n  ctx->input[8] = 0;\n  ctx->input[9] = 0;\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/salsa20.h": {},
  "nettle/nettle-3.4.1/salsa20r12-crypt.c": {
    "salsa20r12_crypt": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "void\nsalsa20r12_crypt(struct salsa20_ctx *ctx,\n\t\t size_t length,\n\t\t uint8_t *c,\n\t\t const uint8_t *m)\n{\n  uint32_t x[_SALSA20_INPUT_LENGTH];\n\n  if (!length)\n    return;\n  \n  for (;;)\n    {\n\n      _salsa20_core (x, ctx->input, 12);\n\n      ctx->input[9] += (++ctx->input[8] == 0);\n\n      /* stopping at 2^70 length per nonce is user's responsibility */\n      \n      if (length <= SALSA20_BLOCK_SIZE)\n\t{\n\t  memxor3 (c, m, x, length);\n\t  return;\n\t}\n      memxor3 (c, m, x, SALSA20_BLOCK_SIZE);\n\n      length -= SALSA20_BLOCK_SIZE;\n      c += SALSA20_BLOCK_SIZE;\n      m += SALSA20_BLOCK_SIZE;\n    }\n}",
      "lines": 32,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sec-add-1.c": {
    "sec_add_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "mp_limb_t\nsec_add_1 (mp_limb_t *rp, mp_limb_t *ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    {\n      mp_limb_t r = ap[i] + b;\n      b = (r < b);\n      rp[i] = r;\n    }\n  return b;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/sec-sub-1.c": {
    "sec_sub_1": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "mp_limb_t\nsec_sub_1 (mp_limb_t *rp, mp_limb_t *ap, mp_size_t n, mp_limb_t b)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    {\n      mp_limb_t a;\n      a = ap[i];\n      rp[i] = a - b;\n      b = a < b;\n    }\n  return b;\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "mp_limb_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/sec-tabselect.c": {
    "sec_tabselect": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "void\nsec_tabselect (mp_limb_t *rp, mp_size_t rn,\n\t       const mp_limb_t *table, unsigned tn,\n\t       unsigned k)\n{\n  const mp_limb_t *end = table + tn * rn;\n  const mp_limb_t *p;\n  mp_size_t i;\n  \n  assert (k < tn);\n  mpn_zero (rp, rn);\n  for (p = table; p < end; p += rn, k--)\n    {\n      mp_limb_t mask = - (mp_limb_t) (k == 0);\n      for (i = 0; i < rn; i++)\n\trp[i] += mask & p[i];\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/serpent-decrypt.c": {
    "serpent_decrypt": {
      "start_point": [
        469,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "void\nserpent_decrypt (const struct serpent_ctx *ctx,\n\t\t size_t length, uint8_t * dst, const uint8_t * src)\n{\n  assert( !(length % SERPENT_BLOCK_SIZE));\n\n#if HAVE_NATIVE_64_BIT\n  if (length & SERPENT_BLOCK_SIZE)\n#else\n  while (length >= SERPENT_BLOCK_SIZE)\n#endif\n    {\n      uint32_t x0,x1,x2,x3, y0,y1,y2,y3;\n      unsigned k;\n\n      x0 = LE_READ_UINT32 (src);\n      x1 = LE_READ_UINT32 (src + 4);\n      x2 = LE_READ_UINT32 (src + 8);\n      x3 = LE_READ_UINT32 (src + 12);\n\n      /* Inverse of special round */\n      KEYXOR (x0,x1,x2,x3, ctx->keys[32]);\n      SBOX7_INVERSE (x0,x1,x2,x3, y0,y1,y2,y3);\n      KEYXOR (y0,y1,y2,y3, ctx->keys[31]);\n\n      k = 24;\n      goto start32;\n      while (k > 0)\n\t{\n\t  k -= 8;\n\t  ROUND_INVERSE (7, ctx->keys[k+7], x0,x1,x2,x3, y0,y1,y2,y3);\n\tstart32:\n\t  ROUND_INVERSE (6, ctx->keys[k+6], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND_INVERSE (5, ctx->keys[k+5], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND_INVERSE (4, ctx->keys[k+4], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND_INVERSE (3, ctx->keys[k+3], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND_INVERSE (2, ctx->keys[k+2], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND_INVERSE (1, ctx->keys[k+1], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND_INVERSE (0, ctx->keys[k], y0,y1,y2,y3, x0,x1,x2,x3);\n\t}\n      \n      LE_WRITE_UINT32 (dst, x0);\n      LE_WRITE_UINT32 (dst + 4, x1);\n      LE_WRITE_UINT32 (dst + 8, x2);\n      LE_WRITE_UINT32 (dst + 12, x3);\n\n      src += SERPENT_BLOCK_SIZE;\n      dst += SERPENT_BLOCK_SIZE;\n      length -= SERPENT_BLOCK_SIZE;\n    }\n#if HAVE_NATIVE_64_BIT\n  FOR_BLOCKS(length, dst, src, 2*SERPENT_BLOCK_SIZE)\n    {\n      uint64_t x0,x1,x2,x3, y0,y1,y2,y3;\n      unsigned k;\n\n      x0 = LE_READ_UINT32 (src);\n      x1 = LE_READ_UINT32 (src + 4);\n      x2 = LE_READ_UINT32 (src + 8);\n      x3 = LE_READ_UINT32 (src + 12);\n\n      x0 <<= 32; x0 |= LE_READ_UINT32 (src + 16);\n      x1 <<= 32; x1 |= LE_READ_UINT32 (src + 20);\n      x2 <<= 32; x2 |= LE_READ_UINT32 (src + 24);\n      x3 <<= 32; x3 |= LE_READ_UINT32 (src + 28);\n\n      /* Inverse of special round */\n      KEYXOR64 (x0,x1,x2,x3, ctx->keys[32]);\n      SBOX7_INVERSE (x0,x1,x2,x3, y0,y1,y2,y3);\n      KEYXOR64 (y0,y1,y2,y3, ctx->keys[31]);\n\n      k = 24;\n      goto start64;\n      while (k > 0)\n\t{\n\t  k -= 8;\n\t  ROUND64_INVERSE (7, ctx->keys[k+7], x0,x1,x2,x3, y0,y1,y2,y3);\n\tstart64:\n\t  ROUND64_INVERSE (6, ctx->keys[k+6], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64_INVERSE (5, ctx->keys[k+5], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64_INVERSE (4, ctx->keys[k+4], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64_INVERSE (3, ctx->keys[k+3], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64_INVERSE (2, ctx->keys[k+2], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64_INVERSE (1, ctx->keys[k+1], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64_INVERSE (0, ctx->keys[k], y0,y1,y2,y3, x0,x1,x2,x3);\n\t}\n    \n      LE_WRITE_UINT32 (dst + 16, x0);\n      LE_WRITE_UINT32 (dst + 20, x1);\n      LE_WRITE_UINT32 (dst + 24, x2);\n      LE_WRITE_UINT32 (dst + 28, x3);\n      x0 >>= 32; LE_WRITE_UINT32 (dst, x0);\n      x1 >>= 32; LE_WRITE_UINT32 (dst + 4, x1);\n      x2 >>= 32; LE_WRITE_UINT32 (dst + 8, x2);\n      x3 >>= 32; LE_WRITE_UINT32 (dst + 12, x3);\n    }\n#endif /* HAVE_NATIVE_64_BIT */  \n}",
      "lines": 98,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/serpent-encrypt.c": {
    "serpent_encrypt": {
      "start_point": [
        442,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "void\nserpent_encrypt (const struct serpent_ctx *ctx,\n\t\t size_t length, uint8_t * dst, const uint8_t * src)\n{\n  assert( !(length % SERPENT_BLOCK_SIZE));\n  \n#if HAVE_NATIVE_64_BIT\n  if (length & SERPENT_BLOCK_SIZE)\n#else\n  while (length >= SERPENT_BLOCK_SIZE)\n#endif\n    {\n      uint32_t x0,x1,x2,x3, y0,y1,y2,y3;\n      unsigned k;\n\n      x0 = LE_READ_UINT32 (src);\n      x1 = LE_READ_UINT32 (src + 4);\n      x2 = LE_READ_UINT32 (src + 8);\n      x3 = LE_READ_UINT32 (src + 12);\n\n      for (k = 0; ; k += 8)\n\t{\n\t  ROUND (0, ctx->keys[k+0], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND (1, ctx->keys[k+1], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND (2, ctx->keys[k+2], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND (3, ctx->keys[k+3], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND (4, ctx->keys[k+4], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND (5, ctx->keys[k+5], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND (6, ctx->keys[k+6], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  if (k == 24)\n\t    break;\n\t  ROUND (7, ctx->keys[k+7], y0,y1,y2,y3, x0,x1,x2,x3);\n\t}\n\n      /* Special final round, using two subkeys. */\n      KEYXOR (y0,y1,y2,y3, ctx->keys[31]);\n      SBOX7 (y0,y1,y2,y3, x0,x1,x2,x3);\n      KEYXOR (x0,x1,x2,x3, ctx->keys[32]);\n    \n      LE_WRITE_UINT32 (dst, x0);\n      LE_WRITE_UINT32 (dst + 4, x1);\n      LE_WRITE_UINT32 (dst + 8, x2);\n      LE_WRITE_UINT32 (dst + 12, x3);\n\n      src += SERPENT_BLOCK_SIZE;\n      dst += SERPENT_BLOCK_SIZE;\n      length -= SERPENT_BLOCK_SIZE;\n    }\n#if HAVE_NATIVE_64_BIT\n  FOR_BLOCKS(length, dst, src, 2*SERPENT_BLOCK_SIZE)\n    {\n      uint64_t x0,x1,x2,x3, y0,y1,y2,y3;\n      unsigned k;\n\n      x0 = LE_READ_UINT32 (src);\n      x1 = LE_READ_UINT32 (src + 4);\n      x2 = LE_READ_UINT32 (src + 8);\n      x3 = LE_READ_UINT32 (src + 12);\n\n      x0 <<= 32; x0 |= LE_READ_UINT32 (src + 16);\n      x1 <<= 32; x1 |= LE_READ_UINT32 (src + 20);\n      x2 <<= 32; x2 |= LE_READ_UINT32 (src + 24);\n      x3 <<= 32; x3 |= LE_READ_UINT32 (src + 28);\n\n      for (k = 0; ; k += 8)\n\t{\n\t  ROUND64 (0, ctx->keys[k+0], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64 (1, ctx->keys[k+1], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64 (2, ctx->keys[k+2], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64 (3, ctx->keys[k+3], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64 (4, ctx->keys[k+4], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  ROUND64 (5, ctx->keys[k+5], y0,y1,y2,y3, x0,x1,x2,x3);\n\t  ROUND64 (6, ctx->keys[k+6], x0,x1,x2,x3, y0,y1,y2,y3);\n\t  if (k == 24)\n\t    break;\n\t  ROUND64 (7, ctx->keys[k+7], y0,y1,y2,y3, x0,x1,x2,x3);\n\t}\n\n      /* Special final round, using two subkeys. */\n      KEYXOR64 (y0,y1,y2,y3, ctx->keys[31]);\n      SBOX7 (y0,y1,y2,y3, x0,x1,x2,x3);\n      KEYXOR64 (x0,x1,x2,x3, ctx->keys[32]);\n    \n      LE_WRITE_UINT32 (dst + 16, x0);\n      LE_WRITE_UINT32 (dst + 20, x1);\n      LE_WRITE_UINT32 (dst + 24, x2);\n      LE_WRITE_UINT32 (dst + 28, x3);\n      x0 >>= 32; LE_WRITE_UINT32 (dst, x0);\n      x1 >>= 32; LE_WRITE_UINT32 (dst + 4, x1);\n      x2 >>= 32; LE_WRITE_UINT32 (dst + 8, x2);\n      x3 >>= 32; LE_WRITE_UINT32 (dst + 12, x3);\n    }\n#endif /* HAVE_NATIVE_64_BIT */\n}",
      "lines": 94,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/serpent-internal.h": {},
  "nettle/nettle-3.4.1/serpent-meta.c": {},
  "nettle/nettle-3.4.1/serpent-set-key.c": {
    "serpent_key_pad": {
      "start_point": [
        296,
        0
      ],
      "end_point": [
        321,
        1
      ],
      "content": "static void\nserpent_key_pad (const uint8_t *key, unsigned int key_length,\n\t\t uint32_t *w)\n{\n  unsigned int i;\n\n  assert (key_length <= SERPENT_MAX_KEY_SIZE);\n  \n  for (i = 0; key_length >= 4; key_length -=4, key += 4)\n    w[i++] = LE_READ_UINT32(key);\n\n  if (i < 8)\n    {\n      /* Key must be padded according to the Serpent specification.\n         \"aabbcc\" -> \"aabbcc0100...00\" -> 0x01ccbbaa. */\n      uint32_t pad = 0x01;\n      \n      while (key_length > 0)\n\tpad = pad << 8 | key[--key_length];\n\n      w[i++] = pad;\n\n      while (i < 8)\n\tw[i++] = 0;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "serpent_set_key": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        358,
        1
      ],
      "content": "void\nserpent_set_key (struct serpent_ctx *ctx,\n\t\t size_t length, const uint8_t * key)\n{\n  uint32_t w[8];\n  uint32_t (*keys)[4];\n  unsigned k;\n  \n  serpent_key_pad (key, length, w);\n\n  /* Derive the 33 subkeys from KEY and store them in SUBKEYS. We do\n     the recurrence in the key schedule using W as a circular buffer\n     of just 8 uint32_t. */\n\n  /* FIXME: Would be better to invoke SBOX with scalar variables as\n     arguments, no arrays. To do that, unpack w into separate\n     variables, use temporary variables as the SBOX destination. */\n\n  keys = ctx->keys;\n  k = 0;\n  for (;;)\n    {\n      KS(keys, 3, w, 0, k);\n      if (k == 132)\n\tbreak;\n      KS(keys, 2, w, 4, k);\n      KS(keys, 1, w, 0, k);\n      KS(keys, 0, w, 4, k);\n      KS(keys, 7, w, 0, k);\n      KS(keys, 6, w, 4, k);\n      KS(keys, 5, w, 0, k);\n      KS(keys, 4, w, 4, k);\n    }\n  assert (keys == ctx->keys + 33);\n}",
      "lines": 35,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "serpent128_set_key": {
      "start_point": [
        360,
        0
      ],
      "end_point": [
        364,
        1
      ],
      "content": "void\nserpent128_set_key (struct serpent_ctx *ctx, const uint8_t *key)\n{\n  serpent_set_key (ctx, SERPENT128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "serpent192_set_key": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        370,
        1
      ],
      "content": "void\nserpent192_set_key (struct serpent_ctx *ctx, const uint8_t *key)\n{\n  serpent_set_key (ctx, SERPENT192_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "serpent256_set_key": {
      "start_point": [
        372,
        0
      ],
      "end_point": [
        376,
        1
      ],
      "content": "void\nserpent256_set_key (struct serpent_ctx *ctx, const uint8_t *key)\n{\n  serpent_set_key (ctx, SERPENT256_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/serpent.h": {},
  "nettle/nettle-3.4.1/sexp-format.c": {
    "format_prefix": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static unsigned\nformat_prefix(struct nettle_buffer *buffer,\n\t      size_t length)\n{\n  size_t digit = 1;\n  unsigned prefix_length = 1;\n  \n  for (;;)\n    {\n      size_t next = digit * 10;\n      if (next > length)\n\tbreak;\n\n      prefix_length++;\n      digit = next;\n    }\n\n  if (buffer)\n    {\n      for (; digit; length %= digit, digit /= 10)\n\tif (!NETTLE_BUFFER_PUTC(buffer, '0' + length / digit))\n\t  return 0;\n      \n      if (!NETTLE_BUFFER_PUTC(buffer, ':'))\n\treturn 0;\n    }\n\n  return prefix_length + 1;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "format_string": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static size_t\nformat_string(struct nettle_buffer *buffer,\n\t      size_t length, const uint8_t *s)\n{\n  unsigned prefix_length = format_prefix(buffer, length);\n  if (!prefix_length)\n    return 0;\n\n  if (buffer && !nettle_buffer_write(buffer, length, s))\n    return 0;\n\n  return prefix_length + length;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "size_t"
      ]
    },
    "strlen_u8": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static inline size_t\nstrlen_u8 (const uint8_t *s)\n{\n  return strlen((const char*) s);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "size_t"
      ]
    },
    "sexp_vformat": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        334,
        1
      ],
      "content": "size_t\nsexp_vformat(struct nettle_buffer *buffer, const char *format, va_list args)\n{\n  unsigned nesting = 0;\n  size_t done = 0;\n\n  for (;;)\n    switch (*format++)\n      {\n      default:\n\t{\n\t  const char *start = format - 1;\n\t  size_t length = 1 + strcspn(format, \"()% \\t\");\n\t  size_t output_length\n\t    = format_string(buffer, length, (const uint8_t *) start);\n\t  if (!output_length)\n\t    return 0;\n\t  \n\t  done += output_length;\n\t  format = start + length;\n\n\t  break;\n\t}\n      case ' ': case '\\t':\n\tbreak;\n\t\n      case '\\0':\n\tassert(!nesting);\n\t    \n\treturn done;\n\n      case '(':\n\tif (buffer && !NETTLE_BUFFER_PUTC(buffer, '('))\n\t  return 0;\n\n\tdone++;\n\tnesting++;\n\tbreak;\n\n      case ')':\n\tassert (nesting);\n\tif (buffer && !NETTLE_BUFFER_PUTC(buffer, ')'))\n\t  return 0;\n\n\tdone++;\n\tnesting--;\n\tbreak;\n\n      case '%':\n\t{\n\t  int nul_flag = 0;\n\n\t  if (*format == '0')\n\t    {\n\t      format++;\n\t      nul_flag = 1;\n\t    }\n\t  switch (*format++)\n\t    {\n\t    default:\n\t      abort();\n\n\t    case '(':\n\t    case ')':\n\t      /* Allow unbalanced parenthesis */\n\t      if (buffer && !NETTLE_BUFFER_PUTC(buffer, format[-1]))\n\t\treturn 0;\n\t      done++;\n\t      break;\n\t      \n\t    case 's':\n\t      {\n\t\tconst uint8_t *s;\n\t\tsize_t length;\n\t\tsize_t output_length;\n\t\t\n\t\tif (nul_flag)\n\t\t  {\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t    length = strlen_u8(s);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    length = va_arg(args, size_t);\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t  }\n\t\t\n\t\toutput_length = format_string(buffer, length, s);\n\t\tif (!output_length)\n\t\t  return 0;\n\n\t\tdone += output_length;\n\t\tbreak;\n\t      }\n\t    case 't':\n\t      {\n\t\tconst uint8_t *s;\n\t\tsize_t length;\n\t\tsize_t output_length;\n\t\t\n\t\tif (nul_flag)\n\t\t  {\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t    if (!s)\n\t\t      break;\n\t\t    \n\t\t    length = strlen_u8(s);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    length = va_arg(args, size_t);\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t    if (!s)\n\t\t      break;\n\t\t  }\n\t\t\n\t\tif (buffer && !NETTLE_BUFFER_PUTC(buffer, '['))\n\t\t  return 0;\n\t\tdone++;\n\t\t\n\t\toutput_length = format_string(buffer, length, s);\n\t      \n\t\tif (!output_length)\n\t\t  return 0;\n\n\t\tdone += output_length;\n\t\t\n\t\tif (buffer && !NETTLE_BUFFER_PUTC(buffer, ']'))\n\t\t  return 0;\n\t\tdone++;\n\t\t\n\t\tbreak;\n\t      }\n\t      \n\t    case 'l':\n\t      {\n\t\tconst uint8_t *s;\n\t\tsize_t length;\n\t\t\n\t\tif (nul_flag)\n\t\t  {\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t    length = strlen_u8(s);\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    length = va_arg(args, size_t);\n\t\t    s = va_arg(args, const uint8_t *);\n\t\t  }\n\n\t\tif (buffer && !nettle_buffer_write(buffer, length, s))\n\t\t  return 0;\n\t      \n\t\tdone += length;\n\t\tbreak;\n\t      }\n\t    case 'i':\n\t      {\n\t\tuint32_t x = va_arg(args, uint32_t);\n\t\tunsigned length;\n\t      \n\t\tif (x < 0x80)\n\t\t  length = 1;\n\t\telse if (x < 0x8000L)\n\t\t  length = 2;\n\t\telse if (x < 0x800000L)\n\t\t  length = 3;\n\t\telse if (x < 0x80000000L)\n\t\t  length = 4;\n\t\telse\n\t\t  length = 5;\n\t      \n\t\tif (buffer && !(NETTLE_BUFFER_PUTC(buffer, '0' + length)\n\t\t\t\t&& NETTLE_BUFFER_PUTC(buffer, ':')))\n\t\t  return 0;\n\n\t\tdone += (2 + length);\n\n\t\tif (buffer)\n\t\t  switch(length)\n\t\t    {\n\t\t    case 5:\n\t\t      /* Leading byte needed for the sign. */\n\t\t      if (!NETTLE_BUFFER_PUTC(buffer, 0))\n\t\t\treturn 0;\n\t\t      /* Fall through */\n\t\t    case 4:\n\t\t      if (!NETTLE_BUFFER_PUTC(buffer, x >> 24))\n\t\t\treturn 0;\n\t\t      /* Fall through */\n\t\t    case 3:\n\t\t      if (!NETTLE_BUFFER_PUTC(buffer, (x >> 16) & 0xff))\n\t\t\treturn 0;\n\t\t      /* Fall through */\n\t\t    case 2:\n\t\t      if (!NETTLE_BUFFER_PUTC(buffer, (x >> 8) & 0xff))\n\t\t\treturn 0;\n\t\t      /* Fall through */\n\t\t    case 1:\n\t\t      if (!NETTLE_BUFFER_PUTC(buffer, x & 0xff))\n\t\t\treturn 0;\n\t\t      break;\n\t\t    default:\n\t\t      abort();\n\t\t    }\n\t\tbreak;\n\t      }\n\t    case 'b':\n\t      {\n\t\tmpz_srcptr n = va_arg(args, mpz_srcptr);\n\t\tsize_t length;\n\t\tunsigned prefix_length;\n\t      \n\t\tlength = nettle_mpz_sizeinbase_256_s(n);\n\t\tprefix_length = format_prefix(buffer, length);\n\t\tif (!prefix_length)\n\t\t  return 0;\n\n\t\tdone += prefix_length;\n\n\t\tif (buffer)\n\t\t  {\n\t\t    uint8_t *space = nettle_buffer_space(buffer, length);\n\t\t    if (!space)\n\t\t      return 0;\n\t\t  \n\t\t    nettle_mpz_get_str_256(length, space, n);\n\t\t  }\n\n\t\tdone += length;\n\t      \n\t\tbreak;\n\t      }\n\t    }\n\t}\n      }\n}",
      "lines": 237,
      "depth": 24,
      "decorators": [
        "size_t"
      ]
    },
    "sexp_format": {
      "start_point": [
        336,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "size_t\nsexp_format(struct nettle_buffer *buffer, const char *format, ...)\n{\n  va_list args;\n  size_t done;\n  \n  va_start(args, format);\n  done = sexp_vformat(buffer, format, args);\n  va_end(args);\n\n  return done;\n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp-transport-format.c": {
    "base64_encode_in_place": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static inline void\nbase64_encode_in_place (size_t length, uint8_t *data)\n{\n  base64_encode_raw ((char *) data, length, data);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "sexp_transport_vformat": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "size_t\nsexp_transport_vformat(struct nettle_buffer *buffer,\n\t\t       const char *format, va_list args)\n{\n  size_t start = 0;\n  size_t length;\n  size_t base64_length;\n\n  if (buffer)\n    {\n      if (!NETTLE_BUFFER_PUTC(buffer, '{'))\n\treturn 0;\n\n      start = buffer->size;\n    }\n  \n  length = sexp_vformat(buffer, format, args);\n\n  if (!length)\n    return 0;\n\n  base64_length = BASE64_ENCODE_RAW_LENGTH(length);\n\n  if (buffer)\n    {\n      if (!nettle_buffer_space(buffer, base64_length - length))\n\treturn 0;\n\n      base64_encode_in_place(length, buffer->contents + start);\n      \n      if (!NETTLE_BUFFER_PUTC(buffer, '}'))\n\treturn 0;\n    }\n  \n  return base64_length + 2;\n}",
      "lines": 36,
      "depth": 11,
      "decorators": [
        "size_t"
      ]
    },
    "sexp_transport_format": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "size_t\nsexp_transport_format(struct nettle_buffer *buffer,\n\t\t      const char *format, ...)\n{\n  size_t done;\n  va_list args;\n\n  va_start(args, format);\n  done = sexp_transport_vformat(buffer, format, args);\n  va_end(args);\n  \n  return done;\n}",
      "lines": 13,
      "depth": 7,
      "decorators": [
        "size_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp-transport.c": {
    "sexp_transport_iterator_first": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "int\nsexp_transport_iterator_first(struct sexp_iterator *iterator,\n\t\t\t      size_t length, uint8_t *input)\n{\n  /* We first base64 decode any transport encoded sexp at the start of\n   * the input. */\n\n  size_t in = 0;\n  size_t out = 0;\n\n  while (in < length)\n    switch(input[in])\n      {\n      case ' ':  /* SPC, TAB, LF, CR */\n      case '\\t':\n      case '\\n':\n      case '\\r':\n\tin++;\n\tbreak;\n\t  \n      case ';':  /* Comments */\n\twhile (++in < length && input[in] != '\\n')\n\t  ;\n\tbreak;\n\t  \n      case '{':\n\t{\n\t  /* Found transport encoding */\n\t  struct base64_decode_ctx ctx;\n\t  size_t coded_length;\n\t  size_t end;\n\n\t  for (end = ++in; end < length && input[end] != '}'; end++)\n\t    ;\n\n\t  if (end == length)\n\t    return 0;\n\t    \n\t  base64_decode_init(&ctx);\n\t  \n\t  if (base64_decode_update(&ctx, &coded_length, input + out,\n\t\t\t\t   end - in, (const char*) (input + in))\n\t      && base64_decode_final(&ctx))\n\t    {\t  \n\t      out += coded_length;\n\t      in = end + 1;\n\t    }\n\t  else\n\t    return 0;\n\t  \n\t  break;\n\t}\n      default:\n\t/* Expression isn't in transport encoding. Rest of the input\n\t * should be in canonical encoding. */\n\tgoto transport_done;\n      }\n  \n transport_done:\n\n  /* Here, we have two, possibly empty, input parts in canonical\n   * encoding:\n   *\n   * 0...out-1,  in...length -1\n   *\n   * If the input was already in canonical encoding, out = 0 and in =\n   * amount of leading space.\n   *\n   * If all input was in transport encoding, in == length.\n   */\n  if (!out)\n    {\n      input += in;\n      length -= in;\n    }\n  else if (in == length)\n    length = out;\n  else if (out == in)\n    /* Unusual case, nothing happens */\n    ;\n  else\n    {\n      /* Both parts non-empty */\n      assert(out < in);\n      memmove(input + out, input + in, length - in);\n      length -= (in - out);\n    }\n\n  return sexp_iterator_first(iterator, length, input);\n}",
      "lines": 90,
      "depth": 16,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp.c": {
    "sexp_iterator_init": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void\nsexp_iterator_init(struct sexp_iterator *iterator,\n\t\t   unsigned length, const uint8_t *input)\n{\n  iterator->length = length;\n  iterator->buffer = input;\n  iterator->pos = 0;\n  iterator->level = 0;\n  iterator->type = SEXP_END; /* Value doesn't matter */\n  iterator->display_length = 0;\n  iterator->display = NULL;\n  iterator->atom_length = 0;\n  iterator->atom = NULL;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_iterator_simple": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static int\nsexp_iterator_simple(struct sexp_iterator *iterator,\n\t\t     size_t *size,\n\t\t     const uint8_t **string)\n{\n  unsigned length = 0;\n  uint8_t c;\n  \n  if (EMPTY(iterator)) return 0;\n  c = NEXT(iterator);\n  if (EMPTY(iterator)) return 0;\n\n  if (c >= '1' && c <= '9')\n    do\n      {\n\tlength = length * 10 + (c - '0');\n\tif (length > (iterator->length - iterator->pos))\n\t  return 0;\n\n\tif (EMPTY(iterator)) return 0;\n\tc = NEXT(iterator);\n      }\n    while (c >= '0' && c <= '9');\n\n  else if (c == '0')\n    /* There can be only one */\n    c = NEXT(iterator);\n  else \n    return 0;\n\n  if (c != ':')\n    return 0;\n\n  *size = length;\n  *string = iterator->buffer + iterator->pos;\n  iterator->pos += length;\n\n  return 1;\n}",
      "lines": 39,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sexp_iterator_parse": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        162,
        1
      ],
      "content": "static int\nsexp_iterator_parse(struct sexp_iterator *iterator)\n{\n  iterator->start = iterator->pos;\n  \n  if (EMPTY(iterator))\n    {\n      if (iterator->level)\n\treturn 0;\n      \n      iterator->type = SEXP_END;\n      return 1;\n    }\n  switch (iterator->buffer[iterator->pos])\n    {\n    case '(': /* A list */\n      iterator->type = SEXP_LIST;\n      return 1;\n\n    case ')':\n      if (!iterator->level)\n\treturn 0;\n      \n      iterator->pos++;\n      iterator->type = SEXP_END;      \n      return 1;\n      \n    case '[': /* Atom with display type */\n      iterator->pos++;\n      if (!sexp_iterator_simple(iterator,\n\t\t\t\t&iterator->display_length,\n\t\t\t\t&iterator->display))\n\treturn 0;\n      if (EMPTY(iterator) || NEXT(iterator) != ']')\n\treturn 0;\n\n      break;\n\n    default:\n      /* Must be either a decimal digit or a syntax error.\n       * Errors are detected by sexp_iterator_simple. */\n      iterator->display_length = 0;\n      iterator->display = NULL;\n\n      break;\n    }\n\n  iterator->type = SEXP_ATOM;\n      \n  return sexp_iterator_simple(iterator,\n\t\t\t      &iterator->atom_length,\n\t\t\t      &iterator->atom);\n}",
      "lines": 53,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sexp_iterator_first": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        170,
        1
      ],
      "content": "int\nsexp_iterator_first(struct sexp_iterator *iterator,\n\t\t    size_t length, const uint8_t *input)\n{\n  sexp_iterator_init(iterator, length, input);\n  return sexp_iterator_parse(iterator);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_next": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "int\nsexp_iterator_next(struct sexp_iterator *iterator)\n{\n  switch (iterator->type)\n    {\n    case SEXP_END:\n      return 1;\n    case SEXP_LIST:\n      /* Skip this list */\n      return sexp_iterator_enter_list(iterator)\n\t&& sexp_iterator_exit_list(iterator);\n    case SEXP_ATOM:\n      /* iterator->pos should already point at the start of the next\n       * element. */\n      return sexp_iterator_parse(iterator);\n    }\n  /* If we get here, we have a bug. */\n  abort();\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_enter_list": {
      "start_point": [
        193,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nsexp_iterator_enter_list(struct sexp_iterator *iterator)\n{\n  if (iterator->type != SEXP_LIST)\n    return 0;\n\n  if (EMPTY(iterator) || NEXT(iterator) != '(')\n    /* Internal error */\n    abort();\n\n  iterator->level++;\n\n  return sexp_iterator_parse(iterator);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_exit_list": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "int\nsexp_iterator_exit_list(struct sexp_iterator *iterator)\n{\n  if (!iterator->level)\n    return 0;\n\n  while(iterator->type != SEXP_END)\n    if (!sexp_iterator_next(iterator))\n      return 0;\n      \n  iterator->level--;\n\n  return sexp_iterator_parse(iterator);\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_exit_lists": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        237,
        1
      ],
      "content": "int\nsexp_iterator_exit_lists(struct sexp_iterator *iterator,\n\t\t\t unsigned level)\n{\n  assert(iterator->level >= level);\n\n  while (iterator->level > level)\n    if (!sexp_iterator_exit_list(iterator))\n      return 0;\n\n  return 1;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_subexpr": {
      "start_point": [
        240,
        0
      ],
      "end_point": [
        250,
        1
      ],
      "content": "const uint8_t *\nsexp_iterator_subexpr(struct sexp_iterator *iterator,\n\t\t      size_t *length)\n{\n  size_t start = iterator->start;\n  if (!sexp_iterator_next(iterator))\n    return 0;\n\n  *length = iterator->start - start;\n  return iterator->buffer + start;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "const",
        "const",
        "uint8_t",
        "*\nsexp_iterator_subexpr(struct sexp_iterator *iterator,\n\t\t      size_t *length)",
        "*"
      ]
    },
    "sexp_iterator_get_uint32": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        293,
        1
      ],
      "content": "int\nsexp_iterator_get_uint32(struct sexp_iterator *iterator,\n\t\t\t uint32_t *x)\n{\n  if (iterator->type == SEXP_ATOM\n      && !iterator->display\n      && iterator->atom_length\n      && iterator->atom[0] < 0x80)\n    {\n      size_t length = iterator->atom_length;\n      const uint8_t *p = iterator->atom;\n\n      /* Skip leading zeros. */\n      while(length && !*p)\n\t{\n\t  length--; p++;\n\t}\n\n      switch(length)\n\t{\n\tcase 0:\n\t  *x = 0;\n\t  break;\n\tcase 1:\n\t  *x = p[0];\n\t  break;\n\tcase 2:\n\t  *x = READ_UINT16(p);\n\t  break;\n\tcase 3:\n\t  *x = READ_UINT24(p);\n\t  break;\n\tcase 4:\n\t  *x = READ_UINT32(p);\n\t  break;\n\tdefault:\n\t  return 0;\n\t}\n      return sexp_iterator_next(iterator);\n    }\n  return 0;\n}",
      "lines": 42,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_check_type": {
      "start_point": [
        295,
        0
      ],
      "end_point": [
        305,
        1
      ],
      "content": "int\nsexp_iterator_check_type(struct sexp_iterator *iterator,\n\t\t\t const char *type)\n{\n  return (sexp_iterator_enter_list(iterator)\n\t  && iterator->type == SEXP_ATOM\n\t  && !iterator->display\n\t  && strlen(type) == iterator->atom_length\n\t  && !memcmp(type, iterator->atom, iterator->atom_length)\n\t  && sexp_iterator_next(iterator));\n}",
      "lines": 11,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "sexp_iterator_check_types": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        324,
        1
      ],
      "content": "const char *\nsexp_iterator_check_types(struct sexp_iterator *iterator,\n\t\t\t  unsigned ntypes,\n\t\t\t  const char * const *types)\n{\n  if (sexp_iterator_enter_list(iterator)\n      && iterator->type == SEXP_ATOM\n      && !iterator->display)\n    {\n      unsigned i;\n      for (i = 0; i<ntypes; i++)\n\tif (strlen(types[i]) == iterator->atom_length\n\t    && !memcmp(types[i], iterator->atom,\n\t\t       iterator->atom_length))\n\t  return sexp_iterator_next(iterator) ? types[i] : NULL;\n    }\n  return NULL;\n}",
      "lines": 18,
      "depth": 13,
      "decorators": [
        "const",
        "const",
        "char",
        "*\nsexp_iterator_check_types(struct sexp_iterator *iterator,\n\t\t\t  unsigned ntypes,\n\t\t\t  const char * const *types)",
        "*"
      ]
    },
    "sexp_iterator_assoc": {
      "start_point": [
        326,
        0
      ],
      "end_point": [
        398,
        1
      ],
      "content": "int\nsexp_iterator_assoc(struct sexp_iterator *iterator,\n\t\t    unsigned nkeys,\n\t\t    const char * const *keys,\n\t\t    struct sexp_iterator *values)\n{\n  TMP_DECL(found, int, NETTLE_MAX_SEXP_ASSOC);\n  unsigned nfound;\n  unsigned i;\n\n  TMP_ALLOC(found, nkeys);\n  for (i = 0; i<nkeys; i++)\n    found[i] = 0;\n\n  nfound = 0;\n  \n  for (;;)\n    {\n      switch (iterator->type)\n\t{\n\tcase SEXP_LIST:\n\n\t  if (!sexp_iterator_enter_list(iterator))\n\t    return 0;\n\t  \n\t  if (iterator->type == SEXP_ATOM\n\t      && !iterator->display)\n\t    {\n\t      /* Compare to the given keys */\n\t      for (i = 0; i<nkeys; i++)\n\t\t{\n\t\t  /* NOTE: The strlen could be put outside of the\n\t\t   * loop */\n\t\t  if (strlen(keys[i]) == iterator->atom_length\n\t\t      && !memcmp(keys[i], iterator->atom,\n\t\t\t\t iterator->atom_length))\n\t\t    {\n\t\t      if (found[i])\n\t\t\t/* We don't allow duplicates */\n\t\t\treturn 0;\n\n\t\t      /* Advance to point to value */\n\t\t      if (!sexp_iterator_next(iterator))\n\t\t\treturn 0;\n\n\t\t      found[i] = 1;\n\t\t      nfound++;\n\t\t      \n\t\t      /* Record this position. */\n\t\t      values[i] = *iterator;\n\t\t      \n\t\t      break;\n\t\t    }\n\t\t}\n\t    }\n\t  if (!sexp_iterator_exit_list(iterator))\n\t    return 0;\n\t  break;\n\tcase SEXP_ATOM:\n\t  /* Just ignore */\n\t  if (!sexp_iterator_next(iterator))\n\t    return 0;\n\t  break;\n\t  \n\tcase SEXP_END:\n\t  return sexp_iterator_exit_list(iterator)\n\t    && (nfound == nkeys);\n\n\tdefault:\n\t  abort();\n\t}\n    }\n}",
      "lines": 73,
      "depth": 19,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp.h": {},
  "nettle/nettle-3.4.1/sexp2bignum.c": {
    "nettle_mpz_set_sexp": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "int\nnettle_mpz_set_sexp(mpz_t x, unsigned limit, struct sexp_iterator *i)\n{\n  if (i->type == SEXP_ATOM\n      && i->atom_length\n      && !i->display)\n    {\n      /* Allow some extra here, for leading sign octets. */\n      if (limit && (8 * i->atom_length > (16 + limit)))\n\treturn 0;\n      \n      nettle_mpz_set_str_256_s(x, i->atom_length, i->atom);\n\n      /* FIXME: How to interpret a limit for negative numbers? */\n      if (limit && mpz_sizeinbase(x, 2) > limit)\n\treturn 0;\n      \n      return sexp_iterator_next(i);\n    }\n  else\n    return 0;\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp2dsa.c": {
    "dsa_keypair_from_sexp_alist": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "int\ndsa_keypair_from_sexp_alist(struct dsa_params *params,\n\t\t\t    mpz_t pub,\n\t\t\t    mpz_t priv,\n\t\t\t    unsigned p_max_bits,\n\t\t\t    unsigned q_bits,\n\t\t\t    struct sexp_iterator *i)\n{\n  static const char * const names[5]\n    = { \"p\", \"q\", \"g\", \"y\", \"x\" };\n  struct sexp_iterator values[5];\n  unsigned nvalues = priv ? 5 : 4;\n  unsigned p_bits;\n\n  if (!sexp_iterator_assoc(i, nvalues, names, values))\n    return 0;\n\n  GET(params->p, p_max_bits, &values[0]);\n  p_bits = mpz_sizeinbase (params->p, 2);\n  GET(params->q, q_bits ? q_bits : p_bits, &values[1]);\n  if (q_bits > 0 && mpz_sizeinbase(params->q, 2) != q_bits)\n    return 0;\n  if (mpz_cmp (params->q, params->p) >= 0)\n    return 0;\n  GET(params->g, p_bits, &values[2]);\n  if (mpz_cmp (params->g, params->p) >= 0)\n    return 0;\n  GET(pub, p_bits, &values[3]);\n  if (mpz_cmp (pub, params->p) >= 0)\n    return 0;\n\n  if (priv)\n    {\n      GET(priv, mpz_sizeinbase (params->q, 2), &values[4]);\n      if (mpz_cmp (priv, params->q) >= 0)\n\treturn 0;\n    }\n\n  return 1;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha1_keypair_from_sexp": {
      "start_point": [
        96,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "int\ndsa_sha1_keypair_from_sexp(struct dsa_params *params,\n\t\t\t   mpz_t pub,\n\t\t\t   mpz_t priv,\n\t\t\t   unsigned p_max_bits, \n\t\t\t   size_t length, const uint8_t *expr)\n{\n  struct sexp_iterator i;\n\n  return sexp_iterator_first(&i, length, expr)\n    && sexp_iterator_check_type(&i, priv ? \"private-key\" : \"public-key\")\n    && sexp_iterator_check_type(&i, \"dsa\")\n    && dsa_keypair_from_sexp_alist(params, pub, priv,\n\t\t\t\t   p_max_bits, DSA_SHA1_Q_BITS, &i);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "dsa_sha256_keypair_from_sexp": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\ndsa_sha256_keypair_from_sexp(struct dsa_params *params,\n\t\t\t     mpz_t pub,\n\t\t\t     mpz_t priv,\n\t\t\t     unsigned p_max_bits, \n\t\t\t     size_t length, const uint8_t *expr)\n{\n  struct sexp_iterator i;\n\n  return sexp_iterator_first(&i, length, expr)\n    && sexp_iterator_check_type(&i, priv ? \"private-key\" : \"public-key\")\n    && sexp_iterator_check_type(&i, \"dsa-sha256\")\n    && dsa_keypair_from_sexp_alist(params, pub, priv,\n\t\t\t\t   p_max_bits, DSA_SHA256_Q_BITS, &i);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    },
    "dsa_signature_from_sexp": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "int\ndsa_signature_from_sexp(struct dsa_signature *rs,\n\t\t\tstruct sexp_iterator *i,\n\t\t\tunsigned q_bits)\n{\n  static const char * const names[2] = { \"r\", \"s\" };\n  struct sexp_iterator values[2];\n\n  if (!sexp_iterator_assoc(i, 2, names, values))\n    return 0;\n\n  GET(rs->r, q_bits, &values[0]);\n  GET(rs->s, q_bits, &values[1]);\n\n  return 1;\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sexp2rsa.c": {
    "rsa_keypair_from_sexp_alist": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "int\nrsa_keypair_from_sexp_alist(struct rsa_public_key *pub,\n\t\t\t    struct rsa_private_key *priv,\n\t\t\t    unsigned limit,\n\t\t\t    struct sexp_iterator *i)\n{\n  static const char * const names[8]\n    = { \"n\", \"e\", \"d\", \"p\", \"q\", \"a\", \"b\", \"c\" };\n  struct sexp_iterator values[8];\n  unsigned nvalues = priv ? 8 : 2;\n  \n  if (!sexp_iterator_assoc(i, nvalues, names, values))\n    return 0;\n\n  if (priv)\n    {\n      GET(priv->d, limit, &values[2]);\n      GET(priv->p, limit, &values[3]);\n      GET(priv->q, limit, &values[4]);\n      GET(priv->a, limit, &values[5]);\n      GET(priv->b, limit, &values[6]);\n      GET(priv->c, limit, &values[7]);\n\n      if (!rsa_private_key_prepare(priv))\n\treturn 0;\n    }\n\n  if (pub)\n    {\n      GET(pub->n, limit, &values[0]);\n      GET(pub->e, limit, &values[1]);\n\n      if (!rsa_public_key_prepare(pub))\n\treturn 0;\n    }\n  \n  return 1;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "int"
      ]
    },
    "rsa_keypair_from_sexp": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "int\nrsa_keypair_from_sexp(struct rsa_public_key *pub,\n\t\t      struct rsa_private_key *priv,\n\t\t      unsigned limit, \n\t\t      size_t length, const uint8_t *expr)\n{\n  struct sexp_iterator i;\n  static const char * const names[3]\n    = { \"rsa\", \"rsa-pkcs1\", \"rsa-pkcs1-sha1\" };\n\n  if (!sexp_iterator_first(&i, length, expr))\n    return 0;\n  \n  if (!sexp_iterator_check_type(&i, priv ? \"private-key\" : \"public-key\"))\n    return 0;\n\n  if (!sexp_iterator_check_types(&i, 3, names))\n    return 0;\n\n  return rsa_keypair_from_sexp_alist(pub, priv, limit, &i);\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha-example.c": {
    "display_hex": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "static void\ndisplay_hex(unsigned length, uint8_t *data)\n{\n  unsigned i;\n\n  for (i = 0; i<length; i++)\n    printf(\"%02x \", data[i]);\n\n  printf(\"\\n\");\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct sha1_ctx ctx;\n  uint8_t buffer[BUF_SIZE];\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  \n  sha1_init(&ctx);\n  for (;;)\n  {\n    int done = fread(buffer, 1, sizeof(buffer), stdin);\n    sha1_update(&ctx, done, buffer);\n    if (done < sizeof(buffer))\n      break;\n  }\n  if (ferror(stdin))\n    return EXIT_FAILURE;\n\n  sha1_digest(&ctx, SHA1_DIGEST_SIZE, digest);\n\n  display_hex(SHA1_DIGEST_SIZE, digest);\n  return EXIT_SUCCESS;  \n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha.h": {},
  "nettle/nettle-3.4.1/sha1-compress.c": {
    "_nettle_sha1_compress": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        259,
        1
      ],
      "content": "void\n_nettle_sha1_compress(uint32_t *state, const uint8_t *input)\n{\n  uint32_t data[SHA1_DATA_LENGTH];\n  uint32_t A, B, C, D, E;     /* Local vars */\n  int i;\n\n  for (i = 0; i < SHA1_DATA_LENGTH; i++, input+= 4)\n    {\n      data[i] = READ_UINT32(input);\n    }\n\n  /* Set up first buffer and local data buffer */\n  A = state[0];\n  B = state[1];\n  C = state[2];\n  D = state[3];\n  E = state[4];\n\n  DEBUG(-1);\n  /* Heavy mangling, in 4 sub-rounds of 20 interations each. */\n  subRound( A, B, C, D, E, f1, K1, data[ 0] ); DEBUG(0);\n  subRound( E, A, B, C, D, f1, K1, data[ 1] ); DEBUG(1);\n  subRound( D, E, A, B, C, f1, K1, data[ 2] );\n  subRound( C, D, E, A, B, f1, K1, data[ 3] );\n  subRound( B, C, D, E, A, f1, K1, data[ 4] );\n  subRound( A, B, C, D, E, f1, K1, data[ 5] );\n  subRound( E, A, B, C, D, f1, K1, data[ 6] );\n  subRound( D, E, A, B, C, f1, K1, data[ 7] );\n  subRound( C, D, E, A, B, f1, K1, data[ 8] );\n  subRound( B, C, D, E, A, f1, K1, data[ 9] );\n  subRound( A, B, C, D, E, f1, K1, data[10] );\n  subRound( E, A, B, C, D, f1, K1, data[11] );\n  subRound( D, E, A, B, C, f1, K1, data[12] );\n  subRound( C, D, E, A, B, f1, K1, data[13] );\n  subRound( B, C, D, E, A, f1, K1, data[14] );\n  subRound( A, B, C, D, E, f1, K1, data[15] ); DEBUG(15);\n  subRound( E, A, B, C, D, f1, K1, expand( data, 16 ) ); DEBUG(16);\n  subRound( D, E, A, B, C, f1, K1, expand( data, 17 ) ); DEBUG(17);\n  subRound( C, D, E, A, B, f1, K1, expand( data, 18 ) ); DEBUG(18);\n  subRound( B, C, D, E, A, f1, K1, expand( data, 19 ) ); DEBUG(19);\n\n  subRound( A, B, C, D, E, f2, K2, expand( data, 20 ) ); DEBUG(20);\n  subRound( E, A, B, C, D, f2, K2, expand( data, 21 ) ); DEBUG(21);\n  subRound( D, E, A, B, C, f2, K2, expand( data, 22 ) );\n  subRound( C, D, E, A, B, f2, K2, expand( data, 23 ) );\n  subRound( B, C, D, E, A, f2, K2, expand( data, 24 ) );\n  subRound( A, B, C, D, E, f2, K2, expand( data, 25 ) );\n  subRound( E, A, B, C, D, f2, K2, expand( data, 26 ) );\n  subRound( D, E, A, B, C, f2, K2, expand( data, 27 ) );\n  subRound( C, D, E, A, B, f2, K2, expand( data, 28 ) );\n  subRound( B, C, D, E, A, f2, K2, expand( data, 29 ) );\n  subRound( A, B, C, D, E, f2, K2, expand( data, 30 ) );\n  subRound( E, A, B, C, D, f2, K2, expand( data, 31 ) );\n  subRound( D, E, A, B, C, f2, K2, expand( data, 32 ) );\n  subRound( C, D, E, A, B, f2, K2, expand( data, 33 ) );\n  subRound( B, C, D, E, A, f2, K2, expand( data, 34 ) );\n  subRound( A, B, C, D, E, f2, K2, expand( data, 35 ) );\n  subRound( E, A, B, C, D, f2, K2, expand( data, 36 ) );\n  subRound( D, E, A, B, C, f2, K2, expand( data, 37 ) );\n  subRound( C, D, E, A, B, f2, K2, expand( data, 38 ) ); DEBUG(38);\n  subRound( B, C, D, E, A, f2, K2, expand( data, 39 ) ); DEBUG(39);\n\n  subRound( A, B, C, D, E, f3, K3, expand( data, 40 ) ); DEBUG(40);\n  subRound( E, A, B, C, D, f3, K3, expand( data, 41 ) ); DEBUG(41);\n  subRound( D, E, A, B, C, f3, K3, expand( data, 42 ) );\n  subRound( C, D, E, A, B, f3, K3, expand( data, 43 ) );\n  subRound( B, C, D, E, A, f3, K3, expand( data, 44 ) );\n  subRound( A, B, C, D, E, f3, K3, expand( data, 45 ) );\n  subRound( E, A, B, C, D, f3, K3, expand( data, 46 ) );\n  subRound( D, E, A, B, C, f3, K3, expand( data, 47 ) );\n  subRound( C, D, E, A, B, f3, K3, expand( data, 48 ) );\n  subRound( B, C, D, E, A, f3, K3, expand( data, 49 ) );\n  subRound( A, B, C, D, E, f3, K3, expand( data, 50 ) );\n  subRound( E, A, B, C, D, f3, K3, expand( data, 51 ) );\n  subRound( D, E, A, B, C, f3, K3, expand( data, 52 ) );\n  subRound( C, D, E, A, B, f3, K3, expand( data, 53 ) );\n  subRound( B, C, D, E, A, f3, K3, expand( data, 54 ) );\n  subRound( A, B, C, D, E, f3, K3, expand( data, 55 ) );\n  subRound( E, A, B, C, D, f3, K3, expand( data, 56 ) );\n  subRound( D, E, A, B, C, f3, K3, expand( data, 57 ) );\n  subRound( C, D, E, A, B, f3, K3, expand( data, 58 ) ); DEBUG(58);\n  subRound( B, C, D, E, A, f3, K3, expand( data, 59 ) ); DEBUG(59);\n\n  subRound( A, B, C, D, E, f4, K4, expand( data, 60 ) ); DEBUG(60);\n  subRound( E, A, B, C, D, f4, K4, expand( data, 61 ) ); DEBUG(61);\n  subRound( D, E, A, B, C, f4, K4, expand( data, 62 ) );\n  subRound( C, D, E, A, B, f4, K4, expand( data, 63 ) );\n  subRound( B, C, D, E, A, f4, K4, expand( data, 64 ) );\n  subRound( A, B, C, D, E, f4, K4, expand( data, 65 ) );\n  subRound( E, A, B, C, D, f4, K4, expand( data, 66 ) );\n  subRound( D, E, A, B, C, f4, K4, expand( data, 67 ) );\n  subRound( C, D, E, A, B, f4, K4, expand( data, 68 ) );\n  subRound( B, C, D, E, A, f4, K4, expand( data, 69 ) );\n  subRound( A, B, C, D, E, f4, K4, expand( data, 70 ) );\n  subRound( E, A, B, C, D, f4, K4, expand( data, 71 ) );\n  subRound( D, E, A, B, C, f4, K4, expand( data, 72 ) );\n  subRound( C, D, E, A, B, f4, K4, expand( data, 73 ) );\n  subRound( B, C, D, E, A, f4, K4, expand( data, 74 ) );\n  subRound( A, B, C, D, E, f4, K4, expand( data, 75 ) );\n  subRound( E, A, B, C, D, f4, K4, expand( data, 76 ) );\n  subRound( D, E, A, B, C, f4, K4, expand( data, 77 ) );\n  subRound( C, D, E, A, B, f4, K4, expand( data, 78 ) ); DEBUG(78);\n  subRound( B, C, D, E, A, f4, K4, expand( data, 79 ) ); DEBUG(79);\n\n  /* Build message digest */\n  state[0] += A;\n  state[1] += B;\n  state[2] += C;\n  state[3] += D;\n  state[4] += E;\n\n#if SHA1_DEBUG\n  fprintf(stderr, \"99: %8x %8x %8x %8x %8x\\n\",\n\t  state[0], state[1], state[2], state[3], state[4]);\n#endif\n}",
      "lines": 117,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha1-meta.c": {},
  "nettle/nettle-3.4.1/sha1.c": {
    "sha1_init": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nsha1_init(struct sha1_ctx *ctx)\n{\n  /* FIXME: Put the buffer last in the struct, and arrange so that we\n     can initialize with a single memcpy. */\n  static const uint32_t iv[_SHA1_DIGEST_LENGTH] = \n    {\n      /* SHA initial values, first 4 identical to md5's. */\n      0x67452301L,\n      0xEFCDAB89L,\n      0x98BADCFEL,\n      0x10325476L,\n      0xC3D2E1F0L,\n    };\n\n  memcpy(ctx->state, iv, sizeof(ctx->state));\n  ctx->count = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha1_update": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "void\nsha1_update(struct sha1_ctx *ctx,\n\t    size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, COMPRESS, ctx->count++);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha1_digest": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nsha1_digest(struct sha1_ctx *ctx,\n\t    size_t length,\n\t    uint8_t *digest)\n{\n  uint64_t bit_count;\n\n  assert(length <= SHA1_DIGEST_SIZE);\n\n  MD_PAD(ctx, 8, COMPRESS);\n\n  /* There are 512 = 2^9 bits in one block */\n  bit_count = (ctx->count << 9) | (ctx->index << 3);\n\n  /* append the 64 bit count */\n  WRITE_UINT64(ctx->block + (SHA1_BLOCK_SIZE - 8), bit_count);\n  _nettle_sha1_compress(ctx->state, ctx->block);\n\n  _nettle_write_be32(length, digest, ctx->state);\n  sha1_init(ctx);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha1.h": {},
  "nettle/nettle-3.4.1/sha2.h": {},
  "nettle/nettle-3.4.1/sha224-meta.c": {},
  "nettle/nettle-3.4.1/sha256-compress.c": {
    "_nettle_sha256_compress": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "void\n_nettle_sha256_compress(uint32_t *state, const uint8_t *input, const uint32_t *k)\n{\n  uint32_t data[SHA256_DATA_LENGTH];\n  uint32_t A, B, C, D, E, F, G, H;     /* Local vars */\n  unsigned i;\n  uint32_t *d;\n\n  for (i = 0; i < SHA256_DATA_LENGTH; i++, input+= 4)\n    {\n      data[i] = READ_UINT32(input);\n    }\n\n  /* Set up first buffer and local data buffer */\n  A = state[0];\n  B = state[1];\n  C = state[2];\n  D = state[3];\n  E = state[4];\n  F = state[5];\n  G = state[6];\n  H = state[7];\n  \n  /* Heavy mangling */\n  /* First 16 subrounds that act on the original data */\n\n  DEBUG(-1);\n  for (i = 0, d = data; i<16; i+=8, k += 8, d+= 8)\n    {\n      ROUND(A, B, C, D, E, F, G, H, k[0], d[0]); DEBUG(i);\n      ROUND(H, A, B, C, D, E, F, G, k[1], d[1]); DEBUG(i+1);\n      ROUND(G, H, A, B, C, D, E, F, k[2], d[2]);\n      ROUND(F, G, H, A, B, C, D, E, k[3], d[3]);\n      ROUND(E, F, G, H, A, B, C, D, k[4], d[4]);\n      ROUND(D, E, F, G, H, A, B, C, k[5], d[5]);\n      ROUND(C, D, E, F, G, H, A, B, k[6], d[6]); DEBUG(i+6);\n      ROUND(B, C, D, E, F, G, H, A, k[7], d[7]); DEBUG(i+7);\n    }\n  \n  for (; i<64; i += 16, k+= 16)\n    {\n      ROUND(A, B, C, D, E, F, G, H, k[ 0], EXPAND(data,  0)); DEBUG(i);\n      ROUND(H, A, B, C, D, E, F, G, k[ 1], EXPAND(data,  1)); DEBUG(i+1);\n      ROUND(G, H, A, B, C, D, E, F, k[ 2], EXPAND(data,  2)); DEBUG(i+2);\n      ROUND(F, G, H, A, B, C, D, E, k[ 3], EXPAND(data,  3)); DEBUG(i+3);\n      ROUND(E, F, G, H, A, B, C, D, k[ 4], EXPAND(data,  4)); DEBUG(i+4);\n      ROUND(D, E, F, G, H, A, B, C, k[ 5], EXPAND(data,  5)); DEBUG(i+5);\n      ROUND(C, D, E, F, G, H, A, B, k[ 6], EXPAND(data,  6)); DEBUG(i+6);\n      ROUND(B, C, D, E, F, G, H, A, k[ 7], EXPAND(data,  7)); DEBUG(i+7);\n      ROUND(A, B, C, D, E, F, G, H, k[ 8], EXPAND(data,  8)); DEBUG(i+8);\n      ROUND(H, A, B, C, D, E, F, G, k[ 9], EXPAND(data,  9)); DEBUG(i+9);\n      ROUND(G, H, A, B, C, D, E, F, k[10], EXPAND(data, 10)); DEBUG(i+10);\n      ROUND(F, G, H, A, B, C, D, E, k[11], EXPAND(data, 11)); DEBUG(i+11);\n      ROUND(E, F, G, H, A, B, C, D, k[12], EXPAND(data, 12)); DEBUG(i+12);\n      ROUND(D, E, F, G, H, A, B, C, k[13], EXPAND(data, 13)); DEBUG(i+13);\n      ROUND(C, D, E, F, G, H, A, B, k[14], EXPAND(data, 14)); DEBUG(i+14);\n      ROUND(B, C, D, E, F, G, H, A, k[15], EXPAND(data, 15)); DEBUG(i+15);\n    }\n\n  /* Update state */\n  state[0] += A;\n  state[1] += B;\n  state[2] += C;\n  state[3] += D;\n  state[4] += E;\n  state[5] += F;\n  state[6] += G;\n  state[7] += H;\n#if SHA256_DEBUG\n  fprintf(stderr, \"99: %8x %8x %8x %8x %8x %8x %8x %8x\\n\",\n\t  state[0], state[1], state[2], state[3],\n\t  state[4], state[5], state[6], state[7]);\n#endif\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha256-meta.c": {},
  "nettle/nettle-3.4.1/sha256.c": {
    "sha256_init": {
      "start_point": [
        75,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\nsha256_init(struct sha256_ctx *ctx)\n{\n  /* Initial values, also generated by the shadata program. */\n  static const uint32_t H0[_SHA256_DIGEST_LENGTH] =\n  {\n    0x6a09e667UL, 0xbb67ae85UL, 0x3c6ef372UL, 0xa54ff53aUL, \n    0x510e527fUL, 0x9b05688cUL, 0x1f83d9abUL, 0x5be0cd19UL, \n  };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha256_update": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\nsha256_update(struct sha256_ctx *ctx,\n\t      size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, COMPRESS, ctx->count++);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha256_write_digest": {
      "start_point": [
        101,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "static void\nsha256_write_digest(struct sha256_ctx *ctx,\n\t\t    size_t length,\n\t\t    uint8_t *digest)\n{\n  uint64_t bit_count;\n\n  assert(length <= SHA256_DIGEST_SIZE);\n\n  MD_PAD(ctx, 8, COMPRESS);\n\n  /* There are 512 = 2^9 bits in one block */  \n  bit_count = (ctx->count << 9) | (ctx->index << 3);\n\n  /* This is slightly inefficient, as the numbers are converted to\n     big-endian format, and will be converted back by the compression\n     function. It's probably not worth the effort to fix this. */\n  WRITE_UINT64(ctx->block + (SHA256_BLOCK_SIZE - 8), bit_count);\n  COMPRESS(ctx, ctx->block);\n\n  _nettle_write_be32(length, digest, ctx->state);\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha256_digest": {
      "start_point": [
        124,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "void\nsha256_digest(struct sha256_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  sha256_write_digest(ctx, length, digest);\n  sha256_init(ctx);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sha224_init": {
      "start_point": [
        135,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "void\nsha224_init(struct sha256_ctx *ctx)\n{\n  /* Initial values. Low 32 bits of the initial values for sha384. */\n  static const uint32_t H0[_SHA256_DIGEST_LENGTH] =\n  {\n    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,\n    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n  };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha224_digest": {
      "start_point": [
        154,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "void\nsha224_digest(struct sha256_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  sha256_write_digest(ctx, length, digest);\n  sha224_init(ctx);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3-224-meta.c": {},
  "nettle/nettle-3.4.1/sha3-224.c": {
    "sha3_224_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nsha3_224_init (struct sha3_224_ctx *ctx)\n{\n  memset (ctx, 0, offsetof (struct sha3_224_ctx, block));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_224_update": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nsha3_224_update (struct sha3_224_ctx *ctx,\n\t\t size_t length,\n\t\t const uint8_t *data)\n{\n  ctx->index = _sha3_update (&ctx->state, SHA3_224_BLOCK_SIZE, ctx->block,\n\t\t\t     ctx->index, length, data);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_224_digest": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nsha3_224_digest(struct sha3_224_ctx *ctx,\n\t\tsize_t length,\n\t\tuint8_t *digest)\n{\n  _sha3_pad (&ctx->state, SHA3_224_BLOCK_SIZE, ctx->block, ctx->index);\n  _nettle_write_le64 (length, digest, ctx->state.a);\n  sha3_224_init (ctx);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3-256-meta.c": {},
  "nettle/nettle-3.4.1/sha3-256.c": {
    "sha3_256_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nsha3_256_init (struct sha3_256_ctx *ctx)\n{\n  memset (ctx, 0, offsetof (struct sha3_256_ctx, block));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_256_update": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nsha3_256_update (struct sha3_256_ctx *ctx,\n\t\t size_t length,\n\t\t const uint8_t *data)\n{\n  ctx->index = _sha3_update (&ctx->state, SHA3_256_BLOCK_SIZE, ctx->block,\n\t\t\t     ctx->index, length, data);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_256_digest": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nsha3_256_digest(struct sha3_256_ctx *ctx,\n\t\tsize_t length,\n\t\tuint8_t *digest)\n{\n  _sha3_pad (&ctx->state, SHA3_256_BLOCK_SIZE, ctx->block, ctx->index);\n  _nettle_write_le64 (length, digest, ctx->state.a);\n  sha3_256_init (ctx);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3-384-meta.c": {},
  "nettle/nettle-3.4.1/sha3-384.c": {
    "sha3_384_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nsha3_384_init (struct sha3_384_ctx *ctx)\n{\n  memset (ctx, 0, offsetof (struct sha3_384_ctx, block));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_384_update": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nsha3_384_update (struct sha3_384_ctx *ctx,\n\t\t size_t length,\n\t\t const uint8_t *data)\n{\n  ctx->index = _sha3_update (&ctx->state, SHA3_384_BLOCK_SIZE, ctx->block,\n\t\t\t     ctx->index, length, data);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_384_digest": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nsha3_384_digest(struct sha3_384_ctx *ctx,\n\t\tsize_t length,\n\t\tuint8_t *digest)\n{\n  _sha3_pad (&ctx->state, SHA3_384_BLOCK_SIZE, ctx->block, ctx->index);\n  _nettle_write_le64 (length, digest, ctx->state.a);\n  sha3_384_init (ctx);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3-512-meta.c": {},
  "nettle/nettle-3.4.1/sha3-512.c": {
    "sha3_512_init": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nsha3_512_init (struct sha3_512_ctx *ctx)\n{\n  memset (ctx, 0, offsetof (struct sha3_512_ctx, block));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_512_update": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "void\nsha3_512_update (struct sha3_512_ctx *ctx,\n\t\t size_t length,\n\t\t const uint8_t *data)\n{\n  ctx->index = _sha3_update (&ctx->state, SHA3_512_BLOCK_SIZE, ctx->block,\n\t\t\t     ctx->index, length, data);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sha3_512_digest": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\nsha3_512_digest(struct sha3_512_ctx *ctx,\n\t\tsize_t length,\n\t\tuint8_t *digest)\n{\n  _sha3_pad (&ctx->state, SHA3_512_BLOCK_SIZE, ctx->block, ctx->index);\n  _nettle_write_le64 (length, digest, ctx->state.a);\n  sha3_512_init (ctx);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3-permute.c": {
    "sha3_permute": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "void\nsha3_permute (struct sha3_state *state)\n{\n  static const uint64_t rc[SHA3_ROUNDS] = {\n    0x0000000000000001ULL, 0X0000000000008082ULL,\n    0X800000000000808AULL, 0X8000000080008000ULL,\n    0X000000000000808BULL, 0X0000000080000001ULL,\n    0X8000000080008081ULL, 0X8000000000008009ULL,\n    0X000000000000008AULL, 0X0000000000000088ULL,\n    0X0000000080008009ULL, 0X000000008000000AULL,\n    0X000000008000808BULL, 0X800000000000008BULL,\n    0X8000000000008089ULL, 0X8000000000008003ULL,\n    0X8000000000008002ULL, 0X8000000000000080ULL,\n    0X000000000000800AULL, 0X800000008000000AULL,\n    0X8000000080008081ULL, 0X8000000000008080ULL,\n    0X0000000080000001ULL, 0X8000000080008008ULL,\n  };\n\n  /* Original permutation:\n     \n       0,10,20, 5,15,\n      16, 1,11,21, 6,\n       7,17, 2,12,22,\n      23, 8,18, 3,13,\n      14,24, 9,19, 4\n\n     Rotation counts:\n\n       0,  1, 62, 28, 27,\n      36, 44,  6, 55, 20,\n       3, 10, 43, 25, 39,\n      41, 45, 15, 21,  8,\n      18,  2, 61, 56, 14,\n  */\n\n  /* In-place implementation. Permutation done as a long sequence of\n     25 moves \"following\" the permutation.\n\n      T <--  1\n      1 <--  6\n      6 <--  9\n      9 <-- 22\n     22 <-- 14\n     14 <-- 20\n     20 <--  2\n      2 <-- 12\n     12 <-- 13\n     13 <-- 19\n     19 <-- 23\n     23 <-- 15\n     15 <--  4\n      4 <-- 24\n     24 <-- 21\n     21 <--  8\n      8 <-- 16\n     16 <--  5\n      5 <--  3\n      3 <-- 18\n     18 <-- 17\n     17 <-- 11\n     11 <--  7\n      7 <-- 10\n     10 <--  T\n\n  */\n  uint64_t C[5], D[5], T, X;\n  unsigned i, y;\n\n#define A state->a\n\n  C[0] = A[0] ^ A[5+0] ^ A[10+0] ^ A[15+0] ^ A[20+0];\n  C[1] = A[1] ^ A[5+1] ^ A[10+1] ^ A[15+1] ^ A[20+1];\n  C[2] = A[2] ^ A[5+2] ^ A[10+2] ^ A[15+2] ^ A[20+2];\n  C[3] = A[3] ^ A[5+3] ^ A[10+3] ^ A[15+3] ^ A[20+3];\n  C[4] = A[4] ^ A[5+4] ^ A[10+4] ^ A[15+4] ^ A[20+4];\n\n  for (i = 0; i < SHA3_ROUNDS; i++)\n    {\n      D[0] = C[4] ^ ROTL64(1, C[1]);\n      D[1] = C[0] ^ ROTL64(1, C[2]);\n      D[2] = C[1] ^ ROTL64(1, C[3]);\n      D[3] = C[2] ^ ROTL64(1, C[4]);\n      D[4] = C[3] ^ ROTL64(1, C[0]);\n\n      A[0] ^= D[0];\n      X = A[ 1] ^ D[1];     T = ROTL64(1, X);\n      X = A[ 6] ^ D[1]; A[ 1] = ROTL64 (44, X);\n      X = A[ 9] ^ D[4]; A[ 6] = ROTL64 (20, X);\n      X = A[22] ^ D[2]; A[ 9] = ROTL64 (61, X);\n      X = A[14] ^ D[4]; A[22] = ROTL64 (39, X);\n      X = A[20] ^ D[0]; A[14] = ROTL64 (18, X);\n      X = A[ 2] ^ D[2]; A[20] = ROTL64 (62, X);\n      X = A[12] ^ D[2]; A[ 2] = ROTL64 (43, X);\n      X = A[13] ^ D[3]; A[12] = ROTL64 (25, X);\n      X = A[19] ^ D[4]; A[13] = ROTL64 ( 8, X);\n      X = A[23] ^ D[3]; A[19] = ROTL64 (56, X);\n      X = A[15] ^ D[0]; A[23] = ROTL64 (41, X);\n      X = A[ 4] ^ D[4]; A[15] = ROTL64 (27, X);\n      X = A[24] ^ D[4]; A[ 4] = ROTL64 (14, X);\n      X = A[21] ^ D[1]; A[24] = ROTL64 ( 2, X);\n      X = A[ 8] ^ D[3]; A[21] = ROTL64 (55, X); /* row 4 done */\n      X = A[16] ^ D[1]; A[ 8] = ROTL64 (45, X);\n      X = A[ 5] ^ D[0]; A[16] = ROTL64 (36, X);\n      X = A[ 3] ^ D[3]; A[ 5] = ROTL64 (28, X);\n      X = A[18] ^ D[3]; A[ 3] = ROTL64 (21, X); /* row 0 done */\n      X = A[17] ^ D[2]; A[18] = ROTL64 (15, X);\n      X = A[11] ^ D[1]; A[17] = ROTL64 (10, X); /* row 3 done */\n      X = A[ 7] ^ D[2]; A[11] = ROTL64 ( 6, X); /* row 1 done */\n      X = A[10] ^ D[0]; A[ 7] = ROTL64 ( 3, X);\n      A[10] = T;\t\t\t\t/* row 2 done */\n\n      D[0] = ~A[1] & A[2];\n      D[1] = ~A[2] & A[3];\n      D[2] = ~A[3] & A[4];\n      D[3] = ~A[4] & A[0];\n      D[4] = ~A[0] & A[1];\n\n      A[0] ^= D[0] ^ rc[i]; C[0] = A[0];\n      A[1] ^= D[1]; C[1] = A[1];\n      A[2] ^= D[2]; C[2] = A[2];\n      A[3] ^= D[3]; C[3] = A[3];\n      A[4] ^= D[4]; C[4] = A[4];\n\n      for (y = 5; y < 25; y+= 5)\n\t{\n\t  D[0] = ~A[y+1] & A[y+2];\n\t  D[1] = ~A[y+2] & A[y+3];\n\t  D[2] = ~A[y+3] & A[y+4];\n\t  D[3] = ~A[y+4] & A[y+0];\n\t  D[4] = ~A[y+0] & A[y+1];\n\n\t  A[y+0] ^= D[0]; C[0] ^= A[y+0];\n\t  A[y+1] ^= D[1]; C[1] ^= A[y+1];\n\t  A[y+2] ^= D[2]; C[2] ^= A[y+2];\n\t  A[y+3] ^= D[3]; C[3] ^= A[y+3];\n\t  A[y+4] ^= D[4]; C[4] ^= A[y+4];\n\t}\n    }\n#undef A\n}",
      "lines": 140,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3.c": {
    "sha3_absorb": {
      "start_point": [
        45,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void\nsha3_absorb (struct sha3_state *state, unsigned length, const uint8_t *data)\n{\n  assert ( (length & 7) == 0);\n#if WORDS_BIGENDIAN\n  {    \n    uint64_t *p;\n    for (p = state->a; length > 0; p++, length -= 8, data += 8)\n      *p ^= LE_READ_UINT64 (data);\n  }\n#else /* !WORDS_BIGENDIAN */\n  memxor (state->a, data, length);\n#endif\n\n  sha3_permute (state);\n}",
      "lines": 16,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_sha3_update": {
      "start_point": [
        62,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "unsigned\n_sha3_update (struct sha3_state *state,\n\t      unsigned block_size, uint8_t *block,\n\t      unsigned pos,\n\t      size_t length, const uint8_t *data)\n{\n  if (pos > 0)\n    {\n      unsigned left = block_size - pos;\n      if (length < left)\n\t{\n\t  memcpy (block + pos, data, length);\n\t  return pos + length;\n\t}\n      else\n\t{\n\t  memcpy (block + pos, data, left);\n\t  data += left;\n\t  length -= left;\n\t  sha3_absorb (state, block_size, block);\n\t}\n    }\n  for (; length >= block_size; length -= block_size, data += block_size)\n    sha3_absorb (state, block_size, data);\n\n  memcpy (block, data, length);\n  return length;\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    },
    "_sha3_pad": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "void\n_sha3_pad (struct sha3_state *state,\n\t   unsigned block_size, uint8_t *block, unsigned pos)\n{\n  assert (pos < block_size);\n  block[pos++] = 6;\n\n  memset (block + pos, 0, block_size - pos);\n  block[block_size - 1] |= 0x80;\n\n  sha3_absorb (state, block_size, block);  \n}",
      "lines": 12,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha3.h": {},
  "nettle/nettle-3.4.1/sha384-meta.c": {},
  "nettle/nettle-3.4.1/sha512-224-meta.c": {},
  "nettle/nettle-3.4.1/sha512-256-meta.c": {},
  "nettle/nettle-3.4.1/sha512-compress.c": {
    "_nettle_sha512_compress": {
      "start_point": [
        121,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "void\n_nettle_sha512_compress(uint64_t *state, const uint8_t *input, const uint64_t *k)\n{\n  uint64_t data[SHA512_DATA_LENGTH];\n  uint64_t A, B, C, D, E, F, G, H;     /* Local vars */\n  unsigned i;\n  uint64_t *d;\n\n  for (i = 0; i < SHA512_DATA_LENGTH; i++, input += 8)\n    {\n      data[i] = READ_UINT64(input);\n    }\n\n  /* Set up first buffer and local data buffer */\n  A = state[0];\n  B = state[1];\n  C = state[2];\n  D = state[3];\n  E = state[4];\n  F = state[5];\n  G = state[6];\n  H = state[7];\n  \n  /* Heavy mangling */\n  /* First 16 subrounds that act on the original data */\n\n  DEBUG(-1);\n  for (i = 0, d = data; i<16; i+=8, k += 8, d+= 8)\n    {\n      ROUND(A, B, C, D, E, F, G, H, k[0], d[0]); DEBUG(i);\n      ROUND(H, A, B, C, D, E, F, G, k[1], d[1]); DEBUG(i+1);\n      ROUND(G, H, A, B, C, D, E, F, k[2], d[2]);\n      ROUND(F, G, H, A, B, C, D, E, k[3], d[3]);\n      ROUND(E, F, G, H, A, B, C, D, k[4], d[4]);\n      ROUND(D, E, F, G, H, A, B, C, k[5], d[5]);\n      ROUND(C, D, E, F, G, H, A, B, k[6], d[6]); DEBUG(i+6);\n      ROUND(B, C, D, E, F, G, H, A, k[7], d[7]); DEBUG(i+7);\n    }\n  \n  for (; i<80; i += 16, k+= 16)\n    {\n      ROUND(A, B, C, D, E, F, G, H, k[ 0], EXPAND(data,  0)); DEBUG(i);\n      ROUND(H, A, B, C, D, E, F, G, k[ 1], EXPAND(data,  1)); DEBUG(i+1);\n      ROUND(G, H, A, B, C, D, E, F, k[ 2], EXPAND(data,  2)); DEBUG(i+2);\n      ROUND(F, G, H, A, B, C, D, E, k[ 3], EXPAND(data,  3));\n      ROUND(E, F, G, H, A, B, C, D, k[ 4], EXPAND(data,  4));\n      ROUND(D, E, F, G, H, A, B, C, k[ 5], EXPAND(data,  5));\n      ROUND(C, D, E, F, G, H, A, B, k[ 6], EXPAND(data,  6));\n      ROUND(B, C, D, E, F, G, H, A, k[ 7], EXPAND(data,  7));\n      ROUND(A, B, C, D, E, F, G, H, k[ 8], EXPAND(data,  8));\n      ROUND(H, A, B, C, D, E, F, G, k[ 9], EXPAND(data,  9));\n      ROUND(G, H, A, B, C, D, E, F, k[10], EXPAND(data, 10));\n      ROUND(F, G, H, A, B, C, D, E, k[11], EXPAND(data, 11));\n      ROUND(E, F, G, H, A, B, C, D, k[12], EXPAND(data, 12));\n      ROUND(D, E, F, G, H, A, B, C, k[13], EXPAND(data, 13));\n      ROUND(C, D, E, F, G, H, A, B, k[14], EXPAND(data, 14)); DEBUG(i+14);\n      ROUND(B, C, D, E, F, G, H, A, k[15], EXPAND(data, 15)); DEBUG(i+15);\n    }\n\n  /* Update state */\n  state[0] += A;\n  state[1] += B;\n  state[2] += C;\n  state[3] += D;\n  state[4] += E;\n  state[5] += F;\n  state[6] += G;\n  state[7] += H;\n#if SHA512_DEBUG\n  fprintf(stderr, \"99: %8lx %8lx %8lx %8lx\\n    %8lx %8lx %8lx %8lx\\n\",\n\t  state[0], state[1], state[2], state[3],\n\t  state[4], state[5], state[6], state[7]);\n#endif\n}",
      "lines": 74,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/sha512-meta.c": {},
  "nettle/nettle-3.4.1/sha512.c": {
    "sha512_init": {
      "start_point": [
        116,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "void\nsha512_init(struct sha512_ctx *ctx)\n{\n  /* Initial values, generated by the gp script\n       {\n         for (i = 1,8,\n\t   root = prime(i)^(1/2);\n\t   fraction = root - floor(root);\n\t   print(floor(2^64 * fraction));\n\t );\n       }\n. */\n  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =\n  {\n    0x6A09E667F3BCC908ULL,0xBB67AE8584CAA73BULL,\n    0x3C6EF372FE94F82BULL,0xA54FF53A5F1D36F1ULL,\n    0x510E527FADE682D1ULL,0x9B05688C2B3E6C1FULL,\n    0x1F83D9ABFB41BD6BULL,0x5BE0CD19137E2179ULL,\n  };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count_low = ctx->count_high = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha512_update": {
      "start_point": [
        145,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "void\nsha512_update(struct sha512_ctx *ctx,\n\t      size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, COMPRESS, MD_INCR(ctx));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha512_write_digest": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "static void\nsha512_write_digest(struct sha512_ctx *ctx,\n\t\t    size_t length,\n\t\t    uint8_t *digest)\n{\n  uint64_t high, low;\n\n  unsigned i;\n  unsigned words;\n  unsigned leftover;\n\n  assert(length <= SHA512_DIGEST_SIZE);\n\n  MD_PAD(ctx, 16, COMPRESS);\n\n  /* There are 1024 = 2^10 bits in one block */  \n  high = (ctx->count_high << 10) | (ctx->count_low >> 54);\n  low = (ctx->count_low << 10) | (ctx->index << 3);\n\n  /* This is slightly inefficient, as the numbers are converted to\n     big-endian format, and will be converted back by the compression\n     function. It's probably not worth the effort to fix this. */\n  WRITE_UINT64(ctx->block + (SHA512_BLOCK_SIZE - 16), high);\n  WRITE_UINT64(ctx->block + (SHA512_BLOCK_SIZE - 8), low);\n  COMPRESS(ctx, ctx->block);\n\n  words = length / 8;\n  leftover = length % 8;\n\n  for (i = 0; i < words; i++, digest += 8)\n    WRITE_UINT64(digest, ctx->state[i]);\n\n  if (leftover)\n    {\n      /* Truncate to the right size */\n      uint64_t word = ctx->state[i] >> (8*(8 - leftover));\n\n      do {\n\tdigest[--leftover] = word & 0xff;\n\tword >>= 8;\n      } while (leftover);\n    }\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sha512_digest": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        205,
        1
      ],
      "content": "void\nsha512_digest(struct sha512_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  assert(length <= SHA512_DIGEST_SIZE);\n\n  sha512_write_digest(ctx, length, digest);\n  sha512_init(ctx);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sha384_init": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "void\nsha384_init(struct sha512_ctx *ctx)\n{\n  /* Initial values, generated by the gp script\n       {\n         for (i = 9,16,\n\t   root = prime(i)^(1/2);\n\t   fraction = root - floor(root);\n\t   print(floor(2^64 * fraction));\n\t );\n       }\n. */\n  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =\n  {\n    0xCBBB9D5DC1059ED8ULL, 0x629A292A367CD507ULL,\n    0x9159015A3070DD17ULL, 0x152FECD8F70E5939ULL,\n    0x67332667FFC00B31ULL, 0x8EB44A8768581511ULL,\n    0xDB0C2E0D64F98FA7ULL, 0x47B5481DBEFA4FA4ULL,\n  };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count_low = ctx->count_high = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 28,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha384_digest": {
      "start_point": [
        237,
        0
      ],
      "end_point": [
        246,
        1
      ],
      "content": "void\nsha384_digest(struct sha512_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  assert(length <= SHA384_DIGEST_SIZE);\n\n  sha512_write_digest(ctx, length, digest);\n  sha384_init(ctx);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sha512_224_init": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        268,
        1
      ],
      "content": "void\nsha512_224_init(struct sha512_224_ctx *ctx)\n{\n  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =\n  {\n    0x8c3d37c819544da2ULL, 0x73e1996689dcd4d6ULL,\n    0x1dfab7ae32ff9c82ULL, 0x679dd514582f9fcfULL,\n    0x0f6d2b697bd44da8ULL, 0x77e36f7304c48942ULL,\n    0x3f9d85a86a1d36c8ULL, 0x1112e6ad91d692a1ULL,\n  };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count_low = ctx->count_high = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha512_224_digest": {
      "start_point": [
        270,
        0
      ],
      "end_point": [
        279,
        1
      ],
      "content": "void\nsha512_224_digest(struct sha512_224_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  assert(length <= SHA224_DIGEST_SIZE);\n\n  sha512_write_digest(ctx, length, digest);\n  sha512_224_init(ctx);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "sha512_256_init": {
      "start_point": [
        283,
        0
      ],
      "end_point": [
        301,
        1
      ],
      "content": "void\nsha512_256_init(struct sha512_256_ctx *ctx)\n{\n  static const uint64_t H0[_SHA512_DIGEST_LENGTH] =\n    {\n      0x22312194fc2bf72cULL, 0x9f555fa3c84c64c2ULL, \n      0x2393b86b6f53b151ULL, 0x963877195940eabdULL, \n      0x96283ee2a88effe3ULL, 0xbe5e1e2553863992ULL, \n      0x2b0199fc2c85b8aaULL, 0x0eb72ddc81c52ca2ULL,\n    };\n\n  memcpy(ctx->state, H0, sizeof(H0));\n\n  /* Initialize bit count */\n  ctx->count_low = ctx->count_high = 0;\n  \n  /* Initialize buffer */\n  ctx->index = 0;\n}",
      "lines": 19,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sha512_256_digest": {
      "start_point": [
        303,
        0
      ],
      "end_point": [
        312,
        1
      ],
      "content": "void\nsha512_256_digest(struct sha512_256_ctx *ctx,\n\t      size_t length,\n\t      uint8_t *digest)\n{\n  assert(length <= SHA256_DIGEST_SIZE);\n\n  sha512_write_digest(ctx, length, digest);\n  sha512_256_init(ctx);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/shadata.c": {
    "main": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "int main(int argc, char **argv)\n{\n  int i;\n  static const double third = 1.0/3;\n\n  printf(\"SHA-256 constants: \\n\");\n  for (i = 0; i < 64; )\n    {\n      double root = pow(primes[i++], third);\n      double fraction = root - floor(root);\n      double value = floor(ldexp(fraction, 32));\n\n      printf(\"0x%08lxUL, \", (unsigned long) value);\n      if (!(i % 4))\n\tprintf(\"\\n\");\n    }\n\n  printf(\"\\nSHA-256 initial values: \\n\");\n\n  for (i = 0; i < 8; )\n    {\n      double root = pow(primes[i++], 0.5);\n      double fraction = root - (floor(root));\n      double value = floor(ldexp(fraction, 32));\n\n      printf(\"0x%08lxUL, \", (unsigned long) value);\n      if (!(i % 4))\n\tprintf(\"\\n\");\n    }\n  \n  return 0;\n}",
      "lines": 32,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/twofish-meta.c": {},
  "nettle/nettle-3.4.1/twofish.c": {
    "gf_multiply": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static uint32_t\ngf_multiply(uint8_t p, uint8_t a, uint8_t b)\n{\n  uint32_t shift  = b;\n  uint8_t result = 0;\n  while (a)\n    {\n      if (a & 1) result ^= shift;\n      a = a >> 1;\n      shift = shift << 1;\n      if (shift & 0x100) shift ^= p;\n    }\n  return result;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "compute_s": {
      "start_point": [
        187,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "static uint32_t\ncompute_s(uint32_t m1, uint32_t m2)\n{\n  uint32_t s = 0;\n  int i;\n  for (i = 0; i < 4; i++)\n    s |=  ((  gf_multiply(0x4D, m1,       rs_matrix[i][0])\n\t    ^ gf_multiply(0x4D, m1 >> 8,  rs_matrix[i][1])\n\t    ^ gf_multiply(0x4D, m1 >> 16, rs_matrix[i][2])\n\t    ^ gf_multiply(0x4D, m1 >> 24, rs_matrix[i][3])\n\t    ^ gf_multiply(0x4D, m2,       rs_matrix[i][4])\n\t    ^ gf_multiply(0x4D, m2 >> 8,  rs_matrix[i][5])\n\t    ^ gf_multiply(0x4D, m2 >> 16, rs_matrix[i][6])\n\t    ^ gf_multiply(0x4D, m2 >> 24, rs_matrix[i][7])) << (i*8));\n  return s;\n}",
      "lines": 16,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "h_byte": {
      "start_point": [
        236,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static uint32_t\nh_byte(int k, int i, uint8_t x, uint8_t l0, uint8_t l1, uint8_t l2, uint8_t l3)\n{\n  uint8_t y = q_table[i][4][l0 ^\n            q_table[i][3][l1 ^\n              q_table[i][2][k == 2 ? x : l2 ^\n                q_table[i][1][k == 3 ? x : l3 ^ q_table[i][0][x]]]]];\n\n  return ( (gf_multiply(0x69, mds_matrix[0][i], y))\n\t   | (gf_multiply(0x69, mds_matrix[1][i], y) << 8)\n\t   | (gf_multiply(0x69, mds_matrix[2][i], y) << 16)\n\t   | (gf_multiply(0x69, mds_matrix[3][i], y) << 24) );\n}",
      "lines": 13,
      "depth": 18,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "h": {
      "start_point": [
        255,
        0
      ],
      "end_point": [
        262,
        1
      ],
      "content": "static uint32_t\nh(int k, uint8_t x, uint32_t l0, uint32_t l1, uint32_t l2, uint32_t l3)\n{\n  return (  h_byte(k, 0, x, l0,       l1,       l2,       l3)\n\t  ^ h_byte(k, 1, x, l0 >> 8,  l1 >> 8,  l2 >> 8,  l3 >> 8)\n\t  ^ h_byte(k, 2, x, l0 >> 16, l1 >> 16, l2 >> 16, l3 >> 16)\n\t  ^ h_byte(k, 3, x, l0 >> 24, l1 >> 24, l2 >> 24, l3 >> 24) );\n}",
      "lines": 8,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "uint32_t"
      ]
    },
    "twofish_set_key": {
      "start_point": [
        280,
        0
      ],
      "end_point": [
        331,
        1
      ],
      "content": "void\ntwofish_set_key(struct twofish_ctx *context,\n\t\tsize_t keysize, const uint8_t *key)\n{\n  uint8_t key_copy[32];\n  uint32_t m[8], s[4], t;\n  int i, j, k;\n\n  /* Extend key as necessary */\n\n  assert(keysize <= 32);\n\n  /* We do a little more copying than necessary, but that doesn't\n   * really matter. */\n  memset(key_copy, 0, 32);\n  memcpy(key_copy, key, keysize);\n\n  for (i = 0; i<8; i++)\n    m[i] = LE_READ_UINT32(key_copy + i*4);\n  \n  if (keysize <= 16)\n    k = 2;\n  else if (keysize <= 24)\n    k = 3;\n  else\n    k = 4;\n\n  /* Compute sub-keys */\n\n  for (i = 0; i < 20; i++)\n    {\n      t = h(k, 2*i+1, m[1], m[3], m[5], m[7]);\n      t = rol8(t);\n      t += (context->keys[2*i] =\n\t    t + h(k, 2*i, m[0], m[2], m[4], m[6]));\n      t = rol9(t);\n      context->keys[2*i+1] = t;\n    }\n\n  /* Compute key-dependent S-boxes */\n\n  for (i = 0; i < k; i++)\n    s[k-1-i] = compute_s(m[2*i], m[2*i+1]);\n\n  for (i = 0; i < 4; i++)\n    for (j = 0; j < 256; j++)\n      context->s_box[i][j] = h_byte(k, i, j,\n\t\t\t\t    s[0] >> (i*8),\n\t\t\t\t    s[1] >> (i*8),\n\t\t\t\t    s[2] >> (i*8),\n\t\t\t\t    s[3] >> (i*8));\n}",
      "lines": 52,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "twofish128_set_key": {
      "start_point": [
        333,
        0
      ],
      "end_point": [
        337,
        1
      ],
      "content": "void\ntwofish128_set_key(struct twofish_ctx *context, const uint8_t *key)\n{\n  twofish_set_key (context, TWOFISH128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "twofish192_set_key": {
      "start_point": [
        338,
        0
      ],
      "end_point": [
        342,
        1
      ],
      "content": "void\ntwofish192_set_key(struct twofish_ctx *context, const uint8_t *key)\n{\n  twofish_set_key (context, TWOFISH192_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "twofish256_set_key": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        347,
        1
      ],
      "content": "void\ntwofish256_set_key(struct twofish_ctx *context, const uint8_t *key)\n{\n  twofish_set_key (context, TWOFISH256_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "twofish_encrypt": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        417,
        1
      ],
      "content": "void\ntwofish_encrypt(const struct twofish_ctx *context,\n\t\tsize_t length,\n\t\tuint8_t *ciphertext,\n\t\tconst uint8_t *plaintext)\n{\n  const uint32_t * keys        = context->keys;\n  const uint32_t (*s_box)[256] = context->s_box;\n\n  assert( !(length % TWOFISH_BLOCK_SIZE) );\n  for ( ; length; length -= TWOFISH_BLOCK_SIZE)\n    {  \n      uint32_t words[4];\n      uint32_t r0, r1, r2, r3, t0, t1;\n      int i;\n\n      for (i = 0; i<4; i++, plaintext += 4)\n\twords[i] = LE_READ_UINT32(plaintext);\n\n      r0 = words[0] ^ keys[0];\n      r1 = words[1] ^ keys[1];\n      r2 = words[2] ^ keys[2];\n      r3 = words[3] ^ keys[3];\n  \n      for (i = 0; i < 8; i++) {\n\tt1 = (  s_box[1][r1 & 0xFF]\n\t\t^ s_box[2][(r1 >> 8) & 0xFF]\n\t\t^ s_box[3][(r1 >> 16) & 0xFF]\n\t\t^ s_box[0][(r1 >> 24) & 0xFF]);\n\tt0 = (  s_box[0][r0 & 0xFF]\n\t\t^ s_box[1][(r0 >> 8) & 0xFF]\n\t\t^ s_box[2][(r0 >> 16) & 0xFF]\n\t\t^ s_box[3][(r0 >> 24) & 0xFF]) + t1;\n\tr3 = (t1 + t0 + keys[4*i+9]) ^ rol1(r3);\n\tr2 = (t0 + keys[4*i+8]) ^ r2;\n\tr2 = ror1(r2);\n\n\tt1 = (  s_box[1][r3 & 0xFF]\n\t\t^ s_box[2][(r3 >> 8) & 0xFF]\n\t\t^ s_box[3][(r3 >> 16) & 0xFF]\n\t\t^ s_box[0][(r3 >> 24) & 0xFF]);\n\tt0 = (  s_box[0][r2 & 0xFF]\n\t\t^ s_box[1][(r2 >> 8) & 0xFF]\n\t\t^ s_box[2][(r2 >> 16) & 0xFF]\n\t\t^ s_box[3][(r2 >> 24) & 0xFF]) + t1;\n\tr1 = (t1 + t0 + keys[4*i+11]) ^ rol1(r1);\n\tr0 = (t0 + keys[4*i+10]) ^ r0;\n\tr0 = ror1(r0);\n      }\n\n      words[0] = r2 ^ keys[4];\n      words[1] = r3 ^ keys[5];\n      words[2] = r0 ^ keys[6];\n      words[3] = r1 ^ keys[7];\n\n      for (i = 0; i<4; i++, ciphertext += 4)\n\tLE_WRITE_UINT32(ciphertext, words[i]);\n    }\n}",
      "lines": 59,
      "depth": 18,
      "decorators": [
        "void"
      ]
    },
    "twofish_decrypt": {
      "start_point": [
        429,
        0
      ],
      "end_point": [
        488,
        1
      ],
      "content": "void\ntwofish_decrypt(const struct twofish_ctx *context,\n\t\tsize_t length,\n\t\tuint8_t *plaintext,\n\t\tconst uint8_t *ciphertext)\n\n{\n  const uint32_t *keys  = context->keys;\n  const uint32_t (*s_box)[256] = context->s_box;\n\n  assert( !(length % TWOFISH_BLOCK_SIZE) );\n  for ( ; length; length -= TWOFISH_BLOCK_SIZE)\n    {  \n      uint32_t words[4];\n      uint32_t r0, r1, r2, r3, t0, t1;\n      int i;\n\n      for (i = 0; i<4; i++, ciphertext += 4)\n\twords[i] = LE_READ_UINT32(ciphertext);\n\n      r0 = words[2] ^ keys[6];\n      r1 = words[3] ^ keys[7];\n      r2 = words[0] ^ keys[4];\n      r3 = words[1] ^ keys[5];\n\n      for (i = 0; i < 8; i++) {\n\tt1 = (  s_box[1][r3 & 0xFF]\n\t\t^ s_box[2][(r3 >> 8) & 0xFF]\n\t\t^ s_box[3][(r3 >> 16) & 0xFF]\n\t\t^ s_box[0][(r3 >> 24) & 0xFF]);\n\tt0 = (  s_box[0][r2 & 0xFF]\n\t\t^ s_box[1][(r2 >> 8) & 0xFF]\n\t\t^ s_box[2][(r2 >> 16) & 0xFF]\n\t\t^ s_box[3][(r2 >> 24) & 0xFF]) + t1;\n\tr1 = (t1 + t0 + keys[39-4*i]) ^ r1;\n\tr1 = ror1(r1);\n\tr0 = (t0 + keys[38-4*i]) ^ rol1(r0);\n\n\tt1 = (  s_box[1][r1 & 0xFF]\n\t\t^ s_box[2][(r1 >> 8) & 0xFF]\n\t\t^ s_box[3][(r1 >> 16) & 0xFF]\n\t\t^ s_box[0][(r1 >> 24) & 0xFF]);\n\tt0 = (  s_box[0][r0 & 0xFF]\n\t\t^ s_box[1][(r0 >> 8) & 0xFF]\n\t\t^ s_box[2][(r0 >> 16) & 0xFF]\n\t\t^ s_box[3][(r0 >> 24) & 0xFF]) + t1;\n\tr3 = (t1 + t0 + keys[37-4*i]) ^ r3;\n\tr3 = ror1(r3);\n\tr2 = (t0 + keys[36-4*i]) ^ rol1(r2);\n      }\n\n      words[0] = r0 ^ keys[0];\n      words[1] = r1 ^ keys[1];\n      words[2] = r2 ^ keys[2];\n      words[3] = r3 ^ keys[3];\n\n      for (i = 0; i<4; i++, plaintext += 4)\n\tLE_WRITE_UINT32(plaintext, words[i]);\n    }\n}",
      "lines": 60,
      "depth": 18,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/twofish.h": {},
  "nettle/nettle-3.4.1/twofishdata.c": {
    "q0": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "static unsigned char q0(unsigned char x)\n{\n    static const unsigned char t0[16] = {\n      0x8, 0x1, 0x7, 0xD, 0x6, 0xF, 0x3, 0x2,\n      0x0, 0xB, 0x5, 0x9, 0xE, 0xC, 0xA, 0x4\n    };\n    static const unsigned char t1[16] = {\n      0xE, 0xC, 0xB, 0x8, 0x1, 0x2, 0x3, 0x5,\n      0xF, 0x4, 0xA, 0x6, 0x7, 0x0, 0x9, 0xD\n    };\n    static const unsigned char t2[16] = {\n      0xB, 0xA, 0x5, 0xE, 0x6, 0xD, 0x9, 0x0,\n      0xC, 0x8, 0xF, 0x3, 0x2, 0x4, 0x7, 0x1\n    };\n    static const unsigned char t3[16] = {\n      0xD, 0x7, 0xF, 0x4, 0x1, 0x2, 0x6, 0xE,\n      0x9, 0xB, 0x3, 0x0, 0x8, 0x5, 0xC, 0xA\n    };\n\n    unsigned char a0 = x / 16;\n    unsigned char b0 = x % 16;\n\n    unsigned char a1 = a0 ^ b0;\n    unsigned char b1 = a0 ^ ror4(b0) ^ ((8*a0) % 16);\n\n    unsigned char a2 = t0[a1];\n    unsigned char b2 = t1[b1];\n\n    unsigned char a3 = a2 ^ b2;\n    unsigned char b3 = a2 ^ ror4(b2) ^ ((8*a2) % 16);\n\n    unsigned char a4 = t2[a3];\n    unsigned char b4 = t3[b3];\n\n    unsigned char y = 16*b4 + a4;\n\n    return y;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "q1": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static unsigned char q1(unsigned char x)\n{\n  static const unsigned char t0[16] = {\n    0x2, 0x8, 0xB, 0xD, 0xF, 0x7, 0x6, 0xE,\n    0x3, 0x1, 0x9, 0x4, 0x0, 0xA, 0xC, 0x5\n  };\n  static const unsigned char t1[16] = {\n    0x1, 0xE, 0x2, 0xB, 0x4, 0xC, 0x3, 0x7,\n    0x6, 0xD, 0xA, 0x5, 0xF, 0x9, 0x0, 0x8\n  };\n  static const unsigned char t2[16] = {\n    0x4, 0xC, 0x7, 0x5, 0x1, 0x6, 0x9, 0xA,\n    0x0, 0xE, 0xD, 0x8, 0x2, 0xB, 0x3, 0xF\n  };\n  static const unsigned char t3[16] = {\n    0xB, 0x9, 0x5, 0x1, 0xC, 0x3, 0xD, 0xE,\n    0x6, 0x4, 0x7, 0xF, 0x2, 0x0, 0x8, 0xA\n  };\n\n  unsigned char a0 = x / 16;\n  unsigned char b0 = x % 16;\n\n  unsigned char a1 = a0 ^ b0;\n  unsigned char b1 = a0 ^ ror4(b0) ^ ((8*a0) % 16);\n\n  unsigned char a2 = t0[a1];\n  unsigned char b2 = t1[b1];\n\n  unsigned char a3 = a2 ^ b2;\n  unsigned char b3 = a2 ^ ror4(b2) ^ ((8*a2) % 16);\n\n  unsigned char a4 = t2[a3];\n  unsigned char b4 = t3[b3];\n\n  unsigned char y = 16*b4 + a4;\n\n  return y;\n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned char",
        "unsigned",
        "char"
      ]
    },
    "main": {
      "start_point": [
        104,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "int\nmain(void)\n{\n  unsigned i;\n\n  printf(\"static const uint8_t q0[256] = {\");\n  for (i = 0; i < 256; i++) {\n    if ( (i % 8) == 0)\n      printf(\"\\n  \");\n    printf(\"0x%02X,\", q0(i));\n  }\n  printf(\"\\n};\\n\\n\");\n\n  printf(\"static const uint8_t q1[256] = {\");\n  for (i = 0; i < 256; i++) {\n    if ( (i % 8) == 0)\n      printf(\"\\n  \");\n    printf(\"0x%02X,\", q1(i));\n  }\n  printf(\"\\n};\\n\");\n\n  return 0;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-l2.c": {
    "_umac_l2_init": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        63,
        1
      ],
      "content": "void\n_umac_l2_init (unsigned size, uint32_t *k)\n{\n  unsigned i;\n  for (i = 0; i < size; i++)\n    {\n      uint32_t w = k[i];\n      w = BE_SWAP32 (w);\n      k[i] = w & KEY_MASK;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "_umac_l2": {
      "start_point": [
        65,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\n_umac_l2(const uint32_t *key, uint64_t *state, unsigned n,\n\t uint64_t count, const uint64_t *m)\n{\n  uint64_t *prev = state + 2*n;\n  unsigned i;\n\n  if (count == 0)\n    memcpy (prev, m, n * sizeof(*m));\n  else if (count == 1)\n    for (i = 0; i < n; i++, key += 6)\n      {\n\tuint64_t y = _umac_poly64 (key[0], key[1], 1, prev[i]);\n\tstate[2*i+1] = _umac_poly64 (key[0], key[1], y, m[i]);\n      }\n  else if (count < UMAC_POLY64_BLOCKS)\n    for (i = 0; i < n; i++, key += 6)\n      state[2*i+1] = _umac_poly64 (key[0], key[1], state[2*i+1], m[i]);\n  else if (count % 2 == 0)\n    {\n      if (count == UMAC_POLY64_BLOCKS)\n\tfor (i = 0, key += 2; i < n; i++, key += 6)\n\t  {\n\t    uint64_t y = state[2*i+1];\n\t    if (y >= UMAC_P64)\n\t      y -= UMAC_P64;\n\t    state[2*i] = 0;\n\t    state[2*i+1] = 1;\n\n\t    _umac_poly128 (key, state + 2*i, 0, y);\n\t  }\n      memcpy (prev, m, n * sizeof(*m));\n    }\n  else\n    for (i = 0, key += 2; i < n; i++, key += 6)\n      _umac_poly128 (key, state + 2*i, prev[i], m[i]);\n}",
      "lines": 37,
      "depth": 16,
      "decorators": [
        "void"
      ]
    },
    "_umac_l2_final": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "void\n_umac_l2_final(const uint32_t *key, uint64_t *state, unsigned n,\n\t       uint64_t count)\n{\n  uint64_t *prev = state + 2*n;\n  unsigned i;\n\n  assert (count > 0);\n  if (count == 1)\n    for (i = 0; i < n; i++)\n      {\n\t*state++ = 0;\n\t*state++ = *prev++;\n      }\n  else if (count <= UMAC_POLY64_BLOCKS)\n    for (i = 0; i < n; i++)\n      {\n\tuint64_t y;\n\t*state++ = 0;\n\n\ty = *state;\n\tif (y >= UMAC_P64)\n\t  y -= UMAC_P64;\n\t*state++ = y;\n      }\n  else\n    {\n      uint64_t pad = (uint64_t) 1 << 63;\n      if (count % 2 == 1)\n\tfor (i = 0, key += 2; i < n; i++, key += 6)\n\t  _umac_poly128 (key, state + 2*i, prev[i], pad);\n      else\n\tfor (i = 0, key += 2; i < n; i++, key += 6)\n\t  _umac_poly128 (key, state + 2*i, pad, 0);\n\n      for (i = 0; i < n; i++, state += 2)\n\t{\n\t  uint64_t yh, yl;\n\n\t  yh = state[0];\n\t  yl = state[1];\n\t  if (yh == UMAC_P128_HI && yl >= UMAC_P128_LO)\n\t    {\n\t      state[0] = 0;\n\t      state[1] = yl -= UMAC_P128_LO;\n\t    }\n\t}\n    }\n}",
      "lines": 49,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-l3.c": {
    "_umac_l3_init": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\n_umac_l3_init (unsigned size, uint64_t *k)\n{\n  unsigned i;\n  for (i = 0; i < size; i++)\n    {\n      uint64_t w = k[i];\n      w = BE_SWAP64 (w);\n      k[i] = w % P;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umac_l3_word": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static uint64_t\numac_l3_word (const uint64_t *k, uint64_t w)\n{\n  unsigned i;\n  uint64_t y;\n\n  /* Since it's easiest to process the input word from the low end,\n   * loop over keys in reverse order. */\n\n  for (i = y = 0; i < 4; i++, w >>= 16)\n    y += (w & 0xffff) * k[3-i];\n\n  return y;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "uint64_t"
      ]
    },
    "_umac_l3": {
      "start_point": [
        83,
        0
      ],
      "end_point": [
        94,
        1
      ],
      "content": "uint32_t\n_umac_l3 (const uint64_t *key, const uint64_t *m)\n{\n  uint32_t y = (umac_l3_word (key, m[0])\n\t\t+ umac_l3_word (key + 4, m[1])) % P;\n\n#if !WORDS_BIGENDIAN\n  y = ((ROTL32(8,  y) & 0x00FF00FFUL)\n       | (ROTL32(24, y) & 0xFF00FF00UL));\n#endif\n  return y;\n}",
      "lines": 12,
      "depth": 12,
      "decorators": [
        "uint32_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-nh-n.c": {
    "_umac_nh_n": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "void\n_umac_nh_n (uint64_t *out, unsigned n, const uint32_t *key,\n\t    unsigned length, const uint8_t *msg)\n{\n  assert (length > 0);\n  assert (length <= 1024);\n  assert (length % 32 == 0);\n\n  memset(out, 0, n*sizeof(*out));\n  \n  for (;length > 0; length -= 32, msg += 32, key += 8)\n    {\n      uint32_t a0, a1, b0, b1;\n      unsigned i;\n      a0 = LE_READ_UINT32 (msg);\n      a1 = LE_READ_UINT32 (msg + 4);\n      b0 = LE_READ_UINT32 (msg + 16);\n      b1 = LE_READ_UINT32 (msg + 20);\n      for (i = 0; i < n; i++)\n\tout[i] += (uint64_t) (a0 + key[0+4*i]) * (b0 + key[4+4*i])\n\t  + (uint64_t) (a1 + key[1+4*i]) * (b1 + key[5+4*i]);\n      a0 = LE_READ_UINT32 (msg + 8);\n      a1 = LE_READ_UINT32 (msg + 12);\n      b0 = LE_READ_UINT32 (msg + 24);\n      b1 = LE_READ_UINT32 (msg + 28);\n      for (i = 0; i < n; i++)\n\tout[i] += (uint64_t) (a0 + key[2+4*i]) * (b0 + key[6+4*i])\n\t  + (uint64_t) (a1 + key[3+4*i]) * (b1 + key[7+4*i]);      \n    }\n}",
      "lines": 30,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-nh.c": {
    "_umac_nh": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        73,
        1
      ],
      "content": "uint64_t\n_umac_nh (const uint32_t *key, unsigned length, const uint8_t *msg)\n{\n  uint64_t y;\n\n  assert (length > 0);\n  assert (length <= 1024);\n  assert (length % 32 == 0);\n  for (y = 0; length > 0; length -= 32, msg += 32, key += 8)\n    {\n      uint32_t a, b;\n      a = LE_READ_UINT32 (msg)      + key[0];\n      b = LE_READ_UINT32 (msg + 16) + key[4];\n      y += (uint64_t) a * b;\n      a = LE_READ_UINT32 (msg +  4) + key[1];\n      b = LE_READ_UINT32 (msg + 20) + key[5];\n      y += (uint64_t) a * b;\n      a = LE_READ_UINT32 (msg +  8) + key[2];\n      b = LE_READ_UINT32 (msg + 24) + key[6];\n      y += (uint64_t) a * b;\n      a = LE_READ_UINT32 (msg + 12) + key[3];\n      b = LE_READ_UINT32 (msg + 28) + key[7];\n      y += (uint64_t) a * b;\n    }\n\n  return y;\n}",
      "lines": 27,
      "depth": 11,
      "decorators": [
        "uint64_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-poly128.c": {
    "poly128_mul": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static void\npoly128_mul (const uint32_t *k, uint64_t *y)\n{\n  uint64_t y0,y1,y2,y3,p0,p1,p2,p3,m0,m1,m2;\n  y0 = LO (y[1]);\n  y1 = HI (y[1]);\n  y2 = LO (y[0]);\n  y3 = HI (y[0]);\n\n  p0 = y0 * k[3];\n  m0 = y0 * k[2] + y1 * k[3];\n  p1 = y0 * k[1] + y1 * k[2] + y2 * k[3];\n  m1 = y0 * k[0] + y1 * k[1] + y2 * k[2] + y3 * k[3];\n  p2 = y1 * k[0] + y2 * k[1] + y3 * k[2];\n  m2 = y2 * k[0] + y3 * k[1];\n  p3 = y3 * k[0];\n\n  /* Collaps to 4 64-bit words,\n     +---+---+---+---+\n     | p3| p2| p1| p0|\n     +-+-+-+-+-+-+-+-+\n    +  | m2| m1| m0|\n    -+-+-+-+-+-+-+-+-+\n  */\n  /* But it's convenient to reduce (p3,p2,p1,p0) and (m2,m1,m0) mod p first.*/\n  m1 += UMAC_P128_OFFSET * HI(p3);\n  p1 += UMAC_P128_OFFSET * (LO(p3) + HI(m2));\n  m0 += UMAC_P128_OFFSET * (HI(p2) + LO(m2));\n  p0 += UMAC_P128_OFFSET * (LO(p2) + HI(m1));\n\n  /* Left to add\n     +---+---+\n     | p1| p0|\n     +-+-+-+-+\n     m1| m0|\n     +-+---+\n  */\n  /* First add high parts, with no possibilities for carries */\n  p1 += m0 >> 32;\n\n  m0 <<= 32;\n  m1 <<= 32;\n\n  /* Remains:\n     +---+---+\n     | p1| p0|\n     +-+-+---+\n    +| m1| m0|\n    -+---+---+\n  */\n  p0 += m0;\n  p1 += (p0 < m0);\n  p1 += m1;\n  if (p1 < m1)\n    {\n      p0 += UMAC_P128_OFFSET;\n      p1 += (p0 < UMAC_P128_OFFSET);\n    }\n\n  y[0] = p1;\n  y[1] = p0;\n}",
      "lines": 62,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_umac_poly128": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\n_umac_poly128 (const uint32_t *k, uint64_t *y, uint64_t mh, uint64_t ml)\n{\n  uint64_t yh, yl, cy;\n\n  if ( (mh >> 32) == 0xffffffff)\n    {\n      poly128_mul (k, y);\n      if (y[1] > 0)\n\ty[1]--;\n      else if (y[0] > 0)\n\t{\n\t  y[0]--;\n\t  y[1] = UMAC_P128_HI;\n\t}\n      else\n\t{\n\t  y[0] = UMAC_P128_HI;\n\t  y[1] = UMAC_P128_LO-1;\n\t}\n\n      mh -= (ml < UMAC_P128_OFFSET);\n      ml -= UMAC_P128_OFFSET;\n    }\n  assert (mh < UMAC_P128_HI || ml < UMAC_P128_LO);\n\n  poly128_mul (k, y);\n  yl = y[1] + ml;\n  cy = (yl < ml);\n  yh = y[0] + cy;\n  cy = (yh < cy);\n  yh += mh;\n  cy += (yh < mh);\n  assert (cy <= 1);\n  if (cy)\n    {\n      yl += UMAC_P128_OFFSET;\n      yh += yl < UMAC_P128_OFFSET;\n    }\n\n  y[0] = yh;\n  y[1] = yl;\n}",
      "lines": 43,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-poly64.c": {
    "poly64_mul": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static uint64_t\npoly64_mul (uint32_t kh, uint32_t kl, uint64_t y)\n{\n  uint64_t yl, yh, pl, ph, ml, mh;\n  yl = y & 0xffffffff;\n  yh = y >> 32;\n  pl = yl * kl;\n  ph = yh * kh;\n  ml = yh * kl + yl * kh; /* No overflow, thanks to special form */\n  mh = ml >> 32;\n  ml <<= 32;\n  pl += ml;\n  ph += mh + (pl < ml);\n\n  /* Reduce, using 2^64 = UMAC_P64_OFFSET (mod p) */\n  assert (ph < ((uint64_t) 1 << 57));\n  ph *= UMAC_P64_OFFSET;\n  pl += ph;\n  if (pl < ph)\n    pl += UMAC_P64_OFFSET;\n\n  return pl;\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "uint64_t"
      ]
    },
    "_umac_poly64": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "uint64_t\n_umac_poly64 (uint32_t kh, uint32_t kl, uint64_t y, uint64_t m)\n{\n  if ( (m >> 32) == 0xffffffff)\n    {\n      y = poly64_mul (kh, kl, y);\n      if (y == 0)\n\ty = UMAC_P64 - 1;\n      else\n\ty--;\n      m -= UMAC_P64_OFFSET;\n    }\n  y = poly64_mul (kh, kl, y);\n  y += m;\n  if (y < m)\n    y += UMAC_P64_OFFSET;\n\n  return y;\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "uint64_t"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac-set-key.c": {
    "umac_kdf": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\numac_kdf (struct aes128_ctx *aes, unsigned index, unsigned length, uint8_t *dst)\n{\n  uint8_t block[AES_BLOCK_SIZE];\n  uint64_t count;\n  WRITE_UINT64 (block, (uint64_t) index);\n  for (count = 1; length >= AES_BLOCK_SIZE;\n       length -= AES_BLOCK_SIZE, dst += AES_BLOCK_SIZE, count++)\n    {\n      WRITE_UINT64 (block + 8, count);\n      aes128_encrypt (aes, AES_BLOCK_SIZE, dst, block);\n    }\n  if (length > 0)\n    {\n      WRITE_UINT64 (block + 8, count);\n      aes128_encrypt (aes, AES_BLOCK_SIZE, block, block);\n      memcpy (dst, block, length);\n    }\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_umac_set_key": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\n_umac_set_key (uint32_t *l1_key, uint32_t *l2_key,\n\t       uint64_t *l3_key1, uint32_t *l3_key2,\n\t       struct aes128_ctx *aes, const uint8_t *key, unsigned n)\n{\n  unsigned size;\n  uint8_t buffer[UMAC_KEY_SIZE];\n\n  aes128_set_encrypt_key (aes, key);\n\n  size = UMAC_BLOCK_SIZE / 4 + 4*(n-1);\n  umac_kdf (aes, 1, size * sizeof(uint32_t), (uint8_t *) l1_key);\n  BE_SWAP32_N (size, l1_key);\n\n  size = 6*n;\n  umac_kdf (aes, 2, size * sizeof(uint32_t), (uint8_t *) l2_key);\n  _umac_l2_init (size, l2_key);\n\n  size = 8*n;\n  umac_kdf (aes, 3, size * sizeof(uint64_t), (uint8_t *) l3_key1);\n  _umac_l3_init (size, l3_key1);\n\n  /* No need to byteswap these subkeys. */\n  umac_kdf (aes, 4, n * sizeof(uint32_t), (uint8_t *) l3_key2);\n\n  umac_kdf (aes, 0, UMAC_KEY_SIZE, buffer);\n  aes128_set_encrypt_key (aes, buffer);\n}",
      "lines": 28,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac.h": {},
  "nettle/nettle-3.4.1/umac128.c": {
    "umac128_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\numac128_set_key (struct umac128_ctx *ctx, const uint8_t *key)\n{\n  _umac_set_key (ctx->l1_key, ctx->l2_key, ctx->l3_key1, ctx->l3_key2,\n\t\t &ctx->pdf_key, key, 4);\n\n  /* Clear nonce */\n  memset (ctx->nonce, 0, sizeof(ctx->nonce));\n  ctx->nonce_length = sizeof(ctx->nonce);\n\n  /* Initialize buffer */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umac128_set_nonce": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\numac128_set_nonce (struct umac128_ctx *ctx,\n\t\t   size_t nonce_length, const uint8_t *nonce)\n{\n  assert (nonce_length > 0);\n  assert (nonce_length <= AES_BLOCK_SIZE);\n\n  memcpy (ctx->nonce, nonce, nonce_length);\n  memset (ctx->nonce + nonce_length, 0, AES_BLOCK_SIZE - nonce_length);\n\n  ctx->nonce_length = nonce_length;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac128_update": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\numac128_update (struct umac128_ctx *ctx,\n\t\tsize_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, UMAC128_BLOCK, (void)0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac128_digest": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        127,
        1
      ],
      "content": "void\numac128_digest (struct umac128_ctx *ctx,\n\t\tsize_t length, uint8_t *digest)\n{\n  uint32_t tag[4];\n  unsigned i;\n\n  assert (length > 0);\n  assert (length <= 16);\n\n  if (ctx->index > 0 || ctx->count == 0)\n    {\n      /* Zero pad to multiple of 32 */\n      uint64_t y[4];\n      unsigned pad = (ctx->index > 0) ? 31 & - ctx->index : 32;\n      memset (ctx->block + ctx->index, 0, pad);\n\n      _umac_nh_n (y, 4, ctx->l1_key, ctx->index + pad, ctx->block);\n      y[0] += 8 * ctx->index;\n      y[1] += 8 * ctx->index;\n      y[2] += 8 * ctx->index;\n      y[3] += 8 * ctx->index;\n      _umac_l2 (ctx->l2_key, ctx->l2_state, 4, ctx->count++, y);\n    }\n  assert (ctx->count > 0);\n\n  aes128_encrypt (&ctx->pdf_key, AES_BLOCK_SIZE,\n\t\t  (uint8_t *) tag, ctx->nonce);\n\n  INCREMENT (ctx->nonce_length, ctx->nonce);\n\n  _umac_l2_final (ctx->l2_key, ctx->l2_state, 4, ctx->count);\n  for (i = 0; i < 4; i++)\n    tag[i] ^= ctx->l3_key2[i] ^ _umac_l3 (ctx->l3_key1 + 8*i,\n\t\t\t\t\t  ctx->l2_state + 2*i);\n\n  memcpy (digest, tag, length);\n\n  /* Reinitialize */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 41,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac32.c": {
    "umac32_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\numac32_set_key (struct umac32_ctx *ctx, const uint8_t *key)\n{\n  _umac_set_key (ctx->l1_key, ctx->l2_key, ctx->l3_key1, ctx->l3_key2,\n\t\t &ctx->pdf_key, key, 1);\n\n  /* Clear nonce */\n  memset (ctx->nonce, 0, sizeof(ctx->nonce));\n  ctx->nonce_low = 0;\n  ctx->nonce_length = sizeof(ctx->nonce);\n\n  /* Initialize buffer */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umac32_set_nonce": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\numac32_set_nonce (struct umac32_ctx *ctx,\n\t\t  size_t nonce_length, const uint8_t *nonce)\n{\n  assert (nonce_length > 0);\n  assert (nonce_length <= AES_BLOCK_SIZE);\n\n  memcpy (ctx->nonce, nonce, nonce_length);\n  memset (ctx->nonce + nonce_length, 0, AES_BLOCK_SIZE - nonce_length);\n\n  ctx->nonce_low = ctx->nonce[nonce_length - 1] & 3;\n  ctx->nonce[nonce_length - 1] &= ~3;\n  ctx->nonce_length = nonce_length;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac32_update": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "void\numac32_update (struct umac32_ctx *ctx,\n\t       size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, UMAC32_BLOCK, (void)0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac32_digest": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        136,
        1
      ],
      "content": "void\numac32_digest (struct umac32_ctx *ctx,\n\t       size_t length, uint8_t *digest)\n{\n  uint32_t pad;\n\n  assert (length > 0);\n  assert (length <= 4);\n\n  if (ctx->index > 0 || ctx->count == 0)\n    {\n      /* Zero pad to multiple of 32 */\n      uint64_t y;\n      unsigned pad = (ctx->index > 0) ? 31 & - ctx->index : 32;\n      memset (ctx->block + ctx->index, 0, pad);\n\n      y = _umac_nh (ctx->l1_key, ctx->index + pad, ctx->block)\n\t+ 8 * ctx->index;\n      _umac_l2 (ctx->l2_key, ctx->l2_state, 1, ctx->count++, &y);\n    }\n  assert (ctx->count > 0);\n  if ( !(ctx->nonce_low & _UMAC_NONCE_CACHED))\n    {\n      aes128_encrypt (&ctx->pdf_key, AES_BLOCK_SIZE,\n\t\t      (uint8_t *) ctx->pad_cache, ctx->nonce);\n      ctx->nonce_low |= _UMAC_NONCE_CACHED;\n    }\n\n  pad = ctx->pad_cache[ctx->nonce_low & 3];\n\n  /* Increment nonce */\n  ctx->nonce_low++;\n  if ( !(ctx->nonce_low & 3))\n    {\n      unsigned i = ctx->nonce_length - 1;\n\n      ctx->nonce_low = 0;\n      ctx->nonce[i] += 4;\n\n      if (ctx->nonce[i] == 0 && i > 0)\n\tINCREMENT (i, ctx->nonce);\n    }\n\n  _umac_l2_final (ctx->l2_key, ctx->l2_state, 1, ctx->count);\n  pad ^= ctx->l3_key2[0] ^ _umac_l3 (ctx->l3_key1, ctx->l2_state);\n  memcpy (digest, &pad, length);\n\n  /* Reinitialize */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 50,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac64.c": {
    "umac64_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\numac64_set_key (struct umac64_ctx *ctx, const uint8_t *key)\n{\n  _umac_set_key (ctx->l1_key, ctx->l2_key, ctx->l3_key1, ctx->l3_key2,\n\t\t &ctx->pdf_key, key, 2);\n\n  /* Clear nonce */\n  memset (ctx->nonce, 0, sizeof(ctx->nonce));\n  ctx->nonce_low = 0;\n  ctx->nonce_length = sizeof(ctx->nonce);\n\n  /* Initialize buffer */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umac64_set_nonce": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "void\numac64_set_nonce (struct umac64_ctx *ctx,\n\t\t  size_t nonce_length, const uint8_t *nonce)\n{\n  assert (nonce_length > 0);\n  assert (nonce_length <= AES_BLOCK_SIZE);\n\n  memcpy (ctx->nonce, nonce, nonce_length);\n  memset (ctx->nonce + nonce_length, 0, AES_BLOCK_SIZE - nonce_length);\n\n  ctx->nonce_low = ctx->nonce[nonce_length - 1] & 1;\n  ctx->nonce[nonce_length - 1] &= ~1;\n  ctx->nonce_length = nonce_length;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac64_update": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\numac64_update (struct umac64_ctx *ctx,\n\t       size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, UMAC64_BLOCK, (void)0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac64_digest": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\numac64_digest (struct umac64_ctx *ctx,\n\t       size_t length, uint8_t *digest)\n{\n  uint32_t tag[2];\n  uint32_t *pad;\n\n  assert (length > 0);\n  assert (length <= 8);\n\n  if (ctx->index > 0 || ctx->count == 0)\n    {\n      /* Zero pad to multiple of 32 */\n      uint64_t y[2];\n      unsigned pad = (ctx->index > 0) ? 31 & - ctx->index : 32;\n      memset (ctx->block + ctx->index, 0, pad);\n\n      _umac_nh_n (y, 2, ctx->l1_key, ctx->index + pad, ctx->block);\n      y[0] += 8 * ctx->index;\n      y[1] += 8 * ctx->index;\n      _umac_l2 (ctx->l2_key, ctx->l2_state, 2, ctx->count++, y);\n    }\n  assert (ctx->count > 0);\n  if ( !(ctx->nonce_low & _UMAC_NONCE_CACHED))\n    {\n      aes128_encrypt (&ctx->pdf_key, AES_BLOCK_SIZE,\n\t\t      (uint8_t *) ctx->pad_cache, ctx->nonce);\n      ctx->nonce_low |= _UMAC_NONCE_CACHED;\n    }\n  pad = ctx->pad_cache + 2*(ctx->nonce_low & 1);\n\n  /* Increment nonce */\n  ctx->nonce_low++;\n  if ( !(ctx->nonce_low & 1))\n    {\n      unsigned i = ctx->nonce_length - 1;\n\n      ctx->nonce_low = 0;\n      ctx->nonce[i] += 2;\n\n      if (ctx->nonce[i] == 0 && i > 0)\n\tINCREMENT (i, ctx->nonce);\n    }\n\n  _umac_l2_final (ctx->l2_key, ctx->l2_state, 2, ctx->count);\n  tag[0] = pad[0] ^ ctx->l3_key2[0] ^ _umac_l3 (ctx->l3_key1,\n\t\t\t\t\t\tctx->l2_state);\n  tag[1] = pad[1] ^ ctx->l3_key2[1] ^ _umac_l3 (ctx->l3_key1 + 8,\n\t\t\t\t\t\tctx->l2_state + 2);\n  memcpy (digest, tag, length);\n\n  /* Reinitialize */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/umac96.c": {
    "umac96_set_key": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\numac96_set_key (struct umac96_ctx *ctx, const uint8_t *key)\n{\n  _umac_set_key (ctx->l1_key, ctx->l2_key, ctx->l3_key1, ctx->l3_key2,\n\t\t &ctx->pdf_key, key, 3);\n\n  /* Clear nonce */\n  memset (ctx->nonce, 0, sizeof(ctx->nonce));\n  ctx->nonce_length = sizeof(ctx->nonce);\n\n  /* Initialize buffer */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "umac96_set_nonce": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "void\numac96_set_nonce (struct umac96_ctx *ctx,\n\t\t  size_t nonce_length, const uint8_t *nonce)\n{\n  assert (nonce_length > 0);\n  assert (nonce_length <= AES_BLOCK_SIZE);\n\n  memcpy (ctx->nonce, nonce, nonce_length);\n  memset (ctx->nonce + nonce_length, 0, AES_BLOCK_SIZE - nonce_length);\n\n  ctx->nonce_length = nonce_length;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac96_update": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "void\numac96_update (struct umac96_ctx *ctx,\n\t       size_t length, const uint8_t *data)\n{\n  MD_UPDATE (ctx, length, data, UMAC96_BLOCK, (void)0);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "umac96_digest": {
      "start_point": [
        86,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\numac96_digest (struct umac96_ctx *ctx,\n\t       size_t length, uint8_t *digest)\n{\n  uint32_t tag[4];\n  unsigned i;\n\n  assert (length > 0);\n  assert (length <= 12);\n\n  if (ctx->index > 0 || ctx->count == 0)\n    {\n      /* Zero pad to multiple of 32 */\n      uint64_t y[3];\n      unsigned pad = (ctx->index > 0) ? 31 & - ctx->index : 32;\n      memset (ctx->block + ctx->index, 0, pad);\n\n      _umac_nh_n (y, 3, ctx->l1_key, ctx->index + pad, ctx->block);\n      y[0] += 8 * ctx->index;\n      y[1] += 8 * ctx->index;\n      y[2] += 8 * ctx->index;\n      _umac_l2 (ctx->l2_key, ctx->l2_state, 3, ctx->count++, y);\n    }\n  assert (ctx->count > 0);\n\n  aes128_encrypt (&ctx->pdf_key, AES_BLOCK_SIZE,\n\t\t  (uint8_t *) tag, ctx->nonce);\n\n  INCREMENT (ctx->nonce_length, ctx->nonce);\n\n  _umac_l2_final (ctx->l2_key, ctx->l2_state, 3, ctx->count);\n  for (i = 0; i < 3; i++)\n    tag[i] ^= ctx->l3_key2[i] ^ _umac_l3 (ctx->l3_key1 + 8*i,\n\t\t\t\t\t  ctx->l2_state + 2*i);\n\n  memcpy (digest, tag, length);\n\n  /* Reinitialize */\n  ctx->count = ctx->index = 0;\n}",
      "lines": 40,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/version.c": {
    "nettle_version_major": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        41,
        1
      ],
      "content": "int\nnettle_version_major (void)\n{\n  return NETTLE_VERSION_MAJOR;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    },
    "nettle_version_minor": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "int\nnettle_version_minor (void)\n{\n  return NETTLE_VERSION_MINOR;\n}",
      "lines": 5,
      "depth": 5,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/write-be32.c": {
    "_nettle_write_be32": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\n_nettle_write_be32(size_t length, uint8_t *dst,\n\t\t   const uint32_t *src)\n{\n  size_t i;\n  size_t words;\n  unsigned leftover;\n  \n  words = length / 4;\n  leftover = length % 4;\n\n  for (i = 0; i < words; i++, dst += 4)\n    WRITE_UINT32(dst, src[i]);\n\n  if (leftover)\n    {\n      uint32_t word;\n      unsigned j = leftover;\n      \n      word = src[i];\n      \n      switch (leftover)\n\t{\n\tdefault:\n\t  abort();\n\tcase 3:\n\t  dst[--j] = (word >> 8) & 0xff;\n\t  /* Fall through */\n\tcase 2:\n\t  dst[--j] = (word >> 16) & 0xff;\n\t  /* Fall through */\n\tcase 1:\n\t  dst[--j] = (word >> 24) & 0xff;\n\t}\n    }\n}",
      "lines": 36,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/write-le32.c": {
    "_nettle_write_le32": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\n_nettle_write_le32(size_t length, uint8_t *dst,\n\t\t   const uint32_t *src)\n{\n  size_t i;\n  size_t words;\n  unsigned leftover;\n  \n  words = length / 4;\n  leftover = length % 4;\n\n  for (i = 0; i < words; i++, dst += 4)\n    LE_WRITE_UINT32(dst, src[i]);\n\n  if (leftover)\n    {\n      uint32_t word;\n      \n      word = src[i];\n\n      do\n\t{\n\t  *dst++ = word & 0xff;\n\t  word >>= 8;\n\t}\n      while (--leftover);\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/write-le64.c": {
    "_nettle_write_le64": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "void\n_nettle_write_le64(size_t length, uint8_t *dst,\n\t\t   const uint64_t *src)\n{\n  size_t i;\n  size_t words;\n  unsigned leftover;\n  \n  words = length / 8;\n  leftover = length % 8;\n\n  for (i = 0; i < words; i++, dst += 8)\n    LE_WRITE_UINT64(dst, src[i]);\n\n  if (leftover)\n    {\n      uint64_t word;\n      \n      word = src[i];\n\n      do\n\t{\n\t  *dst++ = word & 0xff;\n\t  word >>= 8;\n\t}\n      while (--leftover);\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/yarrow.h": {},
  "nettle/nettle-3.4.1/yarrow256.c": {
    "yarrow256_init": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        107,
        1
      ],
      "content": "void\nyarrow256_init(struct yarrow256_ctx *ctx,\n\t       unsigned n,\n\t       struct yarrow_source *s)\n{\n  unsigned i;\n\n  sha256_init(&ctx->pools[0]);\n  sha256_init(&ctx->pools[1]);\n  \n  ctx->seeded = 0;\n\n  /* Not strictly necessary, but it makes it easier to see if the\n   * values are sane. */\n  memset(ctx->counter, 0, sizeof(ctx->counter));\n  \n  ctx->nsources = n;\n  ctx->sources = s;\n\n  for (i = 0; i<n; i++)\n    {\n      ctx->sources[i].estimate[YARROW_FAST] = 0;\n      ctx->sources[i].estimate[YARROW_SLOW] = 0;\n      ctx->sources[i].next = YARROW_FAST;\n    }\n}",
      "lines": 26,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "yarrow256_seed": {
      "start_point": [
        109,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void\nyarrow256_seed(struct yarrow256_ctx *ctx,\n\t       size_t length,\n\t       const uint8_t *seed_file)\n{\n  assert(length > 0);\n\n  sha256_update(&ctx->pools[YARROW_FAST], length, seed_file);\n  yarrow256_fast_reseed(ctx);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yarrow_generate_block": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static void\nyarrow_generate_block(struct yarrow256_ctx *ctx,\n\t\t      uint8_t *block)\n{\n  unsigned i;\n\n  aes256_encrypt(&ctx->key, sizeof(ctx->counter), block, ctx->counter);\n\n  /* Increment counter, treating it as a big-endian number. This is\n   * machine independent, and follows appendix B of the NIST\n   * specification of cipher modes of operation.\n   *\n   * We could keep a representation of the counter as 4 32-bit values,\n   * and write entire words (in big-endian byteorder) into the counter\n   * block, whenever they change. */\n  for (i = sizeof(ctx->counter); i--; )\n    {\n      if (++ctx->counter[i])\n\tbreak;\n    }\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yarrow_iterate": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void\nyarrow_iterate(uint8_t *digest)\n{\n  uint8_t v0[SHA256_DIGEST_SIZE];\n  unsigned i;\n  \n  memcpy(v0, digest, SHA256_DIGEST_SIZE);\n  \n  /* When hashed inside the loop, i should run from 1 to\n   * YARROW_RESEED_ITERATIONS */\n  for (i = 0; ++i < YARROW_RESEED_ITERATIONS; )\n    {\n      uint8_t count[4];\n      struct sha256_ctx hash;\n  \n      sha256_init(&hash);\n\n      /* Hash v_i | v_0 | i */\n      WRITE_UINT32(count, i);\n      sha256_update(&hash, SHA256_DIGEST_SIZE, digest);\n      sha256_update(&hash, sizeof(v0), v0);\n      sha256_update(&hash, sizeof(count), count);\n\n      sha256_digest(&hash, SHA256_DIGEST_SIZE, digest);\n    }\n}",
      "lines": 26,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yarrow256_fast_reseed": {
      "start_point": [
        174,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "void\nyarrow256_fast_reseed(struct yarrow256_ctx *ctx)\n{\n  uint8_t digest[SHA256_DIGEST_SIZE];\n  unsigned i;\n  \n#if YARROW_DEBUG\n  fprintf(stderr, \"yarrow256_fast_reseed\\n\");\n#endif\n  \n  /* We feed two block of output using the current key into the pool\n   * before emptying it. */\n  if (ctx->seeded)\n    {\n      uint8_t blocks[AES_BLOCK_SIZE * 2];\n      \n      yarrow_generate_block(ctx, blocks);\n      yarrow_generate_block(ctx, blocks + AES_BLOCK_SIZE);\n      sha256_update(&ctx->pools[YARROW_FAST], sizeof(blocks), blocks);\n    }\n  \n  sha256_digest(&ctx->pools[YARROW_FAST], sizeof(digest), digest);\n\n  /* Iterate */\n  yarrow_iterate(digest);\n\n  aes256_set_encrypt_key(&ctx->key, digest);\n  ctx->seeded = 1;\n\n  /* Derive new counter value */\n  memset(ctx->counter, 0, sizeof(ctx->counter));\n  aes256_encrypt(&ctx->key, sizeof(ctx->counter), ctx->counter, ctx->counter);\n  \n  /* Reset estimates. */\n  for (i = 0; i<ctx->nsources; i++)\n    ctx->sources[i].estimate[YARROW_FAST] = 0;\n}",
      "lines": 37,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "yarrow256_slow_reseed": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\nyarrow256_slow_reseed(struct yarrow256_ctx *ctx)\n{\n  uint8_t digest[SHA256_DIGEST_SIZE];\n  unsigned i;\n\n#if YARROW_DEBUG\n  fprintf(stderr, \"yarrow256_slow_reseed\\n\");\n#endif\n\n  /* Get digest of the slow pool*/\n  sha256_digest(&ctx->pools[YARROW_SLOW], sizeof(digest), digest);\n\n  /* Feed it into the fast pool */\n  sha256_update(&ctx->pools[YARROW_FAST], sizeof(digest), digest);\n\n  yarrow256_fast_reseed(ctx);\n  \n  /* Reset estimates. */\n  for (i = 0; i<ctx->nsources; i++)\n    ctx->sources[i].estimate[YARROW_SLOW] = 0;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "yarrow256_update": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "int\nyarrow256_update(struct yarrow256_ctx *ctx,\n\t\t unsigned source_index, unsigned entropy,\n\t\t size_t length, const uint8_t *data)\n{\n  enum yarrow_pool_id current;\n  struct yarrow_source *source;\n  \n  assert(source_index < ctx->nsources);\n\n  if (!length)\n    /* Nothing happens */\n    return 0;\n\n  source = &ctx->sources[source_index];\n  \n  if (!ctx->seeded)\n    /* While seeding, use the slow pool */\n    current = YARROW_SLOW;\n  else\n    {\n      current = source->next;\n      source->next = !source->next;\n    }\n\n  sha256_update(&ctx->pools[current], length, data);\n \n  /* NOTE: We should be careful to avoid overflows in the estimates. */\n  if (source->estimate[current] < YARROW_MAX_ENTROPY)\n    {\n      if (entropy > YARROW_MAX_ENTROPY)\n\tentropy = YARROW_MAX_ENTROPY;\n\n      if ( (length < (YARROW_MAX_ENTROPY / YARROW_MULTIPLIER))\n\t   && (entropy > YARROW_MULTIPLIER * length) )\n\tentropy = YARROW_MULTIPLIER * length;\n\n      entropy += source->estimate[current];\n      if (entropy > YARROW_MAX_ENTROPY)\n\tentropy = YARROW_MAX_ENTROPY;\n\n      source->estimate[current] = entropy;\n    }\n\n  /* Check for seed/reseed */\n  switch(current)\n    {\n    case YARROW_FAST:\n#if YARROW_DEBUG\n      fprintf(stderr,\n              \"yarrow256_update: source_index = %d,\\n\"\n              \"            fast pool estimate = %d\\n\",\n              source_index, source->estimate[YARROW_FAST]);\n#endif\n      if (source->estimate[YARROW_FAST] >= YARROW_FAST_THRESHOLD)\n\t{\n\t  yarrow256_fast_reseed(ctx);\n\t  return 1;\n\t}\n      else\n\treturn 0;\n\n    case YARROW_SLOW:\n      {\n        if (!yarrow256_needed_sources(ctx))\n\t  {\n\t    yarrow256_slow_reseed(ctx);\n\t    return 1;\n\t  }\n\telse\n\t  return 0;\n      }\n    default:\n      abort();\n    }\n}",
      "lines": 76,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "yarrow_gate": {
      "start_point": [
        312,
        0
      ],
      "end_point": [
        322,
        1
      ],
      "content": "static void\nyarrow_gate(struct yarrow256_ctx *ctx)\n{\n  uint8_t key[AES256_KEY_SIZE];\n  unsigned i;\n\n  for (i = 0; i < sizeof(key); i+= AES_BLOCK_SIZE)\n    yarrow_generate_block(ctx, key + i);\n\n  aes256_set_encrypt_key(&ctx->key, key);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "yarrow256_random": {
      "start_point": [
        324,
        0
      ],
      "end_point": [
        344,
        1
      ],
      "content": "void\nyarrow256_random(struct yarrow256_ctx *ctx, size_t length, uint8_t *dst)\n{\n  assert(ctx->seeded);\n\n  while (length >= AES_BLOCK_SIZE)\n    {\n      yarrow_generate_block(ctx, dst);\n      dst += AES_BLOCK_SIZE;\n      length -= AES_BLOCK_SIZE;\n    }\n  if (length)\n    {\n      uint8_t buffer[AES_BLOCK_SIZE];\n      \n      assert(length < AES_BLOCK_SIZE);\n      yarrow_generate_block(ctx, buffer);\n      memcpy(dst, buffer, length);\n    }\n  yarrow_gate(ctx);\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "yarrow256_is_seeded": {
      "start_point": [
        346,
        0
      ],
      "end_point": [
        350,
        1
      ],
      "content": "int\nyarrow256_is_seeded(struct yarrow256_ctx *ctx)\n{\n  return ctx->seeded;\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "int"
      ]
    },
    "yarrow256_needed_sources": {
      "start_point": [
        352,
        0
      ],
      "end_point": [
        373,
        1
      ],
      "content": "unsigned\nyarrow256_needed_sources(struct yarrow256_ctx *ctx)\n{\n  /* FIXME: This is somewhat inefficient. It would be better to\n   * either maintain the count, or do this loop only if the\n   * current source just crossed the threshold. */\n  unsigned k, i;\n\n  for (i = k = 0; i < ctx->nsources; i++)\n    if (ctx->sources[i].estimate[YARROW_SLOW] >= YARROW_SLOW_THRESHOLD)\n      k++;\n\n#if YARROW_DEBUG\n  fprintf(stderr,\n          \"yarrow256_needed_sources: source_index = %d,\\n\"\n          \"                    slow pool estimate = %d,\\n\"\n          \"     number of sources above threshold = %d\\n\",\n          source_index, source->estimate[YARROW_SLOW], k);\n#endif\n  \n  return (k < YARROW_SLOW_K) ? (YARROW_SLOW_K - k) : 0;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    }
  },
  "nettle/nettle-3.4.1/yarrow_key_event.c": {
    "yarrow_key_event_init": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        49,
        1
      ],
      "content": "void\nyarrow_key_event_init(struct yarrow_key_event_ctx *ctx)\n{\n  unsigned i;\n  \n  ctx->index = 0;\n  ctx->previous = 0;\n  \n  for (i = 0; i < YARROW_KEY_EVENT_BUFFER; i++)\n    ctx->chars[i] = 0;  \n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "yarrow_key_event_estimate": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "unsigned\nyarrow_key_event_estimate(struct yarrow_key_event_ctx *ctx,\n\t\t\t  unsigned key, unsigned time)\n{\n  unsigned entropy = 0;\n  unsigned i;\n\n  /* Look at timing first. */\n  if (ctx->previous && (time > ctx->previous) )\n    {\n      if ( (time - ctx->previous) >= 256)\n        entropy++;\n    }\n  ctx->previous = time;\n\n  if (!key)\n    return entropy;\n  \n  for (i = 0; i < YARROW_KEY_EVENT_BUFFER; i++)\n    if (key == ctx->chars[i])\n      /* This is a recent character. Ignore it. */\n      return entropy;\n\n  /* Count one bit of entropy, unless this was one of the initial 16\n   * characters. */\n  if (ctx->chars[ctx->index])\n    entropy++;\n  \n  /* Remember the character. */\n  \n  ctx->chars[ctx->index] = key;\n  ctx->index = (ctx->index + 1) % YARROW_KEY_EVENT_BUFFER;\n\n  return entropy;\n}",
      "lines": 35,
      "depth": 11,
      "decorators": [
        "unsigned",
        "unsigned"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/base16dec.c": {
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "int\nmain(int argc UNUSED, char **argv UNUSED)\n{\n  /* \"buffer\" will hold the bytes from disk: */\n  char * buffer = xalloc (CHUNK_SIZE);\n\n  /* \"result\" will hold bytes before output: */\n  uint8_t * result = xalloc (DECODED_SIZE);\n\n  /* We need a Base16 context for decoding: */\n  struct base16_decode_ctx b16_ctx;\n\n  /* Init the context: */\n  base16_decode_init (&b16_ctx);\n\n#ifdef WIN32\n  _setmode(1, O_BINARY);\n#endif\n\n  for (;;)\n    {\n      int nbytes; /* Number of bytes read frmo disk at each iteration */\n      size_t decoded_bytes; /* Bytes actually generated at each iteration */\n\n      nbytes = fread(buffer, 1, CHUNK_SIZE, stdin);\n\n      if (nbytes < CHUNK_SIZE && ferror(stdin))\n\t{\n\t  werror (\"Error reading file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n      \n      /* Decodes one chunk: */\n      if (!base16_decode_update(&b16_ctx, &decoded_bytes, result, nbytes, buffer))\n\t{\n\t  werror (\"Error decoding input (not base16?)\\n\");\n\t  return EXIT_FAILURE;\n\t}\n\n      if (!write_data (stdout, decoded_bytes, result))\n\t{\n\t  werror (\"Error writing file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n      if (nbytes < CHUNK_SIZE)\n\t{\n\t  /* Check if decoding finalized OK: */\n\t  if (!base16_decode_final(&b16_ctx))\n\t    {\n\t      werror(\"Decoding did not finish properly.\\n\");\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\t}\n    }\n\n  if (fflush (stdout) != 0)\n    {\n      werror (\"Error writing file: %s\\n\", strerror(errno));\n      return EXIT_FAILURE;\n    }\n\n  free (buffer);\n  free (result);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/base16enc.c": {
    "main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "int\nmain(int argc UNUSED, char **argv UNUSED)\n{\n\n#ifdef WIN32\n  _setmode(0, O_BINARY);\n#endif\n  \n  /* There is no context to initialize. */\n\n  for (;;)\n    {\n      /* \"buffer\" will hold the bytes from disk: */\n      uint8_t buffer[CHUNK_SIZE];\n      /* \"result\" will hold bytes before output: */\n      char result[ENCODED_SIZE + 1];\n      unsigned nbytes; /* Number of bytes read from stdin */\n      int encoded_bytes; /* Total number of bytes encoded per iteration */\n      \n      nbytes = fread(buffer,1,CHUNK_SIZE,stdin);\n\n      /* We overwrite result with more data */\n      base16_encode_update(result, nbytes, buffer);\n      encoded_bytes = BASE16_ENCODE_LENGTH(nbytes);\n      result[encoded_bytes++] = '\\n';\n      \n      if (nbytes < CHUNK_SIZE)\n\t{\n\t  if (ferror(stdin))\n\t    {\n\t      werror (\"Error reading file: %s\\n\", strerror(errno));\n\t      return EXIT_FAILURE;\n\t    }\n\t  if (!write_data (stdout, encoded_bytes, result)\n\t      || fflush (stdout) != 0)\n\t    {\n\t      werror (\"Error writing file: %s\\n\", strerror(errno));\n\t      return EXIT_FAILURE;\n\t    }\n\t  return EXIT_SUCCESS;\n\t}\n      /* The result vector is printed */\n      if (!write_data(stdout, encoded_bytes, result))\n\t{\n\t  werror (\"Error writing file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n    }\n}",
      "lines": 49,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/base64dec.c": {
    "main": {
      "start_point": [
        56,
        0
      ],
      "end_point": [
        123,
        1
      ],
      "content": "int\nmain(int argc UNUSED, char **argv UNUSED)\n{\n  /* \"buffer\" will hold the bytes from disk: */\n  char * buffer = xalloc (CHUNK_SIZE);\n\n  /* \"result\" will hold bytes before output: */\n  uint8_t * result = xalloc (DECODED_SIZE);\n\n  /* We need a Base64 context for decoding: */\n  struct base64_decode_ctx b64_ctx;\n\n  /* Init the context: */\n  base64_decode_init(&b64_ctx);\n\n#ifdef WIN32\n  _setmode(1, O_BINARY);\n#endif\n\n  for (;;)\n    {\n      int nbytes; /* Number of bytes read frmo disk at each iteration */\n      size_t decoded_bytes; /* Bytes actually generated at each iteration */\n\n      nbytes = fread(buffer, 1, CHUNK_SIZE, stdin);\n\n      if (nbytes < CHUNK_SIZE && ferror(stdin))\n\t{\n\t  werror (\"Error reading file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n\n      /* Decodes one chunk: */\n      if (!base64_decode_update(&b64_ctx, &decoded_bytes, result, nbytes, buffer))\n\t{\n\t  werror (\"Error decoding input (not base64?)\\n\");\n\t  return EXIT_FAILURE;\n\t}\n\n      if (!write_data (stdout, decoded_bytes, result))\n\t{\n\t  werror (\"Error writing file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n\n      if (nbytes < CHUNK_SIZE)\n\t{\n\t  /* Check if decoding finalized OK: */\n\t  if (!base64_decode_final(&b64_ctx))\n\t    {\n\t      werror (\"Decoding did not finish properly.\\n\");\n\t      return EXIT_FAILURE;\n\t    }\n\t  break;\n\t}\n    }\n\n  if (fflush (stdout) != 0)\n    {\n      werror (\"Error writing file: %s\\n\", strerror(errno));\n      return EXIT_FAILURE;\n    }\n\n  free (buffer);\n  free (result);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 68,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/base64enc.c": {
    "main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "int\nmain(int argc UNUSED, char **argv UNUSED)\n{\n  struct base64_encode_ctx b64_ctx;\n\n  /* Init the context: */\n  base64_encode_init(&b64_ctx);\n\n#ifdef WIN32\n  _setmode(0, O_BINARY);\n#endif\n\n  for (;;)\n    {\n      /* \"buffer\" will hold the bytes from disk: */\n      uint8_t buffer[CHUNK_SIZE];\n      /* \"result\" is the result vector: */\n      char result[ENCODED_SIZE + BASE64_ENCODE_FINAL_LENGTH + 1];\n      unsigned nbytes; /* Number of bytes read from stdin */\n      int encoded_bytes; /* total number of bytes encoded per iteration */\n      nbytes = fread(buffer,1,CHUNK_SIZE,stdin);\n\n      /* We overwrite result with more data */\n      encoded_bytes = base64_encode_update(&b64_ctx, result, nbytes, buffer);\n\n      if (nbytes < CHUNK_SIZE)\n\t{\n\t  if (ferror(stdin))\n\t    {\n\t      werror (\"Error reading file: %s\\n\", strerror(errno));\n\t      return EXIT_FAILURE;\n\t    }\n\t  encoded_bytes += base64_encode_final(&b64_ctx,result + encoded_bytes);\n\n\t  result[encoded_bytes++] = '\\n';\n\t  if (!write_data (stdout, encoded_bytes, result)\n\t      || fflush (stdout) != 0)\n\t    {\n\t      werror (\"Error writing file: %s\\n\", strerror(errno));\n\t      return EXIT_FAILURE;\n\t    }\n\t  return EXIT_SUCCESS;\n\t}\n\n      /* The result vector is written */\n      result[encoded_bytes++] = '\\n';\n      if (!write_data (stdout, encoded_bytes, result))\n\t{\n\t  werror (\"Error writing file: %s\\n\", strerror(errno));\n\t  return EXIT_FAILURE;\n\t}\n    }\n}",
      "lines": 53,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/ecc-benchmark.c": {
    "xalloc": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void *\nxalloc (size_t size)\n{\n  void *p = malloc (size);\n  if (!p)\n    {\n      fprintf (stderr, \"Virtual memory exhausted\\n\");\n      abort ();\n    }\n  return p;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nxalloc (size_t size)",
        "*"
      ]
    },
    "xalloc_limbs": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static mp_limb_t *\nxalloc_limbs (mp_size_t size)\n{\n  return xalloc (size * sizeof(mp_limb_t));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "mp_limb_t",
        "*\nxalloc_limbs (mp_size_t size)",
        "*"
      ]
    },
    "time_function": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static double\ntime_function(void (*f)(void *arg), void *arg)\n{\n  unsigned ncalls;\n  double elapsed;\n\n  /* Warm up */\n  f(arg);\n  for (ncalls = 10 ;;)\n    {\n      unsigned i;\n\n      time_start();\n      for (i = 0; i < ncalls; i++)\n\tf(arg);\n      elapsed = time_end();\n      if (elapsed > BENCH_INTERVAL)\n\tbreak;\n      else if (elapsed < BENCH_INTERVAL / 10)\n\tncalls *= 10;\n      else\n\tncalls *= 2;\n    }\n  return elapsed / ncalls;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "modinv_gcd": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "static int\nmodinv_gcd (const struct ecc_curve *ecc,\n\t    mp_limb_t *rp, mp_limb_t *ap, mp_limb_t *tp)\n{\n  mp_size_t size = ecc->p.size;\n  mp_limb_t *up = tp;\n  mp_limb_t *vp = tp + size+1;\n  mp_limb_t *gp = tp + 2*(size+1);\n  mp_limb_t *sp = tp + 3*(size+1);\n  mp_size_t gn, sn;\n\n  mpn_copyi (up, ap, size);\n  mpn_copyi (vp, ecc->p.m, size);\n  gn = mpn_gcdext (gp, sp, &sn, up, size, vp, size);\n  if (gn != 1 || gp[0] != 1)\n    return 0;\n  \n  if (sn < 0)\n    mpn_sub (sp, ecc->p.m, size, sp, -sn);\n  else if (sn < size)\n    /* Zero-pad. */\n    mpn_zero (sp + sn, size - sn);\n\n  mpn_copyi (rp, sp, size);\n  return 1;\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bench_modp": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "static void\nbench_modp (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  mpn_copyi (ctx->rp, ctx->ap, 2*ctx->ecc->p.size);\n  ctx->ecc->p.mod (&ctx->ecc->p, ctx->rp);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_reduce": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "static void\nbench_reduce (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  mpn_copyi (ctx->rp, ctx->ap, 2*ctx->ecc->p.size);\n  ctx->ecc->p.reduce (&ctx->ecc->p, ctx->rp);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_modq": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static void\nbench_modq (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  mpn_copyi (ctx->rp, ctx->ap, 2*ctx->ecc->p.size);\n  ctx->ecc->q.mod(&ctx->ecc->q, ctx->rp);\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_modinv": {
      "start_point": [
        160,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "static void\nbench_modinv (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ctx->ecc->p.invert (&ctx->ecc->p, ctx->rp, ctx->ap, ctx->tp);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_modinv_gcd": {
      "start_point": [
        168,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nbench_modinv_gcd (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  mpn_copyi (ctx->rp + ctx->ecc->p.size, ctx->ap, ctx->ecc->p.size);\n  modinv_gcd (ctx->ecc, ctx->rp, ctx->rp + ctx->ecc->p.size, ctx->tp);  \n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_modinv_powm": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        189,
        1
      ],
      "content": "static void\nbench_modinv_powm (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  const struct ecc_curve *ecc = ctx->ecc;\n  mp_size_t size = ecc->p.size;\n  \n  mpn_sub_1 (ctx->rp + size, ecc->p.m, size, 2);\n  mpn_sec_powm (ctx->rp, ctx->ap, size,\n\t\tctx->rp + size, ecc->p.bit_size,\n\t\tecc->p.m, size, ctx->tp);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_dup_jj": {
      "start_point": [
        192,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "static void\nbench_dup_jj (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ecc_dup_jj (ctx->ecc, ctx->rp, ctx->ap, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_add_jja": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void\nbench_add_jja (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ecc_add_jja (ctx->ecc, ctx->rp, ctx->ap, ctx->bp, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_add_hhh": {
      "start_point": [
        206,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "static void\nbench_add_hhh (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ctx->ecc->add_hhh (ctx->ecc, ctx->rp, ctx->ap, ctx->bp, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_mul_g": {
      "start_point": [
        213,
        0
      ],
      "end_point": [
        218,
        1
      ],
      "content": "static void\nbench_mul_g (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ctx->ecc->mul_g (ctx->ecc, ctx->rp, ctx->ap, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_mul_a": {
      "start_point": [
        220,
        0
      ],
      "end_point": [
        225,
        1
      ],
      "content": "static void\nbench_mul_a (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ctx->ecc->mul (ctx->ecc, ctx->rp, ctx->ap, ctx->bp, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_dup_eh": {
      "start_point": [
        227,
        0
      ],
      "end_point": [
        232,
        1
      ],
      "content": "static void\nbench_dup_eh (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ecc_dup_eh (ctx->ecc, ctx->rp, ctx->ap, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_add_eh": {
      "start_point": [
        234,
        0
      ],
      "end_point": [
        239,
        1
      ],
      "content": "static void\nbench_add_eh (void *p)\n{\n  struct ecc_ctx *ctx = (struct ecc_ctx *) p;\n  ecc_add_eh (ctx->ecc, ctx->rp, ctx->ap, ctx->bp, ctx->tp);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "mpn_random": {
      "start_point": [
        242,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static void\nmpn_random (mp_limb_t *xp, mp_size_t n)\n{\n  mp_size_t i;\n  for (i = 0; i < n; i++)\n    xp[i] = rand();\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_curve": {
      "start_point": [
        251,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static void\nbench_curve (const struct ecc_curve *ecc)\n{\n  struct ecc_ctx ctx;  \n  double modp, reduce, modq, modinv, modinv_gcd, modinv_powm,\n    dup_jj, add_jja, add_hhh,\n    mul_g, mul_a;\n\n  mp_limb_t mask;\n  mp_size_t itch;\n\n  ctx.ecc = ecc;\n  ctx.rp = xalloc_limbs (3*ecc->p.size);\n  ctx.ap = xalloc_limbs (3*ecc->p.size);\n  ctx.bp = xalloc_limbs (3*ecc->p.size);\n  itch = ecc->mul_itch;\n#ifdef mpn_sec_powm\n  {\n    mp_size_t powm_itch\n      = mpn_sec_powm_itch (ecc->p.size, ecc->p.bit_size, ecc->p.size);\n    if (powm_itch > itch)\n      itch = powm_itch;\n  }\n#endif\n  ctx.tp = xalloc_limbs (itch);\n\n  mpn_random (ctx.ap, 3*ecc->p.size);\n  mpn_random (ctx.bp, 3*ecc->p.size);\n\n  mask = (~(mp_limb_t) 0) >> (ecc->p.size * GMP_NUMB_BITS - ecc->p.bit_size);\n  ctx.ap[ecc->p.size - 1] &= mask;\n  ctx.ap[2*ecc->p.size - 1] &= mask;\n  ctx.ap[3*ecc->p.size - 1] &= mask;\n  ctx.bp[ecc->p.size - 1] &= mask;\n  ctx.bp[2*ecc->p.size - 1] &= mask;\n  ctx.bp[3*ecc->p.size - 1] &= mask;\n\n  modp = time_function (bench_modp, &ctx);\n  reduce = time_function (bench_reduce, &ctx);\n\n  modq = time_function (bench_modq, &ctx);\n\n  modinv = time_function (bench_modinv, &ctx);\n#if !NETTLE_USE_MINI_GMP\n  modinv_gcd = time_function (bench_modinv_gcd, &ctx);\n#else\n  modinv_gcd = 0;\n#endif\n#ifdef mpn_sec_powm\n  modinv_powm = time_function (bench_modinv_powm, &ctx);\n#else\n  modinv_powm = 0;\n#endif\n  if (ecc->p.bit_size == 255)\n    {\n      /* For now, curve25519 is a special case */\n      dup_jj = time_function (bench_dup_eh, &ctx);\n      add_jja = time_function (bench_add_eh, &ctx);\n    }\n  else\n    {\n      dup_jj = time_function (bench_dup_jj, &ctx);\n      add_jja = time_function (bench_add_jja, &ctx);\n    }\n  add_hhh = time_function (bench_add_hhh, &ctx);\n  mul_g = time_function (bench_mul_g, &ctx);\n  mul_a = time_function (bench_mul_a, &ctx);\n\n  free (ctx.rp);\n  free (ctx.ap);\n  free (ctx.bp);\n  free (ctx.tp);\n\n  printf (\"%4d %6.4f %6.4f %6.4f %6.2f %6.3f %6.2f %6.3f %6.3f %6.3f %6.1f %6.1f\\n\",\n\t  ecc->p.bit_size, 1e6 * modp, 1e6 * reduce, 1e6 * modq,\n\t  1e6 * modinv, 1e6 * modinv_gcd, 1e6 * modinv_powm,\n\t  1e6 * dup_jj, 1e6 * add_jja, 1e6 * add_hhh,\n\t  1e6 * mul_g, 1e6 * mul_a);\n}",
      "lines": 79,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        342,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "int\nmain (int argc UNUSED, char **argv UNUSED)\n{\n  unsigned i;\n\n  time_init();\n  printf (\"%4s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s %6s (us)\\n\",\n\t  \"size\", \"modp\", \"reduce\", \"modq\", \"modinv\", \"mi_gcd\", \"mi_pow\",\n\t  \"dup_jj\", \"ad_jja\", \"ad_hhh\",\n\t  \"mul_g\", \"mul_a\");\n  for (i = 0; i < numberof (curves); i++)\n    bench_curve (curves[i]);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 15,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/eratosthenes.c": {
    "usage": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nusage(void)\n{\n  fprintf(stderr, \"Usage: erathostenes [OPTIONS] [LIMIT]\\n\\n\"\n\t  \"Options:\\n\"\n\t  \"      -?         Display this message.\\n\"\n\t  \"      -b SIZE    Block size.\\n\"\n\t  \"      -v         Verbose output.\\n\"\n\t  \"      -s         No output.\\n\");\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "isqrt": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "static unsigned\nisqrt(unsigned long n)\n{\n  unsigned long x;\n\n  /* FIXME: Better initialization. */\n  if (n < ULONG_MAX)\n    x = n;\n  else\n    /* Must avoid overflow in the first step. */\n    x = n-1;\n\n  for (;;)\n    {\n      unsigned long y = (x + n/x) / 2;\n      if (y >= x)\n\treturn x;\n\n      x = y;\n    }\n}",
      "lines": 21,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "vector_alloc": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        103,
        1
      ],
      "content": "static unsigned long *\nvector_alloc(unsigned long size)\n{\n  unsigned long end = (size + BITS_PER_LONG - 1) / BITS_PER_LONG;\n  unsigned long *vector = malloc (end * sizeof(*vector));\n\n  if (!vector)\n    {\n      fprintf(stderr, \"Insufficient memory.\\n\");\n      exit(EXIT_FAILURE);\n    }\n  return vector;\n}",
      "lines": 13,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long",
        "*\nvector_alloc(unsigned long size)",
        "*"
      ]
    },
    "vector_init": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\nvector_init(unsigned long *vector, unsigned long size)\n{\n  unsigned long end = (size + BITS_PER_LONG - 1) / BITS_PER_LONG;\n  unsigned long i;\n\n  for (i = 0; i < end; i++)\n    vector[i] = ~0UL;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "vector_clear_bits": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        128,
        1
      ],
      "content": "static void\nvector_clear_bits (unsigned long *vector, unsigned long step,\n\t\t   unsigned long start, unsigned long size)\n{\n  unsigned long bit;\n\n  for (bit = start; bit < size; bit += step)\n    {\n      unsigned long i = bit / BITS_PER_LONG;\n      unsigned long mask = 1L << (bit % BITS_PER_LONG);\n\n      vector[i] &= ~mask;\n    }\n}",
      "lines": 14,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "find_first_one": {
      "start_point": [
        130,
        0
      ],
      "end_point": [
        178,
        1
      ],
      "content": "static unsigned\nfind_first_one (unsigned long x)\n{  \n  static const unsigned char table[0x101] =\n    {\n     15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n     14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n     13, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n     12, 0, 0, 0, 0, 0, 0, 0,11, 0, 0, 0,10, 0, 9, 8,\n      0, 0, 1, 0, 2, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0,\n      4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      7,\n    };\n\n  unsigned i = 0;\n\n  /* Isolate least significant bit */\n  x &= -x;\n\n#if NEED_HANDLE_LARGE_LONG\n#ifndef SIZEOF_LONG\n  /* Can not be tested by the preprocessor. May generate warnings\n     when long is 32 bits. */\n  if (BITS_PER_LONG > 32)\n#endif\n    while (x >= 0x100000000L)\n      {\n\tx >>= 32;\n\ti += 32;\n      }\n#endif /* NEED_HANDLE_LARGE_LONG */\n\n  if (x >= 0x10000)\n    {\n      x >>= 16;\n      i += 16;\n    }\n  return i + table[128 + (x & 0xff) - (x >> 8)];\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "unsigned",
        "unsigned"
      ]
    },
    "vector_find_next": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        198,
        1
      ],
      "content": "static unsigned long\nvector_find_next (const unsigned long *vector, unsigned long bit, unsigned long size)\n{\n  unsigned long end = (size + BITS_PER_LONG - 1) / BITS_PER_LONG;\n  unsigned long i = bit / BITS_PER_LONG;\n  unsigned long mask = 1L << (bit % BITS_PER_LONG);\n  unsigned long word;\n\n  if (i >= end)\n    return size;\n\n  for (word = vector[i] & ~(mask - 1); !word; word = vector[i])\n    if (++i >= end)\n      return size;\n\n  /* Next bit is the least significant bit of word */\n  return i * BITS_PER_LONG + find_first_one(word);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "atosize": {
      "start_point": [
        204,
        0
      ],
      "end_point": [
        228,
        1
      ],
      "content": "static long\natosize(const char *s)\n{\n  char *end;\n  long value = strtol(s, &end, 10);\n\n  if (value <= 0)\n    return 0;\n\n  /* FIXME: Doesn't check for overflow. */\n  switch(*end)\n    {\n    default:\n      return 0;\n    case '\\0':\n      break;\n    case 'k': case 'K':\n      value <<= 10;\n      break;\n    case 'M':\n      value <<= 20;\n      break;\n    }\n  return value;\n}",
      "lines": 25,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "long",
        "long"
      ]
    },
    "main": {
      "start_point": [
        230,
        0
      ],
      "end_point": [
        413,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  /* Generate all primes p <= limit */\n  unsigned long limit;\n  unsigned long root;\n\n  unsigned long limit_nbits;\n\n  /* Represents numbers up to sqrt(limit) */\n  unsigned long sieve_nbits;\n  unsigned long *sieve;\n  /* Block for the rest of the sieving. Size should match the cache,\n     the default value corresponds to 64 KB. */\n  unsigned long block_nbits = 64L << 13;\n  unsigned long block_start_bit;\n  unsigned long *block;\n  \n  unsigned long bit;\n  int silent = 0;\n  int verbose = 0;\n  int c;\n\n  enum { OPT_HELP = 300 };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"verbose\", no_argument, NULL, 'v' },\n      { \"block-size\", required_argument, NULL, 'b' },\n      { \"quiet\", required_argument, NULL, 'q' },\n      { NULL, 0, NULL, 0}\n    };\n\n  while ( (c = getopt_long(argc, argv, \"svb:\", options, NULL)) != -1)\n    switch (c)\n      {\n      case OPT_HELP:\n\tusage();\n\treturn EXIT_SUCCESS;\n      case 'b':\n\tblock_nbits = CHAR_BIT * atosize(optarg);\n\tif (!block_nbits)\n\t  {\n\t    usage();\n\t    return EXIT_FAILURE;\n\t  }\n\tbreak;\n\n      case 'q':\n\tsilent = 1;\n\tbreak;\n\n      case 'v':\n\tverbose++;\n\tbreak;\n\n      case '?':\n\treturn EXIT_FAILURE;\n\n      default:\n\tabort();\n      }\n\n  argc -= optind;\n  argv += optind;\n\n  if (argc == 0)\n    limit = 1000;\n  else if (argc == 1)\n    {\n      limit = atol(argv[0]);\n      if (limit < 2)\n\treturn EXIT_SUCCESS;\n    }\n  else\n    {\n      usage();\n      return EXIT_FAILURE;\n    }\n\n  root = isqrt(limit);\n  /* Round down to odd */\n  root = (root - 1) | 1;\n  /* Represents odd numbers from 3 up. */\n  sieve_nbits = (root - 1) / 2;\n  sieve = vector_alloc(sieve_nbits );\n  vector_init(sieve, sieve_nbits);\n\n  if (verbose)\n    fprintf(stderr, \"Initial sieve using %lu bits.\\n\", sieve_nbits);\n      \n  if (!silent)\n    printf(\"2\\n\");\n\n  if (limit == 2)\n    return EXIT_SUCCESS;\n\n  for (bit = 0;\n       bit < sieve_nbits;\n       bit = vector_find_next(sieve, bit + 1, sieve_nbits))\n    {\n      unsigned long n = 3 + 2 * bit;\n      /* First bit to clear corresponds to n^2, which is bit\n\n\t (n^2 - 3) / 2 = (n + 3) * bit + 3\n      */      \n      unsigned long n2_bit = (n+3)*bit + 3;\n\n      if (!silent)\n\tprintf(\"%lu\\n\", n);\n\n      vector_clear_bits (sieve, n, n2_bit, sieve_nbits);\n    }\n\n  limit_nbits = (limit - 1) / 2;\n\n  if (sieve_nbits + block_nbits > limit_nbits)\n    block_nbits = limit_nbits - sieve_nbits;\n\n  if (verbose)\n    {\n      double storage = block_nbits / 8.0;\n      unsigned shift = 0;\n      const char prefix[] = \" KMG\";\n\n      while (storage > 1024 && shift < 3)\n\t{\n\t  storage /= 1024;\n\t  shift++;\n\t}\n      fprintf(stderr, \"Blockwise sieving using blocks of %lu bits (%.3g %cByte)\\n\",\n\t      block_nbits, storage, prefix[shift]);\n    }\n\n  block = vector_alloc(block_nbits);\n\n  for (block_start_bit = bit; block_start_bit < limit_nbits; block_start_bit += block_nbits)\n    {\n      unsigned long block_start;\n      \n      if (block_start_bit + block_nbits > limit_nbits)\n\tblock_nbits = limit_nbits - block_start_bit;\n\n      vector_init(block, block_nbits);\n\n      block_start = 3 + 2*block_start_bit;\n\n      if (verbose > 1)\n\tfprintf(stderr, \"Next block, n = %lu\\n\", block_start);\n\n      /* Sieve */\n      for (bit = 0; bit < sieve_nbits;\n\t   bit = vector_find_next(sieve, bit + 1, sieve_nbits))\n\t{\t  \n\t  unsigned long n = 3 + 2 * bit;\n\t  unsigned long sieve_start_bit = (n + 3) * bit + 3;\n\n\t  if (sieve_start_bit < block_start_bit)\n\t    {\n\t      unsigned long k = (block_start + n - 1) / (2*n);\n\t      sieve_start_bit = n * k + bit;\n\n\t      assert(sieve_start_bit < block_start_bit + n);\n\t    }\n\t  assert(sieve_start_bit >= block_start_bit);\n\n\t  vector_clear_bits(block, n, sieve_start_bit - block_start_bit, block_nbits);\n\t}\n      for (bit = vector_find_next(block, 0, block_nbits);\n\t   bit < block_nbits;\n\t   bit = vector_find_next(block, bit + 1, block_nbits))\n\t{\n\t  unsigned long n = block_start + 2 * bit;\n\t  if (!silent)\n\t    printf(\"%lu\\n\", n);\n\t}\n    }\n\n  free(sieve);\n  free(block);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 184,
      "depth": 15,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/hogweed-benchmark.c": {
    "NORETURN": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "die(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n\n  exit(EXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": null
    },
    "xalloc": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        89,
        1
      ],
      "content": "static void *\nxalloc (size_t size)\n{\n  void *p = malloc (size);\n  if (!p)\n    {\n      fprintf (stderr, \"Virtual memory exhausted\\n\");\n      abort ();\n    }\n  return p;\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nxalloc (size_t size)",
        "*"
      ]
    },
    "hash_string": {
      "start_point": [
        91,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static uint8_t *\nhash_string (const struct nettle_hash *hash, const char *s)\n{\n  void *ctx = xalloc (hash->context_size);\n  uint8_t *digest = xalloc (hash->digest_size);\n  hash->init (ctx);\n  hash->update (ctx, strlen(s), (const uint8_t *) s);\n  hash->digest (ctx, hash->digest_size, digest);\n  free (ctx);\n\n  return digest;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nhash_string (const struct nettle_hash *hash, const char *s)",
        "*"
      ]
    },
    "time_function": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "static double\ntime_function(void (*f)(void *arg), void *arg)\n{\n  unsigned ncalls;\n  double elapsed;\n\n  /* Warm up */\n  f(arg);\n  for (ncalls = 10 ;;)\n    {\n      unsigned i;\n\n      time_start();\n      for (i = 0; i < ncalls; i++)\n\tf(arg);\n      elapsed = time_end();\n      if (elapsed > BENCH_INTERVAL)\n\tbreak;\n      else if (elapsed < BENCH_INTERVAL / 10)\n\tncalls *= 10;\n      else\n\tncalls *= 2;\n    }\n  return elapsed / ncalls;\n}",
      "lines": 25,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "bench_alg": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        161,
        1
      ],
      "content": "static void \nbench_alg (const struct alg *alg)\n{\n  double sign;\n  double verify;\n  void *ctx;\n\n  ctx = alg->init(alg->size);\n  if (ctx == NULL)\n    {\n      printf(\"%15s %4d N/A\\n\", alg->name, alg->size);\n      return;\n    }\n\n  sign = time_function (alg->sign, ctx);\n  verify = time_function (alg->verify, ctx);\n\n  alg->clear (ctx);\n\n  printf(\"%15s %4d %9.4f %9.4f\\n\",\n\t alg->name, alg->size, 1e-3/sign, 1e-3/verify);\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_rsa_init": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "static void *\nbench_rsa_init (unsigned size)\n{\n  unsigned char rsa1024[] =\n    \"{KDExOnByaXZhdGUta2V5KDE0OnJzYS1wa2NzMS1zaGExKDE6bjEyOToA90+K5EmjbFJBeJD\"\n    \" xP2KD2Df+0Twc9425uB+vhqTrVijtd2PnwEQDfR2VoducgkKcXJzYYyCNILQJbFAi2Km/sD\"\n    \" jImERBqDtaI217Ze+tOKEmImexYTAgFuqEptp2F3M4DqgRQ7s/3nJQ/bPE5Hfi1OZhJSShu\"\n    \" I80ATTU4fUgrPspKDE6ZTM6AQABKSgxOmQxMjk6APAhKckzvxxkWfHJOpXDACWnaSKcbbvo\"\n    \" vtWK3pGr/F2ya7CrLtE+uOx5F1sLs9G+/7flCy5k4uNILIYg4VTirZ1zQ8fNKPrjK1VMRls\"\n    \" JiRRU/0VAs9d7HdncJfs6rbvRQbCRSRYURo4hWir3Lq8V3UUQVBprc4dO+uWmplvwQ5qxKS\"\n    \" gxOnA2NToA+8aIVkdbk8Jg8dJOuzc7m/hZnwkKSs6eVDw4N/2T0CJKGJYT+B3Ct+fPkxhUR\"\n    \" ggd2DQ9OpkTra7SXHTNkzdPVSkoMTpxNjU6APt11P8vXNnGYF0OC/cPsR8zhSYuFmtRuX6G\"\n    \" ES+DdG0VCU07UeNQkok1UoW5sXqY0IGr1jkJq8AMSgKoNbLQ6w8pKDE6YTY0Ohzkxsan/8F\"\n    \" wQDHgQbrIduXKVXaj0fONzKu8EXOTfUAYf0pdBsOlnq/+QVsPIrS6v7oNHK253YFEG84SdX\"\n    \" kcktUpKDE6YjY1OgCR+cRtY3RWY+f6/TWK9gwPndv03xpasLWrMm71ky1aSbT9pasS9+opR\"\n    \" tAiGzthfSbFsBiLQgb3VOr+AeIybT+XKSgxOmM2NDojigqARWN5u1CVDVuD2L2ManpoGiM6\"\n    \" kQ6FaJjqRjxeRRKFrQxGJa9tM1hqStxokC1oJidgaOLGnn60iwzToug9KSkp}\";\n    \n  unsigned char rsa2048[] =\n    \"{KDExOnByaXZhdGUta2V5KDE0OnJzYS1wa2NzMS1zaGExKDE6bjI1NzoAtxWXiglIdunDK48\"\n    \" 8I0vW0wTqnh/riW9pLk8n1F8MUPBFdhvkkl0bDQqSJPUvSHy+w4fLVwcEzeI4qFyo3b2Avz\"\n    \" JK20MFbt/WfHD1TbxuK8rNqXyqmqjJ9vgjtV9nPzAz7CM9ogs3/RJHpcfZPQF15ifizleUZ\"\n    \" aQT0GAXHZL7cePj10yGI2u3hgTkokVzdNC/1T34guKYpErg0pt0B/KejWpsFTb84z3tkR+B\"\n    \" YVx07p/OoByZwoABgncS/uALl31fRS8jyJ2JqUiZOqe7XoO9hkDHYNCWUGUfNGQ7ZgVp9+e\"\n    \" NQpracSjrp6Jnrj7r/oxJUx5ZDVNi18AzQadE/oKOrSkoMTplMzoBAAEpKDE6ZDI1NjogBT\"\n    \" C5vaHk2kF+LtDvw2XRBj0aZq7FHK0ioklvBSicR0l+vKYfSxVeFIk22YLphJfAjtFraRjYA\"\n    \" Uaze3E1Rt1rkxoweupKV++lWAQvElOaaR/LErirz/Vysjdck1D1ZjLOi+NNofSq2DWbsvY1\"\n    \" iznZhQRP3lVf6XBls0iXrYs4gb0pBZqXLQW+j9Ihx6eantf1/6ZMKPgCkzcAZ0ABsCfaFSg\"\n    \" ouNCzilblsgFEspEbb8QqrNQoStS3F/gMwWgDsr3+vQzBqt+7ykWoCJ9wctbYy9kEPq+hX3\"\n    \" GP0hG6HdS81r9E8pgdf3wloNNMzYUHwn7poXGpOi8tG0pmR56TqD/BKSgxOnAxMjk6AN4AJ\"\n    \" TiGPm9We2ga3Y0jpTfA3mWpUbhYgaXYLWA1/riniwq16fqxRIkWQT/O2KKpBVe6WSvNYq9u\"\n    \" lM8N6bdPtDytJs6AOXy0X5vtJ953ZYVMhHbhmUxhIL9I+s0O1+LxMF8b9U4CrFyaTxd8Un/\"\n    \" FXP1BvYJRrkoup6HYvOlGx36lKSgxOnExMjk6ANMfrfH6z/3o7K56aW6kSiloDDbKZQ0+W5\"\n    \" 8LzP2ZOBLf6LX6jLhN3olU1Z0KGTM0S/1AxvwGjuRqhu+LcOJ7oUCUH3uusR5c5nSnArYPq\"\n    \" +0wbco4BQngot/HmGN7U0EDsIWqPt/qoa/b8bCk+TOwJlknNq/PnZU26SPj48XS05lpKSgx\"\n    \" OmExMjk6AJM2n3gLNW3ZeH5BindkktQU9qWNkV5geqDCaNyrEZ3bpI1WsrEGSj9p3Zz1ipz\"\n    \" a3msdbLJqQS26c72WKUzg8tFltR0s1HJInjolGtIgdNbfNdwrn9+RbQjL2VyPokOg0wXO4W\"\n    \" 14wlmqDhax33dRJmfe50964MvaglkGA8fhorrtKSgxOmIxMjk6AKMe+vrX2xRHf3dfxU5jS\"\n    \" ZmsdqNuxZzx7UB5kazvUU/kCJ1yNH/CSoq5LULkpovVgFDwV84qEwWQ+SjkCBg1hWWsDJc3\"\n    \" ZkobZUQENigM+72LiYiQt/PlyHI2eRuEEdNN0nm0DFhdpQeHXLoq/RBerYJ8tdgpBYxgnMn\"\n    \" KLhaOykbhKSgxOmMxMjg6MVlKj2bjb7qFQVkLO1OPg28jSrtRpnQCR+qegN4ZmNam/qbest\"\n    \" 8yn0JQ6gxX7PvP382+jx7uHHWHYYqPq/Flf8gqtOOcjqS5TJgVHz3F3xHWquo1ZofGtCMro\"\n    \" Dd2c0xjRjIVGvLV6Ngs+HRdljRav40vRpTyEoEdlzHBQiILesopKSk=}\";\n\n  struct rsa_ctx *ctx;\n  struct sexp_iterator i;\n\n  int res;\n\n  ctx = xalloc(sizeof(*ctx));\n\n  rsa_public_key_init (&ctx->pub);\n  rsa_private_key_init (&ctx->key);\n  mpz_init (ctx->s);\n\n  /* NOTE: Base64-decodes the strings in-place */\n  if (size == 1024)\n    res = sexp_transport_iterator_first (&i, sizeof(rsa1024) - 1, rsa1024);\n  else if (size == 2048)\n    res = sexp_transport_iterator_first (&i, sizeof(rsa2048) - 1, rsa2048);\n  else\n    die (\"Internal error.\\n\");\n\n  if (! (res\n\t && sexp_iterator_check_type (&i, \"private-key\")\n\t && sexp_iterator_check_type (&i, \"rsa-pkcs1-sha1\")\n\t && rsa_keypair_from_sexp_alist (&ctx->pub, &ctx->key, 0, &i)))\n    die (\"Internal error.\\n\");\n\n  ctx->digest = hash_string (&nettle_sha256, \"foo\");\n\n  rsa_sha256_sign_digest (&ctx->key, ctx->digest, ctx->s);\n  \n  return ctx;\n}",
      "lines": 75,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nbench_rsa_init (unsigned size)",
        "*"
      ]
    },
    "bench_rsa_sign": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        256,
        1
      ],
      "content": "static void\nbench_rsa_sign (void *p)\n{\n  struct rsa_ctx *ctx = p;\n\n  mpz_t s;\n  mpz_init (s);\n  rsa_sha256_sign_digest (&ctx->key, ctx->digest, s);\n  mpz_clear (s);\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_rsa_verify": {
      "start_point": [
        258,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static void\nbench_rsa_verify (void *p)\n{\n  struct rsa_ctx *ctx = p;\n  if (! rsa_sha256_verify_digest (&ctx->pub, ctx->digest, ctx->s))\n    die (\"Internal error, rsa_sha256_verify_digest failed.\\n\");\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_rsa_clear": {
      "start_point": [
        266,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\nbench_rsa_clear (void *p)\n{\n  struct rsa_ctx *ctx = p;\n\n  rsa_public_key_clear (&ctx->pub);\n  rsa_private_key_clear (&ctx->key);\n  mpz_clear (ctx->s);\n  \n  free (ctx->digest);\n  free (ctx);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_dsa_init": {
      "start_point": [
        289,
        0
      ],
      "end_point": [
        332,
        1
      ],
      "content": "static void *\nbench_dsa_init (unsigned size)\n{\n  struct dsa_ctx *ctx;\n  struct sexp_iterator i;  \n\n  unsigned char dsa1024[] =\n    \"{KDExOnByaXZhdGUta2V5KDM6ZHNhKDE6cDEyOToA2q4hOXEClLMXXMOl9xaPcGC/GeGmCMv\"\n    \" VCaaW0uWc50DvvmJDPQPdCehyfZr/1dv2UDbx06TC7ls/IFd+BsDzGBRxqIQ44J20cn+0gt\"\n    \" NMIXAocE1QhCCFaT5gXrk8zMlqBEGaP3RdpgxNanEXkTj2Wma8r1GtrLX3HPafio62jicpK\"\n    \" DE6cTIxOgDN9pcW3exdVAesC9WsxwCGoJK24ykoMTpnMTI5OgCJr9DmKdiE0WJZB7HACESv\"\n    \" Tpg1qZgc8E15byQ+OsHUyOTRrJRTcrgKZJW7dFRJ9cXmyi7XYCd3bJtu/2HRHLY1vd4qMvU\"\n    \" 7Y8x08ooCoABGV7nGqcmdQfEho1OY6TZh2NikmPKZLeur3PZFpcZ8Dl+KVWtwC55plNC7Om\"\n    \" iAQy8MaCkoMTp5MTI5OgDakk0LOUQwzOKt9FHOBmBKrWsvTm7549eScTUqH4OMm3btjUsXz\"\n    \" MmlqEe+imwQCOW/AE3Xw9pXZeETWK0jlLe8k5vnKcNskerFwZ1eQKtOPPQty8IqQ9PEfF6B\"\n    \" 0oVQiJg2maHUDWFnDkIBd7ZR1z8FnZMUxH9mH4kEUo6YQgtCdykoMTp4MjA6cOl3ijiiMjI\"\n    \" pesFD8jxESWb2mn8pKSk=}\";\n\n  ctx = xalloc(sizeof(*ctx));\n\n  dsa_params_init (&ctx->params);\n  mpz_init (ctx->pub);\n  mpz_init (ctx->key);\n  dsa_signature_init (&ctx->s);\n  knuth_lfib_init (&ctx->lfib, 1);\n\n  if (size != 1024)\n    die (\"Internal error.\\n\");\n  \n  if (! (sexp_transport_iterator_first (&i, sizeof(dsa1024) - 1, dsa1024)\n\t && sexp_iterator_check_type (&i, \"private-key\")\n\t && sexp_iterator_check_type (&i, \"dsa\")\n\t && dsa_keypair_from_sexp_alist (&ctx->params, ctx->pub, ctx->key,\n\t\t\t\t\t 0, DSA_SHA1_Q_BITS, &i)) )\n    die (\"Internal error.\\n\");\n\n  ctx->digest = hash_string (&nettle_sha1, \"foo\");\n\n  dsa_sign (&ctx->params, ctx->key,\n\t    &ctx->lfib, (nettle_random_func *)knuth_lfib_random,\n\t    SHA1_DIGEST_SIZE, ctx->digest, &ctx->s);\n\n  return ctx;\n}",
      "lines": 44,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nbench_dsa_init (unsigned size)",
        "*"
      ]
    },
    "bench_dsa_sign": {
      "start_point": [
        334,
        0
      ],
      "end_point": [
        345,
        1
      ],
      "content": "static void\nbench_dsa_sign (void *p)\n{\n  struct dsa_ctx *ctx = p;\n  struct dsa_signature s;\n\n  dsa_signature_init (&s);\n  dsa_sign (&ctx->params, ctx->key,\n\t    &ctx->lfib, (nettle_random_func *)knuth_lfib_random,\n\t    SHA1_DIGEST_SIZE, ctx->digest, &s);\n  dsa_signature_clear (&s);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_dsa_verify": {
      "start_point": [
        347,
        0
      ],
      "end_point": [
        353,
        1
      ],
      "content": "static void\nbench_dsa_verify (void *p)\n{\n  struct dsa_ctx *ctx = p;\n  if (! dsa_verify (&ctx->params, ctx->pub, SHA1_DIGEST_SIZE, ctx->digest, &ctx->s))\n    die (\"Internal error, dsa_sha1_verify_digest failed.\\n\");\n}",
      "lines": 7,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_dsa_clear": {
      "start_point": [
        355,
        0
      ],
      "end_point": [
        365,
        1
      ],
      "content": "static void\nbench_dsa_clear (void *p)\n{\n  struct dsa_ctx *ctx = p;\n  dsa_params_clear (&ctx->params);\n  mpz_clear (ctx->pub);\n  mpz_clear (ctx->key);\n  dsa_signature_clear (&ctx->s);\n  free (ctx->digest);\n  free (ctx);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_ecdsa_init": {
      "start_point": [
        377,
        0
      ],
      "end_point": [
        470,
        1
      ],
      "content": "static void *\nbench_ecdsa_init (unsigned size)\n{\n  struct ecdsa_ctx *ctx;\n  const struct ecc_curve *ecc;\n\n  const char *xs;\n  const char *ys;\n  const char *zs;\n  mpz_t x, y, z;\n  \n  ctx = xalloc (sizeof(*ctx));\n\n  dsa_signature_init (&ctx->s);  \n  knuth_lfib_init (&ctx->rctx, 17);\n\n  switch (size)\n    {\n    case 192:\n      ecc = &nettle_secp_192r1;\n      xs = \"8e8e07360350fb6b7ad8370cfd32fa8c6bba785e6e200599\";\n      ys = \"7f82ddb58a43d59ff8dc66053002b918b99bd01bd68d6736\";\n      zs = \"f2e620e086d658b4b507996988480917640e4dc107808bdd\";\n      ctx->digest = hash_string (&nettle_sha1, \"abc\");\n      ctx->digest_size = 20;\n      break;\n    case 224:\n      ecc = &nettle_secp_224r1;\n      xs = \"993bf363f4f2bc0f255f22563980449164e9c894d9efd088d7b77334\";\n      ys = \"b75fff9849997d02d135140e4d0030944589586e22df1fc4b629082a\";\n      zs = \"cdfd01838247f5de3cc70b688418046f10a2bfaca6de9ec836d48c27\";\n      ctx->digest = hash_string (&nettle_sha224, \"abc\");\n      ctx->digest_size = 28;\n      break;\n\n      /* From RFC 4754 */\n    case 256:\n      ecc = &nettle_secp_256r1;\n      xs = \"2442A5CC 0ECD015F A3CA31DC 8E2BBC70 BF42D60C BCA20085 E0822CB0 4235E970\";\n      ys = \"6FC98BD7 E50211A4 A27102FA 3549DF79 EBCB4BF2 46B80945 CDDFE7D5 09BBFD7D\";\n      zs = \"DC51D386 6A15BACD E33D96F9 92FCA99D A7E6EF09 34E70975 59C27F16 14C88A7F\";\n      ctx->digest = hash_string (&nettle_sha256, \"abc\");\n      ctx->digest_size = 32;\n      break;\n    case 384:\n      ecc = &nettle_secp_384r1;\n      xs = \"96281BF8 DD5E0525 CA049C04 8D345D30 82968D10 FEDF5C5A CA0C64E6 465A97EA\"\n\t\"5CE10C9D FEC21797 41571072 1F437922\";\n      ys = \"447688BA 94708EB6 E2E4D59F 6AB6D7ED FF9301D2 49FE49C3 3096655F 5D502FAD\"\n\t\"3D383B91 C5E7EDAA 2B714CC9 9D5743CA\";\n      zs = \"0BEB6466 34BA8773 5D77AE48 09A0EBEA 865535DE 4C1E1DCB 692E8470 8E81A5AF\"\n\t\"62E528C3 8B2A81B3 5309668D 73524D9F\";\n      ctx->digest = hash_string (&nettle_sha384, \"abc\");\n      ctx->digest_size = 48;\n      break;\n    case 521:\n      ecc = &nettle_secp_521r1;\n      xs = \"0151518F 1AF0F563 517EDD54 85190DF9 5A4BF57B 5CBA4CF2 A9A3F647 4725A35F\"\n\t\"7AFE0A6D DEB8BEDB CD6A197E 592D4018 8901CECD 650699C9 B5E456AE A5ADD190\"\n\t\"52A8\";\n      ys = \"006F3B14 2EA1BFFF 7E2837AD 44C9E4FF 6D2D34C7 3184BBAD 90026DD5 E6E85317\"\n\t\"D9DF45CA D7803C6C 20035B2F 3FF63AFF 4E1BA64D 1C077577 DA3F4286 C58F0AEA\"\n\t\"E643\";\n      zs = \"0065FDA3 409451DC AB0A0EAD 45495112 A3D813C1 7BFD34BD F8C1209D 7DF58491\"\n\t\"20597779 060A7FF9 D704ADF7 8B570FFA D6F062E9 5C7E0C5D 5481C5B1 53B48B37\"\n\t\"5FA1\";\n\n      ctx->digest = hash_string (&nettle_sha512, \"abc\");\n      ctx->digest_size = 64;\n      break;\n    default:\n      die (\"Internal error.\\n\");\n    }\n  ecc_point_init (&ctx->pub, ecc);\n  ecc_scalar_init (&ctx->key, ecc);\n\n  mpz_init_set_str (x, xs, 16);\n  mpz_init_set_str (y, ys, 16);\n  mpz_init_set_str (z, zs, 16);\n\n  ecc_point_set (&ctx->pub, x, y);\n  ecc_scalar_set (&ctx->key, z);\n\n  mpz_clear (x);\n  mpz_clear (y);\n  mpz_clear (z);\n\n  ecdsa_sign (&ctx->key,\n\t      &ctx->rctx, (nettle_random_func *) knuth_lfib_random,\n\t      ctx->digest_size, ctx->digest,\n\t      &ctx->s);\n\n  return ctx;\n}",
      "lines": 94,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nbench_ecdsa_init (unsigned size)",
        "*"
      ]
    },
    "bench_ecdsa_sign": {
      "start_point": [
        472,
        0
      ],
      "end_point": [
        484,
        1
      ],
      "content": "static void\nbench_ecdsa_sign (void *p)\n{\n  struct ecdsa_ctx *ctx = p;\n  struct dsa_signature s;\n\n  dsa_signature_init (&s);\n  ecdsa_sign (&ctx->key,\n\t      &ctx->rctx, (nettle_random_func *) knuth_lfib_random,\n\t      ctx->digest_size, ctx->digest,\n\t      &s);\n  dsa_signature_clear (&s);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_ecdsa_verify": {
      "start_point": [
        486,
        0
      ],
      "end_point": [
        494,
        1
      ],
      "content": "static void\nbench_ecdsa_verify (void *p)\n{\n  struct ecdsa_ctx *ctx = p;\n  if (! ecdsa_verify (&ctx->pub, \n\t\t      ctx->digest_size, ctx->digest,\n\t\t      &ctx->s))\n    die (\"Internal error, _ecdsa_verify failed.\\n\");    \n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_ecdsa_clear": {
      "start_point": [
        496,
        0
      ],
      "end_point": [
        507,
        1
      ],
      "content": "static void\nbench_ecdsa_clear (void *p)\n{\n  struct ecdsa_ctx *ctx = p;\n\n  ecc_point_clear (&ctx->pub);\n  ecc_scalar_clear (&ctx->key);\n  dsa_signature_clear (&ctx->s);\n  free (ctx->digest);\n\n  free (ctx);\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_rsa_init": {
      "start_point": [
        519,
        0
      ],
      "end_point": [
        535,
        1
      ],
      "content": "static void *\nbench_openssl_rsa_init (unsigned size)\n{\n  struct openssl_rsa_ctx *ctx = xalloc (sizeof (*ctx));\n\n  ctx->key = RSA_generate_key (size, 65537, NULL, NULL);\n  ctx->ref = xalloc (RSA_size (ctx->key));\n  ctx->signature = xalloc (RSA_size (ctx->key));\n  ctx->digest = hash_string (&nettle_sha1, \"foo\");\n  RSA_blinding_off(ctx->key);\n\n  if (! RSA_sign (NID_sha1, ctx->digest, SHA1_DIGEST_SIZE,\n\t\t  ctx->ref, &ctx->siglen, ctx->key))\n    die (\"OpenSSL RSA_sign failed.\\n\");\n\n  return ctx;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nbench_openssl_rsa_init (unsigned size)",
        "*"
      ]
    },
    "bench_openssl_rsa_sign": {
      "start_point": [
        537,
        0
      ],
      "end_point": [
        546,
        1
      ],
      "content": "static void\nbench_openssl_rsa_sign (void *p)\n{\n  const struct openssl_rsa_ctx *ctx = p;\n  unsigned siglen;\n\n  if (! RSA_sign (NID_sha1, ctx->digest, SHA1_DIGEST_SIZE,\n\t\t  ctx->signature, &siglen, ctx->key))\n    die (\"OpenSSL RSA_sign failed.\\n\");\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_rsa_verify": {
      "start_point": [
        548,
        0
      ],
      "end_point": [
        555,
        1
      ],
      "content": "static void\nbench_openssl_rsa_verify (void *p)\n{\n  const struct openssl_rsa_ctx *ctx = p;\n  if (! RSA_verify (NID_sha1, ctx->digest, SHA1_DIGEST_SIZE,\n\t\t    ctx->ref, ctx->siglen, ctx->key))\n    die (\"OpenSSL RSA_verify failed.\\n\");    \n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_rsa_clear": {
      "start_point": [
        557,
        0
      ],
      "end_point": [
        566,
        1
      ],
      "content": "static void\nbench_openssl_rsa_clear (void *p)\n{\n  struct openssl_rsa_ctx *ctx = p;\n  RSA_free (ctx->key);\n  free (ctx->ref);\n  free (ctx->signature);\n  free (ctx->digest);\n  free (ctx);\n}",
      "lines": 10,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_ecdsa_init": {
      "start_point": [
        576,
        0
      ],
      "end_point": [
        625,
        1
      ],
      "content": "static void *\nbench_openssl_ecdsa_init (unsigned size)\n{\n  struct openssl_ecdsa_ctx *ctx = xalloc (sizeof (*ctx));\n\n  switch (size)\n    {\n    case 192:\n      ctx->key = EC_KEY_new_by_curve_name (NID_X9_62_prime192v1);\n      ctx->digest_length = 24; /* truncated */\n      ctx->digest = hash_string (&nettle_sha224, \"abc\");\n      break;\n    case 224:\n      ctx->key = EC_KEY_new_by_curve_name (NID_secp224r1);\n      ctx->digest_length = SHA224_DIGEST_SIZE;\n      ctx->digest = hash_string (&nettle_sha224, \"abc\");\n      break;\n    case 256:\n      ctx->key = EC_KEY_new_by_curve_name (NID_X9_62_prime256v1);\n      ctx->digest_length = SHA256_DIGEST_SIZE;\n      ctx->digest = hash_string (&nettle_sha256, \"abc\");\n      break;\n    case 384:\n      ctx->key = EC_KEY_new_by_curve_name (NID_secp384r1);\n      ctx->digest_length = SHA384_DIGEST_SIZE;\n      ctx->digest = hash_string (&nettle_sha384, \"abc\");\n      break;\n    case 521:\n      ctx->key = EC_KEY_new_by_curve_name (NID_secp521r1);\n      ctx->digest_length = SHA512_DIGEST_SIZE;\n      ctx->digest = hash_string (&nettle_sha512, \"abc\");\n      break;\n    default:\n      die (\"Internal error.\\n\");\n    }\n\n  /* This curve isn't supported in this build of openssl */\n  if (ctx->key == NULL)\n    {\n      free(ctx);\n      return NULL;\n    }\n\n  if (!EC_KEY_generate_key( ctx->key))\n    die (\"Openssl EC_KEY_generate_key failed.\\n\");\n  \n  ctx->signature = ECDSA_do_sign (ctx->digest, ctx->digest_length, ctx->key);\n  \n  return ctx;\n}",
      "lines": 50,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nbench_openssl_ecdsa_init (unsigned size)",
        "*"
      ]
    },
    "bench_openssl_ecdsa_sign": {
      "start_point": [
        627,
        0
      ],
      "end_point": [
        633,
        1
      ],
      "content": "static void\nbench_openssl_ecdsa_sign (void *p)\n{\n  const struct openssl_ecdsa_ctx *ctx = p;\n  ECDSA_SIG *sig = ECDSA_do_sign (ctx->digest, ctx->digest_length, ctx->key);\n  ECDSA_SIG_free (sig);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_ecdsa_verify": {
      "start_point": [
        635,
        0
      ],
      "end_point": [
        642,
        1
      ],
      "content": "static void\nbench_openssl_ecdsa_verify (void *p)\n{\n  const struct openssl_ecdsa_ctx *ctx = p;\n  if (ECDSA_do_verify (ctx->digest, ctx->digest_length,\n\t\t\t ctx->signature, ctx->key) != 1)\n    die (\"Openssl ECDSA_do_verify failed.\\n\");      \n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_openssl_ecdsa_clear": {
      "start_point": [
        643,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "static void\nbench_openssl_ecdsa_clear (void *p)\n{\n  struct openssl_ecdsa_ctx *ctx = p;\n  ECDSA_SIG_free (ctx->signature);\n  EC_KEY_free (ctx->key);\n  free (ctx->digest);\n  free (ctx);\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_curve25519_mul_g": {
      "start_point": [
        660,
        0
      ],
      "end_point": [
        666,
        1
      ],
      "content": "static void\nbench_curve25519_mul_g (void *p)\n{\n  struct curve25519_ctx *ctx = p;\n  uint8_t q[CURVE25519_SIZE];\n  curve25519_mul_g (q, ctx->s);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_curve25519_mul": {
      "start_point": [
        668,
        0
      ],
      "end_point": [
        674,
        1
      ],
      "content": "static void\nbench_curve25519_mul (void *p)\n{\n  struct curve25519_ctx *ctx = p;\n  uint8_t q[CURVE25519_SIZE];\n  curve25519_mul (q, ctx->s, ctx->x);\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_curve25519": {
      "start_point": [
        676,
        0
      ],
      "end_point": [
        693,
        1
      ],
      "content": "static void\nbench_curve25519 (void)\n{\n  double mul_g;\n  double mul;\n  struct knuth_lfib_ctx lfib;\n  struct curve25519_ctx ctx;\n  knuth_lfib_init (&lfib, 2);\n\n  knuth_lfib_random (&lfib, sizeof(ctx.s), ctx.s);\n  curve25519_mul_g (ctx.x, ctx.s);\n\n  mul_g = time_function (bench_curve25519_mul_g, &ctx);\n  mul = time_function (bench_curve25519_mul, &ctx);\n\n  printf(\"%15s %4d %9.4f %9.4f\\n\",\n\t \"curve25519\", 255, 1e-3/mul_g, 1e-3/mul);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        722,
        0
      ],
      "end_point": [
        743,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *filter = NULL;\n  unsigned i;\n\n  if (argc > 1)\n    filter = argv[1];\n\n  time_init();\n  printf (\"%15s %4s %9s %9s\\n\",\n\t  \"name\", \"size\", \"sign/ms\", \"verify/ms\");\n\n  for (i = 0; i < numberof(alg_list); i++)\n    if (!filter || strstr (alg_list[i].name, filter))\n      bench_alg (&alg_list[i]);\n\n  if (!filter || strstr(\"curve25519\", filter))\n    bench_curve25519();\n\n  return EXIT_SUCCESS;\n}",
      "lines": 22,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/io.c": {
    "xalloc": {
      "start_point": [
        51,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void *\nxalloc(size_t size)\n{\n  void *p = malloc(size);\n  if (!p)\n    {\n      fprintf(stderr, \"Virtual memory exhausted.\\n\");\n      abort();\n    }\n\n  return p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "*\nxalloc(size_t size)",
        "*"
      ]
    },
    "werror": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nwerror(const char *format, ...)\n{\n  if (!quiet_flag)\n    {\n      va_list args;\n      va_start(args, format);\n      vfprintf(stderr, format, args);\n      va_end(args);\n    }\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "read_file": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "size_t\nread_file(const char *name, size_t max_size, uint8_t **contents)\n{\n  size_t size, done;\n  uint8_t *buffer;\n  FILE *f;\n    \n  f = fopen(name, \"rb\");\n  if (!f)\n    {\n      werror(\"Opening `%s' failed: %s\\n\", name, strerror(errno));\n      return 0;\n    }\n\n  size = 100;\n\n  for (buffer = NULL, done = 0;; size *= 2)\n    {\n      uint8_t *p;\n\n      if (max_size && size > max_size)\n\tsize = max_size;\n\n      /* Space for terminating NUL */\n      p = realloc(buffer, size + 1);\n\n      if (!p)\n\t{\n\tfail:\n\t  fclose(f);\n\t  free(buffer);\n\t  *contents = NULL;\n\t  return 0;\n\t}\n\n      buffer = p;\n      done += fread(buffer + done, 1, size - done, f);\n\n      if (done < size)\n\t{\n\t  /* Short count means EOF or read error */\n\t  if (ferror(f))\n\t    {\n\t      fprintf (stderr, \"Reading `%s' failed: %s\\n\",\n\t\t       name, strerror(errno));\n\n\t      goto fail;\n\t    }\n\t  if (done == 0)\n\t    /* Treat empty file as error */\n\t    goto fail;\n\n\t  break;\n\t}\n\n      if (size == max_size)\n\tbreak;\n    }\n  \n  fclose(f);\n\n  /* NUL-terminate the data. */\n  buffer[done] = '\\0';\n  *contents = buffer;\n  \n  return done;\n}",
      "lines": 67,
      "depth": 14,
      "decorators": [
        "size_t"
      ]
    },
    "write_data": {
      "start_point": [
        144,
        0
      ],
      "end_point": [
        150,
        1
      ],
      "content": "int\nwrite_data(FILE *f, size_t size, const void *buffer)\n{\n  size_t res = fwrite(buffer, 1, size, f);\n\n  return res == size;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "int"
      ]
    },
    "write_file": {
      "start_point": [
        152,
        0
      ],
      "end_point": [
        163,
        1
      ],
      "content": "int\nwrite_file(const char *name, size_t size, const void *buffer)\n{\n  FILE *f = fopen(name, \"wb\");\n  int res;\n  \n  if (!f)\n    return 0;\n\n  res = write_data(f, size, buffer);\n  return fclose(f) == 0 && res;\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "int"
      ]
    },
    "simple_random": {
      "start_point": [
        165,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "int\nsimple_random(struct yarrow256_ctx *ctx, const char *name)\n{\n  unsigned length;\n  uint8_t *buffer;\n\n  if (name)\n    length = read_file(name, 0, &buffer);\n  else\n    length = read_file(RANDOM_DEVICE, 20, &buffer);\n  \n  if (!length)\n    return 0;\n\n  yarrow256_seed(ctx, length, buffer);\n\n  free(buffer);\n\n  return 1;\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "hash_file": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        200,
        1
      ],
      "content": "int\nhash_file(const struct nettle_hash *hash, void *ctx, FILE *f)\n{\n  for (;;)\n    {\n      uint8_t buffer[BUFSIZE];\n      size_t res = fread(buffer, 1, sizeof(buffer), f);\n      if (ferror(f))\n\treturn 0;\n      \n      hash->update(ctx, res, buffer);\n      if (feof(f))\n\treturn 1;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/io.h": {},
  "nettle/nettle-3.4.1/examples/nettle-benchmark.c": {
    "NORETURN": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        122,
        1
      ],
      "content": "die(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n\n  exit(EXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": null
    },
    "time_function": {
      "start_point": [
        127,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "static double\ntime_function(void (*f)(void *arg), void *arg)\n{\n  unsigned ncalls;\n  double elapsed;\n\n  for (ncalls = 10 ;;)\n    {\n      unsigned i;\n\n      time_start();\n      for (i = 0; i < ncalls; i++)\n\tf(arg);\n      elapsed = time_end();\n      if (elapsed > BENCH_INTERVAL)\n\tbreak;\n      else if (elapsed < BENCH_INTERVAL / 10)\n\tncalls *= 10;\n      else\n\tncalls *= 2;\n    }\n  return elapsed / ncalls - overhead;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "bench_nothing": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        155,
        1
      ],
      "content": "static void\nbench_nothing(void *arg UNUSED)\n{\n  return;\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_memxor": {
      "start_point": [
        164,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void\nbench_memxor(void *arg)\n{\n  struct bench_memxor_info *info = arg;\n  memxor (info->dst, info->src, BENCH_BLOCK);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_memxor3": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        176,
        1
      ],
      "content": "static void\nbench_memxor3(void *arg)\n{\n  struct bench_memxor_info *info = arg;\n  memxor3 (info->dst, info->src, info->other, BENCH_BLOCK);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_hash": {
      "start_point": [
        185,
        0
      ],
      "end_point": [
        190,
        1
      ],
      "content": "static void\nbench_hash(void *arg)\n{\n  struct bench_hash_info *info = arg;\n  info->update(info->ctx, BENCH_BLOCK, info->data);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_cipher": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        204,
        1
      ],
      "content": "static void\nbench_cipher(void *arg)\n{\n  struct bench_cipher_info *info = arg;\n  info->crypt(info->ctx, BENCH_BLOCK, info->data, info->data);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_cbc_encrypt": {
      "start_point": [
        217,
        0
      ],
      "end_point": [
        224,
        1
      ],
      "content": "static void\nbench_cbc_encrypt(void *arg)\n{\n  struct bench_cbc_info *info = arg;\n  cbc_encrypt(info->ctx, info->crypt,\n\t      info->block_size, info->iv,\n\t      BENCH_BLOCK, info->data, info->data);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_cbc_decrypt": {
      "start_point": [
        226,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "static void\nbench_cbc_decrypt(void *arg)\n{\n  struct bench_cbc_info *info = arg;\n  cbc_decrypt(info->ctx, info->crypt,\n\t      info->block_size, info->iv,\n\t      BENCH_BLOCK, info->data, info->data);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_ctr": {
      "start_point": [
        235,
        0
      ],
      "end_point": [
        242,
        1
      ],
      "content": "static void\nbench_ctr(void *arg)\n{\n  struct bench_cbc_info *info = arg;\n  ctr_crypt(info->ctx, info->crypt,\n\t    info->block_size, info->iv,\n\t    BENCH_BLOCK, info->data, info->data);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_aead_crypt": {
      "start_point": [
        252,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\nbench_aead_crypt(void *arg)\n{\n  const struct bench_aead_info *info = arg;\n  info->crypt (info->ctx, BENCH_BLOCK, info->data, info->data);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_aead_update": {
      "start_point": [
        259,
        0
      ],
      "end_point": [
        264,
        1
      ],
      "content": "static void\nbench_aead_update(void *arg)\n{\n  const struct bench_aead_info *info = arg;\n  info->update (info->ctx, BENCH_BLOCK, info->data);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_data": {
      "start_point": [
        267,
        0
      ],
      "end_point": [
        277,
        1
      ],
      "content": "static void\ninit_data(uint8_t *data)\n{\n  unsigned i,j;\n  for (i = j = 0; i<BENCH_BLOCK;  i++)\n    {\n      if (j*j < i)\n\tj++;\n      data[i] = j;\n    }\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_key": {
      "start_point": [
        279,
        0
      ],
      "end_point": [
        286,
        1
      ],
      "content": "static void\ninit_key(unsigned length,\n         uint8_t *key)\n{\n  unsigned i;\n  for (i = 0; i<length; i++)\n    key[i] = i;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "init_nonce": {
      "start_point": [
        288,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "static void\ninit_nonce(unsigned length,\n\t   uint8_t *nonce)\n{\n  unsigned i;\n  for (i = 0; i<length; i++)\n    nonce[i] = 3*i;\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "header": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        303,
        1
      ],
      "content": "static void\nheader(void)\n{\n  printf(\"%18s %11s Mbyte/s%s\\n\",\n\t \"Algorithm\", \"mode\", \n\t frequency > 0.0 ? \" cycles/byte cycles/block\" : \"\");  \n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "display": {
      "start_point": [
        305,
        0
      ],
      "end_point": [
        319,
        1
      ],
      "content": "static void\ndisplay(const char *name, const char *mode, unsigned block_size,\n\tdouble time)\n{\n  printf(\"%18s %11s %7.2f\",\n\t name, mode,\n\t BENCH_BLOCK / (time * 1048576.0));\n  if (frequency > 0.0)\n    {\n      printf(\" %11.2f\", time * frequency / BENCH_BLOCK);\n      if (block_size > 0)\n\tprintf(\" %12.2f\", time * frequency * block_size / BENCH_BLOCK);\n    }\n  printf(\"\\n\");\n}",
      "lines": 15,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "xalloc": {
      "start_point": [
        321,
        0
      ],
      "end_point": [
        329,
        1
      ],
      "content": "static void *\nxalloc(size_t size)\n{\n  void *p = malloc(size);\n  if (!p)\n    die(\"Virtual memory exhausted.\\n\");\n\n  return p;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void",
        "*\nxalloc(size_t size)",
        "*"
      ]
    },
    "time_overhead": {
      "start_point": [
        331,
        0
      ],
      "end_point": [
        339,
        1
      ],
      "content": "static void\ntime_overhead(void)\n{\n  overhead = time_function(bench_nothing, NULL);\n  printf(\"benchmark call overhead: %7f us\", overhead * 1e6);\n  if (frequency > 0.0)\n    printf(\"%7.2f cycles\\n\", overhead * frequency);\n  printf(\"\\n\");  \n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_memxor": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        374,
        1
      ],
      "content": "static void\ntime_memxor(void)\n{\n  struct bench_memxor_info info;\n  unsigned long src[BENCH_BLOCK / sizeof(long) + 2];\n  unsigned long other[BENCH_BLOCK / sizeof(long) + 2];\n  unsigned long dst[BENCH_BLOCK / sizeof(long) + 1];\n\n  info.src = src;\n  info.dst = dst;\n\n  display (\"memxor\", \"aligned\", sizeof(unsigned long),\n\t   time_function(bench_memxor, &info));\n  info.src = (const char *) src + 1;\n  display (\"memxor\", \"unaligned\", sizeof(unsigned long),\n\t   time_function(bench_memxor, &info));\n\n  info.src = src;\n  info.other = other;\n  display (\"memxor3\", \"aligned\", sizeof(unsigned long),\n\t   time_function(bench_memxor3, &info));\n\n  info.other = (const char *) other + 1;\n  display (\"memxor3\", \"unaligned01\", sizeof(unsigned long),\n\t   time_function(bench_memxor3, &info));\n  info.src = (const char *) src + 1;\n  display (\"memxor3\", \"unaligned11\", sizeof(unsigned long),\n\t   time_function(bench_memxor3, &info));\n  info.other = (const char *) other + 2;\n  display (\"memxor3\", \"unaligned12\", sizeof(unsigned long),\n\t   time_function(bench_memxor3, &info));  \n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_hash": {
      "start_point": [
        376,
        0
      ],
      "end_point": [
        393,
        1
      ],
      "content": "static void\ntime_hash(const struct nettle_hash *hash)\n{\n  static uint8_t data[BENCH_BLOCK];\n  struct bench_hash_info info;\n\n  info.ctx = xalloc(hash->context_size); \n  info.update = hash->update;\n  info.data = data;\n\n  init_data(data);\n  hash->init(info.ctx);\n\n  display(hash->name, \"update\", hash->block_size,\n\t  time_function(bench_hash, &info));\n\n  free(info.ctx);\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_umac": {
      "start_point": [
        395,
        0
      ],
      "end_point": [
        438,
        1
      ],
      "content": "static void\ntime_umac(void)\n{\n  static uint8_t data[BENCH_BLOCK];\n  struct bench_hash_info info;\n  struct umac32_ctx ctx32;\n  struct umac64_ctx ctx64;\n  struct umac96_ctx ctx96;\n  struct umac128_ctx ctx128;\n  \n  uint8_t key[16];\n\n  umac32_set_key (&ctx32, key);\n  info.ctx = &ctx32;\n  info.update = (nettle_hash_update_func *) umac32_update;\n  info.data = data;\n\n  display(\"umac32\", \"update\", UMAC_BLOCK_SIZE,\n\t  time_function(bench_hash, &info));\n\n  umac64_set_key (&ctx64, key);\n  info.ctx = &ctx64;\n  info.update = (nettle_hash_update_func *) umac64_update;\n  info.data = data;\n\n  display(\"umac64\", \"update\", UMAC_BLOCK_SIZE,\n\t  time_function(bench_hash, &info));\n\n  umac96_set_key (&ctx96, key);\n  info.ctx = &ctx96;\n  info.update = (nettle_hash_update_func *) umac96_update;\n  info.data = data;\n\n  display(\"umac96\", \"update\", UMAC_BLOCK_SIZE,\n\t  time_function(bench_hash, &info));\n\n  umac128_set_key (&ctx128, key);\n  info.ctx = &ctx128;\n  info.update = (nettle_hash_update_func *) umac128_update;\n  info.data = data;\n\n  display(\"umac128\", \"update\", UMAC_BLOCK_SIZE,\n\t  time_function(bench_hash, &info));\n}",
      "lines": 44,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_poly1305_aes": {
      "start_point": [
        440,
        0
      ],
      "end_point": [
        455,
        1
      ],
      "content": "static void\ntime_poly1305_aes(void)\n{\n  static uint8_t data[BENCH_BLOCK];\n  struct bench_hash_info info;\n  struct poly1305_aes_ctx ctx;\n  uint8_t key[32];\n\n  poly1305_aes_set_key (&ctx, key);\n  info.ctx = &ctx;\n  info.update = (nettle_hash_update_func *) poly1305_aes_update;\n  info.data = data;\n\n  display(\"poly1305-aes\", \"update\", 1024,\n\t  time_function(bench_hash, &info));\n}",
      "lines": 16,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "prefix_p": {
      "start_point": [
        457,
        0
      ],
      "end_point": [
        465,
        1
      ],
      "content": "static int\nprefix_p(const char *prefix, const char *s)\n{\n  size_t i;\n  for (i = 0; prefix[i]; i++)\n    if (prefix[i] != s[i])\n      return 0;\n  return 1;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "block_cipher_p": {
      "start_point": [
        467,
        0
      ],
      "end_point": [
        472,
        1
      ],
      "content": "static int\nblock_cipher_p(const struct nettle_cipher *cipher)\n{\n  /* Don't use nettle cbc and ctr for openssl ciphers. */\n  return cipher->block_size > 0 && !prefix_p(\"openssl\", cipher->name);\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "time_cipher": {
      "start_point": [
        474,
        0
      ],
      "end_point": [
        571,
        1
      ],
      "content": "static void\ntime_cipher(const struct nettle_cipher *cipher)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *key = xalloc(cipher->key_size);\n\n  static uint8_t data[BENCH_BLOCK];\n\n  printf(\"\\n\");\n  \n  init_data(data);\n\n  {\n    /* Decent initializers are a GNU extension, so don't use it here. */\n    struct bench_cipher_info info;\n    info.ctx = ctx;\n    info.crypt = cipher->encrypt;\n    info.data = data;\n    \n    init_key(cipher->key_size, key);\n    cipher->set_encrypt_key(ctx, key);\n\n    display(cipher->name, \"ECB encrypt\", cipher->block_size,\n\t    time_function(bench_cipher, &info));\n  }\n  \n  {\n    struct bench_cipher_info info;\n    info.ctx = ctx;\n    info.crypt = cipher->decrypt;\n    info.data = data;\n    \n    init_key(cipher->key_size, key);\n    cipher->set_decrypt_key(ctx, key);\n\n    display(cipher->name, \"ECB decrypt\", cipher->block_size,\n\t    time_function(bench_cipher, &info));\n  }\n\n  if (block_cipher_p(cipher))\n    {\n      uint8_t *iv = xalloc(cipher->block_size);\n      \n      /* Do CBC mode */\n      {\n        struct bench_cbc_info info;\n\tinfo.ctx = ctx;\n\tinfo.crypt = cipher->encrypt;\n\tinfo.data = data;\n\tinfo.block_size = cipher->block_size;\n\tinfo.iv = iv;\n    \n        memset(iv, 0, cipher->block_size);\n    \n        cipher->set_encrypt_key(ctx, key);\n\n\tdisplay(cipher->name, \"CBC encrypt\", cipher->block_size,\n\t\ttime_function(bench_cbc_encrypt, &info));\n      }\n\n      {\n        struct bench_cbc_info info;\n\tinfo.ctx = ctx;\n\tinfo.crypt = cipher->decrypt;\n\tinfo.data = data;\n\tinfo.block_size = cipher->block_size;\n\tinfo.iv = iv;\n    \n        memset(iv, 0, cipher->block_size);\n\n        cipher->set_decrypt_key(ctx, key);\n\n\tdisplay(cipher->name, \"CBC decrypt\", cipher->block_size,\n\t\ttime_function(bench_cbc_decrypt, &info));\n      }\n\n      /* Do CTR mode */\n      {\n        struct bench_cbc_info info;\n\tinfo.ctx = ctx;\n\tinfo.crypt = cipher->encrypt;\n\tinfo.data = data;\n\tinfo.block_size = cipher->block_size;\n\tinfo.iv = iv;\n    \n        memset(iv, 0, cipher->block_size);\n    \n        cipher->set_encrypt_key(ctx, key);\n\n\tdisplay(cipher->name, \"CTR\", cipher->block_size,\n\t\ttime_function(bench_ctr, &info));\t\n      }\n      \n      free(iv);\n    }\n  free(ctx);\n  free(key);\n}",
      "lines": 98,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "time_aead": {
      "start_point": [
        573,
        0
      ],
      "end_point": [
        636,
        1
      ],
      "content": "static void\ntime_aead(const struct nettle_aead *aead)\n{\n  void *ctx = xalloc(aead->context_size);\n  uint8_t *key = xalloc(aead->key_size);\n  uint8_t *nonce = xalloc(aead->nonce_size);\n  static uint8_t data[BENCH_BLOCK];\n\n  printf(\"\\n\");\n  \n  init_data(data);\n  if (aead->set_nonce)\n    init_nonce (aead->nonce_size, nonce);\n\n  {\n    /* Decent initializers are a GNU extension, so don't use it here. */\n    struct bench_aead_info info;\n    info.ctx = ctx;\n    info.crypt = aead->encrypt;\n    info.data = data;\n    \n    init_key(aead->key_size, key);\n    aead->set_encrypt_key(ctx, key);\n    if (aead->set_nonce)\n      aead->set_nonce (ctx, nonce);\n\n    display(aead->name, \"encrypt\", aead->block_size,\n\t    time_function(bench_aead_crypt, &info));\n  }\n  \n  {\n    struct bench_aead_info info;\n    info.ctx = ctx;\n    info.crypt = aead->decrypt;\n    info.data = data;\n    \n    init_key(aead->key_size, key);\n    aead->set_decrypt_key(ctx, key);\n    if (aead->set_nonce)\n      aead->set_nonce (ctx, nonce);\n\n    display(aead->name, \"decrypt\", aead->block_size,\n\t    time_function(bench_aead_crypt, &info));\n  }\n\n  if (aead->update)\n    {\n      struct bench_aead_info info;\n      info.ctx = ctx;\n      info.update = aead->update;\n      info.data = data;\n\n      aead->set_encrypt_key(ctx, key);\n\n      if (aead->set_nonce)\n\taead->set_nonce (ctx, nonce);\n    \n      display(aead->name, \"update\", aead->block_size,\n\t      time_function(bench_aead_update, &info));\n    }\n  free(ctx);\n  free(key);\n  free(nonce);\n}",
      "lines": 64,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "compare_double": {
      "start_point": [
        640,
        0
      ],
      "end_point": [
        651,
        1
      ],
      "content": "static int\ncompare_double(const void *ap, const void *bp)\n{\n  double a = *(const double *) ap;\n  double b = *(const double *) bp;\n  if (a < b)\n    return -1;\n  else if (a > b)\n    return 1;\n  else\n    return 0;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "bench_sha1_compress": {
      "start_point": [
        675,
        0
      ],
      "end_point": [
        685,
        1
      ],
      "content": "static void\nbench_sha1_compress(void)\n{\n  uint32_t state[_SHA1_DIGEST_LENGTH];\n  uint8_t data[SHA1_BLOCK_SIZE];\n  double t;\n\n  TIME_CYCLES (t, _nettle_sha1_compress(state, data));\n\n  printf(\"sha1_compress: %.2f cycles\\n\", t);  \n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_salsa20_core": {
      "start_point": [
        687,
        0
      ],
      "end_point": [
        695,
        1
      ],
      "content": "static void\nbench_salsa20_core(void)\n{\n  uint32_t state[_SALSA20_INPUT_LENGTH];\n  double t;\n\n  TIME_CYCLES (t, _nettle_salsa20_core(state, state, 20));\n  printf(\"salsa20_core: %.2f cycles\\n\", t);  \n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "bench_sha3_permute": {
      "start_point": [
        697,
        0
      ],
      "end_point": [
        705,
        1
      ],
      "content": "static void\nbench_sha3_permute(void)\n{\n  struct sha3_state state;\n  double t;\n\n  TIME_CYCLES (t, sha3_permute (&state));\n  printf(\"sha3_permute: %.2f cycles (%.2f / round)\\n\", t, t / 24.0);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        718,
        0
      ],
      "end_point": [
        840,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  unsigned i;\n  int c;\n  const char *alg;\n\n#if WITH_OPENSSL\n  nettle_openssl_init();\n#endif\n\n  const struct nettle_hash *hashes[] =\n    {\n      &nettle_md2, &nettle_md4, &nettle_md5,\n      OPENSSL(&nettle_openssl_md5)\n      &nettle_sha1, OPENSSL(&nettle_openssl_sha1)\n      &nettle_sha224, &nettle_sha256,\n      &nettle_sha384, &nettle_sha512,\n      &nettle_sha512_224, &nettle_sha512_256,\n      &nettle_sha3_224, &nettle_sha3_256,\n      &nettle_sha3_384, &nettle_sha3_512,\n      &nettle_ripemd160, &nettle_gosthash94,\n      NULL\n    };\n\n  const struct nettle_cipher *ciphers[] =\n    {\n      &nettle_aes128, &nettle_aes192, &nettle_aes256,\n      OPENSSL(&nettle_openssl_aes128)\n      OPENSSL(&nettle_openssl_aes192)\n      OPENSSL(&nettle_openssl_aes256)\n      &nettle_blowfish128, OPENSSL(&nettle_openssl_blowfish128)\n      &nettle_camellia128, &nettle_camellia192, &nettle_camellia256,\n      &nettle_cast128, OPENSSL(&nettle_openssl_cast128)\n      &nettle_des, OPENSSL(&nettle_openssl_des)\n      &nettle_des3,\n      &nettle_serpent256,\n      &nettle_twofish128, &nettle_twofish192, &nettle_twofish256,\n      NULL\n    };\n\n  const struct nettle_aead *aeads[] =\n    {\n      /* Stream ciphers */\n      &nettle_arcfour128, OPENSSL(&nettle_openssl_arcfour128)\n      &nettle_salsa20, &nettle_salsa20r12, &nettle_chacha,\n      /* Proper AEAD algorithme. */\n      &nettle_gcm_aes128,\n      &nettle_gcm_aes192,\n      &nettle_gcm_aes256,\n      &nettle_gcm_camellia128,\n      &nettle_gcm_camellia256,\n      &nettle_eax_aes128,\n      &nettle_chacha_poly1305,\n      NULL\n    };\n\n  enum { OPT_HELP = 300 };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"clock-frequency\", required_argument, NULL, 'f' },\n      { NULL, 0, NULL, 0 }\n    };\n  \n  while ( (c = getopt_long(argc, argv, \"f:\", options, NULL)) != -1)\n    switch (c)\n      {\n      case 'f':\n\tfrequency = atof(optarg);\n\tif (frequency > 0.0)\n\t  break;\n\t/* Fall through */\n\n      case OPT_HELP:\n\tprintf(\"Usage: nettle-benchmark [-f clock frequency] [alg]\\n\");\n\treturn EXIT_SUCCESS;\n\n      case '?':\n\treturn EXIT_FAILURE;\n\n      default:\n\tabort();\n    }\n\n  alg = argv[optind];\n\n  time_init();\n  bench_sha1_compress();\n  bench_salsa20_core();\n  bench_sha3_permute();\n  printf(\"\\n\");\n  time_overhead();\n\n  header();\n\n  if (!alg || strstr (\"memxor\", alg))\n    {\n      time_memxor();\n      printf(\"\\n\");\n    }\n  \n  for (i = 0; hashes[i]; i++)\n    if (!alg || strstr(hashes[i]->name, alg))\n      time_hash(hashes[i]);\n\n  if (!alg || strstr (\"umac\", alg))\n    time_umac();\n\n  if (!alg || strstr (\"poly1305-aes\", alg))\n    time_poly1305_aes();\n\n  for (i = 0; ciphers[i]; i++)\n    if (!alg || strstr(ciphers[i]->name, alg))\n      time_cipher(ciphers[i]);\n\n  for (i = 0; aeads[i]; i++)\n    if (!alg || strstr(aeads[i]->name, alg))\n      time_aead(aeads[i]);\n\n  return 0;\n}",
      "lines": 123,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/nettle-openssl.c": {
    "nettle_openssl_init": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "void\nnettle_openssl_init(void)\n{\n  ERR_load_crypto_strings();\n  OpenSSL_add_all_algorithms();\n#if OPENSSL_VERSION_NUMBER >= 0x1010000\n  CONF_modules_load_file(NULL, NULL, 0);\n#else\n  OPENSSL_config(NULL);\n#endif\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "openssl_evp_set_encrypt_key": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        84,
        1
      ],
      "content": "static void\nopenssl_evp_set_encrypt_key(void *p, const uint8_t *key,\n\t\t\t    const EVP_CIPHER *cipher)\n{\n  struct openssl_cipher_ctx *ctx = p;\n  ctx->evp = EVP_CIPHER_CTX_new();\n  assert(EVP_EncryptInit_ex(ctx->evp, cipher, NULL, key, NULL) == 1);\n  EVP_CIPHER_CTX_set_padding(ctx->evp, 0);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_evp_set_decrypt_key": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "static void\nopenssl_evp_set_decrypt_key(void *p, const uint8_t *key,\n\t\t\t    const EVP_CIPHER *cipher)\n{\n  struct openssl_cipher_ctx *ctx = p;\n  ctx->evp = EVP_CIPHER_CTX_new();\n  assert(EVP_DecryptInit_ex(ctx->evp, cipher, NULL, key, NULL) == 1);\n  EVP_CIPHER_CTX_set_padding(ctx->evp, 0);\n}",
      "lines": 9,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_evp_encrypt": {
      "start_point": [
        95,
        0
      ],
      "end_point": [
        102,
        1
      ],
      "content": "static void\nopenssl_evp_encrypt(const void *p, size_t length,\n\t\t    uint8_t *dst, const uint8_t *src)\n{\n  const struct openssl_cipher_ctx *ctx = p;\n  int len;\n  assert(EVP_EncryptUpdate(ctx->evp, dst, &len, src, length) == 1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_evp_decrypt": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static void\nopenssl_evp_decrypt(const void *p, size_t length,\n\t\t    uint8_t *dst, const uint8_t *src)\n{\n  const struct openssl_cipher_ctx *ctx = p;\n  int len;\n  assert(EVP_DecryptUpdate(ctx->evp, dst, &len, src, length) == 1);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes128_set_encrypt_key": {
      "start_point": [
        120,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static void\nopenssl_aes128_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_aes_128_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes128_set_decrypt_key": {
      "start_point": [
        125,
        0
      ],
      "end_point": [
        129,
        1
      ],
      "content": "static void\nopenssl_aes128_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_aes_128_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes192_set_encrypt_key": {
      "start_point": [
        131,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\nopenssl_aes192_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_aes_192_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes192_set_decrypt_key": {
      "start_point": [
        136,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "static void\nopenssl_aes192_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_aes_192_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes256_set_encrypt_key": {
      "start_point": [
        142,
        0
      ],
      "end_point": [
        146,
        1
      ],
      "content": "static void\nopenssl_aes256_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_aes_256_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_aes256_set_decrypt_key": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        151,
        1
      ],
      "content": "static void\nopenssl_aes256_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_aes_256_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_arcfour128_set_encrypt_key": {
      "start_point": [
        178,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "static void\nopenssl_arcfour128_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_rc4());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_arcfour128_set_decrypt_key": {
      "start_point": [
        184,
        0
      ],
      "end_point": [
        188,
        1
      ],
      "content": "static void\nopenssl_arcfour128_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_rc4());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_bf128_set_encrypt_key": {
      "start_point": [
        203,
        0
      ],
      "end_point": [
        207,
        1
      ],
      "content": "static void\nopenssl_bf128_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_bf_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_bf128_set_decrypt_key": {
      "start_point": [
        209,
        0
      ],
      "end_point": [
        213,
        1
      ],
      "content": "static void\nopenssl_bf128_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_bf_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_des_set_encrypt_key": {
      "start_point": [
        225,
        0
      ],
      "end_point": [
        229,
        1
      ],
      "content": "static void\nopenssl_des_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_des_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_des_set_decrypt_key": {
      "start_point": [
        231,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "static void\nopenssl_des_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_des_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_cast128_set_encrypt_key": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        251,
        1
      ],
      "content": "static void\nopenssl_cast128_set_encrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_encrypt_key(ctx, key, EVP_cast5_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_cast128_set_decrypt_key": {
      "start_point": [
        253,
        0
      ],
      "end_point": [
        257,
        1
      ],
      "content": "static void\nopenssl_cast128_set_decrypt_key(void *ctx, const uint8_t *key)\n{\n  openssl_evp_set_decrypt_key(ctx, key, EVP_cast5_ecb());\n}",
      "lines": 5,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_md5_init": {
      "start_point": [
        271,
        0
      ],
      "end_point": [
        275,
        1
      ],
      "content": "static void\nopenssl_md5_init(void *ctx)\n{\n  MD5_Init(ctx);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_md5_update": {
      "start_point": [
        278,
        0
      ],
      "end_point": [
        284,
        1
      ],
      "content": "static void\nopenssl_md5_update(void *ctx,\n\t\t   size_t length,\n\t\t   const uint8_t *src)\n{\n  MD5_Update(ctx, src, length);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_md5_digest": {
      "start_point": [
        287,
        0
      ],
      "end_point": [
        294,
        1
      ],
      "content": "static void\nopenssl_md5_digest(void *ctx,\n\t\t   size_t length, uint8_t *dst)\n{\n  assert(length == SHA_DIGEST_LENGTH);\n  MD5_Final(dst, ctx);\n  MD5_Init(ctx);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_sha1_init": {
      "start_point": [
        307,
        0
      ],
      "end_point": [
        311,
        1
      ],
      "content": "static void\nopenssl_sha1_init(void *ctx)\n{\n  SHA1_Init(ctx);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_sha1_update": {
      "start_point": [
        314,
        0
      ],
      "end_point": [
        320,
        1
      ],
      "content": "static void\nopenssl_sha1_update(void *ctx,\n\t\t    size_t length,\n\t\t    const uint8_t *src)\n{\n  SHA1_Update(ctx, src, length);\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "openssl_sha1_digest": {
      "start_point": [
        323,
        0
      ],
      "end_point": [
        330,
        1
      ],
      "content": "static void\nopenssl_sha1_digest(void *ctx,\n\t\t    size_t length, uint8_t *dst)\n{\n  assert(length == SHA_DIGEST_LENGTH);\n  SHA1_Final(dst, ctx);\n  SHA1_Init(ctx);\n}",
      "lines": 8,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/random-prime.c": {
    "usage": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static void\nusage(void)\n{\n  fprintf(stderr, \"Usage: random-prime [OPTIONS] bits\\n\\n\"\n\t  \"Options:\\n\"\n\t  \"      --help         Display this message.\\n\"\n\t  \"  -v, --verbose      Display timing information.\\n\"\n\t  \"  -r, --random FILE  Random data to use for seeding.\\n\");\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  long bits;\n  mpz_t p;\n  struct yarrow256_ctx yarrow;\n\n  int verbose = 0;  \n  const char *random_file = NULL;\n\n  int c;\n  char *arg_end;\n\n  clock_t start;\n  clock_t end;\n  \n  enum { OPT_HELP = 300 };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"verbose\", no_argument, NULL, 'v' },\n      { \"random\", required_argument, NULL, 'r' },\n      { NULL, 0, NULL, 0}\n    };\n\n  while ( (c = getopt_long(argc, argv, \"vr:\", options, NULL)) != -1)\n    switch (c)\n      {\n      case 'v':\n\tverbose = 1;\n\tbreak;\n      case 'r':\n\trandom_file = optarg;\n\tbreak;\n      case OPT_HELP:\n\tusage();\n\treturn EXIT_SUCCESS;\n      case '?':\n\treturn EXIT_FAILURE;\n      default:\n\tabort();\n      }\n\n  argc -= optind;\n  argv += optind;\n\n  if (argc != 1)\n    {\n      usage();\n      return EXIT_FAILURE;\n    }\n\n  bits = strtol(argv[0], &arg_end, 0);\n  if (*arg_end || bits < 0)\n    {\n      fprintf(stderr, \"Invalid number.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  if (bits < 3)\n    {\n      fprintf(stderr, \"Bitsize must be at least 3.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  /* NOTE: No sources */\n  yarrow256_init(&yarrow, 0, NULL);\n\n  /* Read some data to seed the generator */\n  if (!simple_random(&yarrow, random_file))\n    {\n      werror(\"Initialization of randomness generator failed.\\n\");\n      return EXIT_FAILURE;\n    }\n  \n  mpz_init(p);\n\n  start = clock();\n\n  nettle_random_prime(p, bits, 0,\n\t\t      &yarrow, (nettle_random_func *) yarrow256_random,\n\t\t      NULL, NULL);\n\n  end = clock();\n\n  mpz_out_str(stdout, 10, p);\n  printf(\"\\n\");\n\n  if (verbose)\n    fprintf(stderr, \"time: %.3g s\\n\",\n\t    (double)(end - start) / CLOCKS_PER_SEC);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 95,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/read_rsa_key.c": {
    "read_rsa_key": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "int\nread_rsa_key(const char *name,\n\t     struct rsa_public_key *pub,\n\t     struct rsa_private_key *priv)\n{\n  unsigned length;\n  uint8_t *buffer;\n  int res;\n  \n  length = read_file(name, 0, &buffer);\n  if (!length)\n    return 0;\n\n  res = rsa_keypair_from_sexp(pub, priv, 0, length, buffer);\n  free(buffer);\n\n  return res;\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/rsa-decrypt.c": {
    "rsa_session_set_decrypt_key": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        69,
        1
      ],
      "content": "void\nrsa_session_set_decrypt_key(struct rsa_session *ctx,\n\t\t\t    const struct rsa_session_info *key)\n{\n  const uint8_t *aes_key = SESSION_AES_KEY(key);\n  const uint8_t *iv = SESSION_IV(key);\n  const uint8_t *hmac_key = SESSION_HMAC_KEY(key);\n  \n  aes_set_decrypt_key(&ctx->aes.ctx, AES_KEY_SIZE, aes_key);\n  CBC_SET_IV(&ctx->aes, iv);\n  hmac_sha1_set_key(&ctx->hmac, SHA1_DIGEST_SIZE, hmac_key);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "read_uint32": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static int\nread_uint32(FILE *f, uint32_t *n)\n{\n  uint8_t buf[4];\n  if (fread(buf, 1, sizeof(buf), f) != sizeof(buf))\n    return 0;\n\n  *n = READ_UINT32(buf);\n  return 1;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_version": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static int\nread_version(FILE *f)\n{\n  uint32_t version;\n  return read_uint32(f, &version) && version == RSA_VERSION;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_bignum": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        109,
        1
      ],
      "content": "static int\nread_bignum(FILE *f, mpz_t x)\n{\n  uint32_t size;\n  if (read_uint32(f, &size)\n      && size < 1000)\n    {\n      uint8_t *p = xalloc(size);\n      if (fread(p, 1, size, f) != size)\n\t{\n\t  free(p);\n\t  return 0;\n\t}\n\n      nettle_mpz_set_str_256_u(x, size, p);\n      free(p);\n\n      return 1;\n    }\n  return 0;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_file": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        199,
        1
      ],
      "content": "static int\nprocess_file(struct rsa_session *ctx,\n\t     FILE *in, FILE *out)\n{\n  uint8_t buffer[BUF_SIZE + BUF_FINAL];\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  size_t size;\n  unsigned padding;\n\n  size = fread(buffer, 1, BUF_FINAL, in);\n  if (size < BUF_FINAL)\n    {\n      if (ferror(in))\n\twerror(\"Reading input failed: %s\\n\", strerror(errno));\n      else\n\twerror(\"Unexpected EOF on input.\\n\");\n      return 0;\n    }\n\n  do\n    {\n      size = fread(buffer + BUF_FINAL, 1, BUF_SIZE, in);\n\n      if (size < BUF_SIZE && ferror(in))\n\t{\n\t  werror(\"Reading input failed: %s\\n\", strerror(errno));\n\t  return 0;\n\t}\n\n      if (size % AES_BLOCK_SIZE != 0)\n\t{\n\t  werror(\"Unexpected EOF on input.\\n\");\n\t  return 0;\n\t}\n\n      if (size)\n\t{\n\t  CBC_DECRYPT(&ctx->aes, aes_decrypt, size, buffer, buffer);\n\t  hmac_sha1_update(&ctx->hmac, size, buffer);\n\t  if (!write_data(out, size, buffer))\n\t    {\n\t      werror(\"Writing output failed: %s\\n\", strerror(errno));\n\t      return 0;\n\t    }\n\t  memmove(buffer, buffer + size, BUF_FINAL);\n\t}\n    }\n  while (size == BUF_SIZE);\n\n  /* Decrypt final block */\n  CBC_DECRYPT(&ctx->aes, aes_decrypt, AES_BLOCK_SIZE, buffer, buffer);\n  padding = buffer[AES_BLOCK_SIZE - 1];\n  if (padding > AES_BLOCK_SIZE)\n    {\n      werror(\"Decryption failed: Invalid padding.\\n\");\n      return 0;\n    }\n\n  if (padding < AES_BLOCK_SIZE)\n    {\n      unsigned leftover = AES_BLOCK_SIZE - padding;\n      hmac_sha1_update(&ctx->hmac, leftover, buffer);\n      if (!write_data(out, leftover, buffer))\n\t{\n\t  werror(\"Writing output failed: %s\\n\", strerror(errno));\n\t  return 0;\n\t}\n    }\n  hmac_sha1_digest(&ctx->hmac, SHA1_DIGEST_SIZE, digest);\n  if (!memeql_sec(digest, buffer + AES_BLOCK_SIZE, SHA1_DIGEST_SIZE))\n    {\n      werror(\"Decryption failed: Invalid mac.\\n\");\n      return 0;\n    }\n  \n  return 1;\n}",
      "lines": 77,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        201,
        0
      ],
      "end_point": [
        261,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct rsa_private_key key;\n  struct rsa_session ctx;\n  struct rsa_session_info session;\n\n  size_t length;\n  mpz_t x;\n\n  mpz_init(x);\n  \n  if (argc != 2)\n    {\n      werror(\"Usage: rsa-decrypt PRIVATE-KEY < ciphertext\\n\");\n      return EXIT_FAILURE;\n    }\n\n  rsa_private_key_init(&key);\n  \n  if (!read_rsa_key(argv[1], NULL, &key))\n    {\n      werror(\"Invalid key\\n\");\n      return EXIT_FAILURE;\n    }\n\n#ifdef WIN32\n  _setmode(0, O_BINARY);\n  _setmode(1, O_BINARY);\n#endif\n\n  if (!read_version(stdin))\n    {\n      werror(\"Bad version number in input file.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  if (!read_bignum(stdin, x))\n    {\n      werror(\"Bad rsa header in input file.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  length = sizeof(session.key);\n  if (!rsa_decrypt(&key, &length, session.key, x) || length != sizeof(session.key))\n    {\n      werror(\"Failed to decrypt rsa header in input file.\\n\");\n      return EXIT_FAILURE;      \n    }\n  mpz_clear(x);\n  \n  rsa_session_set_decrypt_key(&ctx, &session);\n\n  if (!process_file(&ctx,\n\t\t    stdin, stdout))\n    return EXIT_FAILURE;\n  \n  rsa_private_key_clear(&key);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 61,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/rsa-encrypt.c": {
    "rsa_session_set_encrypt_key": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nrsa_session_set_encrypt_key(struct rsa_session *ctx,\n\t\t\t    const struct rsa_session_info *key)\n{\n  const uint8_t *aes_key = SESSION_AES_KEY(key);\n  const uint8_t *iv = SESSION_IV(key);\n  const uint8_t *hmac_key = SESSION_HMAC_KEY(key);\n  \n  aes_set_encrypt_key(&ctx->aes.ctx, AES_KEY_SIZE, aes_key);\n  CBC_SET_IV(&ctx->aes, iv);\n  hmac_sha1_set_key(&ctx->hmac, SHA1_DIGEST_SIZE, hmac_key);\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "write_uint32": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nwrite_uint32(FILE *f, uint32_t n)\n{\n  uint8_t buffer[4];\n  WRITE_UINT32(buffer, n);\n\n  return write_data(f, sizeof(buffer), buffer);\n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "write_version": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        83,
        1
      ],
      "content": "static int\nwrite_version(FILE *f)\n{\n  return write_uint32(f, 1);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "write_bignum": {
      "start_point": [
        85,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "static int\nwrite_bignum(FILE *f, mpz_t x)\n{\n  unsigned size = nettle_mpz_sizeinbase_256_u(x);\n  uint8_t *p;\n  int res;\n  \n  if (!write_uint32(f, size))\n    return 0;\n  \n  p = xalloc(size);\n  nettle_mpz_get_str_256(size, p, x);\n\n  res = write_data(f, size, p);\n  free(p);\n  return res;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "process_file": {
      "start_point": [
        105,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "static int\nprocess_file(struct rsa_session *ctx,\n\t     FILE *in, FILE *out)\n{\n  uint8_t buffer[BLOCK_SIZE + SHA1_DIGEST_SIZE];\n\n  for (;;)\n    {\n      size_t size = fread(buffer, 1, BLOCK_SIZE, in);\n      hmac_sha1_update(&ctx->hmac, size, buffer);\n\n      if (size < BLOCK_SIZE)\n\t{\n\t  unsigned leftover;\n\t  unsigned padding;\n\n\t  if (ferror(in))\n\t    {\n\t      werror(\"Reading input failed: %s\\n\", strerror(errno));\n\t      return 0;\n\t    }\n\t  \n\t  leftover = size % AES_BLOCK_SIZE;\n\t  padding = AES_BLOCK_SIZE - leftover;\n\n\t  assert (size + padding <= BLOCK_SIZE);\n\t  \n\t  if (padding > 1)\n\t    yarrow256_random(&ctx->yarrow, padding - 1, buffer + size);\n\n\t  size += padding;\n\n\t  buffer[size - 1] = padding;\n\t  CBC_ENCRYPT(&ctx->aes, aes_encrypt, size, buffer, buffer);\n\n\t  assert (size + SHA1_DIGEST_SIZE <= sizeof(buffer));\n\n\t  hmac_sha1_digest(&ctx->hmac, SHA1_DIGEST_SIZE, buffer + size);\n\t  size += SHA1_DIGEST_SIZE;\n\n\t  if (!write_data(out, size, buffer))\n\t    {\n\t      werror(\"Writing output failed: %s\\n\", strerror(errno));\n\t      return 0;\n\t    }\n\t  return 1;\n\t}\n\n      CBC_ENCRYPT(&ctx->aes, aes_encrypt, size, buffer, buffer);\n      if (!write_data(out, size, buffer))\n\t{\n\t  werror(\"Writing output failed: %s\\n\", strerror(errno));\n\t  return 0;\n\t}\n    }\n}",
      "lines": 56,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        162,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void\nusage (FILE *out)\n{\n  fprintf (out, \"Usage: rsa-encrypt [OPTIONS] PUBLIC-KEY < cleartext\\n\"\n\t   \"Options:\\n\"\n\t   \"   -r, --random=FILE   seed file for randomness generator\\n\"\n\t   \"       --help          display this help\\n\");  \n}",
      "lines": 8,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        171,
        0
      ],
      "end_point": [
        272,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct rsa_session ctx;\n  struct rsa_session_info info;\n  \n  struct rsa_public_key key;\n  mpz_t x;\n  \n  int c;\n  const char *random_name = NULL;\n\n  enum { OPT_HELP = 300 };\n  \n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"random\", required_argument, NULL, 'r' },\n      { NULL, 0, NULL, 0}\n    };\n  \n  while ( (c = getopt_long(argc, argv, \"o:r:\", options, NULL)) != -1)\n    switch (c)\n      {\n      case 'r':\n\trandom_name = optarg;\n\tbreak;\n\t\n      case '?':\n\treturn EXIT_FAILURE;\n\n      case OPT_HELP:\n\tusage(stdout);\n\treturn EXIT_SUCCESS;\n      default:\n\tabort();\n      }\n\n  argv += optind;\n  argc -= optind;\n\n  if (argc != 1)\n    {\n      usage (stderr);\n      return EXIT_FAILURE;\n    }\n\n  rsa_public_key_init(&key);\n  \n  if (!read_rsa_key(argv[0], &key, NULL))\n    {\n      werror(\"Invalid key\\n\");\n      return EXIT_FAILURE;\n    }\n\n  /* NOTE: No sources */\n  yarrow256_init(&ctx.yarrow, 0, NULL);\n  \n  /* Read some data to seed the generator */\n  if (!simple_random(&ctx.yarrow, random_name))\n    {\n      werror(\"Initialization of randomness generator failed.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  WRITE_UINT32(SESSION_VERSION(&info), RSA_VERSION);\n  \n  yarrow256_random(&ctx.yarrow, sizeof(info.key) - 4, info.key + 4);\n\n  rsa_session_set_encrypt_key(&ctx, &info);\n  \n#ifdef WIN32\n  _setmode(0, O_BINARY);\n  _setmode(1, O_BINARY);\n#endif\n\n  write_version(stdout);\n  \n  mpz_init(x);\n\n  if (!rsa_encrypt(&key,\n\t\t   &ctx.yarrow, (nettle_random_func *) yarrow256_random,\n\t\t   sizeof(info.key), info.key, \n\t\t   x))\n    {\n      werror(\"RSA encryption failed.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  write_bignum(stdout, x);\n\n  mpz_clear (x);\n\n  if (!process_file(&ctx,\n\t\t    stdin, stdout))\n    return EXIT_FAILURE;\n\n  rsa_public_key_clear(&key);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 102,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/rsa-keygen.c": {
    "progress": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\nprogress(void *ctx, int c)\n{\n  (void) ctx;\n  fputc(c, stderr);\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "uint_arg": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static unsigned long\nuint_arg (char c, const char *arg)\n{\n  unsigned long val;\n  char *end;\n\n  val = strtoul(arg, &end, 0);\n  if (*arg == '\\0' || *end != '\\0')\n    {\n      werror (\"Invalid integer argument for -%c option.\\n\", c);\n      exit (EXIT_FAILURE);\n    }\n\n  return val;      \n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "unsigned long",
        "unsigned",
        "long"
      ]
    },
    "main": {
      "start_point": [
        76,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct yarrow256_ctx yarrow;\n  struct rsa_public_key pub;\n  struct rsa_private_key priv;\n\n  int c;\n  char *pub_name = NULL;\n  const char *priv_name = NULL;\n  const char *random_name = NULL;\n  \n  struct nettle_buffer pub_buffer;\n  struct nettle_buffer priv_buffer;\n\n  unsigned long key_size = DEFAULT_KEYSIZE;\n  unsigned long key_e = 0;\n\n  enum { OPT_HELP = 300 };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"random\", required_argument, NULL, 'r' },\n      { NULL, 0, NULL, 0}\n    };\n  \n  while ( (c = getopt_long(argc, argv, \"o:r:e:s:\", options, NULL)) != -1)\n    switch (c)\n      {\t\n      case 'o':\n\tpriv_name = optarg;\n\tbreak;\n\n      case 'r':\n\trandom_name = optarg;\n\tbreak;\n\n      case 's':\n\tkey_size = uint_arg ('s', optarg);\n\tbreak;\n\n      case 'e':\n\tkey_e = uint_arg ('e', optarg);\n\tbreak;\n\n      case OPT_HELP:\n\tprintf(\"FIXME: Usage information.\\n\");\n\treturn EXIT_SUCCESS;\n\n      case '?':\n\treturn EXIT_FAILURE;\n\n      default:\n\tabort();\n      }\n\n  if (!priv_name)\n    {\n      werror(\"No filename provided.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  pub_name = xalloc(strlen(priv_name) + 5);  \n  sprintf(pub_name, \"%s.pub\", priv_name);\n\n  /* NOTE: No sources */\n  yarrow256_init(&yarrow, 0, NULL);\n\n  /* Read some data to seed the generator */\n  if (!simple_random(&yarrow, random_name))\n    {\n      werror(\"Initialization of randomness generator failed.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  rsa_public_key_init(&pub);\n  rsa_private_key_init(&priv);\n\n  if (key_e)\n    mpz_set_ui (pub.e, key_e);\n\n  if (!rsa_generate_keypair\n      (&pub, &priv,\n       (void *) &yarrow, (nettle_random_func *) yarrow256_random,\n       NULL, progress,\n       key_size, key_e == 0 ? ESIZE : 0))\n    {\n      werror(\"Key generation failed.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  nettle_buffer_init(&priv_buffer);\n  nettle_buffer_init(&pub_buffer);\n  \n  if (!rsa_keypair_to_sexp(&pub_buffer, \"rsa-pkcs1-sha1\", &pub, NULL))\n    {\n      werror(\"Formatting public key failed.\\n\");\n      return EXIT_FAILURE;\n    }\n\n  if (!rsa_keypair_to_sexp(&priv_buffer, \"rsa-pkcs1-sha1\", &pub, &priv))\n    {\n      werror(\"Formatting private key failed.\\n\");\n      return EXIT_FAILURE;\n    }\n  \n  if (!write_file(pub_name, pub_buffer.size, pub_buffer.contents))\n    {\n      werror(\"Failed to write public key: %s\\n\",\n\t      strerror(errno));\n      return EXIT_FAILURE;\n    }\n\n  /* NOTE: This doesn't set up paranoid access restrictions on the\n   * private key file, like a serious key generation tool would do. */\n  if (!write_file(priv_name, priv_buffer.size, priv_buffer.contents))\n    {\n      werror(\"Failed to write private key: %s\\n\",\n\t      strerror(errno));\n      return EXIT_FAILURE;\n    }\n\n  nettle_buffer_clear(&priv_buffer);\n  nettle_buffer_clear(&pub_buffer);\n  rsa_public_key_clear(&pub);\n  rsa_private_key_clear(&priv);\n  free (pub_name);\n  \n  return EXIT_SUCCESS;\n}",
      "lines": 131,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/rsa-session.h": {},
  "nettle/nettle-3.4.1/examples/rsa-sign.c": {
    "main": {
      "start_point": [
        44,
        0
      ],
      "end_point": [
        93,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct rsa_private_key key;\n  struct sha1_ctx hash;\n  mpz_t s;\n  \n  if (argc != 2)\n    {\n      werror(\"Usage: rsa-sign PRIVATE-KEY < file\\n\");\n      return EXIT_FAILURE;\n    }\n\n  rsa_private_key_init(&key);\n  \n  if (!read_rsa_key(argv[1], NULL, &key))\n    {\n      werror(\"Invalid key\\n\");\n      return EXIT_FAILURE;\n    }\n\n  sha1_init(&hash);\n  if (!hash_file(&nettle_sha1, &hash, stdin))\n    {\n      werror(\"Failed reading stdin: %s\\n\",\n\t      strerror(errno));\n      return 0;\n    }\n\n  mpz_init(s);\n  if (!rsa_sha1_sign(&key, &hash, s))\n    {\n      werror(\"RSA key too small\\n\");\n      return 0;\n    }\n\n  if (!mpz_out_str(stdout, 16, s))\n    {\n      werror(\"Failed writing signature: %s\\n\",\n\t      strerror(errno));\n      return 0;\n    }\n\n  putchar('\\n');\n  \n  mpz_clear(s);\n  rsa_private_key_clear(&key);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/rsa-verify.c": {
    "read_signature": {
      "start_point": [
        43,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static int\nread_signature(const char *name, mpz_t s)\n{\n  uint8_t *buffer;\n  unsigned length;\n  int res;\n  \n  length = read_file(name, 0, &buffer);\n  if (!length)\n    return 0;\n\n  res = (mpz_set_str(s, (const char *) buffer, 16) == 0);\n  free(buffer);\n\n  return res;\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct rsa_public_key key;\n  struct sha1_ctx hash;\n  mpz_t s;\n  \n  if (argc != 3)\n    {\n      werror(\"Usage: rsa-verify PUBLIC-KEY SIGNATURE-FILE < FILE\\n\");\n      return EXIT_FAILURE;\n    }\n\n  rsa_public_key_init(&key);\n  \n  if (!read_rsa_key(argv[1], &key, NULL))\n    {\n      werror(\"Invalid key\\n\");\n      return EXIT_FAILURE;\n    }\n\n  mpz_init(s);\n\n  if (!read_signature(argv[2], s))\n    {\n      werror(\"Failed to read signature file `%s'\\n\",\n\t      argv[2]);\n      return EXIT_FAILURE;\n    }\n  \n  sha1_init(&hash);\n  if (!hash_file(&nettle_sha1, &hash, stdin))\n    {\n      werror(\"Failed reading stdin: %s\\n\",\n\t      strerror(errno));\n      return 0;\n    }\n\n  if (!rsa_sha1_verify(&key, &hash, s))\n    {\n      werror(\"Invalid signature!\\n\");\n      return EXIT_FAILURE;\n    }\n    \n  mpz_clear(s);\n  rsa_public_key_clear(&key);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/timing.c": {
    "NORETURN": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        57,
        1
      ],
      "content": "die(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n\n  exit(EXIT_FAILURE);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": null
    },
    "cgt_works_p": {
      "start_point": [
        59,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\ncgt_works_p(void)\n{\n  struct timespec now;\n  return clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &now) == 0;\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "cgt_time_start": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\ncgt_time_start(void)\n{\n  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &cgt_start) < 0)\n    die(\"clock_gettime failed: %s\\n\", strerror(errno));\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "cgt_time_end": {
      "start_point": [
        73,
        0
      ],
      "end_point": [
        82,
        1
      ],
      "content": "static double\ncgt_time_end(void)\n{\n  struct timespec end;\n  if (clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &end) < 0)\n    die(\"clock_gettime failed: %s\\n\", strerror(errno));\n\n  return end.tv_sec - cgt_start.tv_sec\n    + 1e-9 * (end.tv_nsec - cgt_start.tv_nsec);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "clock_time_start": {
      "start_point": [
        87,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "static void\nclock_time_start(void)\n{\n  clock_start = clock();\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "clock_time_end": {
      "start_point": [
        93,
        0
      ],
      "end_point": [
        97,
        1
      ],
      "content": "static double\nclock_time_end(void)\n{\n  return (double) (clock() - (clock_start)) / CLOCKS_PER_SEC;\n}",
      "lines": 5,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "double"
      ]
    },
    "time_init": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "void time_init(void)\n{\n  /* Choose timing function */\n#if TRY_CLOCK_GETTIME\n  if (cgt_works_p())\n    {\n      time_start = cgt_time_start;\n      time_end = cgt_time_end;\n    }\n  else\n    {\n      fprintf(stderr, \"clock_gettime not working, falling back to clock\\n\");\n      time_start = clock_time_start;\n      time_end = clock_time_end;\n    }\n#endif\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/examples/timing.h": {},
  "nettle/nettle-3.4.1/testsuite/aes-test.c": {
    "test_invert": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "static void\ntest_invert(const struct tstring *key,\n\t    const struct tstring *cleartext,\n\t    const struct tstring *ciphertext)\n{\n  struct aes_ctx encrypt;\n  struct aes_ctx decrypt;\n  uint8_t *data = xalloc(cleartext->length);\n  size_t length;\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  aes_set_encrypt_key (&encrypt, key->length, key->data);\n  aes_encrypt (&encrypt, length, data, cleartext->data);\n  \n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"test_invert: Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  aes_invert_key (&decrypt, &encrypt);\n  aes_decrypt (&decrypt, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"test_invert: Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  free (data);\n}",
      "lines": 43,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes128_set_encrypt_key": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "static void\nunified_aes128_set_encrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_encrypt_key (ctx, AES128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes128_set_decrypt_key": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\nunified_aes128_set_decrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_decrypt_key (ctx, AES128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes192_set_encrypt_key": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "static void\nunified_aes192_set_encrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_encrypt_key (ctx, AES192_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes192_set_decrypt_key": {
      "start_point": [
        71,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\nunified_aes192_set_decrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_decrypt_key (ctx, AES192_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes256_set_encrypt_key": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        81,
        1
      ],
      "content": "static void\nunified_aes256_set_encrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_encrypt_key (ctx, AES256_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "unified_aes256_set_decrypt_key": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "static void\nunified_aes256_set_decrypt_key (void *ctx, const uint8_t *key)\n{\n  aes_set_decrypt_key (ctx, AES256_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_cipher2": {
      "start_point": [
        103,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "static void\ntest_cipher2(const struct nettle_cipher *c1,\n\t     const struct nettle_cipher *c2,\t     \n\t     const struct tstring *key,\n\t     const struct tstring *cleartext,\n\t     const struct tstring *ciphertext)\n{\n  test_cipher (c1, key, cleartext, ciphertext);\n  test_cipher (c2, key, cleartext, ciphertext);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        114,
        0
      ],
      "end_point": [
        222,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Test both the new interface and the older unified interface. */\n\n  /* 128 bit keys */\n  test_cipher2(&nettle_aes128, &nettle_unified_aes128,\n\t       SHEX(\"0001020305060708 0A0B0C0D0F101112\"),\n\t       SHEX(\"506812A45F08C889 B97F5980038B8359\"),\n\t       SHEX(\"D8F532538289EF7D 06B506A4FD5BE9C9\"));\n  \n  test_cipher2(&nettle_aes128, &nettle_unified_aes128,\n\t       SHEX(\"14151617191A1B1C 1E1F202123242526\"),\n\t       SHEX(\"5C6D71CA30DE8B8B 00549984D2EC7D4B\"),\n\t       SHEX(\"59AB30F4D4EE6E4F F9907EF65B1FB68C\"));\n\n  test_cipher2(&nettle_aes128, &nettle_unified_aes128,\n\t       SHEX(\"28292A2B2D2E2F30 323334353738393A\"),\n\t       SHEX(\"53F3F4C64F8616E4 E7C56199F48F21F6\"),\n\t       SHEX(\"BF1ED2FCB2AF3FD4 1443B56D85025CB1\"));\n  \n  test_cipher2(&nettle_aes128, &nettle_unified_aes128,\n\t       SHEX(\"A0A1A2A3A5A6A7A8 AAABACADAFB0B1B2\"),\n\t       SHEX(\"F5F4F7F684878689 A6A7A0A1D2CDCCCF\"),\n\t       SHEX(\"CE52AF650D088CA5 59425223F4D32694\"));\n\n  /* 192 bit keys */\n  test_cipher2(&nettle_aes192, &nettle_unified_aes192, \n\t       SHEX(\"0001020305060708 0A0B0C0D0F101112\"\n\t\t    \"14151617191A1B1C\"),\n\t       SHEX(\"2D33EEF2C0430A8A 9EBF45E809C40BB6\"),\n\t       SHEX(\"DFF4945E0336DF4C 1C56BC700EFF837F\"));\n\n  /* 256 bit keys */\n  test_cipher2(&nettle_aes256, &nettle_unified_aes256,\n\t       SHEX(\"0001020305060708 0A0B0C0D0F101112\"\n\t\t    \"14151617191A1B1C 1E1F202123242526\"),\n\t       SHEX(\"834EADFCCAC7E1B30664B1ABA44815AB\"),\n\t       SHEX(\"1946DABF6A03A2A2 C3D0B05080AED6FC\"));\n\n  \n  /* This test case has been problematic with the CBC test case */\n  test_cipher2(&nettle_aes256, &nettle_unified_aes256,\n\t       SHEX(\"8d ae 93 ff fc 78 c9 44\"\n\t\t    \"2a bd 0c 1e 68 bc a6 c7\"\n\t\t    \"05 c7 84 e3 5a a9 11 8b\"\n\t\t    \"d3 16 aa 54 9b 44 08 9e\"),\n\t       SHEX(\"a5 ce 55 d4 21 15 a1 c6 4a a4 0c b2 ca a6 d1 37\"),\n\t       /* In the cbc test, I once got the bad value\n\t\t*   \"b2 a0 6c d2 2f df 7d 2c  26 d2 42 88 8f 20 74 a2\" */\n\t       SHEX(\"1f 94 fc 85 f2 36 21 06\"\n\t\t    \"4a ea e3 c9 cc 38 01 0e\"));\n  \n  /* From draft NIST spec on AES modes.\n   *\n   * F.1 ECB Example Vectors\n   * F.1.1 ECB-AES128-Encrypt\n   */\n\n  test_cipher2(&nettle_aes128, &nettle_unified_aes128,\n\t       SHEX(\"2b7e151628aed2a6abf7158809cf4f3c\"),\n\t       SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t    \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t    \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t    \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t       SHEX(\"3ad77bb40d7a3660a89ecaf32466ef97\"\n\t\t    \"f5d3d58503b9699de785895a96fdbaaf\"\n\t\t    \"43b1cd7f598ece23881b00e3ed030688\"\n\t\t    \"7b0c785e27e8ad3f8223207104725dd4\"));\n\n  /* F.1.3 ECB-AES192-Encrypt */\n\n  test_cipher2(&nettle_aes192, &nettle_unified_aes192, \n\t       SHEX(\"8e73b0f7da0e6452c810f32b809079e5 62f8ead2522c6b7b\"),\n\t       SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t    \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t    \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t    \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t       SHEX(\"bd334f1d6e45f25ff712a214571fa5cc\"\n\t\t    \"974104846d0ad3ad7734ecb3ecee4eef\"\n\t\t    \"ef7afd2270e2e60adce0ba2face6444e\"\n\t\t    \"9a4b41ba738d6c72fb16691603c18e0e\"));\n\n  /* F.1.5 ECB-AES256-Encrypt */\n  test_cipher2(&nettle_aes256, &nettle_unified_aes256,\n\t       SHEX(\"603deb1015ca71be2b73aef0857d7781\"\n\t\t    \"1f352c073b6108d72d9810a30914dff4\"),\n\t       SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t    \"ae2d8a571e03ac9c9eb76fac45af8e51\" \n\t\t    \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t    \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t       SHEX(\"f3eed1bdb5d2a03c064b5a7e3db181f8\"\n\t\t    \"591ccb10d410ed26dc5ba74a31362870\"\n\t\t    \"b6ed21b99ca6f4f9f153e7b1beafed1d\"\n\t\t    \"23304b7a39f9f3ff067d8d8f9e24ecc7\"));\n\n  /* Test aes_invert_key with src != dst */\n  test_invert(SHEX(\"0001020305060708 0A0B0C0D0F101112\"),\n\t      SHEX(\"506812A45F08C889 B97F5980038B8359\"),\n\t      SHEX(\"D8F532538289EF7D 06B506A4FD5BE9C9\"));\n  test_invert(SHEX(\"0001020305060708 0A0B0C0D0F101112\"\n\t\t   \"14151617191A1B1C\"),\n\t      SHEX(\"2D33EEF2C0430A8A 9EBF45E809C40BB6\"),\n\t      SHEX(\"DFF4945E0336DF4C 1C56BC700EFF837F\"));\n  test_invert(SHEX(\"0001020305060708 0A0B0C0D0F101112\"\n\t\t   \"14151617191A1B1C 1E1F202123242526\"),\n\t      SHEX(\"834EADFCCAC7E1B30664B1ABA44815AB\"),\n\t      SHEX(\"1946DABF6A03A2A2 C3D0B05080AED6FC\"));\n}",
      "lines": 109,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/arcfour-test.c": {
    "test_arcfour": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        67,
        1
      ],
      "content": "static void\ntest_arcfour(const struct tstring *key,\n\t     const struct tstring *cleartext,\n\t     const struct tstring *ciphertext)\n{\n  size_t block;\n  struct arcfour_ctx ctx;\n\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  data = xalloc(length + 1);\n\n  for (block = 1; block <= length; block++)\n    {\n      size_t i;\n\n      memset(data, 0x17, length + 1);\n      arcfour_set_key(&ctx, key->length, key->data);\n\n      for (i = 0; i + block < length; i += block)\n\t{\n\t  arcfour_crypt(&ctx, block, data + i, cleartext->data + i);\n\t  ASSERT (data[i + block] == 0x17);\n\t}\n\n      arcfour_crypt(&ctx, length - i, data + i, cleartext->data + i);\n      ASSERT (data[length] == 0x17);\n\n      if (!MEMEQ(length, data, ciphertext->data))\n\t{\n\t  fprintf(stderr, \"Encrypt failed, block size %lu\\nInput:\",\n\t\t  (unsigned long) block);\n\t  tstring_print_hex(cleartext);\n\t  fprintf(stderr, \"\\nOutput: \");\n\t  print_hex(length, data);\n\t  fprintf(stderr, \"\\nExpected:\");\n\t  tstring_print_hex(ciphertext);\n\t  fprintf(stderr, \"\\n\");\n\t  FAIL();\n\t}\n    }\n\n  arcfour_set_key(&ctx, key->length, key->data);\n  arcfour_crypt(&ctx, length, data, data);\n\n  ASSERT (data[length] == 0x17);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 65,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        69,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_arcfour(SHEX(\"01234567 89ABCDEF 00000000 00000000\"),\n\t       SHEX(\"01234567 89ABCDEF\"),\n\t       SHEX(\"69723659 1B5242B1\"));\n\n  /* More data. This ensures that we get some collisions between the S\n     accesses at index i,j and the access at si + sj. I.e. the cases\n     where the ordering of loads and stores matter. */\n  test_arcfour(SHEX(\"aaaaaaaa bbbbbbbb cccccccc dddddddd\"),\n\t       SHEX(\"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t\t\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"),\n\t       SHEX(\"a2b35dc7 bf95ae1e 1c432d15 f4fb8c1c\"\n\t\t    \"f264e1d0 bd090831 6caa7d17 5401ae67\"\n\t\t    \"3cfbd140 fd3dee42 1012d674 2fb69fa3\"\n\t\t    \"6522631e bb3d4703 535de1ce 4a81ddce\"\n\n\t\t    \"5780cfe0 b5fc9fae ebe14c96 26451bd9\"\n\t\t    \"992f2204 119cbe37 cbdc453c 7afa08c7\"\n\t\t    \"1380ccf8 48f81e53 a535cdfb 96c64faa\"\n\t\t    \"c3f759d0 fa1ff920 008d95cf 39d52324\"\n\n\t\t    \"d0aac3f9 749b22e2 6a065145 06fb249d\"\n\t\t    \"ffb8e05e cb0381fe 5346a04a 63dac61c\"\n\t\t    \"10b6683e 3ab427de d4c6bc60 6366545e\"\n\t\t    \"77d0e121 96037717 a745d49e e72a70aa\"\n\n\t\t    \"a50a612d 879b0580 fd4a89ae 3ee49871\"\n\t\t    \"2cf6c98d a62dfbc7 d7b2d901 2c3aaf27\"\n\t\t    \"42b7e089 ef2466ac 450b440c 138daa1a\"\n\t\t    \"cf9ebef6 f66a7a64 2677b213 06640130\"\n\n\t\t    \"de6651df 0065180d 4db366ba 9c377712\"\n\t\t    \"53d21cac 82ed72a4 c6c4d81e 4375fea3\"\n\t\t    \"1f935909 95322c83 13c64d8e 829c93a6\"\n\t\t    \"d540a1b3 20f41541 96800888 1a7afc9b\"\n\n\t\t    \"e39e89fc 3ac78be5 cdbbf774 33c36863\"\n\t\t    \"da2a3b1b d06e54a9 aa4b7edd 70b34941\"\n\t\t    \"b886f7db f36c3def f9fc4c80 7ce55ea5\"\n\t\t    \"98a7257b f68a9e1d caf4bfd6 43bd9853\"\n\n\t\t    \"c966629d 54e34221 6e140780 d48c69bb\"\n\t\t    \"5e77e886 86f2ebcb 807732d5 d29bc384\"\n\t\t    \"a4ca1c31 c7c1b5b9 85dbfcf1 8d845905\"\n\t\t    \"a0ff487a b4a3f252 a75caebf 857ba48b\"\n\n\t\t    \"613e3067 92cada3e 0e07f599 2f4794f3\"\n\t\t    \"af01f15a 491732fb 22aa09a3 d2e1e408\"\n\t\t    \"fe94bdb4 993c68b1 1bb79eb1 bb7ec446\"\n\t\t    \"760ef7bf 2caa8713 479760e5 a6e143cd\"));\n}",
      "lines": 90,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/arctwo-test.c": {
    "test_arctwo": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        61,
        1
      ],
      "content": "static void\ntest_arctwo(unsigned ekb,\n\t    const struct tstring *key,\n\t    const struct tstring *cleartext,\n\t    const struct tstring *ciphertext)\n{\n  struct arctwo_ctx ctx;\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n  \n  data = xalloc(length);\n\n  arctwo_set_key_ekb(&ctx, key->length, key->data, ekb);\n  arctwo_encrypt(&ctx, length, data, cleartext->data);\n\n  ASSERT(MEMEQ(length, data, ciphertext->data));\n\n  arctwo_decrypt(&ctx, length, data, data);\n\n  ASSERT(MEMEQ(length, data, cleartext->data));\n\n  free(data);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        125,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Test vectors from Peter Gutmann's paper. */\n  test_cipher(&nettle_arctwo_gutmann128,\n\t      SHEX(\"00000000 00000000 00000000 00000000\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"1c198a83 8df028b7\"));\n\n  test_cipher(&nettle_arctwo_gutmann128,\n\t      SHEX(\"00010203 04050607 08090a0b 0c0d0e0f\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"50dc0162 bd757f31\"));\n\n  /* This one was checked against libmcrypt's RFC2268. */\n  test_cipher(&nettle_arctwo_gutmann128,\n\t      SHEX(\"30000000 00000000 00000000 00000000\"),\n\t      SHEX(\"10000000 00000000\"),\n\t      SHEX(\"8fd10389 336bf95e\"));\n\n  /* Test vectors from RFC 2268. */\n  test_cipher(&nettle_arctwo64,\n\t      SHEX(\"ffffffff ffffffff\"),\n\t      SHEX(\"ffffffff ffffffff\"),\n\t      SHEX(\"278b27e4 2e2f0d49\"));\n\n  test_cipher(&nettle_arctwo64,\n\t      SHEX(\"30000000 00000000\"),\n\t      SHEX(\"10000000 00000001\"),\n\t      SHEX(\"30649edf 9be7d2c2\"));\n\n  test_cipher(&nettle_arctwo128,\n\t      SHEX(\"88bca90e 90875a7f 0f79c384 627bafb2\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"2269552a b0f85ca6\"));\n\n  /* More obscure tests from RFC 2286 */\n  test_arctwo(63,\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"ebb773f9 93278eff\"));\n\n  test_arctwo(64,\n\t      SHEX(\"88\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"61a8a244 adacccf0\"));\n\n  test_arctwo(64,\n\t      SHEX(\"88bca90e 90875a\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"6ccf4308 974c267f\"));\n\n  test_arctwo(64,\n\t      SHEX(\"88bca90e 90875a7f 0f79c384 627bafb2\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"1a807d27 2bbe5db1\"));\n\n  test_arctwo(129,\n\t      SHEX(\"88bca90e 90875a7f 0f79c384 627bafb2\"\n\t\t   \"16f80a6f 85920584 c42fceb0 be255daf 1e\"),\n\t      SHEX(\"00000000 00000000\"),\n\t      SHEX(\"5b78d3a4 3dfff1f1\"));\n}",
      "lines": 63,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/base16-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        23,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  ASSERT(BASE16_ENCODE_LENGTH(0) == 0);\n  ASSERT(BASE16_ENCODE_LENGTH(1) == 2);\n  ASSERT(BASE16_ENCODE_LENGTH(2) == 4);\n\n  ASSERT(BASE16_DECODE_LENGTH(0) == 0);\n  ASSERT(BASE16_DECODE_LENGTH(1) == 1);\n  ASSERT(BASE16_DECODE_LENGTH(2) == 1);\n  ASSERT(BASE16_DECODE_LENGTH(3) == 2);\n  ASSERT(BASE16_DECODE_LENGTH(4) == 2);\n  \n  test_armor(&nettle_base16, LDATA(\"\"), \"\");\n  test_armor(&nettle_base16, LDATA(\"H\"), \"48\");\n  test_armor(&nettle_base16, LDATA(\"He\"), \"4865\");\n  test_armor(&nettle_base16, LDATA(\"Hel\"), \"48656c\");\n  test_armor(&nettle_base16, LDATA(\"Hell\"), \"48656c6c\");\n  test_armor(&nettle_base16, LDATA(\"Hello\"), \"48656c6c6f\");\n  test_armor(&nettle_base16, LDATA(\"Hello\\0\"), \"48656c6c6f00\");\n}",
      "lines": 21,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/base64-test.c": {
    "test_fuzz_once": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static void\ntest_fuzz_once(struct base64_encode_ctx *encode,\n\t       struct base64_decode_ctx *decode,\n\t       size_t size, const uint8_t *input)\n{\n  size_t base64_len = BASE64_ENCODE_RAW_LENGTH (size);\n  size_t out_len;\n  char *base64 = xalloc (base64_len + 2);\n  uint8_t *decoded = xalloc (size + 2);\n\n  *base64++ = 0x12;\n  base64[base64_len] = 0x34;\n\n  *decoded++ = 0x56;\n  decoded[size] = 0x78;\n\n  out_len = base64_encode_update(encode, base64, size, input);\n  ASSERT (out_len <= base64_len);\n  out_len += base64_encode_final(encode, base64 + out_len);\n  ASSERT (out_len == base64_len);\n  ASSERT (base64[-1] == 0x12);\n  ASSERT (base64[base64_len] == 0x34);\n\n  ASSERT(base64_decode_update(decode, &out_len, decoded,\n\t\t\t      base64_len, base64));\n  ASSERT(base64_decode_final(decode));\n  ASSERT (out_len == size);\n  ASSERT (decoded[-1] == 0x56);\n  ASSERT (decoded[size] == 0x78);\n  \n  ASSERT(MEMEQ(size, input, decoded));\n  free (base64 - 1);\n  free (decoded - 1);\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_fuzz": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ntest_fuzz(void)\n{\n  /* Fuzz a round-trip through both encoder and decoder */\n  struct base64_encode_ctx encode;\n  struct base64_decode_ctx decode;\n  unsigned i;\n  size_t length;\n  uint8_t input[1024];\n\n  struct knuth_lfib_ctx rand_ctx;\n  knuth_lfib_init(&rand_ctx, 39854);\n\n  for (i = 0; i < 10000; i++)\n    {\n      length = i % sizeof(input);\n      /* length could be 0, which is fine we need to test that case too */\n      knuth_lfib_random(&rand_ctx, length, input);\n\n      base64_encode_init(&encode);\n      base64_decode_init(&decode);\n      test_fuzz_once(&encode, &decode, length, input);\n\n      base64url_encode_init(&encode);\n      base64url_decode_init(&decode);\n      test_fuzz_once(&encode, &decode, length, input);\n    }\n}",
      "lines": 28,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "base64_encode_in_place": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static inline void\nbase64_encode_in_place (size_t length, uint8_t *data)\n{\n  base64_encode_raw ((char *) data, length, data);\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "void"
      ]
    },
    "base64_decode_in_place": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        80,
        1
      ],
      "content": "static inline int\nbase64_decode_in_place (struct base64_decode_ctx *ctx, size_t *dst_length,\n\t\t\tsize_t length, uint8_t *data)\n{\n  return base64_decode_update (ctx, dst_length,\n\t\t\t       data, length, (const char *) data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "test_main": {
      "start_point": [
        82,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  ASSERT(BASE64_ENCODE_LENGTH(0) == 0);   /* At most   4 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(1) == 2);   /* At most  12 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(2) == 3);   /* At most  20 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(3) == 4);   /* At most  28 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(4) == 6);   /* At most  36 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(5) == 7);   /* At most  44 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(12) == 16); /* At most 100 bits */\n  ASSERT(BASE64_ENCODE_LENGTH(13) == 18); /* At most 108 bits */\n\n  ASSERT(BASE64_DECODE_LENGTH(0) == 0); /* At most  6 bits */\n  ASSERT(BASE64_DECODE_LENGTH(1) == 1); /* At most 12 bits */\n  ASSERT(BASE64_DECODE_LENGTH(2) == 2); /* At most 18 bits */\n  ASSERT(BASE64_DECODE_LENGTH(3) == 3); /* At most 24 bits */\n  ASSERT(BASE64_DECODE_LENGTH(4) == 3); /* At most 30 bits */\n  \n  test_armor(&nettle_base64, LDATA(\"\"), \"\");\n  test_armor(&nettle_base64, LDATA(\"H\"), \"SA==\");\n  test_armor(&nettle_base64, LDATA(\"He\"), \"SGU=\");\n  test_armor(&nettle_base64, LDATA(\"Hel\"), \"SGVs\");\n  test_armor(&nettle_base64, LDATA(\"Hell\"), \"SGVsbA==\");\n  test_armor(&nettle_base64, LDATA(\"Hello\"), \"SGVsbG8=\");\n  test_armor(&nettle_base64, LDATA(\"Hello\\0\"), \"SGVsbG8A\");\n  test_armor(&nettle_base64, LDATA(\"Hello?>>>\"), \"SGVsbG8/Pj4+\");\n  test_armor(&nettle_base64, LDATA(\"\\xff\\xff\\xff\\xff\"), \"/////w==\");\n\n  test_armor(&nettle_base64url, LDATA(\"\"), \"\");\n  test_armor(&nettle_base64url, LDATA(\"H\"), \"SA==\");\n  test_armor(&nettle_base64url, LDATA(\"He\"), \"SGU=\");\n  test_armor(&nettle_base64url, LDATA(\"Hel\"), \"SGVs\");\n  test_armor(&nettle_base64url, LDATA(\"Hell\"), \"SGVsbA==\");\n  test_armor(&nettle_base64url, LDATA(\"Hello\"), \"SGVsbG8=\");\n  test_armor(&nettle_base64url, LDATA(\"Hello\\0\"), \"SGVsbG8A\");\n  test_armor(&nettle_base64url, LDATA(\"Hello?>>>\"), \"SGVsbG8_Pj4-\");\n  test_armor(&nettle_base64url, LDATA(\"\\xff\\xff\\xff\\xff\"), \"_____w==\");\n\n  {\n    /* Test overlapping areas */\n    uint8_t buffer[] = \"Helloxxxx\";\n    struct base64_decode_ctx ctx;\n    size_t dst_length;\n    \n    ASSERT(BASE64_ENCODE_RAW_LENGTH(5) == 8);\n    base64_encode_in_place(5, buffer);\n    ASSERT(MEMEQ(9, buffer, \"SGVsbG8=x\"));\n\n    base64_decode_init(&ctx);\n    dst_length = 0; /* Output parameter only. */\n    ASSERT(base64_decode_in_place(&ctx, &dst_length, 8, buffer));\n    ASSERT(dst_length == 5);\n    \n    ASSERT(MEMEQ(9, buffer, \"HelloG8=x\"));\n  }\n  test_fuzz ();\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/bignum-test.c": {
    "test_bignum": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "static void\ntest_bignum(const char *hex, const struct tstring *base256)\n{\n  mpz_t a;\n  mpz_t b;\n  uint8_t *buf;\n  \n  mpz_init_set_str(a, hex, 16);\n  nettle_mpz_init_set_str_256_s(b, base256->length, base256->data);\n\n  ASSERT(mpz_cmp(a, b) == 0);\n\n  buf = xalloc(base256->length + 1);\n  memset(buf, 17, base256->length + 1);\n\n  nettle_mpz_get_str_256(base256->length, buf, a);\n  ASSERT(MEMEQ(base256->length, buf, base256->data));\n\n  ASSERT(buf[base256->length] == 17);\n\n  mpz_clear(a); mpz_clear(b);\n  free(buf);\n}",
      "lines": 23,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_size": {
      "start_point": [
        36,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\ntest_size(long x, unsigned size)\n{\n  mpz_t t;\n\n  mpz_init_set_si(t, x);\n  ASSERT(nettle_mpz_sizeinbase_256_s(t) == size);\n  mpz_clear(t);\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ntest_main(void)\n{\n#if WITH_HOGWEED\n  test_size(0, 1);\n  test_size(1, 1);\n  test_size(0x7f, 1);\n  test_size(0x80, 2);\n  test_size(0x81, 2);\n  test_size(0xff, 2);\n  test_size(0x100, 2);\n  test_size(0x101, 2);\n  test_size(0x1111, 2);\n  test_size(0x7fff, 2);\n  test_size(0x8000, 3);\n  test_size(0x8001, 3);\n\n  test_size(-      1, 1); /*     ff */\n  test_size(-   0x7f, 1); /*     81 */\n  test_size(-   0x80, 1); /*     80 */\n  test_size(-   0x81, 2); /*   ff7f */\n  test_size(-   0xff, 2); /*   ff01 */\n  test_size(-  0x100, 2); /*   ff00 */\n  test_size(-  0x101, 2); /*   feff */\n  test_size(- 0x1111, 2); /*   eeef */\n  test_size(- 0x7fff, 2); /*   8001 */\n  test_size(- 0x8000, 2); /*   8000 */\n  test_size(- 0x8001, 3); /* ff7fff */\n\n  test_bignum(\"0\", SHEX(\"00\"));\n  test_bignum(\"010203040506\", SHEX(\"010203040506\"));\n  test_bignum(\"80010203040506\", SHEX(\"0080010203040506\"));\n\n  test_bignum(   \"-1\", SHEX(    \"ff\"));\n  test_bignum(  \"-7f\", SHEX(    \"81\"));\n  test_bignum(  \"-80\", SHEX(    \"80\"));\n  test_bignum(  \"-81\", SHEX(  \"ff7f\"));\n  test_bignum(\"-7fff\", SHEX(  \"8001\"));\n  test_bignum(\"-8000\", SHEX(  \"8000\"));\n  test_bignum(\"-8001\", SHEX(\"ff7fff\"));\n  \n#else /* !WITH_HOGWEED */\n  SKIP();\n#endif /* !WITH_HOGWEED */\n}",
      "lines": 45,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/blowfish-test.c": {
    "test_blowfish": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\ntest_blowfish(const struct tstring *key,\n\t      const struct tstring *cleartext,\n\t      const struct tstring *ciphertext)\n{\n  struct blowfish_ctx ctx;\n  uint8_t *data = xalloc(cleartext->length);\n  size_t length;\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  blowfish_set_key(&ctx, key->length, key->data);\n  blowfish_encrypt(&ctx, length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  blowfish_set_key(&ctx, key->length, key->data);\n  blowfish_decrypt(&ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* 208 bit key. Test from GNUPG. */\n  test_blowfish(SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t\tSDATA(\"BLOWFISH\"),\n\t\tSHEX(\"32 4E D0 FE F4 13 A2 03\"));\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/buffer-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        26,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct nettle_buffer buffer;\n  uint8_t s[5];\n  \n  nettle_buffer_init(&buffer);\n  ASSERT(nettle_buffer_write(&buffer, LDATA(\"foo\")));\n  \n  ASSERT(NETTLE_BUFFER_PUTC(&buffer, 'x'));\n\n  ASSERT(buffer.size == 4);\n  ASSERT(buffer.alloc >= 4);\n  ASSERT(MEMEQ(4, buffer.contents, \"foox\"));\n\n  nettle_buffer_clear(&buffer);\n  \n  nettle_buffer_init_size(&buffer, sizeof(s), s);\n  ASSERT(buffer.alloc == sizeof(s));\n  ASSERT(nettle_buffer_write(&buffer, LDATA(\"foo\")));\n  ASSERT(buffer.size == 3);\n\n  ASSERT(!nettle_buffer_write(&buffer, LDATA(\"bar\")));\n}",
      "lines": 24,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/camellia-test.c": {
    "test_invert": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ntest_invert(const struct tstring *key,\n\t    const struct tstring *cleartext,\n\t    const struct tstring *ciphertext)\n{\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  data = xalloc(length);\n\n  if (key->length == 16)\n    {\n      struct camellia128_ctx encrypt;\n      struct camellia128_ctx decrypt;\n\n      camellia128_set_encrypt_key (&encrypt, key->data);\n      camellia128_crypt (&encrypt, length, data, cleartext->data);\n  \n      if (!MEMEQ(length, data, ciphertext->data))\n\t{\n\tfail_encrypt:\n\t  tstring_print_hex(cleartext);\n\t  fprintf(stderr, \"\\nOutput: \");\n\t  print_hex(length, data);\n\t  fprintf(stderr, \"\\nExpected:\");\n\t  tstring_print_hex(ciphertext);\n\t  fprintf(stderr, \"\\n\");\n\t  FAIL();\n\t}\n\n      camellia128_invert_key (&decrypt, &encrypt);\n      camellia128_crypt (&decrypt, length, data, data);\n    }\n  else\n    {\n      struct camellia256_ctx encrypt;\n      struct camellia256_ctx decrypt;\n\n      if (key->length == 24)\n\tcamellia192_set_encrypt_key (&encrypt, key->data);\n      else if (key->length == 32)\n\tcamellia256_set_encrypt_key (&encrypt, key->data);\n      else\n\tabort ();\n\n      camellia256_crypt (&encrypt, length, data, cleartext->data);\n  \n      if (!MEMEQ(length, data, ciphertext->data))\n\tgoto fail_encrypt;\n\n      camellia256_invert_key (&decrypt, &encrypt);\n      camellia256_crypt (&decrypt, length, data, data);\n    }\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"test_invert: Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  free (data);\n}",
      "lines": 70,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Test vectors from RFC 3713 */\n  /* 128 bit keys */\n  test_cipher(&nettle_camellia128,\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43\"));\n\n  /* 192 bit keys */\n  test_cipher(&nettle_camellia192, \n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"\n\t\t   \"00 11 22 33 44 55 66 77\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9\"));\n\n  /* 256 bit keys */\n  test_cipher(&nettle_camellia256, \n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"\n\t\t   \"00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09\"));\n\n  /* Test camellia_invert_key with src != dst */\n  test_invert(SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"67 67 31 38 54 96 69 73 08 57 06 56 48 ea be 43\"));\n  \n  test_invert(SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"\n\t\t   \"00 11 22 33 44 55 66 77\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"b4 99 34 01 b3 e9 96 f8 4e e5 ce e7 d7 9b 09 b9\"));\n\n  test_invert(SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"\n\t\t   \"00 11 22 33 44 55 66 77 88 99 aa bb cc dd ee ff\"),\n\t      SHEX(\"01 23 45 67 89 ab cd ef fe dc ba 98 76 54 32 10\"),\n\t      SHEX(\"9a cc 23 7d ff 16 d7 6c 20 ef 7c 91 9e 3a 75 09\"));\n}",
      "lines": 39,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/cast128-test.c": {
    "test_cast5": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "static void\ntest_cast5(const struct tstring *key,\n\t      const struct tstring *cleartext,\n\t      const struct tstring *ciphertext)\n{\n  struct cast128_ctx ctx;\n  uint8_t *data = xalloc(cleartext->length);\n  size_t length;\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  cast5_set_key(&ctx, key->length, key->data);\n  cast128_encrypt(&ctx, length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cast5_set_key(&ctx, key->length, key->data);\n  cast128_decrypt(&ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Test vectors from B.1. Single Plaintext-Key-Ciphertext Sets, RFC\n   * 2144 */\n\n  /* 128 bit key */\n  test_cipher(&nettle_cast128,\n\t      SHEX(\"01 23 45 67 12 34 56 78\"\n\t\t   \"23 45 67 89 34 56 78 9A\"),\n\t      SHEX(\"01 23 45 67 89 AB CD EF\"),\n\t      SHEX(\"23 8B 4F E5 84 7E 44 B2\"));\n  \n  /* 80 bit key */\n  test_cast5(SHEX(\"01 23 45 67 12 34 56 78 23 45\"),\n\t     SHEX(\"01 23 45 67 89 AB CD EF\"),\n\t     SHEX(\"EB 6A 71 1A 2C 02 27 1B\"));\n\n  /* 40 bit key */\n  test_cast5(SHEX(\"01 23 45 67 12\"),\n\t     SHEX(\"01 23 45 67 89 AB CD EF\"),\n\t     SHEX(\"7A C8 16 D1 6E 9B 30 2E\"));\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/cbc-test.c": {
    "test_cbc_bulk": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\ntest_cbc_bulk(void)\n{\n  struct knuth_lfib_ctx random;\n  \n  uint8_t clear[CBC_BULK_DATA];\n  \n  uint8_t cipher[CBC_BULK_DATA + 1];\n\n  const uint8_t *key = H(\"966c7bf00bebe6dc 8abd37912384958a\"\n\t\t\t \"743008105a08657d dcaad4128eee38b3\");\n  \n  const uint8_t *start_iv = H(\"11adbff119749103 207619cfa0e8d13a\");\n  const uint8_t *end_iv = H(\"c7a42a569b421224 d0c23e52f46f97f5\");\n  \n  struct CBC_CTX(struct aes_ctx, AES_BLOCK_SIZE) aes;\n  \n  knuth_lfib_init(&random, CBC_BULK_DATA);\n  knuth_lfib_random(&random, CBC_BULK_DATA, clear);\n\n  /* Byte that should not be overwritten */\n  cipher[CBC_BULK_DATA] = 17;\n  \n  aes_set_encrypt_key(&aes.ctx, 32, key);\n  CBC_SET_IV(&aes, start_iv);\n\n  CBC_ENCRYPT(&aes, aes_encrypt, CBC_BULK_DATA, cipher, clear);\n\n  ASSERT(cipher[CBC_BULK_DATA] == 17);\n\n  if (verbose)\n    {\n      printf(\"IV after bulk encryption: \");\n      print_hex(AES_BLOCK_SIZE, aes.iv);\n      printf(\"\\n\");\n    }\n\n  ASSERT(MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));\n  \n  /* Decrypt, in place */\n  aes_set_decrypt_key(&aes.ctx, 32, key);\n  CBC_SET_IV(&aes, start_iv);\n  CBC_DECRYPT(&aes, aes_decrypt, CBC_BULK_DATA, cipher, cipher);\n\n  ASSERT(cipher[CBC_BULK_DATA] == 17);\n\n  if (verbose)\n    {\n      printf(\"IV after bulk decryption: \");\n      print_hex(AES_BLOCK_SIZE, aes.iv);\n      printf(\"\\n\");\n    }\n\n  ASSERT (MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));\n  ASSERT (MEMEQ(CBC_BULK_DATA, clear, cipher));\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        164,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Intermediate values:\n   *   iv XOR first message block:\n   *       \"a5 ce 55 d4 21 15 a1 c6 4a a4 0c b2 ca a6 d1 37\"\n   *   First ciphertext block, c1:\n   *       \"1f 94 fc 85 f2 36 21 06 4a ea e3 c9 cc 38 01 0e\"\n   *   c1 XOR second message block:\n   *       \"3f e0 94 ec 81 16 4e 68 26 93 c3 a6 a2 5b 64 2f\"\n   *   Second ciphertext block, c1:\n   *       \"7b f6 5f c5 02 59 2e 71 af bf 34 87 c0 36 2a 16\"\n   */\n\n  test_cipher_cbc(&nettle_aes256,\n\t\t  SHEX(\"8d ae 93 ff fc 78 c9 44\"\n\t\t       \"2a bd 0c 1e 68 bc a6 c7\"\n\t\t       \"05 c7 84 e3 5a a9 11 8b\"\n\t\t       \"d3 16 aa 54 9b 44 08 9e\"),\n\t\t  SDATA(\"Listen, I'll say this only once!\"),\n\t\t  SHEX(\"1f 94 fc 85 f2 36 21 06\"\n\t\t       \"4a ea e3 c9 cc 38 01 0e\"\n\t\t       \"7b f6 5f c5 02 59 2e 71\"\n\t\t       \"af bf 34 87 c0 36 2a 16\"),\n\t\t  SHEX(\"e9 a7 26 a0 44 7b 8d e6  03 83 60 de ea d5 b0 4e\"));\n\n  /* From NIST spec 800-38a on AES modes.\n   *\n   * F.2  CBC Example Vectors \n   * F.2.1 CBC-AES128.Encrypt\n   */\n\n  /* Intermediate values, blocks input to AES:\n   *\n   *   6bc0bce12a459991e134741a7f9e1925 \n   *   d86421fb9f1a1eda505ee1375746972c \n   *   604ed7ddf32efdff7020d0238b7c2a5d \n   *   8521f2fd3c8eef2cdc3da7e5c44ea206 \n   */\n  test_cipher_cbc(&nettle_aes128,\n\t\t  SHEX(\"2b7e151628aed2a6abf7158809cf4f3c\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"7649abac8119b246cee98e9b12e9197d\"\n\t\t       \"5086cb9b507219ee95db113a917678b2\"\n\t\t       \"73bed6b8e3c1743b7116e69e22229516\"\n\t\t       \"3ff1caa1681fac09120eca307586e1a7\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n  \n  /* F.2.3 CBC-AES192.Encrypt */\n  \n  /* Intermediate values, blcoks input to AES:\n   *\n   *   6bc0bce12a459991e134741a7f9e1925 \n   *   e12f97e55dbfcfa1efcf7796da0fffb9\n   *   8411b1ef0e2109e5001cf96f256346b5 \n   *   a1840065cdb4e1f7d282fbd7db9d35f0\n   */\n\n  test_cipher_cbc(&nettle_aes192,\n\t\t  SHEX(\"8e73b0f7da0e6452c810f32b809079e5\"\n\t\t       \"62f8ead2522c6b7b\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"4f021db243bc633d7178183a9fa071e8\"\n\t\t       \"b4d9ada9ad7dedf4e5e738763f69145a\"\n\t\t       \"571b242012fb7ae07fa9baac3df102e0\"\n\t\t       \"08b0e27988598881d920a9e64f5615cd\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n   \n  /* F.2.5 CBC-AES256.Encrypt */\n\n  /* Intermediate values, blcoks input to AES:\n   *\n   *   6bc0bce12a459991e134741a7f9e1925 \n   *   5ba1c653c8e65d26e929c4571ad47587 \n   *   ac3452d0dd87649c8264b662dc7a7e92\n   *   cf6d172c769621d8081ba318e24f2371 \n   */\n\n  test_cipher_cbc(&nettle_aes256,\n\t\t  SHEX(\"603deb1015ca71be2b73aef0857d7781\"\n\t\t       \"1f352c073b6108d72d9810a30914dff4\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"f58c4c04d6e5f1ba779eabfb5f7bfbd6\"\n\t\t       \"9cfc4e967edb808d679f777bc6702c7d\"\n\t\t       \"39f23369a9d9bacfa530e26304231461\"\n\t\t       \"b2eb05e2c39be9fcda6c19078c6a9d1b\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n\n  test_cbc_bulk();\n}",
      "lines": 99,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ccm-test.c": {
    "test_compare_results": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static void\ntest_compare_results(const char *name,\n        const struct tstring *adata,\n        /* Expected results. */\n        const struct tstring *e_clear,\n\t\tconst struct tstring *e_cipher,\n        /* Actual results. */\n        const void *clear,\n        const void *cipher,\n        const void *digest) /* digest optional. */\n{\n  int tlength = (e_cipher->length - e_clear->length);\n  if (digest && tlength && !MEMEQ(tlength, e_cipher->data + e_clear->length, digest))\n    {\n      fprintf(stderr, \"%s digest failed:\\nAdata:\", name);\n      tstring_print_hex(adata);\n      fprintf(stderr, \"\\nInput: \");\n      tstring_print_hex(e_clear);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(tlength, digest);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(tlength, e_cipher->data + e_clear->length);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  if (!MEMEQ(e_cipher->length, e_cipher->data, cipher))\n    {\n      fprintf(stderr, \"%s: encryption failed\\nAdata: \", name);\n      tstring_print_hex(adata);\n      fprintf(stderr, \"\\nInput: \");\n      tstring_print_hex(e_clear);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(e_cipher->length, cipher);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(e_cipher);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  if (!MEMEQ(e_clear->length, e_clear->data, clear))\n    {\n      fprintf(stderr, \"%s decrypt failed:\\nAdata:\", name);\n      tstring_print_hex(adata);\n      fprintf(stderr, \"\\nInput: \");\n      tstring_print_hex(e_cipher);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(e_clear->length, clear);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(e_clear);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n}",
      "lines": 52,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_cipher_ccm": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        248,
        1
      ],
      "content": "static void\ntest_cipher_ccm(const struct nettle_cipher *cipher,\n\t\tconst struct tstring *key,\n\t\tconst struct tstring *nonce,\n\t\tconst struct tstring *authdata,\n\t\tint repeat,\n\t\tconst struct tstring *cleartext,\n\t\tconst struct tstring *ciphertext)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *en_data;\n  uint8_t *de_data;\n  uint8_t *en_digest;\n  uint8_t de_digest[CCM_BLOCK_SIZE];\n  size_t tlength;\n  struct ccm_ctx ccm;\n  int    i;\n\n  ASSERT (key->length == cipher->key_size);\n  ASSERT (cleartext->length <= ciphertext->length);\n  ASSERT ((cleartext->length + CCM_BLOCK_SIZE) >= ciphertext->length);\n  tlength = ciphertext->length - cleartext->length;\n\n  de_data = xalloc(cleartext->length);\n  en_data = xalloc(ciphertext->length);\n  en_digest = en_data + cleartext->length;\n  cipher->set_encrypt_key(ctx, key->data);\n\n  /* Encrypt using the incremental API. */\n  ccm_set_nonce(&ccm, ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\tauthdata->length * repeat, cleartext->length, tlength);\n  for (i = 0; i < repeat; i++) {\n    ccm_update(&ccm, ctx, cipher->encrypt, authdata->length, authdata->data);\n  }\n  ccm_encrypt(&ccm, ctx, cipher->encrypt, cleartext->length, en_data, cleartext->data);\n  ccm_digest(&ccm, ctx, cipher->encrypt, tlength, en_digest);\n\n  /* Decrypt using the incremental API. */\n  ccm_set_nonce(&ccm, ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\tauthdata->length * repeat, cleartext->length, tlength);\n  for (i = 0; i < repeat; i++) {\n    ccm_update(&ccm, ctx, cipher->encrypt, authdata->length, authdata->data);\n  }\n  ccm_decrypt(&ccm, ctx, cipher->encrypt, cleartext->length, de_data, ciphertext->data);\n  ccm_digest(&ccm, ctx, cipher->encrypt, tlength, de_digest);\n\n  /* Compare results using the generic API. */\n  test_compare_results(\"CCM\", authdata,\n\t\t       cleartext, ciphertext, de_data, en_data, de_digest);\n\n  /* Ensure we get the same answers using the all-in-one API. */\n  if (repeat <= 1) {\n    int ret;\n    memset(de_data, 0, cleartext->length);\n    memset(en_data, 0, ciphertext->length);\n    memset(de_digest, 0, sizeof(de_digest));\n\n    ccm_encrypt_message(ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\t\tauthdata->length, authdata->data, tlength,\n\t\t\tciphertext->length, en_data, cleartext->data);\n\n    ret = ccm_decrypt_message(ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\t\t      authdata->length, authdata->data, tlength,\n\t\t\t      cleartext->length, de_data, ciphertext->data);\n\n    if (ret != 1) fprintf(stderr, \"ccm_decrypt_message failed to validate message\\n\");\n    test_compare_results(\"CCM_MSG\", authdata,\n\t\t\t cleartext, ciphertext, de_data, en_data, NULL);\n\n    /* Ensure that we can detect corrupted message or tag data. */\n    if (tlength) {\n      en_data[0] ^= 1;\n      ret = ccm_decrypt_message(ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\t\t\tauthdata->length, authdata->data, tlength,\n\t\t\t\tcleartext->length, de_data, en_data);\n      if (ret != 0) fprintf(stderr, \"ccm_decrypt_message failed to detect corrupted message\\n\");\n    }\n    /* Ensure we can detect corrupted adata. */\n    if (tlength && authdata->length) {\n      ret = ccm_decrypt_message(ctx, cipher->encrypt, nonce->length, nonce->data,\n\t\t\t\tauthdata->length-1, authdata->data, tlength,\n\t\t\t\tcleartext->length, de_data, ciphertext->data);\n      if (ret != 0) fprintf(stderr, \"ccm_decrypt_message failed to detect corrupted message\\n\");\n    }\n  }\n\n  /* Ensure we get the same answers using the per-cipher API. */\n  if (cipher == &nettle_aes128) {\n    struct ccm_aes128_ctx aes;\n    memset(de_data, 0, cleartext->length);\n    memset(en_data, 0, ciphertext->length);\n    memset(de_digest, 0, sizeof(de_digest));\n\n    /* AES-128 encrypt. */\n    ccm_aes128_set_key(&aes, key->data);\n    ccm_aes128_set_nonce(&aes, nonce->length, nonce->data,\n\t\t\t authdata->length * repeat, cleartext->length, tlength);\n    for (i = 0; i < repeat; i++) {\n      ccm_aes128_update(&aes, authdata->length, authdata->data);\n    }\n    ccm_aes128_encrypt(&aes, cleartext->length, en_data, cleartext->data);\n    ccm_aes128_digest(&aes, tlength, en_digest);\n\n    /* AES-128 decrypt. */\n    ccm_aes128_set_nonce(&aes, nonce->length, nonce->data,\n\t\t\t authdata->length * repeat, cleartext->length, tlength);\n    for (i = 0; i < repeat; i++) {\n      ccm_aes128_update(&aes, authdata->length, authdata->data);\n    }\n    ccm_aes128_decrypt(&aes, cleartext->length, de_data, ciphertext->data);\n    ccm_aes128_digest(&aes, tlength, de_digest);\n\n    test_compare_results(\"CCM_AES_128\", authdata,\n\t\t\t cleartext, ciphertext, de_data, en_data, de_digest);\n  }\n  /* TODO: I couldn't find any test cases for CCM-AES-192 */\n  if (cipher == &nettle_aes256) {\n    struct ccm_aes256_ctx aes;\n    memset(de_data, 0, cleartext->length);\n    memset(en_data, 0, ciphertext->length);\n    memset(de_digest, 0, sizeof(de_digest));\n\n    /* AES-256 encrypt. */\n    ccm_aes256_set_key(&aes, key->data);\n    ccm_aes256_set_nonce(&aes, nonce->length, nonce->data,\n\t\t\t authdata->length * repeat, cleartext->length, tlength);\n    for (i = 0; i < repeat; i++) {\n      ccm_aes256_update(&aes, authdata->length, authdata->data);\n    }\n    ccm_aes256_encrypt(&aes, cleartext->length, en_data, cleartext->data);\n    ccm_aes256_digest(&aes, tlength, en_digest);\n\n    /* AES-256 decrypt. */\n    ccm_aes256_set_nonce(&aes, nonce->length, nonce->data,\n\t\t\t authdata->length * repeat, cleartext->length, tlength);\n    for (i = 0; i < repeat; i++) {\n      ccm_aes256_update(&aes, authdata->length, authdata->data);\n    }\n    ccm_aes256_decrypt(&aes, cleartext->length, de_data, ciphertext->data);\n    ccm_aes256_digest(&aes, tlength, de_digest);\n\n    test_compare_results(\"CCM_AES_256\", authdata,\n\t\t\t cleartext, ciphertext, de_data, en_data, de_digest);\n  }\n\n  free(ctx);\n  free(en_data);\n  free(de_data);\n}",
      "lines": 149,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        250,
        0
      ],
      "end_point": [
        727,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Create a pattern of 00010203 04050607 08090a00b 0c0d0e0f ... */\n  struct tstring *adata;\n  unsigned int i;\n  adata = tstring_alloc(256);\n  for (i=0; i<adata->length; i++) adata->data[i] = (i & 0xff);\n\n  /* From NIST spec 800-38C on AES modes.\n   *\n   * Appendix C: Example Vectors\n   */\n  /*\n   * C.1 Example 1\n   * Klen = 128, Tlen = 32, Nlen = 56, Alen = 64, Plen = 32\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f\"),\n\t\t  SHEX(\"10111213141516\"),\n\t\t  SHEX(\"0001020304050607\"), 1,\n\t\t  SHEX(\"20212223\"),\n\t\t  SHEX(\"7162015b\"\n\t\t       \"4dac255d\"));\n\n  /*\n   * C.2 Example 2\n   * Klen = 128, Tlen = 48, Nlen = 64, Alen = 128, Plen = 128\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f\"),\n\t\t  SHEX(\"1011121314151617\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"), 1,\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f\"),\n\t\t  SHEX(\"d2a1f0e051ea5f62081a7792073d593d\"\n\t\t       \"1fc64fbfaccd\"));\n\n  /*\n   * C.3 Example 3\n   * Klen = 128, Tlen = 64, Nlen = 96, Alen = 160, Plen = 192\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f\"),\n\t\t  SHEX(\"101112131415161718191a1b\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"\n\t\t       \"10111213\"), 1,\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f\"\n\t\t       \"3031323334353637\"),\n\t\t  SHEX(\"e3b201a9f5b71a7a9b1ceaeccd97e70b\"\n\t\t       \"6176aad9a4428aa5 484392fbc1b09951\"));\n\n  /*\n   * C.4 Example 4\n   * Klen = 128, Tlen = 112, Nlen = 104, Alen = 524288, Plen = 256\n   * A = 00010203 04050607 08090a0b 0c0d0e0f\n   *     10111213 ...\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f\"),\n\t\t  SHEX(\"101112131415161718191a1b1c\"),\n\t\t  adata, 256,\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f\"\n\t\t       \"303132333435363738393a3b3c3d3e3f\"),\n\t\t  SHEX(\"69915dad1e84c6376a68c2967e4dab61\"\n\t\t       \"5ae0fd1faec44cc484828529463ccf72\"\n\t\t       \"b4ac6bec93e8598e7f0dadbcea5b\"));\n\n  /* From RFC 3610\n   *\n   * Section 8: Test Vectors\n   * Packet Vector #1\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 03  02 01 00 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E\"),\n\t\t  SHEX(\"58 8C 97 9A  61 C6 63 D2  F0 66 D0 C2  C0 F9 89 80  6D 5F 6B 61  DA C3 84\"\n\t\t       \"17 E8 D1 2C  FD F9 26 E0\"));\n\n  /*\n   * Packet Vector #2\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 04  03 02 01 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F\"),\n\t\t  SHEX(\"72 C9 1A 36  E1 35 F8 CF  29 1C A8 94  08 5C 87 E3  CC 15 C4 39  C9 E4 3A 3B\"\n\t\t       \"A0 91 D5 6E  10 40 09 16\"));\n\n  /*\n   * Packet Vector #3\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 05  04 03 02 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20\"),\n\t\t  SHEX(\"51 B1 E5 F4  4A 19 7D 1D  A4 6B 0F 8E  2D 28 2A E8  71 E8 38 BB  64 DA 85 96  57\"\n\t\t       \"4A DA A7 6F  BD 9F B0 C5\"));\n\n  /*\n   * Packet Vector #4\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 06  05 04 03 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E\"),\n\t\t  SHEX(\"A2 8C 68 65  93 9A 9A 79  FA AA 5C 4C  2A 9D 4A 91  CD AC 8C\"\n\t\t       \"96 C8 61 B9  C9 E6 1E F1\"));\n\n  /*\n   * Packet Vector #5\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 07  06 05 04 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F\"),\n\t\t  SHEX(\"DC F1 FB 7B  5D 9E 23 FB  9D 4E 13 12  53 65 8A D8  6E BD CA 3E\"\n\t\t       \"51 E8 3F 07  7D 9C 2D 93\"));\n\n  /*\n   * Packet Vector #6\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 08  07 06 05 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20\"),\n\t\t  SHEX(\"6F C1 B0 11  F0 06 56 8B  51 71 A4 2D  95 3D 46 9B  25 70 A4 BD  87\"\n\t\t       \"40 5A 04 43  AC 91 CB 94\"));\n\n  /*\n   * Packet Vector #7\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 09  08 07 06 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E\"),\n\t\t  SHEX(\"01 35 D1 B2  C9 5F 41 D5  D1 D4 FE C1  85 D1 66 B8  09 4E 99 9D  FE D9 6C\"\n\t\t       \"04 8C 56 60  2C 97 AC BB  74 90\"));\n\n  /*\n   * Packet Vector #8\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 0A  09 08 07 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F\"),\n\t\t  SHEX(\"7B 75 39 9A  C0 83 1D D2  F0 BB D7 58  79 A2 FD 8F  6C AE 6B 6C  D9 B7 DB 24\"\n\t\t       \"C1 7B 44 33  F4 34 96 3F  34 B4\"));\n\n  /*\n   * Packet Vector #9\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 0B  0A 09 08 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07\"), 1,\n\t\t  SHEX(\"08 09 0A 0B  0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20\"),\n\t\t  SHEX(\"82 53 1A 60  CC 24 94 5A  4B 82 79 18  1A B5 C8 4D  F2 1C E7 F9  B7 3F 42 E1  97\"\n\t\t       \"EA 9C 07 E5  6B 5E B1 7E  5F 4E\"));\n\n  /*\n   * Packet Vector #10\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 0C  0B 0A 09 A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E\"),\n\t\t  SHEX(\"07 34 25 94  15 77 85 15  2B 07 40 98  33 0A BB 14  1B 94 7B\"\n\t\t       \"56 6A A9 40  6B 4D 99 99  88 DD\"));\n\n  /*\n   * Packet Vector #11\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 0D  0C 0B 0A A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F\"),\n\t\t  SHEX(\"67 6B B2 03  80 B0 E3 01  E8 AB 79 59  0A 39 6D A7  8B 83 49 34\"\n\t\t       \"F5 3A A2 E9  10 7A 8B 6C  02 2C\"));\n\n  /*\n   * Packet Vector #12\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3  C4 C5 C6 C7  C8 C9 CA CB  CC CD CE CF\"),\n\t\t  SHEX(\"00 00 00 0E  0D 0C 0B A0  A1 A2 A3 A4  A5\"),\n\t\t  SHEX(\"00 01 02 03  04 05 06 07  08 09 0A 0B\"), 1,\n\t\t  SHEX(\"0C 0D 0E 0F  10 11 12 13  14 15 16 17  18 19 1A 1B  1C 1D 1E 1F  20\"),\n\t\t  SHEX(\"C0 FF A0 D6  F0 5B DB 67  F2 4D 43 A4  33 8D 2A A4  BE D7 B2 0E  43\"\n\t\t       \"CD 1A A3 16  62 E7 AD 65  D6 DB\"));\n\n  /*\n   * Packet Vector #13\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 41 2B 4E  A9 CD BE 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"0B E1 A8 8B  AC E0 18 B1\"), 1,\n\t\t  SHEX(\"08 E8 CF 97  D8 20 EA 25  84 60 E9 6A  D9 CF 52 89  05 4D 89 5C  EA C4 7C\"),\n\t\t  SHEX(\"4C B9 7F 86  A2 A4 68 9A  87 79 47 AB  80 91 EF 53  86 A6 FF BD  D0 80 F8\"\n\t\t       \"E7 8C F7 CB  0C DD D7 B3\"));\n\n  /*\n   * Packet Vector #14\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 33 56 8E  F7 B2 63 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"63 01 8F 76  DC 8A 1B CB\"), 1,\n\t\t  SHEX(\"90 20 EA 6F  91 BD D8 5A  FA 00 39 BA  4B AF F9 BF  B7 9C 70 28  94 9C D0 EC\"),\n\t\t  SHEX(\"4C CB 1E 7C  A9 81 BE FA  A0 72 6C 55  D3 78 06 12  98 C8 5C 92  81 4A BC 33\"\n\t\t       \"C5 2E E8 1D  7D 77 C0 8A\"));\n\n  /*\n   * Packet Vector #15\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 10 3F E4  13 36 71 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"AA 6C FA 36  CA E8 6B 40\"), 1,\n\t\t  SHEX(\"B9 16 E0 EA  CC 1C 00 D7  DC EC 68 EC  0B 3B BB 1A  02 DE 8A 2D  1A A3 46 13  2E\"),\n\t\t  SHEX(\"B1 D2 3A 22  20 DD C0 AC  90 0D 9A A0  3C 61 FC F4  A5 59 A4 41  77 67 08 97  08\"\n\t\t       \"A7 76 79 6E  DB 72 35 06\"));\n\n  /*\n   * Packet Vector #16\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 76 4C 63  B8 05 8E 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"D0 D0 73 5C  53 1E 1B EC  F0 49 C2 44\"), 1,\n\t\t  SHEX(\"12 DA AC 56  30 EF A5 39  6F 77 0C E1  A6 6B 21 F7  B2 10 1C\"),\n\t\t  SHEX(\"14 D2 53 C3  96 7B 70 60  9B 7C BB 7C  49 91 60 28  32 45 26\"\n\t\t       \"9A 6F 49 97  5B CA DE AF\"));\n\n  /*\n   * Packet Vector #17\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 F8 B6 78  09 4E 3B 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"77 B6 0F 01  1C 03 E1 52  58 99 BC AE\"), 1,\n\t\t  SHEX(\"E8 8B 6A 46  C7 8D 63 E5  2E B8 C5 46  EF B5 DE 6F  75 E9 CC 0D\"),\n\t\t  SHEX(\"55 45 FF 1A  08 5E E2 EF  BF 52 B2 E0  4B EE 1E 23  36 C7 3E 3F\"\n\t\t       \"76 2C 0C 77  44 FE 7E 3C\"));\n\n  /*\n   * Packet Vector #18\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 D5 60 91  2D 3F 70 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"CD 90 44 D2  B7 1F DB 81  20 EA 60 C0\"), 1,\n\t\t  SHEX(\"64 35 AC BA  FB 11 A8 2E  2F 07 1D 7C  A4 A5 EB D9  3A 80 3B A8  7F\"),\n\t\t  SHEX(\"00 97 69 EC  AB DF 48 62  55 94 C5 92  51 E6 03 57  22 67 5E 04  C8\"\n\t\t       \"47 09 9E 5A  E0 70 45 51\"));\n\n  /*\n   * Packet Vector #19\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 42 FF F8  F1 95 1C 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"D8 5B C7 E6  9F 94 4F B8\"), 1,\n\t\t  SHEX(\"8A 19 B9 50  BC F7 1A 01  8E 5E 67 01  C9 17 87 65  98 09 D6 7D  BE DD 18\"),\n\t\t  SHEX(\"BC 21 8D AA  94 74 27 B6  DB 38 6A 99  AC 1A EF 23  AD E0 B5 29  39 CB 6A\"\n\t\t       \"63 7C F9 BE  C2 40 88 97  C6 BA\"));\n\n  /*\n   * Packet Vector #20\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 92 0F 40  E5 6C DC 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"74 A0 EB C9  06 9F 5B 37\"), 1,\n\t\t  SHEX(\"17 61 43 3C  37 C5 A3 5F  C1 F3 9F 40  63 02 EB 90  7C 61 63 BE  38 C9 84 37\"),\n\t\t  SHEX(\"58 10 E6 FD  25 87 40 22  E8 03 61 A4  78 E3 E9 CF  48 4A B0 4F  44 7E FF F6\"\n\t\t       \"F0 A4 77 CC  2F C9 BF 54  89 44\"));\n\n  /*\n   * Packet Vector #21\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 27 CA 0C  71 20 BC 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"44 A3 AA 3A  AE 64 75 CA\"), 1,\n\t\t  SHEX(\"A4 34 A8 E5  85 00 C6 E4  15 30 53 88  62 D6 86 EA  9E 81 30 1B  5A E4 22 6B  FA\"),\n\t\t  SHEX(\"F2 BE ED 7B  C5 09 8E 83  FE B5 B3 16  08 F8 E2 9C  38 81 9A 89  C8 E7 76 F1  54\"\n\t\t       \"4D 41 51 A4  ED 3A 8B 87  B9 CE\"));\n\n  /*\n   * Packet Vector #22\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 5B 8C CB  CD 9A F8 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"EC 46 BB 63  B0 25 20 C3  3C 49 FD 70\"), 1,\n\t\t  SHEX(\"B9 6B 49 E2  1D 62 17 41  63 28 75 DB  7F 6C 92 43  D2 D7 C2\"),\n\t\t  SHEX(\"31 D7 50 A0  9D A3 ED 7F  DD D4 9A 20  32 AA BF 17  EC 8E BF\"\n\t\t       \"7D 22 C8 08  8C 66 6B E5  C1 97\"));\n\n  /*\n   * Packet Vector #23\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 3E BE 94  04 4B 9A 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"47 A6 5A C7  8B 3D 59 42  27 E8 5E 71\"), 1,\n\t\t  SHEX(\"E2 FC FB B8 80 44 2C 73  1B F9 51 67  C8 FF D7 89  5E 33 70 76\"),\n\t\t  SHEX(\"E8 82 F1 DB D3 8C E3 ED  A7 C2 3F 04  DD 65 07 1E  B4 13 42 AC\"\n\t\t       \"DF 7E 00 DC  CE C7 AE 52  98 7D\"));\n\n  /*\n   * Packet Vector #24\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"D7 82 8D 13  B2 B0 BD C3  25 A7 62 36  DF 93 CC 6B\"),\n\t\t  SHEX(\"00 8D 49 3B  30 AE 8B 3C  96 96 76 6C  FA\"),\n\t\t  SHEX(\"6E 37 A6 EF  54 6D 95 5D  34 AB 60 59\"), 1,\n\t\t  SHEX(\"AB F2 1C 0B  02 FE B8 8F  85 6D F4 A3  73 81 BC E3  CC 12 85 17  D4\"),\n\t\t  SHEX(\"F3 29 05 B8  8A 64 1B 04  B9 C9 FF B5  8C C3 90 90  0F 3D A1 2A  B1\"\n\t\t       \"6D CE 9E 82  EF A1 6D A6  20 59\"));\n\n  /* From IEEE 802.15.4-2011\n   *\n   * Annex C: Test vectors for cryptographic building blocks\n   * C.2.1  MAC beacon frame\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF\"),\n\t\t  SHEX(\"AC DE 48 00 00 00 00 01 00 00 00 05 02\"),\n\t\t  SHEX(\"08 D0 84 21 43 01 00 00 00 00 48 DE AC 02 05 00 00 00 55 CF 00 00 51 52 53 54\"), 1,\n\t\t  SHEX(\"\"),\n\t\t  SHEX(\"22 3B C1 EC 84 1A B5 53\"));\n\n  /*\n   * C.2.2 MAC data frame\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF\"),\n\t\t  SHEX(\"AC DE 48 00 00 00 00 01 00 00 00 05 04\"),\n\t\t  SHEX(\"69 DC 84 21 43 02 00 00 00 00 48 DE AC 01 00 00 00 00 48 DE AC 04 05 00 00 00\"), 1,\n\t\t  SHEX(\"61 62 63 64\"),\n\t\t  SHEX(\"D4 3E 02 2B\"));\n\n  /*\n   * C.2.3 MAC command frame\n   */\n  test_cipher_ccm(&nettle_aes128,\n\t\t  SHEX(\"C0 C1 C2 C3 C4 C5 C6 C7 C8 C9 CA CB CC CD CE CF\"),\n\t\t  SHEX(\"AC DE 48 00 00 00 00 01 00 00 00 05 06\"),\n\t\t  SHEX(\"2B DC 84 21 43 02 00 0000 00 48 DE AC FF FF 01 00 00 00 00 48 DE AC 06 05 00 00 00 01\"), 1,\n\t\t  SHEX(\"CE\"),\n\t\t  SHEX(\"D8 4F DE 52 90 61 F9 C6 F1\"));\n\n  /* From IEEE P1619.1/D22 July 2007 (draft version)\n   *\n   * Annex D: Test Vectors\n   * D.2.1 CCM-128-AES-256 test vector 1\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n\t\t  SHEX(\"000000000000000000000000\"),\n\t\t  SHEX(\"\"), 0,\n\t\t  SHEX(\"00000000000000000000000000000000\"),\n\t\t  SHEX(\"c1944044c8e7aa95d2de9513c7f3dd8c\"\n\t\t       \"4b0a3e5e51f151eb0ffae7c43d010fdb\"));\n\n  /*\n   * D.2.2 CCM-128-AES-256 test vector 2\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n\t\t  SHEX(\"000000000000000000000000\"),\n\t\t  SHEX(\"00000000000000000000000000000000\"), 1,\n\t\t  SHEX(\"\"),\n\t\t  SHEX(\"904704e89fb216443cb9d584911fc3c2\"));\n\n  /*\n   * D.2.3 CCM-128-AES-256 test vector 3\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"0000000000000000000000000000000000000000000000000000000000000000\"),\n\t\t  SHEX(\"000000000000000000000000\"),\n\t\t  SHEX(\"00000000000000000000000000000000\"), 1,\n\t\t  SHEX(\"00000000000000000000000000000000\"),\n\t\t  SHEX(\"c1944044c8e7aa95d2de9513c7f3dd8c\"\n\t\t       \"87314e9c1fa01abe6a6415943dc38521\"));\n\n  /*\n   * D.2.4 CCM-128-AES-256 test vector 4\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"fb7615b23d80891dd470980bc79584c8b2fb64ce60978f4d17fce45a49e830b7\"),\n\t\t  SHEX(\"dbd1a3636024b7b402da7d6f\"),\n\t\t  SHEX(\"\"), 0,\n\t\t  SHEX(\"a845348ec8c5b5f126f50e76fefd1b1e\"),\n\t\t  SHEX(\"cc881261c6a7fa72b96a1739176b277f\"\n\t\t       \"3472e1145f2c0cbe146349062cf0e423\"));\n\n  /*\n   * D.2.5 CCM-128-AES-256 test vector 5\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f\"),\n\t\t  SHEX(\"101112131415161718191a1b\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f10111213\"), 1,\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f3031323334353637\"),\n\t\t  SHEX(\"04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e5\"\n\t\t       \"9bba3f3a107f3239bd63902923f80371\"));\n\n  /*\n   * D.2.6 CCM-128-AES-256 test vector 6\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f\"),\n\t\t  SHEX(\"101112131415161718191a1b\"),\n\t\t  adata, 256,\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"),\n\t\t  SHEX(\"04f883aeb3bd0730eaf50bb6de4fa2212034e4e41b0e75e577f6bf2422c0f6d2\"\n\t\t       \"3376d2cf256ef613c56454cbb5265834\"));\n\n  /*\n   * D.2.7 CCM-128-AES-256 test vector 7\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f\"),\n\t\t  SHEX(\"101112131415161718191a1b\"),\n\t\t  SHEX(\"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"), 1,\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\"\n\t\t       \"202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f\"\n\t\t       \"404142434445464748494a4b4c4d4e4f505152535455565758595a5b5c5d5e5f\"\n\t\t       \"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f\"\n\t\t       \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\"\n\t\t       \"a0a1a2a3a4a5a6a7a8a9aaabacadaeafb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\"\n\t\t       \"c0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\"\n\t\t       \"e0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n\t\t  SHEX(\"24d8a38e939d2710cad52b96fe6f82010014c4c43b2e55c557d69f0402e0d6f2\"\n\t\t       \"06c53d6cbd3f1c3c6de5dcdcad9fb74f25741dea741149fe4278a0cc24741e86\"\n\t\t       \"58cc0523b8d7838c60fb1de4b7c3941f5b26dea9322aa29656ec37ac18a9b108\"\n\t\t       \"a6f38b7917f5a9c398838b22afbd17252e96694a9e6237964a0eae21c0a6e152\"\n\t\t       \"15a0e82022926be97268249599e456e05029c3ebc07d78fc5b4a0862e04e68c2\"\n\t\t       \"9514c7bdafc4b52e04833bf30622e4eb42504a44a9dcbc774752de7bb82891ad\"\n\t\t       \"1eba9dc3281422a8aba8654268d3d9c81705f4c5a531ef856df5609a159af738\"\n\t\t       \"eb753423ed2001b8f20c23725f2bef18c409f7e52132341f27cb8f0e79894dd9\"\n\t\t       \"ebb1fa9d28ccfe21bdfea7e6d91e0bab\"));\n\n  /*\n   * D.2.8 CCM-128-AES-256 test vector 8\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"fb7615b23d80891dd470980bc79584c8b2fb64ce6097878d17fce45a49e830b7\"),\n\t\t  SHEX(\"dbd1a3636024b7b402da7d6f\"),\n\t\t  SHEX(\"36\"), 1,\n\t\t  SHEX(\"a9\"),\n\t\t  SHEX(\"9d3261b1cf931431e99a32806738ecbd2a\"));\n\n  /*\n   * D.2.9 CCM-128-AES-256 test vector 9\n   */\n  test_cipher_ccm(&nettle_aes256,\n\t\t  SHEX(\"f8d476cfd646ea6c2384cb1c27d6195dfef1a9f37b9c8d21a79c21f8cb90d289\"),\n\t\t  SHEX(\"dbd1a3636024b7b402da7d6f\"),\n\t\t  SHEX(\"7bd859a247961a21823b380e9fe8b65082ba61d3\"), 1,\n\t\t  SHEX(\"90ae61cf7baebd4cade494c54a29ae70269aec71\"),\n\t\t  SHEX(\"6c05313e45dc8ec10bea6c670bd94f31569386a6\"\n\t\t       \"8f3829e8e76ee23c04f566189e63c686\"));\n}",
      "lines": 478,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/cfb-test.c": {
    "test_cfb_bulk": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static void\ntest_cfb_bulk(void)\n{\n  struct knuth_lfib_ctx random;\n\n  uint8_t clear[CFB_BULK_DATA];\n\n  uint8_t cipher[CFB_BULK_DATA + 1];\n\n  const uint8_t *key = H(\"966c7bf00bebe6dc 8abd37912384958a\"\n\t\t\t \"743008105a08657d dcaad4128eee38b3\");\n\n  const uint8_t *start_iv = H(\"11adbff119749103 207619cfa0e8d13a\");\n  const uint8_t *end_iv = H(\"1fd0a9189b8480b7 b06a2b36ef5943ba\");\n\n  struct CFB_CTX(struct aes_ctx, AES_BLOCK_SIZE) aes;\n\n  knuth_lfib_init(&random, CFB_BULK_DATA);\n  knuth_lfib_random(&random, CFB_BULK_DATA, clear);\n\n  /* Byte that should not be overwritten */\n  cipher[CFB_BULK_DATA] = 17;\n\n  aes_set_encrypt_key(&aes.ctx, 32, key);\n  CFB_SET_IV(&aes, start_iv);\n\n  CFB_ENCRYPT(&aes, aes_encrypt, CFB_BULK_DATA, cipher, clear);\n\n  ASSERT(cipher[CFB_BULK_DATA] == 17);\n\n  if (verbose)\n    {\n      printf(\"IV after bulk encryption: \");\n      print_hex(AES_BLOCK_SIZE, aes.iv);\n      printf(\"\\n\");\n    }\n\n  ASSERT(MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));\n\n  /* Decrypt, in place */\n  aes_set_encrypt_key(&aes.ctx, 32, key);\n  CFB_SET_IV(&aes, start_iv);\n  CFB_DECRYPT(&aes, aes_encrypt, CFB_BULK_DATA, cipher, cipher);\n\n  ASSERT(cipher[CFB_BULK_DATA] == 17);\n\n  if (verbose)\n    {\n      printf(\"IV after bulk decryption: \");\n      print_hex(AES_BLOCK_SIZE, aes.iv);\n      printf(\"\\n\");\n    }\n\n  ASSERT (MEMEQ(AES_BLOCK_SIZE, aes.iv, end_iv));\n  ASSERT (MEMEQ(CFB_BULK_DATA, clear, cipher));\n}",
      "lines": 56,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        141,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From NIST spec 800-38a on AES modes.\n   *\n   * F.3  CFB Example Vectors\n   * F.3.13 CFB128-AES128.Encrypt\n   */\n\n  /* Intermediate values, blocks input to AES:\n   *\n   *   000102030405060708090a0b0c0d0e0f\n   *   3b3fd92eb72dad20333449f8e83cfb4a\n   *   c8a64537a0b3a93fcde3cdad9f1ce58b\n   *   26751f67a3cbb140b1808cf187a4f4df\n   */\n  test_cipher_cfb(&nettle_aes128,\n\t\t  SHEX(\"2b7e151628aed2a6abf7158809cf4f3c\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"3b3fd92eb72dad20333449f8e83cfb4a\"\n\t\t       \"c8a64537a0b3a93fcde3cdad9f1ce58b\"\n\t\t       \"26751f67a3cbb140b1808cf187a4f4df\"\n\t\t       \"c04b05357c5d1c0eeac4c66f9ff7f2e6\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n\n  /* F.3.15 CFB128-AES192.Encrypt */\n\n  /* Intermediate values, blocks input to AES:\n   *\n   *   000102030405060708090a0b0c0d0e0f\n   *   cdc80d6fddf18cab34c25909c99a4174\n   *   67ce7f7f81173621961a2b70171d3d7a\n   *   2e1e8a1dd59b88b1c8e60fed1efac4c9\n   */\n\n  test_cipher_cfb(&nettle_aes192,\n\t\t  SHEX(\"8e73b0f7da0e6452c810f32b809079e5\"\n\t\t       \"62f8ead2522c6b7b\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"cdc80d6fddf18cab34c25909c99a4174\"\n\t\t       \"67ce7f7f81173621961a2b70171d3d7a\"\n\t\t       \"2e1e8a1dd59b88b1c8e60fed1efac4c9\"\n\t\t       \"c05f9f9ca9834fa042ae8fba584b09ff\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n\n  /* F.3.17 CFB128-AES256.Encrypt */\n\n  /* Intermediate values, blcoks input to AES:\n   *\n   *   000102030405060708090a0b0c0d0e0f\n   *   dc7e84bfda79164b7ecd8486985d3860\n   *   39ffed143b28b1c832113c6331e5407b\n   *   df10132415e54b92a13ed0a8267ae2f9\n   */\n\n  test_cipher_cfb(&nettle_aes256,\n\t\t  SHEX(\"603deb1015ca71be2b73aef0857d7781\"\n\t\t       \"1f352c073b6108d72d9810a30914dff4\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"dc7e84bfda79164b7ecd8486985d3860\"\n\t\t       \"39ffed143b28b1c832113c6331e5407b\"\n\t\t       \"df10132415e54b92a13ed0a8267ae2f9\"\n\t\t       \"75a385741ab9cef82031623d55b1e471\"),\n\t\t  SHEX(\"000102030405060708090a0b0c0d0e0f\"));\n\n  test_cfb_bulk();\n}",
      "lines": 76,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/chacha-poly1305-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        32,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From draft-irtf-cfrg-chacha20-poly1305-08 */\n  test_aead (&nettle_chacha_poly1305, NULL,\n\t     SHEX(\"8081828384858687 88898a8b8c8d8e8f\"\n\t\t  \"9091929394959697 98999a9b9c9d9e9f\"),\n\t     SHEX(\"50515253c0c1c2c3 c4c5c6c7\"),\n\t     SHEX(\"4c61646965732061 6e642047656e746c\"\n\t\t  \"656d656e206f6620 74686520636c6173\"\n\t\t  \"73206f6620273939 3a20496620492063\"\n\t\t  \"6f756c64206f6666 657220796f75206f\"\n\t\t  \"6e6c79206f6e6520 74697020666f7220\"\n\t\t  \"7468652066757475 72652c2073756e73\"\n\t\t  \"637265656e20776f 756c642062652069\"\n\t\t  \"742e\"),\n\t     SHEX(\"d31a8d34648e60db7b86afbc53ef7ec2\"\n\t\t  \"a4aded51296e08fea9e2b5a736ee62d6\"\n\t\t  \"3dbea45e8ca9671282fafb69da92728b\"\n\t\t  \"1a71de0a9e060b2905d6a5b67ecd3b36\"\n\t\t  \"92ddbd7f2d778b8c9803aee328091b58\"\n\t\t  \"fab324e4fad675945585808b4831d7bc\"\n\t\t  \"3ff4def08e4b7a9de576d26586cec64b\"\n\t\t  \"6116\"),\n\t     /* The draft splits the nonce into a \"common part\" and an\n\t\tiv, and it seams the \"common part\" is the first 4\n\t\tbytes. */\n\t     SHEX(\"0700000040414243 44454647\"),\n\t     SHEX(\"1ae10b594f09e26a 7e902ecbd0600691\"));\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/chacha-test.c": {
    "test_chacha": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static void\ntest_chacha(const struct tstring *key, const struct tstring *nonce,\n\t    const struct tstring *expected, unsigned rounds)\n{\n  struct chacha_ctx ctx;\n\n  ASSERT (key->length == CHACHA_KEY_SIZE);\n  chacha_set_key (&ctx, key->data);\n\n  if (rounds == 20)\n    {\n      uint8_t *data = xalloc (expected->length + 2);\n      size_t length;\n      data++;\n\n      for (length = 1; length <= expected->length; length++)\n\t{\n\t  data[-1] = 17;\n\t  memset (data, 0, length);\n\t  data[length] = 17;\n\t  if (nonce->length == CHACHA_NONCE_SIZE)\n\t    chacha_set_nonce(&ctx, nonce->data);\n\t  else if (nonce->length == CHACHA_NONCE96_SIZE)\n\t    {\n\t      chacha_set_nonce96(&ctx, nonce->data);\n\t      /* Use initial counter 1, for\n\t\t draft-irtf-cfrg-chacha20-poly1305-08 test cases. */\n\t      ctx.state[12]++;\n\t    }\n\t  else\n\t    die (\"Bad nonce size %u.\\n\", (unsigned) nonce->length);\n\n\t  chacha_crypt (&ctx, length, data, data);\n\n\t  ASSERT (data[-1] == 17);\n\t  ASSERT (data[length] == 17);\n\t  if (!MEMEQ(length, data, expected->data))\n\t    {\n\t      printf(\"Error, length %u, expected:\\n\", (unsigned) length);\n\t      print_hex (length, expected->data);\n\t      printf(\"Got:\\n\");\n\t      print_hex(length, data);\n\t      FAIL ();\n\t    }\n\t}\n      if (verbose)\n\t{\n\t  printf(\"Result after encryption:\\n\");\n\t  print_hex(expected->length, data);\n\t}\n      free (data - 1);\n    }\n  else\n    {\n      /* Uses the _chacha_core function to be able to test different\n\t numbers of rounds. */\n      uint32_t out[_CHACHA_STATE_LENGTH];\n      ASSERT (expected->length == CHACHA_BLOCK_SIZE);\n      ASSERT (nonce->length == CHACHA_NONCE_SIZE);\n\n      chacha_set_nonce(&ctx, nonce->data);\n      _chacha_core (out, ctx.state, rounds);\n\n      if (!MEMEQ(CHACHA_BLOCK_SIZE, out, expected->data))\n\t{\n\t  printf(\"Error, expected:\\n\");\n\t  tstring_print_hex (expected);\n\t  printf(\"Got:\\n\");\n\t  print_hex(CHACHA_BLOCK_SIZE, (uint8_t *) out);\n\t  FAIL ();\n\t}\n\n      if (verbose)\n\t{\n\t  printf(\"Result after encryption:\\n\");\n\t  print_hex(CHACHA_BLOCK_SIZE, (uint8_t *) out);\n\t}\n    }\n}",
      "lines": 79,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        645,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Test vectors from draft-strombergson-chacha-test-vectors */\n#if 0\n  /* TC1: All zero key and IV. 128 bit key and 8 rounds. */\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"e28a5fa4a67f8c5d efed3e6fb7303486\"\n\t\t    \"aa8427d31419a729 572d777953491120\"\n\t\t    \"b64ab8e72b8deb85 cd6aea7cb6089a10\"\n\t\t    \"1824beeb08814a42 8aab1fa2c816081b\"),\n\t       8);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"e1047ba9476bf8ff 312c01b4345a7d8c\"\n\t\t    \"a5792b0ad467313f 1dc412b5fdce3241\"\n\t\t    \"0dea8b68bd774c36 a920f092a04d3f95\"\n\t\t    \"274fbeff97bc8491 fcef37f85970b450\"),\n\t       12);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"89670952608364fd 00b2f90936f031c8\"\n\t\t    \"e756e15dba04b849 3d00429259b20f46\"\n\t\t    \"cc04f111246b6c2c e066be3bfb32d9aa\"\n\t\t    \"0fddfbc12123d4b9 e44f34dca05a103f\"\n\n\t\t    \"6cd135c2878c832b 5896b134f6142a9d\"\n\t\t    \"4d8d0d8f1026d20a 0a81512cbce6e975\"\n\t\t    \"8a7143d021978022 a384141a80cea306\"\n\t\t    \"2f41f67a752e66ad 3411984c787e30ad\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"3e00ef2f895f40d6 7f5bb8e81f09a5a1\"\n\t\t    \"2c840ec3ce9a7f3b 181be188ef711a1e\"\n\t\t    \"984ce172b9216f41 9f445367456d5619\"\n\t\t    \"314a42a3da86b001 387bfdb80e0cfe42\"\n\n\t\t    /* \"d2aefa0deaa5c151 bf0adb6c01f2a5ad\"\n\t\t    \"c0fd581259f9a2aa dcf20f8fd566a26b\"\n\t\t    \"5032ec38bbc5da98 ee0c6f568b872a65\"\n\t\t    \"a08abf251deb21bb 4b56e5d8821e68aa\" */),\n\t       8);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"9bf49a6a0755f953 811fce125f2683d5\"\n\t\t    \"0429c3bb49e07414 7e0089a52eae155f\"\n\t\t    \"0564f879d27ae3c0 2ce82834acfa8c79\"\n\t\t    \"3a629f2ca0de6919 610be82f411326be\"\n\n\t\t    /* \"0bd58841203e74fe 86fc71338ce0173d\"\n\t\t    \"c628ebb719bdcbcc 151585214cc089b4\"\n\t\t    \"42258dcda14cf111 c602b8971b8cc843\"\n\t\t    \"e91e46ca905151c0 2744a6b017e69316\" */),\n\t       12);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"76b8e0ada0f13d90 405d6ae55386bd28\"\n\t\t    \"bdd219b8a08ded1a a836efcc8b770dc7\"\n\t\t    \"da41597c5157488d 7724e03fb8d84a37\"\n\t\t    \"6a43b8f41518a11c c387b669b2ee6586\"\n\n\t\t    \"9f07e7be5551387a 98ba977c732d080d\"\n\t\t    \"cb0f29a048e36569 12c6533e32ee7aed\"\n\t\t    \"29b721769ce64e43 d57133b074d839d5\"\n\t\t    \"31ed1f28510afb45 ace10a1f4b794d6f\"),\n\t       20);\n\n  /* TC2: Single bit in key set. All zero IV */\n#if 0\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"03a7669888605a07 65e8357475e58673\"\n\t\t    \"f94fc8161da76c2a 3aa2f3caf9fe5449\"\n\t\t    \"e0fcf38eb882656a f83d430d410927d5\"\n\t\t    \"5c972ac4c92ab9da 3713e19f761eaa14\"),\n\t       8);\n\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"2a865a3b8999fa83 ae8aacf33fc6be4f\"\n\t\t    \"32c8aa9762738d26 963270052f4eef8b\"\n\t\t    \"86af758f7867560a f6d0eeb973b5542b\"\n\t\t    \"b24c8abceac8b1f3 6d026963d6c8a9b2\"),\n\t       12);\n\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"ae56060d04f5b597 897ff2af1388dbce\"\n\t\t    \"ff5a2a4920335dc1 7a3cb1b1b10fbe70\"\n\t\t    \"ece8f4864d8c7cdf 0076453a8291c7db\"\n\t\t    \"eb3aa9c9d10e8ca3 6be4449376ed7c42\"\n\n\t\t    \"fc3d471c34a36fbb f616bc0a0e7c5230\"\n\t\t    \"30d944f43ec3e78d d6a12466547cb4f7\"\n\t\t    \"b3cebd0a5005e762 e562d1375b7ac445\"\n\t\t    \"93a991b85d1a60fb a2035dfaa2a642d5\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"cf5ee9a0494aa961 3e05d5ed725b804b\"\n\t\t    \"12f4a465ee635acc 3a311de8740489ea\"\n\t\t    \"289d04f43c7518db 56eb4433e498a123\"\n\t\t    \"8cd8464d3763ddbb 9222ee3bd8fae3c8\"),\n\t       8);\n\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"12056e595d56b0f6 eef090f0cd25a209\"\n\t\t    \"49248c2790525d0f 930218ff0b4ddd10\"\n\t\t    \"a6002239d9a454e2 9e107a7d06fefdfe\"\n\t\t    \"f0210feba044f9f2 9b1772c960dc29c0\"),\n\t       12);\n\n  test_chacha (SHEX(\"0100000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0000000000000000\"),\n\t       SHEX(\"c5d30a7ce1ec1193 78c84f487d775a85\"\n\t\t    \"42f13ece238a9455 e8229e888de85bbd\"\n\t\t    \"29eb63d0a17a5b99 9b52da22be4023eb\"\n\t\t    \"07620a54f6fa6ad8 737b71eb0464dac0\"\n\n\t\t    \"10f656e6d1fd5505 3e50c4875c9930a3\"\n\t\t    \"3f6d0263bd14dfd6 ab8c70521c19338b\"\n\t\t    \"2308b95cf8d0bb7d 202d2102780ea352\"\n\t\t    \"8f1cb48560f76b20 f382b942500fceac\"),\n\t       20);\n\n  /* TC3: Single bit in IV set. All zero key */\n#if 0\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"25f5bec6683916ff 44bccd12d102e692\"\n\t\t    \"176663f4cac53e71 9509ca74b6b2eec8\"\n\t\t    \"5da4236fb2990201 2adc8f0d86c8187d\"\n\t\t    \"25cd1c486966930d 0204c4ee88a6ab35\"),\n\t       8);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"91cdb2f180bc89cf e86b8b6871cd6b3a\"\n\t\t    \"f61abf6eba01635d b619c40a0b2e19ed\"\n\t\t    \"fa8ce5a9bd7f53cc 2c9bcfea181e9754\"\n\t\t    \"a9e245731f658cc2 82c2ae1cab1ae02c\"),\n\t       12);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"1663879eb3f2c994 9e2388caa343d361\"\n\t\t    \"bb132771245ae6d0 27ca9cb010dc1fa7\"\n\t\t    \"178dc41f8278bc1f 64b3f12769a24097\"\n\t\t    \"f40d63a86366bdb3 6ac08abe60c07fe8\"\n\n\t\t    \"b057375c89144408 cc744624f69f7f4c\"\n\t\t    \"cbd93366c92fc4df cada65f1b959d8c6\"\n\t\t    \"4dfc50de711fb464 16c2553cc60f21bb\"\n\t\t    \"fd006491cb17888b 4fb3521c4fdd8745\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"2b8f4bb3798306ca 5130d47c4f8d4ed1\"\n\t\t    \"3aa0edccc1be6942 090faeeca0d7599b\"\n\t\t    \"7ff0fe616bb25aa0 153ad6fdc88b9549\"\n\t\t    \"03c22426d478b97b 22b8f9b1db00cf06\"),\n\t       8);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"64b8bdf87b828c4b 6dbaf7ef698de03d\"\n\t\t    \"f8b33f635714418f 9836ade59be12969\"\n\t\t    \"46c953a0f38ecffc 9ecb98e81d5d99a5\"\n\t\t    \"edfc8f9a0a45b9e4 1ef3b31f028f1d0f\"),\n\t       12);\n\n  test_chacha (SHEX(\"0000000000000000 0000000000000000\"\n\t\t    \"0000000000000000 0000000000000000\"),\n\t       SHEX(\"0100000000000000\"),\n\t       SHEX(\"ef3fdfd6c61578fb f5cf35bd3dd33b80\"\n\t\t    \"09631634d21e42ac 33960bd138e50d32\"\n\t\t    \"111e4caf237ee53c a8ad6426194a8854\"\n\t\t    \"5ddc497a0b466e7d 6bbdb0041b2f586b\"\n\n\t\t    \"5305e5e44aff19b2 35936144675efbe4\"\n\t\t    \"409eb7e8e5f1430f 5f5836aeb49bb532\"\n\t\t    \"8b017c4b9dc11f8a 03863fa803dc71d5\"\n\t\t    \"726b2b6b31aa3270 8afe5af1d6b69058\"),\n\t       20);\n\n  /* TC4: All bits in key and IV are set. */\n#if 0\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"2204d5b81ce66219 3e00966034f91302\"\n\t\t    \"f14a3fb047f58b6e 6ef0d72113230416\"\n\t\t    \"3e0fb640d76ff9c3 b9cd99996e6e38fa\"\n\t\t    \"d13f0e31c82244d3 3abbc1b11e8bf12d\"),\n\t       8);\n\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"60e349e60c38b328 c4baab90d44a7c72\"\n\t\t    \"7662770d36350d65 a1433bd92b00ecf4\"\n\t\t    \"83d5597d7a616258 ec3c5d5b30e1c5c8\"\n\t\t    \"5c5dfe2f92423b8e 36870f3185b6add9\"),\n\t       12);\n\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"992947c3966126a0 e660a3e95db048de\"\n\t\t    \"091fb9e0185b1e41 e41015bb7ee50150\"\n\t\t    \"399e4760b262f9d5 3f26d8dd19e56f5c\"\n\t\t    \"506ae0c3619fa67f b0c408106d0203ee\"\n\n\t\t    \"40ea3cfa61fa32a2 fda8d1238a2135d9\"\n\t\t    \"d4178775240f9900 7064a6a7f0c731b6\"\n\t\t    \"7c227c52ef796b6b ed9f9059ba0614bc\"\n\t\t    \"f6dd6e38917f3b15 0e576375be50ed67\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"\n\t\t    \"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"e163bbf8c9a739d1 8925ee8362dad2cd\"\n\t\t    \"c973df05225afb2a a26396f2a9849a4a\"\n\t\t    \"445e0547d31c1623 c537df4ba85c70a9\"\n\t\t    \"884a35bcbf3dfab0 77e98b0f68135f54\"),\n\t       8);\n\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"\n\t\t    \"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"04bf88dae8e47a22 8fa47b7e6379434b\"\n\t\t    \"a664a7d28f4dab84 e5f8b464add20c3a\"\n\t\t    \"caa69c5ab221a23a 57eb5f345c96f4d1\"\n\t\t    \"322d0a2ff7a9cd43 401cd536639a615a\"),\n\t       12);\n\n  test_chacha (SHEX(\"ffffffffffffffff ffffffffffffffff\"\n\t\t    \"ffffffffffffffff ffffffffffffffff\"),\n\t       SHEX(\"ffffffffffffffff\"),\n\t       SHEX(\"d9bf3f6bce6ed0b5 4254557767fb5744\"\n\t\t    \"3dd4778911b60605 5c39cc25e674b836\"\n\t\t    \"3feabc57fde54f79 0c52c8ae43240b79\"\n\t\t    \"d49042b777bfd6cb 80e931270b7f50eb\"\n\n\t\t    \"5bac2acd86a836c5 dc98c116c1217ec3\"\n\t\t    \"1d3a63a9451319f0 97f3b4d6dab07787\"\n\t\t    \"19477d24d24b403a 12241d7cca064f79\"\n\t\t    \"0f1d51ccaff6b166 7d4bbca1958c4306\"),\n\t       20);\n\n  /* TC5: Every even bit set in key and IV. */\n#if 0\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"f0a23bc36270e18e d0691dc384374b9b\"\n\t\t    \"2c5cb60110a03f56 fa48a9fbbad961aa\"\n\t\t    \"6bab4d892e96261b 6f1a0919514ae56f\"\n\t\t    \"86e066e17c71a417 6ac684af1c931996\"),\n\t       8);\n\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"90ec7a49ee0b20a8 08af3d463c1fac6c\"\n\t\t    \"2a7c897ce8f6e60d 793b62ddbebcf980\"\n\t\t    \"ac917f091e52952d b063b1d2b947de04\"\n\t\t    \"aac087190ca99a35 b5ea501eb535d570\"),\n\t       12);\n\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"357d7d94f966778f 5815a2051dcb0413\"\n\t\t    \"3b26b0ead9f57dd0 9927837bc3067e4b\"\n\t\t    \"6bf299ad81f7f50c 8da83c7810bfc17b\"\n\t\t    \"b6f4813ab6c32695 7045fd3fd5e19915\"\n\n\t\t    \"ec744a6b9bf8cbdc b36d8b6a5499c68a\"\n\t\t    \"08ef7be6cc1e93f2 f5bcd2cad4e47c18\"\n\t\t    \"a3e5d94b5666382c 6d130d822dd56aac\"\n\t\t    \"b0f8195278e7b292 495f09868ddf12cc\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"\n\t\t    \"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"7cb78214e4d3465b 6dc62cf7a1538c88\"\n\t\t    \"996952b4fb72cb61 05f1243ce3442e29\"\n\t\t    \"75a59ebcd2b2a598 290d7538491fe65b\"\n\t\t    \"dbfefd060d887981 20a70d049dc2677d\"),\n\t       8);\n\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"\n\t\t    \"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"a600f07727ff93f3 da00dd74cc3e8bfb\"\n\t\t    \"5ca7302f6a0a2944 953de00450eecd40\"\n\t\t    \"b860f66049f2eaed 63b2ef39cc310d2c\"\n\t\t    \"488f5d9a241b615d c0ab70f921b91b95\"),\n\t       12);\n\n  test_chacha (SHEX(\"5555555555555555 5555555555555555\"\n\t\t    \"5555555555555555 5555555555555555\"),\n\t       SHEX(\"5555555555555555\"),\n\t       SHEX(\"bea9411aa453c543 4a5ae8c92862f564\"\n\t\t    \"396855a9ea6e22d6 d3b50ae1b3663311\"\n\t\t    \"a4a3606c671d605c e16c3aece8e61ea1\"\n\t\t    \"45c59775017bee2f a6f88afc758069f7\"\n\n\t\t    \"e0b8f676e644216f 4d2a3422d7fa36c6\"\n\t\t    \"c4931aca950e9da4 2788e6d0b6d1cd83\"\n\t\t    \"8ef652e97b145b14 871eae6c6804c700\"\n\t\t    \"4db5ac2fce4c68c7 26d004b10fcaba86\"),\n\t       20);\n\n  /* TC6: Every odd bit set in key and IV. */\n#if 0\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"312d95c0bc38eff4 942db2d50bdc500a\"\n\t\t    \"30641ef7132db1a8 ae838b3bea3a7ab0\"\n\t\t    \"3815d7a4cc09dbf5 882a3433d743aced\"\n\t\t    \"48136ebab7329950 6855c0f5437a36c6\"),\n\t       8);\n\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"057fe84fead13c24 b76bb2a6fdde66f2\"\n\t\t    \"688e8eb6268275c2 2c6bcb90b85616d7\"\n\t\t    \"fe4d3193a1036b70 d7fb864f01453641\"\n\t\t    \"851029ecdb60ac38 79f56496f16213f4\"),\n\t       12);\n\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"fc79acbd58526103 862776aab20f3b7d\"\n\t\t    \"8d3149b2fab65766 299316b6e5b16684\"\n\t\t    \"de5de548c1b7d083 efd9e3052319e0c6\"\n\t\t    \"254141da04a6586d f800f64d46b01c87\"\n\n\t\t    \"1f05bc67e07628eb e6f6865a2177e0b6\"\n\t\t    \"6a558aa7cc1e8ff1 a98d27f7071f8335\"\n\t\t    \"efce4537bb0ef7b5 73b32f32765f2900\"\n\t\t    \"7da53bba62e7a44d 006f41eb28fe15d6\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t    \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"40f9ab86c8f9a1a0 cdc05a75e5531b61\"\n\t\t    \"2d71ef7f0cf9e387 df6ed6972f0aae21\"\n\t\t    \"311aa581f816c90e 8a99de990b6b95aa\"\n\t\t    \"c92450f4e1127126 67b804c99e9c6eda\"),\n\t       8);\n\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t    \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"856505b01d3b47aa e03d6a97aa0f033a\"\n\t\t    \"9adcc94377babd86 08864fb3f625b6e3\"\n\t\t    \"14f086158f9f725d 811eeb953b7f7470\"\n\t\t    \"76e4c3f639fa841f ad6c9a709e621397\"),\n\t       12);\n\n  test_chacha (SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t    \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"aaaaaaaaaaaaaaaa\"),\n\t       SHEX(\"9aa2a9f656efde5a a7591c5fed4b35ae\"\n\t\t    \"a2895dec7cb4543b 9e9f21f5e7bcbcf3\"\n\t\t    \"c43c748a970888f8 248393a09d43e0b7\"\n\t\t    \"e164bc4d0b0fb240 a2d72115c4808906\"\n\n\t\t    \"72184489440545d0 21d97ef6b693dfe5\"\n\t\t    \"b2c132d47e6f041c 9063651f96b623e6\"\n\t\t    \"2a11999a23b6f7c4 61b2153026ad5e86\"\n\t\t    \"6a2e597ed07b8401 dec63a0934c6b2a9\"),\n\t       20);\n\n  /* TC7: Sequence patterns in key and IV. */\n#if 0\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"29560d280b452840 0a8f4b795369fb3a\"\n\t\t    \"01105599e9f1ed58 279cfc9ece2dc5f9\"\n\t\t    \"9f1c2e52c98238f5 42a5c0a881d850b6\"\n\t\t    \"15d3acd9fbdb026e 9368565da50e0d49\"),\n\t       8);\n\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"5eddc2d9428fceee c50a52a964eae0ff\"\n\t\t    \"b04b2de006a9b04c ff368ffa921116b2\"\n\t\t    \"e8e264babd2efa0d e43ef2e3b6d065e8\"\n\t\t    \"f7c0a17837b0a40e b0e2c7a3742c8753\"),\n\t       12);\n\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"d1abf630467eb4f6 7f1cfb47cd626aae\"\n\t\t    \"8afedbbe4ff8fc5f e9cfae307e74ed45\"\n\t\t    \"1f1404425ad2b545 69d5f18148939971\"\n\t\t    \"abb8fafc88ce4ac7 fe1c3d1f7a1eb7ca\"\n\n\t\t    \"e76ca87b61a97135 41497760dd9ae059\"\n\t\t    \"350cad0dcedfaa80 a883119a1a6f987f\"\n\t\t    \"d1ce91fd8ee08280 34b411200a9745a2\"\n\t\t    \"85554475d12afc04 887fef3516d12a2c\"),\n\t       20);\n#endif\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"\n\t\t    \"ffeeddccbbaa9988 7766554433221100\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"db43ad9d1e842d12 72e4530e276b3f56\"\n\t\t    \"8f8859b3f7cf6d9d 2c74fa53808cb515\"\n\t\t    \"7a8ebf46ad3dcc4b 6c7dadde131784b0\"\n\t\t    \"120e0e22f6d5f9ff a7407d4a21b695d9\"),\n\t       8);\n\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"\n\t\t    \"ffeeddccbbaa9988 7766554433221100\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"7ed12a3a63912ae9 41ba6d4c0d5e862e\"\n\t\t    \"568b0e5589346935 505f064b8c2698db\"\n\t\t    \"f7d850667d8e67be 639f3b4f6a16f92e\"\n\t\t    \"65ea80f6c7429445 da1fc2c1b9365040\"),\n\t       12);\n\n  test_chacha (SHEX(\"0011223344556677 8899aabbccddeeff\"\n\t\t    \"ffeeddccbbaa9988 7766554433221100\"),\n\t       SHEX(\"0f1e2d3c4b5a6978\"),\n\t       SHEX(\"9fadf409c00811d0 0431d67efbd88fba\"\n\t\t    \"59218d5d6708b1d6 85863fabbb0e961e\"\n\t\t    \"ea480fd6fb532bfd 494b215101505742\"\n\t\t    \"3ab60a63fe4f55f7 a212e2167ccab931\"\n\n\t\t    \"fbfd29cf7bc1d279 eddf25dd316bb884\"\n\t\t    \"3d6edee0bd1ef121 d12fa17cbc2c574c\"\n\t\t    \"ccab5e275167b08b d686f8a09df87ec3\"\n\t\t    \"ffb35361b94ebfa1 3fec0e4889d18da5\"),\n\t       20);\n\n  /* TC8: hashed string patterns */\n#if 0\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"6a870108859f6791 18f3e205e2a56a68\"\n\t\t   \"26ef5a60a4102ac8 d4770059fcb7c7ba\"\n\t\t   \"e02f5ce004a6bfbb ea53014dd82107c0\"\n\t\t   \"aa1c7ce11b7d78f2 d50bd3602bbd2594\"),\n\t      8);\n\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"b02bd81eb55c8f68 b5e9ca4e307079bc\"\n\t\t   \"225bd22007eddc67 02801820709ce098\"\n\t\t   \"07046a0d2aa552bf dbb49466176d56e3\"\n\t\t   \"2d519e10f5ad5f27 46e241e09bdf9959\"),\n\t      12);\n\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"826abdd84460e2e9 349f0ef4af5b179b\"\n\t\t   \"426e4b2d109a9c5b b44000ae51bea90a\"\n\t\t   \"496beeef62a76850 ff3f0402c4ddc99f\"\n\t\t   \"6db07f151c1c0dfa c2e56565d6289625\"\n\n\t\t   \"5b23132e7b469c7b fb88fa95d44ca5ae\"\n\t\t   \"3e45e848a4108e98 bad7a9eb15512784\"\n\t\t   \"a6a9e6e591dce674 120acaf9040ff50f\"\n\t\t   \"f3ac30ccfb5e1420 4f5e4268b90a8804\"),\n\t      20);\n#endif\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"\n\t\t   \"1f68ed2e194c79fb c6aebee1a667975d\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"838751b42d8ddd8a 3d77f48825a2ba75\"\n\t\t   \"2cf4047cb308a597 8ef274973be374c9\"\n\t\t   \"6ad848065871417b 08f034e681fe46a9\"\n\t\t   \"3f7d5c61d1306614 d4aaf257a7cff08b\"),\n\t      8);\n\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"\n\t\t   \"1f68ed2e194c79fb c6aebee1a667975d\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"1482072784bc6d06 b4e73bdc118bc010\"\n\t\t   \"3c7976786ca918e0 6986aa251f7e9cc1\"\n\t\t   \"b2749a0a16ee83b4 242d2e99b08d7c20\"\n\t\t   \"092b80bc466c8728 3b61b1b39d0ffbab\"),\n\t      12);\n\n  test_chacha(SHEX(\"c46ec1b18ce8a878 725a37e780dfb735\"\n\t\t   \"1f68ed2e194c79fb c6aebee1a667975d\"),\n\t      SHEX(\"1ada31d5cf688221\"),\n\t      SHEX(\"f63a89b75c2271f9 368816542ba52f06\"\n\t\t   \"ed49241792302b00 b5e8f80ae9a473af\"\n\t\t   \"c25b218f519af0fd d406362e8d69de7f\"\n\t\t   \"54c604a6e00f353f 110f771bdca8ab92\"\n\n\t\t   \"e5fbc34e60a1d9a9 db17345b0a402736\"\n\t\t   \"853bf910b060bdf1 f897b6290f01d138\"\n\t\t   \"ae2c4c90225ba9ea 14d518f55929dea0\"\n\t\t   \"98ca7a6ccfe61227 053c84e49a4a3332\"),\n\t      20);\n\n  /* From draft-irtf-cfrg-chacha20-poly1305-08, with 96-bit nonce */\n  test_chacha(SHEX(\"0001020304050607 08090a0b0c0d0e0f\"\n\t\t   \"1011121314151617 18191a1b1c1d1e1f\"),\n\t      SHEX(\"000000090000004a 00000000\"),\n\t      SHEX(\"10f1e7e4d13b5915 500fdd1fa32071c4\"\n\t\t   \"c7d1f4c733c06803 0422aa9ac3d46c4e\"\n\t\t   \"d2826446079faa09 14c2d705d98b02a2\"\n\t\t   \"b5129cd1de164eb9 cbd083e8a2503c4e\"),\n\t      20);\n}",
      "lines": 528,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/cnd-memcpy-test.c": {
    "cnd_memcpy_for_test": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        18,
        1
      ],
      "content": "static void\ncnd_memcpy_for_test(int cnd, void *dst, const void *src, size_t n)\n{\n  /* Makes valgrind trigger on any branches depending on the input\n     data. */\n  VALGRIND_MAKE_MEM_UNDEFINED (dst, n);\n  VALGRIND_MAKE_MEM_UNDEFINED (src, n);\n  VALGRIND_MAKE_MEM_UNDEFINED (&cnd, sizeof(cnd));\n\n  cnd_memcpy (cnd, dst, src, n);\n  VALGRIND_MAKE_MEM_DEFINED (src, n);\n  VALGRIND_MAKE_MEM_DEFINED (dst, n);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        46,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  uint8_t src[MAX_SIZE];\n  uint8_t dst[MAX_SIZE];\n  uint8_t res[MAX_SIZE];\n  struct knuth_lfib_ctx random_ctx;\n\n  knuth_lfib_init (&random_ctx, 11);\n\n  size_t size;\n  for (size = 1; size < 50; size++)\n    {\n      knuth_lfib_random (&random_ctx, size, src);\n      knuth_lfib_random (&random_ctx, size, dst);\n      memcpy (res, dst, size);\n      cnd_memcpy_for_test (0, res, src, size);\n\n      ASSERT (memcmp (res, dst, size) == 0);\n      cnd_memcpy_for_test (1, res, src, size);\n      ASSERT (memcmp (res, src, size) == 0);\n    }\n}",
      "lines": 23,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ctr-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From NIST spec 800-38a on AES modes,\n   *\n   * http://csrc.nist.gov/CryptoToolkit/modes/800-38_Series_Publications/SP800-38A.pdf\n   *\n   * F.5  CTR Example Vectors\n   */\n\n  /* Zero-length data. Exposes bug reported by Tim Kosse, where\n     ctr_crypt increment the ctr when it shouldn't. */\n  test_cipher_ctr(&nettle_aes128,\n\t\t  SHEX(\"2b7e151628aed2a6abf7158809cf4f3c\"),\n\t\t  SHEX(\"\"), SHEX(\"\"),\n\t\t  SHEX(\"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"));\n  \n  /* F.5.1  CTR-AES128.Encrypt */\n  test_cipher_ctr(&nettle_aes128,\n\t\t  SHEX(\"2b7e151628aed2a6abf7158809cf4f3c\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"874d6191b620e3261bef6864990db6ce\"\n\t\t       \"9806f66b7970fdff8617187bb9fffdff\"\n\t\t       \"5ae4df3edbd5d35e5b4f09020db03eab\"\n\t\t       \"1e031dda2fbe03d1792170a0f3009cee\"),\n\t\t  SHEX(\"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"));\n\n  /* F.5.3  CTR-AES192.Encrypt */\n  test_cipher_ctr(&nettle_aes192,\n\t\t  SHEX(\"8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"1abc932417521ca24f2b0459fe7e6e0b\"\n\t\t       \"090339ec0aa6faefd5ccc2c6f4ce8e94\"\n\t\t       \"1e36b26bd1ebc670d1bd1d665620abf7\"\n\t\t       \"4f78a7f6d29809585a97daec58c6b050\"),\n\t\t  SHEX(\"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"));\n\n  /* F.5.5  CTR-AES256.Encrypt */\n  test_cipher_ctr(&nettle_aes256,\n\t\t  SHEX(\"603deb1015ca71be2b73aef0857d7781\"\n\t\t       \"1f352c073b6108d72d9810a30914dff4\"),\n\t\t  SHEX(\"6bc1bee22e409f96e93d7e117393172a\"\n\t\t       \"ae2d8a571e03ac9c9eb76fac45af8e51\"\n\t\t       \"30c81c46a35ce411e5fbc1191a0a52ef\"\n\t\t       \"f69f2445df4f9b17ad2b417be66c3710\"),\n\t\t  SHEX(\"601ec313775789a5b7a7f504bbf3d228\"\n\t\t       \"f443e3ca4d62b59aca84e990cacaf5c5\"\n\t\t       \"2b0930daa23de94ce87017ba2d84988d\"\n\t\t       \"dfc9c58db67aada613c2dd08457941a6\"),\n\t\t  SHEX(\"f0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"));\n}",
      "lines": 57,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/curve25519-dh-test.c": {
    "test_g": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ntest_g (const uint8_t *s, const uint8_t *r)\n{\n  uint8_t p[CURVE25519_SIZE];\n  curve25519_mul_g (p, s);\n  if (!MEMEQ (CURVE25519_SIZE, p, r))\n    {\n      printf (\"curve25519_mul_g failure:\\ns = \");\n      print_hex (CURVE25519_SIZE, s);\n      printf (\"\\np = \");\n      print_hex (CURVE25519_SIZE, p);\n      printf (\" (bad)\\nr = \");\n      print_hex (CURVE25519_SIZE, r);\n      printf (\" (expected)\\n\");\n      abort ();\n    }\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_a": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "static void\ntest_a (const uint8_t *s, const uint8_t *b, const uint8_t *r)\n{\n  uint8_t p[CURVE25519_SIZE];\n  curve25519_mul (p, s, b);\n    \n  if (!MEMEQ (CURVE25519_SIZE, p, r))\n    {\n      printf (\"curve25519_mul failure:\\ns = \");\n      print_hex (CURVE25519_SIZE, s);\n      printf (\"\\nb = \");\n      print_hex (CURVE25519_SIZE, b);\n      printf (\"\\np = \");\n      print_hex (CURVE25519_SIZE, p);\n      printf (\" (bad)\\nr = \");\n      print_hex (CURVE25519_SIZE, r);\n      printf (\" (expected)\\n\");\n      abort ();\n    }\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        140,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  /* From RFC 7748. */\n  test_g (H(\"77076d0a7318a57d3c16c17251b26645\"\n\t    \"df4c2f87ebc0992ab177fba51db92c2a\"),\n\t  H(\"8520f0098930a754748b7ddcb43ef75a\"\n\t    \"0dbf3a0d26381af4eba4a98eaa9b4e6a\"));\n  test_g (H(\"5dab087e624a8a4b79e17f8b83800ee6\"\n\t    \"6f3bb1292618b6fd1c2f8b27ff88e0eb\"),\n\t  H(\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n\t    \"3f8343c85b78674dadfc7e146f882b4f\"));\n\n  test_a (H(\"77076d0a7318a57d3c16c17251b26645\"\n\t    \"df4c2f87ebc0992ab177fba51db92c2a\"),\n\t  H(\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n\t    \"3f8343c85b78674dadfc7e146f882b4f\"),\n\t  H(\"4a5d9d5ba4ce2de1728e3bf480350f25\"\n\t    \"e07e21c947d19e3376f09b3c1e161742\"));\n\n  test_a (H(\"5dab087e624a8a4b79e17f8b83800ee6\"\n\t    \"6f3bb1292618b6fd1c2f8b27ff88e0eb\"),\n\t  H(\"8520f0098930a754748b7ddcb43ef75a\"\n\t    \"0dbf3a0d26381af4eba4a98eaa9b4e6a\"),\n\t  H(\"4a5d9d5ba4ce2de1728e3bf480350f25\"\n\t    \"e07e21c947d19e3376f09b3c1e161742\"));\n\n  /* Check that the least significant three bits (first octet) of the\n     scalar are ignored by mul_g. */\n  test_g (H(\"70076d0a7318a57d3c16c17251b26645\"\n\t    \"df4c2f87ebc0992ab177fba51db92c2a\"),\n\t  H(\"8520f0098930a754748b7ddcb43ef75a\"\n\t    \"0dbf3a0d26381af4eba4a98eaa9b4e6a\"));\n  /* Check that the most significant two bits (last octet) of the\n     scalar are ignored by mul_g. */\n  test_g (H(\"5dab087e624a8a4b79e17f8b83800ee6\"\n\t    \"6f3bb1292618b6fd1c2f8b27ff88e02b\"),\n\t  H(\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n\t    \"3f8343c85b78674dadfc7e146f882b4f\"));\n\n  /* Check that the least significant three bits (first octet) of the\n     scalar are ignored by mul_a. */\n  test_a (H(\"5aab087e624a8a4b79e17f8b83800ee6\"\n\t    \"6f3bb1292618b6fd1c2f8b27ff88e0eb\"),\n\t  H(\"8520f0098930a754748b7ddcb43ef75a\"\n\t    \"0dbf3a0d26381af4eba4a98eaa9b4e6a\"),\n\t  H(\"4a5d9d5ba4ce2de1728e3bf480350f25\"\n\t    \"e07e21c947d19e3376f09b3c1e161742\"));\n\n  /* Check that the most significant two bits (last octet) of the\n     scalar are ignored by mul_g. */\n  test_a (H(\"77076d0a7318a57d3c16c17251b26645\"\n\t    \"df4c2f87ebc0992ab177fba51db92cea\"),\n\t  H(\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n\t    \"3f8343c85b78674dadfc7e146f882b4f\"),\n\t  H(\"4a5d9d5ba4ce2de1728e3bf480350f25\"\n\t    \"e07e21c947d19e3376f09b3c1e161742\"));\n\n  /* Check that the most significant bit (last octet) of the x\n     coordinate is ignored. */\n  test_a (H(\"77076d0a7318a57d3c16c17251b26645\"\n\t    \"df4c2f87ebc0992ab177fba51db92c2a\"),\n\t  H(\"de9edb7d7b7dc1b4d35b61c2ece43537\"\n\t    \"3f8343c85b78674dadfc7e146f882bcf\"),\n\t  H(\"4a5d9d5ba4ce2de1728e3bf480350f25\"\n\t    \"e07e21c947d19e3376f09b3c1e161742\"));\n}",
      "lines": 67,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/des-compat-test.c": {
    "test_main": {
      "start_point": [
        301,
        0
      ],
      "end_point": [
        744,
        2
      ],
      "content": "void\ntest_main(void)\n\t{\n\tint i,j,err=0;\n\tdes_cblock in, out, outin, iv3;\n\tdes_key_schedule ks,ks2,ks3;\n\tdes_cblock cbc_in[5];\n\tdes_cblock cbc_out[5];\n\tDES_LONG cs;\n\tunsigned char cret[8];\n#if 0\n\tunsigned char qret[4][4];\n\tDES_LONG lqret[4];\n\tint num;\n\tchar *str;\n#endif\n\tif (verbose) printf(\"Doing ecb\\n\");\n\tfor (i=0; i<NUM_TESTS; i++)\n\t\t{\n\t\tif ((j=des_key_sched(&key_data[i], ks)) != 0)\n\t\t\t{\n\t\t\tprintf(\"Key error %2d:%d\\n\",i+1,j);\n\t\t\terr=1;\n\t\t\t}\n\t\tmemcpy(in,plain_data[i],8);\n\t\tmemset(out,0,8);\n\t\tmemset(outin,0,8);\n\t\tdes_ecb_encrypt(&in, &out, ks, DES_ENCRYPT);\n\t\tdes_ecb_encrypt(&out, &outin, ks, DES_DECRYPT);\n\n\t\tif (memcmp(out,cipher_data[i],8) != 0)\n\t\t\t{\n\t\t\tprintf(\"Encryption error %2d\\nk=%s p=%s o=%s act=%s\\n\",\n\t\t\t\ti+1,pt(key_data[i]),pt(in),pt(cipher_data[i]),\n\t\t\t\tpt(out));\n\t\t\terr=1;\n\t\t\t}\n\t\tif (memcmp(in,outin,8) != 0)\n\t\t\t{\n\t\t\tprintf(\"Decryption error %2d\\nk=%s p=%s o=%s act=%s\\n\",\n\t\t\t\ti+1,pt(key_data[i]),pt(out),pt(in),pt(outin));\n\t\t\terr=1;\n\t\t\t}\n\t\t}\n\n#ifndef LIBDES_LIT\n\tif (verbose) printf(\"Doing ede ecb\\n\");\n\tfor (i=0; i<(NUM_TESTS-1); i++)\n\t\t{\n\t\tif ((j=des_key_sched(&key_data[i], ks)) != 0)\n\t\t\t{\n\t\t\terr=1;\n\t\t\tprintf(\"Key error %2d:%d\\n\",i+1,j);\n\t\t\t}\n\t\tif ((j=des_key_sched(&key_data[i+1],ks2)) != 0)\n\t\t\t{\n\t\t\tprintf(\"Key error %2d:%d\\n\",i+2,j);\n\t\t\terr=1;\n\t\t\t}\n\t\tif (i+2 < NUM_TESTS && (j=des_key_sched(&key_data[i+2],ks3)) != 0)\n\t\t\t{\n\t\t\tprintf(\"Key error %2d:%d\\n\",i+3,j);\n\t\t\terr=1;\n\t\t\t}\n\t\tmemcpy(in,plain_data[i],8);\n\t\tmemset(out,0,8);\n\t\tmemset(outin,0,8);\n\t\tdes_ecb2_encrypt(&in, &out, ks, ks2,\n\t\t\tDES_ENCRYPT);\n\t\tdes_ecb2_encrypt(&out, &outin, ks, ks2,\n\t\t\tDES_DECRYPT);\n\n\t\tif (memcmp(out,cipher_ecb2[i],8) != 0)\n\t\t\t{\n\t\t\tprintf(\"Encryption error %2d\\nk=%s p=%s o=%s act=%s\\n\",\n\t\t\t\ti+1,pt(key_data[i]),pt(in),pt(cipher_ecb2[i]),\n\t\t\t\tpt(out));\n\t\t\terr=1;\n\t\t\t}\n\t\tif (memcmp(in,outin,8) != 0)\n\t\t\t{\n\t\t\tprintf(\"Decryption error %2d\\nk=%s p=%s o=%s act=%s\\n\",\n\t\t\t\ti+1,pt(key_data[i]),pt(out),pt(in),pt(outin));\n\t\t\terr=1;\n\t\t\t}\n\t\t}\n#endif\n\n\tif (verbose) printf(\"Doing cbc\\n\");\n\tif ((j=des_key_sched(&cbc_key, ks)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tmemset(cbc_out,0,sizeof(cbc_data));\n\tmemset(cbc_in,0,sizeof(cbc_data));\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\tdes_ncbc_encrypt(cbc_data, cbc_out,\n\t\tsizeof(cbc_data), ks,\n\t\t&iv3, DES_ENCRYPT);\n\tif (memcmp(cbc_out,cbc_ok,32) != 0)\n\t\tprintf(\"cbc_encrypt encrypt error\\n\");\n\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\tdes_ncbc_encrypt(cbc_out, cbc_in,\n\t\tsizeof(cbc_data),ks,\n\t\t&iv3,DES_DECRYPT);\n\tif (memcmp(cbc_in,cbc_data,sizeof(cbc_data)) != 0)\n\t\t{\n\t\tprintf(\"cbc_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n#ifndef LIBDES_LIT\n#if 0\n\tif (verbose) printf(\"Doing desx cbc\\n\");\n\tif ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tmemset(cbc_out,0,sizeof(cbc_data));\n\tmemset(cbc_in,0,sizeof(cbc_data));\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\tdes_xcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,\n\t\tsizeof(cbc_data), ks,\n\t\t(C_Block *)iv3,\n\t\t(C_Block *)cbc2_key, (C_Block *)cbc3_key, DES_ENCRYPT);\n\tif (memcmp(cbc_out,xcbc_ok,32) != 0)\n\t\t{\n\t\tprintf(\"des_xcbc_encrypt encrypt error\\n\");\n\t\t}\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\tdes_xcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,\n\t\tsizeof(cbc_data), ks,\n\t\t(C_Block *)iv3,\n\t\t(C_Block *)cbc2_key, (C_Block *)cbc3_key, DES_DECRYPT);\n\tif (memcmp(cbc_in,cbc_data,sizeof(cbc_data)) != 0)\n\t\t{\n\t\tprintf(\"des_xcbc_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n#endif\n#endif /* LIBDES_LIT */\n\n\tif (verbose) printf(\"Doing ede cbc\\n\");\n\tif ((j=des_key_sched(&cbc_key,ks)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tif ((j=des_key_sched(&cbc2_key,ks2)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tif ((j=des_key_sched(&cbc3_key,ks3)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tmemset(cbc_out,0,sizeof(cbc_data));\n\tmemset(cbc_in,0,sizeof(cbc_data));\n\ti=sizeof(cbc_data);\n\t/* i=((i+7)/8)*8; */\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\n\tdes_ede3_cbc_encrypt( cbc_data, cbc_out,\n\t\t16L, ks, ks2, ks3, &iv3, DES_ENCRYPT);\n\tdes_ede3_cbc_encrypt( &cbc_data[2],\n\t\t&cbc_out[2],\n\t\t(long)i-16, ks, ks2, ks3, &iv3, DES_ENCRYPT);\n\tif (memcmp(cbc_out,cbc3_ok, sizeof(cbc_data)) != 0)\n\t\t{\n\t\tprintf(\"des_ede3_cbc_encrypt encrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n\tmemcpy(iv3,cbc_iv,sizeof(cbc_iv));\n\tdes_ede3_cbc_encrypt(cbc_out, cbc_in,\n\t\t(long)i, ks, ks2, ks3, &iv3, DES_DECRYPT);\n\tif (memcmp(cbc_in,cbc_data,sizeof(cbc_data)) != 0)\n\t\t{\n\t\tprintf(\"des_ede3_cbc_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n#ifndef LIBDES_LIT\n#if 0\n\tprintf(\"Doing pcbc\\n\");\n\tif ((j=des_key_sched((C_Block *)cbc_key,ks)) != 0)\n\t\t{\n\t\tprintf(\"Key error %d\\n\",j);\n\t\terr=1;\n\t\t}\n\tmemset(cbc_out,0,sizeof(cbc_data));\n\tmemset(cbc_in,0,sizeof(cbc_data));\n\tdes_pcbc_encrypt((C_Block *)cbc_data,(C_Block *)cbc_out,\n\t\tsizeof(cbc_data),ks,(C_Block *)cbc_iv,DES_ENCRYPT);\n\tif (memcmp(cbc_out,pcbc_ok,32) != 0)\n\t\t{\n\t\tprintf(\"pcbc_encrypt encrypt error\\n\");\n\t\terr=1;\n\t\t}\n\tdes_pcbc_encrypt((C_Block *)cbc_out,(C_Block *)cbc_in,\n\t\tsizeof(cbc_data),ks,(C_Block *)cbc_iv,DES_DECRYPT);\n\tif (memcmp(cbc_in,cbc_data,sizeof(cbc_data)) != 0)\n\t\t{\n\t\tprintf(\"pcbc_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n\tprintf(\"Doing \");\n\tprintf(\"cfb8 \");\n\terr+=cfb_test(8,cfb_cipher8);\n\tprintf(\"cfb16 \");\n\terr+=cfb_test(16,cfb_cipher16);\n\tprintf(\"cfb32 \");\n\terr+=cfb_test(32,cfb_cipher32);\n\tprintf(\"cfb48 \");\n\terr+=cfb_test(48,cfb_cipher48);\n\tprintf(\"cfb64 \");\n\terr+=cfb_test(64,cfb_cipher64);\n\n\tprintf(\"cfb64() \");\n\terr+=cfb64_test(cfb_cipher64);\n\n\tmemcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));\n\tfor (i=0; i<sizeof(plain); i++)\n\t\tdes_cfb_encrypt(&(plain[i]),&(cfb_buf1[i]),\n\t\t\t8,(long)1,ks,(C_Block *)cfb_tmp,DES_ENCRYPT);\n\tif (memcmp(cfb_cipher8,cfb_buf1,sizeof(plain)) != 0)\n\t\t{\n\t\tprintf(\"cfb_encrypt small encrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n\tmemcpy(cfb_tmp,cfb_iv,sizeof(cfb_iv));\n\tfor (i=0; i<sizeof(plain); i++)\n\t\tdes_cfb_encrypt(&(cfb_buf1[i]),&(cfb_buf2[i]),\n\t\t\t8,(long)1,ks,(C_Block *)cfb_tmp,DES_DECRYPT);\n\tif (memcmp(plain,cfb_buf2,sizeof(plain)) != 0)\n\t\t{\n\t\tprintf(\"cfb_encrypt small decrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n\tprintf(\"ede_cfb64() \");\n\terr+=ede_cfb64_test(cfb_cipher64);\n\n\tprintf(\"done\\n\");\n\n\tprintf(\"Doing ofb\\n\");\n\tdes_key_sched((C_Block *)ofb_key,ks);\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tdes_ofb_encrypt(plain,ofb_buf1,64,(long)sizeof(plain)/8,ks,\n\t\t(C_Block *)ofb_tmp);\n\tif (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)\n\t\t{\n\t\tprintf(\"ofb_encrypt encrypt error\\n\");\nporintf(\"%02X %02X %02X %02X %02X %02X %02X %02X\\n\",\nofb_buf1[8+0], ofb_buf1[8+1], ofb_buf1[8+2], ofb_buf1[8+3],\nofb_buf1[8+4], ofb_buf1[8+5], ofb_buf1[8+6], ofb_buf1[8+7]);\nprintf(\"%02X %02X %02X %02X %02X %02X %02X %02X\\n\",\nofb_buf1[8+0], ofb_cipher[8+1], ofb_cipher[8+2], ofb_cipher[8+3],\nofb_buf1[8+4], ofb_cipher[8+5], ofb_cipher[8+6], ofb_cipher[8+7]);\n\t\terr=1;\n\t\t}\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tdes_ofb_encrypt(ofb_buf1,ofb_buf2,64,(long)sizeof(ofb_buf1)/8,ks,\n\t\t(C_Block *)ofb_tmp);\n\tif (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)\n\t\t{\n\t\tprintf(\"ofb_encrypt decrypt error\\n\");\nprintf(\"%02X %02X %02X %02X %02X %02X %02X %02X\\n\",\nofb_buf2[8+0], ofb_buf2[8+1], ofb_buf2[8+2], ofb_buf2[8+3],\nofb_buf2[8+4], ofb_buf2[8+5], ofb_buf2[8+6], ofb_buf2[8+7]);\nprintf(\"%02X %02X %02X %02X %02X %02X %02X %02X\\n\",\nplain[8+0], plain[8+1], plain[8+2], plain[8+3],\nplain[8+4], plain[8+5], plain[8+6], plain[8+7]);\n\t\terr=1;\n\t\t}\n\n\tprintf(\"Doing ofb64\\n\");\n\tdes_key_sched((C_Block *)ofb_key,ks);\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tmemset(ofb_buf1,0,sizeof(ofb_buf1));\n\tmemset(ofb_buf2,0,sizeof(ofb_buf1));\n\tnum=0;\n\tfor (i=0; i<sizeof(plain); i++)\n\t\t{\n\t\tdes_ofb64_encrypt(&(plain[i]),&(ofb_buf1[i]),1,ks,\n\t\t\t(C_Block *)ofb_tmp,&num);\n\t\t}\n\tif (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)\n\t\t{\n\t\tprintf(\"ofb64_encrypt encrypt error\\n\");\n\t\terr=1;\n\t\t}\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tnum=0;\n\tdes_ofb64_encrypt(ofb_buf1,ofb_buf2,(long)sizeof(ofb_buf1),ks,\n\t\t(C_Block *)ofb_tmp,&num);\n\tif (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)\n\t\t{\n\t\tprintf(\"ofb64_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n\n\tprintf(\"Doing ede_ofb64\\n\");\n\tdes_key_sched((C_Block *)ofb_key,ks);\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tmemset(ofb_buf1,0,sizeof(ofb_buf1));\n\tmemset(ofb_buf2,0,sizeof(ofb_buf1));\n\tnum=0;\n\tfor (i=0; i<sizeof(plain); i++)\n\t\t{\n\t\tdes_ede3_ofb64_encrypt(&(plain[i]),&(ofb_buf1[i]),1,ks,ks,ks,\n\t\t\t(C_Block *)ofb_tmp,&num);\n\t\t}\n\tif (memcmp(ofb_cipher,ofb_buf1,sizeof(ofb_buf1)) != 0)\n\t\t{\n\t\tprintf(\"ede_ofb64_encrypt encrypt error\\n\");\n\t\terr=1;\n\t\t}\n\tmemcpy(ofb_tmp,ofb_iv,sizeof(ofb_iv));\n\tnum=0;\n\tdes_ede3_ofb64_encrypt(ofb_buf1,ofb_buf2,(long)sizeof(ofb_buf1),ks,\n\t\tks,ks,(C_Block *)ofb_tmp,&num);\n\tif (memcmp(plain,ofb_buf2,sizeof(ofb_buf2)) != 0)\n\t\t{\n\t\tprintf(\"ede_ofb64_encrypt decrypt error\\n\");\n\t\terr=1;\n\t\t}\n#endif\n        \n\tif (verbose) printf(\"Doing cbc_cksum\\n\");\n\tdes_key_sched(&cbc_key,ks);\n\tcs=des_cbc_cksum(cbc_data[0], &cret,\n\t\tsizeof(cbc_data), ks, &cbc_iv);\n\tif (cs != cbc_cksum_ret)\n\t\t{\n\t\tprintf(\"bad return value (%08lX), should be %08lX\\n\",\n\t\t\t(unsigned long)cs,(unsigned long)cbc_cksum_ret);\n\t\terr=1;\n\t\t}\n\tif (memcmp(cret,cbc_cksum_data,8) != 0)\n\t\t{\n\t\tprintf(\"bad cbc_cksum block returned\\n\");\n\t\terr=1;\n\t\t}\n\n#if 0\n\tprintf(\"Doing quad_cksum\\n\");\n\tcs=quad_cksum((C_Block *)cbc_data,(C_Block *)qret,\n\t\tsizeof(cbc_data),2,(C_Block *)cbc_iv);\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tlqret[i]=0;\n\t\tmemcpy(&(lqret[i]),&(qret[i][0]),4);\n\t\t}\n\t{ /* Big-endian fix */\n\tstatic DES_LONG l=1;\n\tstatic unsigned char *c=(unsigned char *)&l;\n\tDES_LONG ll;\n\n\tif (!c[0])\n\t\t{\n\t\tll=lqret[0]^lqret[3];\n\t\tlqret[0]^=ll;\n\t\tlqret[3]^=ll;\n\t\tll=lqret[1]^lqret[2];\n\t\tlqret[1]^=ll;\n\t\tlqret[2]^=ll;\n\t\t}\n\t}\n\tif (cs != 0x70d7a63aL)\n\t\t{\n\t\tprintf(\"quad_cksum error, ret %08lx should be 70d7a63a\\n\",\n\t\t\t(unsigned long)cs);\n\t\terr=1;\n\t\t}\n\tif (lqret[0] != 0x327eba8dL)\n\t\t{\n\t\tprintf(\"quad_cksum error, out[0] %08lx is not %08lx\\n\",\n\t\t\t(unsigned long)lqret[0],0x327eba8dL);\n\t\terr=1;\n\t\t}\n\tif (lqret[1] != 0x201a49ccL)\n\t\t{\n\t\tprintf(\"quad_cksum error, out[1] %08lx is not %08lx\\n\",\n\t\t\t(unsigned long)lqret[1],0x201a49ccL);\n\t\terr=1;\n\t\t}\n\tif (lqret[2] != 0x70d7a63aL)\n\t\t{\n\t\tprintf(\"quad_cksum error, out[2] %08lx is not %08lx\\n\",\n\t\t\t(unsigned long)lqret[2],0x70d7a63aL);\n\t\terr=1;\n\t\t}\n\tif (lqret[3] != 0x501c2c26L)\n\t\t{\n\t\tprintf(\"quad_cksum error, out[3] %08lx is not %08lx\\n\",\n\t\t\t(unsigned long)lqret[3],0x501c2c26L);\n\t\terr=1;\n\t\t}\n#endif\n#endif /* LIBDES_LIT */\n#if 0\n\tprintf(\"input word alignment test\");\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tprintf(\" %d\",i);\n\t\tdes_ncbc_encrypt( (des_cblock *) &(cbc_out[i]), (des_cblock *) cbc_in,\n\t\t\tsizeof(cbc_data), ks, &cbc_iv,\n\t\t\tDES_ENCRYPT);\n\t\t}\n\tprintf(\"\\noutput word alignment test\");\n\tfor (i=0; i<4; i++)\n\t\t{\n\t\tprintf(\" %d\",i);\n\t\tdes_ncbc_encrypt( (des_cblock *) cbc_out, (des_cblock *) &(cbc_in[i]),\n\t\t\tsizeof(cbc_data), ks, &cbc_iv,\n\t\t\tDES_ENCRYPT);\n\t\t}\n\tprintf(\"\\n\");\n\n\tprintf(\"fast crypt test \");\n\tstr=crypt(\"testing\",\"ef\");\n\tif (strcmp(\"efGnQx2725bI2\",str) != 0)\n\t\t{\n\t\tprintf(\"fast crypt error, %s should be efGnQx2725bI2\\n\",str);\n\t\terr=1;\n\t\t}\n\tstr=crypt(\"bca76;23\",\"yA\");\n\tif (strcmp(\"yA1Rp/1hZXIJk\",str) != 0)\n\t\t{\n\t\tprintf(\"fast crypt error, %s should be yA1Rp/1hZXIJk\\n\",str);\n\t\terr=1;\n\t\t}\n\tprintf(\"\\n\");\n#endif\n\tASSERT (err == 0);\n\t}",
      "lines": 444,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "pt": {
      "start_point": [
        746,
        0
      ],
      "end_point": [
        763,
        2
      ],
      "content": "static char *pt(const unsigned char *p)\n\t{\n\tstatic char bufs[10][20];\n\tstatic int bnum=0;\n\tchar *ret;\n\tint i;\n\tstatic const char *f=\"0123456789ABCDEF\";\n\n\tret= &(bufs[bnum++][0]);\n\tbnum%=10;\n\tfor (i=0; i<8; i++)\n\t\t{\n\t\tret[i*2]=f[(p[i]>>4)&0xf];\n\t\tret[i*2+1]=f[p[i]&0xf];\n\t\t}\n\tret[16]='\\0';\n\treturn(ret);\n\t}",
      "lines": 18,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "char",
        "*pt(const unsigned char *p)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/des-test.c": {
    "test_des": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "static void\ntest_des(const struct tstring *key, int expected_parity,\n\t const struct tstring *cleartext,\n\t const struct tstring *ciphertext)\n{\n  struct des_ctx ctx;\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == DES_KEY_SIZE);\n  \n  data = xalloc(length);\n\n  ASSERT (des_check_parity(8, key->data) == expected_parity);\n\n  ASSERT (des_set_key(&ctx, key->data));\n\n  des_encrypt(&ctx, length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  des_decrypt(&ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_weak": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\ntest_weak(const struct tstring *key)\n{\n  struct des_ctx ctx;\n\n  ASSERT (key->length == DES_KEY_SIZE);\n  ASSERT (des_set_key(&ctx, key->data) == 0);\n}",
      "lines": 8,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From Applied Cryptography */\n  test_des(SHEX(\"01234567 89ABCDEF\"), 1,\n\t   SHEX(\"01234567 89ABCDE7\"),\n\t   SHEX(\"C9574425 6A5ED31D\"));\n\n  test_des(SHEX(\"01 01 01 01 01 01 01 80\"), 1,\n\t   SHEX(\"00 00 00 00 00 00 00 00\"),\n\t   SHEX(\"9C C6 2D F4 3B 6E ED 74\"));\n\n  test_des(SHEX(\"80 01 01 01 01 01 01 01\"), 1,\n\t   SHEX(\"00 00 00 00 00 00 00 40\"),\n\t   SHEX(\"A3 80 E0 2A 6B E5 46 96\"));\n\n  test_des(SHEX(\"08 19 2A 3B 4C 5D 6E 7F\"), 1,\n\t   SHEX(\"00 00 00 00 00 00 00 00\"),\n\t   SHEX(\"25 DD AC 3E 96 17 64 67\"));\n\n  test_des(SHEX(\"01 23 45 67 89 AB CD EF\"), 1,\n\t   SDATA(\"Now is t\"),\n\t   SHEX(\"3F A4 0E 8A 98 4D 48 15\"));\n\n  /* Same key, but with one bad parity bit, */\n  test_des(SHEX(\"01 23 45 66 89 AB CD EF\"), 0,\n\t   SDATA(\"Now is t\"),\n\t   SHEX(\"3F A4 0E 8A 98 4D 48 15\"));\n\n  /* Parity check */\n  {\n    const struct tstring *s = SHEX(\"01 01 01 01 01 01 01 00\");\n    ASSERT (des_check_parity(s->length, s->data) == 0);\n  }\n\n  /* The four weak keys */\n  test_weak(SHEX(\"01 01 01 01 01 01 01 01\"));  \n  test_weak(SHEX(\"FE FE FE FE FE FE FE FE\"));\n  test_weak(SHEX(\"1F 1F 1F 1F 0E 0E 0E 0E\"));\n  test_weak(SHEX(\"E0 E0 E0 E0 F1 F1 F1 F1\"));\n\n  /* Same weak key, but different parity. */\n  test_weak(SHEX(\"E0 E0 E0 E0 F0 F1 F1 F1\"));\n\n  /* The six pairs of semiweak keys */\n  test_weak(SHEX(\"01 FE 01 FE 01 FE 01 FE\"));\n  test_weak(SHEX(\"FE 01 FE 01 FE 01 FE 01\"));\n\n  test_weak(SHEX(\"1F E0 1F E0 0E F1 0E F1\"));\n  test_weak(SHEX(\"E0 1F E0 1F F1 0E F1 0E\"));\n\n  test_weak(SHEX(\"01 E0 01 E0 01 F1 01 F1\"));\n  test_weak(SHEX(\"E0 01 E0 01 F1 01 F1 01\"));\n\n  test_weak(SHEX(\"1F FE 1F FE 0E FE 0E FE\"));\n  test_weak(SHEX(\"FE 1F FE 1F FE 0E FE 0E\"));\n\n  test_weak(SHEX(\"01 1F 01 1F 01 0E 01 0E\"));\n  test_weak(SHEX(\"1F 01 1F 01 0E 01 0E 01\"));\n\n  test_weak(SHEX(\"E0 FE E0 FE F1 FE F1 FE\"));\n  test_weak(SHEX(\"FE E0 FE E0 FE F1 FE F1\"));\n}",
      "lines": 63,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/des3-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        18,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Intermediate values:\n   *   After first DES encryption:  \"cd ea 2a 20 c2 e0 9e 48\"\n   *   After second DES decryption: \"69 52 6e 95 8b ea 49 bd\"\n   */\n\n  test_cipher(&nettle_des3,\n\t      SHEX(\"3e 0b 10 b0 5d 49 c2 54\"\n\t\t   \"6b 46 e0 75 8a 91 61 85\"\n\t\t   \"cb 04 07 d3 20 16 cb a2\"),\n\t      SDATA(\"Now is t\"),\n\t      SHEX(\"0a 5d b5 2d 85 74 d1 c9\"));\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/dlopen-test.c": {
    "main": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "int\nmain (int argc UNUSED, char **argv UNUSED)\n{\n#if HAVE_LIBDL\n  void *handle = dlopen (\"../libnettle.so\", RTLD_NOW);\n  int (*get_version)(void);\n  if (!handle)\n    {\n      fprintf (stderr, \"dlopen failed: %s\\n\", dlerror());\n      FAIL ();\n    }\n\n  get_version = (int(*)(void)) dlsym (handle, \"nettle_version_minor\");\n  if (!get_version)\n    {\n      fprintf (stderr, \"dlsym failed: %s\\n\", dlerror());\n      FAIL ();\n    }\n  if (get_version() != NETTLE_VERSION_MINOR)\n    {\n      fprintf (stderr, \"unexpected nettle version\\n\");\n      FAIL ();\n    }\n  dlclose (handle);\n  return EXIT_SUCCESS;\n#else\n  SKIP();\n#endif\n}",
      "lines": 29,
      "depth": 11,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/dsa-keygen-test.c": {
    "progress": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        8,
        1
      ],
      "content": "static void\nprogress(void *ctx UNUSED, int c)\n{\n  fputc(c, stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct dsa_public_key pub;\n  struct dsa_private_key key;\n  struct dsa_params *params;\n\n  struct knuth_lfib_ctx lfib;\n  \n  dsa_private_key_init(&key);\n  dsa_public_key_init(&pub);\n\n  knuth_lfib_init(&lfib, 13);\n\n  params = (struct dsa_params *) &pub;\n  ASSERT (dsa_compat_generate_keypair(&pub, &key,\n\t\t\t       &lfib,\n\t\t\t       (nettle_random_func *) knuth_lfib_random,\n\t\t\t       NULL, verbose ? progress : NULL,\n\t\t\t       1024, 160));\n\n  test_dsa_key(params, pub.y, key.x, 160);\n  test_dsa160(&pub, &key, NULL);\n\n  ASSERT (dsa_compat_generate_keypair(&pub, &key,\n\t\t\t       &lfib,\n\t\t\t       (nettle_random_func *) knuth_lfib_random,\n\t\t\t       NULL, verbose ? progress : NULL,\n\t\t\t       2048, 256));\n\n  test_dsa_key(params, pub.y, key.x, 256);\n  test_dsa256(&pub, &key, NULL);\n  \n  ASSERT (dsa_compat_generate_keypair(&pub, &key,\n\t\t\t       &lfib,\n\t\t\t       (nettle_random_func *) knuth_lfib_random,\n\t\t\t       NULL, verbose ? progress : NULL,\n\t\t\t       2048, 224));\n\n  test_dsa_key(params, pub.y, key.x, 224);\n  test_dsa256(&pub, &key, NULL);\n\n  /* Test with large q */\n  if (!dsa_generate_params (params,\n\t\t\t    &lfib,\n\t\t\t    (nettle_random_func *) knuth_lfib_random,\n\t\t\t    NULL, verbose ? progress : NULL,\n\t\t\t    1024, 768))\n    FAIL();\n\n  dsa_generate_keypair (params, pub.y, key.x,\n\t\t\t&lfib,\n\t\t\t(nettle_random_func *) knuth_lfib_random);\n  test_dsa_key(params, pub.y, key.x, 768);\n  test_dsa256(&pub, &key, NULL);\n  \n  dsa_public_key_clear(&pub);\n  dsa_private_key_clear(&key);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/dsa-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        883,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct dsa_public_key pub;\n  struct dsa_private_key key;\n  struct dsa_signature signature;\n  struct dsa_params *params = (struct dsa_params *) &pub;\n\n  dsa_public_key_init(&pub);\n  dsa_private_key_init(&key);\n  dsa_signature_init(&signature);\n\n  mpz_set_str(pub.p,\n\t      \"83d9a7c2ce2a9179f43cdb3bffe7de0f0eef26dd5dfae44d\"\n\t      \"531bc0de45634d2c07cb929b0dbe10da580070e6abfbb841\"\n\t      \"5c44bff570b8ad779df653aad97dc7bdeb815d7e88103e61\"\n\t      \"606ed3d8a295fbfd340d2d49e220833ebace5511e22c4f02\"\n\t      \"97ed351e9948fa848e9c8fadb7b47bcc47def4255b5e1d5e\"\n\t      \"10215b3b55a0b85f\", 16);\n  mpz_set_str(pub.q,\n\t      \"8266e0deaf46020ba48d410ca580f3a978629b5d\", 16);\n  mpz_set_str(pub.g,\n\t      \"30d34bb9f376bec947154afe4076bc7d359c9d32f5471ddb\"\n\t      \"be8d6a941c47fa9dc4f32573151dbb4aa59eb989b74ac36b\"\n\t      \"b6310a5e8b580501655d91f393daa193ae1303049b87febb\"\n\t      \"093dc0404b53b4c5da2463300f9c5b156d788c4ace8ecbb9\"\n\t      \"dd00c18d99537f255ac025d074d894a607cbe3023a1276ef\"\n\t      \"556916a33f7de543\", 16);\n  mpz_set_str(pub.y,\n\t      \"64402048b27f39f404a546a84909c9c0e9e2dd153a849946\"\n\t      \"1062892598d30af27ae3cefc2b700fb6d077390a83bdcad7\"\n\t      \"8a1299487c9623bb62af0c85a3df9ef1ee2c0d66658e1fd3\"\n\t      \"283b5407f6cd30ee7e6154fad41a6a8b0f5c86c5accc1127\"\n\t      \"bf7c9a5d6badcb012180cb62a55c5e17d6d3528cdbe002cc\"\n\t      \"ee131c1b86867f7a\", 16);\n  mpz_set_str(key.x,\n\t      \"56c6efaf878d06eef21dc070fab71da6ec1e30a6\", 16);\n\n  test_dsa_key(params, pub.y, key.x, 160);\n\n  mpz_set_str(signature.r, \"180342f8d4fb5bd0311ebf205bdee6e556014eaf\", 16);\n  mpz_set_str(signature.s, \"392dc6566b2735531a8460966171464ef7ddfe12\", 16);\n\n  test_dsa160(&pub, &key, &signature);\n\n  mpz_set_str(pub.p,\n\t      \"fda45d8f1df8f2b84fb3cf9ae69f93b087d98bea282f643e\"\n\t      \"23472c5b57605952010e4c846d711f2783e8ad4e1447698e\"\n\t      \"2e328fdb1d411ccb0f3caef5b8fc0b9dcecfadf022ecc7de\"\n\t      \"5c153c8f10fe88d63abf7d296ad485dfd6eead595fc1c36b\"\n\t      \"8bd42e8668b55b2bb0f1a6aecbe678df504880de2481a5e4\"\n\t      \"97d1b7d92ee48ffeb083a1833094a0418ec0d914409c720c\"\n\t      \"87ea63c164ec448c471b574a8f88073ebeb44dc6d6b98260\"\n\t      \"46126f03022ff04dcb6a2381a09b0a227d3c57cfbfd48e4a\"\n\t      \"19cbb0a35242c9e234ebe105ae26cab01ede40aa2869fad8\"\n\t      \"6bff57a19ec87b8de294ca03269c268c10813f18169beac5\"\n\t      \"ac97c0e748ccb244282c50c670e1bccb\", 16);\n  mpz_set_str(pub.q,\n\t      \"bd612630da4d930779a32546dc413efd299111b443c7355d\"\n\t      \"65d991163cc3cd9d\", 16);\n  mpz_set_str(pub.g,\n\t      \"050c56e14adb03e47d3902852f5b21c96c28a2aa89619c8b\"\n\t      \"78a98aa5083700994f99184588d2cefaf2a3ea213dd2d084\"\n\t      \"0e682a52357d5fefaef44520622f021855744d638e792f21\"\n\t      \"89543f9770aa1960da4d7b325a37a2922b035c8da3d71543\"\n\t      \"5d7a6ddefc62e84fe76fecbbf9667c6a1781a84aa434548b\"\n\t      \"bdc315f2fb0a420d65c1f72911845b148e994660138052a1\"\n\t      \"fce1c6f933be155b2af8c0177277cd3b75d9477ddbcb77bc\"\n\t      \"f5cccea915a2f3750ba41f337edd44f768cb3d24b17e299d\"\n\t      \"5cebe5e78cbaf5ad41e815edfc71df3131bd5359c653a224\"\n\t      \"bd3ac6a27bad7efff11b24fad0109ee26e4df76fc99e150d\"\n\t      \"666a9294bab8a03f113d228bfad349f4\", 16);\n  mpz_set_str(pub.y,\n\t      \"da7f9abb0b554afaa926c9cffa897239bfdbc58ed9981748\"\n\t      \"edb1e38f42dea0560a407a48b509a5cb460bf31dee9057a0\"\n\t      \"b41d468698fa82ff03c47e8f3f6564c74d6f1daa5f84ad25\"\n\t      \"b937317f861fa68c19e20d6b855e85cd94d5af95b968416e\"\n\t      \"6d43711f24d5497f018b7627d2bed25dc793ddb897fdcc34\"\n\t      \"5d183e43a80205483dea7a12185be3b185a7d84d3385b962\"\n\t      \"4485882722d177ccd8f49c5b519fb96b9b59fcfc63422f25\"\n\t      \"88fb8ff00bce46acb7c80d105c31414ecf5be0a0dad975bd\"\n\t      \"dcd83d6f063f9bce562fdd5b68e18fc2159dbb2457adc7a7\"\n\t      \"ee5bc0796eff370908f866a41b9a8873f89e1904925141f8\"\n\t      \"e574df25bd869f43a184a804e8ce5fcc\", 16);\n  mpz_set_str(key.x,\n\t      \"39f84f88569da55c6bee7e18175b539ea9b7ee24fabd85a7\"\n\t      \"1fa8c93b7181545b\", 16);\n\n  test_dsa_key(params, pub.y, key.x, 256);\n\n  mpz_set_str(signature.r,\n\t      \"03fe95c9dbbe1be019d7914e45c37c70\"\n\t      \"0f499f559312a59f3bc5037f51d3f74c\", 16);\n  mpz_set_str(signature.s,\n\t      \"839dbee8d30e6b0cc349528f900f30ee\"\n\t      \"6d4ce9864332d07c87b5a98bd75dbdbb\", 16);\n\n  test_dsa256(&pub, &key, &signature);\n\n  /* Some of the test vectors from\n     http://csrc.nist.gov/groups/STM/cavp/documents/dss/186-3dsatestvectors.zip\n  */\n  /* L=1024, N=160, SHA-1 */\n  mpz_set_str(pub.p,\n\t      \"a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f1903\"\n\t      \"30ed3256b26d0e80a0e49a8fffaaad2a24f472d2573241d4\"\n\t      \"d6d6c7480c80b4c67bb4479c15ada7ea8424d2502fa01472\"\n\t      \"e760241713dab025ae1b02e1703a1435f62ddf4ee4c1b664\"\n\t      \"066eb22f2e3bf28bb70a2a76e4fd5ebe2d1229681b5b0643\"\n\t      \"9ac9c7e9d8bde283\", 16);\n  mpz_set_str(pub.q, \"f85f0f83ac4df7ea0cdf8f469bfeeaea14156495\", 16);\n  mpz_set_str(pub.g,\n\t      \"2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74de\"\n\t      \"eae9df131f8b856e3ad6c8455dab87cc0da8ac973417ce4f\"\n\t      \"7878557d6cdf40b35b4a0ca3eb310c6a95d68ce284ad4e25\"\n\t      \"ea28591611ee08b8444bd64b25f3f7c572410ddfb39cc728\"\n\t      \"b9c936f85f419129869929cdb909a6a3a99bbe0892163681\"\n\t      \"71bd0ba81de4fe33\", 16);\n  mpz_set_str(pub.y,\n\t      \"313fd9ebca91574e1c2eebe1517c57e0c21b0209872140c5\"\n\t      \"328761bbb2450b33f1b18b409ce9ab7c4cd8fda3391e8e34\"\n\t      \"868357c199e16a6b2eba06d6749def791d79e95d3a4d09b2\"\n\t      \"4c392ad89dbf100995ae19c01062056bb14bce005e8731ef\"\n\t      \"de175f95b975089bdcdaea562b32786d96f5a31aedf75364\"\n\t      \"008ad4fffebb970b\", 16);\n  mpz_set_str(signature.r, \"50ed0e810e3f1c7cb6ac62332058448bd8b284c0\", 16);\n  mpz_set_str(signature.s, \"c6aded17216b46b7e4b6f2a97c1ad7cc3da83fde\", 16);\n\n  test_dsa_verify(params, pub.y, &nettle_sha1,\n\t\t  SHEX(\"3b46736d559bd4e0c2c1b2553a33ad3c6cf23cac998d3d0c\"\n\t\t       \"0e8fa4b19bca06f2f386db2dcff9dca4f40ad8f561ffc308\"\n\t\t       \"b46c5f31a7735b5fa7e0f9e6cb512e63d7eea05538d66a75\"\n\t\t       \"cd0d4234b5ccf6c1715ccaaf9cdc0a2228135f716ee9bdee\"\n\t\t       \"7fc13ec27a03a6d11c5c5b3685f51900b1337153bc6c4e8f\"\n\t\t       \"52920c33fa37f4e7\"),\n\t\t  &signature);\n\n  mpz_set_str(pub.y,\n\t      \"29bdd759aaa62d4bf16b4861c81cf42eac2e1637b9ecba51\"\n\t      \"2bdbc13ac12a80ae8de2526b899ae5e4a231aef884197c94\"\n\t      \"4c732693a634d7659abc6975a773f8d3cd5a361fe2492386\"\n\t      \"a3c09aaef12e4a7e73ad7dfc3637f7b093f2c40d6223a195\"\n\t      \"c136adf2ea3fbf8704a675aa7817aa7ec7f9adfb2854d4e0\"\n\t      \"5c3ce7f76560313b\", 16);\n  mpz_set_str(signature.r, \"a26c00b5750a2d27fe7435b93476b35438b4d8ab\", 16);\n  mpz_set_str(signature.s, \"61c9bfcb2938755afa7dad1d1e07c6288617bf70\", 16);\n\n  test_dsa_verify(params, pub.y, &nettle_sha1,\n\t\t  SHEX(\"d2bcb53b044b3e2e4b61ba2f91c0995fb83a6a97525e6644\"\n\t\t       \"1a3b489d9594238bc740bdeea0f718a769c977e2de003877\"\n\t\t       \"b5d7dc25b182ae533db33e78f2c3ff0645f2137abc137d4e\"\n\t\t       \"7d93ccf24f60b18a820bc07c7b4b5fe08b4f9e7d21b256c1\"\n\t\t       \"8f3b9d49acc4f93e2ce6f3754c7807757d2e1176042612cb\"\n\t\t       \"32fc3f4f70700e25\"),\n\t\t  &signature);\n\n  /* L=1024, N=160, SHA-224 */\n  mpz_set_str(pub.p,\n\t      \"8b9b32f5ba38faad5e0d506eb555540d0d7963195558ca30\"\n\t      \"8b7466228d92a17b3b14b8e0ab77a9f3b2959a09848aa69f\"\n\t      \"8df92cd9e9edef0adf792ce77bfceccadd9352700ca5faec\"\n\t      \"f181fa0c326db1d6e5d352458011e51bd3248f4e3bd7c820\"\n\t      \"d7e0a81932aca1eba390175e53eada197223674e3900263e\"\n\t      \"90f72d94e7447bff\", 16);\n  mpz_set_str(pub.q, \"bc550e965647fb3a20f245ec8475624abbb26edd\", 16);\n  mpz_set_str(pub.g,\n\t      \"11333a931fba503487777376859fdc12f7c687b0948ae889\"\n\t      \"d287f1b7a712ad220ae4f1ce379d0dbb5c9abf419621f005\"\n\t      \"fc123c327e5055d1850634c36d397e689e111d598c1c3636\"\n\t      \"b940c84f42f436846e8e7fcad9012ceda398720f32fffd1a\"\n\t      \"45ab6136ce417069207ac140675b8f86dd063915ae6f62b0\"\n\t      \"cec729fbd509ac17\", 16);\n  mpz_set_str(pub.y,\n\t      \"7e339f3757450390160e02291559f30bed0b2d758c5ccc2d\"\n\t      \"8d456232bb435ae49de7e7957e3aad9bfdcf6fd5d9b6ee3b\"\n\t      \"521bc2229a8421dc2aa59b9952345a8fc1de49b348003a9b\"\n\t      \"18da642d7f6f56e3bc665131ae9762088a93786f7b4b72a4\"\n\t      \"bcc308c67e2532a3a5bf09652055cc26bf3b18833598cffd\"\n\t      \"7011f2285f794557\", 16);\n  mpz_set_str(signature.r, \"afee719e7f848b54349ccc3b4fb26065833a4d8e\", 16);\n  mpz_set_str(signature.s, \"734efe992256f31325e749bc32a24a1f957b3a1b\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha224,\n\t\t  SHEX(\"fb2128052509488cad0745ed3e6312850dd96ddaf791f1e6\"\n\t\t       \"24e22a6b9beaa65319c325c78ef59cacba0ccfa722259f24\"\n\t\t       \"f92c17b77a8f6d8e97c93d880d2d8dbbbedcf6acefa06b0e\"\n\t\t       \"476ca2013d0394bd90d56c10626ef43cea79d1ef0bc7ac45\"\n\t\t       \"2bf9b9acaef70325e055ac006d34024b32204abea4be5faa\"\n\t\t       \"e0a6d46d365ed0d9\"),\n\t\t  &signature);\n\n  /* L=1024, N=160, SHA-256 */\n  mpz_set_str(pub.p,\n\t      \"cba13e533637c37c0e80d9fcd052c1e41a88ac325c4ebe13\"\n\t      \"b7170088d54eef4881f3d35eae47c210385a8485d2423a64\"\n\t      \"da3ffda63a26f92cf5a304f39260384a9b7759d8ac1adc81\"\n\t      \"d3f8bfc5e6cb10efb4e0f75867f4e848d1a338586dd0648f\"\n\t      \"eeb163647ffe7176174370540ee8a8f588da8cc143d939f7\"\n\t      \"0b114a7f981b8483\", 16);\n  mpz_set_str(pub.q, \"95031b8aa71f29d525b773ef8b7c6701ad8a5d99\", 16);\n  mpz_set_str(pub.g,\n\t      \"45bcaa443d4cd1602d27aaf84126edc73bd773de6ece15e9\"\n\t      \"7e7fef46f13072b7adcaf7b0053cf4706944df8c4568f26c\"\n\t      \"997ee7753000fbe477a37766a4e970ff40008eb900b9de4b\"\n\t      \"5f9ae06e06db6106e78711f3a67feca74dd5bddcdf675ae4\"\n\t      \"014ee9489a42917fbee3bb9f2a24df67512c1c35c97bfbf2\"\n\t      \"308eaacd28368c5c\", 16);\n  mpz_set_str(pub.y,\n\t      \"4cd6178637d0f0de1488515c3b12e203a3c0ca652f2fe30d\"\n\t      \"088dc7278a87affa634a727a721932d671994a958a0f8922\"\n\t      \"3c286c3a9b10a96560542e2626b72e0cd28e5133fb57dc23\"\n\t      \"8b7fab2de2a49863ecf998751861ae668bf7cad136e6933f\"\n\t      \"57dfdba544e3147ce0e7370fa6e8ff1de690c51b4aeedf04\"\n\t      \"85183889205591e8\", 16);\n  mpz_set_str(signature.r, \"76683a085d6742eadf95a61af75f881276cfd26a\", 16);\n  mpz_set_str(signature.s, \"3b9da7f9926eaaad0bebd4845c67fcdb64d12453\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha256,\n\t\t  SHEX(\"812172f09cbae62517804885754125fc6066e9a902f9db20\"\n\t\t       \"41eeddd7e8da67e4a2e65d0029c45ecacea6002f9540eb10\"\n\t\t       \"04c883a8f900fd84a98b5c449ac49c56f3a91d8bed3f08f4\"\n\t\t       \"27935fbe437ce46f75cd666a0707265c61a096698dc2f36b\"\n\t\t       \"28c65ec7b6e475c8b67ddfb444b2ee6a984e9d6d15233e25\"\n\t\t       \"e44bd8d7924d129d\"),\n\t\t  &signature);\n\n  /* L=2048, N=224, SHA-1 */\n  mpz_set_str(pub.p,\n\t      \"f2d39ed3062b13c916273600a0f2a029e86d7a4b9217b4f1\"\n\t      \"815bf2b24d9710a57ab33f997294b014585b8d0198dfdccb\"\n\t      \"cd75314da5ff85aa344b45adaeaa979b51a312a7bfa94472\"\n\t      \"fb633f1a6f156bb4458867dfd38403f06b851f00fe2d3484\"\n\t      \"077bded71ab7513d04a140220575fb693395480e4c8402b7\"\n\t      \"a46cec2d37a778c305accd1f13e9f62e865315f4b22cc467\"\n\t      \"c8986ec8e4961ddf810566b0c4ee369ac6aa15e43f474400\"\n\t      \"5826f5bde8071a19e30b6909aac4b3d174237270dad02799\"\n\t      \"d09b8a2cc5f22e66894b5422228b2c234f11f5a771c5b89c\"\n\t      \"f465a2acecbbeeaa1725fe8f9b59422be8991052cb556ddf\"\n\t      \"2c8ce8fa9206dbf39feadc194e00f8e5\", 16);\n  mpz_set_str(pub.q,\n\t      \"8000000000000000c118f49835e4ef733c4d15800fcf059e884d31b1\", 16);\n  mpz_set_str(pub.g,\n\t      \"e3a93c09da6f560e4d483a382a4c546f2335c36a4c35ac14\"\n\t      \"63c08a3e6dd415df56fdc537f25fd5372be63e4f5300780b\"\n\t      \"782f1acd01c8b4eb33414615fd0ea82573acba7ef83f5a94\"\n\t      \"3854151afc2d7dfe121fb8cd03335b065b549c5dcc606be9\"\n\t      \"052483bc284e12ac3c8dba09b426e08402030e70bc1cc2bf\"\n\t      \"8957c4ba0630f3f32ad689389ac47443176063f247d9e229\"\n\t      \"6b3ea5b5bc2335828ea1a080ed35918dee212fd031279d1b\"\n\t      \"894f01afec523833669eac031a420e540ba1320a59c424a3\"\n\t      \"e5849a460a56bcb001647885b1433c4f992971746bfe2977\"\n\t      \"ce7259c550b551a6c35761e4a41af764e8d92132fcc0a59d\"\n\t      \"1684eab90d863f29f41cf7578faa908c\", 16);\n  mpz_set_str(pub.y,\n\t      \"289ff18c32a56bb0b8839370647683a38a5a7e291410b932\"\n\t      \"07212adc8088d30f93e9e4abc523f3d46936e7d5c90d8874\"\n\t      \"2b36afd37563408f15c8c1a4f7ac24bf05f01008ffee70c8\"\n\t      \"825d57c3a9308bad8a095af2b53b2dda3cbed846d95e301e\"\n\t      \"b9b84766415d11f6c33209a0d28571096ab04a79aa0dc465\"\n\t      \"997529686b68e887cd8a205c2dc8195aef0422eba9979f54\"\n\t      \"9ac85548e419413643b7244361153ada1480d238cd00dc16\"\n\t      \"527938955548dd5d027ded1029eeeb8ed6c61b4cd59341d8\"\n\t      \"b15466e9da890a989996f4d7691e6072de136af28b5874bf\"\n\t      \"08bd1f8a60cfb1c00888132909f515e04bce81b02951aa41\"\n\t      \"baac68ffdb8c5dc77a1d32d8f2c10dd7\", 16);\n  mpz_set_str(signature.r,\n\t      \"45df2f423e94bf155dd4e1d9e63f315ea606dd38527d4cf6328738c8\", 16);\n  mpz_set_str(signature.s,\n\t      \"59b3e8efa5bc0ccbf4a3cbb6515c4b9bf784cfacdcc101dc9f81d31f\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha1,\n\t\t  SHEX(\"edc6fd9b6c6e8a59f283016f7f29ee16deeaa609b5737927\"\n\t\t       \"162aef34fed985d0bcb550275637ba67831a2d4efccb3529\"\n\t\t       \"6dfe730f4a0b4f4728d1d7d1bb8f4a36238a5c94311fa113\"\n\t\t       \"4a93a6b4de39c085e9f60ae4e237c0416d58042bb36baa38\"\n\t\t       \"cba8c896295b745d5376fd8ce42eb6ee5a1b38f87716b265\"\n\t\t       \"b76e58cfb24a9170\"),\n\t\t  &signature);\n  /* L=2048, N=224, SHA-224 */\n  mpz_set_str(pub.p,\n\t      \"aa815c9db1c4d3d2773c7d0d4d1da75ecfc4a39e97d5fa19\"\n\t      \"1ffec8b1490a290ce335e5ce87ea620a8a17de0bb64714e2\"\n\t      \"ec840bf00e6ebdb4ffb4e324ca07c3c8717309af1410362a\"\n\t      \"772c9add838b2b0cae1e90ab448adabdacd2e5df59c4187a\"\n\t      \"32a23719d6c57e9400885383bf8f066f23b941920d54c35b\"\n\t      \"4f7cc5044f3b40f17046956307b748e840732844d00a9ce6\"\n\t      \"ec5714293b6265147f15c67f4be38b082b55fdeadb612468\"\n\t      \"9fb76f9d25cc28b8eaa98b562d5c1011e0dcf9b39923240d\"\n\t      \"332d89dc9603b7bddd0c70b83caa2905631b1c83cabbae6c\"\n\t      \"0c0c2efe8f58131ed8351bf93e875f6a73a93cbad470141a\"\n\t      \"2687fbacf2d71c8ddee971ad660729ad\", 16);\n  mpz_set_str(pub.q,\n\t      \"ea347e90be7c2875d1fe1db622b4763837c5e27a6037310348c1aa11\", 16);\n  mpz_set_str(pub.g,\n\t      \"2042094ccbc8b8723fc928c12fda671b83295e99c743576f\"\n\t      \"44504be1186323319b5002d24f173df909ea241d6ea52899\"\n\t      \"04ee4636204b2fbe94b068fe093f7962579549551d3af219\"\n\t      \"ad8ed19939eff86bcec834de2f2f78596e89e7cb52c524e1\"\n\t      \"77098a56c232eb1f563aa84bc6b026deee6ff51cb441e080\"\n\t      \"f2dafaea1ced86427d1c346be55c66803d4b76d133cd445b\"\n\t      \"4c3482fa415023463c9bf30f2f784223e26057d3aa0d7fbb\"\n\t      \"660630c52e49d4a0325c7389e072aa349f13c966e159752f\"\n\t      \"bb71e9336890f93243fa6e72d299365ee5b3fe266ebf1110\"\n\t      \"568fee4425c847b50210bd484b97431a42856adca3e7d1a9\"\n\t      \"c9c675c7e266918320dd5a78a48c48a9\", 16);\n  mpz_set_str(pub.y,\n\t      \"1ae10c786ad0902c5c685dae5c7121418a377b888b5f2f2b\"\n\t      \"c76623570fd62bcb190b471ad5359c5f062f8819289e956d\"\n\t      \"8aa6f90d1f8cf1ee72d3a1bdfd56c478dc29a19c4569b5a6\"\n\t      \"0e3a8f34f60656eac5b25dde5514a5c67b675423204f6cca\"\n\t      \"f0990617cc7355b9d3ed868978a252020a769ed59a6edaa6\"\n\t      \"efe3377eef45f3f6f3e64179cc7db8b143fb835c5d71bfcf\"\n\t      \"a1e2a9049bccf7fe9ab57546220fe3f4b7521c861739d138\"\n\t      \"507e81a46a6993605441dcb90d6ee4afbc42cabe90a25444\"\n\t      \"4968109d7edd9694a023239f1d56175dd1fac115915e24fa\"\n\t      \"b563f4fc3f269bed2f300832d112596485a711417aa73bb4\"\n\t      \"ac72a651a1fa5baed3636c720d397008\", 16);\n  mpz_set_str(signature.r,\n\t      \"65102e8f64ecb11f06017b1a0c0def3c29897c277c4a948b1f4da6b9\", 16);\n  mpz_set_str(signature.s,\n\t      \"21ad0abb27bd3c21166cb96aef70c0dbd5f3079cab0dd543d4125bd1\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha224,\n\t\t  SHEX(\"e920fc1610718f2b0213d301c0092a51f3c6b0107bbbd824\"\n\t\t       \"3a9689c044e2d142f202d9d195a5faef4be5acadc9ff6f7d\"\n\t\t       \"2261e58b517139bcb9489b110423c2e59eb181294ffdae8a\"\n\t\t       \"ad0e624fab974c97f9f5e7dc19d678a9cb3429cf05ec5090\"\n\t\t       \"72856f5adfec6e29bafe8e5ba95593e612843e343111d88a\"\n\t\t       \"1eaff7dc0a2e277f\"),\n\t\t  &signature);\n\n  /* mod = L=2048, N=224, SHA-256 */\n  mpz_set_str(pub.p,\n\t      \"a4c7eaab42c4c73b757770916489f17cd50725cd0a4bc4e1\"\n\t      \"cf67f763b8c1de2d6dab9856baafb008f365b18a42e14dc5\"\n\t      \"1f350b88eca0209c5aa4fd71a7a96c765f5901c21e720570\"\n\t      \"d7837bec7c76d2e49344731ca39405d0a879b9e0dcd1a812\"\n\t      \"5fd130ec1e783e654b94e3002e6b629e904ab3877867720c\"\n\t      \"bd54b4270a9e15cd028c7cc796f06c272a660951928fdbeb\"\n\t      \"2dca061b41e932257305742ff16e2f429191d5e5f1a6ddf6\"\n\t      \"e78c5d7722cff80a9c0bd5c8d7aeba8c04438992b075e307\"\n\t      \"c1534c49ad380f477f5f7987dc172c161dca38dcaf3fb384\"\n\t      \"6c72c9119a5299adc748951b3dce0d00d4a9013800b20082\"\n\t      \"03b72465bc6a84ae059a30c4522dea57\", 16);\n  mpz_set_str(pub.q,\n\t      \"ce89fe332b8e4eb3d1e8ddcea5d163a5bc13b63f16993755427aef43\", 16);\n  mpz_set_str(pub.g,\n\t      \"8c465edf5a180730291e080dfc5385397a5006450dba2efe\"\n\t      \"0129264fbd897bb5579ca0eab19aa278220424724b4f2a6f\"\n\t      \"6ee6328432abf661380646097233505339c5519d357d7112\"\n\t      \"b6eec938b85d5aa75cc2e38092f0a530acb54e50fe82c4d5\"\n\t      \"62fb0f3036b80b30334023ebbe6637a0010b00c7db863711\"\n\t      \"68563671e1e0f028aedbd45d2d572621a609982a073e51aa\"\n\t      \"e27707afbeef29e2ecee84d7a6d5da382be3a35f42b6c668\"\n\t      \"49202ab19d025b869d08776476d1ab981475ad2ad2f3e6fd\"\n\t      \"07e30696d90a626816df60d6ca7afd7b482f942f83b45cc8\"\n\t      \"2933731f87faee320900f2aa3e70b1867e1430e40be67c07\"\n\t      \"f9290299ef067b8b24a7515b3f992c07\", 16);\n  mpz_set_str(pub.y,\n\t      \"748a40237211a2d9852596e7a891f43d4eb0ee48826c9cfb\"\n\t      \"336bbb68dbe5a5e16b2e1271d4d13de03644bb85ef6be523\"\n\t      \"a4d4d88415bcd596ba8e0a3c4f6439e981ed013d7d9c7033\"\n\t      \"6febf7d420cfed02c267457bb3f3e7c82145d2af54830b94\"\n\t      \"2ec74a5d503e4226cd25dd75decd3f50f0a858155d7be799\"\n\t      \"410836ddc559ce99e1ae513808fdaeac34843dd7258f16f6\"\n\t      \"7f19205f6f139251a4186da8496d5e90d3fecf8ed10be6c2\"\n\t      \"5ff5eb33d960c9a8f4c581c8c724ca43b761e9fdb5af66bf\"\n\t      \"fb9d2ebb11a6b504a1fbe4f834ecb6ac254cab513e943b9a\"\n\t      \"953a7084b3305c661bfad434f6a835503c9ade7f4a57f5c9\"\n\t      \"65ec301ecde938ee31b4deb038af97b3\", 16);\n  mpz_set_str(signature.r,\n\t      \"9c5fa46879ddaf5c14f07dfb5320715f67a6fec179e3ad53342fb6d1\", 16);\n  mpz_set_str(signature.s,\n\t      \"c3e17e7b3c4d0ac8d49f4dd0f04c16a094f42da0afcc6c90f5f1bbc8\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha256,\n\t\t  SHEX(\"cec8d2843dee7cb5f9119b75562585e05c5ce2f4e6457e9b\"\n\t\t       \"cc3c1c781ccd2c0442b6282aea610f7161dcede176e77486\"\n\t\t       \"1f7d2691be6c894ac3ebf80c0fab21e52a3e63ae0b350257\"\n\t\t       \"62ccd6c9e1fecc7f9fe00aa55c0c3ae33ae88f66187f9598\"\n\t\t       \"eba9f863171f3f56484625bf39d883427349b8671d9bb7d3\"\n\t\t       \"96180694e5b546ae\"),\n\t\t  &signature);\n  \n  /* L=2048, N=256, SHA-1 */\n  mpz_set_str(pub.p,\n\t      \"c1a59d215573949e0b20a974c2edf2e3137ff2463062f75f\"\n\t      \"1d13df12aba1076bb2d013402b60af6c187fb0fa362167c9\"\n\t      \"76c2617c726f9077f09e18c11b60f65008825bd6c02a1f57\"\n\t      \"d3eb0ad41cd547de43d87f2525f971d42b306506e7ca03be\"\n\t      \"63b35f4ada172d0a06924440a14250d7822ac2d5aeafed46\"\n\t      \"19e79d4158a7d5eb2d9f023db181a8f094b2c6cb87cb8535\"\n\t      \"416ac19813f07144660c557745f44a01c6b1029092c129b0\"\n\t      \"d27183e82c5a21a80177ee7476eb95c466fb472bd3d2dc28\"\n\t      \"6ce25847e93cbfa9ad39cc57035d0c7b64b926a9c7f5a7b2\"\n\t      \"bc5abcbfbdc0b0e3fede3c1e02c44afc8aefc7957da07a0e\"\n\t      \"5fd12339db8667616f62286df80d58ab\", 16);\n  mpz_set_str(pub.q,\n\t      \"8000000000000000000000001bd62c65e8b87c89797f8f0c\"\n\t      \"bfa55e4a6810e2c7\", 16);\n  mpz_set_str(pub.g,\n\t      \"aea5878740f1424d3c6ea9c6b4799615d2749298a17e2620\"\n\t      \"7f76cef340ddd390e1b1ad6b6c0010ad015a103342ddd452\"\n\t      \"cac024b36e42d9b8ed52fafae7a1d3ce9e4b21f910d1356e\"\n\t      \"b163a3e5a8184c781bf14492afa2e4b0a56d8884fd01a628\"\n\t      \"b9662739c42e5c5795ade2f5f27e6de1d963917ce8806fc4\"\n\t      \"0d021cd87aa3aa3a9e4f0c2c4c45d2959b2578b2fb1a2229\"\n\t      \"c37e181059b9d5e7b7862fa82e2377a49ed0f9dca820a581\"\n\t      \"4079dd6610714efaf8b0cc683d8e72e4c884e6f9d4946b3e\"\n\t      \"8d4cbb92adbbe7d4c47cc30be7f8c37ca81883a1aac68600\"\n\t      \"59ff4640a29ccae73de20b12e63b00a88b2ee9ba94b75eb4\"\n\t      \"0a656e15d9ec83731c85d0effcb9ef9f\", 16);\n  mpz_set_str(pub.y,\n\t      \"880e17c4ae8141750609d8251c0bbd7acf6d0b460ed3688e\"\n\t      \"9a5f990e6c4b5b00875da750e0228a04102a35f57e74b8d2\"\n\t      \"f9b6950f0d1db8d302c5c90a5b8786a82c68ff5b17a57a75\"\n\t      \"8496c5f8053e4484a253d9942204d9a1109f4bd2a3ec311a\"\n\t      \"60cf69c685b586d986f565d33dbf5aab7091e31aa4102c4f\"\n\t      \"4b53fbf872d700156465b6c075e7f778471a23502dc0fee4\"\n\t      \"1b271c837a1c26691699f3550d060a331099f64837cddec6\"\n\t      \"9caebf51bf4ec9f36f2a220fe773cb4d3c02d0446ddd4613\"\n\t      \"3532ef1c3c69d432e303502bd05a75279a7809a742ac4a78\"\n\t      \"72b07f1908654049419350e37a95f2ef33361d8d8736d408\"\n\t      \"3dc14c0bb972e14d4c7b97f3ddfccaef\", 16);\n  mpz_set_str(signature.r,\n\t      \"363e01c564f380a27d7d23b207af3f961d48fc0995487f60\"\n\t      \"052775d724ab3d10\", 16);\n  mpz_set_str(signature.s,\n\t      \"4916d91b2927294e429d537c06dd2463d1845018cca2873e\"\n\t      \"90a6c837b445fdde\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha1,\n\t\t  SHEX(\"de3605dbefde353cbe05e0d6098647b6d041460dfd4c0003\"\n\t\t       \"12be1afe7551fd3b93fed76a9763c34e004564b8f7dcacbd\"\n\t\t       \"99e85030632c94e9b0a032046523b7aacdf934a2dbbdcfce\"\n\t\t       \"efe66b4e3d1cb29e994ff3a4648a8edd9d58ed71f12399d9\"\n\t\t       \"0624789c4e0eebb0fbd5080f7d730f875a1f290749334cb4\"\n\t\t       \"05e9fd2ae1b4ed65\"),\n\t\t  &signature);\n\n  /* L=2048, N=256, SHA-224 */\n  mpz_set_str(pub.p,\n\t      \"d02276ebf3c22ffd666983183a47ae94c9bccbcbf95ddcb4\"\n\t      \"91d1f7ce643549199992d37c79e7b032d26ed031b6ba4489\"\n\t      \"f3125826fafb2726a98333ebd9abdde592d8693d9859536d\"\n\t      \"9cc3841a1d24e044d35aced6136256fc6d6b615cf4f4163a\"\n\t      \"a381eb2b4c480825a8eccc56d8ddcf5fe637e38ad9b2974b\"\n\t      \"d2cf68bf271e0d067d2465a8b6b660524f0082598945ada5\"\n\t      \"8ea649b9804eb4753408c2c59768c46abb82e3295f3d9ca4\"\n\t      \"69f84cc187f572dc4b5a3b39346ec839dfad6f07d6d1f0e2\"\n\t      \"15209bb0ecc05c767cf2e7943ac9cfb02eee1e9ef5946e8c\"\n\t      \"e88316b5e15fdcf95a132ef2e4bb0817136528cfa5dd9653\"\n\t      \"2f9c3abe5c421620edb6bcbd52234ca9\", 16);\n  mpz_set_str(pub.q,\n\t      \"8000000012997e8285e4089708f528070c6d7af8a0bd0140\"\n\t      \"9e7a079cdb6fc5bb\", 16);\n  mpz_set_str(pub.g,\n\t      \"778453049ef262147fed7b59b0ee6764607c51e7b5b5fc6f\"\n\t      \"ea7a7a7b1dd6bb283f4a9ae98efd3964b1556758cb15b2a5\"\n\t      \"3af8619e74d85898bec77d3b3f382494ae5961a13ffc745d\"\n\t      \"a386182291519800f99dd710e00aeb15adee088e2798ee2e\"\n\t      \"46f598526cf0f4667055d1ba009750041dc5cdd2725ff1d9\"\n\t      \"7dd340c8518af7671b87d39d67aeced84b66f84e0701efc8\"\n\t      \"2a5c9ef954ee576d24c385b14d63037f0d866fd424b4975b\"\n\t      \"dd5485ed740cb932e843f906683f7c7b2c74775d901c361b\"\n\t      \"847b519c0da699638da40bd736b783d2710b2c2cc26ef912\"\n\t      \"71bf4e2c1929f876e902e2057164223bc78d6a2b9f6c0c7a\"\n\t      \"7cb85922f7d6c4287ae23861f8128848\", 16);\n  mpz_set_str(pub.y,\n\t      \"7bb31e98c7a0437f978a73d5dcfbdfbb09cc2499dfaf1eb5\"\n\t      \"256bccd6358cabb5f67d04a42823463b7e957f2b9213f1fa\"\n\t      \"8e5a98d614484701abb8c7d67641fe6ed06fa4527b493dda\"\n\t      \"b2e74640fde3de70da693f1db2b8e26417040af0eea6cab4\"\n\t      \"51a795a52e187d2ee241b93f65c86c6d66f45834cce165ac\"\n\t      \"5eb670d4f0095c23ce9757e3bdc636f991ee0073d90a0920\"\n\t      \"2edb35cc3ea1cf9adca1617fa0bffd9c126229a604a1d3bf\"\n\t      \"4931ddf0b9942dfc8a2f8c09fcc97032564a79ae1ebe1e2c\"\n\t      \"e49ff57839e7c43fa60b1603d15a450898aa4e4a1ee80657\"\n\t      \"94126d64f013367096a83686b9f158c33b10f5f3b36cf1f6\"\n\t      \"358b3f34f84b101dc26d3db68bcc95c8\", 16);\n  mpz_set_str(signature.r,\n\t      \"059bee9e708b7f20c3f791a640edee964e0aa672893c4847\"\n\t      \"99715817b3a8f6d4\", 16);\n  mpz_set_str(signature.s,\n\t      \"4bd41c84a724cc86e4f0194ec0fbf379e654d0d7f6a1f08b\"\n\t      \"d468139422a5c353\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha224,\n\t\t  SHEX(\"39f2d8d503aae8cd17854456ecfad49a18900d4375412bc6\"\n\t\t       \"89181ed9c2ccafea98dca689a72dc75e5367d3d3abfc2169\"\n\t\t       \"700d5891cff70f69d9aca093b061b9f5057f94636bc27831\"\n\t\t       \"15254344fb12e33b167272e198838a8728e7744ea9a2e824\"\n\t\t       \"8e34d5906e298302472637b879de91c1a6f9f331a5cf98a5\"\n\t\t       \"af29132990d27416\"),\n\t\t  &signature);\n  \n  /* L=2048, N=256, SHA-256 */\n  mpz_set_str(pub.p,\n\t      \"a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03\"\n\t      \"d814fe13a059705e663230a377bf7323a8fa117100200bfd\"\n\t      \"5adf857393b0bbd67906c081e585410e38480ead51684dac\"\n\t      \"3a38f7b64c9eb109f19739a4517cd7d5d6291e8af20a3fbf\"\n\t      \"17336c7bf80ee718ee087e322ee41047dabefbcc34d10b66\"\n\t      \"b644ddb3160a28c0639563d71993a26543eadb7718f317bf\"\n\t      \"5d9577a6156561b082a10029cd44012b18de6844509fe058\"\n\t      \"ba87980792285f2750969fe89c2cd6498db3545638d5379d\"\n\t      \"125dccf64e06c1af33a6190841d223da1513333a7c9d7846\"\n\t      \"2abaab31b9f96d5f34445ceb6309f2f6d2c8dde06441e879\"\n\t      \"80d303ef9a1ff007e8be2f0be06cc15f\", 16);\n  mpz_set_str(pub.q,\n\t      \"e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc\"\n\t      \"3f6e68604d6b9dfb\", 16);\n  mpz_set_str(pub.g,\n\t      \"5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd\"\n\t      \"82b19fa104abfb5d84579a623b2574b37d22ccae9b3e415e\"\n\t      \"48f5c0f9bcbdff8071d63b9bb956e547af3a8df99e5d3061\"\n\t      \"979652ff96b765cb3ee493643544c75dbe5bb39834531952\"\n\t      \"a0fb4b0378b3fcbb4c8b5800a5330392a2a04e700bb6ed7e\"\n\t      \"0b85795ea38b1b962741b3f33b9dde2f4ec1354f09e2eb78\"\n\t      \"e95f037a5804b6171659f88715ce1a9b0cc90c27f35ef2f1\"\n\t      \"0ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372f4240de\"\n\t      \"8347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d7\"\n\t      \"3f10397d2183f1ba3b7b45a68f1ff1893caf69a827802f7b\"\n\t      \"6a48d51da6fbefb64fd9a6c5b75c4561\", 16);\n  mpz_set_str(pub.y,\n\t      \"5a55dceddd1134ee5f11ed85deb4d634a3643f5f36dc3a70\"\n\t      \"689256469a0b651ad22880f14ab85719434f9c0e407e60ea\"\n\t      \"420e2a0cd29422c4899c416359dbb1e592456f2b3cce2332\"\n\t      \"59c117542fd05f31ea25b015d9121c890b90e0bad033be13\"\n\t      \"68d229985aac7226d1c8c2eab325ef3b2cd59d3b9f7de7db\"\n\t      \"c94af1a9339eb430ca36c26c46ecfa6c5481711496f624e1\"\n\t      \"88ad7540ef5df26f8efacb820bd17a1f618acb50c9bc197d\"\n\t      \"4cb7ccac45d824a3bf795c234b556b06aeb9291734532520\"\n\t      \"84003f69fe98045fe74002ba658f93475622f76791d9b262\"\n\t      \"3d1b5fff2cc16844746efd2d30a6a8134bfc4c8cc80a4610\"\n\t      \"7901fb973c28fc553130f3286c1489da\", 16);\n  mpz_set_str(signature.r,\n\t      \"633055e055f237c38999d81c397848c38cce80a55b649d9e\"\n\t      \"7905c298e2a51447\", 16);\n  mpz_set_str(signature.s,\n\t      \"2bbf68317660ec1e4b154915027b0bc00ee19cfc0bf75d01\"\n\t      \"930504f2ce10a8b0\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha256,\n\t\t  SHEX(\"4e3a28bcf90d1d2e75f075d9fbe55b36c5529b17bc3a9cca\"\n\t\t       \"ba6935c9e20548255b3dfae0f91db030c12f2c344b3a29c4\"\n\t\t       \"151c5b209f5e319fdf1c23b190f64f1fe5b330cb7c8fa952\"\n\t\t       \"f9d90f13aff1cb11d63181da9efc6f7e15bfed4862d1a62c\"\n\t\t       \"7dcf3ba8bf1ff304b102b1ec3f1497dddf09712cf323f561\"\n\t\t       \"0a9d10c3d9132659\"),\n\t\t  &signature);\n  \n  /* L=2048, N=256, SHA-384 */\n  mpz_set_str(pub.p,\n\t      \"a6167c16fff74e29342b8586aed3cd896f7b1635a2286ff1\"\n\t      \"6fdff41a06317ca6b05ca2ba7c060ad6db1561621ccb0c40\"\n\t      \"b86a03619bfff32e204cbd90b79dcb5f86ebb493e3bd1988\"\n\t      \"d8097fa23fa4d78fb3cddcb00c466423d8fa719873c37645\"\n\t      \"fe4eecc57171bbedfe56fa9474c96385b8ba378c79972d7a\"\n\t      \"aae69a2ba64cde8e5654f0f7b74550cd3447e7a472a33b40\"\n\t      \"37db468dde31c348aa25e82b7fc41b837f7fc226a6103966\"\n\t      \"ecd8f9d14c2d3149556d43829f137451b8d20f8520b0ce8e\"\n\t      \"3d705f74d0a57ea872c2bdee9714e0b63906cddfdc28b677\"\n\t      \"7d19325000f8ed5278ec5d912d102109319cba3b6469d467\"\n\t      \"2909b4f0dbeec0bbb634b551ba0cf213\", 16);\n  mpz_set_str(pub.q,\n\t      \"8427529044d214c07574f7b359c2e01c23fd97701b328ac8\"\n\t      \"c1385b81c5373895\", 16);\n  mpz_set_str(pub.g,\n\t      \"6fc232415c31200cf523af3483f8e26ace808d2f1c6a8b86\"\n\t      \"3ab042cc7f6b7144b2d39472c3cb4c7681d0732843503d8f\"\n\t      \"858cbe476e6740324aaa295950105978c335069b919ff9a6\"\n\t      \"ff4b410581b80712fe5d3e04ddb4dfd26d5e7fbca2b0c52d\"\n\t      \"8d404343d57b2f9b2a26daa7ece30ceab9e1789f9751aaa9\"\n\t      \"387049965af32650c6ca5b374a5ae70b3f98e053f51857d6\"\n\t      \"bbb17a670e6eaaf89844d641e1e13d5a1b24d053dc6b8fd1\"\n\t      \"01c624786951927e426310aba9498a0042b3dc7bbc59d705\"\n\t      \"f80d9b807de415f7e94c5cf9d789992d3bb8336d1d808cb8\"\n\t      \"6b56dde09d934bb527033922de14bf307376ab7d22fbcd61\"\n\t      \"6f9eda479ab214a17850bdd0802a871c\", 16);\n  mpz_set_str(pub.y,\n\t      \"5ca7151bca0e457bbc46f59f71d81ab16688dc0eb7e4d17b\"\n\t      \"166c3326c5b12c5bdebb3613224d1a754023c50b83cb5ecc\"\n\t      \"139096cef28933b3b12ca31038e4089383597c59cc27b902\"\n\t      \"be5da62cae7da5f4af90e9410ed1604082e2e38e25eb0b78\"\n\t      \"dfac0aeb2ad3b19dc23539d2bcd755db1cc6c9805a7dd109\"\n\t      \"e1c98667a5b9d52b21c2772121b8d0d2b246e5fd3da80728\"\n\t      \"e85bbf0d7067d1c6baa64394a29e7fcbf80842bd4ab02b35\"\n\t      \"d83f59805a104e0bd69d0079a065f59e3e6f21573a00da99\"\n\t      \"0b72ea537fa98caaa0a58800a7e7a0623e263d4fca65ebb8\"\n\t      \"eded46efdfe7db92c9ebd38062d8f12534f015b186186ee2\"\n\t      \"361d62c24e4f22b3e95da0f9062ce04d\", 16);\n  mpz_set_str(signature.r,\n\t      \"4fd8f25c059030027381d4167c3174b6be0088c15f0a573d\"\n\t      \"7ebd05960f5a1eb2\", 16);\n  mpz_set_str(signature.s,\n\t      \"5f56869cee7bf64fec5d5d6ea15bb1fa1169003a87eccc16\"\n\t      \"21b90a1b892226f2\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha384,\n\t\t  SHEX(\"8c78cffdcf25d8230b835b30512684c9b252115870b603d1\"\n\t\t       \"b4ba2eb5d35b33f26d96b684126ec34fff67dfe5c8c856ac\"\n\t\t       \"fe3a9ff45ae11d415f30449bcdc3bf9a9fb5a7e48afeaba6\"\n\t\t       \"d0b0fc9bce0197eb2bf7a840249d4e550c5a25dc1c71370e\"\n\t\t       \"67933edad2362fae6fad1efba5c08dc1931ca2841b44b78c\"\n\t\t       \"0c63a1665ffac860\"),\n\t\t  &signature);\n\n  /* L=3072, N=256, SHA-1 */\n  mpz_set_str(pub.p,\n\t      \"fd5a6c56dd290f7dd84a29de17126eb4e4487b3eff0a44ab\"\n\t      \"e5c59792d2e1200b9c3db44d528b9f7d2248032e4ba0f7bf\"\n\t      \"c4fafc706be511db2276c0b7ecffd38da2e1c2f237a75390\"\n\t      \"c1e4d3239cba8e20e55840ecb05df5f01a1b6977ad1906f2\"\n\t      \"cb544ccfb93b901ad0966b1832ad2dab526244a3156c905c\"\n\t      \"01ac51cb73b9dcd9860d56175a425d846485d9b1f44a8a0c\"\n\t      \"2578e6cf61947bc1a1392fdd320b16a9d70455fe436f2d47\"\n\t      \"ded8e8e605f7486eb578ea7fc4ffd13c07f9996af159fd41\"\n\t      \"1e9451403278dd1141a8c926b35c96384bbd6bee09c46f44\"\n\t      \"c36b1ffc7197f5e925dbe0544a68e6ab8c18e426a466b392\"\n\t      \"f9c27dd79fefa9ca163cc5a375539a8559f277f657a535d1\"\n\t      \"964c6a5e91683ef5698ebaa01ef818dbf72cb04c3ff092d1\"\n\t      \"88866f25cd405108f566b087f73d2d5beb51fac6de84ae51\"\n\t      \"61a66af9602c7e4bfc146f4820bdfc092faeac69133e4a08\"\n\t      \"a5b202a12498a22e57bad54674ed4b510109d52b5f74e70e\"\n\t      \"1f6f82161718cd4cf00cc9f1958acc8bddcdfbd1fbe46cd1\", 16);\n  mpz_set_str(pub.q,\n\t      \"800000000000000000000000334a26dd8f49c6811ce81bb1\"\n\t      \"342b06e980f64b75\", 16);\n  mpz_set_str(pub.g,\n\t      \"99ab030a21a5c9818174872167641c81c1e03c9b274cfbc2\"\n\t      \"7bc472542927766de5fa0539b3b73f3f16ac866a9aec8b44\"\n\t      \"5ded97fbff08834ed98c77e7fc89e5dc657bef766ff7fbf8\"\n\t      \"e76873e17bee412762d56fe1141760ab4d25bafd4b6ef25b\"\n\t      \"49a3506632d1f8e10770930760ec1325932c5a4baf9e9015\"\n\t      \"4264ddf442ec5c41fed95d11525151dbcfb3758149bad81c\"\n\t      \"62b9cff7816b8f953b8b7c022590d1584e921dc955f5328a\"\n\t      \"c72983ed5cf0d04056fe0d531e62f8f6c9ab3c0fcd44e148\"\n\t      \"60b7311d2561c77c1d32f6c69dc8f77968c9d881ad9db5e0\"\n\t      \"c114fda8628bca0335eb7fb9e15e625aabab58fc01194c81\"\n\t      \"bf6fb2ce54077b82250e57c6a7b25deb6ee39d4b686a5c30\"\n\t      \"7a7612b2d85ee92512413dea297e44f317be7ceb70a3328a\"\n\t      \"f0b401001a418562b8ffe4e9771b4b4a8e0b40c791349d5d\"\n\t      \"4e459fe620a1a2fc72e2f6ca28567d4c2632bbde1b49864c\"\n\t      \"06bb12619f132c1da8f571ef613eac739f66ab3914cb3fa1\"\n\t      \"ab86e05e5082ebaa24ebeea4cf51beefc27df512fe3fee7d\", 16);\n  mpz_set_str(pub.y,\n\t      \"e7c2ee18c3aa362c0182c6a56c2584628083c73e045beda8\"\n\t      \"d653690c9c2f6544edf9702c57c455273905336a5f517110\"\n\t      \"7a313cd7d0b0f50f8d3342c60219f22a9023394059d05f46\"\n\t      \"4c4496d55dab6eb0898527ff4cf5678e7b5bfb5e18d92c4a\"\n\t      \"9d73288cce14530fc4702f6d0397ec39a880c4a72d358730\"\n\t      \"c56633386ede028023c1791f3164d1574e7823c79b8a3ca1\"\n\t      \"343ea166ba6f02b7ff7e9ef2198db107f7cc159f3b6a1c00\"\n\t      \"a78c355c566deb0ac6fde3f633cb9177a1fbc6c1766ca021\"\n\t      \"d5fec470101abb440d2f06982181a8c92b7cdd765336b9a1\"\n\t      \"e1ab70283d6db0a963fb648c37c4e29a74c37577291049ab\"\n\t      \"47cdbc104c04db966681ea8ebb9f00cf4c4a546211737957\"\n\t      \"5fbda4b801979451fa94b19b4e93656705c0f734f3e0914b\"\n\t      \"b96c1e2b8a0fb68faf14296efdf3300ad95bcde8b67cc4b2\"\n\t      \"6e6488eef925cfaeac6f0d6567e8b41355f89d1c2b8fe687\"\n\t      \"bfa2df5e287e1305b89b8c388c26196090ac0351abc561aa\"\n\t      \"dc797da8ccea4146c3e96095ebce353e0da4c55019052caa\", 16);\n  mpz_set_str(signature.r,\n\t      \"21ca148cdf44be4ae93b2f353b8e512d03ad96dafa80623f\"\n\t      \"de4922a95f032732\", 16);\n  mpz_set_str(signature.s,\n\t      \"73e48b77a3aa44307483c2dd895cb51db2112177c185c59c\"\n\t      \"b1dcff32fda02a4f\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha1,\n\t\t  SHEX(\"ca84af5c9adbc0044db00d7acfb1b493aab0388ffbad47b3\"\n\t\t       \"8cd3e9e3111cfe2cda2a45f751c46862f05bdcec4b698adf\"\n\t\t       \"d2e1606e484c3be4ac0c379d4fbc7c2cda43e922811d7f6c\"\n\t\t       \"33040e8e65d5f317684b90e26387cf931fe7c2f515058d75\"\n\t\t       \"3b08137ff2c6b79c910de8283149e6872cb66f7e02e66f23\"\n\t\t       \"71785129569362f1\"),\n\t\t  &signature);\n\n  /* L=3072, N=256, SHA-256 */\n  mpz_set_str(pub.p,\n\t      \"c7b86d7044218e367453d210e76433e4e27a983db1c560bb\"\n\t      \"9755a8fb7d819912c56cfe002ab1ff3f72165b943c0b28ed\"\n\t      \"46039a07de507d7a29f738603decd1270380a41f971f2592\"\n\t      \"661a64ba2f351d9a69e51a888a05156b7fe1563c4b77ee93\"\n\t      \"a44949138438a2ab8bdcfc49b4e78d1cde766e5498476005\"\n\t      \"7d76cd740c94a4dd25a46aa77b18e9d707d6738497d4eac3\"\n\t      \"64f4792d9766a16a0e234807e96b8c64d404bbdb876e39b5\"\n\t      \"799ef53fe6cb9bab62ef19fdcc2bdd905beda13b9ef7ac35\"\n\t      \"f1f557cb0dc458c019e2bc19a9f5dfc1e4eca9e6d4665641\"\n\t      \"24304a31f038605a3e342da01be1c2b545610edd2c1397a3\"\n\t      \"c8396588c6329efeb4e165af5b368a39a88e4888e39f40bb\"\n\t      \"3de4eb1416672f999fead37aef1ca9643ff32cdbc0fcebe6\"\n\t      \"28d7e46d281a989d43dd21432151af68be3f6d56acfbdb6c\"\n\t      \"97d87fcb5e6291bf8b4ee1275ae0eb4383cc753903c8d29f\"\n\t      \"4adb6a547e405decdff288c5f6c7aa30dcb12f84d392493a\"\n\t      \"70933317c0f5e6552601fae18f17e6e5bb6bf396d32d8ab9\", 16);\n  mpz_set_str(pub.q,\n\t      \"876fa09e1dc62b236ce1c3155ba48b0ccfda29f3ac5a97f7\"\n\t      \"ffa1bd87b68d2a4b\", 16);\n  mpz_set_str(pub.g,\n\t      \"110afebb12c7f862b6de03d47fdbc3326e0d4d31b12a8ca9\"\n\t      \"5b2dee2123bcc667d4f72c1e7209767d2721f95fbd9a4d03\"\n\t      \"236d54174fbfaff2c4ff7deae4738b20d9f37bf0a1134c28\"\n\t      \"8b420af0b5792e47a92513c0413f346a4edbab2c45bdca13\"\n\t      \"f5341c2b55b8ba54932b9217b5a859e553f14bb8c120fbb9\"\n\t      \"d99909dff5ea68e14b379964fd3f3861e5ba5cc970c4a180\"\n\t      \"eef54428703961021e7bd68cb637927b8cbee6805fa27285\"\n\t      \"bfee4d1ef70e02c1a18a7cd78bef1dd9cdad45dde9cd6907\"\n\t      \"55050fc4662937ee1d6f4db12807ccc95bc435f11b71e708\"\n\t      \"6048b1dab5913c6055012de82e43a4e50cf93feff5dcab81\"\n\t      \"4abc224c5e0025bd868c3fc592041bba04747c10af513fc3\"\n\t      \"6e4d91c63ee5253422cf4063398d77c52fcb011427cbfcfa\"\n\t      \"67b1b2c2d1aa4a3da72645cb1c767036054e2f31f88665a5\"\n\t      \"4461c885fb3219d5ad8748a01158f6c7c0df5a8c908ba8c3\"\n\t      \"e536822428886c7b500bbc15b49df746b9de5a78fe3b4f69\"\n\t      \"91d0110c3cbff458039dc36261cf46af4bc2515368f4abb7\", 16);\n  mpz_set_str(pub.y,\n\t      \"456a105c713566234838bc070b8a751a0b57767cb75e9911\"\n\t      \"4a1a46641e11da1fa9f22914d808ad7148612c1ea55d2530\"\n\t      \"1781e9ae0c9ae36a69d87ba039ec7cd864c3ad094873e6e5\"\n\t      \"6709fd10d966853d611b1cff15d37fdee424506c184d62c7\"\n\t      \"033358be78c2250943b6f6d043d63b317de56e5ad8d1fd97\"\n\t      \"dd355abe96452f8e435485fb3b907b51900aa3f24418df50\"\n\t      \"b4fcdafbf6137548c39373b8bc4ba3dabb4746ebd17b87fc\"\n\t      \"d6a2f197c107b18ec5b465e6e4cb430d9c0ce78da5988441\"\n\t      \"054a370792b730da9aba41a3169af26176f74e6f7c0c9c9b\"\n\t      \"55b62bbe7ce38d4695d48157e660c2acb63f482f55418150\"\n\t      \"e5fee43ace84c540c3ba7662ae80835c1a2d51890ea96ba2\"\n\t      \"06427c41ef8c38aa07d2a365e7e58380d8f4782e22ac2101\"\n\t      \"af732ee22758337b253637838e16f50f56d313d07981880d\"\n\t      \"685557f7d79a6db823c61f1bb3dbc5d50421a4843a6f2969\"\n\t      \"0e78aa0f0cff304231818b81fc4a243fc00f09a54c466d6a\"\n\t      \"8c73d32a55e1abd5ec8b4e1afa32a79b01df85a81f3f5cfe\", 16);\n  mpz_set_str(signature.r,\n\t      \"53bae6c6f336e2eb311c1e92d95fc449a929444ef81ec427\"\n\t      \"9660b200d59433de\", 16);\n  mpz_set_str(signature.s,\n\t      \"49f3a74e953e77a7941af3aefeef4ed499be209976a0edb3\"\n\t      \"fa5e7cb961b0c112\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha256,\n\t\t  SHEX(\"cb06e02234263c22b80e832d6dc5a1bee5ea8af3bc2da752\"\n\t\t       \"441c04027f176158bfe68372bd67f84d489c0d49b07d4025\"\n\t\t       \"962976be60437be1a2d01d3be0992afa5abe0980e26a9da4\"\n\t\t       \"ae72f827b423665195cc4eed6fe85c335b32d9c03c945a86\"\n\t\t       \"e7fa99373f0a30c6eca938b3afb6dff67adb8bece6f8cfec\"\n\t\t       \"4b6a12ea281e2323\"),\n\t\t  &signature);\n\n  /* L=3072, N=256, SHA-384 */\n  mpz_set_str(pub.p,\n\t      \"a410d23ed9ad9964d3e401cb9317a25213f75712acbc5c12\"\n\t      \"191abf3f1c0e723e2333b49eb1f95b0f9748d952f04a5ae3\"\n\t      \"58859d384403ce364aa3f58dd9769909b45048548c55872a\"\n\t      \"6afbb3b15c54882f96c20df1b2df164f0bac849ca17ad2df\"\n\t      \"63abd75c881922e79a5009f00b7d631622e90e7fa4e98061\"\n\t      \"8575e1d6bd1a72d5b6a50f4f6a68b793937c4af95fc11541\"\n\t      \"759a1736577d9448b87792dff07232415512e933755e1225\"\n\t      \"0d466e9cc8df150727d747e51fea7964158326b1365d580c\"\n\t      \"b190f4518291598221fdf36c6305c8b8a8ed05663dd7b006\"\n\t      \"e945f592abbecae460f77c71b6ec649d3fd5394202ed7bbb\"\n\t      \"d040f7b8fd57cb06a99be254fa25d71a3760734046c2a0db\"\n\t      \"383e02397913ae67ce65870d9f6c6f67a9d00497be1d763b\"\n\t      \"21937cf9cbf9a24ef97bbcaa07916f8894e5b7fb03258821\"\n\t      \"ac46140965b23c5409ca49026efb2bf95bce025c4183a5f6\"\n\t      \"59bf6aaeef56d7933bb29697d7d541348c871fa01f869678\"\n\t      \"b2e34506f6dc0a4c132b689a0ed27dc3c8d53702aa584877\", 16);\n  mpz_set_str(pub.q,\n\t      \"abc67417725cf28fc7640d5de43825f416ebfa80e191c42e\"\n\t      \"e886303338f56045\", 16);\n  mpz_set_str(pub.g,\n\t      \"867d5fb72f5936d1a14ed3b60499662f3124686ef108c5b3\"\n\t      \"da6663a0e86197ec2cc4c9460193a74ff16028ac9441b0c7\"\n\t      \"d27c2272d483ac7cd794d598416c4ff9099a61679d417d47\"\n\t      \"8ce5dd974bf349a14575afe74a88b12dd5f6d1cbd3f91ddd\"\n\t      \"597ed68e79eba402613130c224b94ac28714a1f1c552475a\"\n\t      \"5d29cfcdd8e08a6b1d65661e28ef313514d1408f5abd3e06\"\n\t      \"ebe3a7d814d1ede316bf495273ca1d574f42b482eea30db5\"\n\t      \"3466f454b51a175a0b89b3c05dda006e719a2e6371669080\"\n\t      \"d768cc038cdfb8098e9aad9b8d83d4b759f43ac9d22b353e\"\n\t      \"d88a33723550150de0361b7a376f37b45d437f71cb711f28\"\n\t      \"47de671ad1059516a1d45755224a15d37b4aeada3f58c69a\"\n\t      \"136daef0636fe38e3752064afe598433e80089fda24b144a\"\n\t      \"462734bef8f77638845b00e59ce7fa4f1daf487a2cada11e\"\n\t      \"aba72bb23e1df6b66a183edd226c440272dd9b06bec0e57f\"\n\t      \"1a0822d2e00212064b6dba64562085f5a75929afa5fe509e\"\n\t      \"0b78e630aaf12f91e4980c9b0d6f7e059a2ea3e23479d930\", 16);\n  mpz_set_str(pub.y,\n\t      \"1f0a5c75e7985d6e70e4fbfda51a10b925f6accb600d7c65\"\n\t      \"10db90ec367b93bb069bd286e8f979b22ef0702f717a8755\"\n\t      \"c18309c87dae3fe82cc3dc8f4b7aa3d5f3876f4d4b3eb68b\"\n\t      \"fe910c43076d6cd0d39fc88dde78f09480db55234e6c8ca5\"\n\t      \"9fe2700efec04feee6b4e8ee2413721858be7190dbe905f4\"\n\t      \"56edcab55b2dc2916dc1e8731988d9ef8b619abcf8955aa9\"\n\t      \"60ef02b3f02a8dc649369222af50f1338ed28d667f3f10ca\"\n\t      \"e2a3c28a3c1d08df639c81ada13c8fd198c6dae3d62a3fe9\"\n\t      \"f04c985c65f610c06cb8faea68edb80de6cf07a8e89c0021\"\n\t      \"8185a952b23572e34df07ce5b4261e5de427eb503ee1baf5\"\n\t      \"992db6d438b47434c40c22657bc163e7953fa33eff39dc27\"\n\t      \"34607039aadd6ac27e4367131041f845ffa1a13f556bfba2\"\n\t      \"307a5c78f2ccf11298c762e08871968e48dc3d1569d09965\"\n\t      \"cd09da43cf0309a16af1e20fee7da3dc21b364c4615cd512\"\n\t      \"3fa5f9b23cfc4ffd9cfdcea670623840b062d4648d2eba78\"\n\t      \"6ad3f7ae337a4284324ace236f9f7174fbf442b99043002f\", 16);\n  mpz_set_str(signature.r,\n\t      \"7695698a14755db4206e850b4f5f19c540b07d07e08aac59\"\n\t      \"1e20081646e6eedc\", 16);\n  mpz_set_str(signature.s,\n\t      \"3dae01154ecff7b19007a953f185f0663ef7f2537f0b15e0\"\n\t      \"4fb343c961f36de2\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha384,\n\t\t  SHEX(\"ed9a64d3109ef8a9292956b946873ca4bd887ce624b81be8\"\n\t\t       \"1b82c69c67aaddf5655f70fe4768114db2834c71787f858e\"\n\t\t       \"5165da1a7fa961d855ad7e5bc4b7be31b97dbe770798ef79\"\n\t\t       \"66152b14b86ae35625a28aee5663b9ef3067cbdfbabd8719\"\n\t\t       \"7e5c842d3092eb88dca57c6c8ad4c00a19ddf2e1967b59bd\"\n\t\t       \"06ccaef933bc28e7\"),\n\t\t  &signature);\n\n  /* L=3072, N=256, SHA-512 */\n  mpz_set_str(pub.p,\n\t      \"c1d0a6d0b5ed615dee76ac5a60dd35ecb000a202063018b1\"\n\t      \"ba0a06fe7a00f765db1c59a680cecfe3ad41475badb5ad50\"\n\t      \"b6147e2596b88d34656052aca79486ea6f6ec90b23e363f3\"\n\t      \"ab8cdc8b93b62a070e02688ea877843a4685c2ba6db111e9\"\n\t      \"addbd7ca4bce65bb10c9ceb69bf806e2ebd7e54edeb7f996\"\n\t      \"a65c907b50efdf8e575bae462a219c302fef2ae81d73cee7\"\n\t      \"5274625b5fc29c6d60c057ed9e7b0d46ad2f57fe01f82323\"\n\t      \"0f31422722319ce0abf1f141f326c00fbc2be4cdb8944b6f\"\n\t      \"d050bd300bdb1c5f4da72537e553e01d51239c4d461860f1\"\n\t      \"fb4fd8fa79f5d5263ff62fed7008e2e0a2d36bf7b9062d0d\"\n\t      \"75db226c3464b67ba24101b085f2c670c0f87ae530d98ee6\"\n\t      \"0c5472f4aa15fb25041e19106354da06bc2b1d322d40ed97\"\n\t      \"b21fd1cdad3025c69da6ce9c7ddf3dcf1ea4d56577bfdec2\"\n\t      \"3071c1f05ee4077b5391e9a404eaffe12d1ea62d06acd6bf\"\n\t      \"19e91a158d2066b4cd20e4c4e52ffb1d5204cd022bc7108f\"\n\t      \"2c799fb468866ef1cb09bce09dfd49e4740ff8140497be61\", 16);\n  mpz_set_str(pub.q,\n\t      \"bf65441c987b7737385eadec158dd01614da6f15386248e59f3cddbefc8e9dd1\", 16);\n  mpz_set_str(pub.g,\n\t      \"c02ac85375fab80ba2a784b94e4d145b3be0f92090eba17b\"\n\t      \"d12358cf3e03f4379584f8742252f76b1ede3fc37281420e\"\n\t      \"74a963e4c088796ff2bab8db6e9a4530fc67d51f88b905ab\"\n\t      \"43995aab46364cb40c1256f0466f3dbce36203ef228b35e9\"\n\t      \"0247e95e5115e831b126b628ee984f349911d30ffb9d613b\"\n\t      \"50a84dfa1f042ba536b82d5101e711c629f9f2096dc834de\"\n\t      \"ec63b70f2a2315a6d27323b995aa20d3d0737075186f5049\"\n\t      \"af6f512a0c38a9da06817f4b619b94520edfac85c4a6e2e1\"\n\t      \"86225c95a04ec3c3422b8deb284e98d24b31465802008a09\"\n\t      \"7c25969e826c2baa59d2cba33d6c1d9f3962330c1fcda7cf\"\n\t      \"b18508fea7d0555e3a169daed353f3ee6f4bb30244319161\"\n\t      \"dff6438a37ca793b24bbb1b1bc2194fc6e6ef60278157899\"\n\t      \"cb03c5dd6fc91a836eb20a25c09945643d95f7bd50d20668\"\n\t      \"4d6ffc14d16d82d5f781225bff908392a5793b803f9b70b4\"\n\t      \"dfcb394f9ed81c18e391a09eb3f93a032d81ba670cabfd6f\"\n\t      \"64aa5e3374cb7c2029f45200e4f0bfd820c8bd58dc5eeb34\", 16);\n  mpz_set_str(pub.y,\n\t      \"6da54f2b0ddb4dcce2da1edfa16ba84953d8429ce60cd111\"\n\t      \"a5c65edcf7ba5b8d9387ab6881c24880b2afbdb437e9ed7f\"\n\t      \"fb8e96beca7ea80d1d90f24d546112629df5c9e9661742cc\"\n\t      \"872fdb3d409bc77b75b17c7e6cfff86261071c4b5c9f9898\"\n\t      \"be1e9e27349b933c34fb345685f8fc6c12470d124cecf51b\"\n\t      \"5d5adbf5e7a2490f8d67aac53a82ed6a2110686cf631c348\"\n\t      \"bcbc4cf156f3a6980163e2feca72a45f6b3d68c10e5a2283\"\n\t      \"b470b7292674490383f75fa26ccf93c0e1c8d0628ca35f2f\"\n\t      \"3d9b6876505d118988957237a2fc8051cb47b410e8b7a619\"\n\t      \"e73b1350a9f6a260c5f16841e7c4db53d8eaa0b4708d62f9\"\n\t      \"5b2a72e2f04ca14647bca6b5e3ee707fcdf758b925eb8d4e\"\n\t      \"6ace4fc7443c9bc5819ff9e555be098aa055066828e21b81\"\n\t      \"8fedc3aac517a0ee8f9060bd86e0d4cce212ab6a3a243c5e\"\n\t      \"c0274563353ca7103af085e8f41be524fbb75cda88903907\"\n\t      \"df94bfd69373e288949bd0626d85c1398b3073a139d5c747\"\n\t      \"d24afdae7a3e745437335d0ee993eef36a3041c912f7eb58\", 16);\n  mpz_set_str(signature.r,\n\t      \"a40a6c905654c55fc58e99c7d1a3feea2c5be64823d4086c\"\n\t      \"e811f334cfdc448d\", 16);\n  mpz_set_str(signature.s,\n\t      \"6478050977ec585980454e0a2f26a03037b921ca588a78a4\"\n\t      \"daff7e84d49a8a6c\", 16);\n  test_dsa_verify(params, pub.y, &nettle_sha512,\n\t\t  SHEX(\"494180eed0951371bbaf0a850ef13679df49c1f13fe3770b\"\n\t\t       \"6c13285bf3ad93dc4ab018aab9139d74200808e9c55bf883\"\n\t\t       \"00324cc697efeaa641d37f3acf72d8c97bff0182a35b9401\"\n\t\t       \"50c98a03ef41a3e1487440c923a988e53ca3ce883a2fb532\"\n\t\t       \"bb7441c122f1dc2f9d0b0bc07f26ba29a35cdf0da846a9d8\"\n\t\t       \"eab405cbf8c8e77f\"),\n\t\t  &signature);\n  \n  dsa_public_key_clear(&pub);\n  dsa_private_key_clear(&key);\n  dsa_signature_clear(&signature);\n}",
      "lines": 882,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/eax-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From the EAX specification,\n     http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf */\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"233952DEE4D5ED5F9B9C6D6FF80FF478\"),\t/* key */\n\t    SHEX(\"6BFB914FD07EAE6B\"),\t\t\t/* auth data */\n\t    SHEX(\"\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"\"),\t\t\t\t\t/* ciphertext */\n\t    SHEX(\"62EC67F9C3A4A407FCB2A8C49031A8B3\"),\t/* nonce */\n\t    SHEX(\"E037830E8389F27B025A2D6527E79D01\"));\t/* tag */\n\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"91945D3F4DCBEE0BF45EF52255F095A4\"),\n\t    SHEX(\"FA3BFD4806EB53FA\"),\n\t    SHEX(\"F7FB\"),\n\t    SHEX(\"19DD\"),\n\t    SHEX(\"BECAF043B0A23D843194BA972C66DEBD\"),\n\t    SHEX(\"5C4C9331049D0BDAB0277408F67967E5\"));\n  \n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"01F74AD64077F2E704C0F60ADA3DD523\"),\n\t    SHEX(\"234A3463C1264AC6\"),\n\t    SHEX(\"1A47CB4933\"),\n\t    SHEX(\"D851D5BAE0\"),\n\t    SHEX(\"70C3DB4F0D26368400A10ED05D2BFF5E\"),\n\t    SHEX(\"3A59F238A23E39199DC9266626C40F80\"));\n\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"D07CF6CBB7F313BDDE66B727AFD3C5E8\"),\n\t    SHEX(\"33CCE2EABFF5A79D\"),\n\t    SHEX(\"481C9E39B1\"),\n\t    SHEX(\"632A9D131A\"),\n\t    SHEX(\"8408DFFF3C1A2B1292DC199E46B7D617\"),\n\t    SHEX(\"D4C168A4225D8E1FF755939974A7BEDE\"));\n\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"35B6D0580005BBC12B0587124557D2C2\"),\n\t    SHEX(\"AEB96EAEBE2970E9\"),\n\t    SHEX(\"40D0C07DA5E4\"),\n\t    SHEX(\"071DFE16C675\"),\n\t    SHEX(\"FDB6B06676EEDC5C61D74276E1F8E816\"),\n\t    SHEX(\"CB0677E536F73AFE6A14B74EE49844DD\"));\n\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"BD8E6E11475E60B268784C38C62FEB22\"),\n\t    SHEX(\"D4482D1CA78DCE0F\"),\n\t    SHEX(\"4DE3B35C3FC039245BD1FB7D\"),\n\t    SHEX(\"835BB4F15D743E350E728414\"),\n\t    SHEX(\"6EAC5C93072D8E8513F750935E46DA1B\"),\n\t    SHEX(\"ABB8644FD6CCB86947C5E10590210A4F\"));\n\n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"7C77D6E813BED5AC98BAA417477A2E7D\"),\n\t    SHEX(\"65D2017990D62528\"),\n\t    SHEX(\"8B0A79306C9CE7ED99DAE4F87F8DD61636\"),\n\t    SHEX(\"02083E3979DA014812F59F11D52630DA30\"),\n\t    SHEX(\"1A8C98DCD73D38393B2BF1569DEEFC19\"),\n\t    SHEX(\"137327D10649B0AA6E1C181DB617D7F2\"));\n  \n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"5FFF20CAFAB119CA2FC73549E20F5B0D\"),\n\t    SHEX(\"54B9F04E6A09189A\"),\n\t    SHEX(\"1BDA122BCE8A8DBAF1877D962B8592DD2D56\"),\n\t    SHEX(\"2EC47B2C4954A489AFC7BA4897EDCDAE8CC3\"),\n\t    SHEX(\"DDE59B97D722156D4D9AFF2BC7559826\"),\n\t    SHEX(\"3B60450599BD02C96382902AEF7F832A\"));\n  \n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"A4A4782BCFFD3EC5E7EF6D8C34A56123\"),\n\t    SHEX(\"899A175897561D7E\"),\n\t    SHEX(\"6CF36720872B8513F6EAB1A8A44438D5EF11\"),\n\t    SHEX(\"0DE18FD0FDD91E7AF19F1D8EE8733938B1E8\"),\n\t    SHEX(\"B781FCF2F75FA5A8DE97A9CA48E522EC\"),\n\t    SHEX(\"E7F6D2231618102FDB7FE55FF1991700\"));\n  \n  test_aead(&nettle_eax_aes128, NULL,\n\t    SHEX(\"8395FCF1E95BEBD697BD010BC766AAC3\"),\n\t    SHEX(\"126735FCC320D25A\"),\n\t    SHEX(\"CA40D7446E545FFAED3BD12A740A659FFBBB3CEAB7\"),\n\t    SHEX(\"CB8920F87A6C75CFF39627B56E3ED197C552D295A7\"),\n\t    SHEX(\"22E7ADD93CFC6393C57EC0B3C17D6B44\"),\n\t    SHEX(\"CFC46AFC253B4652B1AF3795B124AB6E\"));\n}",
      "lines": 85,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-add-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        88,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  unsigned i;\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      mp_limb_t *g = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *g2 = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *g3 = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *scratch = xalloc_limbs (ECC_ADD_JJJ_ITCH(ecc->p.size));\n\n      if (ecc->p.bit_size == 255)\n\t{\n\t  mp_limb_t *z = xalloc_limbs (ecc_size_j (ecc));\n\t  /* Zero point has x = 0, y = 1, z = 1 */\n\t  mpn_zero (z, 3*ecc->p.size);\n\t  z[ecc->p.size] = z[2*ecc->p.size] = 1;\n\t  \n\t  ecc_a_to_j (ecc, g, ecc->g);\n\n\t  ecc_add_ehh (ecc, p, z, z, scratch);\n\t  test_ecc_mul_h (i, 0, p);\n\n\t  ecc_add_eh (ecc, p, z, z, scratch);\n\t  test_ecc_mul_h (i, 0, p);\n\n\t  ecc_add_ehh (ecc, p, g, p, scratch);\n\t  test_ecc_mul_h (i, 1, p);\n\n\t  ecc_add_eh (ecc, p, z, g, scratch);\n\t  test_ecc_mul_h (i, 1, p);\n\n\t  ecc_add_ehh (ecc, g2, g, p, scratch);\n\t  test_ecc_mul_h (i, 2, g2);\n\n\t  ecc_add_eh (ecc, g2, g, g, scratch);\n\t  test_ecc_mul_h (i, 2, g2);\n\n\t  ecc_add_ehh (ecc, g3, g, g2, scratch);\n\t  test_ecc_mul_h (i, 3, g3);\n\n\t  ecc_add_eh (ecc, g3, g2, g, scratch);\n\t  test_ecc_mul_h (i, 3, g3);\n\n\t  ecc_add_ehh (ecc, p, g, g3, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\n\t  ecc_add_eh (ecc, p, g3, g, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\n\t  ecc_add_ehh (ecc, p, g2, g2, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\n\t  free (z);\n\t}\n      else\n\t{\n\t  ecc_a_to_j (ecc, g, ecc->g);\n\n\t  ecc_dup_jj (ecc, g2, g, scratch);\n\t  test_ecc_mul_h (i, 2, g2);\n\n\t  ecc_add_jjj (ecc, g3, g, g2, scratch);\n\t  test_ecc_mul_h (i, 3, g3);\n\n\t  ecc_add_jjj (ecc, g3, g2, g, scratch);\n\t  test_ecc_mul_h (i, 3, g3);\n\n\t  ecc_add_jjj (ecc, p, g, g3, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\n\t  ecc_add_jjj (ecc, p, g3, g, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\n\t  ecc_dup_jj (ecc, p, g2, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\t}\n      free (g);\n      free (g2);\n      free (g3);\n      free (p);\n      free (scratch);\n    }\n}",
      "lines": 87,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-dup-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  unsigned i;\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      mp_limb_t *g = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *scratch = xalloc_limbs (ECC_DUP_EH_ITCH(ecc->p.size));;\n\n      if (ecc->p.bit_size == 255)\n\t{\n\t  mp_limb_t *z = xalloc_limbs (ecc_size_j (ecc));\n\t  /* Zero point has x = 0, y = 1, z = 1 */\n\t  mpn_zero (z, 3*ecc->p.size);\n\t  z[ecc->p.size] = z[2*ecc->p.size] = 1;\n\t  \n\t  ecc_a_to_j (ecc, g, ecc->g);\n\n\t  ecc_dup_eh (ecc, p, z, scratch);\n\t  test_ecc_mul_h (i, 0, p);\n\n\t  ecc_dup_eh (ecc, p, g, scratch);\n\t  test_ecc_mul_h (i, 2, p);\n\n\t  ecc_dup_eh (ecc, p, p, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\t  free (z);\n\t}\n      else\n\t{\n\t  ecc_a_to_j (ecc, g, ecc->g);\n\n\t  ecc_dup_jj (ecc, p, g, scratch);\n\t  test_ecc_mul_h (i, 2, p);\n\n\t  ecc_dup_jj (ecc, p, p, scratch);\n\t  test_ecc_mul_h (i, 4, p);\n\t}\n      free (p);\n      free (g);\n      free (scratch);\n    }\n}",
      "lines": 46,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-mod-test.c": {
    "ref_mod": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "static void\nref_mod (mp_limb_t *rp, const mp_limb_t *ap, const mp_limb_t *mp, mp_size_t mn)\n{\n  mpz_t r, a, m;\n  mpz_init (r);\n  mpz_mod (r, mpz_roinit_n (a, ap, 2*mn), mpz_roinit_n (m, mp, mn));\n  mpz_limbs_copy (rp, r, mn);\n\n  mpz_clear (r);\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_one": {
      "start_point": [
        21,
        0
      ],
      "end_point": [
        75,
        1
      ],
      "content": "static void\ntest_one(const char *name,\n\t const struct ecc_modulo *m,\n\t const mpz_t r)\n{\n  mp_limb_t a[MAX_SIZE];\n  mp_limb_t t[MAX_SIZE];\n  mp_limb_t ref[MAX_SIZE];\n\n  mpz_limbs_copy (a, r, 2*m->size);\n\n  ref_mod (ref, a, m->m, m->size);\n\n  mpn_copyi (t, a, 2*m->size);\n  m->mod (m, t);\n  if (mpn_cmp (t, m->m, m->size) >= 0)\n    mpn_sub_n (t, t, m->m, m->size);\n\n  if (mpn_cmp (t, ref, m->size))\n    {\n      fprintf (stderr, \"m->mod %s failed: bit_size = %u\\n\",\n\t       name, m->bit_size);\n\n      fprintf (stderr, \"a   = \");\n      mpn_out_str (stderr, 16, a, 2*m->size);\n      fprintf (stderr, \"\\nt   = \");\n      mpn_out_str (stderr, 16, t, m->size);\n      fprintf (stderr, \" (bad)\\nref = \");\n      mpn_out_str (stderr, 16, ref, m->size);\n      fprintf (stderr, \"\\n\");\n      abort ();\n    }\n\n  if (m->B_size < m->size)\n    {\n      mpn_copyi (t, a, 2*m->size);\n      ecc_mod (m, t);\n      if (mpn_cmp (t, m->m, m->size) >= 0)\n\tmpn_sub_n (t, t, m->m, m->size);\n\n      if (mpn_cmp (t, ref, m->size))\n\t{\n\t  fprintf (stderr, \"ecc_mod %s failed: bit_size = %u\\n\",\n\t\t   name, m->bit_size);\n\t  fprintf (stderr, \"a   = \");\n\t  mpn_out_str (stderr, 16, a, 2*m->size);\n\t  fprintf (stderr, \"\\nt   = \");\n\t  mpn_out_str (stderr, 16, t, m->size);\n\t  fprintf (stderr, \" (bad)\\nref = \");\n\t  mpn_out_str (stderr, 16, ref, m->size);\n\t  fprintf (stderr, \"\\n\");\n\t  abort ();\n\t}\n    }\n}",
      "lines": 55,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_modulo": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        96,
        1
      ],
      "content": "static void\ntest_modulo (gmp_randstate_t rands, const char *name,\n\t     const struct ecc_modulo *m, unsigned count)\n{\n  mpz_t r;\n  unsigned j;\n\n  mpz_init (r);\n\n  for (j = 0; j < count; j++)\n    {\n      if (j & 1)\n\tmpz_rrandomb (r, rands, 2*m->size * GMP_NUMB_BITS);\n      else\n\tmpz_urandomb (r, rands, 2*m->size * GMP_NUMB_BITS);\n\n      test_one (name, m, r);\n    }\n  mpz_clear (r);\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_fixed": {
      "start_point": [
        98,
        0
      ],
      "end_point": [
        126,
        1
      ],
      "content": "static void\ntest_fixed (void)\n{\n  mpz_t r;\n  mpz_init (r);\n\n  /* Triggered a bug reported by Hanno B\u00c3\u00b6ck. */\n  mpz_set_str (r, \"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFF001C2C00\", 16);\n  mpz_mul_2exp (r, r, 256);\n  test_one (\"p\", &nettle_secp_256r1.p, r);\n  test_one (\"q\", &nettle_secp_256r1.q, r);\n\n  mpz_set_str (r, \"ffffffff00000001fffffffeffffffffffffffffffffffffffffffc0000000000007ffffffffffffffffffffffffffff00000000000000000fffffffffffffff\", 16);\n  test_one (\"p\", &nettle_secp_256r1.p, r);\n  test_one (\"q\", &nettle_secp_256r1.q, r);\n\n  /* Triggered a bug reported by Hanno B\u00c3\u00b6ck. */\n  mpz_set_str (r, \"4c9000000000000000000000000000000000000000000000004a604db486e000000000000000000000000000000000000000121025be29575adb2c8ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\", 16);\n  test_one (\"p\", &nettle_secp_384r1.p, r);\n  test_one (\"q\", &nettle_secp_384r1.q, r);\n\n  /* Triggered a carry bug in development version. */\n  mpz_set_str (r, \"e64a84643150260640e4677c19ffc4faef06042132b86af6e9ee33fe1850222e57a514d5f1d6d444008bb896a96a43d5629945e57548f5e12f66be132b24110cbb2df6d7d3dd3aaadc98b0bbf29573843ad72e57f59fc5d4f56cc599da18bb99\", 16);\n\n  test_one (\"p\", &nettle_secp_384r1.p, r);\n  test_one (\"q\", &nettle_secp_384r1.q, r);\n\n  mpz_clear (r);\n}",
      "lines": 29,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_patterns": {
      "start_point": [
        128,
        0
      ],
      "end_point": [
        145,
        1
      ],
      "content": "static void\ntest_patterns (const char *name,\n\t       const struct ecc_modulo *m)\n{\n  mpz_t r;\n  unsigned j;\n\n  mpz_init (r);\n\n  for (j = m->bit_size; j < 2*m->bit_size; j++)\n    {\n      mpz_set_ui (r, 1);\n      mpz_mul_2exp (r, r, j);\n\n      test_one (name, m, r);\n    }\n  mpz_clear (r);\n}",
      "lines": 18,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_random_seed": {
      "start_point": [
        148,
        0
      ],
      "end_point": [
        174,
        1
      ],
      "content": "static void\nget_random_seed(mpz_t seed)\n{\n  struct timeval tv;\n  FILE *f;\n  f = fopen (\"/dev/urandom\", \"rb\");\n  if (f)\n    {\n      uint8_t buf[8];\n      size_t res;\n\n      setbuf (f, NULL);\n      res = fread (&buf, sizeof(buf), 1, f);\n      fclose(f);\n      if (res == 1)\n\t{\n\t  nettle_mpz_set_str_256_u (seed, sizeof(buf), buf);\n\t  return;\n\t}\n      fprintf (stderr, \"Read of /dev/urandom failed: %s\\n\",\n\t       strerror (errno));\n    }\n  gettimeofday(&tv, NULL);\n  mpz_set_ui (seed, tv.tv_sec);\n  mpz_mul_ui (seed, seed, 1000000UL);\n  mpz_add_ui (seed, seed, tv.tv_usec);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        177,
        0
      ],
      "end_point": [
        223,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  const char *nettle_test_seed;\n  gmp_randstate_t rands;\n  unsigned count = COUNT;\n  unsigned i;\n\n  gmp_randinit_default (rands);\n\n  test_fixed ();\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      test_patterns (\"p\", &ecc_curves[i]->p);\n      test_patterns (\"q\", &ecc_curves[i]->p);\n    }\n\n#if !NETTLE_USE_MINI_GMP\n  nettle_test_seed = getenv (\"NETTLE_TEST_SEED\");\n  if (nettle_test_seed && *nettle_test_seed)\n    {\n      mpz_t seed;\n      mpz_init (seed);\n      if (mpz_set_str (seed, nettle_test_seed, 0) < 0\n\t  || mpz_sgn (seed) < 0)\n\tdie (\"Invalid NETTLE_TEST_SEED: %s\\n\",\n\t     nettle_test_seed);\n      if (mpz_sgn (seed) == 0)\n\tget_random_seed (seed);\n      fprintf (stderr, \"Using NETTLE_TEST_SEED=\");\n      mpz_out_str (stderr, 10, seed);\n      fprintf (stderr, \"\\n\");\n\n      gmp_randseed (rands, seed);\n      mpz_clear (seed);\n      count *= 20;\n    }\n#endif /* !NETTLE_USE_MINI_GMP */\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      test_modulo (rands, \"p\", &ecc_curves[i]->p, count);\n      test_modulo (rands, \"q\", &ecc_curves[i]->q, count);\n    }\n  gmp_randclear (rands);\n}",
      "lines": 47,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-modinv-test.c": {
    "ref_modinv": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static int\nref_modinv (mp_limb_t *rp, const mp_limb_t *ap, const mp_limb_t *mp, mp_size_t mn)\n{\n  mpz_t g, s, a, m;\n  int res;\n\n  mpz_init (g);\n  mpz_init (s);\n  mpz_roinit_n (a, ap, mn);\n  mpz_roinit_n (m, mp, mn);\n  \n  mpz_gcdext (g, s, NULL, a, m);\n  if (mpz_cmp_ui (g, 1) == 0)\n    {\n      if (mpz_sgn (s) < 0)\n\t{\n\t  mpz_add (s, s, m);\n\t  ASSERT (mpz_sgn (s) > 0);\n\t}\n      mpz_limbs_copy (rp, s, mn);\n      res = 1;\n    }\n  else\n    res = 0;\n\n  mpz_clear (g);\n  mpz_clear (s);\n  return res;\n}",
      "lines": 29,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "zero_p": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "static int\nzero_p (const struct ecc_modulo *m, const mp_limb_t *xp)\n{\n  return mpn_zero_p (xp, m->size)\n    || mpn_cmp (xp, m->m, m->size) == 0;\n}",
      "lines": 6,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_modulo": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        131,
        1
      ],
      "content": "static void\ntest_modulo (gmp_randstate_t rands, const char *name,\n\t     const struct ecc_modulo *m)\n{\n  mp_limb_t *a;\n  mp_limb_t *ai;\n  mp_limb_t *ref;\n  mp_limb_t *scratch;\n  unsigned j;\n  mpz_t r;\n\n  mpz_init (r);\n\n  a = xalloc_limbs (m->size);\n  ai = xalloc_limbs (2*m->size);\n  ref = xalloc_limbs (m->size);;\n  scratch = xalloc_limbs (m->invert_itch);\n\n  /* Check behaviour for zero input */\n  mpn_zero (a, m->size);\n  memset (ai, 17, m->size * sizeof(*ai));\n  m->invert (m, ai, a, scratch);\n  if (!zero_p (m, ai))\n    {\n      fprintf (stderr, \"%s->invert failed for zero input (bit size %u):\\n\",\n\t       name, m->bit_size);\n      fprintf (stderr, \"p = \");\n      mpn_out_str (stderr, 16, m->m, m->size);\n      fprintf (stderr, \"\\nt = \");\n      mpn_out_str (stderr, 16, ai, m->size);\n      fprintf (stderr, \" (bad)\\n\");\n      abort ();\n    }\n\t  \n  /* Check behaviour for a = m */\n  memset (ai, 17, m->size * sizeof(*ai));\n  m->invert (m, ai, m->m, scratch);\n  if (!zero_p (m, ai))\n    {\n      fprintf (stderr, \"%s->invert failed for a = p input (bit size %u):\\n\",\n\t       name, m->bit_size);\n      \n      fprintf (stderr, \"p = \");\n      mpn_out_str (stderr, 16, m->m, m->size);\n      fprintf (stderr, \"\\nt = \");\n      mpn_out_str (stderr, 16, ai, m->size);\n      fprintf (stderr, \" (bad)\\n\");\n      abort ();\n    }\n\t\n  for (j = 0; j < COUNT; j++)\n    {\n      if (j & 1)\n\tmpz_rrandomb (r, rands, m->size * GMP_NUMB_BITS);\n      else\n\tmpz_urandomb (r, rands, m->size * GMP_NUMB_BITS);\n\n      mpz_limbs_copy (a, r, m->size);\n\n      if (!ref_modinv (ref, a, m->m, m->size))\n\t{\n\t  if (verbose)\n\t    fprintf (stderr, \"Test %u (bit size %u) not invertible mod %s.\\n\",\n\t\t     j, m->bit_size, name);\n\t  continue;\n\t}\n      m->invert (m, ai, a, scratch);\n      if (mpn_cmp (ref, ai, m->size))\n\t{\n\t  fprintf (stderr, \"%s->invert failed (test %u, bit size %u):\\n\",\n\t\t   name, j, m->bit_size);\n\t  fprintf (stderr, \"a = \");\n\t  mpz_out_str (stderr, 16, r);\n\t  fprintf (stderr, \"\\np = \");\n\t  mpn_out_str (stderr, 16, m->m, m->size);\n\t  fprintf (stderr, \"\\nt = \");\n\t  mpn_out_str (stderr, 16, ai, m->size);\n\t  fprintf (stderr, \" (bad)\\nr = \");\n\t  mpn_out_str (stderr, 16, ref, m->size);\n\n\t  abort ();\n\t}\n\t  \n    }\n  mpz_clear (r);\n  free (a);\n  free (ai);\n  free (ref);\n  free (scratch);\n}",
      "lines": 90,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        133,
        0
      ],
      "end_point": [
        147,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  gmp_randstate_t rands;\n  unsigned i;\n\n  gmp_randinit_default (rands);\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      test_modulo (rands, \"p\", &ecc_curves[i]->p);\n      test_modulo (rands, \"q\", &ecc_curves[i]->q);\n    }\n  gmp_randclear (rands);\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-mul-a-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        101,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  gmp_randstate_t rands;\n  mpz_t r;\n  unsigned i;\n\n  gmp_randinit_default (rands);\n  mpz_init (r);\n  \n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      mp_size_t size = ecc_size (ecc);\n      mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *q = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *n = xalloc_limbs (size);\n      mp_limb_t *scratch = xalloc_limbs (ecc->mul_itch);\n      unsigned j;\n      \n      mpn_zero (n, size);\n\n      n[0] = 1;\n      ecc->mul (ecc, p, n, ecc->g, scratch);\n      ecc->h_to_a (ecc, 0, p, p, scratch);\n\n      if (mpn_cmp (p, ecc->g, 2*size) != 0)\n\tdie (\"curve %d: ecc->mul with n = 1 failed.\\n\", ecc->p.bit_size);\n\n      for (n[0] = 2; n[0] <= 4; n[0]++)\n\t{\n\t  ecc->mul (ecc, p, n, ecc->g, scratch);\n\t  test_ecc_mul_h (i, n[0], p);\n\t}\n\n      /* (order - 1) * g = - g */\n      mpn_sub_1 (n, ecc->q.m, size, 1);\n      ecc->mul (ecc, p, n, ecc->g, scratch);\n      ecc->h_to_a (ecc, 0, p, p, scratch);\n      if (ecc->p.bit_size == 255)\n\t/* For edwards curves, - (x,y ) == (-x, y). FIXME: Swap x and\n\t   y, to get identical negation? */\n\tmpn_sub_n (p, ecc->p.m, p, size);\n      else\n\tmpn_sub_n (p + size, ecc->p.m, p + size, size);\n      if (mpn_cmp (p, ecc->g, 2*size) != 0)\n\t{\n\t  fprintf (stderr, \"ecc->mul with n = order - 1 failed.\\n\");\n\t  abort ();\n\t}\n\n      mpn_zero (n, size);\n\n      for (j = 0; j < 100; j++)\n\t{\n\t  if (j & 1)\n\t    mpz_rrandomb (r, rands, size * GMP_NUMB_BITS);\n\t  else\n\t    mpz_urandomb (r, rands, size * GMP_NUMB_BITS);\n\n\t  /* Reduce so that (almost surely) n < q */\n\t  mpz_limbs_copy (n, r, size);\n\t  n[size - 1] %= ecc->q.m[size - 1];\n\n\t  ecc->mul (ecc, p, n, ecc->g, scratch);\n\t  ecc->h_to_a (ecc, 0, p, p, scratch);\n\n\t  ecc->mul_g (ecc, q, n, scratch);\n\t  ecc->h_to_a (ecc, 0, q, q, scratch);\n\n\t  if (mpn_cmp (p, q, 2*size))\n\t    {\n\t      fprintf (stderr,\n\t\t       \"Different results from ecc->mul and ecc->mul_g.\\n\"\n\t\t       \" bits = %u\\n\",\n\t\t       ecc->p.bit_size);\n\t      fprintf (stderr, \" n = \");\n\t      mpn_out_str (stderr, 16, n, size);\n\t      \n\t      fprintf (stderr, \"\\np = \");\n\t      mpn_out_str (stderr, 16, p, size);\n\t      fprintf (stderr, \",\\n    \");\n\t      mpn_out_str (stderr, 16, p + size, size);\n\n\t      fprintf (stderr, \"\\nq = \");\n\t      mpn_out_str (stderr, 16, q, size);\n\t      fprintf (stderr, \",\\n    \");\n\t      mpn_out_str (stderr, 16, q + size, size);\n\t      fprintf (stderr, \"\\n\");\n\t      abort ();\n\t    }\n\t}\n      free (n);\n      free (p);\n      free (q);\n      free (scratch);\n    }\n  mpz_clear (r); \n  gmp_randclear (rands);\n}",
      "lines": 100,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-mul-g-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  gmp_randstate_t rands;\n  mpz_t r;\n  unsigned i;\n\n  gmp_randinit_default (rands);\n  mpz_init (r);\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      mp_size_t size = ecc_size (ecc);\n      mp_limb_t *p = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *q = xalloc_limbs (ecc_size_j (ecc));\n      mp_limb_t *n = xalloc_limbs (size);\n      mp_limb_t *scratch = xalloc_limbs (ecc->mul_g_itch);\n\n      mpn_zero (n, size);\n\n      n[0] = 1;\n      ecc->mul_g (ecc, p, n, scratch);\n      ecc->h_to_a (ecc, 0, p, p, scratch);\n\n      if (mpn_cmp (p, ecc->g, 2*size) != 0)\n\t{\n\t  fprintf (stderr, \"ecc->mul_g with n = 1 failed.\\n\");\n\t  abort ();\n\t}\n\n      for (n[0] = 2; n[0] <= 4; n[0]++)\n\t{\n\t  ecc->mul_g (ecc, p, n, scratch);\n\t  test_ecc_mul_h (i, n[0], p);\n\t}\n\n      /* (order - 1) * g = - g */\n      mpn_sub_1 (n, ecc->q.m, size, 1);\n      ecc->mul_g (ecc, p, n, scratch);\n      ecc->h_to_a (ecc, 0, p, p, scratch);\n      if (ecc->p.bit_size == 255)\n\t/* For edwards curves, - (x,y ) == (-x, y). FIXME: Swap x and\n\t   y, to get identical negation? */\n\tmpn_sub_n (p, ecc->p.m, p, size);\n      else\n\tmpn_sub_n (p + size, ecc->p.m, p + size, size);\n      if (mpn_cmp (p, ecc->g, 2*size) != 0)\n\t{\n\t  fprintf (stderr, \"ecc->mul_g with n = order - 1 failed.\\n\");\n\t  abort ();\n\t}\n\n      free (n);\n      free (p);\n      free (q);\n      free (scratch);\n    }\n  mpz_clear (r);\n  gmp_randclear (rands);\n}",
      "lines": 61,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-redc-test.c": {
    "ref_redc": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "static void\nref_redc (mp_limb_t *rp, const mp_limb_t *ap, const mp_limb_t *mp, mp_size_t mn)\n{\n  mpz_t t;\n  mpz_t m, a;\n  mp_size_t an;\n\n  mpz_init (t);\n  mpz_setbit (t, mn * GMP_NUMB_BITS);\n\n  mpz_roinit_n (m, mp, mn);\n\n  an = 2*mn;\n  while (an > 0 && ap[an-1] == 0)\n    an--;\n\n  mpz_roinit_n (a, ap, an);\n  \n  mpz_invert (t, t, m);\n  mpz_mul (t, t, a);\n  mpz_mod (t, t, m);\n\n  mpz_limbs_copy (rp, t, mn);\n\n  mpz_clear (t);\n}",
      "lines": 26,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        114,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  gmp_randstate_t rands;\n  mp_limb_t a[MAX_SIZE];\n  mp_limb_t m[MAX_SIZE];\n  mp_limb_t ref[MAX_SIZE];\n  unsigned i;\n  mpz_t r;\n\n  gmp_randinit_default (rands);\n  \n  mpz_init (r);\n  \n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      unsigned j;\n\n      for (j = 0; j < COUNT; j++)\n\t{\n\t  if (j & 1)\n\t    mpz_rrandomb (r, rands, 2*ecc->p.size * GMP_NUMB_BITS);\n\t  else\n\t    mpz_urandomb (r, rands, 2*ecc->p.size * GMP_NUMB_BITS);\n\n\t  mpz_limbs_copy (a, r, 2*ecc->p.size);\n\n\t  ref_redc (ref, a, ecc->p.m, ecc->p.size);\n\n\t  if (ecc->p.reduce != ecc->p.mod)\n\t    {\n\t      mpn_copyi (m, a, 2*ecc->p.size);\n\t      ecc->p.reduce (&ecc->p, m);\n\t      if (mpn_cmp (m, ecc->p.m, ecc->p.size) >= 0)\n\t\tmpn_sub_n (m, m, ecc->p.m, ecc->p.size);\n\n\t      if (mpn_cmp (m, ref, ecc->p.size))\n\t\t{\n\t\t  fprintf (stderr, \"ecc->p.reduce failed: bit_size = %u\\n\",\n\t\t\t   ecc->p.bit_size);\n\t\t  fprintf (stderr, \"a   = \");\n\t\t  mpn_out_str (stderr, 16, a, 2*ecc->p.size);\n\t\t  fprintf (stderr, \"\\nm   = \");\n\t\t  mpn_out_str (stderr, 16, m, ecc->p.size);\n\t\t  fprintf (stderr, \" (bad)\\nref   = \");\n\t\t  mpn_out_str (stderr, 16, ref, ecc->p.size);\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  abort ();\n\t\t}\n\t    }\n\t  if (ecc->p.redc_size != 0)\n\t    {\t  \n\t      mpn_copyi (m, a, 2*ecc->p.size);\n\t      if (ecc->p.m[0] == 1)\n\t\tecc_pm1_redc (&ecc->p, m);\n\t      else\n\t\tecc_pp1_redc (&ecc->p, m);\n\n\t      if (mpn_cmp (m, ecc->p.m, ecc->p.size) >= 0)\n\t\tmpn_sub_n (m, m, ecc->p.m, ecc->p.size);\n\n\t      if (mpn_cmp (m, ref, ecc->p.size))\n\t\t{\n\t\t  fprintf (stderr, \"ecc_p%c1_redc failed: bit_size = %u\\n\",\n\t\t\t   (ecc->p.m[0] == 1) ? 'm' : 'p', ecc->p.bit_size);\n\t\t  fprintf (stderr, \"a   = \");\n\t\t  mpn_out_str (stderr, 16, a, 2*ecc->p.size);\n\t\t  fprintf (stderr, \"\\nm   = \");\n\t\t  mpn_out_str (stderr, 16, m, ecc->p.size);\n\t\t  fprintf (stderr, \" (bad)\\nref = \");\n\t\t  mpn_out_str (stderr, 16, ref, ecc->p.size);\n\t\t  fprintf (stderr, \"\\n\");\n\t\t  abort ();\n\t\t}\n\t    }\n\t}\n    }\n\n  mpz_clear (r);\n  gmp_randclear (rands);\n}",
      "lines": 82,
      "depth": 20,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecc-sqrt-test.c": {
    "mpz_ui_kronecker": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        64,
        1
      ],
      "content": "static int\nmpz_ui_kronecker (mp_limb_t ul, const mpz_t p)\n{\n  mpz_t t, u;\n  int r;\n\n  mpz_init_set_ui (u, ul);\n  mpz_init_set (t, p);\n  mpz_sub_ui (t, t, 1);\n  mpz_tdiv_q_2exp (t, t, 1);\n  mpz_powm (t, u, t, p);\n\n  r = mpz_cmp_ui (t, 1);\n  if (r < 0)\n    r = 0;\n  else if (r == 0)\n    r = 1;\n  else\n    {\n      mpz_sub (t, p, t);\n      ASSERT (mpz_cmp_ui (t, 1) == 0);\n      r = -1;\n    }\n  mpz_clear (t);\n  mpz_clear (u);\n\n  return r;\n}",
      "lines": 28,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_modulo": {
      "start_point": [
        67,
        0
      ],
      "end_point": [
        156,
        1
      ],
      "content": "static void\ntest_modulo (gmp_randstate_t rands, const struct ecc_modulo *m)\n{\n  mpz_t u;\n  mpz_t v;\n  mpz_t p;\n  mpz_t r;\n  mpz_t t;\n\n  unsigned z, i;\n  mp_limb_t *up;\n  mp_limb_t *vp;\n  mp_limb_t *rp;\n  mp_limb_t *scratch;\n\n  mpz_init (u);\n  mpz_init (v);\n  mpz_init (t);\n\n  mpz_roinit_n (p, m->m, m->size);\n\n  up = xalloc_limbs (m->size);\n  vp = xalloc_limbs (m->size);\n  rp = xalloc_limbs (2*m->size);\n  scratch = xalloc_limbs (m->sqrt_itch);\n\n  /* Find a non-square */\n  for (z = 2; mpz_ui_kronecker (z, p) != -1; z++)\n    ;\n\n  if (verbose)\n    fprintf(stderr, \"Non square: %d\\n\", z);\n\n  for (i = 0; i < COUNT; i++)\n    {\n      if (i & 1)\n\t{\n\t  mpz_rrandomb (u, rands, m->bit_size);\n\t  mpz_rrandomb (v, rands, m->bit_size);\n\t}\n      else\n\t{\n\t  mpz_urandomb (u, rands, m->bit_size);\n\t  mpz_urandomb (v, rands, m->bit_size);\n\t}\n      mpz_limbs_copy (up, u, m->size);\n      mpz_limbs_copy (vp, v, m->size);\n      if (!m->sqrt (m, rp, up, vp, scratch))\n\t{\n\t  mpz_mul_ui (u, u, z);\n\t  mpz_mod (u, u, p);\n\t  mpz_limbs_copy (up, u, m->size);\n\t  if (!m->sqrt (m, rp, up, vp, scratch))\n\t    {\n\t      fprintf (stderr, \"m->sqrt returned failure, bit_size = %d\\n\"\n\t\t       \"u = 0x\",\n\t\t       m->bit_size);\n\t      mpz_out_str (stderr, 16, u);\n\t      fprintf (stderr, \"\\nv = 0x\");\n\t      mpz_out_str (stderr, 16, v);\n\t      fprintf (stderr, \"\\n\");\n\t      abort ();\n\t    }\n\t}\n      /* Check that r^2 v = u */\n      mpz_roinit_n (r, rp, m->size);\n      mpz_mul (t, r, r);\n      mpz_mul (t, t, v);\n      if (!mpz_congruent_p (t, u, p))\n\t{\n\t  fprintf (stderr, \"m->sqrt gave incorrect result, bit_size = %d\\n\"\n\t\t   \"u = 0x\",\n\t\t   m->bit_size);\n\t  mpz_out_str (stderr, 16, u);\n\t  fprintf (stderr, \"\\nv = 0x\");\n\t  mpz_out_str (stderr, 16, v);\n\t  fprintf (stderr, \"\\nr = 0x\");\n\t  mpz_out_str (stderr, 16, r);\n\t  fprintf (stderr, \"\\n\");\n\t  abort ();\n\t}\n    }\n  mpz_clear (u);\n  mpz_clear (v);\n  mpz_clear (t);\n  free (up);\n  free (vp);\n  free (rp);\n  free (scratch);\n}",
      "lines": 90,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        158,
        0
      ],
      "end_point": [
        171,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  gmp_randstate_t rands;\n  unsigned i;\n\n  gmp_randinit_default (rands);\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      if (ecc_curves[i]->p.sqrt)\n\ttest_modulo (rands, &ecc_curves[i]->p);\n    }\n  gmp_randclear (rands);\n}",
      "lines": 14,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecdh-test.c": {
    "set_point": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static void\nset_point (struct ecc_point *p,\n\t   const char *x, const char *y)\n{\n  mpz_t X, Y;\n  mpz_init_set_str (X, x, 0);\n  mpz_init_set_str (Y, y, 0);\n  if (!ecc_point_set (p, X, Y))\n    die (\"Test point not on curve!\\n\");\n\n  mpz_clear (X);\n  mpz_clear (Y);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_scalar": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\nset_scalar (struct ecc_scalar *s,\n\t    const char *x)\n{\n  mpz_t X;\n  mpz_init_set_str (X, x, 0);\n  ecc_scalar_set (s, X);\n  mpz_clear (X);\n}",
      "lines": 9,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_point": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        90,
        1
      ],
      "content": "static void\ncheck_point (const char *name, const char *label,\n\t     const struct ecc_point *P,\n\t     const struct ecc_point *R)\n{\n  mpz_t px, py, rx, ry;\n\n  mpz_init (px);\n  mpz_init (py);\n  mpz_init (rx);\n  mpz_init (ry);\n\n  ecc_point_get (P, px, py);\n  ecc_point_get (R, rx, ry);\n\n  /* FIXME: Should have a public point compare function */\n  if (mpz_cmp (px, rx) != 0 || mpz_cmp (py, ry) != 0)\n    {\n      fprintf (stderr, \"Failed %s %s\\np_x = \", name, label);\n      mpz_out_str (stderr, 10, px);\n      fprintf (stderr, \"\\nr_x = \");\n      mpz_out_str (stderr, 10, rx);\n      fprintf (stderr, \" (expected)\\np_y = \");\n      mpz_out_str (stderr, 10, py);\n      fprintf (stderr, \"\\nr_y = \");\n      mpz_out_str (stderr, 10, ry);\n      fprintf (stderr, \" (expected)\\n\");\n      abort ();      \n    }\n  mpz_clear (px);\n  mpz_clear (py);\n  mpz_clear (rx);\n  mpz_clear (ry);\n}",
      "lines": 34,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_dh": {
      "start_point": [
        92,
        0
      ],
      "end_point": [
        135,
        1
      ],
      "content": "static void\ntest_dh (const char *name, const struct ecc_curve *ecc,\n\t const char *a_priv, const char *ax, const char *ay,\n\t const char *b_priv, const char *bx, const char *by,\n\t const char *sx, const char *sy)\n{\n  struct ecc_point A, B, S, T;\n  struct ecc_scalar A_priv, B_priv;\n\n  ecc_scalar_init (&A_priv, ecc);\n  set_scalar (&A_priv, a_priv);\n  ecc_point_init (&A, ecc);\n  set_point (&A, ax, ay);\n\n  ecc_scalar_init (&B_priv, ecc);\n  set_scalar (&B_priv, b_priv);\n  ecc_point_init (&B, ecc);\n  set_point (&B, bx, by);\n\n  ecc_point_init (&S, ecc);\n  set_point (&S, sx, sy);\n\n  ecc_point_init (&T, ecc);\n\n  ecc_point_mul_g (&T, &A_priv);\n  check_point (name, \"a g\", &T, &A);\n\n  ecc_point_mul (&T, &B_priv, &T);\n  check_point (name, \"b (a g)\", &T, &S);\n\n  ecc_point_mul_g (&T, &B_priv);\n  check_point (name, \"b g\", &T, &B);\n\n  ecc_point_mul (&T, &A_priv,  &T);\n  check_point (name, \"a (b g)\", &T, &S);\n\n  ecc_scalar_clear (&A_priv);\n  ecc_scalar_clear (&B_priv);\n\n  ecc_point_clear (&A);\n  ecc_point_clear (&B);\n  ecc_point_clear (&S);\n  ecc_point_clear (&T);  \n}",
      "lines": 44,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        137,
        0
      ],
      "end_point": [
        202,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_dh (\"secp-192r1\", &nettle_secp_192r1,\n\t   \"3406157206141798348095184987208239421004566462391397236532\",\n\t   \"1050363442265225480786760666329560655512990381040021438562\",\n\t   \"5298249600854377235107392014200406283816103564916230704184\",\n\t   \"738368960171459956677260317271477822683777845013274506165\",\n\t   \"2585840779771604687467445319428618542927556223024046979917\",\n\t   \"293088185788565313717816218507714888251468410990708684573\",\n\t   \"149293809021051532782730990145509724807636529827149481690\",\n\t   \"2891131861147398318714693938158856874319184314120776776192\");\n\n  test_dh (\"secp-224r1\", &nettle_secp_224r1,\n\t   \"1321072106881784386340709783538698930880431939595776773514895067682\",\n\t   \"6768311794185371282972144247871764855860666277647541840973645586477\",\n\t   \"2880077809069104378181313860274147139049600284805670362929579614547\",\n\t   \"13934723037778859565852601874354272638301919827851286722006496784914\",\n\t   \"373124771833407982305885866158843810218322878380632071540538232035\",\n\t   \"24223309755162432227459925493224336241652868856405241018762887667883\",\n\t   \"8330362698029245839097779050425944245826040430538860338085968752913\",\n\t   \"24167244512472228715617822000878192535267113543393576038737592837010\");\t   \n\n  test_dh (\"secp-256r1\", &nettle_secp_256r1,\n\t   \"94731533361265297353914491124013058635674217345912524033267198103710636378786\",\n\t   \"22441589863306126152768848344973918725077248391248404659242620344938484650846\",\n\t   \"8673475622926171928656873398933611700804732317466515884933832073457396747355\",\n\t   \"97657865959185011849283028361556797595752581630732610898393589042714626616209\",\n\t   \"18453500628354973083413728373777272885280811435138222441593126858566687017580\",\n\t   \"14365748655141740924607822284126054269177292284541187981786689038777833170313\",\n\t   \"102958799567030688009123101477538973715497039396202015119148334812951370853564\",\n\t   \"29188877854984806245046208182450375893010623119030341548941791125497546766367\");\n\n  test_dh (\"secp-384r1\", &nettle_secp_384r1,\n\t   \"39086550219018474560700767788227987514008150214902287969462741484831311917159729009715909108606822193356890811565070\",\n\t   \"15536343869384820642787280162462493474000839389760580357050317691132784247078954166759523572989472049798969369413707\",\n\t   \"23268351460749985365652822073294615614961429585671989812206213135127969284347174876010177880230302801199500921999966\",\n\t   \"36869963309577906178833120963925446333578086292605692048464445726274368063284094788012795873582576522541658781990645\",\n\t   \"6571571183519639697971973492227725184968062063941037806786906539419849188357322949908539215960508669158121817812397\",\n\t   \"36555212611228586427448926841660565534959679681904941933188284044726925984417589749068550977832780023128545833460008\",\n\t   \"27780263733159299625371532605243698753833039933618994121416145881861678645978369807598146716869504289033472077532789\",\n\t   \"12327518461490664021199432424728005314646140038116972426756705356672414772151215711157356913456651047992140493843405\");\n\n  test_dh (\"secp-521r1\", &nettle_secp_521r1,\n\t   \"1177787298234877762125077260641419691552146813662613924864132680693789861345339466386194840381422980702458955378518702648732728796955434922249345867267377826\",\n\t   \"3168153642368000846168628288850857848098131369578410603904155841373678828215434925507474033105518841999665785152501356092020415699294327720257651796364374116\",\n\t   \"278603899104240796379373331240296114411332466119196525390128418935585486485808560319073463912513286987331907013829243645911963547435764718505394265715321106\",\n\t   \"4632844957395758597246278843156350179301194123641664447791935593091018103746003967476919616681982477804041933745387575872964923485212972039478646226080044590\",\n\t   \"3278857364905061449863537070675297207767865967146919975942590789168732752489407699106980407552332044280575891715425195464227794423128203118286002006478070253\",\n\t   \"4488572162727491199625798812850846214916160870437505769058530973184916706326908828109446998319674522651965593412129100088877891410841200092694907512496020182\",\n\t   \"2126311732129869456512627735193938710331935978955001830871465201548004444073866677974896970734635601049909886616595755762740651165670628002084824920216966370\",\n\t   \"4803556648772727869384704240411011976585308117802975396033423138930126997561438092192867119930177133880625991019440171972612468402200399449807843995563872782\");\n\n  /* NOTE: This isn't the standard way to do curve25519\n     diffie-hellman, but it tests that the ecc_point interface works\n     also with curve25519. */\n  test_dh (\"curve25519\", &_nettle_curve25519,\n\t   \"238301186166219052901200372289459967515481170332211409964804596991365959539\",\n\t   \"14283836751943535877833976277675258994717521964638468784408792140505262281235\",\n\t   \"43912344711849354965202408139054167824861850336739416536288592824181793690574\",\n\t   \"3795950278952272509684177709511717492358770264218705926196469999516028451559\",\n\t   \"9468726108732441384988851273894214794301501512287024874346147472389705411936\",\n\t   \"38072138078045635808869930165213470653418146012939584392304609812494425185763\",\n\t   \"10481077163111981870382976851703705086808805457403127024129174358161599078055\",\n\t   \"29260211489972704256554624312266763530759418996739976957020673870747051409679\");\n}",
      "lines": 66,
      "depth": 7,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecdsa-keygen-test.c": {
    "ecc_valid_p": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        56,
        1
      ],
      "content": "static int\necc_valid_p (struct ecc_point *pub)\n{\n  mpz_t t, x, y;\n  mpz_t lhs, rhs;\n  int res;\n  mp_size_t size;\n\n  size = pub->ecc->p.size;\n\n  /* First check range */\n  if (mpn_cmp (pub->p, pub->ecc->p.m, size) >= 0\n      || mpn_cmp (pub->p + size, pub->ecc->p.m, size) >= 0)\n    return 0;\n\n  mpz_init (lhs);\n  mpz_init (rhs);\n\n  mpz_roinit_n (x, pub->p, size);\n  mpz_roinit_n (y, pub->p + size, size);\n\n  mpz_mul (lhs, y, y);\n  \n  if (pub->ecc->p.bit_size == 255)\n    {\n      /* Check that\n\t 121666 (1 + x^2 - y^2) = 121665 x^2 y^2 */\n      mpz_t x2;\n      mpz_init (x2);\n      mpz_mul (x2, x, x); /* x^2 */\n      mpz_mul (rhs, x2, lhs); /* x^2 y^2 */\n      mpz_sub (lhs, x2, lhs); /* x^2 - y^2 */\n      mpz_add_ui (lhs, lhs, 1); /* 1 + x^2 - y^2 */\n      mpz_mul_ui (lhs, lhs, 121666);\n      mpz_mul_ui (rhs, rhs, 121665);\n\n      mpz_clear (x2);\n    }\n  else\n    {\n      /* Check y^2 = x^3 - 3 x + b */\n      mpz_mul (rhs, x, x);\n      mpz_sub_ui (rhs, rhs, 3);\n      mpz_mul (rhs, rhs, x);\n      mpz_add (rhs, rhs, mpz_roinit_n (t, pub->ecc->b, size));\n    }\n  res = mpz_congruent_p (lhs, rhs, mpz_roinit_n (t, pub->ecc->p.m, size));\n  \n  mpz_clear (lhs);\n  mpz_clear (rhs);\n\n  return res;\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_main": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        133,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  unsigned i;\n  struct knuth_lfib_ctx rctx;\n  struct dsa_signature signature;\n\n  struct tstring *digest;\n\n  knuth_lfib_init (&rctx, 4711);\n  dsa_signature_init (&signature);\n\n  digest = SHEX (/* sha256(\"abc\") */\n\t\t \"BA7816BF 8F01CFEA 414140DE 5DAE2223\"\n\t\t \"B00361A3 96177A9C B410FF61 F20015AD\");\n\n  for (i = 0; ecc_curves[i]; i++)\n    {\n      const struct ecc_curve *ecc = ecc_curves[i];\n      struct ecc_point pub;\n      struct ecc_scalar key;\n\n      if (verbose)\n\tfprintf (stderr, \"Curve %d\\n\", ecc->p.bit_size);\n\n      ecc_point_init (&pub, ecc);\n      ecc_scalar_init (&key, ecc);\n\n      ecdsa_generate_keypair (&pub, &key,\n\t\t\t      &rctx,\n\t\t\t      (nettle_random_func *) knuth_lfib_random);\n\n      if (verbose)\n\t{\n\t  fprintf (stderr, \"Public key:\\nx = \");\n\t  write_mpn (stderr, 16, pub.p, ecc->p.size);\n\t  fprintf (stderr, \"\\ny = \");\n\t  write_mpn (stderr, 16, pub.p + ecc->p.size, ecc->p.size);\n\t  fprintf (stderr, \"\\nPrivate key: \");\n\t  write_mpn (stderr, 16, key.p, ecc->p.size);\n\t  fprintf (stderr, \"\\n\");\n\t}\n      if (!ecc_valid_p (&pub))\n\tdie (\"ecdsa_generate_keypair produced an invalid point.\\n\");\n\n      ecdsa_sign (&key,\n\t\t  &rctx, (nettle_random_func *) knuth_lfib_random,\n\t\t  digest->length, digest->data,\n\t\t  &signature);\n\n      if (!ecdsa_verify (&pub, digest->length, digest->data,\n\t\t\t  &signature))\n\tdie (\"ecdsa_verify failed.\\n\");\n\n      digest->data[3] ^= 17;\n      if (ecdsa_verify (&pub, digest->length, digest->data,\n\t\t\t &signature))\n\tdie (\"ecdsa_verify  returned success with invalid digest.\\n\");\n      digest->data[3] ^= 17;\n\n      mpz_combit (signature.r, 117);\n      if (ecdsa_verify (&pub, digest->length, digest->data,\n\t\t\t &signature))\n\tdie (\"ecdsa_verify  returned success with invalid signature.r.\\n\");\n\n      mpz_combit (signature.r, 117);\n      mpz_combit (signature.s, 93);\n      if (ecdsa_verify (&pub, digest->length, digest->data,\n\t\t\t &signature))\n\tdie (\"ecdsa_verify  returned success with invalid signature.s.\\n\");\n\n      ecc_point_clear (&pub);\n      ecc_scalar_clear (&key);\n    }\n  dsa_signature_clear (&signature);\n}",
      "lines": 76,
      "depth": 13,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecdsa-sign-test.c": {
    "test_ecdsa": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "static void\ntest_ecdsa (const struct ecc_curve *ecc,\n\t    /* Private key */\n\t    const char *sz,\n\t    /* Random nonce */\n\t    const char *sk,\n\t    /* Hash */\n\t    const struct tstring *h,\n\t    /* Expected signature */\n\t    const char *r, const char *s)\n{\n  struct dsa_signature ref;\n  mpz_t z;\n  mpz_t k;\n  mp_limb_t *rp = xalloc_limbs (ecc->p.size);\n  mp_limb_t *sp = xalloc_limbs (ecc->p.size);\n  mp_limb_t *scratch = xalloc_limbs (ecc_ecdsa_sign_itch (ecc));\n\n  dsa_signature_init (&ref);\n\n  mpz_init_set_str (z, sz, 16);\n  mpz_init_set_str (k, sk, 16);\n\n  ecc_ecdsa_sign (ecc, mpz_limbs_read_n (z, ecc->p.size),\n\t\t  mpz_limbs_read_n (k, ecc->p.size),\n\t\t  h->length, h->data, rp, sp, scratch);\n\n  mpz_set_str (ref.r, r, 16);\n  mpz_set_str (ref.s, s, 16);\n\n  if (mpz_limbs_cmp (ref.r, rp, ecc->p.size) != 0\n      || mpz_limbs_cmp (ref.s, sp, ecc->p.size) != 0)\n    {\n      fprintf (stderr, \"_ecdsa_sign failed, bit_size = %u\\n\", ecc->p.bit_size);\n      fprintf (stderr, \"r     = \");\n      write_mpn (stderr, 16, rp, ecc->p.size);\n      fprintf (stderr, \"\\ns     = \");\n      write_mpn (stderr, 16, sp, ecc->p.size);\n      fprintf (stderr, \"\\nref.r = \");\n      mpz_out_str (stderr, 16, ref.r);\n      fprintf (stderr, \"\\nref.s = \");\n      mpz_out_str (stderr, 16, ref.s);\n      fprintf (stderr, \"\\n\");\n      abort();\n    }\n\n  free (rp);\n  free (sp);\n  free (scratch);\n\n  dsa_signature_clear (&ref);\n  mpz_clear (k);\n  mpz_clear (z);\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        172,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  /* Test cases for the smaller groups, verified with a\n     proof-of-concept implementation done for Yubico AB. */\n  test_ecdsa (&nettle_secp_192r1,\n\t      \"DC51D3866A15BACDE33D96F992FCA99D\"\n\t      \"A7E6EF0934E70975\", /* z */\n\n\t      \"9E56F509196784D963D1C0A401510EE7\"\n\t      \"ADA3DCC5DEE04B15\", /* k */\n\n\t      SHEX(\"BA7816BF8F01CFEA414140DE5DAE2223\"\n\t\t   \"B00361A396177A9C\"), /* h */\n\n\t      \"8c478db6a5c131540cebc739f9c0a9a8\"\n\t      \"c720c2abdd14a891\", /* r */\n\n\t      \"a91fb738f9f175d72f9c98527e881c36\"\n\t      \"8de68cb55ffe589\"); /* s */\n\n  test_ecdsa (&nettle_secp_224r1,\n\t      \"446df0a771ed58403ca9cb316e617f6b\"\n\t      \"158420465d00a69601e22858\",  /* z */\n\n\t      \"4c13f1905ad7eb201178bc08e0c9267b\"\n\t      \"4751c15d5e1831ca214c33f4\",  /* z */\n\n\t      SHEX(\"1b28a611fe62ab3649350525d06703ba\"\n\t\t   \"4b979a1e543566fd5caa85c6\"),  /* h */\n\n\t      \"2cc280778f3d067df6d3adbe3a6aad63\"\n\t      \"bc75f08f5c5f915411902a99\",  /* r */ \n\n\t      \"d0f069fd0f108eb07b7bbc54c8d6c88d\"\n\t      \"f2715c38a95c31a2b486995f\"); /* s */\n\n  /* From RFC 4754 */\n  test_ecdsa (&nettle_secp_256r1,\n\t      \"DC51D386 6A15BACD E33D96F9 92FCA99D\"\n\t      \"A7E6EF09 34E70975 59C27F16 14C88A7F\",  /* z */\n\n\t      \"9E56F509 196784D9 63D1C0A4 01510EE7\"\n\t      \"ADA3DCC5 DEE04B15 4BF61AF1 D5A6DECE\",  /* k */\n\n\t      SHEX(\"BA7816BF 8F01CFEA 414140DE 5DAE2223\"\n\t\t   \"B00361A3 96177A9C B410FF61 F20015AD\"),  /* h */\n\t      \n\t      \"CB28E099 9B9C7715 FD0A80D8 E47A7707\"\n\t      \"9716CBBF 917DD72E 97566EA1 C066957C\",  /* r */\n\t      \"86FA3BB4 E26CAD5B F90B7F81 899256CE\"\n\t      \"7594BB1E A0C89212 748BFF3B 3D5B0315\"); /* s */\n\n  test_ecdsa (&nettle_secp_384r1,\n\t      \"0BEB6466 34BA8773 5D77AE48 09A0EBEA\"\n\t      \"865535DE 4C1E1DCB 692E8470 8E81A5AF\"\n\t      \"62E528C3 8B2A81B3 5309668D 73524D9F\",  /* z */\n\n\t      \"B4B74E44 D71A13D5 68003D74 89908D56\"\n\t      \"4C7761E2 29C58CBF A1895009 6EB7463B\"\n\t      \"854D7FA9 92F934D9 27376285 E63414FA\",  /* k */\n\n\t      SHEX(\"CB00753F 45A35E8B B5A03D69 9AC65007\"\n\t\t   \"272C32AB 0EDED163 1A8B605A 43FF5BED\"\n\t\t   \"8086072B A1E7CC23 58BAECA1 34C825A7\"),  /* h */\n\n\t      \"FB017B91 4E291494 32D8BAC2 9A514640\"\n\t      \"B46F53DD AB2C6994 8084E293 0F1C8F7E\"\n\t      \"08E07C9C 63F2D21A 07DCB56A 6AF56EB3\",  /* r */\n\t      \"B263A130 5E057F98 4D38726A 1B468741\"\n\t      \"09F417BC A112674C 528262A4 0A629AF1\"\n\t      \"CBB9F516 CE0FA7D2 FF630863 A00E8B9F\"); /* s*/\n\n  test_ecdsa (&nettle_secp_521r1,\n\t      \"0065FDA3 409451DC AB0A0EAD 45495112\"\n\t      \"A3D813C1 7BFD34BD F8C1209D 7DF58491\"\n\t      \"20597779 060A7FF9 D704ADF7 8B570FFA\"\n\t      \"D6F062E9 5C7E0C5D 5481C5B1 53B48B37\"\n\t      \"5FA1\", /* z */\n\t      \n\t      \"00C1C2B3 05419F5A 41344D7E 4359933D\"\n\t      \"734096F5 56197A9B 244342B8 B62F46F9\"\n\t      \"373778F9 DE6B6497 B1EF825F F24F42F9\"\n\t      \"B4A4BD73 82CFC337 8A540B1B 7F0C1B95\"\n\t      \"6C2F\", /* k */\n\n\t      SHEX(\"DDAF35A1 93617ABA CC417349 AE204131\"\n\t\t   \"12E6FA4E 89A97EA2 0A9EEEE6 4B55D39A\"\n\t\t   \"2192992A 274FC1A8 36BA3C23 A3FEEBBD\"\n\t\t   \"454D4423 643CE80E 2A9AC94F A54CA49F\"), /* h */\n\n\t      \"0154FD38 36AF92D0 DCA57DD5 341D3053\"\n\t      \"988534FD E8318FC6 AAAAB68E 2E6F4339\"\n\t      \"B19F2F28 1A7E0B22 C269D93C F8794A92\"\n\t      \"78880ED7 DBB8D936 2CAEACEE 54432055\"\n\t      \"2251\", /* r */\n\t      \"017705A7 030290D1 CEB605A9 A1BB03FF\"\n\t      \"9CDD521E 87A696EC 926C8C10 C8362DF4\"\n\t      \"97536710 1F67D1CF 9BCCBF2F 3D239534\"\n\t      \"FA509E70 AAC851AE 01AAC68D 62F86647\"\n\t      \"2660\"); /* s */\n\n  /* Non-standard ecdsa using curve25519. Not interop-tested with\n     anything else. */\n  test_ecdsa (&_nettle_curve25519,\n\t      \"1db511101b8fd16f e0212c5679ef53f3\"\n\t      \"323bde77f9efa442 617314d576d1dbcb\", /* z */\n\t      \"aa2fa8facfdc3a99 ec466d41a2c9211c\"\n\t      \"e62e1706f54037ff 8486e26153b0fa79\", /* k */\n\t      SHEX(\"e99df2a098c3c590 ea1e1db6d9547339\"\n\t\t   \"ae760d5331496119 5d967fd881e3b0f5\"), /* h */\n\t      \" 515c3a485f57432 0daf3353a0d08110\"\n\t      \"64157c556296de09 4132f74865961b37\", /* r */\n\t      \"  78f23367291b01 3fc430fb09322d95\"\n\t      \"4384723649868d8e 88effc7ac8b141d7\"); /* s */\n}",
      "lines": 116,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ecdsa-verify-test.c": {
    "test_ecdsa": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\ntest_ecdsa (const struct ecc_curve *ecc,\n\t    /* Public key */\n\t    const char *xs, const char *ys,\n\t    /* Hash */\n\t    struct tstring *h,\n\t    /* Valid signature */\n\t    const char *r, const char *s)\n{\n  struct ecc_point pub;\n  struct dsa_signature signature;\n  mpz_t x, y;\n\n  ecc_point_init (&pub, ecc);\n  dsa_signature_init (&signature);\n\n  mpz_init_set_str (x, xs, 16);\n  mpz_init_set_str (y, ys, 16);\n\n  if (!ecc_point_set (&pub, x, y))\n    die (\"ecc_point_set failed.\\n\");\n\n  mpz_set_str (signature.r, r, 16);\n  mpz_set_str (signature.s, s, 16);\n\n  if (!ecdsa_verify (&pub, h->length, h->data, &signature))\n    {\n      fprintf (stderr, \"ecdsa_verify failed with valid signature.\\n\");\n    fail:\n      fprintf (stderr, \"bit_size = %u\\nx = \", ecc->p.bit_size);\n      mpz_out_str (stderr, 16, x);\n      fprintf (stderr, \"\\ny = \");\n      mpz_out_str (stderr, 16, y);\n      fprintf (stderr, \"\\ndigest \");\n      print_hex (h->length, h->data);\n      fprintf (stderr, \"r = \");\n      mpz_out_str (stderr, 16, signature.r);\n      fprintf (stderr, \"\\ns = \");\n      mpz_out_str (stderr, 16, signature.s);\n      fprintf (stderr, \"\\n\");\n      abort();\n    }\n\n  mpz_combit (signature.r, ecc->p.bit_size / 3);\n  if (ecdsa_verify (&pub, h->length, h->data, &signature))\n    {\n      fprintf (stderr, \"ecdsa_verify unexpectedly succeeded with invalid signature.\\n\");\n      goto fail;\n    }\n  mpz_combit (signature.r, ecc->p.bit_size / 3);\n  \n  mpz_combit (signature.s, 4*ecc->p.bit_size / 5);\n  if (ecdsa_verify (&pub, h->length, h->data, &signature))\n    {\n      fprintf (stderr, \"ecdsa_verify unexpectedly succeeded with invalid signature.\\n\");\n      goto fail;\n    }\n  mpz_combit (signature.s, 4*ecc->p.bit_size / 5);\n\n  h->data[2*h->length / 3] ^= 0x40;\n  if (ecdsa_verify (&pub, h->length, h->data, &signature))\n    {\n      fprintf (stderr, \"ecdsa_verify unexpectedly succeeded with invalid signature.\\n\");\n      goto fail;\n    }\n  h->data[2*h->length / 3] ^= 0x40;\n  if (!ecdsa_verify (&pub, h->length, h->data, &signature))\n    {\n      fprintf (stderr, \"ecdsa_verify failed, internal testsuite error.\\n\");\n      goto fail;\n    }\n\n  ecc_point_clear (&pub);\n  dsa_signature_clear (&signature);\n  mpz_clear (x);\n  mpz_clear (y);  \n}",
      "lines": 77,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        160,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  /* From RFC 4754 */\n  test_ecdsa (&nettle_secp_256r1,\n\t      \"2442A5CC 0ECD015F A3CA31DC 8E2BBC70\"\n\t      \"BF42D60C BCA20085 E0822CB0 4235E970\",  /* x */\n\n\t      \"6FC98BD7 E50211A4 A27102FA 3549DF79\"\n\t      \"EBCB4BF2 46B80945 CDDFE7D5 09BBFD7D\",  /* y */\n\n\t      SHEX(\"BA7816BF 8F01CFEA 414140DE 5DAE2223\"\n\t\t   \"B00361A3 96177A9C B410FF61 F20015AD\"),  /* h */\n\t      \n\t      \"CB28E099 9B9C7715 FD0A80D8 E47A7707\"\n\t      \"9716CBBF 917DD72E 97566EA1 C066957C\",  /* r */\n\t      \"86FA3BB4 E26CAD5B F90B7F81 899256CE\"\n\t      \"7594BB1E A0C89212 748BFF3B 3D5B0315\"); /* s */\n\n  test_ecdsa (&nettle_secp_384r1,\n\t      \"96281BF8 DD5E0525 CA049C04 8D345D30\"\n\t      \"82968D10 FEDF5C5A CA0C64E6 465A97EA\"\n\t      \"5CE10C9D FEC21797 41571072 1F437922\",  /* x */\n\n\t      \"447688BA 94708EB6 E2E4D59F 6AB6D7ED\"\n\t      \"FF9301D2 49FE49C3 3096655F 5D502FAD\"\n\t      \"3D383B91 C5E7EDAA 2B714CC9 9D5743CA\",  /* y */\n\n\t      SHEX(\"CB00753F 45A35E8B B5A03D69 9AC65007\"\n\t\t   \"272C32AB 0EDED163 1A8B605A 43FF5BED\"\n\t\t   \"8086072B A1E7CC23 58BAECA1 34C825A7\"),  /* h */\n\n\t      \"FB017B91 4E291494 32D8BAC2 9A514640\"\n\t      \"B46F53DD AB2C6994 8084E293 0F1C8F7E\"\n\t      \"08E07C9C 63F2D21A 07DCB56A 6AF56EB3\",  /* r */\n\t      \"B263A130 5E057F98 4D38726A 1B468741\"\n\t      \"09F417BC A112674C 528262A4 0A629AF1\"\n\t      \"CBB9F516 CE0FA7D2 FF630863 A00E8B9F\"); /* s*/\n\n  test_ecdsa (&nettle_secp_521r1,\n\t      \"0151518F 1AF0F563 517EDD54 85190DF9\"\n\t      \"5A4BF57B 5CBA4CF2 A9A3F647 4725A35F\"\n\t      \"7AFE0A6D DEB8BEDB CD6A197E 592D4018\"\n\t      \"8901CECD 650699C9 B5E456AE A5ADD190\"\n\t      \"52A8\", /* x */\n\n\t      \"006F3B14 2EA1BFFF 7E2837AD 44C9E4FF\"\n\t      \"6D2D34C7 3184BBAD 90026DD5 E6E85317\"\n\t      \"D9DF45CA D7803C6C 20035B2F 3FF63AFF\"\n\t      \"4E1BA64D 1C077577 DA3F4286 C58F0AEA\"\n\t      \"E643\", /* y */\n\n\t      SHEX(\"DDAF35A1 93617ABA CC417349 AE204131\" \n\t\t   \"12E6FA4E 89A97EA2 0A9EEEE6 4B55D39A\"\n\t\t   \"2192992A 274FC1A8 36BA3C23 A3FEEBBD\" \n\t\t   \"454D4423 643CE80E 2A9AC94F A54CA49F\"), /* h */\n\n\t      \"0154FD38 36AF92D0 DCA57DD5 341D3053\" \n\t      \"988534FD E8318FC6 AAAAB68E 2E6F4339\"\n\t      \"B19F2F28 1A7E0B22 C269D93C F8794A92\" \n\t      \"78880ED7 DBB8D936 2CAEACEE 54432055\"\n\t      \"2251\", /* r */\n\t      \"017705A7 030290D1 CEB605A9 A1BB03FF\"\n\t      \"9CDD521E 87A696EC 926C8C10 C8362DF4\"\n\t      \"97536710 1F67D1CF 9BCCBF2F 3D239534\" \n\t      \"FA509E70 AAC851AE 01AAC68D 62F86647\"\n\t      \"2660\"); /* s */\n\n  test_ecdsa (&_nettle_curve25519,\n\t      /* Public key corresponding to the key in ecdsa-sign-test */\n\t      \"59f8f317fd5f4e82 c02f8d4dec665fe1\"\n\t      \"230f83b8572638e1 b2ac34a30028e24d\", /* x */\n\t      \"1902a72dc1a6525a 811b9c1845978d56\"\n\t      \"fd97dce5e278ebdd ec695349d7e41498\", /* y */\n\t      SHEX(\"e99df2a098c3c590 ea1e1db6d9547339\"\n\t\t   \"ae760d5331496119 5d967fd881e3b0f5\"), /* h */\n\t      \" 515c3a485f57432 0daf3353a0d08110\"\n\t      \"64157c556296de09 4132f74865961b37\", /* r */\n\t      \"  78f23367291b01 3fc430fb09322d95\"\n\t      \"4384723649868d8e 88effc7ac8b141d7\"); /* s */\n}",
      "lines": 81,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ed25519-test.c": {
    "decode_hex": {
      "start_point": [
        39,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\ndecode_hex (size_t length, uint8_t *dst, const char *src)\n{\n  struct base16_decode_ctx ctx;\n  size_t out_size;\n  base16_decode_init (&ctx);\n  ASSERT (base16_decode_update (&ctx, &out_size, dst, 2*length, src));\n  ASSERT (out_size == length);\n  ASSERT (base16_decode_final (&ctx));\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_one": {
      "start_point": [
        58,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "static void\ntest_one (const char *line)\n{\n  const char *p;\n  const char *mp;\n  uint8_t sk[ED25519_KEY_SIZE];\n  uint8_t pk[ED25519_KEY_SIZE];\n  uint8_t t[ED25519_KEY_SIZE];\n  uint8_t s[ED25519_SIGNATURE_SIZE];\n  uint8_t *msg;\n  size_t msg_size;\n  uint8_t s2[ED25519_SIGNATURE_SIZE];\n\n  decode_hex (ED25519_KEY_SIZE, sk, line);\n\n  p = strchr (line, ':');\n  ASSERT (p == line + 128);\n  p++;\n  decode_hex (ED25519_KEY_SIZE, pk, p);\n  p = strchr (p, ':');\n  ASSERT (p == line + 193);\n  mp = ++p;\n  p = strchr (p, ':');\n  ASSERT (p);\n  ASSERT ((p - mp) % 2 == 0);\n  msg_size = (p - mp) / 2;\n\n  decode_hex (ED25519_SIGNATURE_SIZE, s, p+1);\n\n  msg = xalloc (msg_size + 1);\n  msg[msg_size] = 'x';\n\n  decode_hex (msg_size, msg, mp);\n\n  ed25519_sha512_public_key (t, sk);\n  ASSERT (MEMEQ(ED25519_KEY_SIZE, t, pk));\n\n  ed25519_sha512_sign (pk, sk, msg_size, msg, s2);\n  ASSERT (MEMEQ (ED25519_SIGNATURE_SIZE, s, s2));\n\n  ASSERT (ed25519_sha512_verify (pk, msg_size, msg, s));\n\n  s2[ED25519_SIGNATURE_SIZE/3] ^= 0x40;\n  ASSERT (!ed25519_sha512_verify (pk, msg_size, msg, s2));\n\n  memcpy (s2, s, ED25519_SIGNATURE_SIZE);\n  s2[2*ED25519_SIGNATURE_SIZE/3] ^= 0x40;\n  ASSERT (!ed25519_sha512_verify (pk, msg_size, msg, s2));\n\n  ASSERT (!ed25519_sha512_verify (pk, msg_size + 1, msg, s));\n\n  if (msg_size > 0)\n    {\n      msg[msg_size-1] ^= 0x20;\n      ASSERT (!ed25519_sha512_verify (pk, msg_size, msg, s));\n    }\n  free (msg);\n}",
      "lines": 58,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "getline": {
      "start_point": [
        118,
        0
      ],
      "end_point": [
        152,
        1
      ],
      "content": "static ssize_t\ngetline(char **lineptr, size_t *n, FILE *f)\n{\n  size_t i;\n  int c;\n  if (!*lineptr)\n    {\n      *n = 500;\n      *lineptr = xalloc (*n);\n    }\n\n  i = 0;\n  do\n    {\n      c = getc(f);\n      if (c < 0)\n\t{\n\t  if (i > 0)\n\t    break;\n\t  return -1;\n\t}\n\n      (*lineptr) [i++] = c;\n      if (i == *n)\n\t{\n\t  *n *= 2;\n\t  *lineptr = realloc (*lineptr, *n);\n\t  if (!*lineptr)\n\t    die (\"Virtual memory exhausted.\\n\");\n\t}\n    } while (c != '\\n');\n\n  (*lineptr) [i] = 0;\n  return i;\n}",
      "lines": 35,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "ssize_t"
      ]
    },
    "test_main": {
      "start_point": [
        155,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  const char *input = getenv (\"ED25519_SIGN_INPUT\");\n  if (input)\n    {\n      size_t buf_size;\n      char *buf;\n      FILE *f = fopen (input, \"r\");\n      if (!f)\n\tdie (\"Opening input file '%s' failed: %s\\n\",\n\t     input, strerror (errno));\n\n      for (buf = NULL; getline (&buf, &buf_size, f) >= 0; )\n\ttest_one (buf);\n\n      free (buf);\n      fclose (f);\n    }\n  else\n    {\n      /* First few lines only */\n      test_one (\"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a:d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a::e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b:\");\n      test_one (\"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c:3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c:72:92a009a9f0d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb69da085ac1e43e15996e458f3613d0f11d8c387b2eaeb4302aeeb00d291612bb0c0072:\");\n      test_one (\"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025:fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025:af82:6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40aaf82:\");\n      test_one (\"0d4a05b07352a5436e180356da0ae6efa0345ff7fb1572575772e8005ed978e9e61a185bcef2613a6c7cb79763ce945d3b245d76114dd440bcf5f2dc1aa57057:e61a185bcef2613a6c7cb79763ce945d3b245d76114dd440bcf5f2dc1aa57057:cbc77b:d9868d52c2bebce5f3fa5a79891970f309cb6591e3e1702a70276fa97c24b3a8e58606c38c9758529da50ee31b8219cba45271c689afa60b0ea26c99db19b00ccbc77b:\");\n    }\n}",
      "lines": 28,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/eddsa-compress-test.c": {
    "test_main": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        111,
        1
      ],
      "content": "void test_main (void)\n{\n  const struct ecc_curve *ecc = &_nettle_curve25519;\n  gmp_randstate_t rands;\n  mp_size_t size, itch;\n  mpz_t zp, t;\n  mp_limb_t *s;\n  mp_limb_t *p;\n  mp_limb_t *pa1;\n  mp_limb_t *pa2;\n  mp_limb_t *scratch;\n  size_t clen;\n  uint8_t *c;\n  unsigned j;\n\n  gmp_randinit_default (rands);\n\n  size = ecc_size (ecc);\n  clen = 1 + ecc->p.bit_size / 8;\n\n  mpz_roinit_n (zp, ecc->p.m, size);\n\n  mpz_init (t);\n  s = xalloc_limbs (size);\n  p = xalloc_limbs (ecc_size_j (ecc));\n  pa1 = xalloc_limbs (ecc_size_a (ecc));\n  pa2 = xalloc_limbs (ecc_size_a (ecc));\n  c = xalloc (clen);\n\n  itch = _eddsa_decompress_itch (ecc);\n  if (itch < ecc->mul_g_itch)\n    itch = ecc->mul_g_itch;\n\n  scratch = xalloc_limbs (itch);\n\n  for (j = 0; j < COUNT; j++)\n    {\n      mpz_t x1, y1, x2, y2;\n\n      mpz_urandomb (t, rands, ecc->q.bit_size);\n      mpz_limbs_copy (s, t, ecc->q.size);\n      ecc->mul_g (ecc, p, s, scratch);\n      _eddsa_compress (ecc, c, p, scratch);\n      ecc->h_to_a (ecc, 0, pa1, p, scratch);\n      _eddsa_decompress (ecc, pa2, c, scratch);\n      mpz_roinit_n (x1, pa1, size);\n      mpz_roinit_n (y1, pa1 + size, size);\n      mpz_roinit_n (x2, pa2, size);\n      mpz_roinit_n (y2, pa2 + size, size);\n      if (!(mpz_congruent_p (x1, x2, zp)\n\t    && mpz_congruent_p (y1, y2, zp)))\n\t{\n\t  fprintf (stderr, \"eddsa compression failed:\\nc = \");\n\t  print_hex (clen, c);\n\t  fprintf (stderr, \"\\np1 = 0x\");\n\t  mpz_out_str (stderr, 16, x1);\n\t  fprintf (stderr, \",\\n     0x\");\n\t  mpz_out_str (stderr, 16, y1);\n\t  fprintf (stderr, \"\\np2 = 0x\");\n\t  mpz_out_str (stderr, 16, x2);\n\t  fprintf (stderr, \",\\n     0x\");\n\t  mpz_out_str (stderr, 16, y2);\n\t  fprintf (stderr, \"\\n\");\n\t  abort ();\n\t}\n    }\n  mpz_clear (t);\n  free (s);\n  free (p);\n  free (c);\n  free (pa1);\n  free (pa2);\n  free (scratch);\n  gmp_randclear (rands);\n}",
      "lines": 75,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/eddsa-sign-test.c": {
    "test_eddsa_sign": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "static void\ntest_eddsa_sign (const struct ecc_curve *ecc,\n\t\t const struct nettle_hash *H,\n\t\t const struct tstring *public,\n\t\t const struct tstring *private,\n\t\t const struct tstring *msg,\n\t\t const struct tstring *ref)\n{\n  mp_limb_t *scratch = xalloc_limbs (_eddsa_sign_itch (ecc));\n  size_t nbytes = 1 + ecc->p.bit_size / 8;\n  uint8_t *signature = xalloc (2*nbytes);\n  void *ctx = xalloc (H->context_size);\n  uint8_t *public_out = xalloc (nbytes);\n  uint8_t *digest = xalloc (2*nbytes);\n  const uint8_t *k1 = digest + nbytes;\n  mp_limb_t *k2 = xalloc_limbs (ecc->p.size);\n\n  ASSERT (public->length == nbytes);\n  ASSERT (private->length == nbytes);\n  ASSERT (ref->length == 2*nbytes);\n\n  _eddsa_expand_key (ecc, H, ctx, private->data,\n\t\t     digest, k2);\n  _eddsa_public_key (ecc, k2, public_out, scratch);\n\n  if (!MEMEQ (nbytes, public_out, public->data))\n    {\n      fprintf (stderr, \"Bad public key from _eddsa_expand_key + _eddsa_public_key.\\n\");\n      fprintf (stderr, \"got:\");\n      print_hex (nbytes, public_out);\n      fprintf (stderr, \"\\nref:\");\n      tstring_print_hex (public);\n      fprintf (stderr, \"\\n\");\n      abort ();\n    }\n  H->update (ctx, nbytes, k1);\n  \n  _eddsa_sign (ecc, H, public->data, ctx, k2,\n\t       msg->length, msg->data, signature, scratch);\n\n  if (!MEMEQ (2*nbytes, signature, ref->data))\n    {\n      fprintf (stderr, \"Bad _eddsa_sign output.\\n\");\n      fprintf (stderr, \"Public key:\");\n      tstring_print_hex (public);\n      fprintf (stderr, \"\\nPrivate key:\");\n      tstring_print_hex (private);\n      fprintf (stderr, \"\\nk2:\");\n      mpn_out_str (stderr, 16, k2, ecc->p.size);\n      fprintf (stderr, \"\\nMessage (length %u):\", (unsigned) msg->length);\n      tstring_print_hex (msg);      \n      fprintf (stderr, \"\\ngot:\");\n      print_hex (2*nbytes, signature);\n      fprintf (stderr, \"\\nref:\");\n      tstring_print_hex (ref);\n      fprintf (stderr, \"\\n\");\n      abort ();\n    }\n  \n  free (scratch);\n  free (signature);\n  free (ctx);\n  free (digest);\n  free (k2);\n  free (public_out);\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void test_main (void)\n{\n  /* Based on a few of the test vectors at\n     http://ed25519.cr.yp.to/python/sign.input */\n  test_eddsa_sign (&_nettle_curve25519, &nettle_sha512,\n\t\t   SHEX(\"d75a980182b10ab7 d54bfed3c964073a\"\n\t\t\t\"0ee172f3daa62325 af021a68f707511a\"),\n\t\t   SHEX(\"9d61b19deffd5a60 ba844af492ec2cc4\"\n\t\t\t\"4449c5697b326919 703bac031cae7f60\"),\n\t\t   SHEX(\"\"),\n\t\t   SHEX(\"e5564300c360ac72 9086e2cc806e828a\"\n\t\t\t\"84877f1eb8e5d974 d873e06522490155\"\n\t\t\t\"5fb8821590a33bac c61e39701cf9b46b\"\n\t\t\t\"d25bf5f0595bbe24 655141438e7a100b\"));\n  test_eddsa_sign (&_nettle_curve25519, &nettle_sha512,\n\t\t   SHEX(\"3d4017c3e843895a 92b70aa74d1b7ebc\"\n\t\t\t\"9c982ccf2ec4968c c0cd55f12af4660c\"),\n\t\t   SHEX(\"4ccd089b28ff96da 9db6c346ec114e0f\"\n\t\t\t\"5b8a319f35aba624 da8cf6ed4fb8a6fb\"),\n\t\t   SHEX(\"72\"),\n\t\t   SHEX(\"92a009a9f0d4cab8 720e820b5f642540\"\n\t\t\t\"a2b27b5416503f8f b3762223ebdb69da\"\n\t\t\t\"085ac1e43e15996e 458f3613d0f11d8c\"\n\t\t\t\"387b2eaeb4302aee b00d291612bb0c00\"));\n  test_eddsa_sign (&_nettle_curve25519, &nettle_sha512,\n\t\t   SHEX(\"1ed506485b09a645 0be7c9337d9fe87e\"\n\t\t\t\"f99c96f8bd11cd63 1ca160d0fd73067e\"),\n\t\t   SHEX(\"f215d34fe2d757cf f9cf5c05430994de\"\n\t\t\t\"587987ce45cb0459 f61ec6c825c62259\"),\n\t\t   SHEX(\"fbed2a7df418ec0e 8036312ec239fcee\"\n\t\t\t\"6ef97dc8c2df1f2e 14adee287808b788\"\n\t\t\t\"a6072143b851d975 c8e8a0299df846b1\"\n\t\t\t\"9113e38cee83da71 ea8e9bd6f57bdcd3\"\n\t\t\t\"557523f4feb616ca a595aea01eb0b3d4\"\n\t\t\t\"90b99b525ea4fbb9 258bc7fbb0deea8f\"\n\t\t\t\"568cb2\"),\n\t\t   SHEX(\"cbef65b6f3fd5809 69fc3340cfae4f7c\"\n\t\t\t\"99df1340cce54626 183144ef46887163\"\n\t\t\t\"4b0a5c0033534108 e1c67c0dc99d3014\"\n\t\t\t\"f01084e98c95e101 4b309b1dbb2e6704\"));\n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/eddsa-verify-test.c": {
    "test_eddsa": {
      "start_point": [
        35,
        0
      ],
      "end_point": [
        124,
        1
      ],
      "content": "static void\ntest_eddsa (const struct ecc_curve *ecc,\n\t    const struct nettle_hash *H,\n\t    const uint8_t *pub,\n\t    const struct tstring *msg,\n\t    const uint8_t *signature)\n{\n  mp_limb_t *A = xalloc_limbs (ecc_size_a (ecc));\n  mp_limb_t *scratch = xalloc_limbs (_eddsa_verify_itch (ecc));\n  size_t nbytes = 1 + ecc->p.bit_size / 8;\n  uint8_t *cmsg = xalloc (msg->length);\n  uint8_t *csignature = xalloc (2*nbytes);\n  void *ctx = xalloc (H->context_size);\n\n  if (!_eddsa_decompress (ecc, A, pub, scratch))\n    die (\"Invalid eddsa public key.\\n\");\n\n  memcpy (csignature, signature, 2*nbytes);\n  if (!_eddsa_verify (ecc, H, pub, A, ctx,\n\t\t      msg->length, msg->data, csignature, scratch))\n    {\n      fprintf (stderr, \"eddsa_verify failed with valid signature.\\n\");\n    fail:\n      fprintf (stderr, \"bit_size = %u\\npub = \", ecc->p.bit_size);\n      print_hex (nbytes, pub);\n      fprintf (stderr, \"\\nmsg = \");\n      tstring_print_hex (msg);\n      fprintf (stderr, \"\\nsign = \");\n      print_hex (2*nbytes, csignature);\n      fprintf (stderr, \"\\n\");\n      abort();\n    }\n\n  memcpy (csignature, signature, 2*nbytes);\n  csignature[nbytes/3] ^= 0x40;\n  if (_eddsa_verify (ecc, H, pub, A, ctx,\n\t\t     msg->length, msg->data, csignature, scratch))\n    {\n      fprintf (stderr,\n\t       \"ecdsa_verify unexpectedly succeeded with invalid signature r.\\n\");\n      goto fail;\n    }\n\n  memcpy (csignature, signature, 2*nbytes);\n  csignature[5*nbytes/3] ^= 0x8;\n\n  if (_eddsa_verify (ecc, H, pub, A, ctx,\n\t\t     msg->length, msg->data, csignature, scratch))\n    {\n      fprintf (stderr,\n\t       \"ecdsa_verify unexpectedly succeeded with invalid signature s.\\n\");\n      goto fail;\n    }\n\n  if (msg->length == 0)\n    {\n      if (_eddsa_verify  (ecc, H, pub, A, ctx,\n\t\t\t  LDATA(\"foo\"), signature, scratch))\n\t{\n\t  fprintf (stderr,\n\t\t   \"ecdsa_verify unexpectedly succeeded with different message.\\n\");\n\t  goto fail;\n\t}\n    }\n  else\n    {\n      if (_eddsa_verify  (ecc, H, pub, A, ctx,\n\t\t\t  msg->length - 1, msg->data,\n\t\t\t  signature, scratch))\n\t{\n\t  fprintf (stderr,\n\t\t   \"ecdsa_verify unexpectedly succeeded with truncated message.\\n\");\n\t  goto fail;\n\t}\n      memcpy (cmsg, msg->data, msg->length);\n      cmsg[2*msg->length / 3] ^= 0x20;\n      if (_eddsa_verify  (ecc, H, pub, A, ctx,\n\t\t\t  msg->length, cmsg, signature, scratch))\n\t{\n\t  fprintf (stderr,\n\t\t   \"ecdsa_verify unexpectedly succeeded with modified message.\\n\");\n\t  goto fail;\n\t}\n    }\n  free (A);\n  free (scratch);\n  free (cmsg);\n  free (csignature);\n  free (ctx);\n}",
      "lines": 90,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        126,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  test_eddsa (&_nettle_curve25519, &nettle_sha512,\n\t      H(\"d75a980182b10ab7 d54bfed3c964073a\"\n\t\t\"0ee172f3daa62325 af021a68f707511a\"),\n\t      SHEX(\"\"),\n\t      H(\"e5564300c360ac72 9086e2cc806e828a\"\n\t\t\"84877f1eb8e5d974 d873e06522490155\"\n\t\t\"5fb8821590a33bac c61e39701cf9b46b\"\n\t\t\"d25bf5f0595bbe24 655141438e7a100b\"));\n  test_eddsa (&_nettle_curve25519, &nettle_sha512,\n\t      H(\"3d4017c3e843895a 92b70aa74d1b7ebc\"\n\t\t\"9c982ccf2ec4968c c0cd55f12af4660c\"),\n\t      SHEX(\"72\"),\n\t      H(\"92a009a9f0d4cab8 720e820b5f642540\"\n\t\t\"a2b27b5416503f8f b3762223ebdb69da\"\n\t\t\"085ac1e43e15996e 458f3613d0f11d8c\"\n\t\t\"387b2eaeb4302aee b00d291612bb0c00\"));\n  test_eddsa (&_nettle_curve25519, &nettle_sha512,\n\t      H(\"1ed506485b09a645 0be7c9337d9fe87e\"\n\t\t\"f99c96f8bd11cd63 1ca160d0fd73067e\"),\n\t      SHEX(\"fbed2a7df418ec0e 8036312ec239fcee\"\n\t\t   \"6ef97dc8c2df1f2e 14adee287808b788\"\n\t\t   \"a6072143b851d975 c8e8a0299df846b1\"\n\t\t   \"9113e38cee83da71 ea8e9bd6f57bdcd3\"\n\t\t   \"557523f4feb616ca a595aea01eb0b3d4\"\n\t\t   \"90b99b525ea4fbb9 258bc7fbb0deea8f\"\n\t\t   \"568cb2\"),\n\t      H(\"cbef65b6f3fd5809 69fc3340cfae4f7c\"\n\t\t\"99df1340cce54626 183144ef46887163\"\n\t\t\"4b0a5c0033534108 e1c67c0dc99d3014\"\n\t\t\"f01084e98c95e101 4b309b1dbb2e6704\"));\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/gcm-test.c": {
    "test_gcm_hash": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "static void\ntest_gcm_hash (const struct tstring *msg, const struct tstring *ref)\n{\n  struct gcm_aes128_ctx ctx;\n  const uint8_t z16[16] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };\n  uint8_t digest[16];\n\n  ASSERT (ref->length == sizeof(digest));\n  gcm_aes128_set_key (&ctx, z16);\n  gcm_aes128_set_iv (&ctx, 16, z16);\n  gcm_aes128_update (&ctx, msg->length, msg->data);\n  gcm_aes128_digest (&ctx, sizeof(digest), digest);\n  if (!MEMEQ (ref->length, ref->data, digest))\n    {\n      fprintf (stderr, \"gcm_hash failed, msg: %s\\nOutput: \", msg->data);\n      print_hex (16, digest);\n      fprintf(stderr, \"Expected:\");\n      tstring_print_hex(ref);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n}",
      "lines": 22,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_unified_aes128_set_key": {
      "start_point": [
        29,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "static void\ngcm_unified_aes128_set_key (void *ctx, const uint8_t *key)\n{\n  gcm_aes_set_key (ctx, AES128_KEY_SIZE, key);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "gcm_unified_aes128_set_iv": {
      "start_point": [
        34,
        0
      ],
      "end_point": [
        38,
        1
      ],
      "content": "static void\ngcm_unified_aes128_set_iv (void *ctx, const uint8_t *iv)\n{\n  gcm_aes_set_iv (ctx, GCM_IV_SIZE, iv);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        55,
        0
      ],
      "end_point": [
        554,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* \n   * GCM-AES Test Vectors from\n   * http://www.cryptobarn.com/papers/gcm-spec.pdf\n   */\n\n  /* Test case 1 */\n  test_aead(&nettle_gcm_aes128, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"),\t/* key */\n\t    SHEX(\"\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"000000000000000000000000\"),\t\t/* IV */\n\t    SHEX(\"58e2fccefa7e3061367f1d57a4e7455a\"));\t/* tag */\n\n  /* Test case 2 */\n  test_aead(&nettle_gcm_aes128, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"00000000000000000000000000000000\"),\n\t    SHEX(\"0388dace60b6a392f328c2b971b2fe78\"),\n\t    SHEX(\"000000000000000000000000\"),\n\t    SHEX(\"ab6e47d42cec13bdf53a67b21257bddf\"));\n\n  /* Test case 3 */\n  test_aead(&nettle_gcm_aes128, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b391aafd255\"),\n\t    SHEX(\"42831ec2217774244b7221b784d0d49c\"\n\t\t \"e3aa212f2c02a4e035c17e2329aca12e\"\n\t\t \"21d514b25466931c7d8f6a5aac84aa05\"\n\t\t \"1ba30b396a0aac973d58e091473f5985\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"4d5c2af327cd64a62cf35abd2ba6fab4\"));\n\n  /* Test case 4 */\n  test_aead(&nettle_gcm_aes128, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"42831ec2217774244b7221b784d0d49c\"\n\t\t \"e3aa212f2c02a4e035c17e2329aca12e\"\n\t\t \"21d514b25466931c7d8f6a5aac84aa05\"\n\t\t \"1ba30b396a0aac973d58e091\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"5bc94fbc3221a5db94fae95ae7121a47\"));\n\n  /* Test case 5 */\n  test_aead(&nettle_gcm_aes128,\n\t    (nettle_hash_update_func *) gcm_aes128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"61353b4c2806934a777ff51fa22a4755\"\n\t\t \"699b2a714fcdc6f83766e5f97b6c7423\"\n\t\t \"73806900e49f24b22b097544d4896b42\"\n\t\t \"4989b5e1ebac0f07c23f4598\"),\n\t    SHEX(\"cafebabefacedbad\"),\n\t    SHEX(\"3612d2e79e3b0785561be14aaca2fccb\"));\n\n  /* Test case 6 */\n  test_aead(&nettle_gcm_aes128,\n\t    (nettle_hash_update_func *) gcm_aes128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"8ce24998625615b603a033aca13fb894\"\n\t\t \"be9112a5c3a211a8ba262a3cca7e2ca7\"\n\t\t \"01e4a9a4fba43c90ccdcb281d48c7c6f\"\n\t\t \"d62875d2aca417034c34aee5\"),\n\t    SHEX(\"9313225df88406e555909c5aff5269aa\"\n\t\t \"6a7a9538534f7da1e4c303d2a318a728\"\n\t\t \"c3c0c95156809539fcf0e2429a6b5254\"\n\t\t \"16aedbf5a0de6a57a637b39b\"),\n\t    SHEX(\"619cc5aefffe0bfa462af43c1699d050\"));\n\n  /* Same test, but with old gcm_aes interface */\n  test_aead(&nettle_gcm_unified_aes128,\n\t    (nettle_hash_update_func *) gcm_aes_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"8ce24998625615b603a033aca13fb894\"\n\t\t \"be9112a5c3a211a8ba262a3cca7e2ca7\"\n\t\t \"01e4a9a4fba43c90ccdcb281d48c7c6f\"\n\t\t \"d62875d2aca417034c34aee5\"),\n\t    SHEX(\"9313225df88406e555909c5aff5269aa\"\n\t\t \"6a7a9538534f7da1e4c303d2a318a728\"\n\t\t \"c3c0c95156809539fcf0e2429a6b5254\"\n\t\t \"16aedbf5a0de6a57a637b39b\"),\n\t    SHEX(\"619cc5aefffe0bfa462af43c1699d050\"));\n\n  /* Test case 7 */\n  test_aead(&nettle_gcm_aes192, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"\n\t\t \"0000000000000000\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"000000000000000000000000\"),\n\t    SHEX(\"cd33b28ac773f74ba00ed1f312572435\"));\n\n  /* Test case 8 */\n  test_aead(&nettle_gcm_aes192, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"\n\t\t \"0000000000000000\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"00000000000000000000000000000000\"),\n\t    SHEX(\"98e7247c07f0fe411c267e4384b0f600\"),\n\t    SHEX(\"000000000000000000000000\"),\n\t    SHEX(\"2ff58d80033927ab8ef4d4587514f0fb\"));\n\n  /* Test case 9 */\n  test_aead(&nettle_gcm_aes192, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b391aafd255\"),\n\t    SHEX(\"3980ca0b3c00e841eb06fac4872a2757\"\n\t\t \"859e1ceaa6efd984628593b40ca1e19c\"\n\t\t \"7d773d00c144c525ac619d18c84a3f47\"\n\t\t \"18e2448b2fe324d9ccda2710acade256\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"9924a7c8587336bfb118024db8674a14\"));\n\n  /* Test case 10 */\n  test_aead(&nettle_gcm_aes192, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"3980ca0b3c00e841eb06fac4872a2757\"\n\t\t \"859e1ceaa6efd984628593b40ca1e19c\"\n\t\t \"7d773d00c144c525ac619d18c84a3f47\"\n\t\t \"18e2448b2fe324d9ccda2710\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"2519498e80f1478f37ba55bd6d27618c\"));\n\n  /* Test case 11 */\n  test_aead(&nettle_gcm_aes192,\n\t    (nettle_hash_update_func *) gcm_aes192_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"0f10f599ae14a154ed24b36e25324db8\"\n\t\t \"c566632ef2bbb34f8347280fc4507057\"\n\t\t \"fddc29df9a471f75c66541d4d4dad1c9\"\n\t\t \"e93a19a58e8b473fa0f062f7\"),\n\t    SHEX(\"cafebabefacedbad\"),\n\t    SHEX(\"65dcc57fcf623a24094fcca40d3533f8\"));\n\n  /* Test case 12 */\n  test_aead(&nettle_gcm_aes192,\n\t    (nettle_hash_update_func *) gcm_aes192_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"d27e88681ce3243c4830165a8fdcf9ff\"\n\t\t \"1de9a1d8e6b447ef6ef7b79828666e45\"\n\t\t \"81e79012af34ddd9e2f037589b292db3\"\n\t\t \"e67c036745fa22e7e9b7373b\"),\n\t    SHEX(\"9313225df88406e555909c5aff5269aa\"\n\t\t \"6a7a9538534f7da1e4c303d2a318a728\"\n\t\t \"c3c0c95156809539fcf0e2429a6b5254\"\n\t\t \"16aedbf5a0de6a57a637b39b\"),\n\t    SHEX(\"dcf566ff291c25bbb8568fc3d376a6d9\"));\n\n  /* Test case 13 */\n  test_aead(&nettle_gcm_aes256, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"\n\t\t \"00000000000000000000000000000000\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"000000000000000000000000\"),\n\t    SHEX(\"530f8afbc74536b9a963b4f1c4cb738b\"));\n\n  /* Test case 14 */\n  test_aead(&nettle_gcm_aes256, NULL,\n\t    SHEX(\"00000000000000000000000000000000\"\n\t\t \"00000000000000000000000000000000\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"00000000000000000000000000000000\"),\n\t    SHEX(\"cea7403d4d606b6e074ec5d3baf39d18\"),\n\t    SHEX(\"000000000000000000000000\"),\n\t    SHEX(\"d0d1c8a799996bf0265b98b5d48ab919\"));\n\n  /* Test case 15 */\n  test_aead(&nettle_gcm_aes256, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b391aafd255\"),\n\t    SHEX(\"522dc1f099567d07f47f37a32a84427d\"\n\t\t \"643a8cdcbfe5c0c97598a2bd2555d1aa\"\n\t\t \"8cb08e48590dbb3da7b08b1056828838\"\n\t\t \"c5f61e6393ba7a0abcc9f662898015ad\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"b094dac5d93471bdec1a502270e3cc6c\"));\n\n  /* Test case 16 */\n  test_aead(&nettle_gcm_aes256, NULL,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"522dc1f099567d07f47f37a32a84427d\"\n\t\t \"643a8cdcbfe5c0c97598a2bd2555d1aa\"\n\t\t \"8cb08e48590dbb3da7b08b1056828838\"\n\t\t \"c5f61e6393ba7a0abcc9f662\"),\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\n\t    SHEX(\"76fc6ece0f4e1768cddf8853bb2d551b\"));\n\n  /* Test case 17 */\n  test_aead(&nettle_gcm_aes256,\n\t    (nettle_hash_update_func *) gcm_aes256_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"c3762df1ca787d32ae47c13bf19844cb\"\n\t\t \"af1ae14d0b976afac52ff7d79bba9de0\"\n\t\t \"feb582d33934a4f0954cc2363bc73f78\"\n\t\t \"62ac430e64abe499f47c9b1f\"),\n\t    SHEX(\"cafebabefacedbad\"),\n\t    SHEX(\"3a337dbf46a792c45e454913fe2ea8f2\"));\n\n  /* Test case 18 */\n  test_aead(&nettle_gcm_aes256,\n\t    (nettle_hash_update_func *) gcm_aes256_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"\n\t\t \"feffe9928665731c6d6a8f9467308308\"),\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeef\"\n\t\t \"abaddad2\"),\n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da2e4c303d8a318a72\"\n\t\t \"1c3c0c95956809532fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657ba637b39\"),\n\t    SHEX(\"5a8def2f0c9e53f1f75d7853659e2a20\"\n\t\t \"eeb2b22aafde6419a058ab4f6f746bf4\"\n\t\t \"0fc0c3b780f244452da3ebf1c5d82cde\"\n\t\t \"a2418997200ef82e44ae7e3f\"),\n\t    SHEX(\"9313225df88406e555909c5aff5269aa\"\n\t\t \"6a7a9538534f7da1e4c303d2a318a728\"\n\t\t \"c3c0c95156809539fcf0e2429a6b5254\"\n\t\t \"16aedbf5a0de6a57a637b39b\"),\n\t    SHEX(\"a44a8266ee1c8eb0c8b5d4cf5ae9f19a\"));\n\n\n\n  /* \n   * GCM-Camellia Test Vectors obtained from the authors\n   */\n\n  /* Test case 1 */\n  test_aead(&nettle_gcm_camellia128,\n\t    (nettle_hash_update_func *) gcm_camellia128_set_iv,\n\t    SHEX(\"00000000000000000000000000000000\"),\t/* key */\n\t    SHEX(\"\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"000000000000000000000000\"),\t\t/* IV */\n\t    SHEX(\"f5574acc3148dfcb9015200631024df9\"));\t/* tag */\n\n  /* Test case 3 */\n  test_aead(&nettle_gcm_camellia128,\n\t    (nettle_hash_update_func *) gcm_camellia128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a72\"\n\t         \"1c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b391aafd255\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"d0d94a13b632f337a0cc9955b94fa020c815f903aab12f1efaf2fe9d90f729a6\"\n\t         \"cccbfa986ef2ff2c33de418d9a2529091cf18fe652c1cfde13f8260614bab815\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\t\t/* IV */\n\t    SHEX(\"86e318012dd8329dc9dae6a170f61b24\"));\t/* tag */\n\n  /* Test case 4 */\n  test_aead(&nettle_gcm_camellia128,\n\t    (nettle_hash_update_func *) gcm_camellia128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeefabaddad2\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a72\"\n\t         \"1c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"d0d94a13b632f337a0cc9955b94fa020c815f903aab12f1efaf2fe9d90f729a6\"\n\t         \"cccbfa986ef2ff2c33de418d9a2529091cf18fe652c1cfde13f82606\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\t\t/* IV */\n\t    SHEX(\"9f458869431576ea6a095456ec6b8101\"));\t/* tag */\n\n  /* Test case 5 */\n  test_aead(&nettle_gcm_camellia128,\n\t    (nettle_hash_update_func *) gcm_camellia128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeefabaddad2\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a72\"\n\t         \"1c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"28fd7434d5cd424a5353818fc21a982460d20cf632eb1e6c4fbfca17d5abcf6a\"\n\t         \"52111086162fe9570e7774c7a912aca3dfa10067ddaad40688645bdd\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"cafebabefacedbad\"),\t\t/* IV */\n\t    SHEX(\"e86f8f2e730c49d536f00fb5225d28b1\"));\t/* tag */\n\n  /* Test case 6 */\n  test_aead(&nettle_gcm_camellia128,\n\t    (nettle_hash_update_func *) gcm_camellia128_set_iv,\n\t    SHEX(\"feffe9928665731c6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeeffeedfacedeadbeefabaddad2\"),\t\t\t\t\t/* auth data */ \n\t    SHEX(\"d9313225f88406e5a55909c5aff5269a86a7a9531534f7da2e4c303d8a318a72\"\n\t         \"1c3c0c95956809532fcf0e2449a6b525b16aedf5aa0de657ba637b39\"),\t\t\t\t\t/* plaintext */\n\t    SHEX(\"2e582b8417c93f2ff4f6f7ee3c361e4496e710ee12433baa964987d02f42953e\"\n\t         \"402e6f4af407fe08cd2f35123696014c34db19128df4056faebcd647\"),\t\t\t\t\t/* ciphertext*/\n\t    SHEX(\"9313225df88406e555909c5aff5269aa6a7a9538534f7da1e4c303d2a318a728\"\n\t         \"c3c0c95156809539fcf0e2429a6b525416aedbf5a0de6a57a637b39b\"),\t\t/* IV */\n\t    SHEX(\"ceae5569b2af8641572622731aed3e53\"));\t/* tag */\n\n  /* gcm-camellia256 */\n\n  /* Test case 13 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"0000000000000000 0000000000000000\"\n\t\t \"0000000000000000 0000000000000000\"),\t/* key */\n\t    SHEX(\"\"),\t/* auth data */\n\t    SHEX(\"\"),\t/* plaintext */\n\t    SHEX(\"\"),\t/* ciphertext */\n\t    SHEX(\"000000000000000000000000\"),\t/* iv */\n\t    SHEX(\"9cdb269b5d293bc5db9c55b057d9b591\"));\t/* tag */\n\n  /* Test case 14 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"0000000000000000 0000000000000000\"\n\t\t \"0000000000000000 0000000000000000\"),\t/* key */\n\t    SHEX(\"\"),\t/* auth data */\n\t    SHEX(\"0000000000000000 0000000000000000\"),\t/* plaintext */\n\t    SHEX(\"3d4b2cde666761ba 5dfb305178e667fb\"),\t/* ciphertext */\n\t    SHEX(\"000000000000000000000000\"),\t/* iv */\n\t    SHEX(\"284b63bb143c40ce100fb4dea6bb617b\"));\t/* tag */\n\n  /* Test case 15 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"feffe9928665731c 6d6a8f9467308308\"\n\t\t \"feffe9928665731c 6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"\"),\t/* auth data */\n\t    SHEX(\"d9313225f88406e5 a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da 2e4c303d8a318a72\"\n\t\t \"1c3c0c9595680953 2fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657 ba637b391aafd255\"),\t/* plaintext */\n\t    SHEX(\"ad142c11579dd95e 41f3c1f324dabc25\"\n\t\t \"5864d920f1b65759 d8f560d4948d4477\"\n\t\t \"58dfdcf77aa9f625 81c7ff572a037f81\"\n\t\t \"0cb1a9c4b3ca6ed6 38179b776549e092\"),\t/* ciphertext */\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\t/* iv */\n\t    SHEX(\"c912686270a2b9966415fca3be75c468\"));\t/* tag */\n\n  /* Test case 16 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"feffe9928665731c 6d6a8f9467308308\"\n\t\t \"feffe9928665731c 6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeef feedfacedeadbeef\"\n\t\t \"abaddad2\"),\t/* auth data */\n\t    SHEX(\"d9313225f88406e5 a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da 2e4c303d8a318a72\"\n\t\t \"1c3c0c9595680953 2fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657 ba637b39\"),\t/* plaintext */\n\t    SHEX(\"ad142c11579dd95e 41f3c1f324dabc25\"\n\t\t \"5864d920f1b65759 d8f560d4948d4477\"\n\t\t \"58dfdcf77aa9f625 81c7ff572a037f81\"\n\t\t \"0cb1a9c4b3ca6ed6 38179b77\"),\t/* ciphertext */\n\t    SHEX(\"cafebabefacedbaddecaf888\"),\t/* iv */\n\t    SHEX(\"4e4b178d8fe26fdc95e2e7246dd94bec\"));\t/* tag */\n\n  /* Test case 17 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"feffe9928665731c 6d6a8f9467308308\"\n\t\t \"feffe9928665731c 6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeef feedfacedeadbeef\"\n\t\t \"abaddad2\"),\t/* auth data */\n\t    SHEX(\"d9313225f88406e5 a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da 2e4c303d8a318a72\"\n\t\t \"1c3c0c9595680953 2fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657 ba637b39\"),\t/* plaintext */\n\t    SHEX(\"6ca95fbb7d16577a 9ef2fded94dc85b5\"\n\t\t \"d40c629f6bef2c64 9888e3cbb0ededc7\"\n\t\t \"810c04b12c2983bb bbc482e16e45c921\"\n\t\t \"5ae12c15c55f2f48 09d06652\"),\t/* ciphertext */\n\t    SHEX(\"cafebabefacedbad\"),\t/* iv */\n\t    SHEX(\"e6472b8ebd331bfcc7c0fa63ce094461\"));\t/* tag */\n\n  /* Test case 18 */\n  test_aead(&nettle_gcm_camellia256,\n\t    (nettle_hash_update_func *) gcm_camellia256_set_iv,\n\t    SHEX(\"feffe9928665731c 6d6a8f9467308308\"\n\t\t \"feffe9928665731c 6d6a8f9467308308\"),\t/* key */\n\t    SHEX(\"feedfacedeadbeef feedfacedeadbeef\"\n\t\t \"abaddad2\"),\t/* auth data */\n\t    SHEX(\"d9313225f88406e5 a55909c5aff5269a\"\n\t\t \"86a7a9531534f7da 2e4c303d8a318a72\"\n\t\t \"1c3c0c9595680953 2fcf0e2449a6b525\"\n\t\t \"b16aedf5aa0de657 ba637b39\"),\t/* plaintext */\n\t    SHEX(\"e0cddd7564d09c4d c522dd65949262bb\"\n\t\t \"f9dcdb07421cf67f 3032becb7253c284\"\n\t\t \"a16e5bf0f556a308 043f53fab9eebb52\"\n\t\t \"6be7f7ad33d697ac 77c67862\"),\t/* ciphertext */\n\t    SHEX(\"9313225df88406e5 55909c5aff5269aa\"\n\t\t \"6a7a9538534f7da1 e4c303d2a318a728\"\n\t\t \"c3c0c95156809539 fcf0e2429a6b5254\"\n\t\t \"16aedbf5a0de6a57 a637b39b\"),\t/* iv */\n\t    SHEX(\"5791883f822013f8bd136fc36fb9946b\"));\t/* tag */\n\n  /* Test gcm_hash, with varying message size, keys and iv all zero.\n     Not compared to any other implementation. */\n  test_gcm_hash (SDATA(\"a\"),\n\t\t SHEX(\"1521c9a442bbf63b 2293a21d4874a5fd\"));\n  test_gcm_hash (SDATA(\"ab\"),\n\t\t SHEX(\"afb4592d2c7c1687 37f27271ee30412a\"));\n  test_gcm_hash (SDATA(\"abc\"), \n\t\t SHEX(\"9543ca3e1662ba03 9a921ec2a20769be\"));\n  test_gcm_hash (SDATA(\"abcd\"),\n\t\t SHEX(\"8f041cc12bcb7e1b 0257a6da22ee1185\"));\n  test_gcm_hash (SDATA(\"abcde\"),\n\t\t SHEX(\"0b2376e5fed58ffb 717b520c27cd5c35\"));\n  test_gcm_hash (SDATA(\"abcdef\"), \n\t\t SHEX(\"9679497a1eafa161 4942963380c1a76f\"));\n  test_gcm_hash (SDATA(\"abcdefg\"),\n\t\t SHEX(\"83862e40339536bc 723d9817f7df8282\"));\n  test_gcm_hash (SDATA(\"abcdefgh\"), \n\t\t SHEX(\"b73bcc4d6815c4dc d7424a04e61b87c5\"));\n  test_gcm_hash (SDATA(\"abcdefghi\"), \n\t\t SHEX(\"8e7846a383f0b3b2 07b01160a5ef993d\"));\n  test_gcm_hash (SDATA(\"abcdefghij\"),\n\t\t SHEX(\"37651643b6f8ecac 4ea1b320e6ea308c\"));\n  test_gcm_hash (SDATA(\"abcdefghijk\"), \n\t\t SHEX(\"c1ce10106ee23286 f00513f55e2226b0\"));\n  test_gcm_hash (SDATA(\"abcdefghijkl\"),\n\t\t SHEX(\"c6a3e32a90196cdf b2c7a415d637e6ca\"));\n  test_gcm_hash (SDATA(\"abcdefghijklm\"), \n\t\t SHEX(\"6cca29389d4444fa 3d20e65497088fd8\"));\n  test_gcm_hash (SDATA(\"abcdefghijklmn\"),\n\t\t SHEX(\"19476a997ec0a824 2022db0f0e8455ce\"));\n  test_gcm_hash (SDATA(\"abcdefghijklmno\"), \n\t\t SHEX(\"f66931cee7eadcbb d42753c3ac3c4c16\"));\n  test_gcm_hash (SDATA(\"abcdefghijklmnop\"),\n\t\t SHEX(\"a79699ce8bed61f9 b8b1b4c5abb1712e\"));\n  test_gcm_hash (SDATA(\"abcdefghijklmnopq\"), \n\t\t SHEX(\"65f8245330febf15 6fd95e324304c258\"));\n  test_gcm_hash (SDATA(\"abcdefghijklmnopqr\"),\n\t\t SHEX(\"d07259e85d4fc998 5a662eed41c8ed1d\"));\n}",
      "lines": 500,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/gosthash94-test.c": {
    "test_main": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        19,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_gosthash94, SDATA(\"The quick brown fox jumps over the lazy dog\"),\n\t    SHEX(\"77b7fa410c9ac58a25f49bca7d0468c9296529315eaca76bd1a10f376d1f4294\"));\n\n  test_hash(&nettle_gosthash94, SDATA(\"message digest\"),\n\t    SHEX(\"ad4434ecb18f2c99b60cbe59ec3d2469582b65273f48de72db2fde16a4889a4d\"));\n\n  test_hash(&nettle_gosthash94, SDATA(\"a\"),\n\t    SHEX(\"d42c539e367c66e9c88a801f6649349c21871b4344c6a573f849fdce62f314dd\"));\n\n  test_hash(&nettle_gosthash94, SDATA(\"\"),\n\t    SHEX(\"ce85b99cc46752fffee35cab9a7b0278abb4c2d2055cff685af4912c49490f8d\"));\n}",
      "lines": 15,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/hkdf-test.c": {
    "test_hkdf_sha256": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "static void\ntest_hkdf_sha256(const struct tstring *ikm,\n\t\t const struct tstring *salt,\n\t\t const struct tstring *info,\n\t\t const struct tstring *extract_output,\n\t\t const struct tstring *expand_output)\n{\n  struct hmac_sha256_ctx ctx;\n  uint8_t prk[SHA256_DIGEST_SIZE];\n  uint8_t *buffer = xalloc(expand_output->length);\n\n  hmac_sha256_set_key(&ctx, salt->length, salt->data);\n  hkdf_extract(&ctx,\n\t       (nettle_hash_update_func*) hmac_sha256_update,\n\t       (nettle_hash_digest_func*) hmac_sha256_digest,\n\t       SHA256_DIGEST_SIZE,\n\t       ikm->length, ikm->data, prk);\n\n  if (MEMEQ(SHA256_DIGEST_SIZE, prk, extract_output->data) == 0)\n    {\n      fprintf(stdout, \"\\nGot:\\n\");\n      print_hex(SHA256_DIGEST_SIZE, prk);\n      fprintf(stdout, \"\\nExpected:\\n\");\n      print_hex(extract_output->length, extract_output->data);\n      abort();\n    }\n\n  hmac_sha256_set_key(&ctx, SHA256_DIGEST_SIZE, prk);\n  hkdf_expand(&ctx,\n\t      (nettle_hash_update_func*) hmac_sha256_update,\n\t      (nettle_hash_digest_func*) hmac_sha256_digest,\n\t      SHA256_DIGEST_SIZE,\n\t      info->length, info->data,\n\t      expand_output->length, buffer);\n\n  if (MEMEQ(expand_output->length, expand_output->data, buffer) == 0)\n    {\n      fprintf(stdout, \"\\nGot:\\n\");\n      print_hex(expand_output->length, buffer);\n      fprintf(stdout, \"\\nExpected:\\n\");\n      print_hex(expand_output->length, expand_output->data);\n      abort();\n    }\n  free(buffer);\n}",
      "lines": 45,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_hkdf_sha1": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "static void\ntest_hkdf_sha1(const struct tstring *ikm,\n\t       const struct tstring *salt,\n\t       const struct tstring *info,\n\t       const struct tstring *extract_output,\n\t       const struct tstring *expand_output)\n{\n  struct hmac_sha1_ctx ctx;\n  uint8_t prk[SHA1_DIGEST_SIZE];\n  uint8_t *buffer = xalloc(expand_output->length);\n\n  hmac_sha1_set_key(&ctx, salt->length, salt->data);\n  hkdf_extract(&ctx,\n\t       (nettle_hash_update_func*) hmac_sha1_update,\n\t       (nettle_hash_digest_func*) hmac_sha1_digest,\n\t       SHA1_DIGEST_SIZE,\n\t       ikm->length, ikm->data,\n\t       prk);\n\n  if (MEMEQ(SHA1_DIGEST_SIZE, prk, extract_output->data) == 0)\n    {\n      fprintf(stdout, \"\\nGot:\\n\");\n      print_hex(SHA1_DIGEST_SIZE, prk);\n      fprintf(stdout, \"\\nExpected:\\n\");\n      print_hex(extract_output->length, extract_output->data);\n      abort();\n    }\n\n  hmac_sha1_set_key(&ctx, SHA1_DIGEST_SIZE, prk);\n  hkdf_expand(&ctx,\n\t      (nettle_hash_update_func*) hmac_sha1_update,\n\t      (nettle_hash_digest_func*) hmac_sha1_digest,\n\t      SHA1_DIGEST_SIZE,\n\t      info->length, info->data,\n\t      expand_output->length, buffer);\n\n  if (MEMEQ(expand_output->length, expand_output->data, buffer) == 0)\n    {\n      fprintf(stdout, \"\\nGot:\\n\");\n      print_hex(expand_output->length, buffer);\n      fprintf(stdout, \"\\nExpected:\\n\");\n      print_hex(expand_output->length, expand_output->data);\n      abort();\n    }\n  free(buffer);\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        97,
        0
      ],
      "end_point": [
        142,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* HKDF test vectors from RFC5869 */\n  test_hkdf_sha256(SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"),\n\tSHEX(\"000102030405060708090a0b0c\"),\n\tSHEX(\"f0f1f2f3f4f5f6f7f8f9\"),\n\tSHEX(\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"),\n\tSHEX(\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c5bf34007208d5b887185865\"));\n\n  test_hkdf_sha256(SHEX(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f\"),\n\tSHEX(\"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf\"),\n\tSHEX(\"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n\tSHEX(\"06a6b88c5853361a06104c9ceb35b45cef760014904671014a193f40c15fc244\"),\n\tSHEX(\"b11e398dc80327a1c8e7f78c596a49344f012eda2d4efad8a050cc4c19afa97c59045a99cac7827271cb41c65e590e09da3275600c2f09b8367793a9aca3db71cc30c58179ec3e87c14c01d5c1f3434f1d87\"));\n\n  test_hkdf_sha256(SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"),\n\tSDATA(\"\"),\n\tSDATA(\"\"),\n\tSHEX(\"19ef24a32c717b167f33a91d6f648bdf96596776afdb6377ac434c1c293ccb04\"),\n\tSHEX(\"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d9d201395faa4b61a96c8\"));\n\n  test_hkdf_sha1(SHEX(\"0b0b0b0b0b0b0b0b0b0b0b\"),\n\tSHEX(\"000102030405060708090a0b0c\"),\n\tSHEX(\"f0f1f2f3f4f5f6f7f8f9\"),\n\tSHEX(\"9b6c18c432a7bf8f0e71c8eb88f4b30baa2ba243\"),\n\tSHEX(\"085a01ea1b10f36933068b56efa5ad81a4f14b822f5b091568a9cdd4f155fda2c22e422478d305f3f896\"));\n\n  test_hkdf_sha1(SHEX(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132333435363738393a3b3c3d3e3f404142434445464748494a4b4c4d4e4f\"),\n\tSHEX(\"606162636465666768696a6b6c6d6e6f707172737475767778797a7b7c7d7e7f808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9fa0a1a2a3a4a5a6a7a8a9aaabacadaeaf\"),\n\tSHEX(\"b0b1b2b3b4b5b6b7b8b9babbbcbdbebfc0c1c2c3c4c5c6c7c8c9cacbcccdcecfd0d1d2d3d4d5d6d7d8d9dadbdcdddedfe0e1e2e3e4e5e6e7e8e9eaebecedeeeff0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\"),\n\tSHEX(\"8adae09a2a307059478d309b26c4115a224cfaf6\"),\n\tSHEX(\"0bd770a74d1160f7c9f12cd5912a06ebff6adcae899d92191fe4305673ba2ffe8fa3f1a4e5ad79f3f334b3b202b2173c486ea37ce3d397ed034c7f9dfeb15c5e927336d0441f4c4300e2cff0d0900b52d3b4\"));\n\n  test_hkdf_sha1(SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"),\n\tSDATA(\"\"),\n\tSDATA(\"\"),\n\tSHEX(\"da8c8a73c7fa77288ec6f5e7c297786aa0d32d01\"),\n\tSHEX(\"0ac1af7002b3d761d1e55298da9d0506b9ae52057220a306e07b6b87e8df21d0ea00033de03984d34918\"));\n\n  test_hkdf_sha1(SHEX(\"0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c\"),\n\tSHEX(\"\"),\n\tSHEX(\"\"),\n\tSHEX(\"2adccada18779e7c2077ad2eb19d3f3e731385dd\"),\n\tSHEX(\"2c91117204d745f3500d636a62f64f0ab3bae548aa53d423b0d1f27ebba6f5e5673a081d70cce7acfc48\"));\n}",
      "lines": 46,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/hmac-test.c": {
    "test_main": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        896,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* sha512's digests are longest */\n  uint8_t digest[SHA512_DIGEST_SIZE+1];\n\n  memset(digest, 0, sizeof(digest));\n\n  /* Test vectors for md5, from RFC-2202 */\n\n  /* md5 - 1 */\n  HMAC_TEST(md5,\n\t    SHEX(\"0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"9294727a3638bb1c 13f48ef8158bfc9d\"));\n\n\n  /* md5 - 2 */\n  HMAC_TEST(md5,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"750c783e6ab0b503 eaa86e310a5db738\"));\t    \n\n  /* md5 - 3 */\n  HMAC_TEST(md5,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"56be34521d144c88 dbb8c733f0e8b3f6\"));\n  \n  /* md5 - 4 */\n  HMAC_TEST(md5,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\" \n\t\t \"1112131415161718 19\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"697eaf0aca3a3aea 3a75164746ffaa79\"));\n\n  /* md5 - 5 */\n  HMAC_TEST(md5,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"56461ef2342edc00 f9bab995\"));\n\n  /* md5 - 6 */\n  HMAC_TEST(md5,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"6b1ab7fe4bd7bf8f 0b62e6ce61b9d0cd\"));\n\n  /* md5 - 7 */\n  HMAC_TEST(md5,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key and Larger \"\n\t\t  \"Than One Block-Size Data\"),\n\t    SHEX(\"6f630fad67cda0ee 1fb1f562db3aa53e\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"e84db42a188813f30a15e611d64c7869\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"123662062e67c2aab371cc49db0df134\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"38\"),\n\t    SHEX(\"0a46cc10a49d4b7025c040c597bf5d76\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"d1f4d89f0e8b2b6ed0623c99ec298310\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"1627207b9bed5009a4f6e9ca8d2ca01e\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"922aae6ab3b3a29202e21ce5f916ae9a\"));\n\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"ede9cb83679ba82d88fbeae865b3f8fc\"));\n\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\n\t    SHEX(\"939dd45512ee3a594b6654f6b8de27f7\"));\n\n  /* Test vectors for ripemd160, from\n     http://homes.esat.kuleuven.be/~bosselae/ripemd160.html */\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"cf387677bfda8483e63b57e06c3b5ecd8b7fc055\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"0d351d71b78e36dbb7391c810a0d2b6240ddbafc\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"f7ef288cb1bbcc6160d76507e0a3bbf712fb67d6\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"f83662cc8d339c227e600fcd636c57d2571b1c34\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"843d1c4eb880ac8ac0c9c95696507957d0155ddb\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"),\n\t    SHEX(\"60f5ef198a2dd5745545c1f0c47aa3fb5776f881\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"00112233445566778899aabbccddeeff01234567\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"e49c136a9e5627e0681b808a3b97e6a6e661ae79\"));\n\n  /* Other key */\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"fe69a66c7423eea9c8fa2eff8d9dafb4f17a62f5\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"85743e899bc82dbfa36faaa7a25b7cfd372432cd\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"6e4afd501fa6b4a1823ca3b10bd9aa0ba97ba182\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"2e066e624badb76a184c8f90fba053330e650e92\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"07e942aa4e3cd7c04dedc1d46e2e8cc4c741b3d9\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"),\n\t    SHEX(\"b6582318ddcfb67a53a67d676b8ad869aded629a\"));\n\n  HMAC_TEST(ripemd160,\n\t    SHEX(\"0123456789abcdeffedcba987654321000112233\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"f1be3ee877703140d34f97ea1ab3a07c141333e2\"));\n\n  /* Test vectors for sha1, from RFC-2202 */\n\n  /* sha1 - 1 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b 0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"b617318655057264 e28bc0b6fb378c8e f146be00\"));\n\n  /* sha1 - 2 */\n  HMAC_TEST(sha1,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"effcdf6ae5eb2fa2 d27416d5f184df9c 259a7c79\"));\n\n  /* sha1 - 3 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa aaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"125d7342b9ac11cd 91a39af48aa17b4f 63f175d3\"));\n\n  /* sha1 - 4 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\" \n\t\t \"1112131415161718 19\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"4c9007f4026250c6 bc8414f9bf50c86c 2d7235da\"));\n\n  /* sha1 - 5 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"4c1a03424b55e07f e7f27be1\"));\n\n  /* sha1 - 6 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"aa4ae5e15272d00e 95705637ce8a3b55 ed402112\"));\n\n  /* sha1 - 7 */\n  HMAC_TEST(sha1,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key and Larger \"\n\t\t  \"Than One Block-Size Data\"),\n\t    SHEX(\"e8e99d0f45237d78 6d6bbaa7965c7808 bbff1a91\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"e84db42a188813f30a15e611d64c7869\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"123662062e67c2aab371cc49db0df134\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"38\"),\n\t    SHEX(\"0a46cc10a49d4b7025c040c597bf5d76\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"d1f4d89f0e8b2b6ed0623c99ec298310\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"1627207b9bed5009a4f6e9ca8d2ca01e\"));\n  \n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"922aae6ab3b3a29202e21ce5f916ae9a\"));\n\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"ede9cb83679ba82d88fbeae865b3f8fc\"));\n\n  HMAC_TEST(md5,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\n\t    SHEX(\"939dd45512ee3a594b6654f6b8de27f7\"));\n\n  /* Test vectors for sha224, from RFC 4231 */\n  HMAC_TEST(sha224,\n\t    SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"896fb1128abbdf196832107cd49df33f\"\n\t\t \"47b4b1169912ba4f53684b22\"));\n\n  HMAC_TEST(sha224,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"a30e01098bc6dbbf45690f3a7e9e6d0f\"\n\t\t \"8bbea2a39e6148008fd05e44\"));\n\n  HMAC_TEST(sha224,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"7fb3cb3588c6c1f6ffa9694d7d6ad264\"\n\t\t \"9365b0c1f65d69d1ec8333ea\"));\n\n  HMAC_TEST(sha224,\n\t    SHEX(\"0102030405060708090a0b0c0d0e0f10\"\n\t\t \"111213141516171819\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"6c11506874013cac6a2abc1bb382627c\"\n\t\t \"ec6a90d86efc012de7afec5a\"));\n\n  HMAC_TEST(sha224,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"0e2aea68a90c8d37c988bcdb9fca6fa8\"));\n\n  HMAC_TEST(sha224,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"95e9a0db962095adaebe9b2d6f0dbce2\"\n\t\t \"d499f112f2d2b7273fa6870e\"));\n\n  HMAC_TEST(sha224,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"This is a test using a larger than block-size ke\"\n\t\t  \"y and a larger than block-size data. The key nee\"\n\t\t  \"ds to be hashed before being used by the HMAC al\"\n\t\t  \"gorithm.\"),\n\t    SHEX(\"3a854166ac5d9f023f54d517d0b39dbd\"\n\t\t \"946770db9c2b95c9f6f565d1\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"d12a49ae38177ffeaa548b2148bb5238\"\n\t\t \"60849772d9391e675b103d89\"));\n  \n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"b04ff8522f904f553970bfa8ad3f0086\"\n\t\t \"bce1e8580affd8a12c94e31a\"));\n  \n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"38\"),\n\t    SHEX(\"afcfb5511f710334f9350f57faec3c08\"\n\t\t \"764b4bd126a6840f4347f116\"));\n  \n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"9df9907af127900c909376893565c6cf\"\n\t\t \"2d7db244fdc4277da1e0b679\"));\n  \n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"254ebf6b8ddd7a3271b3d9aca1699b0c\"\n\t\t \"0bfb7df61e8a114922c88d27\"));\n  \n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"6ec5bffba5880c3234a6cf257816e4d5\"\n\t\t \"35ab178a7f12929769e378fb\"));\n\n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"5f768179dbb29ca722875d0f461a2e2f\"\n\t\t \"597d0210340a84df1a8e9c63\"));\n\n  HMAC_TEST(sha224,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\n\t    SHEX(\"c7667b0d7e56b2b4f6fcc1d8da9e22da\"\n\t\t \"a1556f44c47132a87303c6a2\"));\n\n  /* Test vectors for sha256, from RFC 4231 */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"b0344c61d8db38535ca8afceaf0bf12b\"\n\t\t \"881dc200c9833da726e9376c2e32cff7\"));\n\n  HMAC_TEST(sha256,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"5bdcc146bf60754e6a042426089575c7\"\n\t\t \"5a003f089d2739839dec58b964ec3843\"));\n\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"773ea91e36800e46854db8ebd09181a7\"\n\t\t \"2959098b3ef8c122d9635514ced565fe\"));\n\n  HMAC_TEST(sha256,\n\t    SHEX(\"0102030405060708090a0b0c0d0e0f10\"\n\t\t \"111213141516171819\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"82558a389a443c0ea4cc819899f2083a\"\n\t\t \"85f0faa3e578f8077a2e3ff46729665b\"));\n\n  HMAC_TEST(sha256,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"a3b6167473100ee06e0c796c2955552b\"));\n\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"60e431591ee0b67f0d8a26aacbf5b77f\"\n\t\t \"8e0bc6213728c5140546040f0ee37f54\"));\n\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"This is a test using a larger than block-size ke\"\n\t\t  \"y and a larger than block-size data. The key nee\"\n\t\t  \"ds to be hashed before being used by the HMAC al\"\n\t\t  \"gorithm.\"),\n\t    SHEX(\"9b09ffa71b942fcb27635fbcd5b0e944\"\n\t\t \"bfdc63644f0713938a7f51535c3a35e2\"));\n\n  /* Additional test vectors for sha256, from\n     draft-ietf-ipsec-ciph-sha-256-01.txt */\n\n  /* Test Case #1: HMAC-SHA-256 with 3-byte input and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\"\n\t\t \"1112131415161718 191a1b1c1d1e1f20\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"a21b1f5d4cf4f73a 4dd939750f7a066a\"\n\t\t \"7f98cc131cb16a66 92759021cfab8181\"));\n\n  /* Test Case #2: HMAC-SHA-256 with 56-byte input and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\"\n\t\t \"1112131415161718 191a1b1c1d1e1f20\"),\n\t    SDATA(\"abcdbcdecdefdefgefghfghighijhijk\"\n\t\t  \"ijkljklmklmnlmnomnopnopq\"),\n\t    SHEX(\"104fdc1257328f08 184ba73131c53cae\"\n\t\t \"e698e36119421149 ea8c712456697d30\"));\n\n  /* Test Case #3: HMAC-SHA-256 with 112-byte (multi-block) input\n     and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\"\n\t\t \"1112131415161718 191a1b1c1d1e1f20\"),\n\t    SDATA(\"abcdbcdecdefdefgefghfghighijhijk\"\n\t\t  \"ijkljklmklmnlmnomnopnopqabcdbcde\"\n\t\t  \"cdefdefgefghfghighijhijkijkljklm\"\n\t\t  \"klmnlmnomnopnopq\"),\n\t    SHEX(\"470305fc7e40fe34 d3eeb3e773d95aab\"\n\t\t \"73acf0fd060447a5 eb4595bf33a9d1a3\"));\n\n  /* Test Case #4:  HMAC-SHA-256 with 8-byte input and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b0b0b0b0b 0b0b0b0b0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"198a607eb44bfbc6 9903a0f1cf2bbdc5\"\n\t\t \"ba0aa3f3d9ae3c1c 7a3b1696a0b68cf7\"));\n\n  /* Test Case #6: HMAC-SHA-256 with 50-byte input and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddddddddddddddd dddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"cdcb1220d1ecccea 91e53aba3092f962\"\n\t\t \"e549fe6ce9ed7fdc 43191fbde45c30b0\"));\n\n  /* Test Case #7: HMAC-SHA-256 with 50-byte input and 37-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0102030405060708 090a0b0c0d0e0f10\"\n\t\t \"1112131415161718 191a1b1c1d1e1f20\"\n\t\t \"2122232425\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcd cdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"d4633c17f6fb8d74 4c66dee0f8f07455\"\n\t\t \"6ec4af55ef079985 41468eb49bd2e917\"));\n\n  /* Test Case #8: HMAC-SHA-256 with 20-byte input and 32-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c\"\n\t\t \"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"7546af01841fc09b 1ab9c3749a5f1c17\"));\n\n  /* Test Case #9: HMAC-SHA-256 with 54-byte input and 80-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"6953025ed96f0c09 f80a96f78e6538db\"\n\t\t \"e2e7b820e3dd970e 7ddd39091b32352f\"));\n\n  /* Test Case #10: HMAC-SHA-256 with 73-byte (multi-block) input\n     and 80-byte key */\n  HMAC_TEST(sha256,\n\t    SHEX(\"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaa aaaaaaaaaaaaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data\"),\n\t    SHEX(\"6355ac22e890d0a3 c8481a5ca4825bc8\"\n\t\t \"84d3e7a1ff98a2fc 2ac7d8e064c3b2e6\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"5c780648c90d121c50091c3a0c3afc1f\"\n\t\t \"4ab847528005d99d9821ad3f341b651a\"));\n  \n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"6142364c0646b0cfe426866f21d613e0\"\n\t\t \"55a136a7d9b45d85685e080a09cec463\"));\n  \n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"38\"),\n\t    SHEX(\"e49aa7839977e130ad87b63da9d4eb7b\"\n\t\t \"263cd5a27c54a7604b6044eb35901171\"));\n  \n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"e5ef49f545c7af933a9d18c7c562bc91\"\n\t\t \"08583fd5cf00d9e0db351d6d8f8e41bc\"));\n  \n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"373b04877180fea27a41a8fb8f88201c\"\n\t\t \"a6268411ee3c80b01a424483eb9156e1\"));\n  \n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"eb5945d56eefbdb41602946ea6448d53\"\n\t\t \"86b08d7d801a87f439fab52f8bb9736e\"));\n\n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"3798f363c57afa6edaffe39016ca7bad\"\n\t\t \"efd1e670afb0e3987194307dec3197db\"));\n\n  HMAC_TEST(sha256,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\n\t    SHEX(\"c89a7039a62985ff813fe4509b918a43\"\n\t\t \"6d7b1ffd8778e2c24dec464849fb6128\"));\n\n  /* Test vectors for sha384, from RFC 4231 */\n  HMAC_TEST(sha384,\n\t    SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"afd03944d84895626b0825f4ab46907f\"\n\t\t \"15f9dadbe4101ec682aa034c7cebc59c\"\n\t\t \"faea9ea9076ede7f4af152e8b2fa9cb6\"));\n\n  HMAC_TEST(sha384,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"af45d2e376484031617f78d2b58a6b1b\"\n\t\t \"9c7ef464f5a01b47e42ec3736322445e\"\n\t\t \"8e2240ca5e69e2c78b3239ecfab21649\"));\n\n  HMAC_TEST(sha384,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"88062608d3e6ad8a0aa2ace014c8a86f\"\n\t\t \"0aa635d947ac9febe83ef4e55966144b\"\n\t\t \"2a5ab39dc13814b94e3ab6e101a34f27\"));\n\n  HMAC_TEST(sha384,\n\t    SHEX(\"0102030405060708090a0b0c0d0e0f10\"\n\t\t \"111213141516171819\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"3e8a69b7783c25851933ab6290af6ca7\"\n\t\t \"7a9981480850009cc5577c6e1f573b4e\"\n\t\t \"6801dd23c4a7d679ccf8a386c674cffb\"));\n\n  HMAC_TEST(sha384,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"3abf34c3503b2a23a46efc619baef897\"));\n\n  HMAC_TEST(sha384,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"4ece084485813e9088d2c63a041bc5b4\"\n\t\t \"4f9ef1012a2b588f3cd11f05033ac4c6\"\n\t\t \"0c2ef6ab4030fe8296248df163f44952\"));\n\n  HMAC_TEST(sha384,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"This is a test using a larger than block-size ke\"\n\t\t  \"y and a larger than block-size data. The key nee\"\n\t\t  \"ds to be hashed before being used by the HMAC al\"\n\t\t  \"gorithm.\"),\n\t    SHEX(\"6617178e941f020d351e2f254e8fd32c\"\n\t\t \"602420feb0b8fb9adccebb82461e99c5\"\n\t\t \"a678cc31e799176d3860e6110c46523e\"));\n\n  /* Test vectors for sha512, from RFC 4231 */\n  HMAC_TEST(sha512,\n\t    SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"87aa7cdea5ef619d4ff0b4241a1d6cb0\"\n\t\t \"2379f4e2ce4ec2787ad0b30545e17cde\"\n\t\t \"daa833b7d6b8a702038b274eaea3f4e4\"\n\t\t \"be9d914eeb61f1702e696c203a126854\"));\n\n  HMAC_TEST(sha512,\n\t    SDATA(\"Jefe\"),\n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"164b7a7bfcf819e2e395fbe73b56e0a3\"\n\t\t \"87bd64222e831fd610270cd7ea250554\"\n\t\t \"9758bf75c05a994a6d034f65f8f0e6fd\"\n\t\t \"caeab1a34d4a6b4b636e070a38bce737\"));\n\n  HMAC_TEST(sha512,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"fa73b0089d56a284efb0f0756c890be9\"\n\t\t \"b1b5dbdd8ee81a3655f83e33b2279d39\"\n\t\t \"bf3e848279a722c806b485a47e67c807\"\n\t\t \"b946a337bee8942674278859e13292fb\"));\n\n  HMAC_TEST(sha512,\n\t    SHEX(\"0102030405060708090a0b0c0d0e0f10\"\n\t\t \"111213141516171819\"),\n\t    SHEX(\"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n\t\t \"cdcd\"),\n\t    SHEX(\"b0ba465637458c6990e5a8c5f61d4af7\"\n\t\t \"e576d97ff94b872de76f8050361ee3db\"\n\t\t \"a91ca5c11aa25eb4d679275cc5788063\"\n\t\t \"a5f19741120c4f2de2adebeb10a298dd\"));\n\n  HMAC_TEST(sha512,\n\t    SHEX(\"0c0c0c0c0c0c0c0c 0c0c0c0c0c0c0c0c 0c0c0c0c\"),\n\t    SDATA(\"Test With Truncation\"),\n\t    SHEX(\"415fad6271580a531d4179bc891d87a6\"));\n\n  HMAC_TEST(sha512,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"Test Using Larger Than Block-Size Key - Hash Key First\"),\n\t    SHEX(\"80b24263c7c1a3ebb71493c1dd7be8b4\"\n\t\t \"9b46d1f41b4aeec1121b013783f8f352\"\n\t\t \"6b56d037e05f2598bd0fd2215d6a1e52\"\n\t\t \"95e64f73f63f0aec8b915a985d786598\"));\n\n  HMAC_TEST(sha512,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaa\"),\n\t    SDATA(\"This is a test using a larger than block-size ke\"\n\t\t  \"y and a larger than block-size data. The key nee\"\n\t\t  \"ds to be hashed before being used by the HMAC al\"\n\t\t  \"gorithm.\"),\n\t    SHEX(\"e37b6a775dc87dbaa4dfa9f96e5e3ffd\"\n\t\t \"debd71f8867289865df5a32d20cdc944\"\n\t\t \"b6022cac3c4982b10d5eeb55c3e4de15\"\n\t\t \"134676fb6de0446065c97440fa8c6a58\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"\"),\n\t    SHEX(\"34316413c2d6940572d0bbbf099d529d\"\n\t\t \"148b424533cf562bc1b365f530e21a31\"\n\t\t \"799fc51cef78060cc6f448a8e5d780c2\"\n\t\t \"6cdf20d4c3e6f27fe5ef576bbd05e855\"));\n  \n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"a\"),\n\t    SHEX(\"cf1948507378bc3ab58cb6ec87f4d456\"\n\t\t \"b90d3298395c29873f1ded1e111b50fe\"\n\t\t \"c336ed24684bf19716efc309212f37aa\"\n\t\t \"715cfb9ecccf3af13691ded167b4b336\"));\n  \n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"38\"),\n\t    SHEX(\"b8201784216ce01b83cdd282616c6e89\"\n\t\t \"644c6dfd1269ed8580bbc39b92add364\"\n\t\t \"c2b2a2018cffb1915e8625e473b67d0f\"\n\t\t \"e54a50e475dfa0e2b1a97bac1383792c\"));\n  \n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abc\"),\n\t    SHEX(\"f097ee08b8c44e847a384f9fd645e35e\"\n\t\t \"4816baa9791ba39d3dc611210500b044\"\n\t\t \"873ee296bf1047dc06daa201a5767192\"\n\t\t \"5b73b4ea59c60114881c8287d0699c83\"));\n  \n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"message digest\"),\n\t    SHEX(\"921a441a884b83c76a8526da8e60d60d\"\n\t\t \"17ded4eee5c29375e0d93717669a4c3e\"\n\t\t \"eba7473e95f7c1a2a85afc24a0adbc4d\"\n\t\t \"6c2bdd6ca6cab8b18d19f82d4a6c51bc\"));\n  \n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"640054c96f35815095617d0a8c956066\"\n\t\t \"1a6ff46bfb39110333b2c52c8866abfb\"\n\t\t \"59d9152c9b0948c1ed65c3fd72a8fb82\"\n\t\t \"190acc8830770afe5b0c5b6414c75a77\"));\n\n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"835a4f5b3750b4c1fccfa88da2f746a4\"\n\t\t \"900160c9f18964309bb736c13b59491b\"\n\t\t \"8e32d37b724cc5aebb0f554c6338a3b5\"\n\t\t \"94c4ba26862b2dadb59b7ede1d08d53e\"));\n\n  HMAC_TEST(sha512,\n\t    SDATA(\"monkey monkey monkey monkey\"),\n\t    SDATA(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"),\n\t    SHEX(\"fdf83dc879e3476c8e8aceff2bf6fece\"\n\t\t \"2e4f39c7e1a167845465bb549dfa5ffe\"\n\t\t \"997e6c7cf3720eae51ed2b00ad2a8225\"\n\t\t \"375092290edfa9d48ec7e4bc8e276088\"));\n\n  /* Additional test vectors, from\n     draft-kelly-ipsec-ciph-sha2-01.txt */\n\n  /* Test case AUTH512-1: */\n  HMAC_TEST(sha512,\n\t    SHEX(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n\t\t \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"),\n\t    SDATA(\"Hi There\"),\n\t    SHEX(\"637edc6e01dce7e6742a99451aae82df\"\n\t\t \"23da3e92439e590e43e761b33e910fb8\"\n\t\t \"ac2878ebd5803f6f0b61dbce5e251ff8\"\n\t\t \"789a4722c1be65aea45fd464e89f8f5b\"));\n\n  /* Test case AUTH512-2: */\n  HMAC_TEST(sha512,\n\t    SDATA(\"JefeJefeJefeJefe\"\n\t\t  \"JefeJefeJefeJefe\"\n\t\t  \"JefeJefeJefeJefe\"\n\t\t  \"JefeJefeJefeJefe\"),\t    \n\t    SDATA(\"what do ya want for nothing?\"),\n\t    SHEX(\"cb370917ae8a7ce28cfd1d8f4705d614\"\n\t\t \"1c173b2a9362c15df235dfb251b15454\"\n\t\t \"6aa334ae9fb9afc2184932d8695e397b\"\n\t\t \"fa0ffb93466cfcceaae38c833b7dba38\"));\n\n  /* Test case AUTH512-3: */\n  HMAC_TEST(sha512,\n\t    SHEX(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n\t\t \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"),\n\t    SHEX(\"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddddddddddddddddddddddddddddddd\"\n\t\t \"dddd\"),\n\t    SHEX(\"2ee7acd783624ca9398710f3ee05ae41\"\n\t\t \"b9f9b0510c87e49e586cc9bf961733d8\"\n\t\t \"623c7b55cebefccf02d5581acc1c9d5f\"\n\t\t \"b1ff68a1de45509fbe4da9a433922655\"));\n\n  /* Test case AUTH512-3 from same document seems broken. */\n}",
      "lines": 882,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/knuth-lfib-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        18,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct knuth_lfib_ctx ctx;\n\n  uint32_t a[2009];\n  uint32_t x;\n  unsigned m;\n  \n  knuth_lfib_init(&ctx, 310952);\n  for (m = 0; m<2009; m++)\n    knuth_lfib_get_array(&ctx, 1009, a);\n\n  x = knuth_lfib_get(&ctx);\n  ASSERT (x == 461390032);\n}",
      "lines": 16,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/md2-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Testcases from RFC 1319 */\n  test_hash(&nettle_md2, SDATA(\"\"),\n\t    SHEX(\"8350e5a3e24c153df2275c9f80692773\"));\n  test_hash(&nettle_md2, SDATA(\"a\"),\n\t    SHEX(\"32ec01ec4a6dac72c0ab96fb34c0b5d1\"));\n  test_hash(&nettle_md2, SDATA(\"abc\"),\n\t    SHEX(\"da853b0d3f88d99b30283a69e6ded6bb\"));\n  test_hash(&nettle_md2, SDATA(\"message digest\"),\n\t    SHEX(\"ab4f496bfb2a530b219ff33031fe06b0\"));\n  test_hash(&nettle_md2, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"4e8ddff3650292ab5a4108c3aa47940b\"));\n  test_hash(&nettle_md2,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"),\n\t    SHEX(\"da33def2a42df13975352846c30338cd\"));\n  test_hash(&nettle_md2, SDATA(\"1234567890123456789012345678901234567890\"\n\t\t\t       \"1234567890123456789012345678901234567890\"),\n\t    SHEX(\"d5976f79d83d3a0dc9806c3c66f3efd8\"));\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/md4-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Testcases from RFC 1320 */\n  test_hash(&nettle_md4, SDATA(\"\"),\n\t    SHEX(\"31d6cfe0d16ae931b73c59d7e0c089c0\"));\n  test_hash(&nettle_md4, SDATA(\"a\"),\n\t    SHEX(\"bde52cb31de33e46245e05fbdbd6fb24\"));\n  test_hash(&nettle_md4, SDATA(\"abc\"),\n\t    SHEX(\"a448017aaf21d8525fc10ae87aa6729d\"));\n  test_hash(&nettle_md4, SDATA(\"message digest\"),\n\t    SHEX(\"d9130a8164549fe818874806e1c7014b\"));\n  test_hash(&nettle_md4, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"d79e1c308aa5bbcdeea8ed63df412da9\"));\n  test_hash(&nettle_md4,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"),\n\t    SHEX(\"043f8582f241db351ce627e153e7f0e4\"));\n  test_hash(&nettle_md4,\n\t    SDATA(\"12345678901234567890123456789012345678901234567890\"\n\t\t  \"123456789012345678901234567890\"),\n\t    SHEX(\"e33b4ddc9c38f2199c3e7b164fcc0536\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  test_hash(&nettle_md4, SDATA(\"38\"),\n\t    SHEX(\"ae9c7ebfb68ea795483d270f5934b71d\"));\n  test_hash(&nettle_md4, SDATA(\"abc\"),\n\t    SHEX(\"a448017aaf21d8525fc10ae87aa6729d\"));\n  test_hash(&nettle_md4, SDATA(\"message digest\"),\n\t    SHEX(\"d9130a8164549fe818874806e1c7014b\"));\n  test_hash(&nettle_md4, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"d79e1c308aa5bbcdeea8ed63df412da9\"));\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/md5-compat-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  MD5_CTX ctx;\n  unsigned char digest[MD5_DIGEST_SIZE];\n\n  MD5Init(&ctx);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"D41D8CD98F00B204 E9800998ECF8427E\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"a\"), 1);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"0CC175B9C0F1B6A8 31C399E269772661\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"abc\"), 3);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"900150983cd24fb0 D6963F7D28E17F72\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"message digest\"), 14);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"F96B697D7CB7938D 525A2F31AAF161D0\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"abcdefghijklmnopqrstuvwxyz\"), 26);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"C3FCD3D76192E400 7DFB496CCA67E13B\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"), 62);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"D174AB98D277D9F5 A5611C2C9F419D9F\")));\n\n  MD5Init(&ctx);\n  MD5Update(&ctx, US(\"1234567890123456789012345678901234567890\"\n\t\t     \"1234567890123456789012345678901234567890\"),\n\t    80);\n  MD5Final(digest, &ctx);\n  ASSERT(MEMEQ(MD5_DIGEST_SIZE, digest,\n\t       H(\"57EDF4A22BE3C955 AC49DA2E2107B67A\")));\n}",
      "lines": 49,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/md5-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        95,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_md5, SDATA(\"\"),\n\t    SHEX(\"D41D8CD98F00B204 E9800998ECF8427E\"));\n\n  test_hash(&nettle_md5, SDATA(\"a\"),\n\t    SHEX(\"0CC175B9C0F1B6A8 31C399E269772661\"));\n\t    \n  test_hash(&nettle_md5, SDATA(\"abc\"),\n\t    SHEX(\"900150983cd24fb0 D6963F7D28E17F72\"));\n\n  test_hash(&nettle_md5, SDATA(\"message digest\"),\n\t    SHEX(\"F96B697D7CB7938D 525A2F31AAF161D0\"));\n  \n  test_hash(&nettle_md5, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"C3FCD3D76192E400 7DFB496CCA67E13B\"));\n  \n  test_hash(&nettle_md5,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"),\n\t    SHEX(\"D174AB98D277D9F5 A5611C2C9F419D9F\"));\n\n  test_hash(&nettle_md5,\n\t    SDATA(\"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"),\n\t    SHEX(\"57EDF4A22BE3C955 AC49DA2E2107B67A\"));\n\n  /* Additional test vector, from Daniel Kahn Gillmor */\n  test_hash(&nettle_md5, SDATA(\"38\"),\n\t    SHEX(\"a5771bce93e200c3 6f7cd9dfd0e5deaa\"));\n\n  /* Collisions, reported by Xiaoyun Wang1, Dengguo Feng2, Xuejia\n     Lai3, Hongbo Yu1, http://eprint.iacr.org/2004/199. */\n\n#define M0 \\\n  /*                                          vv */\t\t\t\t\\\n  \"d131dd02 c5e6eec4 693d9a06 98aff95c 2fcab5 87 12467eab 4004583e b8fb7f89\"\t\\\n  \"55ad3406 09f4b302 83e48883 25 71 415a 085125e8 f7cdc99f d91dbd f2 80373c5b\"\t\\\n  /*                             ^^                               ^^ */\n\n#define M1 \\\n  /*                                          vv */\t\t\t\t\\\n  \"d131dd02 c5e6eec4 693d9a06 98aff95c 2fcab5 07 12467eab 4004583e b8fb7f89\"\t\\\n  \"55ad3406 09f4b302 83e48883 25 f1 415a 085125e8 f7cdc99f d91dbd 72 80373c5b\"\t\\\n  /*                             ^^                               ^^ */\n\n#define N0\t\t\t\t\t\t\t\t\t\\\n  /*                                          vv */\t\t\t\t\\\n  \"960b1dd1 dc417b9c e4d897f4 5a6555d5 35739a c7 f0ebfd0c 3029f166 d109b18f\"\t\\\n  \"75277f79 30d55ceb 22e8adba 79 cc 155c ed74cbdd 5fc5d36d b19b0a d8 35cca7e3\"\t\\\n  /*                             ^^                               ^^ */\n\n#define N1\t\t\t\t\t\t\t\t\t\\\n  /*                                          vv */\t\t\t\t\\\n  \"960b1dd1 dc417b9c e4d897f4 5a6555d5 35739a 47 f0ebfd0c 3029f166 d109b18f\"\t\\\n  \"75277f79 30d55ceb 22e8adba 79 4c 155c ed74cbdd 5fc5d36d b19b0a 58 35cca7e3\"\t\\\n  /*                             ^^                               ^^ */\n\n  /* Note: The checksum in the paper, 1f160396 efc71ff4 bcff659f\n     bf9d0fa3, is incorrect. */\n\n#define H0 \"a4c0d35c 95a63a80 5915367d cfe6b751\"\n\n#define N2\t\t\t\t\t\t\t\t\t\\\n  /*                                          vv */\t\t\t\t\\\n  \"d8823e31 56348f5b ae6dacd4 36c919c6 dd53e2 b4 87da03fd 02396306 d248cda0\"\t\\\n  \"e99f3342 0f577ee8 ce54b670 80 a8 0d1e c69821bc b6a88393 96f965 2b 6ff72a70\"\t\\\n  /*                             ^^                               ^^ */\n\n#define N3\t\t\t\t\t\t\t\t\t\\\n  /*                                          vv */\t\t\t\t\\\n  \"d8823e31 56348f5b ae6dacd4 36c919c6 dd53e2 34 87da03fd 02396306 d248cda0\"\t\\\n  \"e99f3342 0f577ee8 ce54b670 80 28 0d1e c69821bc b6a88393 96f965 ab 6ff72a70\"\t\\\n  /*                             ^^                               ^^ */\n\n  /* Note: Also different from the checksum in the paper */\n  \n#define H1 \"79054025 255fb1a2 6e4bc422 aef54eb4\"\n  \n  test_hash(&nettle_md5,\n\t    SHEX(M0 N0), SHEX(H0));\n\n  test_hash(&nettle_md5,\n\t    SHEX(M1 N1), SHEX(H0));\n\n  test_hash(&nettle_md5,\n\t    SHEX(M0 N2), SHEX(H1));\n\n  test_hash(&nettle_md5,\n\t    SHEX(M1 N3), SHEX(H1));\n}",
      "lines": 93,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/memeql-test.c": {
    "memeql_sec_for_test": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        19,
        1
      ],
      "content": "static int\nmemeql_sec_for_test(const void *a, const void *b, size_t n)\n{\n  int res;\n\n  /* Makes valgrind trigger on any branches depending on the input\n     data. */\n  VALGRIND_MAKE_MEM_UNDEFINED (a, n);\n  VALGRIND_MAKE_MEM_UNDEFINED (b, n);\n\n  res = memeql_sec (a, b, n);\n  VALGRIND_MAKE_MEM_DEFINED (&res, sizeof(res));\n  return res;\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_main": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  uint8_t orig[MAX_SIZE];\n  uint8_t a[MAX_SIZE];\n  uint8_t b[MAX_SIZE];\n  struct knuth_lfib_ctx random_ctx;\n\n  knuth_lfib_init (&random_ctx, 11);\n\n  size_t size;\n  for (size = 0; size < 50; size++)\n    {\n      size_t i;\n      uint8_t bit;\n      knuth_lfib_random (&random_ctx, size, orig);\n      memcpy (a, orig, size);\n      memcpy (b, orig, size);\n      ASSERT (memeql_sec_for_test (a, b, size));\n      for (i = 0; i < size; i++)\n\tfor (bit = 0x80; bit; bit >>= 1)\n\t  {\n\t    b[i] = orig[i] ^ bit;\n\t    ASSERT (!memeql_sec_for_test (a, b, size));\n\t    b[i] = orig[i];\n\t  }\n    }\n}",
      "lines": 28,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/memxor-test.c": {
    "test_mark": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        22,
        1
      ],
      "content": "static void\ntest_mark (enum mark_type type,\n\t   const uint8_t *block, size_t block_size,\n\t   const uint8_t *p, size_t size)\n{\n  VALGRIND_MAKE_MEM_NOACCESS(block, p - block);\n  if (type == MARK_DST)\n    VALGRIND_MAKE_MEM_UNDEFINED(p, size);\n  VALGRIND_MAKE_MEM_NOACCESS(p + size,\n\t\t\t     (block + block_size) - (p + size));\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "set_align": {
      "start_point": [
        31,
        0
      ],
      "end_point": [
        45,
        1
      ],
      "content": "static uint8_t *\nset_align(uint8_t *buf, unsigned align)\n{\n  unsigned offset;\n  /* An extra redzone char at the beginning */\n  buf++;\n  offset = (uintptr_t) (buf) % ALIGN_SIZE;\n\n  if (offset < align)\n    buf += (align - offset);\n  else if (offset > align)\n    buf += (align + ALIGN_SIZE - offset);\n\n  return buf;  \n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "uint8_t",
        "*\nset_align(uint8_t *buf, unsigned align)",
        "*"
      ]
    },
    "test_memxor": {
      "start_point": [
        47,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "static void\ntest_memxor (const uint8_t *a, const uint8_t *b, const uint8_t *c,\n\t     size_t size, unsigned align_dst, unsigned align_src)\n{\n  uint8_t dst_buf[MAX_SIZE + ALIGN_SIZE + 1];\n  uint8_t src_buf[MAX_SIZE + ALIGN_SIZE + 1];\n\n  uint8_t *dst = set_align (dst_buf, align_dst);\n  uint8_t *src = set_align (src_buf, align_src);\n\n  if (verbose)\n    fprintf(stderr, \"size = %d, align_dst = %d, align_src = %d\\n\",\n\t      (int) size, align_dst, align_src);\n\n  memcpy (dst, a, size);\n  dst[-1] = 17;\n  dst[size] = 17;\n\n  memcpy (src, b, size);\n  test_mark (MARK_SRC, src_buf, sizeof (src_buf), src, size);\n  test_mark (MARK_SRC, dst_buf, sizeof (dst_buf), dst, size);\n\n  memxor (dst, src, size);\n  ASSERT (MEMEQ (size, dst, c));\n  \n  test_unmark(src_buf, sizeof (src_buf));\n  test_unmark(dst_buf, sizeof (src_buf));\n  ASSERT (dst[-1] == 17);\n  ASSERT (dst[size] == 17);\n}",
      "lines": 30,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_memxor3": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        113,
        1
      ],
      "content": "static void\ntest_memxor3 (const uint8_t *ain, const uint8_t *bin, const uint8_t *c,\n\t      size_t size, unsigned align_dst, unsigned align_a, unsigned align_b)\n{\n  uint8_t dst_buf[MAX_SIZE + ALIGN_SIZE + 1];\n  uint8_t a_buf[MAX_SIZE + ALIGN_SIZE + 1];\n  uint8_t b_buf[MAX_SIZE + ALIGN_SIZE + 1];\n\n  uint8_t *dst = set_align (dst_buf, align_dst);\n  uint8_t *a = set_align (a_buf, align_a);\n  uint8_t *b = set_align (b_buf, align_b);\n\n  if (verbose)\n    fprintf(stderr, \"size = %d, align_dst = %d, align_a = %d, align_b = %d\\n\",\n\t    (int) size, align_dst, align_a, align_b);\n\n  memset (dst, 0, size);\n  dst[-1] = 17;\n  dst[size] = 17;\n\n  memcpy (a, ain, size);\n  memcpy (b, bin, size);\n  test_mark (MARK_SRC, a_buf, sizeof(a_buf), a, size);\n  test_mark (MARK_SRC, b_buf, sizeof(b_buf), b, size);\n  test_mark (MARK_DST, dst_buf, sizeof(dst_buf), dst, size);\n\n  memxor3 (dst, a, b, size);\n  ASSERT (MEMEQ (size, dst, c));\n\n  test_unmark (a_buf, sizeof(a_buf));\n  test_unmark (b_buf, sizeof(b_buf));\n  test_unmark (dst_buf, sizeof(dst_buf));\n\n  ASSERT (dst[-1] == 17);\n  ASSERT (dst[size] == 17);\n}",
      "lines": 36,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        115,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  const uint8_t *a = H(\"ecc8737f 38f2f9e8 86b9d84c 42a9c7ef\"\n\t\t       \"27a50860 49c6be97 c5cc6c35 3981b367\"\n\t\t       \"f8b4397b 951e3b2f 35749fe1 25884fa6\"\n\t\t       \"9361c97a ab1c6cce 494efb5a 1f108411\"\n\t\t       \"21dc6386 e81b2410 2f04c29d e0ca1135\"\n\t\t       \"c9f96f2e bb5b2e2d 8cb45df9 50c4755a\"\n\t\t       \"362b7ead 4b930010 cbc69834 66221ba8\"\n\t\t       \"c0b8d7ac 7ec3b700 6bdb1a3b 599f3e76\"\n\t\t       \"a7e66a29 ee1fb98c 60a66c9e 0a1d9c49\"\n\t\t       \"6367afc7 362d6ae1 f8799443 17e2b1a1\"\n\t\t       \"ff1cc03c 9e2728ca a1f6598f 5a61bd56\"\n\t\t       \"0826effc f3499da7 119249b6 fd643cd4\"\n\t\t       \"2e7c74b0 f775fda4 a5617138 1e8520bf\"\n\t\t       \"f17de57a decc36b6 9eceee6e d448f592\"\n\t\t       \"be77a67a 1b91a5b3 62fab868 dcb046f6\"\n\t\t       \"394b5335 b2eaa351 fc4456e4 35bb9c54\");\n\n  const uint8_t *b = H(\"cac458ad fe87e226 6cb0ce3d cfa5cb3b\"\n\t\t       \"963d0034 5811bb9e acf4675b 7464f800\"\n\t\t       \"4b1bcff2 b2fa5dd0 0576aea6 888b8150\"\n\t\t       \"bcba48f1 49bc33d2 e138b0d0 a29b486e\"\n\t\t       \"f7e143c6 f9959596 6aaa4493 b0bea6f8\"\n\t\t       \"1d778513 a3bfec7e 70cfe6a7 e31ad041\"\n\t\t       \"5fe3371b 63aba991 dab9a3db 66310ebc\"\n\t\t       \"24c2765d a722a131 2fc4d366 1f2e3388\"\n\t\t       \"7e5b26d5 7b34bf4c 655d19da d1335362\"\n\t\t       \"2fbc0d5d cc68c811 ef735c20 352986ef\"\n\t\t       \"f47ac5c9 afa77f5a 20da6dd3 eb9dfb34\"\n\t\t       \"0cdbf792 caf0d633 61d908da a4c0f2a9\"\n\t\t       \"be7a573e 3b8d161c 47fc19be e47d7edc\"\n\t\t       \"e5f00dae f64cbbb4 a081e1f0 381833d8\"\n\t\t       \"30d302ff eed61887 3390d6b2 0048ac32\"\n\t\t       \"9c6b2981 a224dcc1 6b1feebe 15834b1a\");\n\n  const uint8_t *c = H(\"260c2bd2 c6751bce ea091671 8d0c0cd4\"\n\t\t       \"b1980854 11d70509 69380b6e 4de54b67\"\n\t\t       \"b3aff689 27e466ff 30023147 ad03cef6\"\n\t\t       \"2fdb818b e2a05f1c a8764b8a bd8bcc7f\"\n\t\t       \"d63d2040 118eb186 45ae860e 5074b7cd\"\n\t\t       \"d48eea3d 18e4c253 fc7bbb5e b3dea51b\"\n\t\t       \"69c849b6 2838a981 117f3bef 00131514\"\n\t\t       \"e47aa1f1 d9e11631 441fc95d 46b10dfe\"\n\t\t       \"d9bd4cfc 952b06c0 05fb7544 db2ecf2b\"\n\t\t       \"4cdba29a fa45a2f0 170ac863 22cb374e\"\n\t\t       \"0b6605f5 31805790 812c345c b1fc4662\"\n\t\t       \"04fd186e 39b94b94 704b416c 59a4ce7d\"\n\t\t       \"9006238e ccf8ebb8 e29d6886 faf85e63\"\n\t\t       \"148de8d4 28808d02 3e4f0f9e ec50c64a\"\n\t\t       \"8ea4a485 f547bd34 516a6eda dcf8eac4\"\n\t\t       \"a5207ab4 10ce7f90 975bb85a 2038d74e\");\n\n  const int size[] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,\n    17, 23, 24, 25, 30, 31, 32, 33, 34, 35, 36, 37,\n    250, 251, 252, 253,254, 255, 256, -1\n  };\n  \n  unsigned i, align_dst, align_a, align_b;\n  for (i = 0; size[i] >= 0; i++)\n    for (align_dst = 0; align_dst < ALIGN_SIZE; align_dst++)\n      for (align_a = 0; align_a < ALIGN_SIZE; align_a++)\n\t{\n\t  test_memxor (a, b, c, size[i], align_dst, align_a);\n\t  for (align_b = 0; align_b < ALIGN_SIZE; align_b++)\n\t    test_memxor3 (a, b, c, size[i], align_dst, align_a, align_b);\n\t}\n}",
      "lines": 70,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/meta-aead-test.c": {
    "test_main": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  int i,j;\n  int count = sizeof(aeads)/sizeof(*aeads);\n  for (i = 0; i < count; i++) {\n    for (j = 0; NULL != nettle_aeads[j]; j++) {\n      if (0 == strcmp(aeads[i], nettle_aeads[j]->name))\n        break;\n    }\n    ASSERT(NULL != nettle_aeads[j]); /* make sure we found a matching aead */\n  }\n  j = 0;\n  while (NULL != nettle_aeads[j])\n    j++;\n  ASSERT(j == count); /* we are not missing testing any aeads */\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/meta-armor-test.c": {
    "test_main": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  int i,j;\n  int count = sizeof(armors)/sizeof(*armors);\n  for (i = 0; i < count; i++) {\n    for (j = 0; NULL != nettle_armors[j]; j++) {\n      if (0 == strcmp(armors[i], nettle_armors[j]->name))\n        break;\n    }\n    ASSERT(NULL != nettle_armors[j]); /* make sure we found a matching armor */\n  }\n  j = 0;\n  while (NULL != nettle_armors[j])\n    j++;\n  ASSERT(j == count); /* we are not missing testing any armors */\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/meta-cipher-test.c": {
    "test_main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        39,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  int i,j;\n  int count = sizeof(ciphers)/sizeof(*ciphers);\n  for (i = 0; i < count; i++) {\n    for (j = 0; NULL != nettle_ciphers[j]; j++) {\n      if (0 == strcmp(ciphers[i], nettle_ciphers[j]->name))\n        break;\n    }\n    ASSERT(NULL != nettle_ciphers[j]); /* make sure we found a matching cipher */\n  }\n  j = 0;\n  while (NULL != nettle_ciphers[j])\n    j++;\n  ASSERT(j == count); /* we are not missing testing any ciphers */\n}",
      "lines": 17,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/meta-hash-test.c": {
    "test_main": {
      "start_point": [
        22,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  int i;\n  int count = sizeof(hashes)/sizeof(*hashes);\n  for (i = 0; i < count; i++) {\n    /* make sure we found a matching hash */\n    ASSERT(nettle_lookup_hash(hashes[i]) != NULL);\n  }\n\n  for (i = 0; NULL != nettle_hashes[i]; i++) {\n    ASSERT(nettle_hashes[i]->digest_size <= NETTLE_MAX_HASH_DIGEST_SIZE);\n    ASSERT(nettle_hashes[i]->context_size <= NETTLE_MAX_HASH_CONTEXT_SIZE);\n  }\n  ASSERT(i == count); /* we are not missing testing any hashes */\n}",
      "lines": 16,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/pbkdf2-test.c": {
    "test_main": {
      "start_point": [
        23,
        0
      ],
      "end_point": [
        112,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  uint8_t dk[MAX_DKLEN + 1];\n  struct hmac_sha1_ctx sha1ctx;\n  struct hmac_sha256_ctx sha256ctx;\n  struct hmac_sha512_ctx sha512ctx;\n\n  /* Test vectors for PBKDF2 from RFC 6070. */\n\n  hmac_sha1_set_key (&sha1ctx, LDATA(\"password\"));\n\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       1, LDATA(\"salt\"),\n\t       SHEX(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"));\n\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       2, LDATA(\"salt\"),\n\t       SHEX(\"ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957\"));\n\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       4096, LDATA(\"salt\"),\n\t       SHEX(\"4b007901b765489abead49d926f721d065a429c1\"));\n\n#if 0\t\t\t\t/* too slow */\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       16777216, LDATA(\"salt\"),\n\t       SHEX(\"eefe3d61cd4da4e4e9945b3d6ba2158c2634e984\"));\n#endif\n\n  hmac_sha1_set_key (&sha1ctx, LDATA(\"passwordPASSWORDpassword\"));\n\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       4096, LDATA(\"saltSALTsaltSALTsaltSALTsaltSALTsalt\"),\n\t       SHEX(\"3d2eec4fe41c849b80c8d83662c0e44a8b291a964cf2f07038\"));\n\n  hmac_sha1_set_key (&sha1ctx, LDATA(\"pass\\0word\"));\n\n  PBKDF2_TEST (&sha1ctx, hmac_sha1_update, hmac_sha1_digest, SHA1_DIGEST_SIZE,\n\t       4096, LDATA(\"sa\\0lt\"),\n\t       SHEX(\"56fa6aa75548099dcc37d7f03425e0c3\"));\n\n  /* PBKDF2-HMAC-SHA-256 test vectors confirmed with another\n     implementation.  */\n\n  hmac_sha256_set_key (&sha256ctx, LDATA(\"passwd\"));\n\n  PBKDF2_TEST (&sha256ctx, hmac_sha256_update, hmac_sha256_digest,\n\t       SHA256_DIGEST_SIZE, 1, LDATA(\"salt\"),\n\t       SHEX(\"55ac046e56e3089fec1691c22544b605\"));\n\n  hmac_sha256_set_key (&sha256ctx, LDATA(\"Password\"));\n\n  PBKDF2_TEST (&sha256ctx, hmac_sha256_update, hmac_sha256_digest,\n\t       SHA256_DIGEST_SIZE, 80000, LDATA(\"NaCl\"),\n\t       SHEX(\"4ddcd8f60b98be21830cee5ef22701f9\"));\n\n  /* PBKDF2-HMAC-SHA-512 test vectors confirmed with another\n     implementation (python-pbkdf2).\n\n     >>> from pbkdf2 import PBKDF2\n     >>> import hmac as HMAC\n     >>> from hashlib import sha512 as SHA512\n     >>> PBKDF2(\"password\", \"salt\", 50, macmodule=HMAC, digestmodule=SHA512).read(64).encode('hex')\n  */\n\n  hmac_sha512_set_key (&sha512ctx, LDATA(\"password\"));\n  PBKDF2_TEST (&sha512ctx, hmac_sha512_update, hmac_sha512_digest,\n\t       SHA512_DIGEST_SIZE, 1, LDATA(\"NaCL\"),\n\t       SHEX(\"73decfa58aa2e84f94771a75736bb88bd3c7b38270cfb50cb390ed78b305656af8148e52452b2216b2b8098b761fc6336060a09f76415e9f71ea47f9e9064306\"));\n\n  hmac_sha512_set_key (&sha512ctx, LDATA(\"pass\\0word\"));\n  PBKDF2_TEST (&sha512ctx, hmac_sha512_update, hmac_sha512_digest,\n\t       SHA512_DIGEST_SIZE, 1, LDATA(\"sa\\0lt\"),\n\t       SHEX(\"71a0ec842abd5c678bcfd145f09d83522f93361560563c4d0d63b88329871090e76604a49af08fe7c9f57156c8790996b20f06bc535e5ab5440df7e878296fa7\"));\n\n  hmac_sha512_set_key (&sha512ctx, LDATA(\"passwordPASSWORDpassword\"));\n  PBKDF2_TEST (&sha512ctx, hmac_sha512_update, hmac_sha512_digest,\n\t       SHA512_DIGEST_SIZE, 50, LDATA(\"salt\\0\\0\\0\"),\n\t       SHEX(\"016871a4c4b75f96857fd2b9f8ca28023b30ee2a39f5adcac8c9375f9bda1ccd1b6f0b2fc3adda505412e79d890056c62e524c7d51154b1a8534575bd02dee39\"));\n\n  /* Test convenience functions. */\n\n  PBKDF2_HMAC_TEST(pbkdf2_hmac_sha1, LDATA(\"password\"), 1, LDATA(\"salt\"),\n\t\t   SHEX(\"0c60c80f961f0e71f3a9b524af6012062fe037a6\"));\n\n  PBKDF2_HMAC_TEST(pbkdf2_hmac_sha256, LDATA(\"passwd\"), 1, LDATA(\"salt\"),\n\t\t   SHEX(\"55ac046e56e3089fec1691c22544b605\"));\n\n}",
      "lines": 90,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/pkcs1-sec-decrypt-test.c": {
    "pkcs1_decrypt_for_test": {
      "start_point": [
        7,
        0
      ],
      "end_point": [
        23,
        1
      ],
      "content": "static int\npkcs1_decrypt_for_test(size_t msg_len, uint8_t *msg,\n                       size_t pad_len, uint8_t *pad)\n{\n  int ret;\n\n  VALGRIND_MAKE_MEM_UNDEFINED (msg, msg_len);\n  VALGRIND_MAKE_MEM_UNDEFINED (pad, pad_len);\n\n  ret = _pkcs1_sec_decrypt (msg_len, msg, pad_len, pad);\n\n  VALGRIND_MAKE_MEM_DEFINED (msg, msg_len);\n  VALGRIND_MAKE_MEM_DEFINED (pad, pad_len);\n  VALGRIND_MAKE_MEM_DEFINED (&ret, sizeof (ret));\n\n  return ret;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_main": {
      "start_point": [
        28,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  uint8_t pad[128];\n  uint8_t buffer[] =\n    \"\\x00\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09\\x0a\\x0b\\x0c\\x0d\\x0e\\x0f\\x10\"\n    \"\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f\\x20\"\n    \"\\x21\\x22\\x23\\x24\\x25\\x26\\x27\\x28\\x29\\x2a\\x2b\\x2c\\x2d\\x2e\\x2f\\x30\"\n    \"\\x31\\x32\\x33\\x34\\x35\\x36\\x37\\x38\\x39\\x3a\\x3b\\x3c\\x3d\\x3e\\x3f\\x40\"\n    \"\\x41\\x42\\x43\\x44\\x45\\x46\\x47\\x48\\x49\\x4a\\x4b\\x4c\\x4d\\x4e\\x4f\\x50\"\n    \"\\x51\\x52\\x53\\x54\\x55\\x56\\x57\\x58\\x59\\x5a\\x5b\\x5c\\x5d\\x5e\\x5f\\x60\"\n    \"\\x61\\x62\\x63\\x64\\x65\\x66\\x67\\x68\\x69\\x6a\\x6b\\x6c\\x6d\\x6e\\x6f\\x70\"\n    \"\\x00\\x53\\x49\\x47\\x4e\\x45\\x44\\x20\\x4d\\x45\\x53\\x53\\x41\\x47\\x45\\x2e\";\n  uint8_t message[15];\n\n  memcpy(pad, buffer, 128);\n\n  memset (message, 'A', 15);\n  ASSERT (pkcs1_decrypt_for_test(15, message, 128, pad) == 1);\n  ASSERT (memcmp (message, \"SIGNED MESSAGE.\", 15) == 0);\n\n  /* break format byte 1 */\n  memcpy(pad, buffer, 128);\n  pad[0] = 1;\n  memset (message, 'B', 15);\n  ASSERT (pkcs1_decrypt_for_test(15, message, 128, pad) == 0);\n  ASSERT (memcmp (message, \"BBBBBBBBBBBBBBB\", 15) == 0);\n\n  /* break format byte 2 */\n  memcpy(pad, buffer, 128);\n  pad[1] = 1;\n  memset (message, 'C', 15);\n  ASSERT (pkcs1_decrypt_for_test(15, message, 128, pad) == 0);\n  ASSERT (memcmp (message, \"CCCCCCCCCCCCCCC\", 15) == 0);\n\n  /* break padding */\n  memcpy(pad, buffer, 128);\n  pad[24] = 0;\n  memset (message, 'D', 15);\n  ASSERT (pkcs1_decrypt_for_test(15, message, 128, pad) == 0);\n  ASSERT (memcmp (message, \"DDDDDDDDDDDDDDD\", 15) == 0);\n\n  /* break terminator */\n  memcpy(pad, buffer, 128);\n  pad[112] = 1;\n  memset (message, 'E', 15);\n  ASSERT (pkcs1_decrypt_for_test(15, message, 128, pad) == 0);\n  ASSERT (memcmp (message, \"EEEEEEEEEEEEEEE\", 15) == 0);\n}",
      "lines": 49,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/pkcs1-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  uint8_t buffer[16];\n  uint8_t expected[16] = { 0,    1, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n\t\t\t   0xff, 0xff, 0xff, 0xff, 0,    'a',  'b',  'c' };\n\n  _pkcs1_signature_prefix(sizeof(buffer), buffer,\n\t\t\t  LDATA(\"abc\"), 0);\n\n  ASSERT(MEMEQ(sizeof(buffer), buffer, expected));\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/poly1305-test.c": {
    "update": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        11,
        1
      ],
      "content": "static void\nupdate (void *ctx, nettle_hash_update_func *f,\n\tconst struct tstring *msg,\n\tunsigned length)\n{\n  for (; length > msg->length; length -= msg->length)\n    f(ctx, msg->length, msg->data);\n  f(ctx, length, msg->data);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_digest": {
      "start_point": [
        13,
        0
      ],
      "end_point": [
        30,
        1
      ],
      "content": "static void\ncheck_digest (const char *name, void *ctx, nettle_hash_digest_func *f,\n\t      const struct tstring *msg, unsigned length,\n\t      unsigned tag_length, const uint8_t *ref)\n{\n  uint8_t tag[16];\n  f(ctx, tag_length, tag);\n  if (memcmp (tag, ref, tag_length) != 0)\n    {\n      printf (\"%s failed\\n\", name);\n      printf (\"msg: \"); print_hex (msg->length, msg->data);\n      printf (\"length: %u\\n\", length);\n      printf (\"tag: \"); print_hex (tag_length, tag);\n      printf (\"ref: \"); print_hex (tag_length, ref);\n      abort ();\n    }\n\n}",
      "lines": 18,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_poly1305": {
      "start_point": [
        32,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static void\ntest_poly1305 (const struct tstring *key,\n\t   const struct tstring *nonce,\n\t   const struct tstring *msg,\n\t   unsigned length,\n\t   const struct tstring *ref)\n{\n  struct poly1305_aes_ctx ctx;\n\n  ASSERT (key->length == POLY1305_AES_KEY_SIZE);\n  ASSERT (ref->length == POLY1305_AES_DIGEST_SIZE);\n\n  poly1305_aes_set_key (&ctx, key->data);\n  poly1305_aes_set_nonce (&ctx, nonce->data);\n\n  update(&ctx, (nettle_hash_update_func *) poly1305_aes_update, msg, length);\n\n  check_digest (\"poly1305-aes\", &ctx, (nettle_hash_digest_func *) poly1305_aes_digest,\n\t\tmsg, length, 16, ref->data);\n}",
      "lines": 20,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From Bernstein's paper. */\n  test_poly1305\n   (SHEX(\"75deaa25c09f208e1dc4ce6b5cad3fbfa0f3080000f46400d0c7e9076c834403\"),\n    SHEX(\"61ee09218d29b0aaed7e154a2c5509cc\"),\n    SHEX(\"\"), 0,\n    SHEX(\"dd3fab2251f11ac759f0887129cc2ee7\"));\n\n  test_poly1305\n   (SHEX(\"ec074c835580741701425b623235add6851fc40c3467ac0be05cc20404f3f700\"),\n    SHEX(\"fb447350c4e868c52ac3275cf9d4327e\"),\n    SHEX(\"f3f6\"), 2,\n    SHEX(\"f4c633c3044fc145f84f335cb81953de\"));\n\n  test_poly1305\n   (SHEX(\"6acb5f61a7176dd320c5c1eb2edcdc74\"\n         \"48443d0bb0d21109c89a100b5ce2c208\"),\n    SHEX(\"ae212a55399729595dea458bc621ff0e\"),\n    SHEX(\"663cea190ffb83d89593f3f476b6bc24\"\n         \"d7e679107ea26adb8caf6652d0656136\"), 32,\n    SHEX(\"0ee1c16bb73f0f4fd19881753c01cdbe\"));\n\n  test_poly1305\n   (SHEX(\"e1a5668a4d5b66a5f68cc5424ed5982d12976a08c4426d0ce8a82407c4f48207\"),\n    SHEX(\"9ae831e743978d3a23527c7128149e3a\"),\n    SHEX(\"ab0812724a7f1e342742cbed374d94d136c6b8795d45b3819830f2c04491\"\n         \"faf0990c62e48b8018b2c3e4a0fa3134cb67fa83e158c994d961c4cb2109\"\n         \"5c1bf9\"), 63,\n    SHEX(\"5154ad0d2cb26e01274fc51148491f1b\"));\n\n}",
      "lines": 33,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/pss-mgf1-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct sha1_ctx sha1ctx;\n  struct sha256_ctx sha256ctx;\n  const struct tstring *seed, *expected;\n  uint8_t mask[120];\n\n  /* From ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1d2-vec.zip */\n  seed = SHEX(\"df1a896f9d8bc816d97cd7a2c43bad54\"\n\t      \"6fbe8cfe\");\n  expected = SHEX(\"66e4672e836ad121ba244bed6576b867d9a447c28a6e66a5b87dee\"\n\t\t  \"7fbc7e65af5057f86fae8984d9ba7f969ad6fe02a4d75f7445fefd\"\n\t\t  \"d85b6d3a477c28d24ba1e3756f792dd1dce8ca94440ecb5279ecd3\"\n\t\t  \"183a311fc89739a96643136e8b0f465e87a4535cd4c59b10028d\");\n  sha1_init(&sha1ctx);\n  sha1_update(&sha1ctx, seed->length, seed->data);\n  pss_mgf1(&sha1ctx, &nettle_sha1, expected->length, mask);\n  ASSERT(MEMEQ (expected->length, mask, expected->data));\n\n  /* Test with our own data.  */\n  seed = SDATA(\"abc\");\n  expected = SHEX(\"cf2db1ac9867debdf8ce91f99f141e5544bf26ca36b3fd4f8e4035\"\n\t\t  \"eec42cab0d46c386ebccef82ba0bb0b095aaa5548b03cdff695187\"\n\t\t  \"1c6fb505af68af688332f885d324a47d2145a3d8392c37978d7dc9\"\n\t\t  \"84c95728950c4cf3de6becc59e60ea506951bd40e6de3863095064\"\n\t\t  \"3ab2edbb47dc66cb54beb2d1\");\n\n  sha256_init(&sha256ctx);\n  sha256_update(&sha256ctx, seed->length, seed->data);\n  pss_mgf1(&sha256ctx, &nettle_sha256, expected->length, mask);\n  ASSERT(MEMEQ (expected->length, mask, expected->data));\n}",
      "lines": 33,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/pss-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct tstring *salt;\n  struct tstring *digest;\n  mpz_t m;\n  mpz_t expected;\n\n  /* From ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1d2-vec.zip */\n  mpz_init(m);\n  mpz_init(expected);\n\n  salt = SHEX(\"e3b5d5d002c1bce50c2b65ef88a188d83bce7e61\");\n  digest = SHEX(\"37b66ae0445843353d47ecb0b4fd14c110e62d6a\");\n  ASSERT(pss_encode_mgf1(m, 1024, &nettle_sha1,\n\t\t\t salt->length, salt->data, digest->data));\n\n  mpz_set_str(expected,\n\t      \"66e4672e836ad121ba244bed6576b867d9a447c28a6e66a5b87dee\"\n\t      \"7fbc7e65af5057f86fae8984d9ba7f969ad6fe02a4d75f7445fefd\"\n\t      \"d85b6d3a477c28d24ba1e3756f792dd1dce8ca94440ecb5279ecd3\"\n\t      \"183a311fc896da1cb39311af37ea4a75e24bdbfd5c1da0de7cecdf\"\n\t      \"1a896f9d8bc816d97cd7a2c43bad546fbe8cfebc\", 16);\n\n  ASSERT(mpz_cmp(m, expected) == 0);\n\n  mpz_add_ui(m, m, 2);\n  ASSERT(!pss_verify_mgf1(m, 1024, &nettle_sha1, salt->length, digest->data));\n\n  mpz_sub_ui(m, m, 2);\n  ASSERT(pss_verify_mgf1(m, 1024, &nettle_sha1, salt->length, digest->data));\n\n  mpz_clear(m);\n  mpz_clear(expected);\n\n  /* Test with our own data.  */\n  mpz_init(m);\n  mpz_init(expected);\n\n  salt = SHEX(\"11223344556677889900\");\n  /* From sha256-test.c */\n  digest = SHEX(\"ba7816bf8f01cfea 414140de5dae2223\"\n\t\t\"b00361a396177a9c b410ff61f20015ad\");\n\n  mpz_set_str(expected,\n\t      \"76b9a52705c8382c5367732f993184eff340b6305c9f73e7e308c8\"\n\t      \"004fcc15cbbaab01e976bae4b774628595379a2d448a36b3ea6fa8\"\n\t      \"353b97eeea7bdac93b4b7807ac98cd4b3bebfb31f3718e1dd3625f\"\n\t      \"227fbb8696606498e7070e21c3cbbd7386ea20eb81ac7927e0c6d1\"\n\t      \"d7788826a63af767f301bcc05dd65b00da862cbc\", 16);\n\n  /* Try bad salt */\n  salt->data[6] = 0x00;\n  ASSERT(pss_encode_mgf1(m, 1024, &nettle_sha256,\n\t\t\t salt->length, salt->data, digest->data));\n  ASSERT(mpz_cmp(m, expected) != 0);\n\n  /* Try the good salt */\n  salt->data[6] = 0x77;\n  ASSERT(pss_encode_mgf1(m, 1024, &nettle_sha256,\n\t\t\t salt->length, salt->data, digest->data));\n  ASSERT(mpz_cmp(m, expected) == 0);\n\n  /* Try bad message */\n  mpz_add_ui(m, m, 2);\n  ASSERT(!pss_verify_mgf1(m, 1024, &nettle_sha256, salt->length, digest->data));\n\n  /* Try the good message */\n  mpz_sub_ui(m, m, 2);\n  ASSERT(pss_verify_mgf1(m, 1024, &nettle_sha256, salt->length, digest->data));\n\n  /* Try bad digest */\n  digest->data[17] = 0x00;\n  ASSERT(!pss_verify_mgf1(m, 1024, &nettle_sha256, salt->length, digest->data));\n\n  /* Try the good digest */\n  digest->data[17] = 0x03;\n  ASSERT(pss_verify_mgf1(m, 1024, &nettle_sha256, salt->length, digest->data));\n\n  mpz_clear(m);\n  mpz_clear(expected);\n}",
      "lines": 82,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/random-prime-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        27,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct knuth_lfib_ctx lfib;\n  mpz_t p;\n  unsigned bits;\n\n  knuth_lfib_init(&lfib, 17);\n\n  mpz_init(p);\n  for (bits = 6; bits < 1000; bits = bits + 1 + bits/20)\n    {\n      if (verbose)\n\tfprintf(stderr, \"bits = %d\\n\", bits);\n      \n      nettle_random_prime(p, bits, 0,\n\t\t\t  &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t\t  NULL, NULL);\n      ASSERT (mpz_sizeinbase (p, 2) == bits);\n      ASSERT (mpz_probab_prime_p(p, 25));\n    }\n\n  mpz_clear(p);\n}",
      "lines": 24,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/ripemd160-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        34,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_ripemd160, SDATA(\"\"),\n\t    SHEX(\"9c1185a5c5e9fc54612808977ee8f548b2258d31\"));\n\n  test_hash(&nettle_ripemd160, SDATA(\"a\"),\n\t    SHEX(\"0bdc9d2d256b3ee9daae347be6f4dc835a467ffe\"));\n\n  test_hash(&nettle_ripemd160, SDATA(\"abc\"),\n\t    SHEX(\"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc\"));\n\n  test_hash(&nettle_ripemd160, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"f71c27109c692c1b56bbdceb5b9d2865b3708dbc\"));\n\n  test_hash(&nettle_ripemd160, SDATA(\"message digest\"),\n\t    SHEX(\"5d0689ef49d2fae572b881b123a85ffa21595f36\"));\n\n  test_hash(&nettle_ripemd160,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"b0e20b6e3116640286ed3a87a5713079b21f5189\"));\n\n  test_hash(&nettle_ripemd160,  \n\t    SDATA(\"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"),\n\t    SHEX(\"9b752e45573d4b39f4dbd3323cab82bf63326bfb\"));\n\n  /* Additional test vector, from Daniel Kahn Gillmor */\n  test_hash(&nettle_ripemd160, SDATA(\"38\"),\n\t    SHEX(\"6b2d075b1cd34cd1c3e43a995f110c55649dad0e\"));\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-compute-root-test.c": {
    "random_fn": {
      "start_point": [
        12,
        0
      ],
      "end_point": [
        22,
        1
      ],
      "content": "static void\nrandom_fn (void *ctx, size_t n, uint8_t *dst)\n{\n  gmp_randstate_t *rands = (gmp_randstate_t *)ctx;\n  mpz_t r;\n\n  mpz_init (r);\n  mpz_urandomb (r, *rands, n*8);\n  nettle_mpz_get_str_256 (n, dst, r);\n  mpz_clear (r);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_one": {
      "start_point": [
        24,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "static void\ntest_one (gmp_randstate_t *rands, struct rsa_public_key *pub,\n          struct rsa_private_key *key, mpz_t plaintext)\n{\n  mpz_t ciphertext;\n  mpz_t decrypted;\n\n  mpz_init (ciphertext);\n  mpz_init (decrypted);\n\n  mpz_powm (ciphertext, plaintext, pub->e, pub->n);\n  rsa_compute_root_tr (pub, key, rands, random_fn, decrypted, ciphertext);\n  if (mpz_cmp (plaintext, decrypted)) {\n    fprintf (stderr, \"rsa_compute_root_tr failed\\n\");\n\n    fprintf(stderr, \"Public key: size=%lu\\n n:\", pub->size);\n    mpz_out_str (stderr, 10, pub->n);\n    fprintf(stderr, \"\\n e:\");\n    mpz_out_str (stderr, 10, pub->e);\n    fprintf(stderr, \"\\nPrivate key: size=%lu\\n p:\", key->size);\n    mpz_out_str (stderr, 10, key->p);\n    fprintf(stderr, \"\\n q:\");\n    mpz_out_str (stderr, 10, key->q);\n    fprintf(stderr, \"\\n a:\");\n    mpz_out_str (stderr, 10, key->a);\n    fprintf(stderr, \"\\n b:\");\n    mpz_out_str (stderr, 10, key->b);\n    fprintf(stderr, \"\\n c:\");\n    mpz_out_str (stderr, 10, key->c);\n    fprintf(stderr, \"\\n d:\");\n    mpz_out_str (stderr, 10, key->d);\n    fprintf(stderr, \"\\n\");\n\n    fprintf (stderr, \"plaintext(%lu) = \", mpz_sizeinbase (plaintext, 2));\n    mpz_out_str (stderr, 10, plaintext);\n    fprintf (stderr, \"\\n\");\n    fprintf (stderr, \"ciphertext(%lu) = \", mpz_sizeinbase (ciphertext, 2));\n    mpz_out_str (stderr, 10, ciphertext);\n    fprintf (stderr, \"\\n\");\n    fprintf (stderr, \"decrypted(%lu) = \", mpz_sizeinbase (decrypted, 2));\n    mpz_out_str (stderr, 10, decrypted);\n    fprintf (stderr, \"\\n\");\n    abort();\n  }\n\n  mpz_clear (ciphertext);\n  mpz_clear (decrypted);\n}",
      "lines": 48,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "generate_keypair": {
      "start_point": [
        78,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "static void\ngenerate_keypair (gmp_randstate_t rands,\n                  struct rsa_public_key *pub, struct rsa_private_key *key)\n{\n  unsigned long int psize;\n  unsigned long int qsize;\n  mpz_t p1;\n  mpz_t q1;\n  mpz_t phi;\n  mpz_t tmp;\n\n  mpz_init (p1);\n  mpz_init (q1);\n  mpz_init (phi);\n  mpz_init (tmp);\n\n  psize = 100 + gmp_urandomm_ui (rands, 400);\n  qsize = 100 + gmp_urandomm_ui (rands, 400);\n\n  mpz_set_ui (pub->e, 65537);\n\n  for (;;)\n    {\n      for (;;)\n        {\n          mpz_rrandomb (key->p, rands, psize);\n          mpz_nextprime (key->p, key->p);\n          mpz_sub_ui (p1, key->p, 1);\n          mpz_gcd (tmp, pub->e, p1);\n          if (mpz_cmp_ui (tmp, 1) == 0)\n            break;\n        }\n\n      for (;;)\n        {\n          mpz_rrandomb (key->q, rands, qsize);\n          mpz_nextprime (key->q, key->q);\n          mpz_sub_ui (q1, key->q, 1);\n          mpz_gcd (tmp, pub->e, q1);\n          if (mpz_cmp_ui (tmp, 1) == 0)\n            break;\n        }\n\n      if (mpz_invert (key->c, key->q, key->p))\n        break;\n    }\n\n  mpz_mul(phi, p1, q1);\n  assert (mpz_invert(key->d, pub->e, phi));\n\n  mpz_fdiv_r (key->a, key->d, p1);\n  mpz_fdiv_r (key->b, key->d, q1);\n\n  mpz_mul (pub->n, key->p, key->q);\n\n  pub->size = key->size = mpz_size(pub->n) * sizeof(mp_limb_t);\n\n  mpz_clear (tmp);\n  mpz_clear (phi);\n  mpz_clear (q1);\n  mpz_clear (p1);\n}",
      "lines": 62,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "get_random_seed": {
      "start_point": [
        143,
        0
      ],
      "end_point": [
        169,
        1
      ],
      "content": "static void\nget_random_seed(mpz_t seed)\n{\n  struct timeval tv;\n  FILE *f;\n  f = fopen (\"/dev/urandom\", \"rb\");\n  if (f)\n    {\n      uint8_t buf[8];\n      size_t res;\n\n      setbuf (f, NULL);\n      res = fread (&buf, sizeof(buf), 1, f);\n      fclose(f);\n      if (res == 1)\n\t{\n\t  nettle_mpz_set_str_256_u (seed, sizeof(buf), buf);\n\t  return;\n\t}\n      fprintf (stderr, \"Read of /dev/urandom failed: %s\\n\",\n\t       strerror (errno));\n    }\n  gettimeofday(&tv, NULL);\n  mpz_set_ui (seed, tv.tv_sec);\n  mpz_mul_ui (seed, seed, 1000000UL);\n  mpz_add_ui (seed, seed, tv.tv_usec);\n}",
      "lines": 27,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        172,
        0
      ],
      "end_point": [
        233,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  const char *nettle_test_seed;\n  gmp_randstate_t rands;\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n  mpz_t plaintext;\n  unsigned i, j;\n\n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n  mpz_init (plaintext);\n\n  gmp_randinit_default (rands);\n\n#if !NETTLE_USE_MINI_GMP\n  nettle_test_seed = getenv (\"NETTLE_TEST_SEED\");\n  if (nettle_test_seed && *nettle_test_seed)\n    {\n      mpz_t seed;\n      mpz_init (seed);\n      if (mpz_set_str (seed, nettle_test_seed, 0) < 0\n\t  || mpz_sgn (seed) < 0)\n\tdie (\"Invalid NETTLE_TEST_SEED: %s\\n\",\n\t     nettle_test_seed);\n      if (mpz_sgn (seed) == 0)\n\tget_random_seed (seed);\n      fprintf (stderr, \"Using NETTLE_TEST_SEED=\");\n      mpz_out_str (stderr, 10, seed);\n      fprintf (stderr, \"\\n\");\n\n      gmp_randseed (rands, seed);\n      mpz_clear (seed);\n    }\n#endif\n\n  for (j = 0; j < KEY_COUNT; j++)\n    {\n#if !NETTLE_USE_MINI_GMP\n      generate_keypair(rands, &pub, &key);\n#else\n      rsa_generate_keypair(&pub, &key, &rands, random_fn, NULL, NULL, 512, 16);\n#endif /* !NETTLE_USE_MINI_GMP */\n\n      for (i = 0; i < COUNT; i++)\n\t{\n\t  mpz_urandomb(plaintext, rands, mpz_sizeinbase(pub.n, 2) - 1);\n\t  test_one(&rands, &pub, &key, plaintext);\n\t}\n      for (i = 0; i < COUNT; i++)\n\t{\n\t  mpz_rrandomb(plaintext, rands, mpz_sizeinbase(pub.n, 2) - 1);\n\t  test_one(&rands, &pub, &key, plaintext);\n\t}\n    }\n  mpz_clear (plaintext);\n  rsa_public_key_clear (&pub);\n  rsa_private_key_clear (&key);\n\n  gmp_randclear (rands);\n}",
      "lines": 62,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-encrypt-test.c": {
    "test_main": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n  struct knuth_lfib_ctx lfib;\n\n  /* FIXME: How is this spelled? */\n  const unsigned char msg[] = \"Squemish ossifrage\";\n  size_t msg_length = LLENGTH(msg);\n\n  uint8_t *decrypted;\n  size_t decrypted_length;\n  uint8_t after;\n\n  mpz_t gibberish;\n\n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n  mpz_init(gibberish);\n\n  knuth_lfib_init(&lfib, 17);\n  \n  test_rsa_set_key_1(&pub, &key);\n\n  if (verbose)\n    fprintf(stderr, \"msg: `%s', length = %d\\n\", msg, (int) msg_length);\n\n  ASSERT(msg_length <= key.size);\n  \n  ASSERT(rsa_encrypt(&pub,\n\t\t     &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t     msg_length, msg,\n\t\t     gibberish));\n\n  if (verbose)\n    {\n      fprintf(stderr, \"encrypted: \");\n      mpz_out_str(stderr, 10, gibberish);\n    }\n  \n  decrypted = xalloc(key.size + 1);\n\n  knuth_lfib_random (&lfib, msg_length + 1, decrypted);\n  after = decrypted[msg_length];\n  \n  decrypted_length = msg_length - 1;\n  ASSERT(!rsa_decrypt(&key, &decrypted_length, decrypted, gibberish));\n\n  decrypted_length = msg_length;\n  ASSERT(rsa_decrypt(&key, &decrypted_length, decrypted, gibberish));\n  ASSERT(decrypted_length == msg_length);\n  ASSERT(MEMEQ(msg_length, msg, decrypted));\n  ASSERT(decrypted[msg_length] == after);\n\n  knuth_lfib_random (&lfib, key.size + 1, decrypted);\n  after = decrypted[key.size];\n\n  decrypted_length = key.size;\n  ASSERT(rsa_decrypt(&key, &decrypted_length, decrypted, gibberish));\n  ASSERT(decrypted_length == msg_length);\n  ASSERT(MEMEQ(msg_length, msg, decrypted));\n  ASSERT(decrypted[key.size] == after);\n  \n  knuth_lfib_random (&lfib, msg_length + 1, decrypted);\n  after = decrypted[msg_length];\n\n  decrypted_length = msg_length;\n  ASSERT(rsa_decrypt_tr(&pub, &key,\n\t\t\t&lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t\t&decrypted_length, decrypted, gibberish));\n  ASSERT(decrypted_length == msg_length);\n  ASSERT(MEMEQ(msg_length, msg, decrypted));\n  ASSERT(decrypted[msg_length] == after);\n\n  /* test side channel resistant variant */\n  knuth_lfib_random (&lfib, msg_length + 1, decrypted);\n  after = decrypted[msg_length];\n  decrypted_length = msg_length;\n\n  ASSERT(rsa_sec_decrypt(&pub, &key,\n                         &lfib, (nettle_random_func *) knuth_lfib_random,\n                         decrypted_length, decrypted, gibberish));\n  ASSERT(MEMEQ(msg_length, msg, decrypted));\n  ASSERT(decrypted[msg_length] == after);\n\n  /* test invalid length to rsa_sec_decrypt */\n  knuth_lfib_random (&lfib, msg_length + 1, decrypted);\n  decrypted_length = msg_length - 1;\n  after = decrypted[decrypted_length] = 'X';\n  decrypted[0] = 'A';\n\n  ASSERT(!rsa_sec_decrypt(&pub, &key,\n                          &lfib, (nettle_random_func *) knuth_lfib_random,\n                          decrypted_length, decrypted, gibberish));\n  ASSERT(decrypted[decrypted_length] == after);\n  ASSERT(decrypted[0] == 'A');\n\n\n  /* Test invalid key. */\n  mpz_add_ui (key.q, key.q, 2);\n  decrypted_length = key.size;\n  ASSERT(!rsa_decrypt_tr(&pub, &key,\n\t\t\t &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t\t &decrypted_length, decrypted, gibberish));\n\n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(gibberish);\n  free(decrypted);\n}",
      "lines": 111,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-keygen-test.c": {
    "progress": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        8,
        1
      ],
      "content": "static void\nprogress(void *ctx UNUSED, int c)\n{\n  fputc(c, stderr);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        10,
        0
      ],
      "end_point": [
        76,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n  \n  struct knuth_lfib_ctx lfib;\n\n  mpz_t expected;\n  \n  mpz_init(expected);\n  \n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n\n  /* Generate a 1024 bit key with random e */\n  knuth_lfib_init(&lfib, 13);\n\n  ASSERT (rsa_generate_keypair(&pub, &key,\n\t\t\t       &lfib,\n\t\t\t       (nettle_random_func *) knuth_lfib_random,\n\t\t\t       NULL, verbose ? progress : NULL,\n\t\t\t       1024, 50));\n\n  test_rsa_key(&pub, &key);\n\n  mpz_set_str(expected,\n\t      \"31ee088024b66f28\" \"e182fa07e60f7864\" \"636eea21cf74c804\"\n\t      \"02a9c29ebd00933d\" \"8fae3ddf029d18e0\" \"1b5498c70a4b68fd\"\n\t      \"d3135748424e8caf\" \"43ee86068f250c92\" \"8da001d09f68c433\"\n\t      \"96f2c2a42eaed7e5\" \"8934a052faa38b2c\" \"f2ac04cc91bd0d15\"\n\t      \"4f60b16dc9045b08\" \"2ea1372717fd7f9c\" \"1e9cc383b7d5b909\"\n\t      \"72e3126df060ef79\" , 16);\n\n  test_rsa_md5(&pub, &key, expected);\n\n  /* Generate a 2000 bit key with fixed e */\n  knuth_lfib_init(&lfib, 17);\n\n  mpz_set_ui(pub.e, 17);\n  ASSERT (rsa_generate_keypair(&pub, &key,\n\t\t\t       &lfib,\n\t\t\t       (nettle_random_func *) knuth_lfib_random,\n\t\t\t       NULL, verbose ? progress : NULL,\n\t\t\t       2000, 0));\n\n  test_rsa_key(&pub, &key);\n\n  mpz_set_str(expected,\n\t      \"892ef7cda3b0b501\" \"85de20b93340316e\" \"b35ac9c193f1f5a3\"\n\t      \"9e6c1c327b9c36b8\" \"d4f1d41653b48fbd\" \"0c49e48bbdc46ced\"\n\t      \"13b3f6426e8a1780\" \"55b9077ba59ce748\" \"a325563c3b4bdf78\"\n\t      \"acdcdd556f5de3cf\" \"70257c3b334ba360\" \"5625ebda869c8058\"\n\t      \"b95b40c1e75eb91b\" \"776e83c0224757c6\" \"b61266cb1739df1a\"\n\t      \"c7fcc09194c575b5\" \"af4f3eb8e3aa3900\" \"22b72fb6e950c355\"\n\t      \"88743bab32c3a214\" \"ea5865e2f5c41d67\" \"12e745496890fc9d\"\n\t      \"7944a759f39d7b57\" \"e365d8d3f6ac2dd4\" \"052b6a2e58a6af82\"\n\t      \"b0d67e7fe09045d9\" \"bc965e260cf3c9a9\" \"3bfaa09bdd076dc2\"\n\t      \"c0ab48ce5b67105c\" \"cad90dcfc11cd713\" \"e64478d2d7ea42dd\"\n\t      \"fd040793c487588d\" \"6218\" , 16);\n\n  test_rsa_sha1(&pub, &key, expected);\n  \n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(expected);\n}",
      "lines": 67,
      "depth": 11,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-pss-sign-tr-test.c": {
    "test_rsa_pss_sign_tr": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\ntest_rsa_pss_sign_tr(struct rsa_public_key *pub,\n\t\t     struct rsa_private_key *key,\n\t\t     test_pss_sign_tr_func sign_tr_func,\n\t\t     test_pss_verify_func verify_func,\n\t\t     void *ctx, const struct nettle_hash *hash,\n\t\t     size_t salt_length, const uint8_t *salt,\n\t\t     size_t length, const uint8_t *message,\n\t\t     mpz_t expected)\n{\n  mpz_t signature;\n  struct knuth_lfib_ctx lfib;\n  uint8_t digest[NETTLE_MAX_HASH_DIGEST_SIZE];\n  uint8_t bad_digest[NETTLE_MAX_HASH_DIGEST_SIZE];\n\n  knuth_lfib_init(&lfib, 1111);\n\n  hash->init(ctx);\n  hash->update(ctx, length, message);\n  hash->digest(ctx, hash->digest_size, digest);\n\n  mpz_init(signature);\n\n  mpz_set_ui (signature, 17);\n  /* Try bad private key */\n  mpz_add_ui(key->p, key->p, 2);\n\n  ASSERT(!sign_tr_func(pub, key,\n\t\t       &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t       salt_length, salt,\n\t\t       digest, signature));\n\n  mpz_sub_ui(key->p, key->p, 2);\n\n  ASSERT(!mpz_cmp_ui(signature, 17));\n\n  /* Try the good private key */\n  ASSERT(sign_tr_func(pub, key,\n\t\t      &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t      salt_length, salt,\n\t\t      digest, signature));\n\n  if (verbose)\n    {\n      fprintf(stderr, \"rsa-pss-tr signature: \");\n      mpz_out_str(stderr, 16, signature);\n      fprintf(stderr, \"\\nrsa-pss-tr expected: \");\n      mpz_out_str(stderr, 16, expected);\n      fprintf(stderr, \"\\n\");\n    }\n\n  ASSERT (mpz_cmp(signature, expected) == 0);\n\n  /* Try bad digest */\n  memset(bad_digest, 0x17, sizeof(bad_digest));\n  ASSERT (!verify_func(pub, salt_length, bad_digest, signature));\n\n  /* Try the good digest */\n  ASSERT (verify_func(pub, salt_length, digest, signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!verify_func(pub, salt_length, digest, signature));\n\n  mpz_clear(signature);\n}",
      "lines": 66,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        355,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n  struct sha256_ctx sha256ctx;\n  struct sha384_ctx sha384ctx;\n  struct sha512_ctx sha512ctx;\n  mpz_t p1;\n  mpz_t q1;\n  struct tstring *salt;\n  struct tstring *msg;\n\n  mpz_t expected;\n\n  mpz_init(expected);\n\n  mpz_init(p1);\n  mpz_init(q1);\n\n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n\n  test_rsa_set_key_1(&pub, &key);\n\n  /* Test signatures */\n  mpz_set_str(expected,\n\t      \"25e6ce0cc00e917e177a09cb4dfd843d104c179b71aded60e68ebc\"\n\t      \"ca2cabb1e51502adf28e53fa7ede42619f21a1162755b9658edf88\"\n\t      \"a038bb4fea2bb73306fb384d5785c1a8c98a255277c91a4f88ddd3\"\n\t      \"52ebdc78f71f7e62b7a870dac4ab25f1004453457e831a1572f7c9\"\n\t      \"23fcc48e3b69db582127d14471c7195dce\", 16);\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha256_sign_digest_tr,\n\t\t       rsa_pss_sha256_verify_digest,\n\t\t       &sha256ctx, &nettle_sha256,\n\t\t       LDATA(SALT), LDATA(MSG1), expected);\n\n  mpz_set_str(expected,\n\t      \"52f4393ccc92b5672dd3cfd8624765d3a4cdb50c7a92060c33b4663\"\n\t      \"fa545b32ce56ec8cd44fe9720df301906ae40921e844b6d80331194\"\n\t      \"972f98e309c937c887c53da940778f29d52dd9489e6016a07e9aa16\"\n\t      \"b1ea8fefc0860ad69068ad6f94a4b0c8fc8a0797b08c58cf4a8df90\"\n\t      \"ee1375feedf7bf73f16ebb2d1cc7e4\", 16);\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha256_sign_digest_tr,\n\t\t       rsa_pss_sha256_verify_digest,\n\t\t       &sha256ctx, &nettle_sha256,\n\t\t       LDATA(SALT), LDATA(MSG2), expected);\n\n  /* 777-bit key, generated by\n   *\n   *   lsh-keygen -a rsa -l 777 -f advanced-hex\n   *\n   * Interesting because the size of n doesn't equal the sum of the\n   * sizes of p and q.\n   *\n   * (private-key (rsa-pkcs1\n   *        (n #013b04440e3eef25 d51c738d508a7fa8 b3445180c342af0f\n   *            4cb5a789047300e2 cfc5c5450974cfc2 448aeaaa7f43c374\n   *            c9a3b038b181f2d1 0f1a2327fd2c087b a49bf1086969fd2c\n   *            d1df3fd69f81fa4b 162cc8bbb363fc95 b7b24b9c53d0c67e\n   *            f52b#)\n   *        (e #3f1a012d#)\n   *        (d #f9bae89dacca6cca c21e0412b4df8355 6fe7c5322bbae8ad\n   *            3f11494fd12bc076 d4a7da3050fe109d 2074db09cc6a93b4\n   *            745479522558379e a0ddfa74f86c9e9e a22c3b0e93d51447\n   *            0feb38105dd35395 63b91ee32776f40c 67b2a175690f7abb\n   *            25#)\n   *        (p #0b73c990eeda0a2a 2c26416052c85560 0c5c0f5ce86a8326\n   *            166acea91786237a 7ff884e66dbfdd3a ab9d9801414c1506\n   *            8b#)\n   *        (q #1b81c19a62802a41 9c99283331b0badb 08eb0c25ffce0fbf\n   *            50017850036f32f3 2132a845b91a5236 61f7b451d587383f\n   *            e1#)\n   *        (a #0a912fc93a6cca6b 3521725a3065b3be 3c9745e29c93303d\n   *            7d29316c6cafa4a2 89945f964fcdea59 1f9d248b0b6734be\n   *            c9#)\n   *        (b #1658eca933251813 1eb19c77aba13d73 e0b8f4ce986d7615\n   *            764c6b0b03c18146 46b7f332c43e05c5 351e09006979ca5b\n   *            05#)\n   *        (c #0114720dace7b27f 2bf2850c1804869f 79a0aad0ec02e6b4\n   *            05e1831619db2f10 bb9b6a8fd5c95df2 eb78f303ea0c0cc8\n   *            06#)))\n   */\n\n  mpz_set_str(pub.n,\n\t      \"013b04440e3eef25\" \"d51c738d508a7fa8\" \"b3445180c342af0f\"\n\t      \"4cb5a789047300e2\" \"cfc5c5450974cfc2\" \"448aeaaa7f43c374\"\n\t      \"c9a3b038b181f2d1\" \"0f1a2327fd2c087b\" \"a49bf1086969fd2c\"\n\t      \"d1df3fd69f81fa4b\" \"162cc8bbb363fc95\" \"b7b24b9c53d0c67e\"\n\t      \"f52b\", 16);\n\n  mpz_set_str(pub.e, \"3f1a012d\", 16);\n\n  ASSERT (rsa_public_key_prepare(&pub));\n\n  mpz_set_str(key.p,\n\t      \"0b73c990eeda0a2a\" \"2c26416052c85560\" \"0c5c0f5ce86a8326\"\n\t      \"166acea91786237a\" \"7ff884e66dbfdd3a\" \"ab9d9801414c1506\"\n\t      \"8b\", 16);\n\n  mpz_set_str(key.q,\n\t      \"1b81c19a62802a41\" \"9c99283331b0badb\" \"08eb0c25ffce0fbf\"\n\t      \"50017850036f32f3\" \"2132a845b91a5236\" \"61f7b451d587383f\"\n\t      \"e1\", 16);\n\n  mpz_set_str(key.a,\n\t      \"0a912fc93a6cca6b\" \"3521725a3065b3be\" \"3c9745e29c93303d\"\n\t      \"7d29316c6cafa4a2\" \"89945f964fcdea59\" \"1f9d248b0b6734be\"\n\t      \"c9\", 16);\n\n  mpz_set_str(key.b,\n\t      \"1658eca933251813\" \"1eb19c77aba13d73\" \"e0b8f4ce986d7615\"\n\t      \"764c6b0b03c18146\" \"46b7f332c43e05c5\" \"351e09006979ca5b\"\n\t      \"05\", 16);\n\n  mpz_set_str(key.c,\n\t      \"0114720dace7b27f\" \"2bf2850c1804869f\" \"79a0aad0ec02e6b4\"\n\t      \"05e1831619db2f10\" \"bb9b6a8fd5c95df2\" \"eb78f303ea0c0cc8\"\n\t      \"06\", 16);\n\n  ASSERT (rsa_private_key_prepare(&key));\n  ASSERT (pub.size == key.size);\n\n  /* Test signatures */\n  mpz_set_str(expected,\n\t      \"1a4d28331341cabf7ac85bc59a58d439b7ec2c607c6a74e35b5909\"\n\t      \"1dfa3d9de9fde93e4a431f0f768bec07c39995d253209f86e3dc84\"\n\t      \"037ecd5d23d963fab4fa8a001e018d82cb19d743a94ba7dc7a821e\"\n\t      \"87b72e67a0fe058f956208f7060dc104\", 16);\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha256_sign_digest_tr,\n\t\t       rsa_pss_sha256_verify_digest,\n\t\t       &sha256ctx, &nettle_sha256,\n\t\t       LDATA(SALT), LDATA(MSG1), expected);\n\n  /* From FIPS 186-2 */\n  mpz_set_str(pub.n,\n\t      \"be499b5e7f06c83f\" \"a0293e31465c8eb6\" \"b58af920bae52a7b\"\n\t      \"5b9bfeb7aa72db12\" \"64112eb3fd431d31\" \"a2a7e50941566929\"\n\t      \"494a0e891ed56139\" \"18b4b51b0d1fb977\" \"83b26acf7d0f384c\"\n\t      \"fb35f4d2824f5dd3\" \"80623a26bf180b63\" \"961c619dcdb20cae\"\n\t      \"406f22f6e276c80a\" \"37259490cfeb72c1\" \"a71a84f1846d3308\"\n\t      \"77ba3e3101ec9c7b\" , 16);\n\n  mpz_set_str(pub.e, \"11\", 16);\n\n  ASSERT (rsa_public_key_prepare(&pub));\n\n  mpz_set_str(key.p,\n\t      \"e7a80c5d211c06ac\" \"b900939495f26d36\" \"5fc2b4825b75e356\"\n\t      \"f89003eaa5931e6b\" \"e5c3f7e6a633ad59\" \"db6289d06c354c23\"\n\t      \"5e739a1e3f3d39fb\" \"40d1ffb9cb44288f\", 16);\n\n  mpz_set_str(key.q,\n\t      \"d248aa248000f720\" \"258742da67b71194\" \"0c8f76e1ecd52b67\"\n\t      \"a6ffe1e49354d66f\" \"f84fa601804743f5\" \"838da2ed4693a5a2\"\n\t      \"8658d6528cc1803b\" \"f6c8dc73c5230b55\", 16);\n\n  mpz_set_str(key.d,\n\t      \"0d0f17362bdad181\" \"db4e1fe03e8de1a3\" \"208989914e14bf26\"\n\t      \"9558826bfa20faf4\" \"b68dba6bb989a01f\" \"03a21c44665dc5f6\"\n\t      \"48cb5b59b954eb10\" \"77a80263bd22cdfb\" \"88d39164b7404f4f\"\n\t      \"1106ee01cf60b776\" \"95748d8fdaf9fd42\" \"8963fe75144010b1\"\n\t      \"934c8e26a8823967\" \"2cf49b3422a07c4d\" \"834ba208d570fe40\"\n\t      \"8e7095c90547e68d\", 16);\n\n  /* a = d % (p-1) */\n  mpz_sub_ui(p1, key.p, 1);\n  mpz_fdiv_r(key.a, key.d, p1);\n  mpz_clear(p1);\n\n  /* b = d % (q-1) */\n  mpz_sub_ui(q1, key.q, 1);\n  mpz_fdiv_r(key.b, key.d, q1);\n  mpz_clear(q1);\n\n  /* c = q^{-1} (mod p) */\n  mpz_invert(key.c, key.q, key.p);\n\n  ASSERT (rsa_private_key_prepare(&key));\n  ASSERT (pub.size == key.size);\n\n  mpz_set_str(expected,\n\t      \"11e169f2fd40b07641b9768a2ab19965fb6c27f10fcf0323fcc6d1\"\n\t      \"2eb4f1c06b330ddaa1ea504407afa29de9ebe0374fe9d1e7d0ffbd\"\n\t      \"5fc1cf3a3446e4145415d2ab24f789b3464c5c43a256bbc1d692cf\"\n\t      \"7f04801dac5bb401a4a03ab7d5728a860c19e1a4dc797ca542c820\"\n\t      \"3cec2e601eb0c51f567f2eda022b0b9ebddeeefa\", 16);\n\n  salt = SHEX(\"11223344555432167890\");\n  msg = SHEX(\"c7f5270fca725f9bd19f519a8d7cca3cc5c079024029f3bae510f9\"\n\t     \"b02140fe238908e4f6c18f07a89c687c8684669b1f1db2baf9251a\"\n\t     \"3c829faccb493084e16ec9e28d58868074a5d6221667dd6e528d16\"\n\t     \"fe2c9f3db4cfaf6c4dce8c8439af38ceaaaa9ce2ecae7bc8f4a5a5\"\n\t     \"5e3bf96df9cd575c4f9cb327951b8cdfe4087168\");\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha256_sign_digest_tr,\n\t\t       rsa_pss_sha256_verify_digest,\n\t\t       &sha256ctx, &nettle_sha256,\n\t\t       salt->length, salt->data, msg->length, msg->data,\n\t\t       expected);\n\n  mpz_set_str(expected,\n\t      \"b281ad934b2775c0cba5fb10aa574d2ed85c7f99b942b78e497024\"\n\t      \"80069362ed394baded55e56cfcbe7b0b8d2217a05a60e1acd725cb\"\n\t      \"09060dfac585bc2132b99b41cdbd530c69d17cdbc84bc6b9830fc7\"\n\t      \"dc8e1b2412cfe06dcf8c1a0cc3453f93f25ebf10cb0c90334fac57\"\n\t      \"3f449138616e1a194c67f44efac34cc07a526267\", 16);\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha384_sign_digest_tr,\n\t\t       rsa_pss_sha384_verify_digest,\n\t\t       &sha384ctx, &nettle_sha384,\n\t\t       salt->length, salt->data, msg->length, msg->data,\n\t\t       expected);\n  mpz_set_str(expected,\n\t      \"8ffc38f9b820ef6b080fd2ec7de5626c658d79056f3edf610a295b\"\n\t      \"7b0546f73e01ffdf4d0070ebf79c33fd86c2d608be9438b3d420d0\"\n\t      \"9535b97cd3d846ecaf8f6551cdf93197e9f8fb048044473ab41a80\"\n\t      \"1e9f7fc983c62b324361dade9f71a65952bd35c59faaa4d6ff462f\"\n\t      \"68a6c4ec0b428aa47336f2178aeb276136563b7d\", 16);\n\n  test_rsa_pss_sign_tr(&pub, &key,\n\t\t       rsa_pss_sha512_sign_digest_tr,\n\t\t       rsa_pss_sha512_verify_digest,\n\t\t       &sha512ctx, &nettle_sha512,\n\t\t       salt->length, salt->data, msg->length, msg->data,\n\t\t       expected);\n\n  /* The public key n for this test is of size k = 1017 bits, and the\n     pss \"em\" value is limited to k - 1 = 1016 bits or 127 octets. The\n     alleged signature below results in a 1017 bit number during the\n     signature verification, which is too large, and used to result in\n     an assertion failure when attempting to convert the number to a\n     127 octet string.\n  */\n  mpz_set_str(pub.n,\n\t      \"1d64559685aad3490e976b48aacf442ecee847268f882341eafe78\"\n\t      \"a0ca4ef88f66edbaf55b70e5285cc117aa9ceb322a4227c17e9e89\"\n\t      \"27bf38e5672faecf79e2983d92766fbb6624522f072ae0e4e46d37\"\n\t      \"052ce1e5745c2dd8fd67de3862e4711161e359b96bda85911ebf4e\"\n\t      \"6ce1bea625970269c77004a3cb03f9c382c5f79\", 16);\n  mpz_set_str(pub.e, \"10001\", 16);\n\n  ASSERT (rsa_public_key_prepare(&pub));\n\n  msg = SHEX(\"7f85e4909ff7bb29536e540a53031ef03ddcb129e553a43273fa1f\"\n\t     \"ed28c22a8b57c7bde101ff746f335ba69b29642019\");\n  /* Alleged signature, resulting in a too large m. */\n  mpz_set_str(expected,\n\t      \"000000000000000000000000000000000000000000000000000000\"\n\t      \"000000000000000000000000000000000000000000000005ffff05\"\n\t      \"000000000000000000000000000000000000000000000000000000\"\n\t      \"000000000000000000000000000000000000000000000000000000\"\n\t      \"0000000000000000000000000000000000000000\", 16);\n\n  ASSERT(!rsa_pss_sha384_verify_digest(&pub, 48, msg->data, expected));\n\n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(expected);\n}",
      "lines": 268,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-sec-decrypt-test.c": {
    "rsa_decrypt_for_test": {
      "start_point": [
        14,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "static int\nrsa_decrypt_for_test(const struct rsa_public_key *pub,\n                     const struct rsa_private_key *key,\n                     void *random_ctx, nettle_random_func *random,\n                     size_t length, uint8_t *message,\n                     const mpz_t gibberish)\n{\n  int ret;\n  /* Makes valgrind trigger on any branches depending on the input\n     data. Except that (i) we have to allow rsa_sec_compute_root_tr to\n     check that p and q are odd, (ii) mpn_sec_div_r may leak\n     information about the most significant bits of p and q, due to\n     normalization check and table lookup in invert_limb, and (iii)\n     mpn_sec_powm may leak information about the least significant\n     bits of p and q, due to table lookup in binvert_limb. */\n  VALGRIND_MAKE_MEM_UNDEFINED (message, length);\n  MARK_MPZ_LIMBS_UNDEFINED(gibberish);\n  MARK_MPZ_LIMBS_UNDEFINED(key->a);\n  MARK_MPZ_LIMBS_UNDEFINED(key->b);\n  MARK_MPZ_LIMBS_UNDEFINED(key->c);\n  VALGRIND_MAKE_MEM_UNDEFINED(mpz_limbs_read (key->p) + 1,\n\t\t\t      (mpz_size (key->p) - 3) * sizeof(mp_limb_t));\n  VALGRIND_MAKE_MEM_UNDEFINED(mpz_limbs_read (key->q) + 1,\n\t\t\t      (mpz_size (key->q) - 3) * sizeof(mp_limb_t));\n\n  ret = rsa_sec_decrypt (pub, key, random_ctx, random, length, message, gibberish);\n\n  VALGRIND_MAKE_MEM_DEFINED (message, length);\n  VALGRIND_MAKE_MEM_DEFINED (&ret, sizeof(ret));\n  MARK_MPZ_LIMBS_DEFINED(gibberish);\n  MARK_MPZ_LIMBS_DEFINED(key->a);\n  MARK_MPZ_LIMBS_DEFINED(key->b);\n  MARK_MPZ_LIMBS_DEFINED(key->c);\n  MARK_MPZ_LIMBS_DEFINED(key->p);\n  MARK_MPZ_LIMBS_DEFINED(key->q);\n\n  return ret;\n}",
      "lines": 38,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_main": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n  struct knuth_lfib_ctx random_ctx;\n\n  uint8_t plaintext[PAYLOAD_SIZE];\n  uint8_t decrypted[PAYLOAD_SIZE];\n  uint8_t verifybad[PAYLOAD_SIZE];\n  unsigned n_size = 1024;\n  mpz_t gibberish;\n  mpz_t garbage;\n\n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n  mpz_init(gibberish);\n  mpz_init(garbage);\n\n  knuth_lfib_init (&random_ctx, 19);\n\n  memset(verifybad, 'A', PAYLOAD_SIZE);\n\n  for (size_t size = 1; size < 51; size++)\n    {\n      ASSERT (rsa_generate_keypair(&pub, &key, &random_ctx,\n\t\t\t           (nettle_random_func *) knuth_lfib_random,\n\t\t\t           NULL, NULL, n_size, 17));\n\n      /* the next key will be 19 bits larger */\n      n_size += 19;\n\n      knuth_lfib_random (&random_ctx, PAYLOAD_SIZE, plaintext);\n      ASSERT(rsa_encrypt(&pub, &random_ctx,\n                         (nettle_random_func *) knuth_lfib_random,\n                         PAYLOAD_SIZE, plaintext, gibberish));\n\n      /* good decryption */\n      ASSERT (rsa_decrypt_for_test (&pub, &key, &random_ctx,\n                                    (nettle_random_func *) knuth_lfib_random,\n                                    PAYLOAD_SIZE, decrypted, gibberish) == 1);\n      ASSERT (MEMEQ (PAYLOAD_SIZE, plaintext, decrypted));\n\n      /* bad one */\n      memcpy(decrypted, verifybad, PAYLOAD_SIZE);\n      nettle_mpz_random_size(garbage, &random_ctx,\n                             (nettle_random_func *) knuth_lfib_random,\n                             mpz_sizeinbase(gibberish, 2));\n\n      ASSERT (rsa_decrypt_for_test (&pub, &key, &random_ctx,\n                                    (nettle_random_func *) knuth_lfib_random,\n                                    PAYLOAD_SIZE, decrypted, garbage) == 0);\n      ASSERT (MEMEQ (PAYLOAD_SIZE, verifybad, decrypted));\n    }\n\n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(gibberish);\n  mpz_clear(garbage);\n}",
      "lines": 60,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-sign-tr-test.c": {
    "test_rsa_sign_tr": {
      "start_point": [
        6,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static void\ntest_rsa_sign_tr(struct rsa_public_key *pub,\n\t     struct rsa_private_key *key,\n\t     unsigned di_length,\n\t     const uint8_t *di,\n\t     mpz_t expected)\n{\n  mpz_t signature;\n  struct knuth_lfib_ctx lfib;\n\n  knuth_lfib_init(&lfib, 1111);\n\n  mpz_init(signature);\n  mpz_set_ui (signature, 17);\n  /* Try bad private key */\n  mpz_add_ui(key->p, key->p, 2);\n\n  ASSERT(!rsa_pkcs1_sign_tr(pub, key,\n\t\t    &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t    di_length, di, signature));\n\n  mpz_sub_ui(key->p, key->p, 2);\n\n  ASSERT(!mpz_cmp_ui(signature, 17));\n\n  /* Try the good private key */\n  ASSERT(rsa_pkcs1_sign_tr(pub, key,\n\t\t    &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t    di_length, di, signature));\n\n  if (verbose)\n    {\n      fprintf(stderr, \"rsa-pkcs1-tr signature: \");\n      mpz_out_str(stderr, 16, signature);\n      fprintf(stderr, \"\\nrsa-pkcs1-tr expected: \");\n      mpz_out_str(stderr, 16, expected);\n      fprintf(stderr, \"\\n\");\n    }\n\n  ASSERT (mpz_cmp(signature, expected) == 0);\n\n  /* Try bad data */\n  ASSERT (!rsa_pkcs1_verify(pub, 16, (void*)\"The magick words\", signature));\n\n  /* Try correct data */\n  ASSERT (rsa_pkcs1_verify(pub, di_length, di, signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!rsa_pkcs1_verify(pub, di_length, di, signature));\n\n  mpz_clear(signature);\n}",
      "lines": 53,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        192,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n\n  mpz_t expected;\n\n  mpz_init(expected);\n\n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n\n  test_rsa_set_key_1(&pub, &key);\n\n  /* Test signatures */\n  mpz_set_str(expected,\n\t      \"23bd361a622bc35450a30ae332d8dad050c6bad5cae0b61c5bee29\"\n\t      \"db876d7fe098472fc7933f2cc1121c0fc8a414c71a98189c66077b\"\n\t      \"fe3d58d08dc242bbcfdf2c905b91de0e479a8b4b159a45fe1789db\"\n\t      \"abdaf88aa704e7558f24f5a0be382619758061cde89e9c730ac6db\"\n\t      \"ef005bfad5a936633e3dfccc37b2214e2\",\n\t      16);\n\n  test_rsa_sign_tr(&pub, &key, LDATA(MSG1), expected);\n\n  mpz_set_str(expected,\n\t      \"15bd817f53501f8eb6693283004546ba14f19dd4da742b1e30a7b2\"\n\t      \"1db309cd3f36f821f565d31c1ed2df8b6648dd8bdb218f841f5506\"\n\t      \"a437825999aaf3ef77dff9a1fc7631ce0e99f851f4166ae67caed9\"\n\t      \"820a764e44274a898ddd72f4c7115ba49d332f4fa929ee6dce4d61\"\n\t      \"39fef8d8d25d4c9ff857689846e5cac26d\", 16);\n\n  test_rsa_sign_tr(&pub, &key, LDATA(MSG2), expected);\n\n  /* 777-bit key, generated by\n   *\n   *   lsh-keygen -a rsa -l 777 -f advanced-hex\n   *\n   * Interesting because the size of n doesn't equal the sum of the\n   * sizes of p and q.\n   *\n   * (private-key (rsa-pkcs1\n   *        (n #013b04440e3eef25 d51c738d508a7fa8 b3445180c342af0f\n   *            4cb5a789047300e2 cfc5c5450974cfc2 448aeaaa7f43c374\n   *            c9a3b038b181f2d1 0f1a2327fd2c087b a49bf1086969fd2c\n   *            d1df3fd69f81fa4b 162cc8bbb363fc95 b7b24b9c53d0c67e\n   *            f52b#)\n   *        (e #3f1a012d#)\n   *        (d #f9bae89dacca6cca c21e0412b4df8355 6fe7c5322bbae8ad\n   *            3f11494fd12bc076 d4a7da3050fe109d 2074db09cc6a93b4\n   *            745479522558379e a0ddfa74f86c9e9e a22c3b0e93d51447\n   *            0feb38105dd35395 63b91ee32776f40c 67b2a175690f7abb\n   *            25#)\n   *        (p #0b73c990eeda0a2a 2c26416052c85560 0c5c0f5ce86a8326\n   *            166acea91786237a 7ff884e66dbfdd3a ab9d9801414c1506\n   *            8b#)\n   *        (q #1b81c19a62802a41 9c99283331b0badb 08eb0c25ffce0fbf\n   *            50017850036f32f3 2132a845b91a5236 61f7b451d587383f\n   *            e1#)\n   *        (a #0a912fc93a6cca6b 3521725a3065b3be 3c9745e29c93303d\n   *            7d29316c6cafa4a2 89945f964fcdea59 1f9d248b0b6734be\n   *            c9#)\n   *        (b #1658eca933251813 1eb19c77aba13d73 e0b8f4ce986d7615\n   *            764c6b0b03c18146 46b7f332c43e05c5 351e09006979ca5b\n   *            05#)\n   *        (c #0114720dace7b27f 2bf2850c1804869f 79a0aad0ec02e6b4\n   *            05e1831619db2f10 bb9b6a8fd5c95df2 eb78f303ea0c0cc8\n   *            06#)))\n   */\n\n  mpz_set_str(pub.n,\n\t      \"013b04440e3eef25\" \"d51c738d508a7fa8\" \"b3445180c342af0f\"\n\t      \"4cb5a789047300e2\" \"cfc5c5450974cfc2\" \"448aeaaa7f43c374\"\n\t      \"c9a3b038b181f2d1\" \"0f1a2327fd2c087b\" \"a49bf1086969fd2c\"\n\t      \"d1df3fd69f81fa4b\" \"162cc8bbb363fc95\" \"b7b24b9c53d0c67e\"\n\t      \"f52b\", 16);\n\n  mpz_set_str(pub.e, \"3f1a012d\", 16);\n\n  ASSERT (rsa_public_key_prepare(&pub));\n\n  mpz_set_str(key.p,\n\t      \"0b73c990eeda0a2a\" \"2c26416052c85560\" \"0c5c0f5ce86a8326\"\n\t      \"166acea91786237a\" \"7ff884e66dbfdd3a\" \"ab9d9801414c1506\"\n\t      \"8b\", 16);\n\n  mpz_set_str(key.q,\n\t      \"1b81c19a62802a41\" \"9c99283331b0badb\" \"08eb0c25ffce0fbf\"\n\t      \"50017850036f32f3\" \"2132a845b91a5236\" \"61f7b451d587383f\"\n\t      \"e1\", 16);\n\n  mpz_set_str(key.a,\n\t      \"0a912fc93a6cca6b\" \"3521725a3065b3be\" \"3c9745e29c93303d\"\n\t      \"7d29316c6cafa4a2\" \"89945f964fcdea59\" \"1f9d248b0b6734be\"\n\t      \"c9\", 16);\n\n  mpz_set_str(key.b,\n\t      \"1658eca933251813\" \"1eb19c77aba13d73\" \"e0b8f4ce986d7615\"\n\t      \"764c6b0b03c18146\" \"46b7f332c43e05c5\" \"351e09006979ca5b\"\n\t      \"05\", 16);\n\n  mpz_set_str(key.c,\n\t      \"0114720dace7b27f\" \"2bf2850c1804869f\" \"79a0aad0ec02e6b4\"\n\t      \"05e1831619db2f10\" \"bb9b6a8fd5c95df2\" \"eb78f303ea0c0cc8\"\n\t      \"06\", 16);\n\n  ASSERT (rsa_private_key_prepare(&key));\n  ASSERT (pub.size == key.size);\n\n  /* Test signatures */\n  mpz_set_str(expected,\n\t      \"5493d4d774d03f54de2e9bef6818b74a8e22bbe9628b6dec3f178d\"\n\t      \"cc0090dab933a0f24bc9ac8aec949558868ea4f8e29d0248e70717\"\n\t      \"6c113e8fbd9f1428c45a120378e32febffd4e9aca8102081bb5b90\"\n\t      \"0f2914395a220823b700dbd7bd32646e\", 16);\n\n  test_rsa_sign_tr(&pub, &key, LDATA(MSG1), expected);\n\n  /* Test sha1 signature */\n  mpz_set_str(expected,\n\t      \"126bbd3d9e8649187069d8b6f0f43bd234a53249f765f616647049\"\n\t      \"ca49b2c4cc8049440d5a9f1d10fcdf162b40afd9b761bcd30e2c60\"\n\t      \"133b2c6f0504fe447038422b835d35448acb0881e894144e4ccaea\"\n\t      \"59ce8dd16d3540fcbb84ebd1c5fb37510\", 16);\n\n  test_rsa_sign_tr(&pub, &key, LDATA(MSG2), expected);\n\n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(expected);\n}",
      "lines": 132,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        182,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key key;\n\n  mpz_t expected;\n  \n  mpz_init(expected);\n  \n  rsa_private_key_init(&key);\n  rsa_public_key_init(&pub);\n\n  test_rsa_set_key_1(&pub, &key);\n  \n  /* Test md5 signatures */\n  mpz_set_str(expected,\n\t      \"53bf517009fa956e\" \"3daa6adc95e8663d\" \"3759002f488bbbad\"\n\t      \"e49f62792d85dbcc\" \"293f68e2b68ef89a\" \"c5bd42d98f845325\"\n\t      \"3e6c1b76fc337db5\" \"e0053f255c55faf3\" \"eb6cc568ad7f5013\"\n\t      \"5b269a64acb9eaa7\" \"b7f09d9bd90310e6\" \"4c58f6dbe673ada2\"\n\t      \"67c97a9d99e19f9d\" \"87960d9ce3f0d5ce\" \"84f401fe7e10fa24\"\n\t      \"28b9bffcf9\", 16);\n\n  test_rsa_md5(&pub, &key, expected);\n\n  /* Test sha1 signature */\n  mpz_set_str(expected,\n\t      \"129b405ed85db88c\" \"55d35344c4b52854\" \"496516b4d63d8211\"\n\t      \"80a0c24d6ced9047\" \"33065a564bbd33d0\" \"a5cdfd204b9c6d15\"\n\t      \"78337207c2f1662d\" \"c73906c7a0f2bf5c\" \"af92cef9121957b1\"\n\t      \"dcb111ff47b92389\" \"888e384d0cfd1b1e\" \"e5d7003a8feff3fd\"\n\t      \"dd6a71d242a79272\" \"25234d67ba369441\" \"c12ae555c697754e\"\n\t      \"a17f93fa92\", 16);\n\n  test_rsa_sha1(&pub, &key, expected);\n\n  mpz_set_str(expected,\n\t      \"13f9e43f7a401a73\" \"0a74985c01520d76\" \"bf5f2e2dff91e93b\"\n\t      \"9267d8c388d6937b\" \"d4bc6f1fa31618a9\" \"b5e3a1a875af72f5\"\n\t      \"0e805dbfebdf4348\" \"7d49763f0b365e78\" \"d2c0ea8fb3785897\"\n\t      \"782289a58f998907\" \"248c9cdf2c643d7e\" \"6ba6b55026227773\"\n\t      \"6f19caa69c4fc6d7\" \"7e2e5d4cd6b7a82b\" \"900d201ffd000448\"\n\t      \"685e5a4f3e\", 16);\n\n  test_rsa_sha256(&pub, &key, expected);\n\n  mpz_set_str(expected,\n\t      \"06327f717f43bcf3\" \"5994e567e8241963\" \"8c22e1057a7771e7\"\n\t      \"a665bb7441a39cc8\" \"7762f6b1a459cae3\" \"281462ed3f6aec48\"\n\t      \"15c2365797a02af6\" \"8a603adf276c46f6\" \"e6afb25d07c57f47\"\n\t      \"c516aff84abda629\" \"cc83d9364eb3616d\" \"7d4ddf0e9a25fac5\"\n\t      \"7d56a252b0cb7b1f\" \"8266b525e9b893af\" \"116e7845c0969a9f\"\n\t      \"603e2543f3\", 16);\n\n  test_rsa_sha512(&pub, &key, expected);\n\n  /* Test detection of invalid keys with even modulo */\n  mpz_clrbit (pub.n, 0);\n  ASSERT (!rsa_public_key_prepare (&pub));\n\n  mpz_clrbit (key.p, 0);\n  ASSERT (!rsa_private_key_prepare (&key));\n\n  /* 777-bit key, generated by\n   *\n   *   lsh-keygen -a rsa -l 777 -f advanced-hex\n   *\n   * Interesting because the size of n doesn't equal the sum of the\n   * sizes of p and q. \n   *\n   * (private-key (rsa-pkcs1\n   *        (n #013b04440e3eef25 d51c738d508a7fa8 b3445180c342af0f\n   *            4cb5a789047300e2 cfc5c5450974cfc2 448aeaaa7f43c374\n   *            c9a3b038b181f2d1 0f1a2327fd2c087b a49bf1086969fd2c\n   *            d1df3fd69f81fa4b 162cc8bbb363fc95 b7b24b9c53d0c67e\n   *            f52b#)\n   *        (e #3f1a012d#)\n   *        (d #f9bae89dacca6cca c21e0412b4df8355 6fe7c5322bbae8ad\n   *            3f11494fd12bc076 d4a7da3050fe109d 2074db09cc6a93b4\n   *            745479522558379e a0ddfa74f86c9e9e a22c3b0e93d51447\n   *            0feb38105dd35395 63b91ee32776f40c 67b2a175690f7abb\n   *            25#)\n   *        (p #0b73c990eeda0a2a 2c26416052c85560 0c5c0f5ce86a8326\n   *            166acea91786237a 7ff884e66dbfdd3a ab9d9801414c1506\n   *            8b#)\n   *        (q #1b81c19a62802a41 9c99283331b0badb 08eb0c25ffce0fbf\n   *            50017850036f32f3 2132a845b91a5236 61f7b451d587383f\n   *            e1#)\n   *        (a #0a912fc93a6cca6b 3521725a3065b3be 3c9745e29c93303d\n   *            7d29316c6cafa4a2 89945f964fcdea59 1f9d248b0b6734be\n   *            c9#)\n   *        (b #1658eca933251813 1eb19c77aba13d73 e0b8f4ce986d7615\n   *            764c6b0b03c18146 46b7f332c43e05c5 351e09006979ca5b\n   *            05#)\n   *        (c #0114720dace7b27f 2bf2850c1804869f 79a0aad0ec02e6b4\n   *            05e1831619db2f10 bb9b6a8fd5c95df2 eb78f303ea0c0cc8\n   *            06#)))\n   */\n  \n  mpz_set_str(pub.n,\n\t      \"013b04440e3eef25\" \"d51c738d508a7fa8\" \"b3445180c342af0f\"\n\t      \"4cb5a789047300e2\" \"cfc5c5450974cfc2\" \"448aeaaa7f43c374\"\n\t      \"c9a3b038b181f2d1\" \"0f1a2327fd2c087b\" \"a49bf1086969fd2c\"\n\t      \"d1df3fd69f81fa4b\" \"162cc8bbb363fc95\" \"b7b24b9c53d0c67e\"\n\t      \"f52b\", 16);\n  \n  mpz_set_str(pub.e, \"3f1a012d\", 16);\n\n  ASSERT (rsa_public_key_prepare(&pub));\n  \n  mpz_set_str(key.p,\n\t      \"0b73c990eeda0a2a\" \"2c26416052c85560\" \"0c5c0f5ce86a8326\"\n\t      \"166acea91786237a\" \"7ff884e66dbfdd3a\" \"ab9d9801414c1506\"\n\t      \"8b\", 16);\n  \n  mpz_set_str(key.q,\n\t      \"1b81c19a62802a41\" \"9c99283331b0badb\" \"08eb0c25ffce0fbf\"\n\t      \"50017850036f32f3\" \"2132a845b91a5236\" \"61f7b451d587383f\"\n\t      \"e1\", 16);\n  \n  mpz_set_str(key.a,\n\t      \"0a912fc93a6cca6b\" \"3521725a3065b3be\" \"3c9745e29c93303d\"\n\t      \"7d29316c6cafa4a2\" \"89945f964fcdea59\" \"1f9d248b0b6734be\"\n\t      \"c9\", 16);\n  \n  mpz_set_str(key.b,\n\t      \"1658eca933251813\" \"1eb19c77aba13d73\" \"e0b8f4ce986d7615\"\n\t      \"764c6b0b03c18146\" \"46b7f332c43e05c5\" \"351e09006979ca5b\"\n\t      \"05\", 16);\n  \n  mpz_set_str(key.c,\n\t      \"0114720dace7b27f\" \"2bf2850c1804869f\" \"79a0aad0ec02e6b4\"\n\t      \"05e1831619db2f10\" \"bb9b6a8fd5c95df2\" \"eb78f303ea0c0cc8\"\n\t      \"06\", 16);\n\n  ASSERT (rsa_private_key_prepare(&key));\n  ASSERT (pub.size == key.size);\n\n  /* Test md5 signatures */\n  mpz_set_str(expected,\n\t      \"011b939f6fbacf7f\" \"7d3217b022d07477\" \"e582e34d4bbddd4c\"\n\t      \"31520647417fc8a6\" \"18b2e196d799cedd\" \"d8f5c062fd796b0f\"\n\t      \"72ab46db2ac6ec74\" \"39d856be3f746cc4\" \"3e0a15429954736a\"\n\t      \"60a8b3c6ea93d2cb\" \"c69085c307d72517\" \"07d43bf97a3b51eb\"\n\t      \"9e89\", 16);\n\n  test_rsa_md5(&pub, &key, expected);\n\n  /* Test sha1 signature */\n  mpz_set_str(expected,\n\t      \"648c49e0ed045547\" \"08381d0bcd03b7bd\" \"b0f80a0e9030525d\"\n\t      \"234327a1c96b8660\" \"f1c01c6f15ae76d0\" \"4f53a53806b7e4db\"\n\t      \"1f789e6e89b538f6\" \"88fcbd2caa6abef0\" \"5432d52f3de463a4\"\n\t      \"a9e6de94f1b7bb68\" \"3c07edf0924fc93f\" \"56e1a0dba8f7491c\"\n\t      \"5c\", 16);\n\n  test_rsa_sha1(&pub, &key, expected);\n\n  mpz_set_str(expected,\n\t      \"d759bb28b4d249a2\" \"f8b67bdbb1ab7f50\" \"c88712fbcabc2956\"\n\t      \"1ec6ca3f8fdafe7a\" \"38433d7da287b8f7\" \"87857274c1640b2b\"\n\t      \"e652cd89c501d570\" \"3980a0af5c6bb60c\" \"f84feab25b099d06\"\n\t      \"e2519accb73dac43\" \"fb8bdad28835f3bd\" \"84c43678fe2ef41f\"\n\t      \"af\", 16);\n\n  test_rsa_sha256(&pub, &key, expected);\n\n  mpz_set_str(expected,\n\t      \"f761aae6273d6149\" \"06d8c208fb2897ca\" \"d798a46af4985b86\"\n\t      \"51d51e6a3e11cbe0\" \"84f18ba8979c0f54\" \"11493f7c6e770560\"\n\t      \"03db2146b4dbcaa6\" \"4aae2e02aab9ff7b\" \"1ddf77dc72145cf1\"\n\t      \"c26ebde7c708cdc1\" \"62e167a7ac33967b\" \"386a40ea4a988d17\"\n\t      \"47\", 16);\n\n  test_rsa_sha512(&pub, &key, expected);\n\n  rsa_private_key_clear(&key);\n  rsa_public_key_clear(&pub);\n  mpz_clear(expected);\n}",
      "lines": 181,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/rsa2sexp-test.c": {
    "test_main": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        105,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key priv;\n\n  struct nettle_buffer buffer;\n  \n  rsa_public_key_init(&pub);\n  rsa_private_key_init(&priv);\n\n  mpz_set_str(pub.n,\n\t      \"085c3408989acae4faec3cbbad91c90d34c1d259cd74121a\"\n\t      \"36f38b0b51424a9b2be514a04377113a6cdafe79dd7d5f2e\"\n\t      \"cc8b5e9661189b86a7b22239907c25\", 16);\n  mpz_set_str(pub.e, \"36ad4b1d\", 16);\n\n  ASSERT(rsa_public_key_prepare(&pub));\n  \n  mpz_set_str(priv.d,\n\t      \"06ee6d4ff3c239e408150daf8117abfa36a40ad4455d9059\"\n\t      \"a86d52f33a2de07418a0a699594588c64810248c9412d554\"\n\t      \"f74af947c73c32007e87c92f0937ed\", 16);\n\n  mpz_set_str(priv.p,\n\t      \"03259879b24315e9cf14254824c7935d807cdb6990f414a0\"\n\t      \"f65e6065130a611f\", 16);\n\n  mpz_set_str(priv.q,\n\t      \"02a81ba73bad45fc73b36deffce52d1b73e0747f4d8a8264\"\n\t      \"8cecd310448ea63b\", 16);\n\n  mpz_set_str(priv.a,\n\t      \"026cbdad5dd0046e093f060ecd5b4ac918e098b0278bb752\"\n\t      \"b7cadd6a8944f0b9\", 16);\n\n  mpz_set_str(priv.b,\n\t      \"0148751e622d6d58e3bb094afd6edacf7370351d068e2ce9\"\n\t      \"f565c5528c4a7473\", 16);\n\n  mpz_set_str(priv.c,\n\t      \"f8a458ea73a018dc6fa56863e3bc6de405f364f77dee6f09\"\n\t      \"62679ea1a8282e\", 16);\n\n  ASSERT(rsa_private_key_prepare(&priv));\n  \n  nettle_buffer_init(&buffer);\n  ASSERT(rsa_keypair_to_sexp(&buffer, \"rsa\", &pub, &priv));\n\n  if (verbose)\n    {\n      printf(\"private:\");\n      print_hex(buffer.size, buffer.contents);  \n    }\n  \n  ASSERT(MEMEQ(buffer.size, buffer.contents,\n\t       H(\"2831313a707269766174652d6b657928\"\n\t\t \"333a72736128313a6e36333a085c3408\"\n\t\t \"989acae4faec3cbbad91c90d34c1d259\"\n\t\t \"cd74121a36f38b0b51424a9b2be514a0\"\n\t\t \"4377113a6cdafe79dd7d5f2ecc8b5e96\"\n\t\t \"61189b86a7b22239907c252928313a65\"\n\t\t \"343a36ad4b1d2928313a6436333a06ee\"\n\t\t \"6d4ff3c239e408150daf8117abfa36a4\"\n\t\t \"0ad4455d9059a86d52f33a2de07418a0\"\n\t\t \"a699594588c64810248c9412d554f74a\"\n\t\t \"f947c73c32007e87c92f0937ed292831\"\n\t\t \"3a7033323a03259879b24315e9cf1425\"\n\t\t \"4824c7935d807cdb6990f414a0f65e60\"\n\t\t \"65130a611f2928313a7133323a02a81b\"\n\t\t \"a73bad45fc73b36deffce52d1b73e074\"\n\t\t \"7f4d8a82648cecd310448ea63b292831\"\n\t\t \"3a6133323a026cbdad5dd0046e093f06\"\n\t\t \"0ecd5b4ac918e098b0278bb752b7cadd\"\n\t\t \"6a8944f0b92928313a6233323a014875\"\n\t\t \"1e622d6d58e3bb094afd6edacf737035\"\n\t\t \"1d068e2ce9f565c5528c4a7473292831\"\n\t\t \"3a6333323a00f8a458ea73a018dc6fa5\"\n\t\t \"6863e3bc6de405f364f77dee6f096267\"\n\t\t \"9ea1a8282e292929\")));\n\n  nettle_buffer_clear(&buffer);\n  ASSERT(rsa_keypair_to_sexp(&buffer, NULL, &pub, NULL));\n\n  if (verbose)\n    {\n      printf(\"public:\");\n      print_hex(buffer.size, buffer.contents);  \n    }\n  ASSERT(MEMEQ(buffer.size, buffer.contents,\n\t       H(\"2831303a7075626c69632d6b65792839\"\n\t\t \"3a7273612d706b63733128313a6e3633\"\n\t\t \"3a085c3408989acae4faec3cbbad91c9\"\n\t\t \"0d34c1d259cd74121a36f38b0b51424a\"\n\t\t \"9b2be514a04377113a6cdafe79dd7d5f\"\n\t\t \"2ecc8b5e9661189b86a7b22239907c25\"\n\t\t \"2928313a65343a36ad4b1d292929\")));\n\n  nettle_buffer_clear(&buffer);\n  rsa_public_key_clear(&pub);\n  rsa_private_key_clear(&priv);\n}",
      "lines": 102,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/salsa20-test.c": {
    "memzero_p": {
      "start_point": [
        5,
        0
      ],
      "end_point": [
        13,
        1
      ],
      "content": "static int\nmemzero_p (const uint8_t *p, size_t n)\n{\n  size_t i;\n  for (i = 0; i < n; i++)\n    if (p[i])\n      return 0;\n  return 1;\n}",
      "lines": 9,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "test_salsa20_stream": {
      "start_point": [
        20,
        0
      ],
      "end_point": [
        118,
        1
      ],
      "content": "static void\ntest_salsa20_stream(const struct tstring *key,\n\t\t    const struct tstring *iv,\n\t\t    const struct tstring *ciphertext,\n\t\t    const struct tstring *xor_ref)\n{\n  struct salsa20_ctx ctx;\n  uint8_t data[STREAM_LENGTH + 1];\n  uint8_t stream[STREAM_LENGTH + 1];\n  uint8_t xor[SALSA20_BLOCK_SIZE];\n  size_t j;\n\n  ASSERT (iv->length == SALSA20_IV_SIZE);\n  ASSERT (ciphertext->length == 4*SALSA20_BLOCK_SIZE);\n  ASSERT (xor_ref->length == SALSA20_BLOCK_SIZE);\n\n  salsa20_set_key(&ctx, key->length, key->data);\n  salsa20_set_iv(&ctx, iv->data);\n  memset(stream, 0, STREAM_LENGTH + 1);\n  salsa20_crypt(&ctx, STREAM_LENGTH, stream, stream);\n  if (stream[STREAM_LENGTH])\n    {\n      fprintf(stderr, \"Stream of %d bytes wrote too much!\\n\", STREAM_LENGTH);\n      FAIL();\n    }\n  if (!MEMEQ (64, stream, ciphertext->data))\n    {\n      fprintf(stderr, \"Error failed, offset 0:\\n\");\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(64, stream);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(64, ciphertext->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  if (!MEMEQ (128, stream + 192, ciphertext->data + 64))\n    {\n      fprintf(stderr, \"Error failed, offset 192:\\n\");\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(128, stream + 192);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(64, ciphertext->data + 64);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  if (!MEMEQ (64, stream + 448, ciphertext->data + 192))\n    {\n      fprintf(stderr, \"Error failed, offset 448:\\n\");\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(64, stream + 448);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(64, ciphertext->data + 192);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  memxor3 (xor, stream, stream + SALSA20_BLOCK_SIZE, SALSA20_BLOCK_SIZE);\n  for (j = 2*SALSA20_BLOCK_SIZE; j < STREAM_LENGTH; j += SALSA20_BLOCK_SIZE)\n    memxor (xor, stream + j, SALSA20_BLOCK_SIZE);\n\n  if (!MEMEQ (SALSA20_BLOCK_SIZE, xor, xor_ref->data))\n    {\n      fprintf(stderr, \"Error failed, bad xor 448:\\n\");\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(SALSA20_BLOCK_SIZE, xor);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(SALSA20_BLOCK_SIZE, xor_ref->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  for (j = 1; j <= STREAM_LENGTH; j++)\n    {\n      memset(data, 0, STREAM_LENGTH + 1);\n      salsa20_set_iv(&ctx, iv->data);\n      salsa20_crypt(&ctx, j, data, data);\n\n      if (!MEMEQ(j, data, stream))\n\t{\n\t  fprintf(stderr, \"Encrypt failed for length %lu:\\n\",\n\t\t  (unsigned long) j);\n\t  fprintf(stderr, \"\\nOutput: \");\n\t  print_hex(j, data);\n\t  fprintf(stderr, \"\\nExpected:\");\n\t  print_hex(j, stream);\n\t  fprintf(stderr, \"\\n\");\n\t  FAIL();\n\t}\n      if (!memzero_p (data + j, STREAM_LENGTH + 1 - j))\n\t{\n\t  fprintf(stderr, \"Encrypt failed for length %lu, wrote too much:\\n\",\n\t\t  (unsigned long) j);\n\t  fprintf(stderr, \"\\nOutput: \");\n\t  print_hex(STREAM_LENGTH + 1 - j, data + j);\n\t  fprintf(stderr, \"\\n\");\n\t  FAIL();\n\t}\n    }\n}",
      "lines": 99,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "_test_salsa20": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        181,
        1
      ],
      "content": "static void\n_test_salsa20(salsa20_func *crypt,\n\t      const struct tstring *key,\n\t      const struct tstring *iv,\n\t      const struct tstring *cleartext,\n\t      const struct tstring *ciphertext)\n{\n  struct salsa20_ctx ctx;\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (iv->length == SALSA20_IV_SIZE);\n\n  data = xalloc(length + 1);\n\n  salsa20_set_key(&ctx, key->length, key->data);\n  salsa20_set_iv(&ctx, iv->data);\n  data[length] = 17;\n  crypt(&ctx, length, data, cleartext->data);\n  if (data[length] != 17)\n    {\n      fprintf(stderr, \"Encrypt of %lu bytes wrote too much!\\nInput:\",\n\t      (unsigned long) length);\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  salsa20_set_key(&ctx, key->length, key->data);\n  salsa20_set_iv(&ctx, iv->data);\n  crypt(&ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 59,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        190,
        0
      ],
      "end_point": [
        307,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/reduced/12-rounds/verified.test-vectors?logsort=rev&rev=210&view=markup */\n  test_salsa20r12(SHEX(\"80000000 00000000 00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"FC207DBF C76C5E17\"));\n\n  test_salsa20r12(SHEX(\"00400000 00000000 00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"6C11A3F9 5FEC7F48\"));\n\n  test_salsa20r12(SHEX(\"09090909090909090909090909090909\"),\n\t\t  SHEX(\"0000000000000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"78E11FC3 33DEDE88\"));\n\n  test_salsa20r12(SHEX(\"1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B1B\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"A6747461 1DF551FF\"));\n\n  test_salsa20r12(SHEX(\"80000000000000000000000000000000\"\n\t\t       \"00000000000000000000000000000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"AFE411ED 1C4E07E4\"));\n\n  test_salsa20r12(SHEX(\"0053A6F94C9FF24598EB3E91E4378ADD\"\n\t\t       \"3083D6297CCF2275C81B6EC11467BA0D\"),\n\t\t  SHEX(\"0D74DB42A91077DE\"),\n\t\t  SHEX(\"00000000 00000000\"),\n\t\t  SHEX(\"52E20CF8 775AE882\"));\n\n  /* http://www.ecrypt.eu.org/stream/svn/viewcvs.cgi/ecrypt/trunk/submissions/salsa20/full/verified.test-vectors?logsort=rev&rev=210&view=markup */\n\n  test_salsa20(SHEX(\"80000000 00000000 00000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"4DFA5E48 1DA23EA0\"));\n\n  test_salsa20(SHEX(\"00000000 00000000 00000000 00000000\"),\n\t       SHEX(\"80000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"B66C1E44 46DD9557\"));\n\n  test_salsa20(SHEX(\"0053A6F94C9FF24598EB3E91E4378ADD\"),\n\t       SHEX(\"0D74DB42A91077DE\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"05E1E7BE B697D999\"));\n\n  test_salsa20(SHEX(\"80000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"E3BE8FDD 8BECA2E3\"));\n\n  test_salsa20(SHEX(\"00000000 00000000 00000000 00000000\"\n\t\t    \"00000000 00000000 00000000 00000000\"),\n\t       SHEX(\"80000000 00000000\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"2ABA3DC45B494700\"));\n\n  test_salsa20(SHEX(\"0053A6F94C9FF24598EB3E91E4378ADD\"\n\t\t    \"3083D6297CCF2275C81B6EC11467BA0D\"),\n\t       SHEX(\"0D74DB42A91077DE\"),\n\t       SHEX(\"00000000 00000000\"),\n\t       SHEX(\"F5FAD53F 79F9DF58\"));\n\n  test_salsa20_stream(SHEX(\"80000000000000000000000000000000\"),\n\t\t      SHEX(\"00000000 00000000\"),\n\t\t      SHEX(\"4DFA5E481DA23EA09A31022050859936\"\n\t\t\t   \"DA52FCEE218005164F267CB65F5CFD7F\"\n\t\t\t   \"2B4F97E0FF16924A52DF269515110A07\"\n\t\t\t   \"F9E460BC65EF95DA58F740B7D1DBB0AA\"\n\t\t\t   \"DA9C1581F429E0A00F7D67E23B730676\"\n\t\t\t   \"783B262E8EB43A25F55FB90B3E753AEF\"\n\t\t\t   \"8C6713EC66C51881111593CCB3E8CB8F\"\n\t\t\t   \"8DE124080501EEEB389C4BCB6977CF95\"\n\t\t\t   \"7D5789631EB4554400E1E025935DFA7B\"\n\t\t\t   \"3E9039D61BDC58A8697D36815BF1985C\"\n\t\t\t   \"EFDF7AE112E5BB81E37ECF0616CE7147\"\n\t\t\t   \"FC08A93A367E08631F23C03B00A8DA2F\"\n\t\t\t   \"B375703739DACED4DD4059FD71C3C47F\"\n\t\t\t   \"C2F9939670FAD4A46066ADCC6A564578\"\n\t\t\t   \"3308B90FFB72BE04A6B147CBE38CC0C3\"\n\t\t\t   \"B9267C296A92A7C69873F9F263BE9703\"),\n\t\t      SHEX(\"F7A274D268316790A67EC058F45C0F2A\"\n\t\t\t   \"067A99FCDE6236C0CEF8E056349FE54C\"\n\t\t\t   \"5F13AC74D2539570FD34FEAB06C57205\"\n\t\t\t   \"3949B59585742181A5A760223AFA22D4\"));\n\n  test_salsa20_stream(SHEX(\"48494A4B4C4D4E4F5051525354555657\"\n\t\t\t   \"58595A5B5C5D5E5F6061626364656667\"),\n\t\t      SHEX(\"0000000000000000\"),\n\t\t      SHEX(\"53AD3698A011F779AD71030F3EFBEBA0\"\n\t\t\t   \"A7EE3C55789681B1591EF33A7BE521ED\"\n\t\t\t   \"68FC36E58F53FFD6E1369B00E390E973\"\n\t\t\t   \"F656ACB097E0D603BE59A0B8F7975B98\"\n\t\t\t   \"A04698274C6AC6EC03F66ED3F94C08B7\"\n\t\t\t   \"9FFDBF2A1610E6F5814905E73AD6D0D2\"\n\t\t\t   \"8164EEB8450D8ED0BB4B644761B43512\"\n\t\t\t   \"52DD5DDF00C31E3DABA0BC17691CCFDC\"\n\t\t\t   \"B826C7F071E796D34E3BFFB3C96E76A1\"\n\t\t\t   \"209388392806947C7F19B86D379FA3AE\"\n\t\t\t   \"DFCD19EBF49803DACC6E577E5B97B0F6\"\n\t\t\t   \"D2036B6624D8196C96FCF02C865D30C1\"\n\t\t\t   \"B505D41E2C207FA1C0A0E93413DDCFFC\"\n\t\t\t   \"9BECA8030AFFAC2466E56482DA0EF428\"\n\t\t\t   \"E63880B5021D3051F18679505A2B9D4F\"\n\t\t\t   \"9B2C5A2D271D276DE3F51DBEBA934436\"),\n\t\t      SHEX(\"7849651A820B1CDFE36D5D6632716534\"\n\t\t\t   \"E0635EDEFD538122D80870B60FB055DB\"\n\t\t\t   \"637C7CA2B78B116F83AFF46E40F8F71D\"\n\t\t\t   \"4CD6D2E1B750D5E011D1DF2E80F7210A\"));\n}",
      "lines": 118,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/serpent-test.c": {
    "tstring_hex_reverse": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        20,
        1
      ],
      "content": "static const struct tstring *\ntstring_hex_reverse (const char *hex)\n{\n  struct tstring *s = tstring_hex (hex);\n  uint8_t *p;\n  size_t length, i;\n\n  length = s->length;\n  p = s->data;\n\n  for (i = 0; i < (length+1)/2; i++)\n    {\n      uint8_t t = p[i];\n      p[i] = p[length - 1 - i];\n      p[length - 1 - i] = t;\n    }\n  return s;\n}",
      "lines": 18,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "const",
        "const",
        "struct tstring",
        "struct",
        "tstring",
        "*\ntstring_hex_reverse (const char *hex)",
        "*"
      ]
    },
    "test_serpent": {
      "start_point": [
        25,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\ntest_serpent(const struct tstring *key,\n\t     const struct tstring *cleartext,\n\t     const struct tstring *ciphertext)\n{\n  struct serpent_ctx ctx;\n  uint8_t *data = xalloc(cleartext->length);\n  size_t length;\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  serpent_set_key(&ctx, key->length, key->data);\n  serpent_encrypt(&ctx, length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  serpent_set_key(&ctx, key->length, key->data);\n  serpent_decrypt(&ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(data);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        328,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From libgcrypt */\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"0000000000000000 0000000000000000\"),\n\t      SHEX(\"D29D576FCEA3A3A7 ED9099F29273D78E\"),\n\t      SHEX(\"B2288B968AE8B086 48D1CE9606FD992D\"));\n  test_cipher(&nettle_serpent192,\n\t      SHEX(\"0000000000000000 0000000000000000 0000000000000000\"),\n\t      SHEX(\"D29D576FCEABA3A7 ED9899F2927BD78E\"),\n\t      SHEX(\"130E353E1037C224 05E8FAEFB2C3C3E9\"));\n  test_cipher(&nettle_serpent256,\n\t      SHEX(\"0000000000000000 0000000000000000\"\n\t\t   \"0000000000000000 0000000000000000\"),\n\t      SHEX(\"D095576FCEA3E3A7 ED98D9F29073D78E\"),\n\t      SHEX(\"B90EE5862DE69168 F2BDD5125B45472B\"));\n  test_cipher(&nettle_serpent256,\n\t      SHEX(\"0000000000000000 0000000000000000\"\n\t\t   \"0000000000000000 0000000000000000\"),\n\t      SHEX(\"0000000001000000 0200000003000000\"),\n\t      SHEX(\"2061A42782BD52EC 691EC383B03BA77C\"));\n\n  /* The first test for each key size from the ecb_vk.txt and ecb_vt.txt\n   * files in the serpent package. */\n\n  /* NOTE: These vectors uses strange byte-reversed order of inputs\n     and outputs. */\n  /* 128 bit key */\n\n  /* vk, 1 */\n  test_cipher(&nettle_serpent128,\n\t      RHEX(\"8000000000000000 0000000000000000\"),\n\t      RHEX(\"0000000000000000 0000000000000000\"),\n\t      RHEX(\"49AFBFAD9D5A3405 2CD8FFA5986BD2DD\"));\n\n  /* vt, 1 */\n  test_cipher(&nettle_serpent128,\n\t      RHEX(\"0000000000000000 0000000000000000\"),\n\t      RHEX(\"8000000000000000 0000000000000000\"),\n\t      RHEX(\"10B5FFB720B8CB90 02A1142B0BA2E94A\"));\n\n  /* 192 bit key */\n\n  /* vk, 1 */\n  test_cipher(&nettle_serpent192,\n\t      RHEX(\"8000000000000000 0000000000000000\"\n\t\t   \"0000000000000000\"),\n\t      RHEX(\"0000000000000000 0000000000000000\"),\n\t      RHEX(\"E78E5402C7195568 AC3678F7A3F60C66\"));\n\n  /* vt, 1 */\n  test_cipher(&nettle_serpent192,\n\t      RHEX(\"0000000000000000 0000000000000000\"\n\t\t   \"0000000000000000\"),\n\t      RHEX(\"8000000000000000 0000000000000000\"),\n\t      RHEX(\"B10B271BA25257E1 294F2B51F076D0D9\"));\n\n  /* 256 bit key */\n\n  /* vk, 1 */\n  test_cipher(&nettle_serpent256,\n\t      RHEX(\"8000000000000000 0000000000000000\"\n\t\t   \"0000000000000000 0000000000000000\"),\n\t      RHEX(\"0000000000000000 0000000000000000\"),\n\t      RHEX(\"ABED96E766BF28CB C0EBD21A82EF0819\"));\n\n  /* vt, 1 */\n  test_cipher(&nettle_serpent256,\n\t      RHEX(\"0000000000000000 0000000000000000\"\n\t\t   \"0000000000000000 0000000000000000\"),\n\t      RHEX(\"8000000000000000 0000000000000000\"),\n\t      RHEX(\"DA5A7992B1B4AE6F 8C004BC8A7DE5520\"));\n\n  /* Test vectors from\n     http://www.cs.technion.ac.il/~biham/Reports/Serpent/ */\n\n  /* serpent128 */\n  /* Set 4, vector#  0 */\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"000102030405060708090A0B0C0D0E0F\"),\n\t      SHEX(\"00112233445566778899AABBCCDDEEFF\"),\n\t      SHEX(\"563E2CF8740A27C164804560391E9B27\"));\n\n  /* Set 4, vector#  1 */\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"2BD6459F82C5B300952C49104881FF48\"),\n\t      SHEX(\"EA024714AD5C4D84EA024714AD5C4D84\"),\n\t      SHEX(\"92D7F8EF2C36C53409F275902F06539F\"));\n\n  /* serpent192 */\n  /* Set 4, vector#  0 */\n  test_cipher(&nettle_serpent192,\n\t      SHEX(\"000102030405060708090A0B0C0D0E0F1011121314151617\"),\n\t      SHEX(\"00112233445566778899AABBCCDDEEFF\"),\n\t      SHEX(\"6AB816C82DE53B93005008AFA2246A02\"));\n\n  /* Set 4, vector#  1 */\n  test_cipher(&nettle_serpent192,\n\t      SHEX(\"2BD6459F82C5B300952C49104881FF482BD6459F82C5B300\"),\n\t      SHEX(\"EA024714AD5C4D84EA024714AD5C4D84\"),\n\t      SHEX(\"827B18C2678A239DFC5512842000E204\"));\n\n  /* serpent256 */\n  /* Set 4, vector#  0 */\n  test_cipher(&nettle_serpent256,\n\t      SHEX(\"000102030405060708090A0B0C0D0E0F\"\n\t\t   \"101112131415161718191A1B1C1D1E1F\"),\n\t      SHEX(\"00112233445566778899AABBCCDDEEFF\"),\n\t      SHEX(\"2868B7A2D28ECD5E4FDEFAC3C4330074\"));\n\n  /* Set 4, vector#  1 */\n  test_cipher(&nettle_serpent256,\n\t      SHEX(\"2BD6459F82C5B300952C49104881FF48\"\n\t\t   \"2BD6459F82C5B300952C49104881FF48\"),\n\t      SHEX(\"EA024714AD5C4D84EA024714AD5C4D84\"),\n\t      SHEX(\"3E507730776B93FDEA661235E1DD99F0\"));\n\n  /* Test key padding. We use nettle_serpent256, which actually works\n     also with key sizes smaller than 32 bytes. */\n  test_cipher(&nettle_serpent256,\n\t      SHEX(\"00112233440100000000000000000000\"\n\t\t   \"00000000000000000000000000000000\"),\n\t      SHEX(\"0000000001000000 0200000003000000\"),\n\t      SHEX(\"C1415AC653FD7C7F D917482EE8EBFE25\"));\n\n  /* Tests with various key sizes. Currrently, key sizes smaller than\n     SERPENT_MIN_KEY_SIZE bytes (128 bits) are not publicly\n     supported. */\n  test_serpent(SHEX(\"0011223344\"),\n\t       SHEX(\"0000000001000000 0200000003000000\"),\n\t       SHEX(\"C1415AC653FD7C7F D917482EE8EBFE25\"));\n\n  test_serpent(SHEX(\"00112233445566778899aabbccddeeff\"\n\t\t    \"00010000000000000000000000000000\"),\n\t       SHEX(\"0000000001000000 0200000003000000\"),\n\t       SHEX(\"8EB9C958EAFFDF42 009755D7B6458838\"));\n\n  test_serpent(SHEX(\"00112233445566778899aabbccddeeff\"\n\t\t    \"00\"),\n\t       SHEX(\"0000000001000000 0200000003000000\"),\n\t       SHEX(\"8EB9C958EAFFDF42 009755D7B6458838\"));\n\n  test_serpent(SHEX(\"00112233445566778899aabbccddeeff\"\n\t\t    \"00112201000000000000000000000000\"),\n\t       SHEX(\"0000000001000000 0200000003000000\"),\n\t       SHEX(\"C8A078D8212AC96D 9060E30EC5CBB5C7\"));\n\n  test_serpent(SHEX(\"00112233445566778899aabbccddeeff\"\n\t\t    \"001122\"),\n\t       SHEX(\"0000000001000000 0200000003000000\"),\n\t       SHEX(\"C8A078D8212AC96D 9060E30EC5CBB5C7\"));\n\n  /* Test with multiple blocks. */\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"91c8e949e12f0e38 7b2473238a3df1b6\"),\n\t      SHEX(\"00000000 00000001 00000002 00000003\"\n\t\t   \"00000004 00000005 00000006 00000007\"\n\t\t   \"00000008 00000009 0000000a 0000000b\"\n\t\t   \"0000000c 0000000d 0000000e 0000000f\"),\n\t      SHEX(\"2db9f0a39d4f31a4 b1a83cd1032fe1bd\"\n\t\t   \"3606caa84a220b1b f6f43ff80a831203\"\n\t\t   \"8c6c8d2793dc10b3 904d30e194f086a6\"\n\t\t   \"b2f3e932b9b3f8d1 d4d074f7bd1ff7a3\"));\n\t      \n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"\n\t\t   \"672eadf1624a2ed0 c42d1b08b076f75a\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"\n\t\t   \"30ac8c52697102ae 3b725dba79ceb250\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"\n\t\t   \"672eadf1624a2ed0 c42d1b08b076f75a\"\n\t\t   \"7378272aa57ad7c8 803e326689541266\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"\n\t\t   \"30ac8c52697102ae 3b725dba79ceb250\"\n\t\t   \"d308b83478e86dbb 629f18736cca042f\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"\n\t\t   \"672eadf1624a2ed0 c42d1b08b076f75a\"\n\t\t   \"7378272aa57ad7c8 803e326689541266\"\n\t\t   \"b7a2efda5721776f 4113d63a702ac3ae\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"\n\t\t   \"30ac8c52697102ae 3b725dba79ceb250\"\n\t\t   \"d308b83478e86dbb 629f18736cca042f\"\n\t\t   \"006b89e494469adf 0ee78c60684dff86\"));\n    \n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"\n\t\t   \"672eadf1624a2ed0 c42d1b08b076f75a\"\n\t\t   \"7378272aa57ad7c8 803e326689541266\"\n\t\t   \"b7a2efda5721776f 4113d63a702ac3ae\"\n\t\t   \"cd1be7bbfad74819 644617f8656e9e5b\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"\n\t\t   \"30ac8c52697102ae 3b725dba79ceb250\"\n\t\t   \"d308b83478e86dbb 629f18736cca042f\"\n\t\t   \"006b89e494469adf 0ee78c60684dff86\"\n\t\t   \"5f2c99908ee77ffe aea3d30cb78a1ce1\"));\n\n  test_cipher(&nettle_serpent128,\n\t      SHEX(\"e87450aa0fd87293fd0371483a459bd2\"),\n\t      SHEX(\"a78a7a8d392f629d bd13674c8dce6fa2\"\n\t\t   \"930c74dec02a11d8 c80d90b5e5c887a7\"\n\t\t   \"83c92a921b5b2028 d9cb313a5f07ab09\"\n\t\t   \"672eadf1624a2ed0 c42d1b08b076f75a\"\n\t\t   \"7378272aa57ad7c8 803e326689541266\"\n\t\t   \"b7a2efda5721776f 4113d63a702ac3ae\"\n\t\t   \"cd1be7bbfad74819 644617f8656e9e5b\"\n\t\t   \"34d449409c1f850a 4cb6700d6ef3405f\"),\n\t      SHEX(\"b3d488986c80dea7 c5ebdab4907871c9\"\n\t\t   \"a4b92b13b79afb37 5518b01bfd706a37\"\n\t\t   \"8e44c2d463df4531 165461699edbad03\"\n\t\t   \"30ac8c52697102ae 3b725dba79ceb250\"\n\t\t   \"d308b83478e86dbb 629f18736cca042f\"\n\t\t   \"006b89e494469adf 0ee78c60684dff86\"\n\t\t   \"5f2c99908ee77ffe aea3d30cb78a1ce1\"\n\t\t   \"ebe855dd51532477 4d2d55969e032e6c\"));\n}",
      "lines": 261,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sexp-format-test.c": {
    "test_main": {
      "start_point": [
        9,
        0
      ],
      "end_point": [
        165,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct nettle_buffer buffer;\n\n  {\n    const char e[] = \"(3:foo(3:bar17:xxxxxxxxxxxxxxxxx))\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_format(&buffer, \"(%0s(%0s%0s))\",\n\t\t       \"foo\", \"bar\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(sexp_format(NULL, \"(%0s(%0s%0s))\",\n\t\t       \"foo\", \"bar\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n  {\n    const char e[] = \"{KDM6Zm9vKDM6YmFyMTc6eHh4eHh4eHh4eHh4eHh4eHgpKQ==}\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_transport_format(&buffer, \"(%0s(%0s%0s))\",\n\t\t       \"foo\", \"bar\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(sexp_transport_format(NULL, \"(%0s(%0s%0s))\",\n\t\t\t\t \"foo\", \"bar\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n  {\n    const char e[] = \"1:\\0\"\"1:a2:bc3:def4:ghij5:\\x00\\xDE\\xAD\\xBE\\xEF\";\n\n    nettle_buffer_init(&buffer);  \n    ASSERT(sexp_format(&buffer, \"%i%i%i%i%i%i\",\n\t\t       0, 0x61, 0x6263, 0x646566, 0x6768696a, 0xDEADBEEF)\n\t   == LLENGTH(e));\n    \n    ASSERT(buffer.size == LLENGTH(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n\n  {\n    const char e[] = \"(3:foo(4:bar))\";\n    \n    nettle_buffer_init(&buffer);  \n    ASSERT(sexp_format(&buffer, \"(%0s%l)\",\n\t\t       \"foo\", (size_t) 7, \"(4:bar)\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n\n  {\n    const char e[] = \"([1:t]3:foo3:bar[6:gazonk]3:baz1:q)\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_format(&buffer, \"(%0t%0s%0s%0t%0s%0t%0s)\",\n\t\t       \"t\", \"foo\", \"bar\", \"gazonk\", \"baz\", NULL, \"q\")\n\t   == strlen(e));\n\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n\n  /* Try literals */\n  {\n    const char e[] = \"(3:foo(3:bar17:xxxxxxxxxxxxxxxxx))\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_format(&buffer, \"(%0s(bar%0s))\",\n\t\t       \"foo\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(sexp_format(NULL, \"(%0s(bar %0s))\",\n\t\t       \"foo\", \"xxxxxxxxxxxxxxxxx\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n  {\n    const char e[] = \"(3:foo(3:bar17:xxxxxxxxxxxxxxxxx))\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_format(&buffer, \"(%0s(bar xxxxxxxxxxxxxxxxx))\",\n\t\t       \"foo\")\n\t   == strlen(e));\n    \n    ASSERT(sexp_format(NULL, \"(%0s(bar xxxxxxxxxxxxxxxxx))\",\n\t\t       \"foo\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n\n  /* Literal parenthesis */\n  {\n    const char e[] = \")3:foo(3:bar\";\n\n    nettle_buffer_init(&buffer);\n    ASSERT(sexp_format(&buffer, \"%)foo%(%s\", (size_t) 3, \"bar\")\n\t   == strlen(e));\n    \n    ASSERT(sexp_format(NULL, \"%)foo%(%s\", (size_t) 3, \"bar\")\n\t   == strlen(e));\n    \n    ASSERT(buffer.size == strlen(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n    nettle_buffer_clear(&buffer);\n  }\n  \n#if WITH_HOGWEED\n  {\n    mpz_t x;\n    mpz_t y;\n    mpz_t z;\n    \n    const char e[] =\n      \"(3:foo(3:bar1:\\xff\"\"11:abcdefghijk13:\\0\\x81\"\"abcdefghijk))\";\n\n    mpz_init_set_si(x, -1);\n    nettle_mpz_init_set_str_256_u(y, 11, US(\"abcdefghijk\"));\n    nettle_mpz_init_set_str_256_u(z, 12, US(\"\\x81\"\"abcdefghijk\"));\n    nettle_buffer_init(&buffer);\n\n    ASSERT(sexp_format(&buffer, \"(%0s(%0s%b%b%b))\",\n\t\t     \"foo\", \"bar\", x, y, z)\n\t   == LLENGTH(e));\n\n    ASSERT(sexp_format(NULL, \"(%0s(%0s%b%b%b))\",\n\t\t     \"foo\", \"bar\", x, y, z)\n\t   == LLENGTH(e));\n    \n    ASSERT(buffer.size == LLENGTH(e));\n    ASSERT(MEMEQ(buffer.size, buffer.contents, e));\n\n    nettle_buffer_clear(&buffer);\n    mpz_clear(x);\n    mpz_clear(y);\n    mpz_clear(z);\n  }\n#endif /* WITH_HOGWEED */\n}",
      "lines": 157,
      "depth": 12,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sexp-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        99,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct sexp_iterator i;\n  uint32_t x;\n  \n  ASSERT(sexp_iterator_first(&i, LDATA(\"\")));\n  ASSERT(i.type == SEXP_END);\n\n  ASSERT(sexp_iterator_first(&i, LDATA(\"()\")));\n  ASSERT(i.type == SEXP_LIST\n\t && sexp_iterator_enter_list(&i)\n\t && i.type == SEXP_END\n\t && sexp_iterator_exit_list(&i)\n\t && i.type == SEXP_END);\n\n  ASSERT(sexp_iterator_first(&i, LDATA(\"(\")));\n  ASSERT(i.type == SEXP_LIST\n\t && !sexp_iterator_enter_list(&i));\n\n  /* Check integers. */\n  ASSERT(sexp_iterator_first(&i, LDATA(\"1:\\0\"\n\t\t\t\t       \"1:\\x11\"\n\t\t\t\t       \"2:\\x00\\x11\"\n\t\t\t\t       \"2:\\x00\\x80\"\n\t\t\t\t       \"5:\\x00\\xaa\\xbb\\xcc\\xdd\")));\n  ASSERT(sexp_iterator_get_uint32(&i, &x) && x == 0);\n  ASSERT(sexp_iterator_get_uint32(&i, &x) && x == 0x11);\n  ASSERT(sexp_iterator_get_uint32(&i, &x) && x == 0x11);\n  ASSERT(sexp_iterator_get_uint32(&i, &x) && x == 0x80);\n  ASSERT(sexp_iterator_get_uint32(&i, &x) && x == 0xaabbccdd);\n\n  ASSERT(sexp_iterator_first(&i, LDATA(\"3:foo0:[3:bar]12:xxxxxxxxxxxx\")));\n  ASSERT(i.type == SEXP_ATOM\n\t && !i.display_length && !i.display\n\t && i.atom_length == 3 && MEMEQ(3, \"foo\", i.atom)\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_ATOM\n\t && !i.display_length && !i.display\n\t && !i.atom_length && i.atom\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_ATOM\n\t && i.display_length == 3 && MEMEQ(3, \"bar\", i.display)\n\t && i.atom_length == 12 && MEMEQ(12, \"xxxxxxxxxxxx\", i.atom)\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_END);\n  \n  /* Same data, transport encoded. */\n\n  {\n    struct tstring *s\n      = tstring_data(LDATA(\"{Mzpmb28=} {MDo=} {WzM6YmFyXTEyOnh4eHh4eHh4eHh4eA==}\"));\n  ASSERT(sexp_transport_iterator_first (&i, s->length, s->data));\n  ASSERT(i.type == SEXP_ATOM\n\t && !i.display_length && !i.display\n\t && i.atom_length == 3 && MEMEQ(3, \"foo\", i.atom)\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_ATOM\n\t && !i.display_length && !i.display\n\t && !i.atom_length && i.atom\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_ATOM\n\t && i.display_length == 3 && MEMEQ(3, \"bar\", i.display)\n\t && i.atom_length == 12 && MEMEQ(12, \"xxxxxxxxxxxx\", i.atom)\n\n\t && sexp_iterator_next(&i) && i.type == SEXP_END);\n\n  }\n  {\n    static const char * const keys[2] = { \"n\", \"e\" };\n    struct sexp_iterator v[2];\n    \n    ASSERT(sexp_iterator_first(&i, LDATA(\"((1:n2:xx3:foo)0:(1:y)(1:e))\")));\n    ASSERT(sexp_iterator_enter_list(&i)\n\t   && sexp_iterator_assoc(&i, 2, keys, v));\n\n    ASSERT(v[0].type == SEXP_ATOM\n\t   && !v[0].display_length && !v[0].display\n\t   && v[0].atom_length == 2 && MEMEQ(2, \"xx\", v[0].atom)\n\n\t   && sexp_iterator_next(&v[0]) && v[0].type == SEXP_ATOM\n\t   && !v[0].display_length && !v[0].display\n\t   && v[0].atom_length == 3 && MEMEQ(3, \"foo\", v[0].atom)\n\n\t   && sexp_iterator_next(&v[0]) && v[0].type == SEXP_END);\n\n    ASSERT(v[1].type == SEXP_END);\n\n    ASSERT(sexp_iterator_first(&i, LDATA(\"((1:n))\")));\n    ASSERT(sexp_iterator_enter_list(&i)\n\t   && !sexp_iterator_assoc(&i, 2, keys, v));\n\n    ASSERT(sexp_iterator_first(&i, LDATA(\"((1:n)(1:n3:foo))\")));\n    ASSERT(sexp_iterator_enter_list(&i)\n\t   && !sexp_iterator_assoc(&i, 2, keys, v));    \n  }\n}",
      "lines": 97,
      "depth": 27,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sexp2rsa-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        43,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key priv;\n  const struct tstring *sexp;\n\n  rsa_public_key_init(&pub);\n  rsa_private_key_init(&priv);\n\n  sexp = SHEX(\"2831313a707269766174652d6b657928\"\n\t\t\"333a72736128313a6e36333a085c3408\"\n\t\t\"989acae4faec3cbbad91c90d34c1d259\"\n\t\t\"cd74121a36f38b0b51424a9b2be514a0\"\n\t\t\"4377113a6cdafe79dd7d5f2ecc8b5e96\"\n\t\t\"61189b86a7b22239907c252928313a65\"\n\t\t\"343a36ad4b1d2928313a6436333a06ee\"\n\t\t\"6d4ff3c239e408150daf8117abfa36a4\"\n\t\t\"0ad4455d9059a86d52f33a2de07418a0\"\n\t\t\"a699594588c64810248c9412d554f74a\"\n\t\t\"f947c73c32007e87c92f0937ed292831\"\n\t\t\"3a7033323a03259879b24315e9cf1425\"\n\t\t\"4824c7935d807cdb6990f414a0f65e60\"\n\t\t\"65130a611f2928313a7133323a02a81b\"\n\t\t\"a73bad45fc73b36deffce52d1b73e074\"\n\t\t\"7f4d8a82648cecd310448ea63b292831\"\n\t\t\"3a6133323a026cbdad5dd0046e093f06\"\n\t\t\"0ecd5b4ac918e098b0278bb752b7cadd\"\n\t\t\"6a8944f0b92928313a6233323a014875\"\n\t\t\"1e622d6d58e3bb094afd6edacf737035\"\n\t\t\"1d068e2ce9f565c5528c4a7473292831\"\n\t\t\"3a6333323a00f8a458ea73a018dc6fa5\"\n\t\t\"6863e3bc6de405f364f77dee6f096267\"\n\t      \"9ea1a8282e292929\");\n  ASSERT(rsa_keypair_from_sexp\n\t (&pub, &priv, 0, sexp->length, sexp->data));\n\n  test_rsa_key(&pub, &priv);\n\n  rsa_public_key_clear(&pub);\n  rsa_private_key_clear(&priv);\n}",
      "lines": 42,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha1-huge-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        11,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Hashes 10 000 000 x 30 000 bytes > 64 * 2^32. This overflows the\n     low word of the block counter. This test vector is not cross\n     checked with any other sha1 implementation. */\n  test_hash_large(&nettle_sha1, 10000000, 30000, 'a',\n\t\t  SHEX(\"0ba79364dc64648f 2074fb4bc5c28bcf\"\n\t\t       \"b7a787b0\"));\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha1-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        33,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_sha1, SDATA(\"\"),\n\t    SHEX(\"DA39A3EE5E6B4B0D 3255BFEF95601890 AFD80709\")); \n\n  test_hash(&nettle_sha1, SDATA(\"a\"),\n\t    SHEX(\"86F7E437FAA5A7FC E15D1DDCB9EAEAEA 377667B8\")); \n\n  test_hash(&nettle_sha1, SDATA(\"abc\"),\n\t    SHEX(\"A9993E364706816A BA3E25717850C26C 9CD0D89D\"));\n  \n  test_hash(&nettle_sha1, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"32D10C7B8CF96570 CA04CE37F2A19D84 240D3A89\"));\n  \n  test_hash(&nettle_sha1, SDATA(\"message digest\"),\n\t    SHEX(\"C12252CEDA8BE899 4D5FA0290A47231C 1D16AAE3\")); \n\n  test_hash(&nettle_sha1,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"761C457BF73B14D2 7E9E9265C46F4B4D DA11F940\"));\n  \n  test_hash(&nettle_sha1,\n\t    SDATA(\"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"),\n\t    SHEX(\"50ABF5706A150990 A08B2C5EA40FA0E5 85554732\"));\n\n  /* Additional test vector, from Daniel Kahn Gillmor */\n  test_hash(&nettle_sha1, SDATA(\"38\"),\n\t    SHEX(\"5b384ce32d8cdef02bc3a139d4cac0a22bb029e8\"));\n}",
      "lines": 32,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha224-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        44,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From FIPS180-2 addendum\n     (http://csrc.nist.gov/publications/fips/fips180-2/fips180-2withchangenotice.pdf) */\n  test_hash(&nettle_sha224, SDATA(\"abc\"),\n\t    SHEX(\"23097d22 3405d822 8642a477 bda255b3\"\n\t\t \"2aadbce4 bda0b3f7 e36c9da7\"));\n\n  test_hash(&nettle_sha224,\n\t    SDATA(\"abcdbcdecdefdefgefghfghighij\"\n\t\t  \"hijkijkljklmklmnlmnomnopnopq\"),\n\t    SHEX(\"75388b16 512776cc 5dba5da1 fd890150\"\n\t\t \"b0c6455c b4f58b19 52522525\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  test_hash(&nettle_sha224, SDATA(\"\"),\n\t    SHEX(\"d14a028c2a3a2bc9 476102bb288234c4\"\n\t\t \"15a2b01f828ea62a c5b3e42f\"));\n  test_hash(&nettle_sha224, SDATA(\"a\"),\n\t    SHEX(\"abd37534c7d9a2ef b9465de931cd7055\"\n\t\t \"ffdb8879563ae980 78d6d6d5\"));\n  test_hash(&nettle_sha224, SDATA(\"38\"),\n\t    SHEX(\"4cfca6da32da6471 98225460722b7ea1\"\n\t\t \"284f98c4b179e8db ae3f93d5\"));\n  test_hash(&nettle_sha224, SDATA(\"message digest\"),\n\t    SHEX(\"2cb21c83ae2f004d e7e81c3c7019cbcb\"\n\t\t \"65b71ab656b22d6d 0c39b8eb\"));\n  test_hash(&nettle_sha224, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"45a5f72c39c5cff2 522eb3429799e49e\"\n\t\t \"5f44b356ef926bcf 390dccc2\"));\n  test_hash(&nettle_sha224,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"\n\t\t  \"ghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"bff72b4fcb7d75e5 632900ac5f90d219\"\n\t\t \"e05e97a7bde72e74 0db393d9\"));\n  test_hash(&nettle_sha224,\n\t    SDATA(\"12345678901234567890123456789012\"\n\t\t  \"34567890123456789012345678901234\"\n\t\t  \"5678901234567890\"),\n\t    SHEX(\"b50aecbe4e9bb0b5 7bc5f3ae760a8e01\"\n\t\t \"db24f203fb3cdcd1 3148046e\"));\n}",
      "lines": 43,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha256-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From FIPS180-2 */\n  test_hash(&nettle_sha256, SDATA(\"abc\"),\n\t    SHEX(\"ba7816bf8f01cfea 414140de5dae2223\"\n\t\t \"b00361a396177a9c b410ff61f20015ad\"));\n\n  test_hash(&nettle_sha256,\n\t    SDATA(\"abcdbcdecdefdefgefghfghighij\"\n\t\t  \"hijkijkljklmklmnlmnomnopnopq\"),\n\t    SHEX(\"248d6a61d20638b8 e5c026930c3e6039\"\n\t\t \"a33ce45964ff2167 f6ecedd419db06c1\"));\n\n  test_hash(&nettle_sha256,\n\t    SDATA(\"abcdefghbcdefghicdefghijdefg\"\n\t\t  \"hijkefghijklfghijklmghijklmn\"\n\t\t  \"hijklmnoijklmnopjklmnopqklmn\"\n\t\t  \"opqrlmnopqrsmnopqrstnopqrstu\"),\n\t    SHEX(\"cf5b16a778af8380 036ce59e7b049237\"\n\t\t \"0b249b11e8f07a51 afac45037afee9d1\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  test_hash(&nettle_sha256, SDATA(\"\"),\n\t    SHEX(\"e3b0c44298fc1c14 9afbf4c8996fb924\"\n\t\t \"27ae41e4649b934c a495991b7852b855\"));\n  test_hash(&nettle_sha256, SDATA(\"a\"),\n\t    SHEX(\"ca978112ca1bbdca fac231b39a23dc4d\"\n\t\t \"a786eff8147c4e72 b9807785afee48bb\"));\n  test_hash(&nettle_sha256, SDATA(\"38\"),\n\t    SHEX(\"aea92132c4cbeb26 3e6ac2bf6c183b5d\"\n\t\t \"81737f179f21efdc 5863739672f0f470\"));\n  test_hash(&nettle_sha256, SDATA(\"message digest\"),\n\t    SHEX(\"f7846f55cf23e14e ebeab5b4e1550cad\"\n\t\t \"5b509e3348fbc4ef a3a1413d393cb650\"));\n  test_hash(&nettle_sha256, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"71c480df93d6ae2f 1efad1447c66c952\"\n\t\t \"5e316218cf51fc8d 9ed832f2daf18b73\"));\n  test_hash(&nettle_sha256,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"\n\t\t  \"ghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"db4bfcbd4da0cd85 a60c3c37d3fbd880\"\n\t\t \"5c77f15fc6b1fdfe 614ee0a7c8fdb4c0\"));\n  test_hash(&nettle_sha256,\n\t    SDATA(\"12345678901234567890123456789012\"\n\t\t  \"34567890123456789012345678901234\"\n\t\t  \"5678901234567890\"),\n\t    SHEX(\"f371bc4a311f2b00 9eef952dd83ca80e\"\n\t\t \"2b60026c8e935592 d0f9c308453c813e\"));\n}",
      "lines": 50,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha3-224-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Extracted from ShortMsgKAT_224.txt using sha3.awk. */\n  test_hash(&nettle_sha3_224, /* 0 octets */\n\t    SHEX(\"\"),\n\t    SHEX(\"6B4E03423667DBB73B6E15454F0EB1ABD4597F9A1B078E3F5B5A6BC7\"));\n  test_hash(&nettle_sha3_224, /* 1 octets */\n\t    SHEX(\"CC\"),\n\t    SHEX(\"DF70ADC49B2E76EEE3A6931B93FA41841C3AF2CDF5B32A18B5478C39\"));\n  test_hash(&nettle_sha3_224, /* 2 octets */\n\t    SHEX(\"41FB\"),\n\t    SHEX(\"BFF295861DAEDF33E70519B1E2BCB4C2E9FE3364D789BC3B17301C15\"));\n  test_hash(&nettle_sha3_224, /* 3 octets */\n\t    SHEX(\"1F877C\"),\n\t    SHEX(\"14889DF49C076A9AF2F4BCB16339BCC45A24EBF9CE4DCDCE7EC17217\"));\n  test_hash(&nettle_sha3_224, /* 4 octets */\n\t    SHEX(\"C1ECFDFC\"),\n\t    SHEX(\"A33C58DF8A8026F0F9591966BD6D00EED3B1E829580AB9BE268CAF39\"));\n  test_hash(&nettle_sha3_224, /* 5 octets */\n\t    SHEX(\"21F134AC57\"),\n\t    SHEX(\"10E580A32199596169331AD43CFCF10264F81565037040028A06B458\"));\n  test_hash(&nettle_sha3_224, /* 6 octets */\n\t    SHEX(\"C6F50BB74E29\"),\n\t    SHEX(\"FE52C30C95C1E5193207E97D355FDE09453482708C0876AA961508F0\"));\n  test_hash(&nettle_sha3_224, /* 7 octets */\n\t    SHEX(\"119713CC83EEEF\"),\n\t    SHEX(\"8B449849CB7C4776C593DE58FD5C2E322CB5316BE08A75057A01ED6A\"));\n  test_hash(&nettle_sha3_224, /* 8 octets */\n\t    SHEX(\"4A4F202484512526\"),\n\t    SHEX(\"01386CDD70589B3B34941EFE16B85071E9BA948179922044F640868E\"));\n  test_hash(&nettle_sha3_224, /* 9 octets */\n\t    SHEX(\"1F66AB4185ED9B6375\"),\n\t    SHEX(\"86953D0864019C81FD3A805357A162FD76A13A7CBF6FF0D635015D0E\"));\n  test_hash(&nettle_sha3_224, /* 10 octets */\n\t    SHEX(\"EED7422227613B6F53C9\"),\n\t    SHEX(\"E56FC2A5A58709031DF02A2E46AD95F93583E2745630540D8D97F703\"));\n  test_hash(&nettle_sha3_224, /* 11 octets */\n\t    SHEX(\"EAEED5CDFFD89DECE455F1\"),\n\t    SHEX(\"1D783C37C32A2B71B504BCAA05FC00B639F1FAE7E8D8E3F3BC49F041\"));\n  test_hash(&nettle_sha3_224, /* 12 octets */\n\t    SHEX(\"5BE43C90F22902E4FE8ED2D3\"),\n\t    SHEX(\"54C7E4BF3C73E192ADE223DFEA86F2D04ACF953612731958F854C7BD\"));\n  test_hash(&nettle_sha3_224, /* 13 octets */\n\t    SHEX(\"A746273228122F381C3B46E4F1\"),\n\t    SHEX(\"77E51CEADA2AA1CBBF95ACD821008B57E946F7940223B19F0C53E62E\"));\n  test_hash(&nettle_sha3_224, /* 14 octets */\n\t    SHEX(\"3C5871CD619C69A63B540EB5A625\"),\n\t    SHEX(\"9ED59ED155E97154E067FA0F5A130839B57BDBDA6FEB82DABE006F00\"));\n  test_hash(&nettle_sha3_224, /* 15 octets */\n\t    SHEX(\"FA22874BCC068879E8EF11A69F0722\"),\n\t    SHEX(\"81B3E56CFEEE8E9138D3BFE24BB7CCDFD4B50D0B8CA11AE7D4B0C960\"));\n  test_hash(&nettle_sha3_224, /* 16 octets */\n\t    SHEX(\"52A608AB21CCDD8A4457A57EDE782176\"),\n\t    SHEX(\"B1571BED52E54EEF377D99DF7BE4BC6682C43387F2BF9ACC92DF608F\"));\n  test_hash(&nettle_sha3_224, /* 17 octets */\n\t    SHEX(\"82E192E4043DDCD12ECF52969D0F807EED\"),\n\t    SHEX(\"08045CF78D238D56972F1C850414BC404FC6DCB11F8D8210D034C610\"));\n  test_hash(&nettle_sha3_224, /* 18 octets */\n\t    SHEX(\"75683DCB556140C522543BB6E9098B21A21E\"),\n\t    SHEX(\"9FFD840C550AD23971EB5CE89AE2FD6222ABFB7F0AAFD7EB0005716B\"));\n  test_hash(&nettle_sha3_224, /* 19 octets */\n\t    SHEX(\"06E4EFE45035E61FAAF4287B4D8D1F12CA97E5\"),\n\t    SHEX(\"72DECB5EA1B25A2DAAEB234A8D96E0F57211426666A2EE76B2385C62\"));\n  test_hash(&nettle_sha3_224, /* 20 octets */\n\t    SHEX(\"E26193989D06568FE688E75540AEA06747D9F851\"),\n\t    SHEX(\"A589936370A3D20039C469D44A1C26E62823AB28CC50175A9897F98E\"));\n  test_hash(&nettle_sha3_224, /* 21 octets */\n\t    SHEX(\"D8DC8FDEFBDCE9D44E4CBAFE78447BAE3B5436102A\"),\n\t    SHEX(\"96F43401AD49C58D887020F395BDD01F6DAD04128A85B17780408C37\"));\n  test_hash(&nettle_sha3_224, /* 22 octets */\n\t    SHEX(\"57085FD7E14216AB102D8317B0CB338A786D5FC32D8F\"),\n\t    SHEX(\"A3A0F0C552E7CD2723FE22E1D5719E213D9A3DA1DB99E32EFFFD0F46\"));\n  test_hash(&nettle_sha3_224, /* 23 octets */\n\t    SHEX(\"A05404DF5DBB57697E2C16FA29DEFAC8AB3560D6126FA0\"),\n\t    SHEX(\"E991F4A14B56DC6B224EF352AE8BC8CAE8B1AF1C25C6733DFB7FFE1F\"));\n  test_hash(&nettle_sha3_224, /* 24 octets */\n\t    SHEX(\"AECBB02759F7433D6FCB06963C74061CD83B5B3FFA6F13C6\"),\n\t    SHEX(\"718866C21CBE3F291364C07B36078A6BF0B8258B0EC155E2E2B1AF23\"));\n  test_hash(&nettle_sha3_224, /* 25 octets */\n\t    SHEX(\"AAFDC9243D3D4A096558A360CC27C8D862F0BE73DB5E88AA55\"),\n\t    SHEX(\"23606D06FD8F87C2205ABB5FD04C33EBA30509955200566A0F772B49\"));\n  test_hash(&nettle_sha3_224, /* 26 octets */\n\t    SHEX(\"7BC84867F6F9E9FDC3E1046CAE3A52C77ED485860EE260E30B15\"),\n\t    SHEX(\"05935F0AD2264475DF34FA96F6A9118C32B217E86169EB7ADE4E2FDB\"));\n  test_hash(&nettle_sha3_224, /* 27 octets */\n\t    SHEX(\"FAC523575A99EC48279A7A459E98FF901918A475034327EFB55843\"),\n\t    SHEX(\"FBEC83CBDB6D08C7BFDDC2E37F73B16DC92926A5C23DAB41DEEBFB1B\"));\n  test_hash(&nettle_sha3_224, /* 28 octets */\n\t    SHEX(\"0F8B2D8FCFD9D68CFFC17CCFB117709B53D26462A3F346FB7C79B85E\"),\n\t    SHEX(\"1E693B0BCE2372550DAEF35B14F13AB43441ED6742DEE3E86FD1D8EF\"));\n  test_hash(&nettle_sha3_224, /* 29 octets */\n\t    SHEX(\"A963C3E895FF5A0BE4824400518D81412F875FA50521E26E85EAC90C04\"),\n\t    SHEX(\"1781F1344DC17F678571F4E5DF3998B1D38B1D83602B53B9B6F283D6\"));\n  test_hash(&nettle_sha3_224, /* 30 octets */\n\t    SHEX(\"03A18688B10CC0EDF83ADF0A84808A9718383C4070C6C4F295098699AC2C\"),\n\t    SHEX(\"03B74B7D8FC1F23F76BAB2B6C35F292C15506DE64978FCF6D9973FCE\"));\n  test_hash(&nettle_sha3_224, /* 31 octets */\n\t    SHEX(\"84FB51B517DF6C5ACCB5D022F8F28DA09B10232D42320FFC32DBECC3835B29\"),\n\t    SHEX(\"6A6857FBA903B9DA2753690C39C548BE008E22EBB372EEAA16C85918\"));\n  test_hash(&nettle_sha3_224, /* 32 octets */\n\t    SHEX(\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\"),\n\t    SHEX(\"887921848AD98458F3DB3E0ECD5AD5DB1F0BF9F2D0CA08601074D597\"));\n  test_hash(&nettle_sha3_224, /* 33 octets */\n\t    SHEX(\"DE8F1B3FAA4B7040ED4563C3B8E598253178E87E4D0DF75E4FF2F2DEDD5A0BE046\"),\n\t    SHEX(\"E0573AD706B44D8C4D204F884B95AB18913E76F41CF29A16DBE34794\"));\n  test_hash(&nettle_sha3_224, /* 34 octets */\n\t    SHEX(\"62F154EC394D0BC757D045C798C8B87A00E0655D0481A7D2D9FB58D93AEDC676B5A0\"),\n\t    SHEX(\"BA31233099055483C99F7AD82D0D24AF487ED4B53FFF1A892A55DDB3\"));\n  test_hash(&nettle_sha3_224, /* 35 octets */\n\t    SHEX(\"B2DCFE9FF19E2B23CE7DA2A4207D3E5EC7C6112A8A22AEC9675A886378E14E5BFBAD4E\"),\n\t    SHEX(\"BEFAA1CB47CF78DDD4E096B861BC340B776F52E351EBE378ADE305BA\"));\n  test_hash(&nettle_sha3_224, /* 36 octets */\n\t    SHEX(\"47F5697AC8C31409C0868827347A613A3562041C633CF1F1F86865A576E02835ED2C2492\"),\n\t    SHEX(\"F1E7A1B28EA4D6FB86570F66911E3258C3F49F891654FBCE9BC79B8B\"));\n  test_hash(&nettle_sha3_224, /* 37 octets */\n\t    SHEX(\"512A6D292E67ECB2FE486BFE92660953A75484FF4C4F2ECA2B0AF0EDCDD4339C6B2EE4E542\"),\n\t    SHEX(\"C2B31746446934FE29E84CFB5C25B03BE33E9004F74E91C1AF0DB789\"));\n  test_hash(&nettle_sha3_224, /* 38 octets */\n\t    SHEX(\"973CF2B4DCF0BFA872B41194CB05BB4E16760A1840D8343301802576197EC19E2A1493D8F4FB\"),\n\t    SHEX(\"3A80645FE4271346AAEDC3AE5011B75DF163FAD3EE6128D87F3D9DA3\"));\n  test_hash(&nettle_sha3_224, /* 39 octets */\n\t    SHEX(\"80BEEBCD2E3F8A9451D4499961C9731AE667CDC24EA020CE3B9AA4BBC0A7F79E30A934467DA4B0\"),\n\t    SHEX(\"3C5EBE43A2571BCEF25E4EA67A4CA9838770D23599059955AF93FF83\"));\n  test_hash(&nettle_sha3_224, /* 40 octets */\n\t    SHEX(\"7ABAA12EC2A7347674E444140AE0FB659D08E1C66DECD8D6EAE925FA451D65F3C0308E29446B8ED3\"),\n\t    SHEX(\"AF71DAB0F33D3B48733AD6335CA609398D894E6FA96F5510AE73E5D2\"));\n  test_hash(&nettle_sha3_224, /* 41 octets */\n\t    SHEX(\"C88DEE9927679B8AF422ABCBACF283B904FF31E1CAC58C7819809F65D5807D46723B20F67BA610C2B7\"),\n\t    SHEX(\"DD7512DAA0C634CC1588870B84691D7DE2C182E5570D57868E7DDA5D\"));\n  test_hash(&nettle_sha3_224, /* 42 octets */\n\t    SHEX(\"01E43FE350FCEC450EC9B102053E6B5D56E09896E0DDD9074FE138E6038210270C834CE6EADC2BB86BF6\"),\n\t    SHEX(\"6CB4F9292BA33CA8D293B7A7EF76619E77309BA2178CD4A130BF9218\"));\n  test_hash(&nettle_sha3_224, /* 43 octets */\n\t    SHEX(\"337023370A48B62EE43546F17C4EF2BF8D7ECD1D49F90BAB604B839C2E6E5BD21540D29BA27AB8E309A4B7\"),\n\t    SHEX(\"A9B8435E55FC50FE935EC96798A629C13E856C3C5CFD248126976E0D\"));\n  test_hash(&nettle_sha3_224, /* 44 octets */\n\t    SHEX(\"6892540F964C8C74BD2DB02C0AD884510CB38AFD4438AF31FC912756F3EFEC6B32B58EBC38FC2A6B913596A8\"),\n\t    SHEX(\"93E79850622B91F729AB056EA402E27F01B5323158111B29362A96D5\"));\n  test_hash(&nettle_sha3_224, /* 45 octets */\n\t    SHEX(\"F5961DFD2B1FFFFDA4FFBF30560C165BFEDAB8CE0BE525845DEB8DC61004B7DB38467205F5DCFB34A2ACFE96C0\"),\n\t    SHEX(\"7E51D5531382490670115DE13137CB3ADB6E7621B7D9ECA8170FAA96\"));\n  test_hash(&nettle_sha3_224, /* 46 octets */\n\t    SHEX(\"CA061A2EB6CEED8881CE2057172D869D73A1951E63D57261384B80CEB5451E77B06CF0F5A0EA15CA907EE1C27EBA\"),\n\t    SHEX(\"95C35037A8076926FC5C421C35160AC5FE533A2782F20F2D3F4B1B7D\"));\n  test_hash(&nettle_sha3_224, /* 47 octets */\n\t    SHEX(\"1743A77251D69242750C4F1140532CD3C33F9B5CCDF7514E8584D4A5F9FBD730BCF84D0D4726364B9BF95AB251D9BB\"),\n\t    SHEX(\"BF024A4FE480636118FCC85B807704D59B64D16A150AA53CDE41F030\"));\n  test_hash(&nettle_sha3_224, /* 48 octets */\n\t    SHEX(\"D8FABA1F5194C4DB5F176FABFFF856924EF627A37CD08CF55608BBA8F1E324D7C7F157298EABC4DCE7D89CE5162499F9\"),\n\t    SHEX(\"B7A51FBB084DEEB55136EFD7260E5B112E3C40D1A2D14B142DF930DF\"));\n  test_hash(&nettle_sha3_224, /* 49 octets */\n\t    SHEX(\"BE9684BE70340860373C9C482BA517E899FC81BAAA12E5C6D7727975D1D41BA8BEF788CDB5CF4606C9C1C7F61AED59F97D\"),\n\t    SHEX(\"61CF830A2C4F8F48BC643F97A25F822C013F73BDF4CB4194BC8D55DF\"));\n  test_hash(&nettle_sha3_224, /* 50 octets */\n\t    SHEX(\"7E15D2B9EA74CA60F66C8DFAB377D9198B7B16DEB6A1BA0EA3C7EE2042F89D3786E779CF053C77785AA9E692F821F14A7F51\"),\n\t    SHEX(\"D87F62EA811A2F6BF3C5FDE13475B9C676620C0184F87149DC8686C8\"));\n  test_hash(&nettle_sha3_224, /* 51 octets */\n\t    SHEX(\"9A219BE43713BD578015E9FDA66C0F2D83CAC563B776AB9F38F3E4F7EF229CB443304FBA401EFB2BDBD7ECE939102298651C86\"),\n\t    SHEX(\"028A639C7EC0BA1DCEC0B689AA26E2C0167622462669A5C52031602B\"));\n  test_hash(&nettle_sha3_224, /* 52 octets */\n\t    SHEX(\"C8F2B693BD0D75EF99CAEBDC22ADF4088A95A3542F637203E283BBC3268780E787D68D28CC3897452F6A22AA8573CCEBF245972A\"),\n\t    SHEX(\"908EF28AB2B6CBB449B9AF7FA78B3D90E019C3916562EB4819A0C87F\"));\n  test_hash(&nettle_sha3_224, /* 53 octets */\n\t    SHEX(\"EC0F99711016C6A2A07AD80D16427506CE6F441059FD269442BAAA28C6CA037B22EEAC49D5D894C0BF66219F2C08E9D0E8AB21DE52\"),\n\t    SHEX(\"6AC84149F890E1352C6D7397DAC3B3773947B3757E8ED4EC059EF899\"));\n  test_hash(&nettle_sha3_224, /* 54 octets */\n\t    SHEX(\"0DC45181337CA32A8222FE7A3BF42FC9F89744259CFF653504D6051FE84B1A7FFD20CB47D4696CE212A686BB9BE9A8AB1C697B6D6A33\"),\n\t    SHEX(\"45DA27715CD75F5875BEB7D914CF7488240D1B1F975D430D2F49E9BF\"));\n  test_hash(&nettle_sha3_224, /* 55 octets */\n\t    SHEX(\"DE286BA4206E8B005714F80FB1CDFAEBDE91D29F84603E4A3EBC04686F99A46C9E880B96C574825582E8812A26E5A857FFC6579F63742F\"),\n\t    SHEX(\"63AFBABBEC072140DFCEFE64CF7BC9534DCA10956042E31DBE58D0A5\"));\n  test_hash(&nettle_sha3_224, /* 56 octets */\n\t    SHEX(\"EEBCC18057252CBF3F9C070F1A73213356D5D4BC19AC2A411EC8CDEEE7A571E2E20EAF61FD0C33A0FFEB297DDB77A97F0A415347DB66BCAF\"),\n\t    SHEX(\"6487193D9CBE593B3DAA50D4DFDF7DD2612300BB93CB39E3EEFA1AFA\"));\n  test_hash(&nettle_sha3_224, /* 57 octets */\n\t    SHEX(\"416B5CDC9FE951BD361BD7ABFC120A5054758EBA88FDD68FD84E39D3B09AC25497D36B43CBE7B85A6A3CEBDA8DB4E5549C3EE51BB6FCB6AC1E\"),\n\t    SHEX(\"0DEC25BE3277E27D4F784AD5FF8F79D61D9A309BD693513ACBEED12F\"));\n  test_hash(&nettle_sha3_224, /* 58 octets */\n\t    SHEX(\"5C5FAF66F32E0F8311C32E8DA8284A4ED60891A5A7E50FB2956B3CBAA79FC66CA376460E100415401FC2B8518C64502F187EA14BFC9503759705\"),\n\t    SHEX(\"130B67C6D1A5616227ABD73ABF6FEB70FCE1D5A4BF3338C6DCCB39D5\"));\n  test_hash(&nettle_sha3_224, /* 59 octets */\n\t    SHEX(\"7167E1E02BE1A7CA69D788666F823AE4EEF39271F3C26A5CF7CEE05BCA83161066DC2E217B330DF821103799DF6D74810EED363ADC4AB99F36046A\"),\n\t    SHEX(\"3ABB5ACB8485E20BB620D4A030B9C25D3156A9B26893AE007C79F305\"));\n  test_hash(&nettle_sha3_224, /* 60 octets */\n\t    SHEX(\"2FDA311DBBA27321C5329510FAE6948F03210B76D43E7448D1689A063877B6D14C4F6D0EAA96C150051371F7DD8A4119F7DA5C483CC3E6723C01FB7D\"),\n\t    SHEX(\"922E216529A95305307E908C69367EBB9AD931ECA314563AC36AAB80\"));\n  test_hash(&nettle_sha3_224, /* 61 octets */\n\t    SHEX(\"95D1474A5AAB5D2422ACA6E481187833A6212BD2D0F91451A67DD786DFC91DFED51B35F47E1DEB8A8AB4B9CB67B70179CC26F553AE7B569969CE151B8D\"),\n\t    SHEX(\"C72E93A2C39ABCD90AB11CD3F15D59DA3C23C0F17C4E26C9C5890887\"));\n  test_hash(&nettle_sha3_224, /* 62 octets */\n\t    SHEX(\"C71BD7941F41DF044A2927A8FF55B4B467C33D089F0988AA253D294ADDBDB32530C0D4208B10D9959823F0C0F0734684006DF79F7099870F6BF53211A88D\"),\n\t    SHEX(\"CCCC3B59F28C3FC462DC0A696150F5AEA62DA0ABA97C476BD0D866C1\"));\n  test_hash(&nettle_sha3_224, /* 63 octets */\n\t    SHEX(\"F57C64006D9EA761892E145C99DF1B24640883DA79D9ED5262859DCDA8C3C32E05B03D984F1AB4A230242AB6B78D368DC5AAA1E6D3498D53371E84B0C1D4BA\"),\n\t    SHEX(\"28CFD0C6F0208D24AAA69E6C39F5257C13303E91C2D683A9AF29B973\"));\n  test_hash(&nettle_sha3_224, /* 64 octets */\n\t    SHEX(\"E926AE8B0AF6E53176DBFFCC2A6B88C6BD765F939D3D178A9BDE9EF3AA131C61E31C1E42CDFAF4B4DCDE579A37E150EFBEF5555B4C1CB40439D835A724E2FAE7\"),\n\t    SHEX(\"C154607F986F9BF902D831293C8386D36B201EABA6F6FB0B678B4B81\"));\n  test_hash(&nettle_sha3_224, /* 65 octets */\n\t    SHEX(\"16E8B3D8F988E9BB04DE9C96F2627811C973CE4A5296B4772CA3EEFEB80A652BDF21F50DF79F32DB23F9F73D393B2D57D9A0297F7A2F2E79CFDA39FA393DF1AC00\"),\n\t    SHEX(\"95E87AC90F541AB90CBCF7FD7E0E0C152CEF78D5EE1830E9ED8A1ED7\"));\n  test_hash(&nettle_sha3_224, /* 66 octets */\n\t    SHEX(\"FC424EEB27C18A11C01F39C555D8B78A805B88DBA1DC2A42ED5E2C0EC737FF68B2456D80EB85E11714FA3F8EABFB906D3C17964CB4F5E76B29C1765DB03D91BE37FC\"),\n\t    SHEX(\"35BD7D02541D6D4B10ACE6029A24C07A38FD563ABA227F0F776EA5E2\"));\n  test_hash(&nettle_sha3_224, /* 67 octets */\n\t    SHEX(\"ABE3472B54E72734BDBA7D9158736464251C4F21B33FBBC92D7FAC9A35C4E3322FF01D2380CBAA4EF8FB07D21A2128B7B9F5B6D9F34E13F39C7FFC2E72E47888599BA5\"),\n\t    SHEX(\"99DECB8CF1D474970B3CFA87FA462B75E3287B98B4BE4093429E22D6\"));\n  test_hash(&nettle_sha3_224, /* 68 octets */\n\t    SHEX(\"36F9F0A65F2CA498D739B944D6EFF3DA5EBBA57E7D9C41598A2B0E4380F3CF4B479EC2348D015FFE6256273511154AFCF3B4B4BF09D6C4744FDD0F62D75079D440706B05\"),\n\t    SHEX(\"8C20FD3D8E08235B01727A4DF44D86E71E824F14B0C2FE4E8DA7F1BB\"));\n  test_hash(&nettle_sha3_224, /* 69 octets */\n\t    SHEX(\"ABC87763CAE1CA98BD8C5B82CABA54AC83286F87E9610128AE4DE68AC95DF5E329C360717BD349F26B872528492CA7C94C2C1E1EF56B74DBB65C2AC351981FDB31D06C77A4\"),\n\t    SHEX(\"E29E68439AECDE56F5297FB935DC7DBE63D61CE360A19629195BD8AA\"));\n  test_hash(&nettle_sha3_224, /* 70 octets */\n\t    SHEX(\"94F7CA8E1A54234C6D53CC734BB3D3150C8BA8C5F880EAB8D25FED13793A9701EBE320509286FD8E422E931D99C98DA4DF7E70AE447BAB8CFFD92382D8A77760A259FC4FBD72\"),\n\t    SHEX(\"5D2164DA84E7707CD1E789711A664AB2EBCF66EBA899A909A1D0CBEC\"));\n  test_hash(&nettle_sha3_224, /* 71 octets */\n\t    SHEX(\"13BD2811F6ED2B6F04FF3895ACEED7BEF8DCD45EB121791BC194A0F806206BFFC3B9281C2B308B1A729CE008119DD3066E9378ACDCC50A98A82E20738800B6CDDBE5FE9694AD6D\"),\n\t    SHEX(\"FA263B093EA3F96B52DB6251EA25A5254ADA5B54D476CB0794D38889\"));\n  test_hash(&nettle_sha3_224, /* 72 octets */\n\t    SHEX(\"1EED9CBA179A009EC2EC5508773DD305477CA117E6D569E66B5F64C6BC64801CE25A8424CE4A26D575B8A6FB10EAD3FD1992EDDDEEC2EBE7150DC98F63ADC3237EF57B91397AA8A7\"),\n\t    SHEX(\"D803E320A9865EBF3555E8A3E3134768A2EE1B3E59FA15F35C2EC550\"));\n  test_hash(&nettle_sha3_224, /* 73 octets */\n\t    SHEX(\"BA5B67B5EC3A3FFAE2C19DD8176A2EF75C0CD903725D45C9CB7009A900C0B0CA7A2967A95AE68269A6DBF8466C7B6844A1D608AC661F7EFF00538E323DB5F2C644B78B2D48DE1A08AA\"),\n\t    SHEX(\"102925B63B3E9395F88124C3BFA777F29A5B41C13B62ADD7C271CD6E\"));\n  test_hash(&nettle_sha3_224, /* 74 octets */\n\t    SHEX(\"0EFA26AC5673167DCACAB860932ED612F65FF49B80FA9AE65465E5542CB62075DF1C5AE54FBA4DB807BE25B070033EFA223BDD5B1D3C94C6E1909C02B620D4B1B3A6C9FED24D70749604\"),\n\t    SHEX(\"6C4E83CD9258205F3C2BCF64149F4ACDCEE7742CB2D36038537171BD\"));\n  test_hash(&nettle_sha3_224, /* 75 octets */\n\t    SHEX(\"BBFD933D1FD7BF594AC7F435277DC17D8D5A5B8E4D13D96D2F64E771ABBD51A5A8AEA741BECCBDDB177BCEA05243EBD003CFDEAE877CCA4DA94605B67691919D8B033F77D384CA01593C1B\"),\n\t    SHEX(\"C74C9EBB2EF9A9822A6228BD1186DCC4411BC59EC938DF27E54B0815\"));\n  test_hash(&nettle_sha3_224, /* 76 octets */\n\t    SHEX(\"90078999FD3C35B8AFBF4066CBDE335891365F0FC75C1286CDD88FA51FAB94F9B8DEF7C9AC582A5DBCD95817AFB7D1B48F63704E19C2BAA4DF347F48D4A6D603013C23F1E9611D595EBAC37C\"),\n\t    SHEX(\"D23420F9985D66F097D43A0FB2434149D2B33F21B5BAD6CFC250E072\"));\n  test_hash(&nettle_sha3_224, /* 77 octets */\n\t    SHEX(\"64105ECA863515C20E7CFBAA0A0B8809046164F374D691CDBD6508AAABC1819F9AC84B52BAFC1B0FE7CDDBC554B608C01C8904C669D8DB316A0953A4C68ECE324EC5A49FFDB59A1BD6A292AA0E\"),\n\t    SHEX(\"102EDD2E946F33DD7AA553EA4CE4E659C7B240E1E28BC66200845D87\"));\n  test_hash(&nettle_sha3_224, /* 78 octets */\n\t    SHEX(\"D4654BE288B9F3B711C2D02015978A8CC57471D5680A092AA534F7372C71CEAAB725A383C4FCF4D8DEAA57FCA3CE056F312961ECCF9B86F14981BA5BED6AB5B4498E1F6C82C6CAE6FC14845B3C8A\"),\n\t    SHEX(\"7C8EB98B7338403C013D65C0B5BB4B5D2CBF539CB1109CF447FA6650\"));\n  test_hash(&nettle_sha3_224, /* 79 octets */\n\t    SHEX(\"12D9394888305AC96E65F2BF0E1B18C29C90FE9D714DD59F651F52B88B3008C588435548066EA2FC4C101118C91F32556224A540DE6EFDDBCA296EF1FB00341F5B01FECFC146BDB251B3BDAD556CD2\"),\n\t    SHEX(\"C7B07DE91EFCE42DAB78199EE2EB3014A494994236A12B3DE2330C25\"));\n  test_hash(&nettle_sha3_224, /* 80 octets */\n\t    SHEX(\"871A0D7A5F36C3DA1DFCE57ACD8AB8487C274FAD336BC137EBD6FF4658B547C1DCFAB65F037AA58F35EF16AFF4ABE77BA61F65826F7BE681B5B6D5A1EA8085E2AE9CD5CF0991878A311B549A6D6AF230\"),\n\t    SHEX(\"2FCEF2594AE855DE4FC66DCCC517A659118B3A9F2E5FE638980ADBFB\"));\n  test_hash(&nettle_sha3_224, /* 81 octets */\n\t    SHEX(\"E90B4FFEF4D457BC7711FF4AA72231CA25AF6B2E206F8BF859D8758B89A7CD36105DB2538D06DA83BAD5F663BA11A5F6F61F236FD5F8D53C5E89F183A3CEC615B50C7C681E773D109FF7491B5CC22296C5\"),\n\t    SHEX(\"D45873F0453CBF38156A1384E33E5C76588B7BFB48A709B3943D9186\"));\n  test_hash(&nettle_sha3_224, /* 82 octets */\n\t    SHEX(\"E728DE62D75856500C4C77A428612CD804F30C3F10D36FB219C5CA0AA30726AB190E5F3F279E0733D77E7267C17BE27D21650A9A4D1E32F649627638DBADA9702C7CA303269ED14014B2F3CF8B894EAC8554\"),\n\t    SHEX(\"3543ADD5B7EDFC83AFE7C1F2D55140AEDB858304628109FD077B3860\"));\n  test_hash(&nettle_sha3_224, /* 83 octets */\n\t    SHEX(\"6348F229E7B1DF3B770C77544E5166E081850FA1C6C88169DB74C76E42EB983FACB276AD6A0D1FA7B50D3E3B6FCD799EC97470920A7ABED47D288FF883E24CA21C7F8016B93BB9B9E078BDB9703D2B781B616E\"),\n\t    SHEX(\"36784F114958D8B5B625DD89A4E3973A113E5D1610DFA55B4FB45AEC\"));\n  test_hash(&nettle_sha3_224, /* 84 octets */\n\t    SHEX(\"4B127FDE5DE733A1680C2790363627E63AC8A3F1B4707D982CAEA258655D9BF18F89AFE54127482BA01E08845594B671306A025C9A5C5B6F93B0A39522DC877437BE5C2436CBF300CE7AB6747934FCFC30AEAAF6\"),\n\t    SHEX(\"4187FEAED4FBD3D505A96A8D60668A88172E4F7C8451A4A6802C5747\"));\n  test_hash(&nettle_sha3_224, /* 85 octets */\n\t    SHEX(\"08461F006CFF4CC64B752C957287E5A0FAABC05C9BFF89D23FD902D324C79903B48FCB8F8F4B01F3E4DDB483593D25F000386698F5ADE7FAADE9615FDC50D32785EA51D49894E45BAA3DC707E224688C6408B68B11\"),\n\t    SHEX(\"6E4766DB4E9D1102CEE6DFE0AE2221321B9C0FE707F0A7825D7557EC\"));\n  test_hash(&nettle_sha3_224, /* 86 octets */\n\t    SHEX(\"68C8F8849B120E6E0C9969A5866AF591A829B92F33CD9A4A3196957A148C49138E1E2F5C7619A6D5EDEBE995ACD81EC8BB9C7B9CFCA678D081EA9E25A75D39DB04E18D475920CE828B94E72241F24DB72546B352A0E4\"),\n\t    SHEX(\"E1FC972BFB294185F1980CA2938655FB583E812AD3D64FA5A4CF703E\"));\n  test_hash(&nettle_sha3_224, /* 87 octets */\n\t    SHEX(\"B8D56472954E31FB54E28FCA743F84D8DC34891CB564C64B08F7B71636DEBD64CA1EDBDBA7FC5C3E40049CE982BBA8C7E0703034E331384695E9DE76B5104F2FBC4535ECBEEBC33BC27F29F18F6F27E8023B0FBB6F563C\"),\n\t    SHEX(\"F6F28E3B65B684C9D9506061980046061390CCDE2458A20F9B086BE5\"));\n  test_hash(&nettle_sha3_224, /* 88 octets */\n\t    SHEX(\"0D58AC665FA84342E60CEFEE31B1A4EACDB092F122DFC68309077AED1F3E528F578859EE9E4CEFB4A728E946324927B675CD4F4AC84F64DB3DACFE850C1DD18744C74CECCD9FE4DC214085108F404EAB6D8F452B5442A47D\"),\n\t    SHEX(\"F686D2B1386B02B08F6B02BD5D50206D5E138440CB0D93EBCC3B32A7\"));\n  test_hash(&nettle_sha3_224, /* 89 octets */\n\t    SHEX(\"1755E2D2E5D1C1B0156456B539753FF416651D44698E87002DCF61DCFA2B4E72F264D9AD591DF1FDEE7B41B2EB00283C5AEBB3411323B672EAA145C5125185104F20F335804B02325B6DEA65603F349F4D5D8B782DD3469CCD\"),\n\t    SHEX(\"46483375D112FC2BE7F611BE4B98DFADA38892C43CEFA586726B48BB\"));\n  test_hash(&nettle_sha3_224, /* 90 octets */\n\t    SHEX(\"B180DE1A611111EE7584BA2C4B020598CD574AC77E404E853D15A101C6F5A2E5C801D7D85DC95286A1804C870BB9F00FD4DCB03AA8328275158819DCAD7253F3E3D237AEAA7979268A5DB1C6CE08A9EC7C2579783C8AFC1F91A7\"),\n\t    SHEX(\"E1E9AD568AE5B0D9731400BA4FC7DF0321A04EA41393BA6979C7179C\"));\n  test_hash(&nettle_sha3_224, /* 91 octets */\n\t    SHEX(\"CF3583CBDFD4CBC17063B1E7D90B02F0E6E2EE05F99D77E24E560392535E47E05077157F96813544A17046914F9EFB64762A23CF7A49FE52A0A4C01C630CFE8727B81FB99A89FF7CC11DCA5173057E0417B8FE7A9EFBA6D95C555F\"),\n\t    SHEX(\"133F31D9FBC1B2A33F1C98BFE21E129E0716A69EE27408743FFF17AC\"));\n  test_hash(&nettle_sha3_224, /* 92 octets */\n\t    SHEX(\"072FC02340EF99115BAD72F92C01E4C093B9599F6CFC45CB380EE686CB5EB019E806AB9BD55E634AB10AA62A9510CC0672CD3EDDB589C7DF2B67FCD3329F61B1A4441ECA87A33C8F55DA4FBBAD5CF2B2527B8E983BB31A2FADEC7523\"),\n\t    SHEX(\"31328F04CA64E8521A36A8943C33CEB95BE1B9080F4533D6DA07606D\"));\n  test_hash(&nettle_sha3_224, /* 93 octets */\n\t    SHEX(\"76EECF956A52649F877528146DE33DF249CD800E21830F65E90F0F25CA9D6540FDE40603230ECA6760F1139C7F268DEBA2060631EEA92B1FFF05F93FD5572FBE29579ECD48BC3A8D6C2EB4A6B26E38D6C5FBF2C08044AEEA470A8F2F26\"),\n\t    SHEX(\"ADD374B1D279469C08E7B27AE3FF1B04C3D0FB3EF6E59AA3AF86660B\"));\n  test_hash(&nettle_sha3_224, /* 94 octets */\n\t    SHEX(\"7ADC0B6693E61C269F278E6944A5A2D8300981E40022F839AC644387BFAC9086650085C2CDC585FEA47B9D2E52D65A2B29A7DC370401EF5D60DD0D21F9E2B90FAE919319B14B8C5565B0423CEFB827D5F1203302A9D01523498A4DB10374\"),\n\t    SHEX(\"FED7FDE894D92CC3BB68FCC396B5EB00C4156F04FC9CED99D12CFA5B\"));\n  test_hash(&nettle_sha3_224, /* 95 octets */\n\t    SHEX(\"E1FFFA9826CCE8B86BCCEFB8794E48C46CDF372013F782ECED1E378269B7BE2B7BF51374092261AE120E822BE685F2E7A83664BCFBE38FE8633F24E633FFE1988E1BC5ACF59A587079A57A910BDA60060E85B5F5B6F776F0529639D9CCE4BD\"),\n\t    SHEX(\"17FC0327DE474C78F538B4F3981674FF470AA42EF3B82C0CC34DE6DA\"));\n  test_hash(&nettle_sha3_224, /* 96 octets */\n\t    SHEX(\"69F9ABBA65592EE01DB4DCE52DBAB90B08FC04193602792EE4DAA263033D59081587B09BBE49D0B49C9825D22840B2FF5D9C5155F975F8F2C2E7A90C75D2E4A8040FE39F63BBAFB403D9E28CC3B86E04E394A9C9E8065BD3C85FA9F0C7891600\"),\n\t    SHEX(\"88FEFBE8995E296A9DEE4DA2B414D5A7E134045639A6B176C2D736ED\"));\n  test_hash(&nettle_sha3_224, /* 97 octets */\n\t    SHEX(\"38A10A352CA5AEDFA8E19C64787D8E9C3A75DBF3B8674BFAB29B5DBFC15A63D10FAE66CD1A6E6D2452D557967EAAD89A4C98449787B0B3164CA5B717A93F24EB0B506CEB70CBBCB8D72B2A72993F909AAD92F044E0B5A2C9AC9CB16A0CA2F81F49\"),\n\t    SHEX(\"C002732F6F38AB83828921F5FCB4A8CE1FC561B0E9FA214C5FF02192\"));\n  test_hash(&nettle_sha3_224, /* 98 octets */\n\t    SHEX(\"6D8C6E449BC13634F115749C248C17CD148B72157A2C37BF8969EA83B4D6BA8C0EE2711C28EE11495F43049596520CE436004B026B6C1F7292B9C436B055CBB72D530D860D1276A1502A5140E3C3F54A93663E4D20EDEC32D284E25564F624955B52\"),\n\t    SHEX(\"44E9002F9D97D98BB439AFC361F93BB959523E73136A2C65B2E2B066\"));\n  test_hash(&nettle_sha3_224, /* 99 octets */\n\t    SHEX(\"6EFCBCAF451C129DBE00B9CEF0C3749D3EE9D41C7BD500ADE40CDC65DEDBBBADB885A5B14B32A0C0D087825201E303288A733842FA7E599C0C514E078F05C821C7A4498B01C40032E9F1872A1C925FA17CE253E8935E4C3C71282242CB716B2089CCC1\"),\n\t    SHEX(\"2BFF16CBA9E50762D2288EB780078462C086F4CBF59479F5387A0B27\"));\n  test_hash(&nettle_sha3_224, /* 100 octets */\n\t    SHEX(\"433C5303131624C0021D868A30825475E8D0BD3052A022180398F4CA4423B98214B6BEAAC21C8807A2C33F8C93BD42B092CC1B06CEDF3224D5ED1EC29784444F22E08A55AA58542B524B02CD3D5D5F6907AFE71C5D7462224A3F9D9E53E7E0846DCBB4CE\"),\n\t    SHEX(\"5EFDC3CAA22EE2C2EB632D4C6645CE3EC63960DFD69A04BBE01156C5\"));\n  test_hash(&nettle_sha3_224, /* 101 octets */\n\t    SHEX(\"A873E0C67CA639026B6683008F7AA6324D4979550E9BCE064CA1E1FB97A30B147A24F3F666C0A72D71348EDE701CF2D17E2253C34D1EC3B647DBCEF2F879F4EB881C4830B791378C901EB725EA5C172316C6D606E0AF7DF4DF7F76E490CD30B2BADF45685F\"),\n\t    SHEX(\"E8FB64A74387C9A3E1AC4ABC82D3591B6B349F2E5CDE6584D8D7C371\"));\n  test_hash(&nettle_sha3_224, /* 102 octets */\n\t    SHEX(\"006917B64F9DCDF1D2D87C8A6173B64F6587168E80FAA80F82D84F60301E561E312D9FBCE62F39A6FB476E01E925F26BCC91DE621449BE6504C504830AAE394096C8FC7694651051365D4EE9070101EC9B68086F2EA8F8AB7B811EA8AD934D5C9B62C60A4771\"),\n\t    SHEX(\"DB224BCCF5CA86DFBA3EA372E2269750B532409EA004E82D4B5835E8\"));\n  test_hash(&nettle_sha3_224, /* 103 octets */\n\t    SHEX(\"F13C972C52CB3CC4A4DF28C97F2DF11CE089B815466BE88863243EB318C2ADB1A417CB1041308598541720197B9B1CB5BA2318BD5574D1DF2174AF14884149BA9B2F446D609DF240CE335599957B8EC80876D9A085AE084907BC5961B20BF5F6CA58D5DAB38ADB\"),\n\t    SHEX(\"4E28867DCEF3A7B759CA24D8107BEB0CBF9DB0F10A3C410A9B4BA8C8\"));\n  test_hash(&nettle_sha3_224, /* 104 octets */\n\t    SHEX(\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\"),\n\t    SHEX(\"5C0C2DF13A1FD6762B6E50FB3E080E649C3A7A8DDA415C42FB637136\"));\n  test_hash(&nettle_sha3_224, /* 105 octets */\n\t    SHEX(\"64EC021C9585E01FFE6D31BB50D44C79B6993D72678163DB474947A053674619D158016ADB243F5C8D50AA92F50AB36E579FF2DABB780A2B529370DAA299207CFBCDD3A9A25006D19C4F1FE33E4B1EAEC315D8C6EE1E730623FD1941875B924EB57D6D0C2EDC4E78D6\"),\n\t    SHEX(\"36F5630EC2829B0FBAD84F150932E46647EDCC454E06B23166661D60\"));\n  test_hash(&nettle_sha3_224, /* 106 octets */\n\t    SHEX(\"5954BAB512CF327D66B5D9F296180080402624AD7628506B555EEA8382562324CF452FBA4A2130DE3E165D11831A270D9CB97CE8C2D32A96F50D71600BB4CA268CF98E90D6496B0A6619A5A8C63DB6D8A0634DFC6C7EC8EA9C006B6C456F1B20CD19E781AF20454AC880\"),\n\t    SHEX(\"DAC2594BCD357E63928A21E98348F27D0FA2C70EB07C7E8E93D6D84E\"));\n  test_hash(&nettle_sha3_224, /* 107 octets */\n\t    SHEX(\"03D9F92B2C565709A568724A0AFF90F8F347F43B02338F94A03ED32E6F33666FF5802DA4C81BDCE0D0E86C04AFD4EDC2FC8B4141C2975B6F07639B1994C973D9A9AFCE3D9D365862003498513BFA166D2629E314D97441667B007414E739D7FEBF0FE3C32C17AA188A8683\"),\n\t    SHEX(\"24970DF3CF8C9E30DCBE661817FF74538AD43BC90B149ED7CAB7811B\"));\n  test_hash(&nettle_sha3_224, /* 108 octets */\n\t    SHEX(\"F31E8B4F9E0621D531D22A380BE5D9ABD56FAEC53CBD39B1FAB230EA67184440E5B1D15457BD25F56204FA917FA48E669016CB48C1FFC1E1E45274B3B47379E00A43843CF8601A5551411EC12503E5AAC43D8676A1B2297EC7A0800DBFEE04292E937F21C005F17411473041\"),\n\t    SHEX(\"AD9BF420D2B570EBE7923A76B253F156F3513712955BCBB9A87394DB\"));\n  test_hash(&nettle_sha3_224, /* 109 octets */\n\t    SHEX(\"758EA3FEA738973DB0B8BE7E599BBEF4519373D6E6DCD7195EA885FC991D896762992759C2A09002912FB08E0CB5B76F49162AEB8CF87B172CF3AD190253DF612F77B1F0C532E3B5FC99C2D31F8F65011695A087A35EE4EEE5E334C369D8EE5D29F695815D866DA99DF3F79403\"),\n\t    SHEX(\"2F60928263FE1D5FA5136DA8DE1D2C3B60BD4B700A3E2C256E9536EF\"));\n  test_hash(&nettle_sha3_224, /* 110 octets */\n\t    SHEX(\"47C6E0C2B74948465921868804F0F7BD50DD323583DC784F998A93CD1CA4C6EF84D41DC81C2C40F34B5BEE6A93867B3BDBA0052C5F59E6F3657918C382E771D33109122CC8BB0E1E53C4E3D13B43CE44970F5E0C079D2AD7D7A3549CD75760C21BB15B447589E86E8D76B1E9CED2\"),\n\t    SHEX(\"BFB40F7E7F81F2FEC7644E08FBC99C768ADC6314B8CCD833332F1BF8\"));\n  test_hash(&nettle_sha3_224, /* 111 octets */\n\t    SHEX(\"F690A132AB46B28EDFA6479283D6444E371C6459108AFD9C35DBD235E0B6B6FF4C4EA58E7554BD002460433B2164CA51E868F7947D7D7A0D792E4ABF0BE5F450853CC40D85485B2B8857EA31B5EA6E4CCFA2F3A7EF3380066D7D8979FDAC618AAD3D7E886DEA4F005AE4AD05E5065F\"),\n\t    SHEX(\"190E9FDA8A7D78343FF24ADE9FEE69650C7631AD6329D17D4BD575DB\"));\n  test_hash(&nettle_sha3_224, /* 112 octets */\n\t    SHEX(\"58D6A99BC6458824B256916770A8417040721CCCFD4B79EACD8B65A3767CE5BA7E74104C985AC56B8CC9AEBD16FEBD4CDA5ADB130B0FF2329CC8D611EB14DAC268A2F9E633C99DE33997FEA41C52A7C5E1317D5B5DAED35EBA7D5A60E45D1FA7EAABC35F5C2B0A0F2379231953322C4E\"),\n\t    SHEX(\"E26CD20B87083CB9F246D216E3DA51EF7C5519B483DB439D37256DBE\"));\n  test_hash(&nettle_sha3_224, /* 113 octets */\n\t    SHEX(\"BEFAB574396D7F8B6705E2D5B58B2C1C820BB24E3F4BAE3E8FBCD36DBF734EE14E5D6AB972AEDD3540235466E825850EE4C512EA9795ABFD33F330D9FD7F79E62BBB63A6EA85DE15BEAEEA6F8D204A28956059E2632D11861DFB0E65BC07AC8A159388D5C3277E227286F65FF5E5B5AEC1\"),\n\t    SHEX(\"6CAF807F6ABC1A7721A5F209FC09FD00474B9E2A77EF7B57E1320271\"));\n  test_hash(&nettle_sha3_224, /* 114 octets */\n\t    SHEX(\"8E58144FA9179D686478622CE450C748260C95D1BA43B8F9B59ABECA8D93488DA73463EF40198B4D16FB0B0707201347E0506FF19D01BEA0F42B8AF9E71A1F1BD168781069D4D338FDEF00BF419FBB003031DF671F4A37979564F69282DE9C65407847DD0DA505AB1641C02DEA4F0D834986\"),\n\t    SHEX(\"64CD5291A1A0807BA7C14103A0F46C636795F8F8D3A12E59E88D9C51\"));\n  test_hash(&nettle_sha3_224, /* 115 octets */\n\t    SHEX(\"B55C10EAE0EC684C16D13463F29291BF26C82E2FA0422A99C71DB4AF14DD9C7F33EDA52FD73D017CC0F2DBE734D831F0D820D06D5F89DACC485739144F8CFD4799223B1AFF9031A105CB6A029BA71E6E5867D85A554991C38DF3C9EF8C1E1E9A7630BE61CAABCA69280C399C1FB7A12D12AEFC\"),\n\t    SHEX(\"29491256A80BF1A9325348B5841EDC726FA8A53117268C47F74B5E49\"));\n  test_hash(&nettle_sha3_224, /* 116 octets */\n\t    SHEX(\"2EEEA693F585F4ED6F6F8865BBAE47A6908AECD7C429E4BEC4F0DE1D0CA0183FA201A0CB14A529B7D7AC0E6FF6607A3243EE9FB11BCF3E2304FE75FFCDDD6C5C2E2A4CD45F63C962D010645058D36571404A6D2B4F44755434D76998E83409C3205AA1615DB44057DB991231D2CB42624574F545\"),\n\t    SHEX(\"A523449B770A8DE3B39CD446046149FEAEE327D6D5B39929B9AAC915\"));\n  test_hash(&nettle_sha3_224, /* 117 octets */\n\t    SHEX(\"DAB11DC0B047DB0420A585F56C42D93175562852428499F66A0DB811FCDDDAB2F7CDFFED1543E5FB72110B64686BC7B6887A538AD44C050F1E42631BC4EC8A9F2A047163D822A38989EE4AAB01B4C1F161B062D873B1CFA388FD301514F62224157B9BEF423C7783B7AAC8D30D65CD1BBA8D689C2D\"),\n\t    SHEX(\"ABB2FCE213CE164C94AB7A763C21F638A3BB8D72F802DEADACC023AE\"));\n  test_hash(&nettle_sha3_224, /* 118 octets */\n\t    SHEX(\"42E99A2F80AEE0E001279A2434F731E01D34A44B1A8101726921C0590C30F3120EB83059F325E894A5AC959DCA71CE2214799916424E859D27D789437B9D27240BF8C35ADBAFCECC322B48AA205B293962D858652ABACBD588BCF6CBC388D0993BD622F96ED54614C25B6A9AA527589EAAFFCF17DDF7\"),\n\t    SHEX(\"C40D969F7218D71B904C4E4EACEB0473BA0A2E7339649DA5DFEB8938\"));\n  test_hash(&nettle_sha3_224, /* 119 octets */\n\t    SHEX(\"3C9B46450C0F2CAE8E3823F8BDB4277F31B744CE2EB17054BDDC6DFF36AF7F49FB8A2320CC3BDF8E0A2EA29AD3A55DE1165D219ADEDDB5175253E2D1489E9B6FDD02E2C3D3A4B54D60E3A47334C37913C5695378A669E9B72DEC32AF5434F93F46176EBF044C4784467C700470D0C0B40C8A088C815816\"),\n\t    SHEX(\"2EB28FDF458D4FECB5B441D910B576F630E666BBF30AAC90AB64425B\"));\n  test_hash(&nettle_sha3_224, /* 120 octets */\n\t    SHEX(\"D1E654B77CB155F5C77971A64DF9E5D34C26A3CAD6C7F6B300D39DEB1910094691ADAA095BE4BA5D86690A976428635D5526F3E946F7DC3BD4DBC78999E653441187A81F9ADCD5A3C5F254BC8256B0158F54673DCC1232F6E918EBFC6C51CE67EAEB042D9F57EEC4BFE910E169AF78B3DE48D137DF4F2840\"),\n\t    SHEX(\"A3387B2FA23A13BFAE77895F1F93935A0710EE3A027FF0D6399D8ECC\"));\n  test_hash(&nettle_sha3_224, /* 121 octets */\n\t    SHEX(\"626F68C18A69A6590159A9C46BE03D5965698F2DAC3DE779B878B3D9C421E0F21B955A16C715C1EC1E22CE3EB645B8B4F263F60660EA3028981EEBD6C8C3A367285B691C8EE56944A7CD1217997E1D9C21620B536BDBD5DE8925FF71DEC6FBC06624AB6B21E329813DE90D1E572DFB89A18120C3F606355D25\"),\n\t    SHEX(\"75755F46C2FC86BD4AAE75919C6CA5B1A7375E466CA3170F70EEE490\"));\n  test_hash(&nettle_sha3_224, /* 122 octets */\n\t    SHEX(\"651A6FB3C4B80C7C68C6011675E6094EB56ABF5FC3057324EBC6477825061F9F27E7A94633ABD1FA598A746E4A577CAF524C52EC1788471F92B8C37F23795CA19D559D446CAB16CBCDCE90B79FA1026CEE77BF4AB1B503C5B94C2256AD75B3EAC6FD5DCB96ACA4B03A834BFB4E9AF988CECBF2AE597CB9097940\"),\n\t    SHEX(\"7184C69EE1C43FD564102CD68EF898D5D0D8264B9B0D044691BC18AF\"));\n  test_hash(&nettle_sha3_224, /* 123 octets */\n\t    SHEX(\"8AAF072FCE8A2D96BC10B3C91C809EE93072FB205CA7F10ABD82ECD82CF040B1BC49EA13D1857815C0E99781DE3ADBB5443CE1C897E55188CEAF221AA9681638DE05AE1B322938F46BCE51543B57ECDB4C266272259D1798DE13BE90E10EFEC2D07484D9B21A3870E2AA9E06C21AA2D0C9CF420080A80A91DEE16F\"),\n\t    SHEX(\"F50CF78FF46513C905399CC2510681A90CE089FCED40FBC9CF218CA4\"));\n  test_hash(&nettle_sha3_224, /* 124 octets */\n\t    SHEX(\"53F918FD00B1701BD504F8CDEA803ACCA21AC18C564AB90C2A17DA592C7D69688F6580575395551E8CD33E0FEF08CA6ED4588D4D140B3E44C032355DF1C531564D7F4835753344345A6781E11CD5E095B73DF5F82C8AE3AD00877936896671E947CC52E2B29DCD463D90A0C9929128DA222B5A211450BBC0E02448E2\"),\n\t    SHEX(\"F2AABE18D7B4DD8E4DC0AC8DCF4E9019C7C9AF33D4B952DA41219FE5\"));\n  test_hash(&nettle_sha3_224, /* 125 octets */\n\t    SHEX(\"A64599B8A61B5CCEC9E67AED69447459C8DA3D1EC6C7C7C82A7428B9B584FA67E90F68E2C00FBBED4613666E5168DA4A16F395F7A3C3832B3B134BFC9CBAA95D2A0FE252F44AC6681EB6D40AB91C1D0282FED6701C57463D3C5F2BB8C6A7301FB4576AA3B5F15510DB8956FF77478C26A7C09BEA7B398CFC83503F538E\"),\n\t    SHEX(\"AC5D00D177E71D7B9A97270E6200E4D3D07851EB2E58B12BE0BEED95\"));\n  test_hash(&nettle_sha3_224, /* 126 octets */\n\t    SHEX(\"0E3AB0E054739B00CDB6A87BD12CAE024B54CB5E550E6C425360C2E87E59401F5EC24EF0314855F0F56C47695D56A7FB1417693AF2A1ED5291F2FEE95F75EED54A1B1C2E81226FBFF6F63ADE584911C71967A8EB70933BC3F5D15BC91B5C2644D9516D3C3A8C154EE48E118BD1442C043C7A0DBA5AC5B1D5360AAE5B9065\"),\n\t    SHEX(\"CB7979B4C6C2826CDEF7E1AADA85F8C4546DD59D29FC0AEA444F8077\"));\n  test_hash(&nettle_sha3_224, /* 127 octets */\n\t    SHEX(\"A62FC595B4096E6336E53FCDFC8D1CC175D71DAC9D750A6133D23199EAAC288207944CEA6B16D27631915B4619F743DA2E30A0C00BBDB1BBB35AB852EF3B9AEC6B0A8DCC6E9E1ABAA3AD62AC0A6C5DE765DE2C3711B769E3FDE44A74016FFF82AC46FA8F1797D3B2A726B696E3DEA5530439ACEE3A45C2A51BC32DD055650B\"),\n\t    SHEX(\"F9D8CCF6684693C40C81EBBD006C49984FBAF3A2B2E905ABE60765DD\"));\n  test_hash(&nettle_sha3_224, /* 128 octets */\n\t    SHEX(\"2B6DB7CED8665EBE9DEB080295218426BDAA7C6DA9ADD2088932CDFFBAA1C14129BCCDD70F369EFB149285858D2B1D155D14DE2FDB680A8B027284055182A0CAE275234CC9C92863C1B4AB66F304CF0621CD54565F5BFF461D3B461BD40DF28198E3732501B4860EADD503D26D6E69338F4E0456E9E9BAF3D827AE685FB1D817\"),\n\t    SHEX(\"ED1F6387A7BE090277B65A5FCD7040C7BE0EEAF0FD7F14968097873B\"));\n  test_hash(&nettle_sha3_224, /* 129 octets */\n\t    SHEX(\"10DB509B2CDCABA6C062AE33BE48116A29EB18E390E1BBADA5CA0A2718AFBCD23431440106594893043CC7F2625281BF7DE2655880966A23705F0C5155C2F5CCA9F2C2142E96D0A2E763B70686CD421B5DB812DACED0C6D65035FDE558E94F26B3E6DDE5BD13980CC80292B723013BD033284584BFF27657871B0CF07A849F4AE2\"),\n\t    SHEX(\"0A27CE6973CB22A8B10057A8E7A654058B71E6D8C69C653415FF0C81\"));\n  test_hash(&nettle_sha3_224, /* 130 octets */\n\t    SHEX(\"9334DE60C997BDA6086101A6314F64E4458F5FF9450C509DF006E8C547983C651CA97879175AABA0C539E82D05C1E02C480975CBB30118121061B1EBAC4F8D9A3781E2DB6B18042E01ECF9017A64A0E57447EC7FCBE6A7F82585F7403EE2223D52D37B4BF426428613D6B4257980972A0ACAB508A7620C1CB28EB4E9D30FC41361EC\"),\n\t    SHEX(\"BE3BE49980F43FB6598BE921D7D8FDA1F397F605D9708C5D125C4E9F\"));\n  test_hash(&nettle_sha3_224, /* 131 octets */\n\t    SHEX(\"E88AB086891693AA535CEB20E64C7AB97C7DD3548F3786339897A5F0C39031549CA870166E477743CCFBE016B4428D89738E426F5FFE81626137F17AECFF61B72DBEE2DC20961880CFE281DFAB5EE38B1921881450E16032DE5E4D55AD8D4FCA609721B0692BAC79BE5A06E177FE8C80C0C83519FB3347DE9F43D5561CB8107B9B5EDC\"),\n\t    SHEX(\"932137BF2CD32DDFD3BA80C525268730B6F7458601B5296AEB325183\"));\n  test_hash(&nettle_sha3_224, /* 132 octets */\n\t    SHEX(\"FD19E01A83EB6EC810B94582CB8FBFA2FCB992B53684FB748D2264F020D3B960CB1D6B8C348C2B54A9FCEA72330C2AAA9A24ECDB00C436ABC702361A82BB8828B85369B8C72ECE0082FE06557163899C2A0EFA466C33C04343A839417057399A63A3929BE1EE4805D6CE3E5D0D0967FE9004696A5663F4CAC9179006A2CEB75542D75D68\"),\n\t    SHEX(\"796698CE24EFCDA8214D161138F3C7DA6D7615E4CF1DAC63B69941F9\"));\n  test_hash(&nettle_sha3_224, /* 133 octets */\n\t    SHEX(\"59AE20B6F7E0B3C7A989AFB28324A40FCA25D8651CF1F46AE383EF6D8441587AA1C04C3E3BF88E8131CE6145CFB8973D961E8432B202FA5AF3E09D625FAAD825BC19DA9B5C6C20D02ABDA2FCC58B5BD3FE507BF201263F30543819510C12BC23E2DDB4F711D087A86EDB1B355313363A2DE996B891025E147036087401CCF3CA7815BF3C49\"),\n\t    SHEX(\"B216930E158D65FB1FF424F9EAB6CD28996231EF5EE1D65DBE29D370\"));\n  test_hash(&nettle_sha3_224, /* 134 octets */\n\t    SHEX(\"77EE804B9F3295AB2362798B72B0A1B2D3291DCEB8139896355830F34B3B328561531F8079B79A6E9980705150866402FDC176C05897E359A6CB1A7AB067383EB497182A7E5AEF7038E4C96D133B2782917417E391535B5E1B51F47D8ED7E4D4025FE98DC87B9C1622614BFF3D1029E68E372DE719803857CA52067CDDAAD958951CB2068CC6\"),\n\t    SHEX(\"AF6C676A62288B2D25A862F8866B262A74E3D2A0D414B966CE601E14\"));\n  test_hash(&nettle_sha3_224, /* 135 octets */\n\t    SHEX(\"B771D5CEF5D1A41A93D15643D7181D2A2EF0A8E84D91812F20ED21F147BEF732BF3A60EF4067C3734B85BC8CD471780F10DC9E8291B58339A677B960218F71E793F2797AEA349406512829065D37BB55EA796FA4F56FD8896B49B2CD19B43215AD967C712B24E5032D065232E02C127409D2ED4146B9D75D763D52DB98D949D3B0FED6A8052FBB\"),\n\t    SHEX(\"418C83EB01881B4F38544665201DD05C939CA047D31834F637342342\"));\n  test_hash(&nettle_sha3_224, /* 136 octets */\n\t    SHEX(\"B32D95B0B9AAD2A8816DE6D06D1F86008505BD8C14124F6E9A163B5A2ADE55F835D0EC3880EF50700D3B25E42CC0AF050CCD1BE5E555B23087E04D7BF9813622780C7313A1954F8740B6EE2D3F71F768DD417F520482BD3A08D4F222B4EE9DBD015447B33507DD50F3AB4247C5DE9A8ABD62A8DECEA01E3B87C8B927F5B08BEB37674C6F8E380C04\"),\n\t    SHEX(\"64D78817714FE05272D3805E6E19056B1649036CDCD5094FD1CC890A\"));\n  test_hash(&nettle_sha3_224, /* 137 octets */\n\t    SHEX(\"04410E31082A47584B406F051398A6ABE74E4DA59BB6F85E6B49E8A1F7F2CA00DFBA5462C2CD2BFDE8B64FB21D70C083F11318B56A52D03B81CAC5EEC29EB31BD0078B6156786DA3D6D8C33098C5C47BB67AC64DB14165AF65B44544D806DDE5F487D5373C7F9792C299E9686B7E5821E7C8E2458315B996B5677D926DAC57B3F22DA873C601016A0D\"),\n\t    SHEX(\"2C4E7C537D0E2AF2261A669BC24BD0DF16D2C72A7F98D7A5EF6A8150\"));\n  test_hash(&nettle_sha3_224, /* 138 octets */\n\t    SHEX(\"8B81E9BADDE026F14D95C019977024C9E13DB7A5CD21F9E9FC491D716164BBACDC7060D882615D411438AEA056C340CDF977788F6E17D118DE55026855F93270472D1FD18B9E7E812BAE107E0DFDE7063301B71F6CFE4E225CAB3B232905A56E994F08EE2891BA922D49C3DAFEB75F7C69750CB67D822C96176C46BD8A29F1701373FB09A1A6E3C7158F\"),\n\t    SHEX(\"DF1FCB80AB380CA33BDB61F96ADAB334937E190F03C1B78B219E50F8\"));\n  test_hash(&nettle_sha3_224, /* 139 octets */\n\t    SHEX(\"FA6EED24DA6666A22208146B19A532C2EC9BA94F09F1DEF1E7FC13C399A48E41ACC2A589D099276296348F396253B57CB0E40291BD282773656B6E0D8BEA1CDA084A3738816A840485FCF3FB307F777FA5FEAC48695C2AF4769720258C77943FB4556C362D9CBA8BF103AEB9034BAA8EA8BFB9C4F8E6742CE0D52C49EA8E974F339612E830E9E7A9C29065\"),\n\t    SHEX(\"0DD77ADA384CAB6A7ACED19CFC8048C2566D4303E2010C98D16A0516\"));\n  test_hash(&nettle_sha3_224, /* 140 octets */\n\t    SHEX(\"9BB4AF1B4F09C071CE3CAFA92E4EB73CE8A6F5D82A85733440368DEE4EB1CBC7B55AC150773B6FE47DBE036C45582ED67E23F4C74585DAB509DF1B83610564545642B2B1EC463E18048FC23477C6B2AA035594ECD33791AF6AF4CBC2A1166ABA8D628C57E707F0B0E8707CAF91CD44BDB915E0296E0190D56D33D8DDE10B5B60377838973C1D943C22ED335E\"),\n\t    SHEX(\"B256D0D6B6D6A72E113D105AD9601C91933D53B20A30D8E2CF33F96D\"));\n  test_hash(&nettle_sha3_224, /* 141 octets */\n\t    SHEX(\"2167F02118CC62043E9091A647CADBED95611A521FE0D64E8518F16C808AB297725598AE296880A773607A798F7C3CFCE80D251EBEC6885015F9ABF7EAABAE46798F82CB5926DE5C23F44A3F9F9534B3C6F405B5364C2F8A8BDC5CA49C749BED8CE4BA48897062AE8424CA6DDE5F55C0E42A95D1E292CA54FB46A84FBC9CD87F2D0C9E7448DE3043AE22FDD229\"),\n\t    SHEX(\"B95F72512546E4AF685931246717BC482BFE922789A26EEF01BDE82D\"));\n  test_hash(&nettle_sha3_224, /* 142 octets */\n\t    SHEX(\"94B7FA0BC1C44E949B1D7617D31B4720CBE7CA57C6FA4F4094D4761567E389ECC64F6968E4064DF70DF836A47D0C713336B5028B35930D29EB7A7F9A5AF9AD5CF441745BAEC9BB014CEEFF5A41BA5C1CE085FEB980BAB9CF79F2158E03EF7E63E29C38D7816A84D4F71E0F548B7FC316085AE38A060FF9B8DEC36F91AD9EBC0A5B6C338CBB8F6659D342A24368CF\"),\n\t    SHEX(\"628238A9532727CC83F8FDCED11D138A17EEE4822C5D3549157D6D5E\"));\n  test_hash(&nettle_sha3_224, /* 143 octets */\n\t    SHEX(\"EA40E83CB18B3A242C1ECC6CCD0B7853A439DAB2C569CFC6DC38A19F5C90ACBF76AEF9EA3742FF3B54EF7D36EB7CE4FF1C9AB3BC119CFF6BE93C03E208783335C0AB8137BE5B10CDC66FF3F89A1BDDC6A1EED74F504CBE7290690BB295A872B9E3FE2CEE9E6C67C41DB8EFD7D863CF10F840FE618E7936DA3DCA5CA6DF933F24F6954BA0801A1294CD8D7E66DFAFEC\"),\n\t    SHEX(\"AB0FD308590574D6F6130232D9FAFA9FFCFEA78579A6A8F67C590420\"));\n  test_hash(&nettle_sha3_224, /* 144 octets */\n\t    SHEX(\"157D5B7E4507F66D9A267476D33831E7BB768D4D04CC3438DA12F9010263EA5FCAFBDE2579DB2F6B58F911D593D5F79FB05FE3596E3FA80FF2F761D1B0E57080055C118C53E53CDB63055261D7C9B2B39BD90ACC32520CBBDBDA2C4FD8856DBCEE173132A2679198DAF83007A9B5C51511AE49766C792A29520388444EBEFE28256FB33D4260439CBA73A9479EE00C63\"),\n\t    SHEX(\"D5134200DC98F4CA480CD24D24497737252B55977AE5A869BA27089D\"));\n  test_hash(&nettle_sha3_224, /* 145 octets */\n\t    SHEX(\"836B34B515476F613FE447A4E0C3F3B8F20910AC89A3977055C960D2D5D2B72BD8ACC715A9035321B86703A411DDE0466D58A59769672AA60AD587B8481DE4BBA552A1645779789501EC53D540B904821F32B0BD1855B04E4848F9F8CFE9EBD8911BE95781A759D7AD9724A7102DBE576776B7C632BC39B9B5E19057E226552A5994C1DBB3B5C7871A11F5537011044C53\"),\n\t    SHEX(\"494CBC9B649E48EC5AD7364AEB9C8EDF4A4F400789EF203F7B818A44\"));\n  test_hash(&nettle_sha3_224, /* 146 octets */\n\t    SHEX(\"CC7784A4912A7AB5AD3620AAB29BA87077CD3CB83636ADC9F3DC94F51EDF521B2161EF108F21A0A298557981C0E53CE6CED45BDF782C1EF200D29BAB81DD6460586964EDAB7CEBDBBEC75FD7925060F7DA2B853B2B089588FA0F8C16EC6498B14C55DCEE335CB3A91D698E4D393AB8E8EAC0825F8ADEBEEE196DF41205C011674E53426CAA453F8DE1CBB57932B0B741D4C6\"),\n\t    SHEX(\"7FF8A28AB12074102AEF3EFB8904284B617237322A2BF701C9FCFEFC\"));\n  test_hash(&nettle_sha3_224, /* 147 octets */\n\t    SHEX(\"7639B461FFF270B2455AC1D1AFCE782944AEA5E9087EB4A39EB96BB5C3BAAF0E868C8526D3404F9405E79E77BFAC5FFB89BF1957B523E17D341D7323C302EA7083872DD5E8705694ACDDA36D5A1B895AAA16ECA6104C82688532C8BFE1790B5DC9F4EC5FE95BAED37E1D287BE710431F1E5E8EE105BC42ED37D74B1E55984BF1C09FE6A1FA13EF3B96FAEAED6A2A1950A12153\"),\n\t    SHEX(\"50CDBEAB4BBAA0861F3E364AF520F9D8B54E79E3871ABCA7BBB2BAE5\"));\n  test_hash(&nettle_sha3_224, /* 148 octets */\n\t    SHEX(\"EB6513FC61B30CFBA58D4D7E80F94D14589090CF1D80B1DF2E68088DC6104959BA0D583D585E9578AB0AEC0CF36C48435EB52ED9AB4BBCE7A5ABE679C97AE2DBE35E8CC1D45B06DDA3CF418665C57CBEE4BBB47FA4CAF78F4EE656FEC237FE4EEBBAFA206E1EF2BD0EE4AE71BD0E9B2F54F91DAADF1FEBFD7032381D636B733DCB3BF76FB14E23AFF1F68ED3DBCF75C9B99C6F26\"),\n\t    SHEX(\"29B6B523C82F499078C73630BA38227BBD08EF1A2D67B425C058DEF5\"));\n  test_hash(&nettle_sha3_224, /* 149 octets */\n\t    SHEX(\"1594D74BF5DDE444265D4C04DAD9721FF3E34CBF622DAF341FE16B96431F6C4DF1F760D34F296EB97D98D560AD5286FEC4DCE1724F20B54FD7DF51D4BF137ADD656C80546FB1BF516D62EE82BAA992910EF4CC18B70F3F8698276FCFB44E0EC546C2C39CFD8EE91034FF9303058B4252462F86C823EB15BF481E6B79CC3A02218595B3658E8B37382BD5048EAED5FD02C37944E73B\"),\n\t    SHEX(\"93CE0C8D4355300D4E63D6599129DEA7420E5B609DBB35BE432B12B5\"));\n  test_hash(&nettle_sha3_224, /* 150 octets */\n\t    SHEX(\"4CFA1278903026F66FEDD41374558BE1B585D03C5C55DAC94361DF286D4BD39C7CB8037ED3B267B07C346626449D0CC5B0DD2CF221F7E4C3449A4BE99985D2D5E67BFF2923357DDEAB5ABCB4619F3A3A57B2CF928A022EB27676C6CF805689004FCA4D41EA6C2D0A4789C7605F7BB838DD883B3AD3E6027E775BCF262881428099C7FFF95B14C095EA130E0B9938A5E22FC52650F591\"),\n\t    SHEX(\"D02896D957B599869F2B2A4992A49EEF7AB1308F456C78C809BDAC88\"));\n  test_hash(&nettle_sha3_224, /* 151 octets */\n\t    SHEX(\"D3E65CB92CFA79662F6AF493D696A07CCF32AAADCCEFF06E73E8D9F6F909209E66715D6E978788C49EFB9087B170ECF3AA86D2D4D1A065AE0EFC8924F365D676B3CB9E2BEC918FD96D0B43DEE83727C9A93BF56CA2B2E59ADBA85696546A815067FC7A78039629D4948D157E7B0D826D1BF8E81237BAB7321312FDAA4D521744F988DB6FDF04549D0FDCA393D639C729AF716E9C8BBA48\"),\n\t    SHEX(\"181E2301F629A569271BB740D32B1D3BD25ACB179E9AEBEF98009ED4\"));\n  test_hash(&nettle_sha3_224, /* 152 octets */\n\t    SHEX(\"842CC583504539622D7F71E7E31863A2B885C56A0BA62DB4C2A3F2FD12E79660DC7205CA29A0DC0A87DB4DC62EE47A41DB36B9DDB3293B9AC4BAAE7DF5C6E7201E17F717AB56E12CAD476BE49608AD2D50309E7D48D2D8DE4FA58AC3CFEAFEEE48C0A9EEC88498E3EFC51F54D300D828DDDCCB9D0B06DD021A29CF5CB5B2506915BEB8A11998B8B886E0F9B7A80E97D91A7D01270F9A7717\"),\n\t    SHEX(\"5CD017B269A6366C789D9CECAEF3EE9C3575181A084266D78A028DB7\"));\n  test_hash(&nettle_sha3_224, /* 153 octets */\n\t    SHEX(\"6C4B0A0719573E57248661E98FEBE326571F9A1CA813D3638531AE28B4860F23C3A3A8AC1C250034A660E2D71E16D3ACC4BF9CE215C6F15B1C0FC7E77D3D27157E66DA9CEEC9258F8F2BF9E02B4AC93793DD6E29E307EDE3695A0DF63CBDC0FC66FB770813EB149CA2A916911BEE4902C47C7802E69E405FE3C04CEB5522792A5503FA829F707272226621F7C488A7698C0D69AA561BE9F378\"),\n\t    SHEX(\"AC280A211C98A07F6FCBB719F250E3E5A6BA2C93A833976C9F3147EB\"));\n  test_hash(&nettle_sha3_224, /* 154 octets */\n\t    SHEX(\"51B7DBB7CE2FFEB427A91CCFE5218FD40F9E0B7E24756D4C47CD55606008BDC27D16400933906FD9F30EFFDD4880022D081155342AF3FB6CD53672AB7FB5B3A3BCBE47BE1FD3A2278CAE8A5FD61C1433F7D350675DD21803746CADCA574130F01200024C6340AB0CC2CF74F2234669F34E9009EF2EB94823D62B31407F4BA46F1A1EEC41641E84D77727B59E746B8A671BEF936F05BE820759FA\"),\n\t    SHEX(\"C284C9308A28B6D29CCAA7853F8C41BADCDDBC1AA4E99481A6EE2F4D\"));\n  test_hash(&nettle_sha3_224, /* 155 octets */\n\t    SHEX(\"83599D93F5561E821BD01A472386BC2FF4EFBD4AED60D5821E84AAE74D8071029810F5E286F8F17651CD27DA07B1EB4382F754CD1C95268783AD09220F5502840370D494BEB17124220F6AFCE91EC8A0F55231F9652433E5CE3489B727716CF4AEBA7DCDA20CD29AA9A859201253F948DD94395ABA9E3852BD1D60DDA7AE5DC045B283DA006E1CBAD83CC13292A315DB5553305C628DD091146597\"),\n\t    SHEX(\"3D9A979B34D45569E1C98D09DC62D03616C0251C41A8B90138750F1E\"));\n  test_hash(&nettle_sha3_224, /* 156 octets */\n\t    SHEX(\"2BE9BF526C9D5A75D565DD11EF63B979D068659C7F026C08BEA4AF161D85A462D80E45040E91F4165C074C43AC661380311A8CBED59CC8E4C4518E80CD2C78AB1CABF66BFF83EAB3A80148550307310950D034A6286C93A1ECE8929E6385C5E3BB6EA8A7C0FB6D6332E320E71CC4EB462A2A62E2BFE08F0CCAD93E61BEDB5DD0B786A728AB666F07E0576D189C92BF9FB20DCA49AC2D3956D47385E2\"),\n\t    SHEX(\"8DDC9F1E0F94C1247A67D6119A9169762C6C7F1EC7F611D61353AB30\"));\n  test_hash(&nettle_sha3_224, /* 157 octets */\n\t    SHEX(\"CA76D3A12595A817682617006848675547D3E8F50C2210F9AF906C0E7CE50B4460186FE70457A9E879E79FD4D1A688C70A347361C847BA0DD6AA52936EAF8E58A1BE2F5C1C704E20146D366AEB3853BED9DE9BEFE9569AC8AAEA37A9FB7139A1A1A7D5C748605A8DEFB297869EBEDD71D615A5DA23496D11E11ABBB126B206FA0A7797EE7DE117986012D0362DCEF775C2FE145ADA6BDA1CCB326BF644\"),\n\t    SHEX(\"46EDA2622D49B9148B40B6014C75A4086EB9DD4740F0DD591ACA53B2\"));\n  test_hash(&nettle_sha3_224, /* 158 octets */\n\t    SHEX(\"F76B85DC67421025D64E93096D1D712B7BAF7FB001716F02D33B2160C2C882C310EF13A576B1C2D30EF8F78EF8D2F465007109AAD93F74CB9E7D7BEF7C9590E8AF3B267C89C15DB238138C45833C98CC4A471A7802723EF4C744A853CF80A0C2568DD4ED58A2C9644806F42104CEE53628E5BDF7B63B0B338E931E31B87C24B146C6D040605567CEEF5960DF9E022CB469D4C787F4CBA3C544A1AC91F95F\"),\n\t    SHEX(\"57CFA137968C39EAA12533044B8265BB903EC16C8D17B6CF1F106C57\"));\n  test_hash(&nettle_sha3_224, /* 159 octets */\n\t    SHEX(\"25B8C9C032EA6BCD733FFC8718FBB2A503A4EA8F71DEA1176189F694304F0FF68E862A8197B839957549EF243A5279FC2646BD4C009B6D1EDEBF24738197ABB4C992F6B1DC9BA891F570879ACCD5A6B18691A93C7D0A8D38F95B639C1DAEB48C4C2F15CCF5B9D508F8333C32DE78781B41850F261B855C4BEBCC125A380C54D501C5D3BD07E6B52102116088E53D76583B0161E2A58D0778F091206AABD5A1\"),\n\t    SHEX(\"8730C219E19D9D37CB7A63A4DDD55E84DCB0236EF7C8828B2A23C9B9\"));\n  test_hash(&nettle_sha3_224, /* 160 octets */\n\t    SHEX(\"21CFDC2A7CCB7F331B3D2EEFFF37E48AD9FA9C788C3F3C200E0173D99963E1CBCA93623B264E920394AE48BB4C3A5BB96FFBC8F0E53F30E22956ADABC2765F57FB761E147ECBF8567533DB6E50C8A1F894310A94EDF806DD8CA6A0E141C0FA7C9FAE6C6AE65F18C93A8529E6E5B553BF55F25BE2E80A9882BD37F145FECBEB3D447A3C4E46C21524CC55CDD62F521AB92A8BA72B897996C49BB273198B7B1C9E\"),\n\t    SHEX(\"61C01FB4A010F319D193CB6D36063751950A1A8F93539BEA32F84EA1\"));\n  test_hash(&nettle_sha3_224, /* 161 octets */\n\t    SHEX(\"4E452BA42127DCC956EF4F8F35DD68CB225FB73B5BC7E1EC5A898BBA2931563E74FAFF3B67314F241EC49F4A7061E3BD0213AE826BAB380F1F14FAAB8B0EFDDD5FD1BB49373853A08F30553D5A55CCBBB8153DE4704F29CA2BDEEF0419468E05DD51557CCC80C0A96190BBCC4D77ECFF21C66BDF486459D427F986410F883A80A5BCC32C20F0478BB9A97A126FC5F95451E40F292A4614930D054C851ACD019CCF\"),\n\t    SHEX(\"1459044DF9C26F5E240F6A6B9380734CAD84B6592FC9693DDD9F974E\"));\n  test_hash(&nettle_sha3_224, /* 162 octets */\n\t    SHEX(\"FA85671DF7DADF99A6FFEE97A3AB9991671F5629195049880497487867A6C446B60087FAC9A0F2FCC8E3B24E97E42345B93B5F7D3691829D3F8CCD4BB36411B85FC2328EB0C51CB3151F70860AD3246CE0623A8DC8B3C49F958F8690F8E3860E71EB2B1479A5CEA0B3F8BEFD87ACAF5362435EAECCB52F38617BC6C5C2C6E269EAD1FBD69E941D4AD2012DA2C5B21BCFBF98E4A77AB2AF1F3FDA3233F046D38F1DC8\"),\n\t    SHEX(\"EB5CC00173239851F3960EDAC336005109189DFC04B29CA4CDDE5BC1\"));\n  test_hash(&nettle_sha3_224, /* 163 octets */\n\t    SHEX(\"E90847AE6797FBC0B6B36D6E588C0A743D725788CA50B6D792352EA8294F5BA654A15366B8E1B288D84F5178240827975A763BC45C7B0430E8A559DF4488505E009C63DA994F1403F407958203CEBB6E37D89C94A5EACF6039A327F6C4DBBC7A2A307D976AA39E41AF6537243FC218DFA6AB4DD817B6A397DF5CA69107A9198799ED248641B63B42CB4C29BFDD7975AC96EDFC274AC562D0474C60347A078CE4C25E88\"),\n\t    SHEX(\"A640D4841390F47DC47D4BFCF130FCF51C5F2D491F91C13374CE5965\"));\n  test_hash(&nettle_sha3_224, /* 164 octets */\n\t    SHEX(\"F6D5C2B6C93954FC627602C00C4CA9A7D3ED12B27173F0B2C9B0E4A5939398A665E67E69D0B12FB7E4CEB253E8083D1CEB724AC07F009F094E42F2D6F2129489E846EAFF0700A8D4453EF453A3EDDC18F408C77A83275617FABC4EA3A2833AA73406C0E966276079D38E8E38539A70E194CC5513AAA457C699383FD1900B1E72BDFB835D1FD321B37BA80549B078A49EA08152869A918CA57F5B54ED71E4FD3AC5C06729\"),\n\t    SHEX(\"85BB3ED98C4808D8F67C722C9119C54E6543B29E57BD4FB5CBC878C7\"));\n  test_hash(&nettle_sha3_224, /* 165 octets */\n\t    SHEX(\"CF8562B1BED89892D67DDAAF3DEEB28246456E972326DBCDB5CF3FB289ACA01E68DA5D59896E3A6165358B071B304D6AB3D018944BE5049D5E0E2BB819ACF67A6006111089E6767132D72DD85BEDDCBB2D64496DB0CC92955AB4C6234F1EEA24F2D51483F2E209E4589BF9519FAC51B4D061E801125E605F8093BB6997BC163D551596FE4AB7CFAE8FB9A90F6980480CE0C229FD1675409BD788354DAF316240CFE0AF93EB\"),\n\t    SHEX(\"50B7D0ACB93211E0FC935F970BC43A00BE829D6B3C137D4A7E3B2BC1\"));\n  test_hash(&nettle_sha3_224, /* 166 octets */\n\t    SHEX(\"2ACE31ABB0A2E3267944D2F75E1559985DB7354C6E605F18DC8470423FCA30B7331D9B33C4A4326783D1CAAE1B4F07060EFF978E4746BF0C7E30CD61040BD5EC2746B29863EB7F103EBDA614C4291A805B6A4C8214230564A0557BC7102E0BD3ED23719252F7435D64D210EE2AAFC585BE903FA41E1968C50FD5D5367926DF7A05E3A42CF07E656FF92DE73B036CF8B19898C0CB34557C0C12C2D8B84E91181AF467BC75A9D1\"),\n\t    SHEX(\"7CDC1782B39FC0EEB1F874D97C88051CF10508E0875FA173AC41CC8E\"));\n  test_hash(&nettle_sha3_224, /* 167 octets */\n\t    SHEX(\"0D8D09AED19F1013969CE5E7EB92F83A209AE76BE31C754844EA9116CEB39A22EBB6003017BBCF26555FA6624185187DB8F0CB3564B8B1C06BF685D47F3286EDA20B83358F599D2044BBF0583FAB8D78F854FE0A596183230C5EF8E54426750EAF2CC4E29D3BDD037E734D863C2BD9789B4C243096138F7672C232314EFFDFC6513427E2DA76916B5248933BE312EB5DDE4CF70804FB258AC5FB82D58D08177AC6F4756017FFF5\"),\n\t    SHEX(\"EE5D508A4E75900193E99A04B8D838A18DEDFCC431E7AF3182A47DD6\"));\n  test_hash(&nettle_sha3_224, /* 168 octets */\n\t    SHEX(\"C3236B73DEB7662BF3F3DAA58F137B358BA610560EF7455785A9BEFDB035A066E90704F929BD9689CEF0CE3BDA5ACF4480BCEB8D09D10B098AD8500D9B6071DFC3A14AF6C77511D81E3AA8844986C3BEA6F469F9E02194C92868CD5F51646256798FF0424954C1434BDFED9FACB390B07D342E992936E0F88BFD0E884A0DDB679D0547CCDEC6384285A45429D115AC7D235A717242021D1DC35641F5F0A48E8445DBA58E6CB2C8EA\"),\n\t    SHEX(\"5942BA8B58A355F2AEF07E29F8F9971301E877FA32D7025DF552B1EB\"));\n  test_hash(&nettle_sha3_224, /* 169 octets */\n\t    SHEX(\"B39FEB8283EADC63E8184B51DF5AE3FD41AAC8A963BB0BE1CD08AA5867D8D910C669221E73243360646F6553D1CA05A84E8DC0DE05B6419EC349CA994480193D01C92525F3FB3DCEFB08AFC6D26947BDBBFD85193F53B50609C6140905C53A6686B58E53A319A57B962331EDE98149AF3DE3118A819DA4D76706A0424B4E1D2910B0ED26AF61D150EBCB46595D4266A0BD7F651BA47D0C7F179CA28545007D92E8419D48FDFBD744CE\"),\n\t    SHEX(\"29240A9E973888B98A3A836933855D41D8ABB6C3806A626C3DF18F6C\"));\n  test_hash(&nettle_sha3_224, /* 170 octets */\n\t    SHEX(\"A983D54F503803E8C7999F4EDBBE82E9084F422143A932DDDDC47A17B0B7564A7F37A99D0786E99476428D29E29D3C197A72BFAB1342C12A0FC4787FD7017D7A6174049EA43B5779169EF7472BDBBD941DCB82FC73AAC45A8A94C9F2BD3477F61FD3B796F02A1B8264A214C6FEA74B7051B226C722099EC7883A462B83B6AFDD4009248B8A237F605FE5A08FE7D8B45321421EBBA67BD70A0B00DDBF94BAAB7F359D5D1EEA105F28DCFB\"),\n\t    SHEX(\"9AF178B1DD3CEFC96227A289175BB61D9F6B0B352D7804F5E07EA45D\"));\n  test_hash(&nettle_sha3_224, /* 171 octets */\n\t    SHEX(\"E4D1C1897A0A866CE564635B74222F9696BF2C7F640DD78D7E2ACA66E1B61C642BB03EA7536AAE597811E9BF4A7B453EDE31F97B46A5F0EF51A071A2B3918DF16B152519AE3776F9F1EDAB4C2A377C3292E96408359D3613844D5EB393000283D5AD3401A318B12FD1474B8612F2BB50FB6A8B9E023A54D7DDE28C43D6D8854C8D9D1155935C199811DBFC87E9E0072E90EB88681CC7529714F8FB8A2C9D88567ADFB974EE205A9BF7B848\"),\n\t    SHEX(\"F543B4D423EAAC86338BB6D8C6181AD6DC0A25733953CED7EB8377F3\"));\n  test_hash(&nettle_sha3_224, /* 172 octets */\n\t    SHEX(\"B10C59723E3DCADD6D75DF87D0A1580E73133A9B7D00CB95EC19F5547027323BE75158B11F80B6E142C6A78531886D9047B08E551E75E6261E79785366D7024BD7CD9CF322D9BE7D57FB661069F2481C7BB759CD71B4B36CA2BC2DF6D3A328FAEBDB995A9794A8D72155ED551A1F87C80BF6059B43FC764900B18A1C2441F7487743CF84E565F61F8DD2ECE6B6CCC9444049197AAAF53E926FBEE3BFCA8BE588EC77F29D211BE89DE18B15F6\"),\n\t    SHEX(\"77B4079EEE9D9E3FDA051EE0CA430B4DF011D056612C1AF446A187C2\"));\n  test_hash(&nettle_sha3_224, /* 173 octets */\n\t    SHEX(\"DB11F609BABA7B0CA634926B1DD539C8CBADA24967D7ADD4D9876F77C2D80C0F4DCEFBD7121548373582705CCA2495BD2A43716FE64ED26D059CFB566B3364BD49EE0717BDD9810DD14D8FAD80DBBDC4CAFB37CC60FB0FE2A80FB4541B8CA9D59DCE457738A9D3D8F641AF8C3FD6DA162DC16FC01AAC527A4A0255B4D231C0BE50F44F0DB0B713AF03D968FE7F0F61ED0824C55C4B5265548FEBD6AAD5C5EEDF63EFE793489C39B8FD29D104CE\"),\n\t    SHEX(\"987D30120C9AA4964650A6A730E99C86F7FBDDB4EA8D6B4815EE4EBF\"));\n  test_hash(&nettle_sha3_224, /* 174 octets */\n\t    SHEX(\"BEBD4F1A84FC8B15E4452A54BD02D69E304B7F32616AADD90537937106AE4E28DE9D8AAB02D19BC3E2FDE1D651559E296453E4DBA94370A14DBBB2D1D4E2022302EE90E208321EFCD8528AD89E46DC839EA9DF618EA8394A6BFF308E7726BAE0C19BCD4BE52DA6258E2EF4E96AA21244429F49EF5CB486D7FF35CAC1BACB7E95711944BCCB2AB34700D42D1EB38B5D536B947348A458EDE3DC6BD6EC547B1B0CAE5B257BE36A7124E1060C170FFA\"),\n\t    SHEX(\"46193359397BC3EACD69BFF410203583382DE93ECC4D80DCFB4FC51D\"));\n  test_hash(&nettle_sha3_224, /* 175 octets */\n\t    SHEX(\"5ACA56A03A13784BDC3289D9364F79E2A85C12276B49B92DB0ADAA4F206D5028F213F678C3510E111F9DC4C1C1F8B6ACB17A6413AA227607C515C62A733817BA5E762CC6748E7E0D6872C984D723C9BB3B117EB8963185300A80BFA65CDE495D70A46C44858605FCCBED086C2B45CEF963D33294DBE9706B13AF22F1B7C4CD5A001CFEC251FBA18E722C6E1C4B1166918B4F6F48A98B64B3C07FC86A6B17A6D0480AB79D4E6415B520F1C484D675B1\"),\n\t    SHEX(\"0BC29107C7E25D44F8CE83A415B1DE5DF38A6719769606762B7192C2\"));\n  test_hash(&nettle_sha3_224, /* 176 octets */\n\t    SHEX(\"A5AAD0E4646A32C85CFCAC73F02FC5300F1982FABB2F2179E28303E447854094CDFC854310E5C0F60993CEFF54D84D6B46323D930ADB07C17599B35B505F09E784BCA5985E0172257797FB53649E2E9723EFD16865C31B5C3D5113B58BB0BFC8920FABDDA086D7537E66D709D050BD14D0C960873F156FAD5B3D3840CDFCDC9BE6AF519DB262A27F40896AB25CC39F96984D650611C0D5A3080D5B3A1BF186ABD42956588B3B58CD948970D298776060\"),\n\t    SHEX(\"B485644C32283B280179F7C9714350F0B3ACFD7C45A247BF3B6CDB07\"));\n  test_hash(&nettle_sha3_224, /* 177 octets */\n\t    SHEX(\"06CBBE67E94A978203EAD6C057A1A5B098478B4B4CBEF5A97E93C8E42F5572713575FC2A884531D7622F8F879387A859A80F10EF02708CD8F7413AB385AFC357678B9578C0EBF641EF076A1A30F1F75379E9DCB2A885BDD295905EE80C0168A62A9597D10CF12DD2D8CEE46645C7E5A141F6E0E23AA482ABE5661C16E69EF1E28371E2E236C359BA4E92C25626A7B7FF13F6EA4AE906E1CFE163E91719B1F750A96CBDE5FBC953D9E576CD216AFC90323A\"),\n\t    SHEX(\"F384542499EFD23381DEBCD9124C539C40BFA70E517280F56A0920E1\"));\n  test_hash(&nettle_sha3_224, /* 178 octets */\n\t    SHEX(\"F1C528CF7739874707D4D8AD5B98F7C77169DE0B57188DF233B2DC8A5B31EDA5DB4291DD9F68E6BAD37B8D7F6C9C0044B3BF74BBC3D7D1798E138709B0D75E7C593D3CCCDC1B20C7174B4E692ADD820ACE262D45CCFAE2077E878796347168060A162ECCA8C38C1A88350BD63BB539134F700FD4ADDD5959E255337DAA06BC86358FABCBEFDFB5BC889783D843C08AADC6C4F6C36F65F156E851C9A0F917E4A367B5AD93D874812A1DE6A7B93CD53AD97232\"),\n\t    SHEX(\"D12E3884BC8CF9175D1778E8A3AAA119E4A897738F8D81B1278BC448\"));\n  test_hash(&nettle_sha3_224, /* 179 octets */\n\t    SHEX(\"9D9F3A7ECD51B41F6572FD0D0881E30390DFB780991DAE7DB3B47619134718E6F987810E542619DFAA7B505C76B7350C6432D8BF1CFEBDF1069B90A35F0D04CBDF130B0DFC7875F4A4E62CDB8E525AADD7CE842520A482AC18F09442D78305FE85A74E39E760A4837482ED2F437DD13B2EC1042AFCF9DECDC3E877E50FF4106AD10A525230D11920324A81094DA31DEAB6476AA42F20C84843CFC1C58545EE80352BDD3740DD6A16792AE2D86F11641BB717C2\"),\n\t    SHEX(\"D8A348264D48045D4482F3FE002C1A1F36D4DF0D5E47FAC5125C7947\"));\n  test_hash(&nettle_sha3_224, /* 180 octets */\n\t    SHEX(\"5179888724819FBAD3AFA927D3577796660E6A81C52D98E9303261D5A4A83232F6F758934D50AA83FF9E20A5926DFEBAAC49529D006EB923C5AE5048ED544EC471ED7191EDF46363383824F915769B3E688094C682B02151E5EE01E510B431C8865AFF8B6B6F2F59CB6D129DA79E97C6D2B8FA6C6DA3F603199D2D1BCAB547682A81CD6CF65F6551121391D78BCC23B5BD0E922EC6D8BF97C952E84DD28AEF909ABA31EDB903B28FBFC33B7703CD996215A11238\"),\n\t    SHEX(\"6865464C6A230B4BF64BA33BF97459D1D22DAFB19E08F4B7DACE02FF\"));\n  test_hash(&nettle_sha3_224, /* 181 octets */\n\t    SHEX(\"576EF3520D30B7A4899B8C0D5E359E45C5189ADD100E43BE429A02FB3DE5FF4F8FD0E79D9663ACCA72CD29C94582B19292A557C5B1315297D168FBB54E9E2ECD13809C2B5FCE998EDC6570545E1499DBE7FB74D47CD7F35823B212B05BF3F5A79CAA34224FDD670D335FCB106F5D92C3946F44D3AFCBAE2E41AC554D8E6759F332B76BE89A0324AA12C5482D1EA3EE89DED4936F3E3C080436F539FA137E74C6D3389BDF5A45074C47BC7B20B0948407A66D855E2F\"),\n\t    SHEX(\"19D33CD354A13AB2A44044154BD865F117EF8A887FBD0570A8A4CA80\"));\n  test_hash(&nettle_sha3_224, /* 182 octets */\n\t    SHEX(\"0DF2152FA4F4357C8741529DD77E783925D3D76E95BAFA2B542A2C33F3D1D117D159CF473F82310356FEE4C90A9E505E70F8F24859656368BA09381FA245EB6C3D763F3093F0C89B972E66B53D59406D9F01AEA07F8B3B615CAC4EE4D05F542E7D0DAB45D67CCCCD3A606CCBEB31EA1FA7005BA07176E60DAB7D78F6810EF086F42F08E595F0EC217372B98970CC6321576D92CE38F7C397A403BADA1548D205C343AC09DECA86325373C3B76D9F32028FEA8EB32515\"),\n\t    SHEX(\"E438AE4153463B333AE4FE57BF131505C8C04A534A39A20574155E49\"));\n  test_hash(&nettle_sha3_224, /* 183 octets */\n\t    SHEX(\"3E15350D87D6EBB5C8AD99D42515CFE17980933C7A8F6B8BBBF0A63728CEFAAD2052623C0BD5931839112A48633FB3C2004E0749C87A41B26A8B48945539D1FF41A4B269462FD199BFECD45374756F55A9116E92093AC99451AEFB2AF9FD32D6D7F5FBC7F7A540D5097C096EBC3B3A721541DE073A1CC02F7FB0FB1B9327FB0B1218CA49C9487AB5396622A13AE546C97ABDEF6B56380DDA7012A8384091B6656D0AB272D363CEA78163FF765CDD13AB1738B940D16CAE\"),\n\t    SHEX(\"454796C7219C6F7E88508DFC13668B81748211BD016D84B59293B445\"));\n  test_hash(&nettle_sha3_224, /* 184 octets */\n\t    SHEX(\"C38D6B0B757CB552BE40940ECE0009EF3B0B59307C1451686F1A22702922800D58BCE7A636C1727EE547C01B214779E898FC0E560F8AE7F61BEF4D75EAA696B921FD6B735D171535E9EDD267C192B99880C87997711002009095D8A7A437E258104A41A505E5EF71E5613DDD2008195F0C574E6BA3FE40099CFA116E5F1A2FA8A6DA04BADCB4E2D5D0DE31FDC4800891C45781A0AAC7C907B56D631FCA5CE8B2CDE620D11D1777ED9FA603541DE794DDC5758FCD5FAD78C0\"),\n\t    SHEX(\"CE158AED6ED3C9D4432E2422AF8D255AB1F3898F6F5B5C5A1478552C\"));\n  test_hash(&nettle_sha3_224, /* 185 octets */\n\t    SHEX(\"8D2DE3F0B37A6385C90739805B170057F091CD0C7A0BC951540F26A5A75B3E694631BB64C7635EED316F51318E9D8DE13C70A2ABA04A14836855F35E480528B776D0A1E8A23B547C8B8D6A0D09B241D3BE9377160CCA4E6793D00A515DC2992CB7FC741DACA171431DA99CCE6F7789F129E2AC5CF65B40D703035CD2185BB936C82002DAF8CBC27A7A9E554B06196630446A6F0A14BA155ED26D95BD627B7205C072D02B60DB0FD7E49EA058C2E0BA202DAFF0DE91E845CF79\"),\n\t    SHEX(\"A0A21D95E640F13B25652484E244BE1B373E9B0609B685EFCE48107A\"));\n  test_hash(&nettle_sha3_224, /* 186 octets */\n\t    SHEX(\"C464BBDAD275C50DCD983B65AD1019B9FF85A1E71C807F3204BB2C921DC31FBCD8C5FC45868AE9EF85B6C9B83BBA2A5A822201ED68586EC5EC27FB2857A5D1A2D09D09115F22DCC39FE61F5E1BA0FF6E8B4ACB4C6DA748BE7F3F0839739394FF7FA8E39F7F7E84A33C3866875C01BCB1263C9405D91908E9E0B50E7459FABB63D8C6BBB73D8E3483C099B55BC30FF092FF68B6ADEDFD477D63570C9F5515847F36E24BA0B705557130CEC57EBAD1D0B31A378E91894EE26E3A04\"),\n\t    SHEX(\"CA8CB1359F0B05E2FF9414CCE0DE6D2CB4D05B08354C2119A87342CA\"));\n  test_hash(&nettle_sha3_224, /* 187 octets */\n\t    SHEX(\"8B8D68BB8A75732FE272815A68A1C9C5AA31B41DEDC8493E76525D1D013D33CEBD9E21A5BB95DB2616976A8C07FCF411F5F6BC6F7E0B57ACA78CC2790A6F9B898858AC9C79B165FF24E66677531E39F572BE5D81EB3264524181115F32780257BFB9AEEC6AF12AF28E587CAC068A1A2953B59AD680F4C245B2E3EC36F59940D37E1D3DB38E13EDB29B5C0F404F6FF87F80FC8BE7A225FF22FBB9C8B6B1D7330C57840D24BC75B06B80D30DAD6806544D510AF6C4785E823AC3E0B8\"),\n\t    SHEX(\"0DDDD152CF063F0F505B518EB8DB755704F45C9735780EC3A898A923\"));\n  test_hash(&nettle_sha3_224, /* 188 octets */\n\t    SHEX(\"6B018710446F368E7421F1BC0CCF562D9C1843846BC8D98D1C9BF7D9D6FCB48BFC3BF83B36D44C4FA93430AF75CD190BDE36A7F92F867F58A803900DF8018150384D85D82132F123006AC2AEBA58E02A037FE6AFBD65ECA7C44977DD3DC74F48B6E7A1BFD5CC4DCF24E4D52E92BD4455848E4928B0EAC8B7476FE3CC03E862AA4DFF4470DBFED6DE48E410F25096487ECFC32A27277F3F5023B2725ADE461B1355889554A8836C9CF53BD767F5737D55184EEA1AB3F53EDD0976C485\"),\n\t    SHEX(\"57397BB1F84711641E94F413F5D73556B96BA5CFE15F709528626D07\"));\n  test_hash(&nettle_sha3_224, /* 189 octets */\n\t    SHEX(\"C9534A24714BD4BE37C88A3DA1082EDA7CABD154C309D7BD670DCCD95AA535594463058A29F79031D6ECAA9F675D1211E9359BE82669A79C855EA8D89DD38C2C761DDD0EC0CE9E97597432E9A1BEAE062CDD71EDFDFD464119BE9E69D18A7A7FD7CE0E2106F0C8B0ABF4715E2CA48EF9F454DC203C96656653B727083513F8EFB86E49C513BB758B3B052FE21F1C05BB33C37129D6CC81F1AEF6ADC45B0E8827A830FE545CF57D0955802C117D23CCB55EA28F95C0D8C2F9C5A242B33F\"),\n\t    SHEX(\"68F6AC4289FD5214263130830FDA4DA601B88B1F8533EAC07A0338D9\"));\n  test_hash(&nettle_sha3_224, /* 190 octets */\n\t    SHEX(\"07906C87297B867ABF4576E9F3CC7F82F22B154AFCBF293B9319F1B0584DA6A40C27B32E0B1B7F412C4F1B82480E70A9235B12EC27090A5A33175A2BB28D8ADC475CEFE33F7803F8CE27967217381F02E67A3B4F84A71F1C5228E0C2AD971373F6F672624FCEA8D1A9F85170FAD30FA0BBD25035C3B41A6175D467998BD1215F6F3866F53847F9CF68EF3E2FBB54BC994DE2302B829C5EEA68EC441FCBAFD7D16AE4FE9FFF98BF00E5BC2AD54DD91FF9FDA4DD77B6C754A91955D1FBAAD0\"),\n\t    SHEX(\"F145C45212392894E7F1C4E52728470F8A2D961514869990EFBE8232\"));\n  test_hash(&nettle_sha3_224, /* 191 octets */\n\t    SHEX(\"588E94B9054ABC2189DF69B8BA34341B77CDD528E7860E5DEFCAA79B0C9A452AD4B82AA306BE84536EB7CEDCBE058D7B84A6AEF826B028B8A0271B69AC3605A9635EA9F5EA0AA700F3EB7835BC54611B922964300C953EFE7491E3677C2CEBE0822E956CD16433B02C68C4A23252C3F9E151A416B4963257B783E038F6B4D5C9F110F871652C7A649A7BCEDCBCCC6F2D0725BB903CC196BA76C76AA9F10A190B1D1168993BAA9FFC96A1655216773458BEC72B0E39C9F2C121378FEAB4E76A\"),\n\t    SHEX(\"38CE7100E92EE4B65CC831915A06CFC2101990CB68E1004F7E9017D4\"));\n  test_hash(&nettle_sha3_224, /* 192 octets */\n\t    SHEX(\"08959A7E4BAAE874928813364071194E2939772F20DB7C3157078987C557C2A6D5ABE68D520EEF3DC491692E1E21BCD880ADEBF63BB4213B50897FA005256ED41B5690F78F52855C8D9168A4B666FCE2DA2B456D7A7E7C17AB5F2FB1EE90B79E698712E963715983FD07641AE4B4E9DC73203FAC1AE11FA1F8C7941FCC82EAB247ADDB56E2638447E9D609E610B60CE086656AAEBF1DA3C8A231D7D94E2FD0AFE46B391FF14A72EAEB3F44AD4DF85866DEF43D4781A0B3578BC996C87970B132\"),\n\t    SHEX(\"BD63CA84DAC8BC586D0F0BE352DBBBA1F4CB430DEAA8119B8DA13C06\"));\n  test_hash(&nettle_sha3_224, /* 193 octets */\n\t    SHEX(\"CB2A234F45E2ECD5863895A451D389A369AAB99CFEF0D5C9FFCA1E6E63F763B5C14FB9B478313C8E8C0EFEB3AC9500CF5FD93791B789E67EAC12FD038E2547CC8E0FC9DB591F33A1E4907C64A922DDA23EC9827310B306098554A4A78F050262DB5B545B159E1FF1DCA6EB734B872343B842C57EAFCFDA8405EEDBB48EF32E99696D135979235C3A05364E371C2D76F1902F1D83146DF9495C0A6C57D7BF9EE77E80F9787AEE27BE1FE126CDC9EF893A4A7DCBBC367E40FE4E1EE90B42EA25AF01\"),\n\t    SHEX(\"7EE4EAEA6127C68EFCE66991B8F0851FE072DF3B1E0B5D07E3A4BE06\"));\n  test_hash(&nettle_sha3_224, /* 194 octets */\n\t    SHEX(\"D16BEADF02AB1D4DC6F88B8C4554C51E866DF830B89C06E786A5F8757E8909310AF51C840EFE8D20B35331F4355D80F73295974653DDD620CDDE4730FB6C8D0D2DCB2B45D92D4FBDB567C0A3E86BD1A8A795AF26FBF29FC6C65941CDDB090FF7CD230AC5268AB4606FCCBA9EDED0A2B5D014EE0C34F0B2881AC036E24E151BE89EEB6CD9A7A790AFCCFF234D7CB11B99EBF58CD0C589F20BDAC4F9F0E28F75E3E04E5B3DEBCE607A496D848D67FA7B49132C71B878FD5557E082A18ECA1FBDA94D4B\"),\n\t    SHEX(\"7F3EE578B0410687EAF536F9EC7D654B75F504C104B78793C4CF90D5\"));\n  test_hash(&nettle_sha3_224, /* 195 octets */\n\t    SHEX(\"8F65F6BC59A85705016E2BAE7FE57980DE3127E5AB275F573D334F73F8603106EC3553016608EF2DD6E69B24BE0B7113BF6A760BA6E9CE1C48F9E186012CF96A1D4849D75DF5BB8315387FD78E9E153E76F8BA7EC6C8849810F59FB4BB9B004318210B37F1299526866F44059E017E22E96CBE418699D014C6EA01C9F0038B10299884DBEC3199BB05ADC94E955A1533219C1115FED0E5F21228B071F40DD57C4240D98D37B73E412FE0FA4703120D7C0C67972ED233E5DEB300A22605472FA3A3BA86\"),\n\t    SHEX(\"C9C26396E560CD1E6824D9E56E179FCC8AAC4C0D932F7632BA594D4C\"));\n  test_hash(&nettle_sha3_224, /* 196 octets */\n\t    SHEX(\"84891E52E0D451813210C3FD635B39A03A6B7A7317B221A7ABC270DFA946C42669AACBBBDF801E1584F330E28C729847EA14152BD637B3D0F2B38B4BD5BF9C791C58806281103A3EABBAEDE5E711E539E6A8B2CF297CF351C078B4FA8F7F35CF61BEBF8814BF248A01D41E86C5715EA40C63F7375379A7EB1D78F27622FB468AB784AAABA4E534A6DFD1DF6FA15511341E725ED2E87F98737CCB7B6A6DFAE416477472B046BF1811187D151BFA9F7B2BF9ACDB23A3BE507CDF14CFDF517D2CB5FB9E4AB6\"),\n\t    SHEX(\"EF30652E3C6EA4EC214472BF96E5F30DCA1D31A78EB422734615EAF1\"));\n  test_hash(&nettle_sha3_224, /* 197 octets */\n\t    SHEX(\"FDD7A9433A3B4AFABD7A3A5E3457E56DEBF78E84B7A0B0CA0E8C6D53BD0C2DAE31B2700C6128334F43981BE3B213B1D7A118D59C7E6B6493A86F866A1635C12859CFB9AD17460A77B4522A5C1883C3D6ACC86E6162667EC414E9A104AA892053A2B1D72165A855BACD8FAF8034A5DD9B716F47A0818C09BB6BAF22AA503C06B4CA261F557761989D2AFBD88B6A678AD128AF68672107D0F1FC73C5CA740459297B3292B281E93BCEB761BDE7221C3A55708E5EC84472CDDCAA84ECF23723CC0991355C6280\"),\n\t    SHEX(\"5A964BF38EB347684220A3E83EB1EFCB641C8F911CB068A774B25B8C\"));\n  test_hash(&nettle_sha3_224, /* 198 octets */\n\t    SHEX(\"70A40BFBEF92277A1AAD72F6B79D0177197C4EBD432668CFEC05D099ACCB651062B5DFF156C0B27336687A94B26679CFDD9DAF7AD204338DD9C4D14114033A5C225BD11F217B5F4732DA167EE3F939262D4043FC9CBA92303B7B5E96AEA12ADDA64859DF4B86E9EE0B58E39091E6B188B408AC94E1294A8911245EE361E60E601EFF58D1D37639F3753BEC80EBB4EFDE25817436076623FC65415FE51D1B0280366D12C554D86743F3C3B6572E400361A60726131441BA493A83FBE9AFDA90F7AF1AE717238D\"),\n\t    SHEX(\"07413665EDCB8A35021874984910B498CF74823050640243AE7C84CD\"));\n  test_hash(&nettle_sha3_224, /* 199 octets */\n\t    SHEX(\"74356E449F4BF8644F77B14F4D67CB6BD9C1F5AE357621D5B8147E562B65C66585CAF2E491B48529A01A34D226D436959153815380D5689E30B35357CDAC6E08D3F2B0E88E200600D62BD9F5EAF488DF86A4470EA227006182E44809009868C4C280C43D7D64A5268FA719074960087B3A6ABC837882F882C837834535929389A12B2C78187E2EA07EF8B8EEF27DC85002C3AE35F1A50BEE6A1C48BA7E175F3316670B27983472AA6A61EED0A683A39EE323080620EA44A9F74411AE5CE99030528F9AB49C79F2\"),\n\t    SHEX(\"FCC9EAD160832F5F0FAFED6381AFD57FE1335FBFB05B7FB1F0075D37\"));\n  test_hash(&nettle_sha3_224, /* 200 octets */\n\t    SHEX(\"8C3798E51BC68482D7337D3ABB75DC9FFE860714A9AD73551E120059860DDE24AB87327222B64CF774415A70F724CDF270DE3FE47DDA07B61C9EF2A3551F45A5584860248FABDE676E1CD75F6355AA3EAEABE3B51DC813D9FB2EAA4F0F1D9F834D7CAD9C7C695AE84B329385BC0BEF895B9F1EDF44A03D4B410CC23A79A6B62E4F346A5E8DD851C2857995DDBF5B2D717AEB847310E1F6A46AC3D26A7F9B44985AF656D2B7C9406E8A9E8F47DCB4EF6B83CAACF9AEFB6118BFCFF7E44BEF6937EBDDC89186839B77\"),\n\t    SHEX(\"EC5C6DB60B0834FB2E0E7106AEEAFB9E614BE093C847018214D8A5DB\"));\n  test_hash(&nettle_sha3_224, /* 201 octets */\n\t    SHEX(\"FA56BF730C4F8395875189C10C4FB251605757A8FECC31F9737E3C2503B02608E6731E85D7A38393C67DE516B85304824BFB135E33BF22B3A23B913BF6ACD2B7AB85198B8187B2BCD454D5E3318CACB32FD6261C31AE7F6C54EF6A7A2A4C9F3ECB81CE3555D4F0AD466DD4C108A90399D70041997C3B25345A9653F3C9A6711AB1B91D6A9D2216442DA2C973CBD685EE7643BFD77327A2F7AE9CB283620A08716DFB462E5C1D65432CA9D56A90E811443CD1ECB8F0DE179C9CB48BA4F6FEC360C66F252F6E64EDC96B\"),\n\t    SHEX(\"0D5F6DE16B7CBBA49C28654F2AE98163257E7B6B500A3801EEF0733F\"));\n  test_hash(&nettle_sha3_224, /* 202 octets */\n\t    SHEX(\"B6134F9C3E91DD8000740D009DD806240811D51AB1546A974BCB18D344642BAA5CD5903AF84D58EC5BA17301D5EC0F10CCD0509CBB3FD3FFF9172D193AF0F782252FD1338C7244D40E0E42362275B22D01C4C3389F19DD69BDF958EBE28E31A4FFE2B5F18A87831CFB7095F58A87C9FA21DB72BA269379B2DC2384B3DA953C7925761FED324620ACEA435E52B424A7723F6A2357374157A34CD8252351C25A1B232826CEFE1BD3E70FFC15A31E7C0598219D7F00436294D11891B82497BC78AA5363892A2495DF8C1EEF\"),\n\t    SHEX(\"7B7E1FC4D3833ED87FD166F909F5C2566DC0E95B17AC834F1E9E3DAD\"));\n  test_hash(&nettle_sha3_224, /* 203 octets */\n\t    SHEX(\"C941CDB9C28AB0A791F2E5C8E8BB52850626AA89205BEC3A7E22682313D198B1FA33FC7295381354858758AE6C8EC6FAC3245C6E454D16FA2F51C4166FAB51DF272858F2D603770C40987F64442D487AF49CD5C3991CE858EA2A60DAB6A65A34414965933973AC2457089E359160B7CDEDC42F29E10A91921785F6B7224EE0B349393CDCFF6151B50B377D609559923D0984CDA6000829B916AB6896693EF6A2199B3C22F7DC5500A15B8258420E314C222BC000BC4E5413E6DD82C993F8330F5C6D1BE4BC79F08A1A0A46\"),\n\t    SHEX(\"C6AC9D5464855E5C2F83F2A56F9A992137DA47EC05C541295F8C43E7\"));\n  test_hash(&nettle_sha3_224, /* 204 octets */\n\t    SHEX(\"4499EFFFAC4BCEA52747EFD1E4F20B73E48758BE915C88A1FFE5299B0B005837A46B2F20A9CB3C6E64A9E3C564A27C0F1C6AD1960373036EC5BFE1A8FC6A435C2185ED0F114C50E8B3E4C7ED96B06A036819C9463E864A58D6286F785E32A804443A56AF0B4DF6ABC57ED5C2B185DDEE8489EA080DEEEE66AA33C2E6DAB36251C402682B6824821F998C32163164298E1FAFD31BABBCFFB594C91888C6219079D907FDB438ED89529D6D96212FD55ABE20399DBEFD342248507436931CDEAD496EB6E4A80358ACC78647D043\"),\n\t    SHEX(\"4EE2F93C18974D978DD3A1CBF8B1DAC473807067B8807D026182B901\"));\n  test_hash(&nettle_sha3_224, /* 205 octets */\n\t    SHEX(\"EECBB8FDFA4DA62170FD06727F697D81F83F601FF61E478105D3CB7502F2C89BF3E8F56EDD469D049807A38882A7EEFBC85FC9A950952E9FA84B8AFEBD3CE782D4DA598002827B1EB98882EA1F0A8F7AA9CE013A6E9BC462FB66C8D4A18DA21401E1B93356EB12F3725B6DB1684F2300A98B9A119E5D27FF704AFFB618E12708E77E6E5F34139A5A41131FD1D6336C272A8FC37080F041C71341BEE6AB550CB4A20A6DDB6A8E0299F2B14BC730C54B8B1C1C487B494BDCCFD3A53535AB2F231590BF2C4062FD2AD58F906A2D0D\"),\n\t    SHEX(\"D64AEE17ED8E2B85E6B097DB49554D356F032A34A15B7E844EC8D889\"));\n  test_hash(&nettle_sha3_224, /* 206 octets */\n\t    SHEX(\"E64F3E4ACE5C8418D65FEC2BC5D2A303DD458034736E3B0DF719098BE7A206DEAF52D6BA82316CAF330EF852375188CDE2B39CC94AA449578A7E2A8E3F5A9D68E816B8D16889FBC0EBF0939D04F63033AE9AE2BDAB73B88C26D6BD25EE460EE1EF58FB0AFA92CC539F8C76D3D097E7A6A63EBB9B5887EDF3CF076028C5BBD5B9DB3211371AD3FE121D4E9BF44229F4E1ECF5A0F9F0EBA4D5CEB72878AB22C3F0EB5A625323AC66F7061F4A81FAC834471E0C59553F108475FE290D43E6A055AE3EE46FB67422F814A68C4BE3E8C9\"),\n\t    SHEX(\"1BDDC92BE89A672C1BD956B450B9D7B47B4BB0BC58AC51F15F7E054D\"));\n  test_hash(&nettle_sha3_224, /* 207 octets */\n\t    SHEX(\"D2CB2D733033F9E91395312808383CC4F0CA974E87EC68400D52E96B3FA6984AC58D9AD0938DDE5A973008D818C49607D9DE2284E7618F1B8AED8372FBD52ED54557AF4220FAC09DFA8443011699B97D743F8F2B1AEF3537EBB45DCC9E13DFB438428EE190A4EFDB3CAEB7F3933117BF63ABDC7E57BEB4171C7E1AD260AB0587806C4D137B6316B50ABC9CCE0DFF3ACADA47BBB86BE777E617BBE578FF4519844DB360E0A96C6701290E76BB95D26F0F804C8A4F2717EAC4E7DE9F2CFF3BBC55A17E776C0D02856032A6CD10AD2838\"),\n\t    SHEX(\"0C8AC240170C6546DEBF4BFB5B38F8F30EA5DC6EF86C166E8E136D6B\"));\n  test_hash(&nettle_sha3_224, /* 208 octets */\n\t    SHEX(\"F2998955613DD414CC111DF5CE30A995BB792E260B0E37A5B1D942FE90171A4AC2F66D4928D7AD377F4D0554CBF4C523D21F6E5F379D6F4B028CDCB9B1758D3B39663242FF3CB6EDE6A36A6F05DB3BC41E0D861B384B6DEC58BB096D0A422FD542DF175E1BE1571FB52AE66F2D86A2F6824A8CFAACBAC4A7492AD0433EEB15454AF8F312B3B2A577750E3EFBD370E8A8CAC1582581971FBA3BA4BD0D76E718DACF8433D33A59D287F8CC92234E7A271041B526E389EFB0E40B6A18B3AAF658E82ED1C78631FD23B4C3EB27C3FAEC8685\"),\n\t    SHEX(\"2FD9FDFD244B0A7342F886B87B3DDDCE54C8870FB26A71A8F6520231\"));\n  test_hash(&nettle_sha3_224, /* 209 octets */\n\t    SHEX(\"447797E2899B72A356BA55BF4DF3ACCA6CDB1041EB477BD1834A9F9ACBC340A294D729F2F97DF3A610BE0FF15EDB9C6D5DB41644B9874360140FC64F52AA03F0286C8A640670067A84E017926A70438DB1BB361DEFEE7317021425F8821DEF26D1EFD77FC853B818545D055ADC9284796E583C76E6FE74C9AC2587AA46AA8F8804F2FEB5836CC4B3ABABAB8429A5783E17D5999F32242EB59EF30CD7ADABC16D72DBDB097623047C98989F88D14EAF02A7212BE16EC2D07981AAA99949DDF89ECD90333A77BC4E1988A82ABF7C7CAF3291\"),\n\t    SHEX(\"1B6BE19D72199BF75FD4075E54975AFA0433B9BF515BD300CE543D41\"));\n  test_hash(&nettle_sha3_224, /* 210 octets */\n\t    SHEX(\"9F2C18ADE9B380C784E170FB763E9AA205F64303067EB1BCEA93DF5DAC4BF5A2E00B78195F808DF24FC76E26CB7BE31DC35F0844CDED1567BBA29858CFFC97FB29010331B01D6A3FB3159CC1B973D255DA9843E34A0A4061CABDB9ED37F241BFABB3C20D32743F4026B59A4CCC385A2301F83C0B0A190B0F2D01ACB8F0D41111E10F2F4E149379275599A52DC089B35FDD5234B0CFB7B6D8AEBD563CA1FA653C5C021DFD6F5920E6F18BFAFDBECBF0AB00281333ED50B9A999549C1C8F8C63D7626C48322E9791D5FF72294049BDE91E73F8\"),\n\t    SHEX(\"A46B89B64B0C7930DD45F5B2582FD79C7AD90A58C94C52F9BFA55CFC\"));\n  test_hash(&nettle_sha3_224, /* 211 octets */\n\t    SHEX(\"AE159F3FA33619002AE6BCCE8CBBDD7D28E5ED9D61534595C4C9F43C402A9BB31F3B301CBFD4A43CE4C24CD5C9849CC6259ECA90E2A79E01FFBAC07BA0E147FA42676A1D668570E0396387B5BCD599E8E66AAED1B8A191C5A47547F61373021FA6DEADCB55363D233C24440F2C73DBB519F7C9FA5A8962EFD5F6252C0407F190DFEFAD707F3C7007D69FF36B8489A5B6B7C557E79DD4F50C06511F599F56C896B35C917B63BA35C6FF8092BAF7D1658E77FC95D8A6A43EEB4C01F33F03877F92774BE89C1114DD531C011E53A34DC248A2F0E6\"),\n\t    SHEX(\"21F0D8855387241D71A712E5F5682C156B9FD2AA6284294718853F0A\"));\n  test_hash(&nettle_sha3_224, /* 212 octets */\n\t    SHEX(\"3B8E97C5FFC2D6A40FA7DE7FCEFC90F3B12C940E7AB415321E29EE692DFAC799B009C99DCDDB708FCE5A178C5C35EE2B8617143EDC4C40B4D313661F49ABDD93CEA79D117518805496FE6ACF292C4C2A1F76B403A97D7C399DAF85B46AD84E16246C67D6836757BDE336C290D5D401E6C1386AB32797AF6BB251E9B2D8FE754C47482B72E0B394EAB76916126FD68EA7D65EB93D59F5B4C5AC40F7C3B37E7F3694F29424C24AF8C8F0EF59CD9DBF1D28E0E10F799A6F78CAD1D45B9DB3D7DEE4A7059ABE99182714983B9C9D44D7F5643596D4F3\"),\n\t    SHEX(\"82EE85541D7A5B2A2B290003C3EE46574D58A7DDD54FBC210F8FEA57\"));\n  test_hash(&nettle_sha3_224, /* 213 octets */\n\t    SHEX(\"3434EC31B10FAFDBFEEC0DD6BD94E80F7BA9DCA19EF075F7EB017512AF66D6A4BCF7D16BA0819A1892A6372F9B35BCC7CA8155EE19E8428BC22D214856ED5FA9374C3C09BDE169602CC219679F65A1566FC7316F4CC3B631A18FB4449FA6AFA16A3DB2BC4212EFF539C67CF184680826535589C7111D73BFFCE431B4C40492E763D9279560AAA38EB2DC14A212D723F994A1FE656FF4DD14551CE4E7C621B2AA5604A10001B2878A897A28A08095C325E10A26D2FB1A75BFD64C250309BB55A44F23BBAC0D5516A1C687D3B41EF2FBBF9CC56D4739\"),\n\t    SHEX(\"278DD8A3F3208191CFF658B8D6DB35E133A16E47AA375EDB92C6A737\"));\n  test_hash(&nettle_sha3_224, /* 214 octets */\n\t    SHEX(\"7C7953D81C8D208FD1C97681D48F49DD003456DE60475B84070EF4847C333B74575B1FC8D2A186964485A3B8634FEAA3595AAA1A2F4595A7D6B6153563DEE31BBAC443C8A33EED6D5D956A980A68366C2527B550EE950250DFB691EACBD5D56AE14B970668BE174C89DF2FEA43AE52F13142639C884FD62A3683C0C3792F0F24AB1318BCB27E21F4737FAB62C77EA38BC8FD1CF41F7DAB64C13FEBE7152BF5BB7AB5A78F5346D43CC741CB6F72B7B8980F268B68BF62ABDFB1577A52438FE14B591498CC95F071228460C7C5D5CEB4A7BDE588E7F21C\"),\n\t    SHEX(\"B50527711C047DEF70B17CF20F970BED79C1C1B95275C2784C3903DE\"));\n  test_hash(&nettle_sha3_224, /* 215 octets */\n\t    SHEX(\"7A6A4F4FDC59A1D223381AE5AF498D74B7252ECF59E389E49130C7EAEE626E7BD9897EFFD92017F4CCDE66B0440462CDEDFD352D8153E6A4C8D7A0812F701CC737B5178C2556F07111200EB627DBC299CAA792DFA58F35935299FA3A3519E9B03166DFFA159103FFA35E8577F7C0A86C6B46FE13DB8E2CDD9DCFBA85BDDDCCE0A7A8E155F81F712D8E9FE646153D3D22C811BD39F830433B2213DD46301941B59293FD0A33E2B63ADBD95239BC01315C46FDB678875B3C81E053A40F581CFBEC24A1404B1671A1B88A6D06120229518FB13A74CA0AC5AE\"),\n\t    SHEX(\"F77CB5275212C92FA0DAD921B65F50814822E3D6D584C89528990F02\"));\n  test_hash(&nettle_sha3_224, /* 216 octets */\n\t    SHEX(\"D9FAA14CEBE9B7DE551B6C0765409A33938562013B5E8E0E1E0A6418DF7399D0A6A771FB81C3CA9BD3BB8E2951B0BC792525A294EBD1083688806FE5E7F1E17FD4E3A41D00C89E8FCF4A363CAEDB1ACB558E3D562F1302B3D83BB886ED27B76033798131DAB05B4217381EAAA7BA15EC820BB5C13B516DD640EAEC5A27D05FDFCA0F35B3A5312146806B4C0275BCD0AAA3B2017F346975DB566F9B4D137F4EE10644C2A2DA66DEECA5342E236495C3C6280528BFD32E90AF4CD9BB908F34012B52B4BC56D48CC8A6B59BAB014988EABD12E1A0A1C2E170E7\"),\n\t    SHEX(\"76CA9E685DFADC67576D44E8C1A82E8CF7E92FB0A81FE49E21108E09\"));\n  test_hash(&nettle_sha3_224, /* 217 octets */\n\t    SHEX(\"2D8427433D0C61F2D96CFE80CF1E932265A191365C3B61AAA3D6DCC039F6BA2AD52A6A8CC30FC10F705E6B7705105977FA496C1C708A277A124304F1FC40911E7441D1B5E77B951AAD7B01FD5DB1B377D165B05BBF898042E39660CAF8B279FE5229D1A8DB86C0999ED65E53D01CCBC4B43173CCF992B3A14586F6BA42F5FE30AFA8AE40C5DF29966F9346DA5F8B35F16A1DE3AB6DE0F477D8D8660918060E88B9B9E9CA6A4207033B87A812DBF5544D39E4882010F82B6CE005F8E8FF6FE3C3806BC2B73C2B83AFB704345629304F9F86358712E9FAE3CA3E\"),\n\t    SHEX(\"ABD313BC70B7FAB0EBC167D739B54C97389E752EE1A313B12673F51C\"));\n  test_hash(&nettle_sha3_224, /* 218 octets */\n\t    SHEX(\"5E19D97887FCAAC0387E22C6F803C34A3DACD2604172433F7A8A7A526CA4A2A1271ECFC5D5D7BE5AC0D85D921095350DFC65997D443C21C8094E0A3FEFD2961BCB94AED03291AE310CCDA75D8ACE4BC7D89E7D3E5D1650BDA5D668B8B50BFC8E608E184F4D3A9A2BADC4FF5F07E0C0BC8A9F2E0B2A26FD6D8C550008FAAAB75FD71AF2A424BEC9A7CD9D83FAD4C8E9319115656A8717D3B523A68FF8004258B9990ED362308461804BA3E3A7E92D8F2FFAE5C2FBA55BA5A3C27C0A2F71BD711D2FE1799C2ADB31B200035481E9EE5C4ADF2AB9C0FA50B23975CF\"),\n\t    SHEX(\"F79F6356328C580B811FEA81C5ED90A303CAF34A09BEB143BE450D42\"));\n  test_hash(&nettle_sha3_224, /* 219 octets */\n\t    SHEX(\"C8E976AB4638909387CE3B8D4E510C3230E5690E02C45093B1D297910ABC481E56EEA0F296F98379DFC9080AF69E73B2399D1C143BEE80AE1328162CE1BA7F6A8374679B20AACD380EB4E61382C99998704D62701AFA914F9A2705CDB065885F50D086C3EB5753700C387118BB142F3E6DA1E988DFB31AC75D7368931E45D1391A274B22F83CEB072F9BCABC0B216685BFD789F5023971024B1878A205442522F9EA7D8797A4102A3DF41703768251FD5E017C85D1200A464118AA35654E7CA39F3C375B8EF8CBE7534DBC64BC20BEFB417CF60EC92F63D9EE7397\"),\n\t    SHEX(\"299D62F8DF5EADE6871883B033B830A9952A74B12F3D55AF798C6997\"));\n  test_hash(&nettle_sha3_224, /* 220 octets */\n\t    SHEX(\"7145FA124B7429A1FC2231237A949BA7201BCC1822D3272DE005B682398196C25F7E5CC2F289FBF44415F699CB7FE6757791B1443410234AE061EDF623359E2B4E32C19BF88450432DD01CAA5EB16A1DC378F391CA5E3C4E5F356728BDDD4975DB7C890DA8BBC84CC73FF244394D0D48954978765E4A00B593F70F2CA082673A261ED88DBCEF1127728D8CD89BC2C597E9102CED6010F65FA75A14EBE467FA57CE3BD4948B6867D74A9DF5C0EC6F530CBF2EE61CE6F06BC8F2864DFF5583776B31DF8C7FFCB61428A56BF7BD37188B4A5123BBF338393AF46EDA85E6\"),\n\t    SHEX(\"82BA2B8D65E14FDAC51F609F888881DB8070A0B70D7892C009A1AD28\"));\n  test_hash(&nettle_sha3_224, /* 221 octets */\n\t    SHEX(\"7FDFADCC9D29BAD23AE038C6C65CDA1AEF757221B8872ED3D75FF8DF7DA0627D266E224E812C39F7983E4558BFD0A1F2BEF3FEB56BA09120EF762917B9C093867948547AEE98600D10D87B20106878A8D22C64378BF634F7F75900C03986B077B0BF8B740A82447B61B99FEE5376C5EB6680EC9E3088F0BDD0C56883413D60C1357D3C811950E5890E7600103C916341B80C743C6A852B7B4FB60C3BA21F3BC15B8382437A68454779CF3CD7F9F90CCC8EF28D0B706535B1E4108EB5627BB45D719CB046839AEE311CA1ABDC8319E050D67972CB35A6B1601B25DBF487\"),\n\t    SHEX(\"F8E5218DB087D38B1C773247FC22704C1FBDB20B1500E26AFA0B7572\"));\n  test_hash(&nettle_sha3_224, /* 222 octets */\n\t    SHEX(\"988638219FD3095421F826F56E4F09E356296B628C3CE6930C9F2E758FD1A80C8273F2F61E4DAAE65C4F110D3E7CA0965AC7D24E34C0DC4BA2D6FF0BF5BBE93B3585F354D7543CB542A1AA54674D375077F2D360A8F4D42F3DB131C3B7AB7306267BA107659864A90C8C909460A73621D1F5D9D3FD95BEB19B23DB1CB6C0D0FBA91D36891529B8BD8263CAA1BAB56A4AFFAED44962DF096D8D5B1EB845EF31188B3E10F1AF811A13F156BEB7A288AAE593EBD1471B624AA1A7C6ADF01E2200B3D72D88A3AED3100C88231E41EFC376906F0B580DC895F080FDA5741DB1CB\"),\n\t    SHEX(\"FA602F09B28F8679771E9C3966032B80FA2F0F33E84F3ED69BE7AE9C\"));\n  test_hash(&nettle_sha3_224, /* 223 octets */\n\t    SHEX(\"5AAB62756D307A669D146ABA988D9074C5A159B3DE85151A819B117CA1FF6597F6156E80FDD28C9C3176835164D37DA7DA11D94E09ADD770B68A6E081CD22CA0C004BFE7CD283BF43A588DA91F509B27A6584C474A4A2F3EE0F1F56447379240A5AB1FB77FDCA49B305F07BA86B62756FB9EFB4FC225C86845F026EA542076B91A0BC2CDD136E122C659BE259D98E5841DF4C2F60330D4D8CDEE7BF1A0A244524EECC68FF2AEF5BF0069C9E87A11C6E519DE1A4062A10C83837388F7EF58598A3846F49D499682B683C4A062B421594FAFBC1383C943BA83BDEF515EFCF10D\"),\n\t    SHEX(\"C8D7568889DD6FCBC3B8874ED79051875D3CE29102DF0C5DAC8AEB8A\"));\n  test_hash(&nettle_sha3_224, /* 224 octets */\n\t    SHEX(\"47B8216AA0FBB5D67966F2E82C17C07AA2D6327E96FCD83E3DE7333689F3EE79994A1BF45082C4D725ED8D41205CB5BCDF5C341F77FACB1DA46A5B9B2CBC49EADF786BCD881F371A95FA17DF73F606519AEA0FF79D5A11427B98EE7F13A5C00637E2854134691059839121FEA9ABE2CD1BCBBBF27C74CAF3678E05BFB1C949897EA01F56FFA4DAFBE8644611685C617A3206C7A7036E4AC816799F693DAFE7F19F303CE4EBA09D21E03610201BFC665B72400A547A1E00FA9B7AD8D84F84B34AEF118515E74DEF11B9188BD1E1F97D9A12C30132EC2806339BDADACDA2FD8B78\"),\n\t    SHEX(\"D83B06D509D332164087C0C3FA50B2264CB27F66D746B0470166CBC2\"));\n  test_hash(&nettle_sha3_224, /* 225 octets */\n\t    SHEX(\"8CFF1F67FE53C098896D9136389BD8881816CCAB34862BB67A656E3D98896F3CE6FFD4DA73975809FCDF9666760D6E561C55238B205D8049C1CEDEEF374D1735DAA533147BFA960B2CCE4A4F254176BB4D1BD1E89654432B8DBE1A135C42115B394B024856A2A83DC85D6782BE4B444239567CCEC4B184D4548EAE3FF6A192F343292BA2E32A0F267F31CC26719EB85245D415FB897AC2DA433EE91A99424C9D7F1766A44171D1651001C38FC79294ACCC68CEB5665D36218454D3BA169AE058A831338C17743603F81EE173BFC0927464F9BD728DEE94C6AEAB7AAE6EE3A627E8\"),\n\t    SHEX(\"386147B0CF2365346E9846D3F3A7DCEEB6E3665BA7D1593C08B2B582\"));\n  test_hash(&nettle_sha3_224, /* 226 octets */\n\t    SHEX(\"EACD07971CFF9B9939903F8C1D8CBB5D4DB1B548A85D04E037514A583604E787F32992BF2111B97AC5E8A938233552731321522AB5E8583561260B7D13EBEEF785B23A41FD8576A6DA764A8ED6D822D4957A545D5244756C18AA80E1AAD4D1F9C20D259DEE1711E2CC8FD013169FB7CC4CE38B362F8E0936AE9198B7E838DCEA4F7A5B9429BB3F6BBCF2DC92565E3676C1C5E6EB3DD2A0F86AA23EDD3D0891F197447692794B3DFA269611AD97F72B795602B4FDB198F3FD3EB41B415064256E345E8D8C51C555DC8A21904A9B0F1AD0EFFAB7786AAC2DA3B196507E9F33CA356427\"),\n\t    SHEX(\"A69C0C18A712408D8FA2389ACABC3BF6F6412F69783E9F37960D0B56\"));\n  test_hash(&nettle_sha3_224, /* 227 octets */\n\t    SHEX(\"23AC4E9A42C6EF45C3336CE6DFC2FF7DE8884CD23DC912FEF0F7756C09D335C189F3AD3A23697ABDA851A81881A0C8CCAFC980AB2C702564C2BE15FE4C4B9F10DFB2248D0D0CB2E2887FD4598A1D4ACDA897944A2FFC580FF92719C95CF2AA42DC584674CB5A9BC5765B9D6DDF5789791D15F8DD925AA12BFFAFBCE60827B490BB7DF3DDA6F2A143C8BF96ABC903D83D59A791E2D62814A89B8080A28060568CF24A80AE61179FE84E0FFAD00388178CB6A617D37EFD54CC01970A4A41D1A8D3DDCE46EDBBA4AB7C90AD565398D376F431189CE8C1C33E132FEAE6A8CD17A61C630012\"),\n\t    SHEX(\"0699FD35416D83791DC8E656F22718B09DA9E3DF6E7F37A250E22DCD\"));\n  test_hash(&nettle_sha3_224, /* 228 octets */\n\t    SHEX(\"0172DF732282C9D488669C358E3492260CBE91C95CFBC1E3FEA6C4B0EC129B45F242ACE09F152FC6234E1BEE8AAB8CD56E8B486E1DCBA9C05407C2F95DA8D8F1C0AF78EE2ED82A3A79EC0CB0709396EE62AADB84F8A4EE8A7CCCA3C1EE84E302A09EA802204AFECF04097E67D0F8E8A9D2651126C0A598A37081E42D168B0AE8A71951C524259E4E2054E535B779679BDADE566FE55700858618E626B4A0FAF895BCCE9011504A49E05FD56127EAE3D1F8917AFB548ECADABDA1020111FEC9314C413498A360B08640549A22CB23C731ACE743252A8227A0D2689D4C6001606678DFB921\"),\n\t    SHEX(\"BF6A3598A15E28B776229F4D124D403FAD9D0FBC2B7668C95D8B5046\"));\n  test_hash(&nettle_sha3_224, /* 229 octets */\n\t    SHEX(\"3875B9240CF3E0A8B59C658540F26A701CF188496E2C2174788B126FD29402D6A75453BA0635284D08835F40051A2A9683DC92AFB9383719191231170379BA6F4ADC816FECBB0F9C446B785BF520796841E58878B73C58D3EBB097CE4761FDEABE15DE2F319DFBAF1742CDEB389559C788131A6793E193856661376C81CE9568DA19AA6925B47FFD77A43C7A0E758C37D69254909FF0FBD415EF8EB937BCD49F91468B49974C07DC819ABD67395DB0E05874FF83DDDAB895344ABD0E7111B2DF9E58D76D85AD98106B36295826BE04D435615595605E4B4BB824B33C4AFEB5E7BB0D19F909\"),\n\t    SHEX(\"56F8E9F69A399E528996C463D65F20DB41406533C7DF2BA1AFA2494A\"));\n  test_hash(&nettle_sha3_224, /* 230 octets */\n\t    SHEX(\"747CC1A59FEFBA94A9C75BA866C30DC5C1CB0C0F8E9361D98484956DD5D1A40F6184AFBE3DAC9F76028D1CAECCFBF69199C6CE2B4C092A3F4D2A56FE5A33A00757F4D7DEE5DFB0524311A97AE0668A47971B95766E2F6DD48C3F57841F91F04A00AD5EA70F2D479A2620DC5CD78EAAB3A3B011719B7E78D19DDF70D9423798AF77517EBC55392FCD01FC600D8D466B9E7A7A85BF33F9CC5419E9BD874DDFD60981150DDAF8D7FEBAA4374F0872A5628D318000311E2F5655365AD4D407C20E5C04DF17A222E7DEEC79C5AB1116D8572F91CD06E1CCC7CED53736FC867FD49ECEBE6BF8082E8A\"),\n\t    SHEX(\"9904D57DEDB935427F235A0009612235F14E9426B218E028F87B3C0C\"));\n  test_hash(&nettle_sha3_224, /* 231 octets */\n\t    SHEX(\"57AF971FCCAEC97435DC2EC9EF0429BCEDC6B647729EA168858A6E49AC1071E706F4A5A645CA14E8C7746D65511620682C906C8B86EC901F3DDED4167B3F00B06CBFAC6AEE3728051B3E5FF10B4F9ED8BD0B8DA94303C833755B3CA3AEDDF0B54BC8D6632138B5D25BAB03D17B3458A9D782108006F5BB7DE75B5C0BA854B423D8BB801E701E99DC4FEAAD59BC1C7112453B04D33EA3635639FB802C73C2B71D58A56BBD671B18FE34ED2E3DCA38827D63FDB1D4FB3285405004B2B3E26081A8FF08CD6D2B08F8E7B7E90A2AB1ED7A41B1D0128522C2F8BFF56A7FE67969422CE839A9D4608F03\"),\n\t    SHEX(\"FF7013679AB2BE65AEDD09739F56F8DD0072738B86E71A2470476C8C\"));\n  test_hash(&nettle_sha3_224, /* 232 octets */\n\t    SHEX(\"04E16DEDC1227902BAAF332D3D08923601BDD64F573FAA1BB7201918CFE16B1E10151DAE875DA0C0D63C59C3DD050C4C6A874011B018421AFC4623AB0381831B2DA2A8BA42C96E4F70864AC44E106F94311051E74C77C1291BF5DB9539E69567BF6A11CF6932BBBAD33F8946BF5814C066D851633D1A513510039B349939BFD42B858C21827C8FF05F1D09B1B0765DC78A135B5CA4DFBA0801BCADDFA175623C8B647EACFB4444B85A44F73890607D06D507A4F8393658788669F6EF4DEB58D08C50CA0756D5E2F49D1A7AD73E0F0B3D3B5F090ACF622B1878C59133E4A848E05153592EA81C6FBF\"),\n\t    SHEX(\"9DFB6A854A33914EAE1596DCD2BE363A96E7E088BE520F60E5A65C7F\"));\n  test_hash(&nettle_sha3_224, /* 233 octets */\n\t    SHEX(\"7C815C384EEE0F288ECE27CCED52A01603127B079C007378BC5D1E6C5E9E6D1C735723ACBBD5801AC49854B2B569D4472D33F40BBB8882956245C366DC3582D71696A97A4E19557E41E54DEE482A14229005F93AFD2C4A7D8614D10A97A9DFA07F7CD946FA45263063DDD29DB8F9E34DB60DAA32684F0072EA2A9426ECEBFA5239FB67F29C18CBAA2AF6ED4BF4283936823AC1790164FEC5457A9CBA7C767CA59392D94CAB7448F50EB34E9A93A80027471CE59736F099C886DEA1AB4CBA4D89F5FC7AE2F21CCD27F611ECA4626B2D08DC22382E92C1EFB2F6AFDC8FDC3D2172604F5035C46B8197D3\"),\n\t    SHEX(\"C27E80C373B216703D3D9E67223CFC5497C3E74455D49B049AE3F5F4\"));\n  test_hash(&nettle_sha3_224, /* 234 octets */\n\t    SHEX(\"E29D505158DBDD937D9E3D2145658EE6F5992A2FC790F4F608D9CDB44A091D5B94B88E81FAC4FDF5C49442F13B911C55886469629551189EAFF62488F1A479B7DB11A1560E198DDCCCCF50159093425FF7F1CB8D1D1246D0978764087D6BAC257026B090EFAE8CEC5F22B6F21C59ACE1AC7386F5B8837CA6A12B6FBF5534DD0560EF05CA78104D3B943DDB220FEAEC89AA5E692A00F822A2AB9A2FE60350D75E7BE16FF2526DC643872502D01F42F188ABED0A6E9A6F5FD0D1CE7D5755C9FFA66B0AF0B20BD806F08E06156690D81AC811778CA3DAC2C249B96002017FCE93E507E3B953ACF99964B847\"),\n\t    SHEX(\"3A189630F53C567B1C1825794D50DEF901A00E7F3728ECF2BBE00D90\"));\n  test_hash(&nettle_sha3_224, /* 235 octets */\n\t    SHEX(\"D85588696F576E65ECA0155F395F0CFACD83F36A99111ED5768DF2D116D2121E32357BA4F54EDE927F189F297D3A97FAD4E9A0F5B41D8D89DD7FE20156799C2B7B6BF9C957BA0D6763F5C3BC5129747BBB53652B49290CFF1C87E2CDF2C4B95D8AAEE09BC8FBFA6883E62D237885810491BFC101F1D8C636E3D0EDE838AD05C207A3DF4FAD76452979EB99F29AFAECEDD1C63B8D36CF378454A1BB67A741C77AC6B6B3F95F4F02B64DABC15438613EA49750DF42EE90101F115AA9ABB9FF64324DDE9DABBB01054E1BD6B4BCDC7930A44C2300D87CA78C06924D0323AD7887E46C90E8C4D100ACD9EED21E\"),\n\t    SHEX(\"2585BD8D9158D6952BEE95B004F5FED70FAF061B68AB2D6A40469BE7\"));\n  test_hash(&nettle_sha3_224, /* 236 octets */\n\t    SHEX(\"3A12F8508B40C32C74492B66323375DCFE49184C78F73179F3314B79E63376B8AC683F5A51F1534BD729B02B04D002F55CBD8E8FC9B5EC1EA6BBE6A0D0E7431518E6BA45D124035F9D3DCE0A8BB7BF1430A9F657E0B4EA9F20EB20C786A58181A1E20A96F1628F8728A13BDF7A4B4B32FC8AA7054CC4881AE7FA19AFA65C6C3EE1B3ADE3192AF42054A8A911B8EC1826865D46D93F1E7C5E2B7813C92A506E53886F3D4701BB93D2A681AD109C845904BB861AF8AF0646B6E399B38B614051D34F6842563A0F37EC00CB3D865FC5D746C4987DE2A65071100883A2A9C7A2BFE1E2DD603D9EA24DC7C5FD06BE\"),\n\t    SHEX(\"7E64F3C5895D0586CC5B543B27DE1B66A935171E2E7F3CA48DD3718E\"));\n  test_hash(&nettle_sha3_224, /* 237 octets */\n\t    SHEX(\"1861EDCE46FA5AD17E1FF1DEAE084DEC580F97D0A67885DFE834B9DFAC1AE076742CE9E267512CA51F6DF5A455AF0C5FD6ABF94ACEA103A3370C354485A7846FB84F3AC7C2904B5B2FBF227002CE512133BB7E1C4E50057BFD1E44DB33C7CDB969A99E284B184F50A14B068A1FC5009D9B298DBE92239572A7627AAC02ABE8F3E3B473417F36D4D2505D16B7577F4526C9D94A270A2DFE450D06DA8F6FA956879A0A55CFE99E742EA555EA477BA3E9B44CCD508C375423611AF92E55345DC215779B2D5119EBA49C71D49B9FE3F1569FA24E5CA3E332D042422A8B8158D3EC66A80012976F31FFDF305F0C9C5E\"),\n\t    SHEX(\"0F837708E010375AF87F75415ED69988FE60EB2F2669AD051FA99727\"));\n  test_hash(&nettle_sha3_224, /* 238 octets */\n\t    SHEX(\"08D0FFDE3A6E4EF65608EA672E4830C12943D7187CCFF08F4941CFC13E545F3B9C7AD5EEBBE2B01642B486CAF855C2C73F58C1E4E3391DA8E2D63D96E15FD84953AE5C231911B00AD6050CD7AAFDAAC9B0F663AE6AAB45519D0F5391A541707D479034E73A6AD805AE3598096AF078F1393301493D663DD71F83869CA27BA508B7E91E81E128C1716DC3ACFE3084B2201E04CF8006617EECF1B640474A5D45CFDE9F4D3EF92D6D055B909892194D8A8218DB6D8203A84261D200D71473D7488F3427416B6896C137D455F231071CACBC86E0415AB88AEC841D96B7B8AF41E05BB461A40645BF176601F1E760DE5F\"),\n\t    SHEX(\"C79DE39778593810C03583D5962B36E04F343653074766D157A15993\"));\n  test_hash(&nettle_sha3_224, /* 239 octets */\n\t    SHEX(\"D782ABB72A5BE3392757BE02D3E45BE6E2099D6F000D042C8A543F50ED6EBC055A7F133B0DD8E9BC348536EDCAAE2E12EC18E8837DF7A1B3C87EC46D50C241DEE820FD586197552DC20BEEA50F445A07A38F1768A39E2B2FF05DDDEDF751F1DEF612D2E4D810DAA3A0CC904516F9A43AF660315385178A529E51F8AAE141808C8BC5D7B60CAC26BB984AC1890D0436EF780426C547E94A7B08F01ACBFC4A3825EAE04F520A9016F2FB8BF5165ED12736FC71E36A49A73614739EAA3EC834069B1B40F1350C2B3AB885C02C640B9F7686ED5F99527E41CFCD796FE4C256C9173186C226169FF257954EBDA81C0E5F99\"),\n\t    SHEX(\"95CC811CC56521A40E3CED8D9A230E2101E8061FB01E388B9964BF29\"));\n  test_hash(&nettle_sha3_224, /* 240 octets */\n\t    SHEX(\"5FCE8109A358570E40983E1184E541833BB9091E280F258CFB144387B05D190E431CB19BAA67273BA0C58ABE91308E1844DCD0B3678BAA42F335F2FA05267A0240B3C718A5942B3B3E3BFA98A55C25A1466E8D7A603722CB2BBF03AFA54CD769A99F310735EE5A05DAE2C22D397BD95635F58C48A67F90E1B73AAFCD3F82117F0166657838691005B18DA6F341D6E90FC1CDB352B30FAE45D348294E501B63252DE14740F2B85AE5299DDEC3172DE8B6D0BA219A20A23BB5E10FF434D39DB3F583305E9F5C039D98569E377B75A70AB837D1DF269B8A4B566F40BB91B577455FD3C356C914FA06B9A7CE24C7317A172D\"),\n\t    SHEX(\"2EBE13F12EC43E3F6B0506D7AB216E1C311394F7C89D69A920CD00C0\"));\n  test_hash(&nettle_sha3_224, /* 241 octets */\n\t    SHEX(\"6172F1971A6E1E4E6170AFBAD95D5FEC99BF69B24B674BC17DD78011615E502DE6F56B86B1A71D3F4348087218AC7B7D09302993BE272E4A591968AEF18A1262D665610D1070EE91CC8DA36E1F841A69A7A682C580E836941D21D909A3AFC1F0B963E1CA5AB193E124A1A53DF1C587470E5881FB54DAE1B0D840F0C8F9D1B04C645BA1041C7D8DBF22030A623AA15638B3D99A2C400FF76F3252079AF88D2B37F35EE66C1AD7801A28D3D388AC450B97D5F0F79E4541755356B3B1A5696B023F39AB7AB5F28DF4202936BC97393B93BC915CB159EA1BD7A0A414CB4B7A1AC3AF68F50D79F0C9C7314E750F7D02FAA58BFA\"),\n\t    SHEX(\"820101F5435D86E19BEC58ED0E1C7E630FE82DD92D7704E414802A16\"));\n  test_hash(&nettle_sha3_224, /* 242 octets */\n\t    SHEX(\"5668ECD99DFBE215C4118398AC9C9EAF1A1433FAB4CCDD3968064752B625EA944731F75D48A27D047D67547F14DD0FFAA55FA5E29F7AF0D161D85EAFC4F2029B717C918EAB9D304543290BDBA7158B68020C0BA4E079BC95B5BC0FC044A992B94B4CCD3BD66D0EABB5DBBAB904D62E00752C4E3B0091D773BCF4C14B4377DA3EFFF824B1CB2FA01B32D1E46C909E626ED2DAE920F4C7DBEB635BC754FACBD8D49BEBA3F23C1C41CCBFCD0EE0C114E69737F5597C0BF1D859F0C767E18002AE8E39C26261FFDE2920D3D0BAF0E906138696CFE5B7E32B600F45DF3AAA39932F3A7DF95B60FA8712A2271FCAF3911CE7B511B1\"),\n\t    SHEX(\"B1CF54F51F81FDB5B649BB6115126149296278BFF3D5395CF5F112D4\"));\n  test_hash(&nettle_sha3_224, /* 243 octets */\n\t    SHEX(\"03D625488354DF30E3F875A68EDFCF340E8366A8E1AB67F9D5C5486A96829DFAC0578289082B2A62117E1CF418B43B90E0ADC881FC6AE8105C888E9ECD21AEA1C9AE1A4038DFD17378FED71D02AE492087D7CDCD98F746855227967CB1AB4714261EE3BEAD3F4DB118329D3EBEF4BC48A875C19BA763966DA0EBEA800E01B2F50B00E9DD4CACA6DCB314D00184EF71EA2391D760C950710DB4A70F9212FFC54861F9DC752CE18867B8AD0C48DF8466EF7231E7AC567F0EB55099E622EBB86CB237520190A61C66AD34F1F4E289CB3282AE3EAAC6152ED24D2C92BAE5A7658252A53C49B7B02DFE54FDB2E90074B6CF310AC661\"),\n\t    SHEX(\"B602722D1B9F31B9C5091E0FF720F1D1A8A51EB6F95ED3B412DE063D\"));\n  test_hash(&nettle_sha3_224, /* 244 octets */\n\t    SHEX(\"2EDC282FFB90B97118DD03AAA03B145F363905E3CBD2D50ECD692B37BF000185C651D3E9726C690D3773EC1E48510E42B17742B0B0377E7DE6B8F55E00A8A4DB4740CEE6DB0830529DD19617501DC1E9359AA3BCF147E0A76B3AB70C4984C13E339E6806BB35E683AF8527093670859F3D8A0FC7D493BCBA6BB12B5F65E71E705CA5D6C948D66ED3D730B26DB395B3447737C26FAD089AA0AD0E306CB28BF0ACF106F89AF3745F0EC72D534968CCA543CD2CA50C94B1456743254E358C1317C07A07BF2B0ECA438A709367FAFC89A57239028FC5FECFD53B8EF958EF10EE0608B7F5CB9923AD97058EC067700CC746C127A61EE3\"),\n\t    SHEX(\"1368454E849F2D2299077F40826B4072E6FEE49B2062CB8E3B4523C9\"));\n  test_hash(&nettle_sha3_224, /* 245 octets */\n\t    SHEX(\"90B28A6AA1FE533915BCB8E81ED6CACDC10962B7FF82474F845EEB86977600CF70B07BA8E3796141EE340E3FCE842A38A50AFBE90301A3BDCC591F2E7D9DE53E495525560B908C892439990A2CA2679C5539FFDF636777AD9C1CDEF809CDA9E8DCDB451ABB9E9C17EFA4379ABD24B182BD981CAFC792640A183B61694301D04C5B3EAAD694A6BD4CC06EF5DA8FA23B4FA2A64559C5A68397930079D250C51BCF00E2B16A6C49171433B0AADFD80231276560B80458DD77089B7A1BBCC9E7E4B9F881EACD6C92C4318348A13F4914EB27115A1CFC5D16D7FD94954C3532EFACA2CAB025103B2D02C6FD71DA3A77F417D7932685888A\"),\n\t    SHEX(\"5765B70574F93341C1CC4ACB34F645B5D97B81D4CE8F38C3862F6C19\"));\n  test_hash(&nettle_sha3_224, /* 246 octets */\n\t    SHEX(\"2969447D175490F2AA9BB055014DBEF2E6854C95F8D60950BFE8C0BE8DE254C26B2D31B9E4DE9C68C9ADF49E4EE9B1C2850967F29F5D08738483B417BB96B2A56F0C8ACA632B552059C59AAC3F61F7B45C966B75F1D9931FF4E596406378CEE91AAA726A3A84C33F37E9CDBE626B5745A0B06064A8A8D56E53AAF102D23DD9DF0A3FDF7A638509A6761A33FA42FA8DDBD8E16159C93008B53765019C3F0E9F10B144CE2AC57F5D7297F9C9949E4FF68B70D339F87501CE8550B772F32C6DA8AD2CE2100A895D8B08FA1EEAD7C376B407709703C510B50F87E73E43F8E7348F87C3832A547EF2BBE5799ABEDCF5E1F372EA809233F006\"),\n\t    SHEX(\"B8FB318245B4042222B4063A053F15DA6B894F22736F3F9E26F72175\"));\n  test_hash(&nettle_sha3_224, /* 247 octets */\n\t    SHEX(\"721645633A44A2C78B19024EAECF58575AB23C27190833C26875DC0F0D50B46AEA9C343D82EA7D5B3E50EC700545C615DAEAEA64726A0F05607576DCD396D812B03FB6551C641087856D050B10E6A4D5577B82A98AFB89CEE8594C9DC19E79FEFF0382FCFD127F1B803A4B9946F4AC9A4378E1E6E041B1389A53E3450CD32D9D2941B0CBABDB50DA8EA2513145164C3AB6BCBD251C448D2D4B087AC57A59C2285D564F16DA4ED5E607ED979592146FFB0EF3F3DB308FB342DF5EB5924A48256FC763141A278814C82D6D6348577545870AE3A83C7230AC02A1540FE1798F7EF09E335A865A2AE0949B21E4F748FB8A51F44750E213A8FB\"),\n\t    SHEX(\"353622E92C7907F5563BAF8F4E7AF0C2F872F4FB583B01AF9EB3D907\"));\n  test_hash(&nettle_sha3_224, /* 248 octets */\n\t    SHEX(\"6B860D39725A14B498BB714574B4D37CA787404768F64C648B1751B353AC92BAC2C3A28EA909FDF0423336401A02E63EC24325300D823B6864BB701F9D7C7A1F8EC9D0AE3584AA6DD62EA1997CD831B4BABD9A4DA50932D4EFDA745C61E4130890E156AEE6113716DAF95764222A91187DB2EFFEA49D5D0596102D619BD26A616BBFDA8335505FBB0D90B4C180D1A2335B91538E1668F9F9642790B4E55F9CAB0FE2BDD2935D001EE6419ABAB5457880D0DBFF20ED8758F4C20FE759EFB33141CF0E892587FE8187E5FBC57786B7E8B089612C936DFC03D27EFBBE7C8673F1606BD51D5FF386F4A7AB68EDF59F385EB1291F117BFE717399\"),\n\t    SHEX(\"87215AF73D5CDE98B355479AFB82A511180B7DC3D5342C88E133AED8\"));\n  test_hash(&nettle_sha3_224, /* 249 octets */\n\t    SHEX(\"6A01830AF3889A25183244DECB508BD01253D5B508AB490D3124AFBF42626B2E70894E9B562B288D0A2450CFACF14A0DDAE5C04716E5A0082C33981F6037D23D5E045EE1EF2283FB8B6378A914C5D9441627A722C282FF452E25A7EA608D69CEE4393A0725D17963D0342684F255496D8A18C2961145315130549311FC07F0312FB78E6077334F87EAA873BEE8AA95698996EB21375EB2B4EF53C14401207DEB4568398E5DD9A7CF97E8C9663E23334B46912F8344C19EFCF8C2BA6F04325F1A27E062B62A58D0766FC6DB4D2C6A1928604B0175D872D16B7908EBC041761187CC785526C2A3873FEAC3A642BB39F5351550AF9770C328AF7B\"),\n\t    SHEX(\"25AE852DBA36B8D58A94DD5CFD8345141FF57E7DB7D7816C4F7252BB\"));\n  test_hash(&nettle_sha3_224, /* 250 octets */\n\t    SHEX(\"B3C5E74B69933C2533106C563B4CA20238F2B6E675E8681E34A389894785BDADE59652D4A73D80A5C85BD454FD1E9FFDAD1C3815F5038E9EF432AAC5C3C4FE840CC370CF86580A6011778BBEDAF511A51B56D1A2EB68394AA299E26DA9ADA6A2F39B9FAFF7FBA457689B9C1A577B2A1E505FDF75C7A0A64B1DF81B3A356001BF0DF4E02A1FC59F651C9D585EC6224BB279C6BEBA2966E8882D68376081B987468E7AED1EF90EBD090AE825795CDCA1B4F09A979C8DFC21A48D8A53CDBB26C4DB547FC06EFE2F9850EDD2685A4661CB4911F165D4B63EF25B87D0A96D3DFF6AB0758999AAD214D07BD4F133A6734FDE445FE474711B69A98F7E2B\"),\n\t    SHEX(\"ECE0394418F066F55023797551E06F6A7D1645682AA4D9DD75AF8E76\"));\n  test_hash(&nettle_sha3_224, /* 251 octets */\n\t    SHEX(\"83AF34279CCB5430FEBEC07A81950D30F4B66F484826AFEE7456F0071A51E1BBC55570B5CC7EC6F9309C17BF5BEFDD7C6BA6E968CF218A2B34BD5CF927AB846E38A40BBD81759E9E33381016A755F699DF35D660007B5EADF292FEEFB735207EBF70B5BD17834F7BFA0E16CB219AD4AF524AB1EA37334AA66435E5D397FC0A065C411EBBCE32C240B90476D307CE802EC82C1C49BC1BEC48C0675EC2A6C6F3ED3E5B741D13437095707C565E10D8A20B8C20468FF9514FCF31B4249CD82DCEE58C0A2AF538B291A87E3390D737191A07484A5D3F3FB8C8F15CE056E5E5F8FEBE5E1FB59D6740980AA06CA8A0C20F5712B4CDE5D032E92AB89F0AE1\"),\n\t    SHEX(\"84A4BD2E3FA26C4FB01FE81953398F5B4B5704944354B51B887FD990\"));\n  test_hash(&nettle_sha3_224, /* 252 octets */\n\t    SHEX(\"A7ED84749CCC56BB1DFBA57119D279D412B8A986886D810F067AF349E8749E9EA746A60B03742636C464FC1EE233ACC52C1983914692B64309EDFDF29F1AB912EC3E8DA074D3F1D231511F5756F0B6EEAD3E89A6A88FE330A10FACE267BFFBFC3E3090C7FD9A850561F363AD75EA881E7244F80FF55802D5EF7A1A4E7B89FCFA80F16DF54D1B056EE637E6964B9E0FFD15B6196BDD7DB270C56B47251485348E49813B4EB9ED122A01B3EA45AD5E1A929DF61D5C0F3E77E1FDC356B63883A60E9CBB9FC3E00C2F32DBD469659883F690C6772E335F617BC33F161D6F6984252EE12E62B6000AC5231E0C9BC65BE223D8DFD94C5004A101AF9FD6C0FB\"),\n\t    SHEX(\"170C413863D9F4E8C0B87A8532416B10A69C348D3A144658EAEEF0ED\"));\n  test_hash(&nettle_sha3_224, /* 253 octets */\n\t    SHEX(\"A6FE30DCFCDA1A329E82AB50E32B5F50EB25C873C5D2305860A835AECEE6264AA36A47429922C4B8B3AFD00DA16035830EDB897831C4E7B00F2C23FC0B15FDC30D85FB70C30C431C638E1A25B51CAF1D7E8B050B7F89BFB30F59F0F20FECFF3D639ABC4255B3868FC45DD81E47EB12AB40F2AAC735DF5D1DC1AD997CEFC4D836B854CEE9AC02900036F3867FE0D84AFFF37BDE3308C2206C62C4743375094108877C73B87B2546FE05EA137BEDFC06A2796274099A0D554DA8F7D7223A48CBF31B7DECAA1EBC8B145763E3673168C1B1B715C1CD99ECD3DDB238B06049885ECAD9347C2436DFF32C771F34A38587A44A82C5D3D137A03CAA27E66C8FF6\"),\n\t    SHEX(\"D8C257DB76536F7EF1DCFB24976EB716D9491CD8651E0254E7C4A5BB\"));\n  test_hash(&nettle_sha3_224, /* 254 octets */\n\t    SHEX(\"83167FF53704C3AA19E9FB3303539759C46DD4091A52DDAE9AD86408B69335989E61414BC20AB4D01220E35241EFF5C9522B079FBA597674C8D716FE441E566110B6211531CECCF8FD06BC8E511D00785E57788ED9A1C5C73524F01830D2E1148C92D0EDC97113E3B7B5CD3049627ABDB8B39DD4D6890E0EE91993F92B03354A88F52251C546E64434D9C3D74544F23FB93E5A2D2F1FB15545B4E1367C97335B0291944C8B730AD3D4789273FA44FB98D78A36C3C3764ABEEAC7C569C1E43A352E5B770C3504F87090DEE075A1C4C85C0C39CF421BDCC615F9EFF6CB4FE6468004AECE5F30E1ECC6DB22AD9939BB2B0CCC96521DFBF4AE008B5B46BC006E\"),\n\t    SHEX(\"F81D8EE40869BB38A13A4F75588FA3308068DD1CDC27267D66FAC198\"));\n  test_hash(&nettle_sha3_224, /* 255 octets */\n\t    SHEX(\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\"),\n\t    SHEX(\"94689EA9F347DDA8DD798A858605868743C6BD03A6A65C6085D52BED\"));\n}",
      "lines": 773,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha3-256-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Extracted from ShortMsgKAT_256.txt using sha3.awk. */\n  test_hash(&nettle_sha3_256, /* 0 octets */\n\t    SHEX(\"\"),\n\t    SHEX(\"A7FFC6F8BF1ED76651C14756A061D662F580FF4DE43B49FA82D80A4B80F8434A\"));\n  test_hash(&nettle_sha3_256, /* 1 octets */\n\t    SHEX(\"CC\"),\n\t    SHEX(\"677035391CD3701293D385F037BA32796252BB7CE180B00B582DD9B20AAAD7F0\"));\n  test_hash(&nettle_sha3_256, /* 2 octets */\n\t    SHEX(\"41FB\"),\n\t    SHEX(\"39F31B6E653DFCD9CAED2602FD87F61B6254F581312FB6EEEC4D7148FA2E72AA\"));\n  test_hash(&nettle_sha3_256, /* 3 octets */\n\t    SHEX(\"1F877C\"),\n\t    SHEX(\"BC22345E4BD3F792A341CF18AC0789F1C9C966712A501B19D1B6632CCD408EC5\"));\n  test_hash(&nettle_sha3_256, /* 4 octets */\n\t    SHEX(\"C1ECFDFC\"),\n\t    SHEX(\"C5859BE82560CC8789133F7C834A6EE628E351E504E601E8059A0667FF62C124\"));\n  test_hash(&nettle_sha3_256, /* 5 octets */\n\t    SHEX(\"21F134AC57\"),\n\t    SHEX(\"55BD9224AF4EED0D121149E37FF4D7DD5BE24BD9FBE56E0171E87DB7A6F4E06D\"));\n  test_hash(&nettle_sha3_256, /* 6 octets */\n\t    SHEX(\"C6F50BB74E29\"),\n\t    SHEX(\"AE0CBC757D4AB088E172ABFD8746289950F92D38A25295658DBF744B5635AF04\"));\n  test_hash(&nettle_sha3_256, /* 7 octets */\n\t    SHEX(\"119713CC83EEEF\"),\n\t    SHEX(\"E340C9A44373EFCC212F3CB66A047AC34C87FF1C58C4A14B16A2BFC34698BB1D\"));\n  test_hash(&nettle_sha3_256, /* 8 octets */\n\t    SHEX(\"4A4F202484512526\"),\n\t    SHEX(\"BA4FB009D57A5CEB85FC64D54E5C55A55854B41CC47AD15294BC41F32165DFBA\"));\n  test_hash(&nettle_sha3_256, /* 9 octets */\n\t    SHEX(\"1F66AB4185ED9B6375\"),\n\t    SHEX(\"B9886EF905C8BDD272EDA8298865E0769869F1C964460D1AA9D7A0C687707CCD\"));\n  test_hash(&nettle_sha3_256, /* 10 octets */\n\t    SHEX(\"EED7422227613B6F53C9\"),\n\t    SHEX(\"FAB8F88D3191E21A725B21C63A02CAD3FA7C450EF8584B94CFA382F393422455\"));\n  test_hash(&nettle_sha3_256, /* 11 octets */\n\t    SHEX(\"EAEED5CDFFD89DECE455F1\"),\n\t    SHEX(\"9363ACD3F48BB91A8998AA0E8DF75C971770A16A71E7D2334409734CD7D0A9EE\"));\n  test_hash(&nettle_sha3_256, /* 12 octets */\n\t    SHEX(\"5BE43C90F22902E4FE8ED2D3\"),\n\t    SHEX(\"16932F6F65DEAAD5780E25AB410C66B0E4198EBA9F4ED1A25EE24F7879FAEFE2\"));\n  test_hash(&nettle_sha3_256, /* 13 octets */\n\t    SHEX(\"A746273228122F381C3B46E4F1\"),\n\t    SHEX(\"1C28100E0EF50671C7EA3E024FA3BA9DA2EBDDB4DE264C3A2426C36AD3F91C61\"));\n  test_hash(&nettle_sha3_256, /* 14 octets */\n\t    SHEX(\"3C5871CD619C69A63B540EB5A625\"),\n\t    SHEX(\"8183BE4875FAB7EC5F99ED94F5F900CF1D6B953D8F71E1E7CC008687980E613A\"));\n  test_hash(&nettle_sha3_256, /* 15 octets */\n\t    SHEX(\"FA22874BCC068879E8EF11A69F0722\"),\n\t    SHEX(\"3B1A6D21FE44691DAC4EB7C593A6D8523CB606E63CF00E94D711A574248DACA5\"));\n  test_hash(&nettle_sha3_256, /* 16 octets */\n\t    SHEX(\"52A608AB21CCDD8A4457A57EDE782176\"),\n\t    SHEX(\"2C7E7CB356FDC68EC8927E499D2A6BAE2B781817919C829EBBE8225BAED46967\"));\n  test_hash(&nettle_sha3_256, /* 17 octets */\n\t    SHEX(\"82E192E4043DDCD12ECF52969D0F807EED\"),\n\t    SHEX(\"C7B12EFF692D842110CC39AC60616707ACB3F9B0F1CB361B94577EFC529CA26C\"));\n  test_hash(&nettle_sha3_256, /* 18 octets */\n\t    SHEX(\"75683DCB556140C522543BB6E9098B21A21E\"),\n\t    SHEX(\"493EBAEBC04776F4E067555AFA09B58C850FDF1B0E22D4BF006CE41C091DC762\"));\n  test_hash(&nettle_sha3_256, /* 19 octets */\n\t    SHEX(\"06E4EFE45035E61FAAF4287B4D8D1F12CA97E5\"),\n\t    SHEX(\"1D01F3120ECFBDD28DCE44317666CF864F52391B9ECA3843DB45667C2E0A98AD\"));\n  test_hash(&nettle_sha3_256, /* 20 octets */\n\t    SHEX(\"E26193989D06568FE688E75540AEA06747D9F851\"),\n\t    SHEX(\"2C1E61E5D45203F27B86F1293A80BAB34192DAF42B8623B12005B2FB1C18ACB1\"));\n  test_hash(&nettle_sha3_256, /* 21 octets */\n\t    SHEX(\"D8DC8FDEFBDCE9D44E4CBAFE78447BAE3B5436102A\"),\n\t    SHEX(\"AD0E3F29767067E929D1CECD95582DF8F2A9BEB92EAA27EEB315F620365A9244\"));\n  test_hash(&nettle_sha3_256, /* 22 octets */\n\t    SHEX(\"57085FD7E14216AB102D8317B0CB338A786D5FC32D8F\"),\n\t    SHEX(\"2B4EB5DE20E86074CABB55BFA63A5C8C6AE15679302061845B9CF233E17C906B\"));\n  test_hash(&nettle_sha3_256, /* 23 octets */\n\t    SHEX(\"A05404DF5DBB57697E2C16FA29DEFAC8AB3560D6126FA0\"),\n\t    SHEX(\"6AE04C6C6F3651F1F64C0AD69733990B41747C93F87ACB813BB25BB1FC0EFF07\"));\n  test_hash(&nettle_sha3_256, /* 24 octets */\n\t    SHEX(\"AECBB02759F7433D6FCB06963C74061CD83B5B3FFA6F13C6\"),\n\t    SHEX(\"40F9F55BC55DA466BC3DC1F89835A64094572DE73D64ED6646A1D3B667BE70A9\"));\n  test_hash(&nettle_sha3_256, /* 25 octets */\n\t    SHEX(\"AAFDC9243D3D4A096558A360CC27C8D862F0BE73DB5E88AA55\"),\n\t    SHEX(\"C64BECF7B75FC885D5853924F2B7D37ABCEFD3DA126BB817697E1A09152B1EBE\"));\n  test_hash(&nettle_sha3_256, /* 26 octets */\n\t    SHEX(\"7BC84867F6F9E9FDC3E1046CAE3A52C77ED485860EE260E30B15\"),\n\t    SHEX(\"57D46A6BC8FAB33601538DAD27F98C66443032CC3912434C28EB88D0AF44C52C\"));\n  test_hash(&nettle_sha3_256, /* 27 octets */\n\t    SHEX(\"FAC523575A99EC48279A7A459E98FF901918A475034327EFB55843\"),\n\t    SHEX(\"7C956503D5B4DBB764FF8E66FA74CE0F9132DA90EA3543F669C9DD08E413E33C\"));\n  test_hash(&nettle_sha3_256, /* 28 octets */\n\t    SHEX(\"0F8B2D8FCFD9D68CFFC17CCFB117709B53D26462A3F346FB7C79B85E\"),\n\t    SHEX(\"6DE164A9626D5A4F54D854AC158994F35A8E362ECC753F55182790934A2E0D06\"));\n  test_hash(&nettle_sha3_256, /* 29 octets */\n\t    SHEX(\"A963C3E895FF5A0BE4824400518D81412F875FA50521E26E85EAC90C04\"),\n\t    SHEX(\"B760312BD1B279FC672479D21C5ED349E5FE96F08940237B4515452721C49A16\"));\n  test_hash(&nettle_sha3_256, /* 30 octets */\n\t    SHEX(\"03A18688B10CC0EDF83ADF0A84808A9718383C4070C6C4F295098699AC2C\"),\n\t    SHEX(\"94FC255DE4EF19C0DA4B09B2E2FAC21F20048B46F17C30685ABE40D5C743F375\"));\n  test_hash(&nettle_sha3_256, /* 31 octets */\n\t    SHEX(\"84FB51B517DF6C5ACCB5D022F8F28DA09B10232D42320FFC32DBECC3835B29\"),\n\t    SHEX(\"39A4A0FFC4603698AE0A4F3D24B1BC42AC7A2D7D923E7A5D602453E82D5323C5\"));\n  test_hash(&nettle_sha3_256, /* 32 octets */\n\t    SHEX(\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\"),\n\t    SHEX(\"2F1A5F7159E34EA19CDDC70EBF9B81F1A66DB40615D7EAD3CC1F1B954D82A3AF\"));\n  test_hash(&nettle_sha3_256, /* 33 octets */\n\t    SHEX(\"DE8F1B3FAA4B7040ED4563C3B8E598253178E87E4D0DF75E4FF2F2DEDD5A0BE046\"),\n\t    SHEX(\"1C57FE0E38CD3A124EAA6CD87F70A079BCCC073A341E8C0EB1976FB3A3F7B774\"));\n  test_hash(&nettle_sha3_256, /* 34 octets */\n\t    SHEX(\"62F154EC394D0BC757D045C798C8B87A00E0655D0481A7D2D9FB58D93AEDC676B5A0\"),\n\t    SHEX(\"A905603B186EF4F2D5B2D1BCFDA504C68ED5EB9B0C7B7EA2A001575F5AA69E68\"));\n  test_hash(&nettle_sha3_256, /* 35 octets */\n\t    SHEX(\"B2DCFE9FF19E2B23CE7DA2A4207D3E5EC7C6112A8A22AEC9675A886378E14E5BFBAD4E\"),\n\t    SHEX(\"FFFD39F7C451788EB0316F429EA0A7C0AC8091657ACA28F1560ED5775E8C4C12\"));\n  test_hash(&nettle_sha3_256, /* 36 octets */\n\t    SHEX(\"47F5697AC8C31409C0868827347A613A3562041C633CF1F1F86865A576E02835ED2C2492\"),\n\t    SHEX(\"6F55BECD168E0939BA2FA090257B1727FC66491A44493279A5BEACB9E3435324\"));\n  test_hash(&nettle_sha3_256, /* 37 octets */\n\t    SHEX(\"512A6D292E67ECB2FE486BFE92660953A75484FF4C4F2ECA2B0AF0EDCDD4339C6B2EE4E542\"),\n\t    SHEX(\"84649BFFCD48527B9288E8DA5F52FBAB2604DC5A91C4B0B87D477DBD7B40B6AE\"));\n  test_hash(&nettle_sha3_256, /* 38 octets */\n\t    SHEX(\"973CF2B4DCF0BFA872B41194CB05BB4E16760A1840D8343301802576197EC19E2A1493D8F4FB\"),\n\t    SHEX(\"D4055B4E3E2AEA1C67CC99FD409D574E53E1E296CF9EEF73C472AB92A6CB6609\"));\n  test_hash(&nettle_sha3_256, /* 39 octets */\n\t    SHEX(\"80BEEBCD2E3F8A9451D4499961C9731AE667CDC24EA020CE3B9AA4BBC0A7F79E30A934467DA4B0\"),\n\t    SHEX(\"5694CA2F3B9962226A87163AB38325BCDC898A732DFEB2C36DB4EB88616B8741\"));\n  test_hash(&nettle_sha3_256, /* 40 octets */\n\t    SHEX(\"7ABAA12EC2A7347674E444140AE0FB659D08E1C66DECD8D6EAE925FA451D65F3C0308E29446B8ED3\"),\n\t    SHEX(\"8CF287AD03AB4A74086620CFA4CCE74F48FA5CDB15EC02B1F721736A4F849E60\"));\n  test_hash(&nettle_sha3_256, /* 41 octets */\n\t    SHEX(\"C88DEE9927679B8AF422ABCBACF283B904FF31E1CAC58C7819809F65D5807D46723B20F67BA610C2B7\"),\n\t    SHEX(\"C5D5AF22A4DF9ACD0C056FA30D8E240B679A20D4D2630260F779FF815CA82D7D\"));\n  test_hash(&nettle_sha3_256, /* 42 octets */\n\t    SHEX(\"01E43FE350FCEC450EC9B102053E6B5D56E09896E0DDD9074FE138E6038210270C834CE6EADC2BB86BF6\"),\n\t    SHEX(\"0AC75279ADFF65660464550A283FECD4E0610D88F35574C3D7AC5D22262A2FE8\"));\n  test_hash(&nettle_sha3_256, /* 43 octets */\n\t    SHEX(\"337023370A48B62EE43546F17C4EF2BF8D7ECD1D49F90BAB604B839C2E6E5BD21540D29BA27AB8E309A4B7\"),\n\t    SHEX(\"81917AE290DBBA17289A8A67E5C2E8B12D3DDE0EFE9F990198A1763FF4F3DDA7\"));\n  test_hash(&nettle_sha3_256, /* 44 octets */\n\t    SHEX(\"6892540F964C8C74BD2DB02C0AD884510CB38AFD4438AF31FC912756F3EFEC6B32B58EBC38FC2A6B913596A8\"),\n\t    SHEX(\"138E75E72FDDD927E591315AF8D3ABA280EFA36230A3309A97BCDE5A78C31589\"));\n  test_hash(&nettle_sha3_256, /* 45 octets */\n\t    SHEX(\"F5961DFD2B1FFFFDA4FFBF30560C165BFEDAB8CE0BE525845DEB8DC61004B7DB38467205F5DCFB34A2ACFE96C0\"),\n\t    SHEX(\"21BCDAD3FEF3E5B859CB0912A2991EFA661BAD812747292EF0F79A8FCC6B4E98\"));\n  test_hash(&nettle_sha3_256, /* 46 octets */\n\t    SHEX(\"CA061A2EB6CEED8881CE2057172D869D73A1951E63D57261384B80CEB5451E77B06CF0F5A0EA15CA907EE1C27EBA\"),\n\t    SHEX(\"8D6FD9C559B0B4948F91337916084C0082A16A0755B0A00811096E973E48B3C8\"));\n  test_hash(&nettle_sha3_256, /* 47 octets */\n\t    SHEX(\"1743A77251D69242750C4F1140532CD3C33F9B5CCDF7514E8584D4A5F9FBD730BCF84D0D4726364B9BF95AB251D9BB\"),\n\t    SHEX(\"1DD23AE7AADD61E712BDD82BD60A70DD9D66C9FD79DBFD8669E3EAABF7901CDC\"));\n  test_hash(&nettle_sha3_256, /* 48 octets */\n\t    SHEX(\"D8FABA1F5194C4DB5F176FABFFF856924EF627A37CD08CF55608BBA8F1E324D7C7F157298EABC4DCE7D89CE5162499F9\"),\n\t    SHEX(\"34F8607EC10C092C1BA0B6565CE6197062C4E1A35A8E8C723E48A2D2416C3790\"));\n  test_hash(&nettle_sha3_256, /* 49 octets */\n\t    SHEX(\"BE9684BE70340860373C9C482BA517E899FC81BAAA12E5C6D7727975D1D41BA8BEF788CDB5CF4606C9C1C7F61AED59F97D\"),\n\t    SHEX(\"19A8577FC90FAE5D6A6B2E0C1FF155515502CFA1757029C09BEBBFA263D9A363\"));\n  test_hash(&nettle_sha3_256, /* 50 octets */\n\t    SHEX(\"7E15D2B9EA74CA60F66C8DFAB377D9198B7B16DEB6A1BA0EA3C7EE2042F89D3786E779CF053C77785AA9E692F821F14A7F51\"),\n\t    SHEX(\"9D9DBB4CE7D01D009E72A66051ACC16805E49F598CBE430C5D4C22A881A64B3F\"));\n  test_hash(&nettle_sha3_256, /* 51 octets */\n\t    SHEX(\"9A219BE43713BD578015E9FDA66C0F2D83CAC563B776AB9F38F3E4F7EF229CB443304FBA401EFB2BDBD7ECE939102298651C86\"),\n\t    SHEX(\"13F0D951B64481135466CFCCBE52418CC1D03FB16B5B696C35D724F6F55CBB6D\"));\n  test_hash(&nettle_sha3_256, /* 52 octets */\n\t    SHEX(\"C8F2B693BD0D75EF99CAEBDC22ADF4088A95A3542F637203E283BBC3268780E787D68D28CC3897452F6A22AA8573CCEBF245972A\"),\n\t    SHEX(\"FB2FE7B00B75C42305CF31DE14D98F904E8C46DC57BB6F94C282CA8C13DC45DB\"));\n  test_hash(&nettle_sha3_256, /* 53 octets */\n\t    SHEX(\"EC0F99711016C6A2A07AD80D16427506CE6F441059FD269442BAAA28C6CA037B22EEAC49D5D894C0BF66219F2C08E9D0E8AB21DE52\"),\n\t    SHEX(\"D54CBF7D5C80AE11A0D0BAD4E95AB18B5F07C970621F3936447A48EEF818D06E\"));\n  test_hash(&nettle_sha3_256, /* 54 octets */\n\t    SHEX(\"0DC45181337CA32A8222FE7A3BF42FC9F89744259CFF653504D6051FE84B1A7FFD20CB47D4696CE212A686BB9BE9A8AB1C697B6D6A33\"),\n\t    SHEX(\"FF050A45ADEEF4CFC7D964102BA877C80320A37794893E6865965EC2547CD4C9\"));\n  test_hash(&nettle_sha3_256, /* 55 octets */\n\t    SHEX(\"DE286BA4206E8B005714F80FB1CDFAEBDE91D29F84603E4A3EBC04686F99A46C9E880B96C574825582E8812A26E5A857FFC6579F63742F\"),\n\t    SHEX(\"1BC1BCC70F638958DB1006AF37B02EBD8954EC59B3ACBAD12EACEDBC5B21E908\"));\n  test_hash(&nettle_sha3_256, /* 56 octets */\n\t    SHEX(\"EEBCC18057252CBF3F9C070F1A73213356D5D4BC19AC2A411EC8CDEEE7A571E2E20EAF61FD0C33A0FFEB297DDB77A97F0A415347DB66BCAF\"),\n\t    SHEX(\"F7BDE239AD087AA7DABE42CC4D3C49380A026CD239A7FAAF34A2233469A44A4D\"));\n  test_hash(&nettle_sha3_256, /* 57 octets */\n\t    SHEX(\"416B5CDC9FE951BD361BD7ABFC120A5054758EBA88FDD68FD84E39D3B09AC25497D36B43CBE7B85A6A3CEBDA8DB4E5549C3EE51BB6FCB6AC1E\"),\n\t    SHEX(\"EF845AAC2AAF0A793108204FF380E0A30F2558E7ACDE4531AB22F8EC79E26A69\"));\n  test_hash(&nettle_sha3_256, /* 58 octets */\n\t    SHEX(\"5C5FAF66F32E0F8311C32E8DA8284A4ED60891A5A7E50FB2956B3CBAA79FC66CA376460E100415401FC2B8518C64502F187EA14BFC9503759705\"),\n\t    SHEX(\"26DB514E01E034C678B636D40BA367DA2F37F67078BB576FF2B8559B3517484D\"));\n  test_hash(&nettle_sha3_256, /* 59 octets */\n\t    SHEX(\"7167E1E02BE1A7CA69D788666F823AE4EEF39271F3C26A5CF7CEE05BCA83161066DC2E217B330DF821103799DF6D74810EED363ADC4AB99F36046A\"),\n\t    SHEX(\"5DBD4B558463196211465C1FC32401FC2D8E41EBC5E6BADD1D8F7C4F090F728F\"));\n  test_hash(&nettle_sha3_256, /* 60 octets */\n\t    SHEX(\"2FDA311DBBA27321C5329510FAE6948F03210B76D43E7448D1689A063877B6D14C4F6D0EAA96C150051371F7DD8A4119F7DA5C483CC3E6723C01FB7D\"),\n\t    SHEX(\"355C79FD6E6FA88ED402B6979FDE1ED805498ABEB101F4231B5D64D1439D552D\"));\n  test_hash(&nettle_sha3_256, /* 61 octets */\n\t    SHEX(\"95D1474A5AAB5D2422ACA6E481187833A6212BD2D0F91451A67DD786DFC91DFED51B35F47E1DEB8A8AB4B9CB67B70179CC26F553AE7B569969CE151B8D\"),\n\t    SHEX(\"3D9C9BF09D88211C7E0056112D073EE85D00ACAA4DA7A668FA017B3273CD4D4B\"));\n  test_hash(&nettle_sha3_256, /* 62 octets */\n\t    SHEX(\"C71BD7941F41DF044A2927A8FF55B4B467C33D089F0988AA253D294ADDBDB32530C0D4208B10D9959823F0C0F0734684006DF79F7099870F6BF53211A88D\"),\n\t    SHEX(\"67980D28E2E658E7A24A2593A28167A13D907D06F47729D47CA4FE1772F8B3DF\"));\n  test_hash(&nettle_sha3_256, /* 63 octets */\n\t    SHEX(\"F57C64006D9EA761892E145C99DF1B24640883DA79D9ED5262859DCDA8C3C32E05B03D984F1AB4A230242AB6B78D368DC5AAA1E6D3498D53371E84B0C1D4BA\"),\n\t    SHEX(\"A8DF6B76DF41994F7593F1A81967E77EE180E31183D1C4A569DB854E61E99B05\"));\n  test_hash(&nettle_sha3_256, /* 64 octets */\n\t    SHEX(\"E926AE8B0AF6E53176DBFFCC2A6B88C6BD765F939D3D178A9BDE9EF3AA131C61E31C1E42CDFAF4B4DCDE579A37E150EFBEF5555B4C1CB40439D835A724E2FAE7\"),\n\t    SHEX(\"27A6441EE939B46E2C378D7AFEB0E891C47A28120E488EFF0AB71AF08788CEB3\"));\n  test_hash(&nettle_sha3_256, /* 65 octets */\n\t    SHEX(\"16E8B3D8F988E9BB04DE9C96F2627811C973CE4A5296B4772CA3EEFEB80A652BDF21F50DF79F32DB23F9F73D393B2D57D9A0297F7A2F2E79CFDA39FA393DF1AC00\"),\n\t    SHEX(\"C4BB067383002DB44CA773918BB74104B604A583E12B06BE56C270F8B43512F2\"));\n  test_hash(&nettle_sha3_256, /* 66 octets */\n\t    SHEX(\"FC424EEB27C18A11C01F39C555D8B78A805B88DBA1DC2A42ED5E2C0EC737FF68B2456D80EB85E11714FA3F8EABFB906D3C17964CB4F5E76B29C1765DB03D91BE37FC\"),\n\t    SHEX(\"AE773915CA642D80413330C9E0EE9BD06653C0023C5C0277100F3B1526EAA51D\"));\n  test_hash(&nettle_sha3_256, /* 67 octets */\n\t    SHEX(\"ABE3472B54E72734BDBA7D9158736464251C4F21B33FBBC92D7FAC9A35C4E3322FF01D2380CBAA4EF8FB07D21A2128B7B9F5B6D9F34E13F39C7FFC2E72E47888599BA5\"),\n\t    SHEX(\"1CF9D6CE9CB658556B76CD7EBA3E51393699AD500B1AB3F56172748DB7F59667\"));\n  test_hash(&nettle_sha3_256, /* 68 octets */\n\t    SHEX(\"36F9F0A65F2CA498D739B944D6EFF3DA5EBBA57E7D9C41598A2B0E4380F3CF4B479EC2348D015FFE6256273511154AFCF3B4B4BF09D6C4744FDD0F62D75079D440706B05\"),\n\t    SHEX(\"8D60E889E2B1020DAD4B523301F5F6BBAB6C781AF276085AF6765546FCFB95AC\"));\n  test_hash(&nettle_sha3_256, /* 69 octets */\n\t    SHEX(\"ABC87763CAE1CA98BD8C5B82CABA54AC83286F87E9610128AE4DE68AC95DF5E329C360717BD349F26B872528492CA7C94C2C1E1EF56B74DBB65C2AC351981FDB31D06C77A4\"),\n\t    SHEX(\"DD4FF4B530552F48AF9A7530A6464819ED1A5B733084F709E41DAF1ACB35ECFD\"));\n  test_hash(&nettle_sha3_256, /* 70 octets */\n\t    SHEX(\"94F7CA8E1A54234C6D53CC734BB3D3150C8BA8C5F880EAB8D25FED13793A9701EBE320509286FD8E422E931D99C98DA4DF7E70AE447BAB8CFFD92382D8A77760A259FC4FBD72\"),\n\t    SHEX(\"7AC8D4BB53FC434DD8712DAEFEB474668F541418E6F617DBA523D8392EB0766E\"));\n  test_hash(&nettle_sha3_256, /* 71 octets */\n\t    SHEX(\"13BD2811F6ED2B6F04FF3895ACEED7BEF8DCD45EB121791BC194A0F806206BFFC3B9281C2B308B1A729CE008119DD3066E9378ACDCC50A98A82E20738800B6CDDBE5FE9694AD6D\"),\n\t    SHEX(\"F7B0E15A63232A2B800B23B311D357617DDFD1293E1FFE3F772692ADE3427152\"));\n  test_hash(&nettle_sha3_256, /* 72 octets */\n\t    SHEX(\"1EED9CBA179A009EC2EC5508773DD305477CA117E6D569E66B5F64C6BC64801CE25A8424CE4A26D575B8A6FB10EAD3FD1992EDDDEEC2EBE7150DC98F63ADC3237EF57B91397AA8A7\"),\n\t    SHEX(\"B3D05AF7E8C406A7C2709223791D3F5F4B3129329993220053A36293AC2B0E06\"));\n  test_hash(&nettle_sha3_256, /* 73 octets */\n\t    SHEX(\"BA5B67B5EC3A3FFAE2C19DD8176A2EF75C0CD903725D45C9CB7009A900C0B0CA7A2967A95AE68269A6DBF8466C7B6844A1D608AC661F7EFF00538E323DB5F2C644B78B2D48DE1A08AA\"),\n\t    SHEX(\"6C47E2EA4BA29E17792DEFC4B707754C4664BDE15168A5100BF881EC7C02B258\"));\n  test_hash(&nettle_sha3_256, /* 74 octets */\n\t    SHEX(\"0EFA26AC5673167DCACAB860932ED612F65FF49B80FA9AE65465E5542CB62075DF1C5AE54FBA4DB807BE25B070033EFA223BDD5B1D3C94C6E1909C02B620D4B1B3A6C9FED24D70749604\"),\n\t    SHEX(\"82A66BED668DCC14AF12C14C976CE650049E9D1D9969B83D1DD3B6F1C07D252B\"));\n  test_hash(&nettle_sha3_256, /* 75 octets */\n\t    SHEX(\"BBFD933D1FD7BF594AC7F435277DC17D8D5A5B8E4D13D96D2F64E771ABBD51A5A8AEA741BECCBDDB177BCEA05243EBD003CFDEAE877CCA4DA94605B67691919D8B033F77D384CA01593C1B\"),\n\t    SHEX(\"2F21D07D7B10683B9AC7A63E9FCC70CF9F887CB905F9BFF5332551288B288524\"));\n  test_hash(&nettle_sha3_256, /* 76 octets */\n\t    SHEX(\"90078999FD3C35B8AFBF4066CBDE335891365F0FC75C1286CDD88FA51FAB94F9B8DEF7C9AC582A5DBCD95817AFB7D1B48F63704E19C2BAA4DF347F48D4A6D603013C23F1E9611D595EBAC37C\"),\n\t    SHEX(\"80202F01E7140DB4FEE490DCC50AFAFDF6A48CA33D362C7875B8E8DB9C9D0655\"));\n  test_hash(&nettle_sha3_256, /* 77 octets */\n\t    SHEX(\"64105ECA863515C20E7CFBAA0A0B8809046164F374D691CDBD6508AAABC1819F9AC84B52BAFC1B0FE7CDDBC554B608C01C8904C669D8DB316A0953A4C68ECE324EC5A49FFDB59A1BD6A292AA0E\"),\n\t    SHEX(\"B2330A189047E3117479A2F20B3407A7D119E4AD431FE06FF1FF2A106F2AB3A2\"));\n  test_hash(&nettle_sha3_256, /* 78 octets */\n\t    SHEX(\"D4654BE288B9F3B711C2D02015978A8CC57471D5680A092AA534F7372C71CEAAB725A383C4FCF4D8DEAA57FCA3CE056F312961ECCF9B86F14981BA5BED6AB5B4498E1F6C82C6CAE6FC14845B3C8A\"),\n\t    SHEX(\"BB9B9BB685C241F8D63FDBF0DBAABCEF7075ADD7BA405A2FFFE7AD5B23E021C7\"));\n  test_hash(&nettle_sha3_256, /* 79 octets */\n\t    SHEX(\"12D9394888305AC96E65F2BF0E1B18C29C90FE9D714DD59F651F52B88B3008C588435548066EA2FC4C101118C91F32556224A540DE6EFDDBCA296EF1FB00341F5B01FECFC146BDB251B3BDAD556CD2\"),\n\t    SHEX(\"F8316A367AA0316DA3562F319D522E81F4A8BD2E2108D2532126F4A903704BA3\"));\n  test_hash(&nettle_sha3_256, /* 80 octets */\n\t    SHEX(\"871A0D7A5F36C3DA1DFCE57ACD8AB8487C274FAD336BC137EBD6FF4658B547C1DCFAB65F037AA58F35EF16AFF4ABE77BA61F65826F7BE681B5B6D5A1EA8085E2AE9CD5CF0991878A311B549A6D6AF230\"),\n\t    SHEX(\"89E3EBD02B229CD759612A5521D867AB2A1594BC0B1FE6A78B7954CCC84CAF03\"));\n  test_hash(&nettle_sha3_256, /* 81 octets */\n\t    SHEX(\"E90B4FFEF4D457BC7711FF4AA72231CA25AF6B2E206F8BF859D8758B89A7CD36105DB2538D06DA83BAD5F663BA11A5F6F61F236FD5F8D53C5E89F183A3CEC615B50C7C681E773D109FF7491B5CC22296C5\"),\n\t    SHEX(\"2E7CC875305EA6BB9C2FC770B9D84FD93B96405DF9B93307F6B5DE26E135724C\"));\n  test_hash(&nettle_sha3_256, /* 82 octets */\n\t    SHEX(\"E728DE62D75856500C4C77A428612CD804F30C3F10D36FB219C5CA0AA30726AB190E5F3F279E0733D77E7267C17BE27D21650A9A4D1E32F649627638DBADA9702C7CA303269ED14014B2F3CF8B894EAC8554\"),\n\t    SHEX(\"ECAB75F28A728429CB433EC13310D1B850CCF522C38D2FA6DFA489963D6D6CA7\"));\n  test_hash(&nettle_sha3_256, /* 83 octets */\n\t    SHEX(\"6348F229E7B1DF3B770C77544E5166E081850FA1C6C88169DB74C76E42EB983FACB276AD6A0D1FA7B50D3E3B6FCD799EC97470920A7ABED47D288FF883E24CA21C7F8016B93BB9B9E078BDB9703D2B781B616E\"),\n\t    SHEX(\"021C9459D1451F3DA4C07C029A8681945C87C5BEBC6C30DA1D95C5C49D8AB95C\"));\n  test_hash(&nettle_sha3_256, /* 84 octets */\n\t    SHEX(\"4B127FDE5DE733A1680C2790363627E63AC8A3F1B4707D982CAEA258655D9BF18F89AFE54127482BA01E08845594B671306A025C9A5C5B6F93B0A39522DC877437BE5C2436CBF300CE7AB6747934FCFC30AEAAF6\"),\n\t    SHEX(\"4642E21622F15B09B9413659680116BF2F96CAC2384B8C79F1328D5DD36D7A01\"));\n  test_hash(&nettle_sha3_256, /* 85 octets */\n\t    SHEX(\"08461F006CFF4CC64B752C957287E5A0FAABC05C9BFF89D23FD902D324C79903B48FCB8F8F4B01F3E4DDB483593D25F000386698F5ADE7FAADE9615FDC50D32785EA51D49894E45BAA3DC707E224688C6408B68B11\"),\n\t    SHEX(\"8DAA47C3572157266AD0276D5926AFF2872F06B0CD7B974A80D7A6827D41D782\"));\n  test_hash(&nettle_sha3_256, /* 86 octets */\n\t    SHEX(\"68C8F8849B120E6E0C9969A5866AF591A829B92F33CD9A4A3196957A148C49138E1E2F5C7619A6D5EDEBE995ACD81EC8BB9C7B9CFCA678D081EA9E25A75D39DB04E18D475920CE828B94E72241F24DB72546B352A0E4\"),\n\t    SHEX(\"345365232CE9AFC655DCE4BAC23F43C8ACBDF9016D4BC2344BE8D396A4919C34\"));\n  test_hash(&nettle_sha3_256, /* 87 octets */\n\t    SHEX(\"B8D56472954E31FB54E28FCA743F84D8DC34891CB564C64B08F7B71636DEBD64CA1EDBDBA7FC5C3E40049CE982BBA8C7E0703034E331384695E9DE76B5104F2FBC4535ECBEEBC33BC27F29F18F6F27E8023B0FBB6F563C\"),\n\t    SHEX(\"F52E102E57293878C28F29DEB47792324FE455A62FA7441AABCC16A9CFC40FFA\"));\n  test_hash(&nettle_sha3_256, /* 88 octets */\n\t    SHEX(\"0D58AC665FA84342E60CEFEE31B1A4EACDB092F122DFC68309077AED1F3E528F578859EE9E4CEFB4A728E946324927B675CD4F4AC84F64DB3DACFE850C1DD18744C74CECCD9FE4DC214085108F404EAB6D8F452B5442A47D\"),\n\t    SHEX(\"2B89AA88B1B7F9F8EA461C4C5CAE4829125F45F5697DEADB8DB2E964524C0D91\"));\n  test_hash(&nettle_sha3_256, /* 89 octets */\n\t    SHEX(\"1755E2D2E5D1C1B0156456B539753FF416651D44698E87002DCF61DCFA2B4E72F264D9AD591DF1FDEE7B41B2EB00283C5AEBB3411323B672EAA145C5125185104F20F335804B02325B6DEA65603F349F4D5D8B782DD3469CCD\"),\n\t    SHEX(\"3F3092365982C0B4278055BEEE9032FF9D1060E03C3B087E1A6197DEFC707E1A\"));\n  test_hash(&nettle_sha3_256, /* 90 octets */\n\t    SHEX(\"B180DE1A611111EE7584BA2C4B020598CD574AC77E404E853D15A101C6F5A2E5C801D7D85DC95286A1804C870BB9F00FD4DCB03AA8328275158819DCAD7253F3E3D237AEAA7979268A5DB1C6CE08A9EC7C2579783C8AFC1F91A7\"),\n\t    SHEX(\"3C74AAE2F340A24178CBAB51004CBA1AAC3D91133C300715EA82C177269C0556\"));\n  test_hash(&nettle_sha3_256, /* 91 octets */\n\t    SHEX(\"CF3583CBDFD4CBC17063B1E7D90B02F0E6E2EE05F99D77E24E560392535E47E05077157F96813544A17046914F9EFB64762A23CF7A49FE52A0A4C01C630CFE8727B81FB99A89FF7CC11DCA5173057E0417B8FE7A9EFBA6D95C555F\"),\n\t    SHEX(\"0157C4BA44618DED11E9800AFA07A0D5B6C711FC16A576C5EDB71C4CC6894F82\"));\n  test_hash(&nettle_sha3_256, /* 92 octets */\n\t    SHEX(\"072FC02340EF99115BAD72F92C01E4C093B9599F6CFC45CB380EE686CB5EB019E806AB9BD55E634AB10AA62A9510CC0672CD3EDDB589C7DF2B67FCD3329F61B1A4441ECA87A33C8F55DA4FBBAD5CF2B2527B8E983BB31A2FADEC7523\"),\n\t    SHEX(\"8D53DBA107AAACB8422D6667F6778839F8965F8E4C8F4A851284CC91168A9030\"));\n  test_hash(&nettle_sha3_256, /* 93 octets */\n\t    SHEX(\"76EECF956A52649F877528146DE33DF249CD800E21830F65E90F0F25CA9D6540FDE40603230ECA6760F1139C7F268DEBA2060631EEA92B1FFF05F93FD5572FBE29579ECD48BC3A8D6C2EB4A6B26E38D6C5FBF2C08044AEEA470A8F2F26\"),\n\t    SHEX(\"5163F02233E332AD9BE32C2346C9FCFE39AFA5FBE9BC1CFEB92F4920155B20EC\"));\n  test_hash(&nettle_sha3_256, /* 94 octets */\n\t    SHEX(\"7ADC0B6693E61C269F278E6944A5A2D8300981E40022F839AC644387BFAC9086650085C2CDC585FEA47B9D2E52D65A2B29A7DC370401EF5D60DD0D21F9E2B90FAE919319B14B8C5565B0423CEFB827D5F1203302A9D01523498A4DB10374\"),\n\t    SHEX(\"FAAF0E95217CA4B1568751EF2E4CD341D9EC33E16600BF09B92C6F1A6DF84D2E\"));\n  test_hash(&nettle_sha3_256, /* 95 octets */\n\t    SHEX(\"E1FFFA9826CCE8B86BCCEFB8794E48C46CDF372013F782ECED1E378269B7BE2B7BF51374092261AE120E822BE685F2E7A83664BCFBE38FE8633F24E633FFE1988E1BC5ACF59A587079A57A910BDA60060E85B5F5B6F776F0529639D9CCE4BD\"),\n\t    SHEX(\"B2C175D9D92AAA9EE72672F995B8DFD2DAAF6555A0327A508218A9B447F00BE8\"));\n  test_hash(&nettle_sha3_256, /* 96 octets */\n\t    SHEX(\"69F9ABBA65592EE01DB4DCE52DBAB90B08FC04193602792EE4DAA263033D59081587B09BBE49D0B49C9825D22840B2FF5D9C5155F975F8F2C2E7A90C75D2E4A8040FE39F63BBAFB403D9E28CC3B86E04E394A9C9E8065BD3C85FA9F0C7891600\"),\n\t    SHEX(\"FB5388122306D37CEE790CAD1D3CDDBA8E9A93D5F9D78288B052482739C883FD\"));\n  test_hash(&nettle_sha3_256, /* 97 octets */\n\t    SHEX(\"38A10A352CA5AEDFA8E19C64787D8E9C3A75DBF3B8674BFAB29B5DBFC15A63D10FAE66CD1A6E6D2452D557967EAAD89A4C98449787B0B3164CA5B717A93F24EB0B506CEB70CBBCB8D72B2A72993F909AAD92F044E0B5A2C9AC9CB16A0CA2F81F49\"),\n\t    SHEX(\"1C2F8D418FF6718B18DD4C756DCC8ED0F4755E8C22497A6CC19F8D7AE7FD2DA7\"));\n  test_hash(&nettle_sha3_256, /* 98 octets */\n\t    SHEX(\"6D8C6E449BC13634F115749C248C17CD148B72157A2C37BF8969EA83B4D6BA8C0EE2711C28EE11495F43049596520CE436004B026B6C1F7292B9C436B055CBB72D530D860D1276A1502A5140E3C3F54A93663E4D20EDEC32D284E25564F624955B52\"),\n\t    SHEX(\"7EA8116E6434C1CAA049069DBBD9B6F0E9DC6CDFD6A889343D3B2652803078FC\"));\n  test_hash(&nettle_sha3_256, /* 99 octets */\n\t    SHEX(\"6EFCBCAF451C129DBE00B9CEF0C3749D3EE9D41C7BD500ADE40CDC65DEDBBBADB885A5B14B32A0C0D087825201E303288A733842FA7E599C0C514E078F05C821C7A4498B01C40032E9F1872A1C925FA17CE253E8935E4C3C71282242CB716B2089CCC1\"),\n\t    SHEX(\"736D888751FAAC4D8E78B45B95ABB15D40D98D8038C7225BE0F523D5439EA5B6\"));\n  test_hash(&nettle_sha3_256, /* 100 octets */\n\t    SHEX(\"433C5303131624C0021D868A30825475E8D0BD3052A022180398F4CA4423B98214B6BEAAC21C8807A2C33F8C93BD42B092CC1B06CEDF3224D5ED1EC29784444F22E08A55AA58542B524B02CD3D5D5F6907AFE71C5D7462224A3F9D9E53E7E0846DCBB4CE\"),\n\t    SHEX(\"90E10B1CA8D352794D7DBD7BAE410BEF25F0EC7D080E053F48674237E33EA45F\"));\n  test_hash(&nettle_sha3_256, /* 101 octets */\n\t    SHEX(\"A873E0C67CA639026B6683008F7AA6324D4979550E9BCE064CA1E1FB97A30B147A24F3F666C0A72D71348EDE701CF2D17E2253C34D1EC3B647DBCEF2F879F4EB881C4830B791378C901EB725EA5C172316C6D606E0AF7DF4DF7F76E490CD30B2BADF45685F\"),\n\t    SHEX(\"8A0A8D6D55CCCBE05EC74DC273B16D66C9B9006665EECB5B6023D2EA39C64554\"));\n  test_hash(&nettle_sha3_256, /* 102 octets */\n\t    SHEX(\"006917B64F9DCDF1D2D87C8A6173B64F6587168E80FAA80F82D84F60301E561E312D9FBCE62F39A6FB476E01E925F26BCC91DE621449BE6504C504830AAE394096C8FC7694651051365D4EE9070101EC9B68086F2EA8F8AB7B811EA8AD934D5C9B62C60A4771\"),\n\t    SHEX(\"122895D63AA6030FC8F23940C528E7A5D9C7FB170A79FE7BC42360CE50E25B7A\"));\n  test_hash(&nettle_sha3_256, /* 103 octets */\n\t    SHEX(\"F13C972C52CB3CC4A4DF28C97F2DF11CE089B815466BE88863243EB318C2ADB1A417CB1041308598541720197B9B1CB5BA2318BD5574D1DF2174AF14884149BA9B2F446D609DF240CE335599957B8EC80876D9A085AE084907BC5961B20BF5F6CA58D5DAB38ADB\"),\n\t    SHEX(\"3E04EE539505C52D814CAB3C5CDD7DF2D6EEE627EA44188153EA6B8C8BE5F6C2\"));\n  test_hash(&nettle_sha3_256, /* 104 octets */\n\t    SHEX(\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\"),\n\t    SHEX(\"E360B424A5C06704D148352E04F4651F8D3B385C01F24FDA09D266D4ED7FF662\"));\n  test_hash(&nettle_sha3_256, /* 105 octets */\n\t    SHEX(\"64EC021C9585E01FFE6D31BB50D44C79B6993D72678163DB474947A053674619D158016ADB243F5C8D50AA92F50AB36E579FF2DABB780A2B529370DAA299207CFBCDD3A9A25006D19C4F1FE33E4B1EAEC315D8C6EE1E730623FD1941875B924EB57D6D0C2EDC4E78D6\"),\n\t    SHEX(\"0D3BECB9E1B4AE1F15C9EE98732B4796E99FD799F76ED7332A68AB36C77A1EF9\"));\n  test_hash(&nettle_sha3_256, /* 106 octets */\n\t    SHEX(\"5954BAB512CF327D66B5D9F296180080402624AD7628506B555EEA8382562324CF452FBA4A2130DE3E165D11831A270D9CB97CE8C2D32A96F50D71600BB4CA268CF98E90D6496B0A6619A5A8C63DB6D8A0634DFC6C7EC8EA9C006B6C456F1B20CD19E781AF20454AC880\"),\n\t    SHEX(\"3AADD7E2086D383832489AA3088E903F5C6FA8E38DF2CF876E0B4DCDDCA5C923\"));\n  test_hash(&nettle_sha3_256, /* 107 octets */\n\t    SHEX(\"03D9F92B2C565709A568724A0AFF90F8F347F43B02338F94A03ED32E6F33666FF5802DA4C81BDCE0D0E86C04AFD4EDC2FC8B4141C2975B6F07639B1994C973D9A9AFCE3D9D365862003498513BFA166D2629E314D97441667B007414E739D7FEBF0FE3C32C17AA188A8683\"),\n\t    SHEX(\"715CED5776A802EB8EE02C9D46543FF46FE7A9CD192FA7D4FFB6E81427FE1B71\"));\n  test_hash(&nettle_sha3_256, /* 108 octets */\n\t    SHEX(\"F31E8B4F9E0621D531D22A380BE5D9ABD56FAEC53CBD39B1FAB230EA67184440E5B1D15457BD25F56204FA917FA48E669016CB48C1FFC1E1E45274B3B47379E00A43843CF8601A5551411EC12503E5AAC43D8676A1B2297EC7A0800DBFEE04292E937F21C005F17411473041\"),\n\t    SHEX(\"DDE61F8BE25B8B23E1212C1C0B8A85A0D02D8548BB17D377133E3C06DDB58CA2\"));\n  test_hash(&nettle_sha3_256, /* 109 octets */\n\t    SHEX(\"758EA3FEA738973DB0B8BE7E599BBEF4519373D6E6DCD7195EA885FC991D896762992759C2A09002912FB08E0CB5B76F49162AEB8CF87B172CF3AD190253DF612F77B1F0C532E3B5FC99C2D31F8F65011695A087A35EE4EEE5E334C369D8EE5D29F695815D866DA99DF3F79403\"),\n\t    SHEX(\"059F2BEDF4A6EEFB95FC5C0AE17556CE8BDDC5E1880FAB2F688A03A46BB28C5F\"));\n  test_hash(&nettle_sha3_256, /* 110 octets */\n\t    SHEX(\"47C6E0C2B74948465921868804F0F7BD50DD323583DC784F998A93CD1CA4C6EF84D41DC81C2C40F34B5BEE6A93867B3BDBA0052C5F59E6F3657918C382E771D33109122CC8BB0E1E53C4E3D13B43CE44970F5E0C079D2AD7D7A3549CD75760C21BB15B447589E86E8D76B1E9CED2\"),\n\t    SHEX(\"125B0EE7870A6F7EB4FD965D9E0B90D79FFFBC54A2018F4C68224682F3603F3F\"));\n  test_hash(&nettle_sha3_256, /* 111 octets */\n\t    SHEX(\"F690A132AB46B28EDFA6479283D6444E371C6459108AFD9C35DBD235E0B6B6FF4C4EA58E7554BD002460433B2164CA51E868F7947D7D7A0D792E4ABF0BE5F450853CC40D85485B2B8857EA31B5EA6E4CCFA2F3A7EF3380066D7D8979FDAC618AAD3D7E886DEA4F005AE4AD05E5065F\"),\n\t    SHEX(\"9A78E0B5A34CBF1716F14CF7B67EFDC4540A75CC646538A11A8EFD9D7CD7529F\"));\n  test_hash(&nettle_sha3_256, /* 112 octets */\n\t    SHEX(\"58D6A99BC6458824B256916770A8417040721CCCFD4B79EACD8B65A3767CE5BA7E74104C985AC56B8CC9AEBD16FEBD4CDA5ADB130B0FF2329CC8D611EB14DAC268A2F9E633C99DE33997FEA41C52A7C5E1317D5B5DAED35EBA7D5A60E45D1FA7EAABC35F5C2B0A0F2379231953322C4E\"),\n\t    SHEX(\"42305A251A8009EDFD62C7D91910B96B9B5DD8FDA5B1326FE41EF6EEF978D1BE\"));\n  test_hash(&nettle_sha3_256, /* 113 octets */\n\t    SHEX(\"BEFAB574396D7F8B6705E2D5B58B2C1C820BB24E3F4BAE3E8FBCD36DBF734EE14E5D6AB972AEDD3540235466E825850EE4C512EA9795ABFD33F330D9FD7F79E62BBB63A6EA85DE15BEAEEA6F8D204A28956059E2632D11861DFB0E65BC07AC8A159388D5C3277E227286F65FF5E5B5AEC1\"),\n\t    SHEX(\"6B9E8F3E82EA174EBC88A53C5DED06271D38F79E9CEC571A9D195EF549102EB8\"));\n  test_hash(&nettle_sha3_256, /* 114 octets */\n\t    SHEX(\"8E58144FA9179D686478622CE450C748260C95D1BA43B8F9B59ABECA8D93488DA73463EF40198B4D16FB0B0707201347E0506FF19D01BEA0F42B8AF9E71A1F1BD168781069D4D338FDEF00BF419FBB003031DF671F4A37979564F69282DE9C65407847DD0DA505AB1641C02DEA4F0D834986\"),\n\t    SHEX(\"358DE4C1ED30F48B084F961F653FEBC69318F93883612D5A04B9139A14EC702E\"));\n  test_hash(&nettle_sha3_256, /* 115 octets */\n\t    SHEX(\"B55C10EAE0EC684C16D13463F29291BF26C82E2FA0422A99C71DB4AF14DD9C7F33EDA52FD73D017CC0F2DBE734D831F0D820D06D5F89DACC485739144F8CFD4799223B1AFF9031A105CB6A029BA71E6E5867D85A554991C38DF3C9EF8C1E1E9A7630BE61CAABCA69280C399C1FB7A12D12AEFC\"),\n\t    SHEX(\"4A7BD18AE10EB9458924AA5CA00D3F634AB9753628107F15FF2BF24CCD3B94F4\"));\n  test_hash(&nettle_sha3_256, /* 116 octets */\n\t    SHEX(\"2EEEA693F585F4ED6F6F8865BBAE47A6908AECD7C429E4BEC4F0DE1D0CA0183FA201A0CB14A529B7D7AC0E6FF6607A3243EE9FB11BCF3E2304FE75FFCDDD6C5C2E2A4CD45F63C962D010645058D36571404A6D2B4F44755434D76998E83409C3205AA1615DB44057DB991231D2CB42624574F545\"),\n\t    SHEX(\"9889E4B3B1294A01556FA9DE6A6A508A9A763D5133FDCD4937B6BB23CA3E1901\"));\n  test_hash(&nettle_sha3_256, /* 117 octets */\n\t    SHEX(\"DAB11DC0B047DB0420A585F56C42D93175562852428499F66A0DB811FCDDDAB2F7CDFFED1543E5FB72110B64686BC7B6887A538AD44C050F1E42631BC4EC8A9F2A047163D822A38989EE4AAB01B4C1F161B062D873B1CFA388FD301514F62224157B9BEF423C7783B7AAC8D30D65CD1BBA8D689C2D\"),\n\t    SHEX(\"3D02B41985BDD1835CB474FB364C25C2CCA9DA0ED2FBBAB75524B410903815B9\"));\n  test_hash(&nettle_sha3_256, /* 118 octets */\n\t    SHEX(\"42E99A2F80AEE0E001279A2434F731E01D34A44B1A8101726921C0590C30F3120EB83059F325E894A5AC959DCA71CE2214799916424E859D27D789437B9D27240BF8C35ADBAFCECC322B48AA205B293962D858652ABACBD588BCF6CBC388D0993BD622F96ED54614C25B6A9AA527589EAAFFCF17DDF7\"),\n\t    SHEX(\"1CD92039BE4580C686796D5900EED431EBAD6EA566E9244E76BA6873EFCB49AB\"));\n  test_hash(&nettle_sha3_256, /* 119 octets */\n\t    SHEX(\"3C9B46450C0F2CAE8E3823F8BDB4277F31B744CE2EB17054BDDC6DFF36AF7F49FB8A2320CC3BDF8E0A2EA29AD3A55DE1165D219ADEDDB5175253E2D1489E9B6FDD02E2C3D3A4B54D60E3A47334C37913C5695378A669E9B72DEC32AF5434F93F46176EBF044C4784467C700470D0C0B40C8A088C815816\"),\n\t    SHEX(\"680C70B243163BE6E58ED3B8E2D85E6894E5E89501C444C8C0A2D776ACAD8599\"));\n  test_hash(&nettle_sha3_256, /* 120 octets */\n\t    SHEX(\"D1E654B77CB155F5C77971A64DF9E5D34C26A3CAD6C7F6B300D39DEB1910094691ADAA095BE4BA5D86690A976428635D5526F3E946F7DC3BD4DBC78999E653441187A81F9ADCD5A3C5F254BC8256B0158F54673DCC1232F6E918EBFC6C51CE67EAEB042D9F57EEC4BFE910E169AF78B3DE48D137DF4F2840\"),\n\t    SHEX(\"D65E823D2CE4EFFB9B27DBBF6EFCDA738AD152FBB12D2108D2EC6D050A3FB295\"));\n  test_hash(&nettle_sha3_256, /* 121 octets */\n\t    SHEX(\"626F68C18A69A6590159A9C46BE03D5965698F2DAC3DE779B878B3D9C421E0F21B955A16C715C1EC1E22CE3EB645B8B4F263F60660EA3028981EEBD6C8C3A367285B691C8EE56944A7CD1217997E1D9C21620B536BDBD5DE8925FF71DEC6FBC06624AB6B21E329813DE90D1E572DFB89A18120C3F606355D25\"),\n\t    SHEX(\"CE6D2DD8D5441FC15B888FED72061E129125431BEDEA32E00EE0A7655C06C358\"));\n  test_hash(&nettle_sha3_256, /* 122 octets */\n\t    SHEX(\"651A6FB3C4B80C7C68C6011675E6094EB56ABF5FC3057324EBC6477825061F9F27E7A94633ABD1FA598A746E4A577CAF524C52EC1788471F92B8C37F23795CA19D559D446CAB16CBCDCE90B79FA1026CEE77BF4AB1B503C5B94C2256AD75B3EAC6FD5DCB96ACA4B03A834BFB4E9AF988CECBF2AE597CB9097940\"),\n\t    SHEX(\"280713C0FA7160289FBFEE5AA580AD82512839153DAE47DE0D154384A4D8B3ED\"));\n  test_hash(&nettle_sha3_256, /* 123 octets */\n\t    SHEX(\"8AAF072FCE8A2D96BC10B3C91C809EE93072FB205CA7F10ABD82ECD82CF040B1BC49EA13D1857815C0E99781DE3ADBB5443CE1C897E55188CEAF221AA9681638DE05AE1B322938F46BCE51543B57ECDB4C266272259D1798DE13BE90E10EFEC2D07484D9B21A3870E2AA9E06C21AA2D0C9CF420080A80A91DEE16F\"),\n\t    SHEX(\"721FD872696F21DEAA9595C0CEE7BC07249601927C96A65826B4887CDBA1AE96\"));\n  test_hash(&nettle_sha3_256, /* 124 octets */\n\t    SHEX(\"53F918FD00B1701BD504F8CDEA803ACCA21AC18C564AB90C2A17DA592C7D69688F6580575395551E8CD33E0FEF08CA6ED4588D4D140B3E44C032355DF1C531564D7F4835753344345A6781E11CD5E095B73DF5F82C8AE3AD00877936896671E947CC52E2B29DCD463D90A0C9929128DA222B5A211450BBC0E02448E2\"),\n\t    SHEX(\"B53AF8620B39CAD2D698A176A070AEAA9FB67BD0335C3485A3B6C73A71DC5C5C\"));\n  test_hash(&nettle_sha3_256, /* 125 octets */\n\t    SHEX(\"A64599B8A61B5CCEC9E67AED69447459C8DA3D1EC6C7C7C82A7428B9B584FA67E90F68E2C00FBBED4613666E5168DA4A16F395F7A3C3832B3B134BFC9CBAA95D2A0FE252F44AC6681EB6D40AB91C1D0282FED6701C57463D3C5F2BB8C6A7301FB4576AA3B5F15510DB8956FF77478C26A7C09BEA7B398CFC83503F538E\"),\n\t    SHEX(\"78A18BF0A52E6F77F15F7FFE4CA3C999E57E1C3F6BF10950581F403450EDB797\"));\n  test_hash(&nettle_sha3_256, /* 126 octets */\n\t    SHEX(\"0E3AB0E054739B00CDB6A87BD12CAE024B54CB5E550E6C425360C2E87E59401F5EC24EF0314855F0F56C47695D56A7FB1417693AF2A1ED5291F2FEE95F75EED54A1B1C2E81226FBFF6F63ADE584911C71967A8EB70933BC3F5D15BC91B5C2644D9516D3C3A8C154EE48E118BD1442C043C7A0DBA5AC5B1D5360AAE5B9065\"),\n\t    SHEX(\"A7F0151EEE6B21FE827E69256D560E1EA8D939B80962FC7FA8610AC189402AD2\"));\n  test_hash(&nettle_sha3_256, /* 127 octets */\n\t    SHEX(\"A62FC595B4096E6336E53FCDFC8D1CC175D71DAC9D750A6133D23199EAAC288207944CEA6B16D27631915B4619F743DA2E30A0C00BBDB1BBB35AB852EF3B9AEC6B0A8DCC6E9E1ABAA3AD62AC0A6C5DE765DE2C3711B769E3FDE44A74016FFF82AC46FA8F1797D3B2A726B696E3DEA5530439ACEE3A45C2A51BC32DD055650B\"),\n\t    SHEX(\"0A09C4B18F5117F0E45D43E235BB14E55B162E99EB3744165196D04A854229F9\"));\n  test_hash(&nettle_sha3_256, /* 128 octets */\n\t    SHEX(\"2B6DB7CED8665EBE9DEB080295218426BDAA7C6DA9ADD2088932CDFFBAA1C14129BCCDD70F369EFB149285858D2B1D155D14DE2FDB680A8B027284055182A0CAE275234CC9C92863C1B4AB66F304CF0621CD54565F5BFF461D3B461BD40DF28198E3732501B4860EADD503D26D6E69338F4E0456E9E9BAF3D827AE685FB1D817\"),\n\t    SHEX(\"B7D031AA69B7B4D26A35B896D761314F1D61EB12DCC1E72AAF61B9CD48003AF9\"));\n  test_hash(&nettle_sha3_256, /* 129 octets */\n\t    SHEX(\"10DB509B2CDCABA6C062AE33BE48116A29EB18E390E1BBADA5CA0A2718AFBCD23431440106594893043CC7F2625281BF7DE2655880966A23705F0C5155C2F5CCA9F2C2142E96D0A2E763B70686CD421B5DB812DACED0C6D65035FDE558E94F26B3E6DDE5BD13980CC80292B723013BD033284584BFF27657871B0CF07A849F4AE2\"),\n\t    SHEX(\"EC0858C9D017A2D3727CAADE7E4872684F17B822CAFECDA445A15CF30FAC8CF0\"));\n  test_hash(&nettle_sha3_256, /* 130 octets */\n\t    SHEX(\"9334DE60C997BDA6086101A6314F64E4458F5FF9450C509DF006E8C547983C651CA97879175AABA0C539E82D05C1E02C480975CBB30118121061B1EBAC4F8D9A3781E2DB6B18042E01ECF9017A64A0E57447EC7FCBE6A7F82585F7403EE2223D52D37B4BF426428613D6B4257980972A0ACAB508A7620C1CB28EB4E9D30FC41361EC\"),\n\t    SHEX(\"71E1D610B576063F2B12F691220BEADF506BEC0A3A086BBE5864FB54F93DB556\"));\n  test_hash(&nettle_sha3_256, /* 131 octets */\n\t    SHEX(\"E88AB086891693AA535CEB20E64C7AB97C7DD3548F3786339897A5F0C39031549CA870166E477743CCFBE016B4428D89738E426F5FFE81626137F17AECFF61B72DBEE2DC20961880CFE281DFAB5EE38B1921881450E16032DE5E4D55AD8D4FCA609721B0692BAC79BE5A06E177FE8C80C0C83519FB3347DE9F43D5561CB8107B9B5EDC\"),\n\t    SHEX(\"72A8A7493309080ACCCA2A2A21D641F2B9685B7362BE496DC7BC330659F8CFE1\"));\n  test_hash(&nettle_sha3_256, /* 132 octets */\n\t    SHEX(\"FD19E01A83EB6EC810B94582CB8FBFA2FCB992B53684FB748D2264F020D3B960CB1D6B8C348C2B54A9FCEA72330C2AAA9A24ECDB00C436ABC702361A82BB8828B85369B8C72ECE0082FE06557163899C2A0EFA466C33C04343A839417057399A63A3929BE1EE4805D6CE3E5D0D0967FE9004696A5663F4CAC9179006A2CEB75542D75D68\"),\n\t    SHEX(\"AF19E988D37E2577DA4F43463789B73625D354FCCCBD10CD2C61FBDC8BB01827\"));\n  test_hash(&nettle_sha3_256, /* 133 octets */\n\t    SHEX(\"59AE20B6F7E0B3C7A989AFB28324A40FCA25D8651CF1F46AE383EF6D8441587AA1C04C3E3BF88E8131CE6145CFB8973D961E8432B202FA5AF3E09D625FAAD825BC19DA9B5C6C20D02ABDA2FCC58B5BD3FE507BF201263F30543819510C12BC23E2DDB4F711D087A86EDB1B355313363A2DE996B891025E147036087401CCF3CA7815BF3C49\"),\n\t    SHEX(\"F1E9B9CEF2B37E4EC3A0FCD5EFF5BF7E3D49100AEBF018DC92FB6A40E4297704\"));\n  test_hash(&nettle_sha3_256, /* 134 octets */\n\t    SHEX(\"77EE804B9F3295AB2362798B72B0A1B2D3291DCEB8139896355830F34B3B328561531F8079B79A6E9980705150866402FDC176C05897E359A6CB1A7AB067383EB497182A7E5AEF7038E4C96D133B2782917417E391535B5E1B51F47D8ED7E4D4025FE98DC87B9C1622614BFF3D1029E68E372DE719803857CA52067CDDAAD958951CB2068CC6\"),\n\t    SHEX(\"DD3EBE0CCA0CAD3AF72AF73FB49D40DBDCC4B1F1FF465CCAEFE672F77992ACA0\"));\n  test_hash(&nettle_sha3_256, /* 135 octets */\n\t    SHEX(\"B771D5CEF5D1A41A93D15643D7181D2A2EF0A8E84D91812F20ED21F147BEF732BF3A60EF4067C3734B85BC8CD471780F10DC9E8291B58339A677B960218F71E793F2797AEA349406512829065D37BB55EA796FA4F56FD8896B49B2CD19B43215AD967C712B24E5032D065232E02C127409D2ED4146B9D75D763D52DB98D949D3B0FED6A8052FBB\"),\n\t    SHEX(\"A19EEE92BB2097B64E823D597798AA18BE9B7C736B8059ABFD6779AC35AC81B5\"));\n  test_hash(&nettle_sha3_256, /* 136 octets */\n\t    SHEX(\"B32D95B0B9AAD2A8816DE6D06D1F86008505BD8C14124F6E9A163B5A2ADE55F835D0EC3880EF50700D3B25E42CC0AF050CCD1BE5E555B23087E04D7BF9813622780C7313A1954F8740B6EE2D3F71F768DD417F520482BD3A08D4F222B4EE9DBD015447B33507DD50F3AB4247C5DE9A8ABD62A8DECEA01E3B87C8B927F5B08BEB37674C6F8E380C04\"),\n\t    SHEX(\"DF673F4105379FF6B755EEAB20CEB0DC77B5286364FE16C59CC8A907AFF07732\"));\n  test_hash(&nettle_sha3_256, /* 137 octets */\n\t    SHEX(\"04410E31082A47584B406F051398A6ABE74E4DA59BB6F85E6B49E8A1F7F2CA00DFBA5462C2CD2BFDE8B64FB21D70C083F11318B56A52D03B81CAC5EEC29EB31BD0078B6156786DA3D6D8C33098C5C47BB67AC64DB14165AF65B44544D806DDE5F487D5373C7F9792C299E9686B7E5821E7C8E2458315B996B5677D926DAC57B3F22DA873C601016A0D\"),\n\t    SHEX(\"D52432CF3B6B4B949AA848E058DCD62D735E0177279222E7AC0AF8504762FAA0\"));\n  test_hash(&nettle_sha3_256, /* 138 octets */\n\t    SHEX(\"8B81E9BADDE026F14D95C019977024C9E13DB7A5CD21F9E9FC491D716164BBACDC7060D882615D411438AEA056C340CDF977788F6E17D118DE55026855F93270472D1FD18B9E7E812BAE107E0DFDE7063301B71F6CFE4E225CAB3B232905A56E994F08EE2891BA922D49C3DAFEB75F7C69750CB67D822C96176C46BD8A29F1701373FB09A1A6E3C7158F\"),\n\t    SHEX(\"07E65754D62E01B9A049D15DEC0D09C02F479CA2AEB4B18E37070B20F85A1B26\"));\n  test_hash(&nettle_sha3_256, /* 139 octets */\n\t    SHEX(\"FA6EED24DA6666A22208146B19A532C2EC9BA94F09F1DEF1E7FC13C399A48E41ACC2A589D099276296348F396253B57CB0E40291BD282773656B6E0D8BEA1CDA084A3738816A840485FCF3FB307F777FA5FEAC48695C2AF4769720258C77943FB4556C362D9CBA8BF103AEB9034BAA8EA8BFB9C4F8E6742CE0D52C49EA8E974F339612E830E9E7A9C29065\"),\n\t    SHEX(\"17A461B8EE507ABCFED51A50EF14891309FE402C569D94394CA7A3031BEFCD50\"));\n  test_hash(&nettle_sha3_256, /* 140 octets */\n\t    SHEX(\"9BB4AF1B4F09C071CE3CAFA92E4EB73CE8A6F5D82A85733440368DEE4EB1CBC7B55AC150773B6FE47DBE036C45582ED67E23F4C74585DAB509DF1B83610564545642B2B1EC463E18048FC23477C6B2AA035594ECD33791AF6AF4CBC2A1166ABA8D628C57E707F0B0E8707CAF91CD44BDB915E0296E0190D56D33D8DDE10B5B60377838973C1D943C22ED335E\"),\n\t    SHEX(\"A03C6B5B51AE4AA00912AF1CFB6C7B960EF58036156497CC567B1369149A5949\"));\n  test_hash(&nettle_sha3_256, /* 141 octets */\n\t    SHEX(\"2167F02118CC62043E9091A647CADBED95611A521FE0D64E8518F16C808AB297725598AE296880A773607A798F7C3CFCE80D251EBEC6885015F9ABF7EAABAE46798F82CB5926DE5C23F44A3F9F9534B3C6F405B5364C2F8A8BDC5CA49C749BED8CE4BA48897062AE8424CA6DDE5F55C0E42A95D1E292CA54FB46A84FBC9CD87F2D0C9E7448DE3043AE22FDD229\"),\n\t    SHEX(\"14C69C5EABDEFC9E3A1461A379EC92C32BC6B69071029CB3655159DB1A5251A7\"));\n  test_hash(&nettle_sha3_256, /* 142 octets */\n\t    SHEX(\"94B7FA0BC1C44E949B1D7617D31B4720CBE7CA57C6FA4F4094D4761567E389ECC64F6968E4064DF70DF836A47D0C713336B5028B35930D29EB7A7F9A5AF9AD5CF441745BAEC9BB014CEEFF5A41BA5C1CE085FEB980BAB9CF79F2158E03EF7E63E29C38D7816A84D4F71E0F548B7FC316085AE38A060FF9B8DEC36F91AD9EBC0A5B6C338CBB8F6659D342A24368CF\"),\n\t    SHEX(\"3CBE06887C8AE360E957EB08CA577834C457FADF418D0CB73967FA827A22A4D7\"));\n  test_hash(&nettle_sha3_256, /* 143 octets */\n\t    SHEX(\"EA40E83CB18B3A242C1ECC6CCD0B7853A439DAB2C569CFC6DC38A19F5C90ACBF76AEF9EA3742FF3B54EF7D36EB7CE4FF1C9AB3BC119CFF6BE93C03E208783335C0AB8137BE5B10CDC66FF3F89A1BDDC6A1EED74F504CBE7290690BB295A872B9E3FE2CEE9E6C67C41DB8EFD7D863CF10F840FE618E7936DA3DCA5CA6DF933F24F6954BA0801A1294CD8D7E66DFAFEC\"),\n\t    SHEX(\"E58A947E98D6DD7E932D2FE02D9992E6118C0C2C606BDCDA06E7943D2C95E0E5\"));\n  test_hash(&nettle_sha3_256, /* 144 octets */\n\t    SHEX(\"157D5B7E4507F66D9A267476D33831E7BB768D4D04CC3438DA12F9010263EA5FCAFBDE2579DB2F6B58F911D593D5F79FB05FE3596E3FA80FF2F761D1B0E57080055C118C53E53CDB63055261D7C9B2B39BD90ACC32520CBBDBDA2C4FD8856DBCEE173132A2679198DAF83007A9B5C51511AE49766C792A29520388444EBEFE28256FB33D4260439CBA73A9479EE00C63\"),\n\t    SHEX(\"A936FB9AF87FB67857B3EAD5C76226AD84DA47678F3C2FFE5A39FDB5F7E63FFB\"));\n  test_hash(&nettle_sha3_256, /* 145 octets */\n\t    SHEX(\"836B34B515476F613FE447A4E0C3F3B8F20910AC89A3977055C960D2D5D2B72BD8ACC715A9035321B86703A411DDE0466D58A59769672AA60AD587B8481DE4BBA552A1645779789501EC53D540B904821F32B0BD1855B04E4848F9F8CFE9EBD8911BE95781A759D7AD9724A7102DBE576776B7C632BC39B9B5E19057E226552A5994C1DBB3B5C7871A11F5537011044C53\"),\n\t    SHEX(\"3A654B88F88086C2751EDAE6D39248143CF6235C6B0B7969342C45A35194B67E\"));\n  test_hash(&nettle_sha3_256, /* 146 octets */\n\t    SHEX(\"CC7784A4912A7AB5AD3620AAB29BA87077CD3CB83636ADC9F3DC94F51EDF521B2161EF108F21A0A298557981C0E53CE6CED45BDF782C1EF200D29BAB81DD6460586964EDAB7CEBDBBEC75FD7925060F7DA2B853B2B089588FA0F8C16EC6498B14C55DCEE335CB3A91D698E4D393AB8E8EAC0825F8ADEBEEE196DF41205C011674E53426CAA453F8DE1CBB57932B0B741D4C6\"),\n\t    SHEX(\"19A3CB3E8551F08FBBA5DB614E268F63D1F6A0C3689BBE973D59D35BB4F455D0\"));\n  test_hash(&nettle_sha3_256, /* 147 octets */\n\t    SHEX(\"7639B461FFF270B2455AC1D1AFCE782944AEA5E9087EB4A39EB96BB5C3BAAF0E868C8526D3404F9405E79E77BFAC5FFB89BF1957B523E17D341D7323C302EA7083872DD5E8705694ACDDA36D5A1B895AAA16ECA6104C82688532C8BFE1790B5DC9F4EC5FE95BAED37E1D287BE710431F1E5E8EE105BC42ED37D74B1E55984BF1C09FE6A1FA13EF3B96FAEAED6A2A1950A12153\"),\n\t    SHEX(\"CA8CFB13973FF8597D6AAA806BD32E82F4EA68BAC3FB543F26687DE4B9CBE8BD\"));\n  test_hash(&nettle_sha3_256, /* 148 octets */\n\t    SHEX(\"EB6513FC61B30CFBA58D4D7E80F94D14589090CF1D80B1DF2E68088DC6104959BA0D583D585E9578AB0AEC0CF36C48435EB52ED9AB4BBCE7A5ABE679C97AE2DBE35E8CC1D45B06DDA3CF418665C57CBEE4BBB47FA4CAF78F4EE656FEC237FE4EEBBAFA206E1EF2BD0EE4AE71BD0E9B2F54F91DAADF1FEBFD7032381D636B733DCB3BF76FB14E23AFF1F68ED3DBCF75C9B99C6F26\"),\n\t    SHEX(\"9AE670FA85AB5C6B3BC76797CF24CD385110708137B6F8EFD8D1A21C39881C18\"));\n  test_hash(&nettle_sha3_256, /* 149 octets */\n\t    SHEX(\"1594D74BF5DDE444265D4C04DAD9721FF3E34CBF622DAF341FE16B96431F6C4DF1F760D34F296EB97D98D560AD5286FEC4DCE1724F20B54FD7DF51D4BF137ADD656C80546FB1BF516D62EE82BAA992910EF4CC18B70F3F8698276FCFB44E0EC546C2C39CFD8EE91034FF9303058B4252462F86C823EB15BF481E6B79CC3A02218595B3658E8B37382BD5048EAED5FD02C37944E73B\"),\n\t    SHEX(\"E32DF6218BA75FD4788A7E5727A7D68C5829C49346683FC213E433AF3DBA5AB5\"));\n  test_hash(&nettle_sha3_256, /* 150 octets */\n\t    SHEX(\"4CFA1278903026F66FEDD41374558BE1B585D03C5C55DAC94361DF286D4BD39C7CB8037ED3B267B07C346626449D0CC5B0DD2CF221F7E4C3449A4BE99985D2D5E67BFF2923357DDEAB5ABCB4619F3A3A57B2CF928A022EB27676C6CF805689004FCA4D41EA6C2D0A4789C7605F7BB838DD883B3AD3E6027E775BCF262881428099C7FFF95B14C095EA130E0B9938A5E22FC52650F591\"),\n\t    SHEX(\"028173E3C6C392E5D13AF748F3788D43449BC5DD5953124EA5EDF3930275F665\"));\n  test_hash(&nettle_sha3_256, /* 151 octets */\n\t    SHEX(\"D3E65CB92CFA79662F6AF493D696A07CCF32AAADCCEFF06E73E8D9F6F909209E66715D6E978788C49EFB9087B170ECF3AA86D2D4D1A065AE0EFC8924F365D676B3CB9E2BEC918FD96D0B43DEE83727C9A93BF56CA2B2E59ADBA85696546A815067FC7A78039629D4948D157E7B0D826D1BF8E81237BAB7321312FDAA4D521744F988DB6FDF04549D0FDCA393D639C729AF716E9C8BBA48\"),\n\t    SHEX(\"97450FC46F2E5DF8F81623B1CCA43FA50F51EA735E4421D7DFF66314D8E211BC\"));\n  test_hash(&nettle_sha3_256, /* 152 octets */\n\t    SHEX(\"842CC583504539622D7F71E7E31863A2B885C56A0BA62DB4C2A3F2FD12E79660DC7205CA29A0DC0A87DB4DC62EE47A41DB36B9DDB3293B9AC4BAAE7DF5C6E7201E17F717AB56E12CAD476BE49608AD2D50309E7D48D2D8DE4FA58AC3CFEAFEEE48C0A9EEC88498E3EFC51F54D300D828DDDCCB9D0B06DD021A29CF5CB5B2506915BEB8A11998B8B886E0F9B7A80E97D91A7D01270F9A7717\"),\n\t    SHEX(\"AB4E5A70390577F8AE260D53CB0E70914F8B9398ABAA841F7807F1476046C64F\"));\n  test_hash(&nettle_sha3_256, /* 153 octets */\n\t    SHEX(\"6C4B0A0719573E57248661E98FEBE326571F9A1CA813D3638531AE28B4860F23C3A3A8AC1C250034A660E2D71E16D3ACC4BF9CE215C6F15B1C0FC7E77D3D27157E66DA9CEEC9258F8F2BF9E02B4AC93793DD6E29E307EDE3695A0DF63CBDC0FC66FB770813EB149CA2A916911BEE4902C47C7802E69E405FE3C04CEB5522792A5503FA829F707272226621F7C488A7698C0D69AA561BE9F378\"),\n\t    SHEX(\"8118F2C157DF1250DB43B31183F442F89B322E496918838C5B668F9647AC6D6B\"));\n  test_hash(&nettle_sha3_256, /* 154 octets */\n\t    SHEX(\"51B7DBB7CE2FFEB427A91CCFE5218FD40F9E0B7E24756D4C47CD55606008BDC27D16400933906FD9F30EFFDD4880022D081155342AF3FB6CD53672AB7FB5B3A3BCBE47BE1FD3A2278CAE8A5FD61C1433F7D350675DD21803746CADCA574130F01200024C6340AB0CC2CF74F2234669F34E9009EF2EB94823D62B31407F4BA46F1A1EEC41641E84D77727B59E746B8A671BEF936F05BE820759FA\"),\n\t    SHEX(\"736E30ACCC5559188412C797A1A5BE61D1F90F149401F631597944155A85FAF7\"));\n  test_hash(&nettle_sha3_256, /* 155 octets */\n\t    SHEX(\"83599D93F5561E821BD01A472386BC2FF4EFBD4AED60D5821E84AAE74D8071029810F5E286F8F17651CD27DA07B1EB4382F754CD1C95268783AD09220F5502840370D494BEB17124220F6AFCE91EC8A0F55231F9652433E5CE3489B727716CF4AEBA7DCDA20CD29AA9A859201253F948DD94395ABA9E3852BD1D60DDA7AE5DC045B283DA006E1CBAD83CC13292A315DB5553305C628DD091146597\"),\n\t    SHEX(\"9599DEECCC698A24A461A7419E91939C741613F4CE887DBA89DC7E327C51F5BF\"));\n  test_hash(&nettle_sha3_256, /* 156 octets */\n\t    SHEX(\"2BE9BF526C9D5A75D565DD11EF63B979D068659C7F026C08BEA4AF161D85A462D80E45040E91F4165C074C43AC661380311A8CBED59CC8E4C4518E80CD2C78AB1CABF66BFF83EAB3A80148550307310950D034A6286C93A1ECE8929E6385C5E3BB6EA8A7C0FB6D6332E320E71CC4EB462A2A62E2BFE08F0CCAD93E61BEDB5DD0B786A728AB666F07E0576D189C92BF9FB20DCA49AC2D3956D47385E2\"),\n\t    SHEX(\"BE0D871606A4C129CEF616F438600D5CBC0E9F49D2ADC8A86571C192361C3F4F\"));\n  test_hash(&nettle_sha3_256, /* 157 octets */\n\t    SHEX(\"CA76D3A12595A817682617006848675547D3E8F50C2210F9AF906C0E7CE50B4460186FE70457A9E879E79FD4D1A688C70A347361C847BA0DD6AA52936EAF8E58A1BE2F5C1C704E20146D366AEB3853BED9DE9BEFE9569AC8AAEA37A9FB7139A1A1A7D5C748605A8DEFB297869EBEDD71D615A5DA23496D11E11ABBB126B206FA0A7797EE7DE117986012D0362DCEF775C2FE145ADA6BDA1CCB326BF644\"),\n\t    SHEX(\"4D30600C60ED94A0D2BCC17571A19BD0170CDACAC78D0421E0BBAE2A36A48B6D\"));\n  test_hash(&nettle_sha3_256, /* 158 octets */\n\t    SHEX(\"F76B85DC67421025D64E93096D1D712B7BAF7FB001716F02D33B2160C2C882C310EF13A576B1C2D30EF8F78EF8D2F465007109AAD93F74CB9E7D7BEF7C9590E8AF3B267C89C15DB238138C45833C98CC4A471A7802723EF4C744A853CF80A0C2568DD4ED58A2C9644806F42104CEE53628E5BDF7B63B0B338E931E31B87C24B146C6D040605567CEEF5960DF9E022CB469D4C787F4CBA3C544A1AC91F95F\"),\n\t    SHEX(\"3BD6FB72764F7AD4391B7B40AEA424ABD5F5561AC56F9E072C753D6090FA4BFB\"));\n  test_hash(&nettle_sha3_256, /* 159 octets */\n\t    SHEX(\"25B8C9C032EA6BCD733FFC8718FBB2A503A4EA8F71DEA1176189F694304F0FF68E862A8197B839957549EF243A5279FC2646BD4C009B6D1EDEBF24738197ABB4C992F6B1DC9BA891F570879ACCD5A6B18691A93C7D0A8D38F95B639C1DAEB48C4C2F15CCF5B9D508F8333C32DE78781B41850F261B855C4BEBCC125A380C54D501C5D3BD07E6B52102116088E53D76583B0161E2A58D0778F091206AABD5A1\"),\n\t    SHEX(\"6689BB25BAEE0C582F8F1B0C87073BE366644DA859313BECF446435D2F6E899E\"));\n  test_hash(&nettle_sha3_256, /* 160 octets */\n\t    SHEX(\"21CFDC2A7CCB7F331B3D2EEFFF37E48AD9FA9C788C3F3C200E0173D99963E1CBCA93623B264E920394AE48BB4C3A5BB96FFBC8F0E53F30E22956ADABC2765F57FB761E147ECBF8567533DB6E50C8A1F894310A94EDF806DD8CA6A0E141C0FA7C9FAE6C6AE65F18C93A8529E6E5B553BF55F25BE2E80A9882BD37F145FECBEB3D447A3C4E46C21524CC55CDD62F521AB92A8BA72B897996C49BB273198B7B1C9E\"),\n\t    SHEX(\"2628DDC7758208AA9F1E49497224EB268C6D2BCDAAB4820DE9C16A65C6F6017A\"));\n  test_hash(&nettle_sha3_256, /* 161 octets */\n\t    SHEX(\"4E452BA42127DCC956EF4F8F35DD68CB225FB73B5BC7E1EC5A898BBA2931563E74FAFF3B67314F241EC49F4A7061E3BD0213AE826BAB380F1F14FAAB8B0EFDDD5FD1BB49373853A08F30553D5A55CCBBB8153DE4704F29CA2BDEEF0419468E05DD51557CCC80C0A96190BBCC4D77ECFF21C66BDF486459D427F986410F883A80A5BCC32C20F0478BB9A97A126FC5F95451E40F292A4614930D054C851ACD019CCF\"),\n\t    SHEX(\"DF448936EE72D9FE6CCFB37D183AAFDDC7908E016271AFA81EC083A10A144F5D\"));\n  test_hash(&nettle_sha3_256, /* 162 octets */\n\t    SHEX(\"FA85671DF7DADF99A6FFEE97A3AB9991671F5629195049880497487867A6C446B60087FAC9A0F2FCC8E3B24E97E42345B93B5F7D3691829D3F8CCD4BB36411B85FC2328EB0C51CB3151F70860AD3246CE0623A8DC8B3C49F958F8690F8E3860E71EB2B1479A5CEA0B3F8BEFD87ACAF5362435EAECCB52F38617BC6C5C2C6E269EAD1FBD69E941D4AD2012DA2C5B21BCFBF98E4A77AB2AF1F3FDA3233F046D38F1DC8\"),\n\t    SHEX(\"2BB4CEC22A4FECD83FBBBAD1E3835343E36C6CB66C26964A432EC4C70F3E17B4\"));\n  test_hash(&nettle_sha3_256, /* 163 octets */\n\t    SHEX(\"E90847AE6797FBC0B6B36D6E588C0A743D725788CA50B6D792352EA8294F5BA654A15366B8E1B288D84F5178240827975A763BC45C7B0430E8A559DF4488505E009C63DA994F1403F407958203CEBB6E37D89C94A5EACF6039A327F6C4DBBC7A2A307D976AA39E41AF6537243FC218DFA6AB4DD817B6A397DF5CA69107A9198799ED248641B63B42CB4C29BFDD7975AC96EDFC274AC562D0474C60347A078CE4C25E88\"),\n\t    SHEX(\"1462F2EA1C3580C0A2E8C0B30C27A608D82CD707F6D1A0AAD5CC7C3D1B8D6C30\"));\n  test_hash(&nettle_sha3_256, /* 164 octets */\n\t    SHEX(\"F6D5C2B6C93954FC627602C00C4CA9A7D3ED12B27173F0B2C9B0E4A5939398A665E67E69D0B12FB7E4CEB253E8083D1CEB724AC07F009F094E42F2D6F2129489E846EAFF0700A8D4453EF453A3EDDC18F408C77A83275617FABC4EA3A2833AA73406C0E966276079D38E8E38539A70E194CC5513AAA457C699383FD1900B1E72BDFB835D1FD321B37BA80549B078A49EA08152869A918CA57F5B54ED71E4FD3AC5C06729\"),\n\t    SHEX(\"617B412ED64F56D6DB36B7E52EAD618D95A091D65052C3F376A532D8BBDAF7C7\"));\n  test_hash(&nettle_sha3_256, /* 165 octets */\n\t    SHEX(\"CF8562B1BED89892D67DDAAF3DEEB28246456E972326DBCDB5CF3FB289ACA01E68DA5D59896E3A6165358B071B304D6AB3D018944BE5049D5E0E2BB819ACF67A6006111089E6767132D72DD85BEDDCBB2D64496DB0CC92955AB4C6234F1EEA24F2D51483F2E209E4589BF9519FAC51B4D061E801125E605F8093BB6997BC163D551596FE4AB7CFAE8FB9A90F6980480CE0C229FD1675409BD788354DAF316240CFE0AF93EB\"),\n\t    SHEX(\"82C541EA5CB15D1A4125F536825938C2358EEC2BDDC5D1CC4042DE3AF036CA55\"));\n  test_hash(&nettle_sha3_256, /* 166 octets */\n\t    SHEX(\"2ACE31ABB0A2E3267944D2F75E1559985DB7354C6E605F18DC8470423FCA30B7331D9B33C4A4326783D1CAAE1B4F07060EFF978E4746BF0C7E30CD61040BD5EC2746B29863EB7F103EBDA614C4291A805B6A4C8214230564A0557BC7102E0BD3ED23719252F7435D64D210EE2AAFC585BE903FA41E1968C50FD5D5367926DF7A05E3A42CF07E656FF92DE73B036CF8B19898C0CB34557C0C12C2D8B84E91181AF467BC75A9D1\"),\n\t    SHEX(\"684BB7932433218C616F0590B039CEFAC972828470647D1591CEAC889C893272\"));\n  test_hash(&nettle_sha3_256, /* 167 octets */\n\t    SHEX(\"0D8D09AED19F1013969CE5E7EB92F83A209AE76BE31C754844EA9116CEB39A22EBB6003017BBCF26555FA6624185187DB8F0CB3564B8B1C06BF685D47F3286EDA20B83358F599D2044BBF0583FAB8D78F854FE0A596183230C5EF8E54426750EAF2CC4E29D3BDD037E734D863C2BD9789B4C243096138F7672C232314EFFDFC6513427E2DA76916B5248933BE312EB5DDE4CF70804FB258AC5FB82D58D08177AC6F4756017FFF5\"),\n\t    SHEX(\"508B2AF376BA6467CF982C767C848D2BDA8D068A53416F074A0C98C473D02F6B\"));\n  test_hash(&nettle_sha3_256, /* 168 octets */\n\t    SHEX(\"C3236B73DEB7662BF3F3DAA58F137B358BA610560EF7455785A9BEFDB035A066E90704F929BD9689CEF0CE3BDA5ACF4480BCEB8D09D10B098AD8500D9B6071DFC3A14AF6C77511D81E3AA8844986C3BEA6F469F9E02194C92868CD5F51646256798FF0424954C1434BDFED9FACB390B07D342E992936E0F88BFD0E884A0DDB679D0547CCDEC6384285A45429D115AC7D235A717242021D1DC35641F5F0A48E8445DBA58E6CB2C8EA\"),\n\t    SHEX(\"55E228BCBDA7061642D004373D4E6407B72A37381D1BEFFCBFBF9F5F6EA093EA\"));\n  test_hash(&nettle_sha3_256, /* 169 octets */\n\t    SHEX(\"B39FEB8283EADC63E8184B51DF5AE3FD41AAC8A963BB0BE1CD08AA5867D8D910C669221E73243360646F6553D1CA05A84E8DC0DE05B6419EC349CA994480193D01C92525F3FB3DCEFB08AFC6D26947BDBBFD85193F53B50609C6140905C53A6686B58E53A319A57B962331EDE98149AF3DE3118A819DA4D76706A0424B4E1D2910B0ED26AF61D150EBCB46595D4266A0BD7F651BA47D0C7F179CA28545007D92E8419D48FDFBD744CE\"),\n\t    SHEX(\"0523C09BBCFFE418D3FCD22C6ABF95ABFB38F94CE5562B8BFCD2EEA9FB729041\"));\n  test_hash(&nettle_sha3_256, /* 170 octets */\n\t    SHEX(\"A983D54F503803E8C7999F4EDBBE82E9084F422143A932DDDDC47A17B0B7564A7F37A99D0786E99476428D29E29D3C197A72BFAB1342C12A0FC4787FD7017D7A6174049EA43B5779169EF7472BDBBD941DCB82FC73AAC45A8A94C9F2BD3477F61FD3B796F02A1B8264A214C6FEA74B7051B226C722099EC7883A462B83B6AFDD4009248B8A237F605FE5A08FE7D8B45321421EBBA67BD70A0B00DDBF94BAAB7F359D5D1EEA105F28DCFB\"),\n\t    SHEX(\"DCBC258241ADED3799996C2AD6ED0E3D74CFCC67749D3480B2A9A78E5F8AFF82\"));\n  test_hash(&nettle_sha3_256, /* 171 octets */\n\t    SHEX(\"E4D1C1897A0A866CE564635B74222F9696BF2C7F640DD78D7E2ACA66E1B61C642BB03EA7536AAE597811E9BF4A7B453EDE31F97B46A5F0EF51A071A2B3918DF16B152519AE3776F9F1EDAB4C2A377C3292E96408359D3613844D5EB393000283D5AD3401A318B12FD1474B8612F2BB50FB6A8B9E023A54D7DDE28C43D6D8854C8D9D1155935C199811DBFC87E9E0072E90EB88681CC7529714F8FB8A2C9D88567ADFB974EE205A9BF7B848\"),\n\t    SHEX(\"CBE8318E7B2FE72BFCD2530CCCECEA4018B1587F483B73F50CE5E84CED65E093\"));\n  test_hash(&nettle_sha3_256, /* 172 octets */\n\t    SHEX(\"B10C59723E3DCADD6D75DF87D0A1580E73133A9B7D00CB95EC19F5547027323BE75158B11F80B6E142C6A78531886D9047B08E551E75E6261E79785366D7024BD7CD9CF322D9BE7D57FB661069F2481C7BB759CD71B4B36CA2BC2DF6D3A328FAEBDB995A9794A8D72155ED551A1F87C80BF6059B43FC764900B18A1C2441F7487743CF84E565F61F8DD2ECE6B6CCC9444049197AAAF53E926FBEE3BFCA8BE588EC77F29D211BE89DE18B15F6\"),\n\t    SHEX(\"8CEA2960087048E6E6D47E31554F305FCC81E03E90BA8F8332DD86C6B6B38E03\"));\n  test_hash(&nettle_sha3_256, /* 173 octets */\n\t    SHEX(\"DB11F609BABA7B0CA634926B1DD539C8CBADA24967D7ADD4D9876F77C2D80C0F4DCEFBD7121548373582705CCA2495BD2A43716FE64ED26D059CFB566B3364BD49EE0717BDD9810DD14D8FAD80DBBDC4CAFB37CC60FB0FE2A80FB4541B8CA9D59DCE457738A9D3D8F641AF8C3FD6DA162DC16FC01AAC527A4A0255B4D231C0BE50F44F0DB0B713AF03D968FE7F0F61ED0824C55C4B5265548FEBD6AAD5C5EEDF63EFE793489C39B8FD29D104CE\"),\n\t    SHEX(\"44E276991E5382BD7EB5ADCF1F79362804D346BEDFC6916F4DCA4B57240E9C99\"));\n  test_hash(&nettle_sha3_256, /* 174 octets */\n\t    SHEX(\"BEBD4F1A84FC8B15E4452A54BD02D69E304B7F32616AADD90537937106AE4E28DE9D8AAB02D19BC3E2FDE1D651559E296453E4DBA94370A14DBBB2D1D4E2022302EE90E208321EFCD8528AD89E46DC839EA9DF618EA8394A6BFF308E7726BAE0C19BCD4BE52DA6258E2EF4E96AA21244429F49EF5CB486D7FF35CAC1BACB7E95711944BCCB2AB34700D42D1EB38B5D536B947348A458EDE3DC6BD6EC547B1B0CAE5B257BE36A7124E1060C170FFA\"),\n\t    SHEX(\"80891A086AF385025068799F192411C689CC4E0D9A59F3F41DBB02A343F1A759\"));\n  test_hash(&nettle_sha3_256, /* 175 octets */\n\t    SHEX(\"5ACA56A03A13784BDC3289D9364F79E2A85C12276B49B92DB0ADAA4F206D5028F213F678C3510E111F9DC4C1C1F8B6ACB17A6413AA227607C515C62A733817BA5E762CC6748E7E0D6872C984D723C9BB3B117EB8963185300A80BFA65CDE495D70A46C44858605FCCBED086C2B45CEF963D33294DBE9706B13AF22F1B7C4CD5A001CFEC251FBA18E722C6E1C4B1166918B4F6F48A98B64B3C07FC86A6B17A6D0480AB79D4E6415B520F1C484D675B1\"),\n\t    SHEX(\"77DDF034B7DFD6B292AA3B0C1E552F47B1D8C23078042CC58BB3DD4720B9EE4D\"));\n  test_hash(&nettle_sha3_256, /* 176 octets */\n\t    SHEX(\"A5AAD0E4646A32C85CFCAC73F02FC5300F1982FABB2F2179E28303E447854094CDFC854310E5C0F60993CEFF54D84D6B46323D930ADB07C17599B35B505F09E784BCA5985E0172257797FB53649E2E9723EFD16865C31B5C3D5113B58BB0BFC8920FABDDA086D7537E66D709D050BD14D0C960873F156FAD5B3D3840CDFCDC9BE6AF519DB262A27F40896AB25CC39F96984D650611C0D5A3080D5B3A1BF186ABD42956588B3B58CD948970D298776060\"),\n\t    SHEX(\"23D2688D867A18040E82F7876ACF04DC3A9C0140FEDD93EBE7ADF920B2F83DA4\"));\n  test_hash(&nettle_sha3_256, /* 177 octets */\n\t    SHEX(\"06CBBE67E94A978203EAD6C057A1A5B098478B4B4CBEF5A97E93C8E42F5572713575FC2A884531D7622F8F879387A859A80F10EF02708CD8F7413AB385AFC357678B9578C0EBF641EF076A1A30F1F75379E9DCB2A885BDD295905EE80C0168A62A9597D10CF12DD2D8CEE46645C7E5A141F6E0E23AA482ABE5661C16E69EF1E28371E2E236C359BA4E92C25626A7B7FF13F6EA4AE906E1CFE163E91719B1F750A96CBDE5FBC953D9E576CD216AFC90323A\"),\n\t    SHEX(\"2DF666FC5D4EAD1C3B10B9F8D4BB81AEA4F93D3873D5CE5CFBAC4B69435E1B7C\"));\n  test_hash(&nettle_sha3_256, /* 178 octets */\n\t    SHEX(\"F1C528CF7739874707D4D8AD5B98F7C77169DE0B57188DF233B2DC8A5B31EDA5DB4291DD9F68E6BAD37B8D7F6C9C0044B3BF74BBC3D7D1798E138709B0D75E7C593D3CCCDC1B20C7174B4E692ADD820ACE262D45CCFAE2077E878796347168060A162ECCA8C38C1A88350BD63BB539134F700FD4ADDD5959E255337DAA06BC86358FABCBEFDFB5BC889783D843C08AADC6C4F6C36F65F156E851C9A0F917E4A367B5AD93D874812A1DE6A7B93CD53AD97232\"),\n\t    SHEX(\"AF0C5474528032E2629B8FBB0E34405F7F251D41E73B5667BE3C07CCB2C1C953\"));\n  test_hash(&nettle_sha3_256, /* 179 octets */\n\t    SHEX(\"9D9F3A7ECD51B41F6572FD0D0881E30390DFB780991DAE7DB3B47619134718E6F987810E542619DFAA7B505C76B7350C6432D8BF1CFEBDF1069B90A35F0D04CBDF130B0DFC7875F4A4E62CDB8E525AADD7CE842520A482AC18F09442D78305FE85A74E39E760A4837482ED2F437DD13B2EC1042AFCF9DECDC3E877E50FF4106AD10A525230D11920324A81094DA31DEAB6476AA42F20C84843CFC1C58545EE80352BDD3740DD6A16792AE2D86F11641BB717C2\"),\n\t    SHEX(\"9BBEF7A75391354A388AAA7CA035DC62D3231B80091BB7748F76E52D8E9F20F0\"));\n  test_hash(&nettle_sha3_256, /* 180 octets */\n\t    SHEX(\"5179888724819FBAD3AFA927D3577796660E6A81C52D98E9303261D5A4A83232F6F758934D50AA83FF9E20A5926DFEBAAC49529D006EB923C5AE5048ED544EC471ED7191EDF46363383824F915769B3E688094C682B02151E5EE01E510B431C8865AFF8B6B6F2F59CB6D129DA79E97C6D2B8FA6C6DA3F603199D2D1BCAB547682A81CD6CF65F6551121391D78BCC23B5BD0E922EC6D8BF97C952E84DD28AEF909ABA31EDB903B28FBFC33B7703CD996215A11238\"),\n\t    SHEX(\"B108457A6BD331BE43C9FE1E2A02E8C744C2BCC927A9C3C486F110DCCF907F6B\"));\n  test_hash(&nettle_sha3_256, /* 181 octets */\n\t    SHEX(\"576EF3520D30B7A4899B8C0D5E359E45C5189ADD100E43BE429A02FB3DE5FF4F8FD0E79D9663ACCA72CD29C94582B19292A557C5B1315297D168FBB54E9E2ECD13809C2B5FCE998EDC6570545E1499DBE7FB74D47CD7F35823B212B05BF3F5A79CAA34224FDD670D335FCB106F5D92C3946F44D3AFCBAE2E41AC554D8E6759F332B76BE89A0324AA12C5482D1EA3EE89DED4936F3E3C080436F539FA137E74C6D3389BDF5A45074C47BC7B20B0948407A66D855E2F\"),\n\t    SHEX(\"A61109838DFA5B146DF4E6C3BDBC7A477BE36B6228EBD91025012AF4CC0EB409\"));\n  test_hash(&nettle_sha3_256, /* 182 octets */\n\t    SHEX(\"0DF2152FA4F4357C8741529DD77E783925D3D76E95BAFA2B542A2C33F3D1D117D159CF473F82310356FEE4C90A9E505E70F8F24859656368BA09381FA245EB6C3D763F3093F0C89B972E66B53D59406D9F01AEA07F8B3B615CAC4EE4D05F542E7D0DAB45D67CCCCD3A606CCBEB31EA1FA7005BA07176E60DAB7D78F6810EF086F42F08E595F0EC217372B98970CC6321576D92CE38F7C397A403BADA1548D205C343AC09DECA86325373C3B76D9F32028FEA8EB32515\"),\n\t    SHEX(\"4F0F30C890B0AB404961158573538FE9A2B234B94A0991F26D5EA04FDDC9C565\"));\n  test_hash(&nettle_sha3_256, /* 183 octets */\n\t    SHEX(\"3E15350D87D6EBB5C8AD99D42515CFE17980933C7A8F6B8BBBF0A63728CEFAAD2052623C0BD5931839112A48633FB3C2004E0749C87A41B26A8B48945539D1FF41A4B269462FD199BFECD45374756F55A9116E92093AC99451AEFB2AF9FD32D6D7F5FBC7F7A540D5097C096EBC3B3A721541DE073A1CC02F7FB0FB1B9327FB0B1218CA49C9487AB5396622A13AE546C97ABDEF6B56380DDA7012A8384091B6656D0AB272D363CEA78163FF765CDD13AB1738B940D16CAE\"),\n\t    SHEX(\"85459CFB0289599CDD67C473A0BA6DA616C608E367F58C50A03562424DCF1D06\"));\n  test_hash(&nettle_sha3_256, /* 184 octets */\n\t    SHEX(\"C38D6B0B757CB552BE40940ECE0009EF3B0B59307C1451686F1A22702922800D58BCE7A636C1727EE547C01B214779E898FC0E560F8AE7F61BEF4D75EAA696B921FD6B735D171535E9EDD267C192B99880C87997711002009095D8A7A437E258104A41A505E5EF71E5613DDD2008195F0C574E6BA3FE40099CFA116E5F1A2FA8A6DA04BADCB4E2D5D0DE31FDC4800891C45781A0AAC7C907B56D631FCA5CE8B2CDE620D11D1777ED9FA603541DE794DDC5758FCD5FAD78C0\"),\n\t    SHEX(\"5539D2E52A5A1BB3C246B0158356E2B2782FC13C10248937A0C4A40B091F6247\"));\n  test_hash(&nettle_sha3_256, /* 185 octets */\n\t    SHEX(\"8D2DE3F0B37A6385C90739805B170057F091CD0C7A0BC951540F26A5A75B3E694631BB64C7635EED316F51318E9D8DE13C70A2ABA04A14836855F35E480528B776D0A1E8A23B547C8B8D6A0D09B241D3BE9377160CCA4E6793D00A515DC2992CB7FC741DACA171431DA99CCE6F7789F129E2AC5CF65B40D703035CD2185BB936C82002DAF8CBC27A7A9E554B06196630446A6F0A14BA155ED26D95BD627B7205C072D02B60DB0FD7E49EA058C2E0BA202DAFF0DE91E845CF79\"),\n\t    SHEX(\"6D63419207B99D4DB1ADD795D852A8DAAC11B789AF0C7D6353036CB23F6428B4\"));\n  test_hash(&nettle_sha3_256, /* 186 octets */\n\t    SHEX(\"C464BBDAD275C50DCD983B65AD1019B9FF85A1E71C807F3204BB2C921DC31FBCD8C5FC45868AE9EF85B6C9B83BBA2A5A822201ED68586EC5EC27FB2857A5D1A2D09D09115F22DCC39FE61F5E1BA0FF6E8B4ACB4C6DA748BE7F3F0839739394FF7FA8E39F7F7E84A33C3866875C01BCB1263C9405D91908E9E0B50E7459FABB63D8C6BBB73D8E3483C099B55BC30FF092FF68B6ADEDFD477D63570C9F5515847F36E24BA0B705557130CEC57EBAD1D0B31A378E91894EE26E3A04\"),\n\t    SHEX(\"D2090DAE0FC201B2B9C03DD482A8EB1FFD3CF70C55F98D6F39A41B8BDAC27A17\"));\n  test_hash(&nettle_sha3_256, /* 187 octets */\n\t    SHEX(\"8B8D68BB8A75732FE272815A68A1C9C5AA31B41DEDC8493E76525D1D013D33CEBD9E21A5BB95DB2616976A8C07FCF411F5F6BC6F7E0B57ACA78CC2790A6F9B898858AC9C79B165FF24E66677531E39F572BE5D81EB3264524181115F32780257BFB9AEEC6AF12AF28E587CAC068A1A2953B59AD680F4C245B2E3EC36F59940D37E1D3DB38E13EDB29B5C0F404F6FF87F80FC8BE7A225FF22FBB9C8B6B1D7330C57840D24BC75B06B80D30DAD6806544D510AF6C4785E823AC3E0B8\"),\n\t    SHEX(\"C9E8F96BA75EAF371DCA35DC69138ECA8CB3F2823F3BE551D9DC8AA6A4ED4169\"));\n  test_hash(&nettle_sha3_256, /* 188 octets */\n\t    SHEX(\"6B018710446F368E7421F1BC0CCF562D9C1843846BC8D98D1C9BF7D9D6FCB48BFC3BF83B36D44C4FA93430AF75CD190BDE36A7F92F867F58A803900DF8018150384D85D82132F123006AC2AEBA58E02A037FE6AFBD65ECA7C44977DD3DC74F48B6E7A1BFD5CC4DCF24E4D52E92BD4455848E4928B0EAC8B7476FE3CC03E862AA4DFF4470DBFED6DE48E410F25096487ECFC32A27277F3F5023B2725ADE461B1355889554A8836C9CF53BD767F5737D55184EEA1AB3F53EDD0976C485\"),\n\t    SHEX(\"233B0BC28143C32A668B0AB5D76BE5712C0387056FB0E79F2C2F7F1C31E4A86A\"));\n  test_hash(&nettle_sha3_256, /* 189 octets */\n\t    SHEX(\"C9534A24714BD4BE37C88A3DA1082EDA7CABD154C309D7BD670DCCD95AA535594463058A29F79031D6ECAA9F675D1211E9359BE82669A79C855EA8D89DD38C2C761DDD0EC0CE9E97597432E9A1BEAE062CDD71EDFDFD464119BE9E69D18A7A7FD7CE0E2106F0C8B0ABF4715E2CA48EF9F454DC203C96656653B727083513F8EFB86E49C513BB758B3B052FE21F1C05BB33C37129D6CC81F1AEF6ADC45B0E8827A830FE545CF57D0955802C117D23CCB55EA28F95C0D8C2F9C5A242B33F\"),\n\t    SHEX(\"B79B5F8182D3FB4ABAB63E7CB26A8E0865AE8D79BD4C514AD8917D5ECB7FED8F\"));\n  test_hash(&nettle_sha3_256, /* 190 octets */\n\t    SHEX(\"07906C87297B867ABF4576E9F3CC7F82F22B154AFCBF293B9319F1B0584DA6A40C27B32E0B1B7F412C4F1B82480E70A9235B12EC27090A5A33175A2BB28D8ADC475CEFE33F7803F8CE27967217381F02E67A3B4F84A71F1C5228E0C2AD971373F6F672624FCEA8D1A9F85170FAD30FA0BBD25035C3B41A6175D467998BD1215F6F3866F53847F9CF68EF3E2FBB54BC994DE2302B829C5EEA68EC441FCBAFD7D16AE4FE9FFF98BF00E5BC2AD54DD91FF9FDA4DD77B6C754A91955D1FBAAD0\"),\n\t    SHEX(\"F680198DE2943D20E9D809FD8312D674C9A250DA22BA6E920E408F6F2C0E0739\"));\n  test_hash(&nettle_sha3_256, /* 191 octets */\n\t    SHEX(\"588E94B9054ABC2189DF69B8BA34341B77CDD528E7860E5DEFCAA79B0C9A452AD4B82AA306BE84536EB7CEDCBE058D7B84A6AEF826B028B8A0271B69AC3605A9635EA9F5EA0AA700F3EB7835BC54611B922964300C953EFE7491E3677C2CEBE0822E956CD16433B02C68C4A23252C3F9E151A416B4963257B783E038F6B4D5C9F110F871652C7A649A7BCEDCBCCC6F2D0725BB903CC196BA76C76AA9F10A190B1D1168993BAA9FFC96A1655216773458BEC72B0E39C9F2C121378FEAB4E76A\"),\n\t    SHEX(\"A190DD73556086EA70BC31022D6A4F95D89DC099E2030C19311CC8988281278F\"));\n  test_hash(&nettle_sha3_256, /* 192 octets */\n\t    SHEX(\"08959A7E4BAAE874928813364071194E2939772F20DB7C3157078987C557C2A6D5ABE68D520EEF3DC491692E1E21BCD880ADEBF63BB4213B50897FA005256ED41B5690F78F52855C8D9168A4B666FCE2DA2B456D7A7E7C17AB5F2FB1EE90B79E698712E963715983FD07641AE4B4E9DC73203FAC1AE11FA1F8C7941FCC82EAB247ADDB56E2638447E9D609E610B60CE086656AAEBF1DA3C8A231D7D94E2FD0AFE46B391FF14A72EAEB3F44AD4DF85866DEF43D4781A0B3578BC996C87970B132\"),\n\t    SHEX(\"21166064C52B588C1EC7EA6DF1905A2B59BAD499B470F308A26B6E354DDFE58F\"));\n  test_hash(&nettle_sha3_256, /* 193 octets */\n\t    SHEX(\"CB2A234F45E2ECD5863895A451D389A369AAB99CFEF0D5C9FFCA1E6E63F763B5C14FB9B478313C8E8C0EFEB3AC9500CF5FD93791B789E67EAC12FD038E2547CC8E0FC9DB591F33A1E4907C64A922DDA23EC9827310B306098554A4A78F050262DB5B545B159E1FF1DCA6EB734B872343B842C57EAFCFDA8405EEDBB48EF32E99696D135979235C3A05364E371C2D76F1902F1D83146DF9495C0A6C57D7BF9EE77E80F9787AEE27BE1FE126CDC9EF893A4A7DCBBC367E40FE4E1EE90B42EA25AF01\"),\n\t    SHEX(\"051E19906464EC7FDC3D37EE3BCEF63438EC5EDBEA5AA202A24B7F7190B689E0\"));\n  test_hash(&nettle_sha3_256, /* 194 octets */\n\t    SHEX(\"D16BEADF02AB1D4DC6F88B8C4554C51E866DF830B89C06E786A5F8757E8909310AF51C840EFE8D20B35331F4355D80F73295974653DDD620CDDE4730FB6C8D0D2DCB2B45D92D4FBDB567C0A3E86BD1A8A795AF26FBF29FC6C65941CDDB090FF7CD230AC5268AB4606FCCBA9EDED0A2B5D014EE0C34F0B2881AC036E24E151BE89EEB6CD9A7A790AFCCFF234D7CB11B99EBF58CD0C589F20BDAC4F9F0E28F75E3E04E5B3DEBCE607A496D848D67FA7B49132C71B878FD5557E082A18ECA1FBDA94D4B\"),\n\t    SHEX(\"18FE66C0CD095C9CC811F5410B5CFDC1B152AE3CAB0C3328974E7D4BBEB40053\"));\n  test_hash(&nettle_sha3_256, /* 195 octets */\n\t    SHEX(\"8F65F6BC59A85705016E2BAE7FE57980DE3127E5AB275F573D334F73F8603106EC3553016608EF2DD6E69B24BE0B7113BF6A760BA6E9CE1C48F9E186012CF96A1D4849D75DF5BB8315387FD78E9E153E76F8BA7EC6C8849810F59FB4BB9B004318210B37F1299526866F44059E017E22E96CBE418699D014C6EA01C9F0038B10299884DBEC3199BB05ADC94E955A1533219C1115FED0E5F21228B071F40DD57C4240D98D37B73E412FE0FA4703120D7C0C67972ED233E5DEB300A22605472FA3A3BA86\"),\n\t    SHEX(\"BDB42638921199D604294B5578CEBACCDF132E1D7AF7675B7768E50553FCB604\"));\n  test_hash(&nettle_sha3_256, /* 196 octets */\n\t    SHEX(\"84891E52E0D451813210C3FD635B39A03A6B7A7317B221A7ABC270DFA946C42669AACBBBDF801E1584F330E28C729847EA14152BD637B3D0F2B38B4BD5BF9C791C58806281103A3EABBAEDE5E711E539E6A8B2CF297CF351C078B4FA8F7F35CF61BEBF8814BF248A01D41E86C5715EA40C63F7375379A7EB1D78F27622FB468AB784AAABA4E534A6DFD1DF6FA15511341E725ED2E87F98737CCB7B6A6DFAE416477472B046BF1811187D151BFA9F7B2BF9ACDB23A3BE507CDF14CFDF517D2CB5FB9E4AB6\"),\n\t    SHEX(\"CBD88209B530018A856C5C2321D7E485511CA1513661F1FDE1FA06F4603DE117\"));\n  test_hash(&nettle_sha3_256, /* 197 octets */\n\t    SHEX(\"FDD7A9433A3B4AFABD7A3A5E3457E56DEBF78E84B7A0B0CA0E8C6D53BD0C2DAE31B2700C6128334F43981BE3B213B1D7A118D59C7E6B6493A86F866A1635C12859CFB9AD17460A77B4522A5C1883C3D6ACC86E6162667EC414E9A104AA892053A2B1D72165A855BACD8FAF8034A5DD9B716F47A0818C09BB6BAF22AA503C06B4CA261F557761989D2AFBD88B6A678AD128AF68672107D0F1FC73C5CA740459297B3292B281E93BCEB761BDE7221C3A55708E5EC84472CDDCAA84ECF23723CC0991355C6280\"),\n\t    SHEX(\"F0C4C1374F33A91DC657F8A3FA51763CBD0FBA1CAFDD2C595ED302AAB1AB75A9\"));\n  test_hash(&nettle_sha3_256, /* 198 octets */\n\t    SHEX(\"70A40BFBEF92277A1AAD72F6B79D0177197C4EBD432668CFEC05D099ACCB651062B5DFF156C0B27336687A94B26679CFDD9DAF7AD204338DD9C4D14114033A5C225BD11F217B5F4732DA167EE3F939262D4043FC9CBA92303B7B5E96AEA12ADDA64859DF4B86E9EE0B58E39091E6B188B408AC94E1294A8911245EE361E60E601EFF58D1D37639F3753BEC80EBB4EFDE25817436076623FC65415FE51D1B0280366D12C554D86743F3C3B6572E400361A60726131441BA493A83FBE9AFDA90F7AF1AE717238D\"),\n\t    SHEX(\"F2157C165EEBDFD04451E9E6CF0B112BB148EB9C40E8B2427EE8EA57E60D5DD6\"));\n  test_hash(&nettle_sha3_256, /* 199 octets */\n\t    SHEX(\"74356E449F4BF8644F77B14F4D67CB6BD9C1F5AE357621D5B8147E562B65C66585CAF2E491B48529A01A34D226D436959153815380D5689E30B35357CDAC6E08D3F2B0E88E200600D62BD9F5EAF488DF86A4470EA227006182E44809009868C4C280C43D7D64A5268FA719074960087B3A6ABC837882F882C837834535929389A12B2C78187E2EA07EF8B8EEF27DC85002C3AE35F1A50BEE6A1C48BA7E175F3316670B27983472AA6A61EED0A683A39EE323080620EA44A9F74411AE5CE99030528F9AB49C79F2\"),\n\t    SHEX(\"0836ABBF77EF78E162DE8FB664B9996D5A03919B741EB4A3F02E7B97826569FA\"));\n  test_hash(&nettle_sha3_256, /* 200 octets */\n\t    SHEX(\"8C3798E51BC68482D7337D3ABB75DC9FFE860714A9AD73551E120059860DDE24AB87327222B64CF774415A70F724CDF270DE3FE47DDA07B61C9EF2A3551F45A5584860248FABDE676E1CD75F6355AA3EAEABE3B51DC813D9FB2EAA4F0F1D9F834D7CAD9C7C695AE84B329385BC0BEF895B9F1EDF44A03D4B410CC23A79A6B62E4F346A5E8DD851C2857995DDBF5B2D717AEB847310E1F6A46AC3D26A7F9B44985AF656D2B7C9406E8A9E8F47DCB4EF6B83CAACF9AEFB6118BFCFF7E44BEF6937EBDDC89186839B77\"),\n\t    SHEX(\"84970C79316E89B70E2B186A69DB1A4C3E33C7A376B45C1B79BD346DD33EF4CE\"));\n  test_hash(&nettle_sha3_256, /* 201 octets */\n\t    SHEX(\"FA56BF730C4F8395875189C10C4FB251605757A8FECC31F9737E3C2503B02608E6731E85D7A38393C67DE516B85304824BFB135E33BF22B3A23B913BF6ACD2B7AB85198B8187B2BCD454D5E3318CACB32FD6261C31AE7F6C54EF6A7A2A4C9F3ECB81CE3555D4F0AD466DD4C108A90399D70041997C3B25345A9653F3C9A6711AB1B91D6A9D2216442DA2C973CBD685EE7643BFD77327A2F7AE9CB283620A08716DFB462E5C1D65432CA9D56A90E811443CD1ECB8F0DE179C9CB48BA4F6FEC360C66F252F6E64EDC96B\"),\n\t    SHEX(\"06ED2EBC419D053949E88CC9C040B1EBCE74375AD0CE09C0CD4D562C62F8497D\"));\n  test_hash(&nettle_sha3_256, /* 202 octets */\n\t    SHEX(\"B6134F9C3E91DD8000740D009DD806240811D51AB1546A974BCB18D344642BAA5CD5903AF84D58EC5BA17301D5EC0F10CCD0509CBB3FD3FFF9172D193AF0F782252FD1338C7244D40E0E42362275B22D01C4C3389F19DD69BDF958EBE28E31A4FFE2B5F18A87831CFB7095F58A87C9FA21DB72BA269379B2DC2384B3DA953C7925761FED324620ACEA435E52B424A7723F6A2357374157A34CD8252351C25A1B232826CEFE1BD3E70FFC15A31E7C0598219D7F00436294D11891B82497BC78AA5363892A2495DF8C1EEF\"),\n\t    SHEX(\"CF9060AF3E4ED47316ACF51E5B92123CDC4827BD4AEF991588DCD8078B9EEA40\"));\n  test_hash(&nettle_sha3_256, /* 203 octets */\n\t    SHEX(\"C941CDB9C28AB0A791F2E5C8E8BB52850626AA89205BEC3A7E22682313D198B1FA33FC7295381354858758AE6C8EC6FAC3245C6E454D16FA2F51C4166FAB51DF272858F2D603770C40987F64442D487AF49CD5C3991CE858EA2A60DAB6A65A34414965933973AC2457089E359160B7CDEDC42F29E10A91921785F6B7224EE0B349393CDCFF6151B50B377D609559923D0984CDA6000829B916AB6896693EF6A2199B3C22F7DC5500A15B8258420E314C222BC000BC4E5413E6DD82C993F8330F5C6D1BE4BC79F08A1A0A46\"),\n\t    SHEX(\"63E407300F99FF2360F02AAE0ADA35F6C1A90AED2C63282B23A7990BAE307254\"));\n  test_hash(&nettle_sha3_256, /* 204 octets */\n\t    SHEX(\"4499EFFFAC4BCEA52747EFD1E4F20B73E48758BE915C88A1FFE5299B0B005837A46B2F20A9CB3C6E64A9E3C564A27C0F1C6AD1960373036EC5BFE1A8FC6A435C2185ED0F114C50E8B3E4C7ED96B06A036819C9463E864A58D6286F785E32A804443A56AF0B4DF6ABC57ED5C2B185DDEE8489EA080DEEEE66AA33C2E6DAB36251C402682B6824821F998C32163164298E1FAFD31BABBCFFB594C91888C6219079D907FDB438ED89529D6D96212FD55ABE20399DBEFD342248507436931CDEAD496EB6E4A80358ACC78647D043\"),\n\t    SHEX(\"427741570D5E21590E5045A8450216365BA95C2E72455A3DBD694F13155DE1B7\"));\n  test_hash(&nettle_sha3_256, /* 205 octets */\n\t    SHEX(\"EECBB8FDFA4DA62170FD06727F697D81F83F601FF61E478105D3CB7502F2C89BF3E8F56EDD469D049807A38882A7EEFBC85FC9A950952E9FA84B8AFEBD3CE782D4DA598002827B1EB98882EA1F0A8F7AA9CE013A6E9BC462FB66C8D4A18DA21401E1B93356EB12F3725B6DB1684F2300A98B9A119E5D27FF704AFFB618E12708E77E6E5F34139A5A41131FD1D6336C272A8FC37080F041C71341BEE6AB550CB4A20A6DDB6A8E0299F2B14BC730C54B8B1C1C487B494BDCCFD3A53535AB2F231590BF2C4062FD2AD58F906A2D0D\"),\n\t    SHEX(\"B5E60A019E8414D470AE702738BC358F1C80BB6FF7BDE4F2DBB56C299C764B16\"));\n  test_hash(&nettle_sha3_256, /* 206 octets */\n\t    SHEX(\"E64F3E4ACE5C8418D65FEC2BC5D2A303DD458034736E3B0DF719098BE7A206DEAF52D6BA82316CAF330EF852375188CDE2B39CC94AA449578A7E2A8E3F5A9D68E816B8D16889FBC0EBF0939D04F63033AE9AE2BDAB73B88C26D6BD25EE460EE1EF58FB0AFA92CC539F8C76D3D097E7A6A63EBB9B5887EDF3CF076028C5BBD5B9DB3211371AD3FE121D4E9BF44229F4E1ECF5A0F9F0EBA4D5CEB72878AB22C3F0EB5A625323AC66F7061F4A81FAC834471E0C59553F108475FE290D43E6A055AE3EE46FB67422F814A68C4BE3E8C9\"),\n\t    SHEX(\"C986BDAE9B13FBC92793619E4970ABC33398F2B5A57A6CBB40A622592E2695DF\"));\n  test_hash(&nettle_sha3_256, /* 207 octets */\n\t    SHEX(\"D2CB2D733033F9E91395312808383CC4F0CA974E87EC68400D52E96B3FA6984AC58D9AD0938DDE5A973008D818C49607D9DE2284E7618F1B8AED8372FBD52ED54557AF4220FAC09DFA8443011699B97D743F8F2B1AEF3537EBB45DCC9E13DFB438428EE190A4EFDB3CAEB7F3933117BF63ABDC7E57BEB4171C7E1AD260AB0587806C4D137B6316B50ABC9CCE0DFF3ACADA47BBB86BE777E617BBE578FF4519844DB360E0A96C6701290E76BB95D26F0F804C8A4F2717EAC4E7DE9F2CFF3BBC55A17E776C0D02856032A6CD10AD2838\"),\n\t    SHEX(\"224C7FC8A0EC3895E8969CE7C7F7ECAA54FE2EEC9AB3120726106F22AA297541\"));\n  test_hash(&nettle_sha3_256, /* 208 octets */\n\t    SHEX(\"F2998955613DD414CC111DF5CE30A995BB792E260B0E37A5B1D942FE90171A4AC2F66D4928D7AD377F4D0554CBF4C523D21F6E5F379D6F4B028CDCB9B1758D3B39663242FF3CB6EDE6A36A6F05DB3BC41E0D861B384B6DEC58BB096D0A422FD542DF175E1BE1571FB52AE66F2D86A2F6824A8CFAACBAC4A7492AD0433EEB15454AF8F312B3B2A577750E3EFBD370E8A8CAC1582581971FBA3BA4BD0D76E718DACF8433D33A59D287F8CC92234E7A271041B526E389EFB0E40B6A18B3AAF658E82ED1C78631FD23B4C3EB27C3FAEC8685\"),\n\t    SHEX(\"FAF5E3B7A64629FFEEE07A67ED77A3A4F67F18C9381FE9B19F6EE601F5FB99AF\"));\n  test_hash(&nettle_sha3_256, /* 209 octets */\n\t    SHEX(\"447797E2899B72A356BA55BF4DF3ACCA6CDB1041EB477BD1834A9F9ACBC340A294D729F2F97DF3A610BE0FF15EDB9C6D5DB41644B9874360140FC64F52AA03F0286C8A640670067A84E017926A70438DB1BB361DEFEE7317021425F8821DEF26D1EFD77FC853B818545D055ADC9284796E583C76E6FE74C9AC2587AA46AA8F8804F2FEB5836CC4B3ABABAB8429A5783E17D5999F32242EB59EF30CD7ADABC16D72DBDB097623047C98989F88D14EAF02A7212BE16EC2D07981AAA99949DDF89ECD90333A77BC4E1988A82ABF7C7CAF3291\"),\n\t    SHEX(\"A8A98E6B3A005FCB319FEE58C5457D04B69D59F53873F6FCC6065D68F880833F\"));\n  test_hash(&nettle_sha3_256, /* 210 octets */\n\t    SHEX(\"9F2C18ADE9B380C784E170FB763E9AA205F64303067EB1BCEA93DF5DAC4BF5A2E00B78195F808DF24FC76E26CB7BE31DC35F0844CDED1567BBA29858CFFC97FB29010331B01D6A3FB3159CC1B973D255DA9843E34A0A4061CABDB9ED37F241BFABB3C20D32743F4026B59A4CCC385A2301F83C0B0A190B0F2D01ACB8F0D41111E10F2F4E149379275599A52DC089B35FDD5234B0CFB7B6D8AEBD563CA1FA653C5C021DFD6F5920E6F18BFAFDBECBF0AB00281333ED50B9A999549C1C8F8C63D7626C48322E9791D5FF72294049BDE91E73F8\"),\n\t    SHEX(\"C89F2B346127EAB9E28095DC44918C1A1AAEAE04861C1DD0144A1EE07F823C18\"));\n  test_hash(&nettle_sha3_256, /* 211 octets */\n\t    SHEX(\"AE159F3FA33619002AE6BCCE8CBBDD7D28E5ED9D61534595C4C9F43C402A9BB31F3B301CBFD4A43CE4C24CD5C9849CC6259ECA90E2A79E01FFBAC07BA0E147FA42676A1D668570E0396387B5BCD599E8E66AAED1B8A191C5A47547F61373021FA6DEADCB55363D233C24440F2C73DBB519F7C9FA5A8962EFD5F6252C0407F190DFEFAD707F3C7007D69FF36B8489A5B6B7C557E79DD4F50C06511F599F56C896B35C917B63BA35C6FF8092BAF7D1658E77FC95D8A6A43EEB4C01F33F03877F92774BE89C1114DD531C011E53A34DC248A2F0E6\"),\n\t    SHEX(\"E7A81ACBEF35D7B24B706549B41ABD82628CCFF9ACF41F2C8ADD28743688AE01\"));\n  test_hash(&nettle_sha3_256, /* 212 octets */\n\t    SHEX(\"3B8E97C5FFC2D6A40FA7DE7FCEFC90F3B12C940E7AB415321E29EE692DFAC799B009C99DCDDB708FCE5A178C5C35EE2B8617143EDC4C40B4D313661F49ABDD93CEA79D117518805496FE6ACF292C4C2A1F76B403A97D7C399DAF85B46AD84E16246C67D6836757BDE336C290D5D401E6C1386AB32797AF6BB251E9B2D8FE754C47482B72E0B394EAB76916126FD68EA7D65EB93D59F5B4C5AC40F7C3B37E7F3694F29424C24AF8C8F0EF59CD9DBF1D28E0E10F799A6F78CAD1D45B9DB3D7DEE4A7059ABE99182714983B9C9D44D7F5643596D4F3\"),\n\t    SHEX(\"D81249143A69EA1C9DC168B55FFE06D46D0FBC007065110353D76C6CCE4FFE66\"));\n  test_hash(&nettle_sha3_256, /* 213 octets */\n\t    SHEX(\"3434EC31B10FAFDBFEEC0DD6BD94E80F7BA9DCA19EF075F7EB017512AF66D6A4BCF7D16BA0819A1892A6372F9B35BCC7CA8155EE19E8428BC22D214856ED5FA9374C3C09BDE169602CC219679F65A1566FC7316F4CC3B631A18FB4449FA6AFA16A3DB2BC4212EFF539C67CF184680826535589C7111D73BFFCE431B4C40492E763D9279560AAA38EB2DC14A212D723F994A1FE656FF4DD14551CE4E7C621B2AA5604A10001B2878A897A28A08095C325E10A26D2FB1A75BFD64C250309BB55A44F23BBAC0D5516A1C687D3B41EF2FBBF9CC56D4739\"),\n\t    SHEX(\"AA8BBD4812142211212763BF8EE4D6E0AADAFE5E528AEA1FB1BE118806E49F66\"));\n  test_hash(&nettle_sha3_256, /* 214 octets */\n\t    SHEX(\"7C7953D81C8D208FD1C97681D48F49DD003456DE60475B84070EF4847C333B74575B1FC8D2A186964485A3B8634FEAA3595AAA1A2F4595A7D6B6153563DEE31BBAC443C8A33EED6D5D956A980A68366C2527B550EE950250DFB691EACBD5D56AE14B970668BE174C89DF2FEA43AE52F13142639C884FD62A3683C0C3792F0F24AB1318BCB27E21F4737FAB62C77EA38BC8FD1CF41F7DAB64C13FEBE7152BF5BB7AB5A78F5346D43CC741CB6F72B7B8980F268B68BF62ABDFB1577A52438FE14B591498CC95F071228460C7C5D5CEB4A7BDE588E7F21C\"),\n\t    SHEX(\"4089B181DF5ECA5F14DAB1057AAAEECABA15F200FDDA0DE49357D6196FAAB44B\"));\n  test_hash(&nettle_sha3_256, /* 215 octets */\n\t    SHEX(\"7A6A4F4FDC59A1D223381AE5AF498D74B7252ECF59E389E49130C7EAEE626E7BD9897EFFD92017F4CCDE66B0440462CDEDFD352D8153E6A4C8D7A0812F701CC737B5178C2556F07111200EB627DBC299CAA792DFA58F35935299FA3A3519E9B03166DFFA159103FFA35E8577F7C0A86C6B46FE13DB8E2CDD9DCFBA85BDDDCCE0A7A8E155F81F712D8E9FE646153D3D22C811BD39F830433B2213DD46301941B59293FD0A33E2B63ADBD95239BC01315C46FDB678875B3C81E053A40F581CFBEC24A1404B1671A1B88A6D06120229518FB13A74CA0AC5AE\"),\n\t    SHEX(\"DEBF59BB233D05549853804FC67840821BD5802F87FC8A915B710D3E82070950\"));\n  test_hash(&nettle_sha3_256, /* 216 octets */\n\t    SHEX(\"D9FAA14CEBE9B7DE551B6C0765409A33938562013B5E8E0E1E0A6418DF7399D0A6A771FB81C3CA9BD3BB8E2951B0BC792525A294EBD1083688806FE5E7F1E17FD4E3A41D00C89E8FCF4A363CAEDB1ACB558E3D562F1302B3D83BB886ED27B76033798131DAB05B4217381EAAA7BA15EC820BB5C13B516DD640EAEC5A27D05FDFCA0F35B3A5312146806B4C0275BCD0AAA3B2017F346975DB566F9B4D137F4EE10644C2A2DA66DEECA5342E236495C3C6280528BFD32E90AF4CD9BB908F34012B52B4BC56D48CC8A6B59BAB014988EABD12E1A0A1C2E170E7\"),\n\t    SHEX(\"0FDBA1C79F55F233A1217F522D6C81F777F330FADB565E1171F39E1788913342\"));\n  test_hash(&nettle_sha3_256, /* 217 octets */\n\t    SHEX(\"2D8427433D0C61F2D96CFE80CF1E932265A191365C3B61AAA3D6DCC039F6BA2AD52A6A8CC30FC10F705E6B7705105977FA496C1C708A277A124304F1FC40911E7441D1B5E77B951AAD7B01FD5DB1B377D165B05BBF898042E39660CAF8B279FE5229D1A8DB86C0999ED65E53D01CCBC4B43173CCF992B3A14586F6BA42F5FE30AFA8AE40C5DF29966F9346DA5F8B35F16A1DE3AB6DE0F477D8D8660918060E88B9B9E9CA6A4207033B87A812DBF5544D39E4882010F82B6CE005F8E8FF6FE3C3806BC2B73C2B83AFB704345629304F9F86358712E9FAE3CA3E\"),\n\t    SHEX(\"ED45A06E95A6539270B02290D71005F01C55BA077414C3BCDB379537E6DBEFC9\"));\n  test_hash(&nettle_sha3_256, /* 218 octets */\n\t    SHEX(\"5E19D97887FCAAC0387E22C6F803C34A3DACD2604172433F7A8A7A526CA4A2A1271ECFC5D5D7BE5AC0D85D921095350DFC65997D443C21C8094E0A3FEFD2961BCB94AED03291AE310CCDA75D8ACE4BC7D89E7D3E5D1650BDA5D668B8B50BFC8E608E184F4D3A9A2BADC4FF5F07E0C0BC8A9F2E0B2A26FD6D8C550008FAAAB75FD71AF2A424BEC9A7CD9D83FAD4C8E9319115656A8717D3B523A68FF8004258B9990ED362308461804BA3E3A7E92D8F2FFAE5C2FBA55BA5A3C27C0A2F71BD711D2FE1799C2ADB31B200035481E9EE5C4ADF2AB9C0FA50B23975CF\"),\n\t    SHEX(\"37E7CF6A9A31B0982B2479432B7838657741B0EE79ADDA1B287550EB325C78CC\"));\n  test_hash(&nettle_sha3_256, /* 219 octets */\n\t    SHEX(\"C8E976AB4638909387CE3B8D4E510C3230E5690E02C45093B1D297910ABC481E56EEA0F296F98379DFC9080AF69E73B2399D1C143BEE80AE1328162CE1BA7F6A8374679B20AACD380EB4E61382C99998704D62701AFA914F9A2705CDB065885F50D086C3EB5753700C387118BB142F3E6DA1E988DFB31AC75D7368931E45D1391A274B22F83CEB072F9BCABC0B216685BFD789F5023971024B1878A205442522F9EA7D8797A4102A3DF41703768251FD5E017C85D1200A464118AA35654E7CA39F3C375B8EF8CBE7534DBC64BC20BEFB417CF60EC92F63D9EE7397\"),\n\t    SHEX(\"373704F641FAF2B918E22E9142ABF6B4AC71B6883AC4D7A075F626E947837D3F\"));\n  test_hash(&nettle_sha3_256, /* 220 octets */\n\t    SHEX(\"7145FA124B7429A1FC2231237A949BA7201BCC1822D3272DE005B682398196C25F7E5CC2F289FBF44415F699CB7FE6757791B1443410234AE061EDF623359E2B4E32C19BF88450432DD01CAA5EB16A1DC378F391CA5E3C4E5F356728BDDD4975DB7C890DA8BBC84CC73FF244394D0D48954978765E4A00B593F70F2CA082673A261ED88DBCEF1127728D8CD89BC2C597E9102CED6010F65FA75A14EBE467FA57CE3BD4948B6867D74A9DF5C0EC6F530CBF2EE61CE6F06BC8F2864DFF5583776B31DF8C7FFCB61428A56BF7BD37188B4A5123BBF338393AF46EDA85E6\"),\n\t    SHEX(\"EE5994B3D32BDAE58E72566FC24B886461217FDD7273E1608F0B2926B7923546\"));\n  test_hash(&nettle_sha3_256, /* 221 octets */\n\t    SHEX(\"7FDFADCC9D29BAD23AE038C6C65CDA1AEF757221B8872ED3D75FF8DF7DA0627D266E224E812C39F7983E4558BFD0A1F2BEF3FEB56BA09120EF762917B9C093867948547AEE98600D10D87B20106878A8D22C64378BF634F7F75900C03986B077B0BF8B740A82447B61B99FEE5376C5EB6680EC9E3088F0BDD0C56883413D60C1357D3C811950E5890E7600103C916341B80C743C6A852B7B4FB60C3BA21F3BC15B8382437A68454779CF3CD7F9F90CCC8EF28D0B706535B1E4108EB5627BB45D719CB046839AEE311CA1ABDC8319E050D67972CB35A6B1601B25DBF487\"),\n\t    SHEX(\"6A584F9F4ACD8FC8E15DACD326291FE9311C20987225C51CF4251E52B47FA223\"));\n  test_hash(&nettle_sha3_256, /* 222 octets */\n\t    SHEX(\"988638219FD3095421F826F56E4F09E356296B628C3CE6930C9F2E758FD1A80C8273F2F61E4DAAE65C4F110D3E7CA0965AC7D24E34C0DC4BA2D6FF0BF5BBE93B3585F354D7543CB542A1AA54674D375077F2D360A8F4D42F3DB131C3B7AB7306267BA107659864A90C8C909460A73621D1F5D9D3FD95BEB19B23DB1CB6C0D0FBA91D36891529B8BD8263CAA1BAB56A4AFFAED44962DF096D8D5B1EB845EF31188B3E10F1AF811A13F156BEB7A288AAE593EBD1471B624AA1A7C6ADF01E2200B3D72D88A3AED3100C88231E41EFC376906F0B580DC895F080FDA5741DB1CB\"),\n\t    SHEX(\"4F92839CDDB0DF31D16A0DB53BBE07698A7C1912D5590D21155D45DB1B48CAB4\"));\n  test_hash(&nettle_sha3_256, /* 223 octets */\n\t    SHEX(\"5AAB62756D307A669D146ABA988D9074C5A159B3DE85151A819B117CA1FF6597F6156E80FDD28C9C3176835164D37DA7DA11D94E09ADD770B68A6E081CD22CA0C004BFE7CD283BF43A588DA91F509B27A6584C474A4A2F3EE0F1F56447379240A5AB1FB77FDCA49B305F07BA86B62756FB9EFB4FC225C86845F026EA542076B91A0BC2CDD136E122C659BE259D98E5841DF4C2F60330D4D8CDEE7BF1A0A244524EECC68FF2AEF5BF0069C9E87A11C6E519DE1A4062A10C83837388F7EF58598A3846F49D499682B683C4A062B421594FAFBC1383C943BA83BDEF515EFCF10D\"),\n\t    SHEX(\"EAFD661F343AE834C621E074AC6903A2E3E6324F365B3432DFFA732F477AC129\"));\n  test_hash(&nettle_sha3_256, /* 224 octets */\n\t    SHEX(\"47B8216AA0FBB5D67966F2E82C17C07AA2D6327E96FCD83E3DE7333689F3EE79994A1BF45082C4D725ED8D41205CB5BCDF5C341F77FACB1DA46A5B9B2CBC49EADF786BCD881F371A95FA17DF73F606519AEA0FF79D5A11427B98EE7F13A5C00637E2854134691059839121FEA9ABE2CD1BCBBBF27C74CAF3678E05BFB1C949897EA01F56FFA4DAFBE8644611685C617A3206C7A7036E4AC816799F693DAFE7F19F303CE4EBA09D21E03610201BFC665B72400A547A1E00FA9B7AD8D84F84B34AEF118515E74DEF11B9188BD1E1F97D9A12C30132EC2806339BDADACDA2FD8B78\"),\n\t    SHEX(\"3DCEC669C5D0176B1BDC002728D242C587DDA03B3ABFA6074523D3FAEF4820BE\"));\n  test_hash(&nettle_sha3_256, /* 225 octets */\n\t    SHEX(\"8CFF1F67FE53C098896D9136389BD8881816CCAB34862BB67A656E3D98896F3CE6FFD4DA73975809FCDF9666760D6E561C55238B205D8049C1CEDEEF374D1735DAA533147BFA960B2CCE4A4F254176BB4D1BD1E89654432B8DBE1A135C42115B394B024856A2A83DC85D6782BE4B444239567CCEC4B184D4548EAE3FF6A192F343292BA2E32A0F267F31CC26719EB85245D415FB897AC2DA433EE91A99424C9D7F1766A44171D1651001C38FC79294ACCC68CEB5665D36218454D3BA169AE058A831338C17743603F81EE173BFC0927464F9BD728DEE94C6AEAB7AAE6EE3A627E8\"),\n\t    SHEX(\"4BDF731BBB3D0E2AB0EB3D972123A7A0A085E8A98AC6AF8ADBD335B37275DDFF\"));\n  test_hash(&nettle_sha3_256, /* 226 octets */\n\t    SHEX(\"EACD07971CFF9B9939903F8C1D8CBB5D4DB1B548A85D04E037514A583604E787F32992BF2111B97AC5E8A938233552731321522AB5E8583561260B7D13EBEEF785B23A41FD8576A6DA764A8ED6D822D4957A545D5244756C18AA80E1AAD4D1F9C20D259DEE1711E2CC8FD013169FB7CC4CE38B362F8E0936AE9198B7E838DCEA4F7A5B9429BB3F6BBCF2DC92565E3676C1C5E6EB3DD2A0F86AA23EDD3D0891F197447692794B3DFA269611AD97F72B795602B4FDB198F3FD3EB41B415064256E345E8D8C51C555DC8A21904A9B0F1AD0EFFAB7786AAC2DA3B196507E9F33CA356427\"),\n\t    SHEX(\"47F904FEEA607225CAB2E3C52748878964BFEDCFE068727DE610F63421367BCF\"));\n  test_hash(&nettle_sha3_256, /* 227 octets */\n\t    SHEX(\"23AC4E9A42C6EF45C3336CE6DFC2FF7DE8884CD23DC912FEF0F7756C09D335C189F3AD3A23697ABDA851A81881A0C8CCAFC980AB2C702564C2BE15FE4C4B9F10DFB2248D0D0CB2E2887FD4598A1D4ACDA897944A2FFC580FF92719C95CF2AA42DC584674CB5A9BC5765B9D6DDF5789791D15F8DD925AA12BFFAFBCE60827B490BB7DF3DDA6F2A143C8BF96ABC903D83D59A791E2D62814A89B8080A28060568CF24A80AE61179FE84E0FFAD00388178CB6A617D37EFD54CC01970A4A41D1A8D3DDCE46EDBBA4AB7C90AD565398D376F431189CE8C1C33E132FEAE6A8CD17A61C630012\"),\n\t    SHEX(\"324937607D9F16AF815701749F0377B3281AF9C5BB565D6F2B9611532B6BF044\"));\n  test_hash(&nettle_sha3_256, /* 228 octets */\n\t    SHEX(\"0172DF732282C9D488669C358E3492260CBE91C95CFBC1E3FEA6C4B0EC129B45F242ACE09F152FC6234E1BEE8AAB8CD56E8B486E1DCBA9C05407C2F95DA8D8F1C0AF78EE2ED82A3A79EC0CB0709396EE62AADB84F8A4EE8A7CCCA3C1EE84E302A09EA802204AFECF04097E67D0F8E8A9D2651126C0A598A37081E42D168B0AE8A71951C524259E4E2054E535B779679BDADE566FE55700858618E626B4A0FAF895BCCE9011504A49E05FD56127EAE3D1F8917AFB548ECADABDA1020111FEC9314C413498A360B08640549A22CB23C731ACE743252A8227A0D2689D4C6001606678DFB921\"),\n\t    SHEX(\"B984C2D6B6FDC28574AAD551FC16B68F85BF6CC480A15C128AE5616561D46721\"));\n  test_hash(&nettle_sha3_256, /* 229 octets */\n\t    SHEX(\"3875B9240CF3E0A8B59C658540F26A701CF188496E2C2174788B126FD29402D6A75453BA0635284D08835F40051A2A9683DC92AFB9383719191231170379BA6F4ADC816FECBB0F9C446B785BF520796841E58878B73C58D3EBB097CE4761FDEABE15DE2F319DFBAF1742CDEB389559C788131A6793E193856661376C81CE9568DA19AA6925B47FFD77A43C7A0E758C37D69254909FF0FBD415EF8EB937BCD49F91468B49974C07DC819ABD67395DB0E05874FF83DDDAB895344ABD0E7111B2DF9E58D76D85AD98106B36295826BE04D435615595605E4B4BB824B33C4AFEB5E7BB0D19F909\"),\n\t    SHEX(\"91A5B9FC2DCC5FAEDA57D2E7A41E922DC32D572AEBDF6D54CB8C3AE4245E8565\"));\n  test_hash(&nettle_sha3_256, /* 230 octets */\n\t    SHEX(\"747CC1A59FEFBA94A9C75BA866C30DC5C1CB0C0F8E9361D98484956DD5D1A40F6184AFBE3DAC9F76028D1CAECCFBF69199C6CE2B4C092A3F4D2A56FE5A33A00757F4D7DEE5DFB0524311A97AE0668A47971B95766E2F6DD48C3F57841F91F04A00AD5EA70F2D479A2620DC5CD78EAAB3A3B011719B7E78D19DDF70D9423798AF77517EBC55392FCD01FC600D8D466B9E7A7A85BF33F9CC5419E9BD874DDFD60981150DDAF8D7FEBAA4374F0872A5628D318000311E2F5655365AD4D407C20E5C04DF17A222E7DEEC79C5AB1116D8572F91CD06E1CCC7CED53736FC867FD49ECEBE6BF8082E8A\"),\n\t    SHEX(\"97DCA1050A465B60E91EBE26E29ADB5A286A0582EEE2E89B8B901954293F6146\"));\n  test_hash(&nettle_sha3_256, /* 231 octets */\n\t    SHEX(\"57AF971FCCAEC97435DC2EC9EF0429BCEDC6B647729EA168858A6E49AC1071E706F4A5A645CA14E8C7746D65511620682C906C8B86EC901F3DDED4167B3F00B06CBFAC6AEE3728051B3E5FF10B4F9ED8BD0B8DA94303C833755B3CA3AEDDF0B54BC8D6632138B5D25BAB03D17B3458A9D782108006F5BB7DE75B5C0BA854B423D8BB801E701E99DC4FEAAD59BC1C7112453B04D33EA3635639FB802C73C2B71D58A56BBD671B18FE34ED2E3DCA38827D63FDB1D4FB3285405004B2B3E26081A8FF08CD6D2B08F8E7B7E90A2AB1ED7A41B1D0128522C2F8BFF56A7FE67969422CE839A9D4608F03\"),\n\t    SHEX(\"6D033D85DAED3366D5F7D5E4F03B3D05B65778EEEA074B0C683CFFCD6F51D5BD\"));\n  test_hash(&nettle_sha3_256, /* 232 octets */\n\t    SHEX(\"04E16DEDC1227902BAAF332D3D08923601BDD64F573FAA1BB7201918CFE16B1E10151DAE875DA0C0D63C59C3DD050C4C6A874011B018421AFC4623AB0381831B2DA2A8BA42C96E4F70864AC44E106F94311051E74C77C1291BF5DB9539E69567BF6A11CF6932BBBAD33F8946BF5814C066D851633D1A513510039B349939BFD42B858C21827C8FF05F1D09B1B0765DC78A135B5CA4DFBA0801BCADDFA175623C8B647EACFB4444B85A44F73890607D06D507A4F8393658788669F6EF4DEB58D08C50CA0756D5E2F49D1A7AD73E0F0B3D3B5F090ACF622B1878C59133E4A848E05153592EA81C6FBF\"),\n\t    SHEX(\"01EBBB73410EEBAC665C3B40063D001F43DBE9D1722EB323FE08763D7FF0616C\"));\n  test_hash(&nettle_sha3_256, /* 233 octets */\n\t    SHEX(\"7C815C384EEE0F288ECE27CCED52A01603127B079C007378BC5D1E6C5E9E6D1C735723ACBBD5801AC49854B2B569D4472D33F40BBB8882956245C366DC3582D71696A97A4E19557E41E54DEE482A14229005F93AFD2C4A7D8614D10A97A9DFA07F7CD946FA45263063DDD29DB8F9E34DB60DAA32684F0072EA2A9426ECEBFA5239FB67F29C18CBAA2AF6ED4BF4283936823AC1790164FEC5457A9CBA7C767CA59392D94CAB7448F50EB34E9A93A80027471CE59736F099C886DEA1AB4CBA4D89F5FC7AE2F21CCD27F611ECA4626B2D08DC22382E92C1EFB2F6AFDC8FDC3D2172604F5035C46B8197D3\"),\n\t    SHEX(\"8D3A49CB572AB99C9BF0231366BB017C9ADF25479D35443A971E45787E738CE5\"));\n  test_hash(&nettle_sha3_256, /* 234 octets */\n\t    SHEX(\"E29D505158DBDD937D9E3D2145658EE6F5992A2FC790F4F608D9CDB44A091D5B94B88E81FAC4FDF5C49442F13B911C55886469629551189EAFF62488F1A479B7DB11A1560E198DDCCCCF50159093425FF7F1CB8D1D1246D0978764087D6BAC257026B090EFAE8CEC5F22B6F21C59ACE1AC7386F5B8837CA6A12B6FBF5534DD0560EF05CA78104D3B943DDB220FEAEC89AA5E692A00F822A2AB9A2FE60350D75E7BE16FF2526DC643872502D01F42F188ABED0A6E9A6F5FD0D1CE7D5755C9FFA66B0AF0B20BD806F08E06156690D81AC811778CA3DAC2C249B96002017FCE93E507E3B953ACF99964B847\"),\n\t    SHEX(\"FBB5A0AB1A3B4C4FA56ADB1C9531EB9979C554903053013C20FEFD3F57B5CCDB\"));\n  test_hash(&nettle_sha3_256, /* 235 octets */\n\t    SHEX(\"D85588696F576E65ECA0155F395F0CFACD83F36A99111ED5768DF2D116D2121E32357BA4F54EDE927F189F297D3A97FAD4E9A0F5B41D8D89DD7FE20156799C2B7B6BF9C957BA0D6763F5C3BC5129747BBB53652B49290CFF1C87E2CDF2C4B95D8AAEE09BC8FBFA6883E62D237885810491BFC101F1D8C636E3D0EDE838AD05C207A3DF4FAD76452979EB99F29AFAECEDD1C63B8D36CF378454A1BB67A741C77AC6B6B3F95F4F02B64DABC15438613EA49750DF42EE90101F115AA9ABB9FF64324DDE9DABBB01054E1BD6B4BCDC7930A44C2300D87CA78C06924D0323AD7887E46C90E8C4D100ACD9EED21E\"),\n\t    SHEX(\"6B3DCC7AC6A5CB85B67FC71B4055D3798134DEEF26FD3EB03A042E0DAA35CC85\"));\n  test_hash(&nettle_sha3_256, /* 236 octets */\n\t    SHEX(\"3A12F8508B40C32C74492B66323375DCFE49184C78F73179F3314B79E63376B8AC683F5A51F1534BD729B02B04D002F55CBD8E8FC9B5EC1EA6BBE6A0D0E7431518E6BA45D124035F9D3DCE0A8BB7BF1430A9F657E0B4EA9F20EB20C786A58181A1E20A96F1628F8728A13BDF7A4B4B32FC8AA7054CC4881AE7FA19AFA65C6C3EE1B3ADE3192AF42054A8A911B8EC1826865D46D93F1E7C5E2B7813C92A506E53886F3D4701BB93D2A681AD109C845904BB861AF8AF0646B6E399B38B614051D34F6842563A0F37EC00CB3D865FC5D746C4987DE2A65071100883A2A9C7A2BFE1E2DD603D9EA24DC7C5FD06BE\"),\n\t    SHEX(\"5D1DBA8F1584AC3F36B3AC925EC13AC284013B9664965AB6265B942466B5D8EC\"));\n  test_hash(&nettle_sha3_256, /* 237 octets */\n\t    SHEX(\"1861EDCE46FA5AD17E1FF1DEAE084DEC580F97D0A67885DFE834B9DFAC1AE076742CE9E267512CA51F6DF5A455AF0C5FD6ABF94ACEA103A3370C354485A7846FB84F3AC7C2904B5B2FBF227002CE512133BB7E1C4E50057BFD1E44DB33C7CDB969A99E284B184F50A14B068A1FC5009D9B298DBE92239572A7627AAC02ABE8F3E3B473417F36D4D2505D16B7577F4526C9D94A270A2DFE450D06DA8F6FA956879A0A55CFE99E742EA555EA477BA3E9B44CCD508C375423611AF92E55345DC215779B2D5119EBA49C71D49B9FE3F1569FA24E5CA3E332D042422A8B8158D3EC66A80012976F31FFDF305F0C9C5E\"),\n\t    SHEX(\"89C6C86DB0A889AA67D8CB085F9F4312645972D977C5B952D9F6243D7D3BE4D5\"));\n  test_hash(&nettle_sha3_256, /* 238 octets */\n\t    SHEX(\"08D0FFDE3A6E4EF65608EA672E4830C12943D7187CCFF08F4941CFC13E545F3B9C7AD5EEBBE2B01642B486CAF855C2C73F58C1E4E3391DA8E2D63D96E15FD84953AE5C231911B00AD6050CD7AAFDAAC9B0F663AE6AAB45519D0F5391A541707D479034E73A6AD805AE3598096AF078F1393301493D663DD71F83869CA27BA508B7E91E81E128C1716DC3ACFE3084B2201E04CF8006617EECF1B640474A5D45CFDE9F4D3EF92D6D055B909892194D8A8218DB6D8203A84261D200D71473D7488F3427416B6896C137D455F231071CACBC86E0415AB88AEC841D96B7B8AF41E05BB461A40645BF176601F1E760DE5F\"),\n\t    SHEX(\"AC02432A5541C26238C6F99FADB2B23B5FFCAD8F04BD4C3B9A6620CAB1266E6B\"));\n  test_hash(&nettle_sha3_256, /* 239 octets */\n\t    SHEX(\"D782ABB72A5BE3392757BE02D3E45BE6E2099D6F000D042C8A543F50ED6EBC055A7F133B0DD8E9BC348536EDCAAE2E12EC18E8837DF7A1B3C87EC46D50C241DEE820FD586197552DC20BEEA50F445A07A38F1768A39E2B2FF05DDDEDF751F1DEF612D2E4D810DAA3A0CC904516F9A43AF660315385178A529E51F8AAE141808C8BC5D7B60CAC26BB984AC1890D0436EF780426C547E94A7B08F01ACBFC4A3825EAE04F520A9016F2FB8BF5165ED12736FC71E36A49A73614739EAA3EC834069B1B40F1350C2B3AB885C02C640B9F7686ED5F99527E41CFCD796FE4C256C9173186C226169FF257954EBDA81C0E5F99\"),\n\t    SHEX(\"F55AA01DEAB12148E35759DB818F1059351165E9E6F93D342F0ABFCA102E0801\"));\n  test_hash(&nettle_sha3_256, /* 240 octets */\n\t    SHEX(\"5FCE8109A358570E40983E1184E541833BB9091E280F258CFB144387B05D190E431CB19BAA67273BA0C58ABE91308E1844DCD0B3678BAA42F335F2FA05267A0240B3C718A5942B3B3E3BFA98A55C25A1466E8D7A603722CB2BBF03AFA54CD769A99F310735EE5A05DAE2C22D397BD95635F58C48A67F90E1B73AAFCD3F82117F0166657838691005B18DA6F341D6E90FC1CDB352B30FAE45D348294E501B63252DE14740F2B85AE5299DDEC3172DE8B6D0BA219A20A23BB5E10FF434D39DB3F583305E9F5C039D98569E377B75A70AB837D1DF269B8A4B566F40BB91B577455FD3C356C914FA06B9A7CE24C7317A172D\"),\n\t    SHEX(\"7C0BDA7CB42DADBD037F50A5F27E3AB5DA258D4670F1BEA90154C87C98136BA1\"));\n  test_hash(&nettle_sha3_256, /* 241 octets */\n\t    SHEX(\"6172F1971A6E1E4E6170AFBAD95D5FEC99BF69B24B674BC17DD78011615E502DE6F56B86B1A71D3F4348087218AC7B7D09302993BE272E4A591968AEF18A1262D665610D1070EE91CC8DA36E1F841A69A7A682C580E836941D21D909A3AFC1F0B963E1CA5AB193E124A1A53DF1C587470E5881FB54DAE1B0D840F0C8F9D1B04C645BA1041C7D8DBF22030A623AA15638B3D99A2C400FF76F3252079AF88D2B37F35EE66C1AD7801A28D3D388AC450B97D5F0F79E4541755356B3B1A5696B023F39AB7AB5F28DF4202936BC97393B93BC915CB159EA1BD7A0A414CB4B7A1AC3AF68F50D79F0C9C7314E750F7D02FAA58BFA\"),\n\t    SHEX(\"F60C53BA2132293B881F0513E7AB47FE9746ED4A6AC9CADE61E6D802D5872372\"));\n  test_hash(&nettle_sha3_256, /* 242 octets */\n\t    SHEX(\"5668ECD99DFBE215C4118398AC9C9EAF1A1433FAB4CCDD3968064752B625EA944731F75D48A27D047D67547F14DD0FFAA55FA5E29F7AF0D161D85EAFC4F2029B717C918EAB9D304543290BDBA7158B68020C0BA4E079BC95B5BC0FC044A992B94B4CCD3BD66D0EABB5DBBAB904D62E00752C4E3B0091D773BCF4C14B4377DA3EFFF824B1CB2FA01B32D1E46C909E626ED2DAE920F4C7DBEB635BC754FACBD8D49BEBA3F23C1C41CCBFCD0EE0C114E69737F5597C0BF1D859F0C767E18002AE8E39C26261FFDE2920D3D0BAF0E906138696CFE5B7E32B600F45DF3AAA39932F3A7DF95B60FA8712A2271FCAF3911CE7B511B1\"),\n\t    SHEX(\"1C66B9A7C50ED77D179A0C437D5890C9835A13F90A73A01332AB0731A41A115E\"));\n  test_hash(&nettle_sha3_256, /* 243 octets */\n\t    SHEX(\"03D625488354DF30E3F875A68EDFCF340E8366A8E1AB67F9D5C5486A96829DFAC0578289082B2A62117E1CF418B43B90E0ADC881FC6AE8105C888E9ECD21AEA1C9AE1A4038DFD17378FED71D02AE492087D7CDCD98F746855227967CB1AB4714261EE3BEAD3F4DB118329D3EBEF4BC48A875C19BA763966DA0EBEA800E01B2F50B00E9DD4CACA6DCB314D00184EF71EA2391D760C950710DB4A70F9212FFC54861F9DC752CE18867B8AD0C48DF8466EF7231E7AC567F0EB55099E622EBB86CB237520190A61C66AD34F1F4E289CB3282AE3EAAC6152ED24D2C92BAE5A7658252A53C49B7B02DFE54FDB2E90074B6CF310AC661\"),\n\t    SHEX(\"48A00BA224AC5558F41A79F52137DB9182A93F1045D43789E5913D7BE40408C2\"));\n  test_hash(&nettle_sha3_256, /* 244 octets */\n\t    SHEX(\"2EDC282FFB90B97118DD03AAA03B145F363905E3CBD2D50ECD692B37BF000185C651D3E9726C690D3773EC1E48510E42B17742B0B0377E7DE6B8F55E00A8A4DB4740CEE6DB0830529DD19617501DC1E9359AA3BCF147E0A76B3AB70C4984C13E339E6806BB35E683AF8527093670859F3D8A0FC7D493BCBA6BB12B5F65E71E705CA5D6C948D66ED3D730B26DB395B3447737C26FAD089AA0AD0E306CB28BF0ACF106F89AF3745F0EC72D534968CCA543CD2CA50C94B1456743254E358C1317C07A07BF2B0ECA438A709367FAFC89A57239028FC5FECFD53B8EF958EF10EE0608B7F5CB9923AD97058EC067700CC746C127A61EE3\"),\n\t    SHEX(\"240A85EAF7F3016C192AD5E17E5F93B643FE3EDBA719F423693A34DA3784827A\"));\n  test_hash(&nettle_sha3_256, /* 245 octets */\n\t    SHEX(\"90B28A6AA1FE533915BCB8E81ED6CACDC10962B7FF82474F845EEB86977600CF70B07BA8E3796141EE340E3FCE842A38A50AFBE90301A3BDCC591F2E7D9DE53E495525560B908C892439990A2CA2679C5539FFDF636777AD9C1CDEF809CDA9E8DCDB451ABB9E9C17EFA4379ABD24B182BD981CAFC792640A183B61694301D04C5B3EAAD694A6BD4CC06EF5DA8FA23B4FA2A64559C5A68397930079D250C51BCF00E2B16A6C49171433B0AADFD80231276560B80458DD77089B7A1BBCC9E7E4B9F881EACD6C92C4318348A13F4914EB27115A1CFC5D16D7FD94954C3532EFACA2CAB025103B2D02C6FD71DA3A77F417D7932685888A\"),\n\t    SHEX(\"2AA9D0A1D9B9B691B4B8641E68D454D2D9C34CE43A5B55DD57590716B8A46CF7\"));\n  test_hash(&nettle_sha3_256, /* 246 octets */\n\t    SHEX(\"2969447D175490F2AA9BB055014DBEF2E6854C95F8D60950BFE8C0BE8DE254C26B2D31B9E4DE9C68C9ADF49E4EE9B1C2850967F29F5D08738483B417BB96B2A56F0C8ACA632B552059C59AAC3F61F7B45C966B75F1D9931FF4E596406378CEE91AAA726A3A84C33F37E9CDBE626B5745A0B06064A8A8D56E53AAF102D23DD9DF0A3FDF7A638509A6761A33FA42FA8DDBD8E16159C93008B53765019C3F0E9F10B144CE2AC57F5D7297F9C9949E4FF68B70D339F87501CE8550B772F32C6DA8AD2CE2100A895D8B08FA1EEAD7C376B407709703C510B50F87E73E43F8E7348F87C3832A547EF2BBE5799ABEDCF5E1F372EA809233F006\"),\n\t    SHEX(\"58C469E1A76835CC1A897B885B1B2A33B0AABCE4CFBB65523D2E0D08D6D1A413\"));\n  test_hash(&nettle_sha3_256, /* 247 octets */\n\t    SHEX(\"721645633A44A2C78B19024EAECF58575AB23C27190833C26875DC0F0D50B46AEA9C343D82EA7D5B3E50EC700545C615DAEAEA64726A0F05607576DCD396D812B03FB6551C641087856D050B10E6A4D5577B82A98AFB89CEE8594C9DC19E79FEFF0382FCFD127F1B803A4B9946F4AC9A4378E1E6E041B1389A53E3450CD32D9D2941B0CBABDB50DA8EA2513145164C3AB6BCBD251C448D2D4B087AC57A59C2285D564F16DA4ED5E607ED979592146FFB0EF3F3DB308FB342DF5EB5924A48256FC763141A278814C82D6D6348577545870AE3A83C7230AC02A1540FE1798F7EF09E335A865A2AE0949B21E4F748FB8A51F44750E213A8FB\"),\n\t    SHEX(\"6C8DF81B1E1ED70A5413368018DB9628B0E0B4563423C051A54D000AADDE0C06\"));\n  test_hash(&nettle_sha3_256, /* 248 octets */\n\t    SHEX(\"6B860D39725A14B498BB714574B4D37CA787404768F64C648B1751B353AC92BAC2C3A28EA909FDF0423336401A02E63EC24325300D823B6864BB701F9D7C7A1F8EC9D0AE3584AA6DD62EA1997CD831B4BABD9A4DA50932D4EFDA745C61E4130890E156AEE6113716DAF95764222A91187DB2EFFEA49D5D0596102D619BD26A616BBFDA8335505FBB0D90B4C180D1A2335B91538E1668F9F9642790B4E55F9CAB0FE2BDD2935D001EE6419ABAB5457880D0DBFF20ED8758F4C20FE759EFB33141CF0E892587FE8187E5FBC57786B7E8B089612C936DFC03D27EFBBE7C8673F1606BD51D5FF386F4A7AB68EDF59F385EB1291F117BFE717399\"),\n\t    SHEX(\"108FFF41D5BCF654071B4414E666FDEBBE878C309D6DDC90AFAF5C61DF8559F0\"));\n  test_hash(&nettle_sha3_256, /* 249 octets */\n\t    SHEX(\"6A01830AF3889A25183244DECB508BD01253D5B508AB490D3124AFBF42626B2E70894E9B562B288D0A2450CFACF14A0DDAE5C04716E5A0082C33981F6037D23D5E045EE1EF2283FB8B6378A914C5D9441627A722C282FF452E25A7EA608D69CEE4393A0725D17963D0342684F255496D8A18C2961145315130549311FC07F0312FB78E6077334F87EAA873BEE8AA95698996EB21375EB2B4EF53C14401207DEB4568398E5DD9A7CF97E8C9663E23334B46912F8344C19EFCF8C2BA6F04325F1A27E062B62A58D0766FC6DB4D2C6A1928604B0175D872D16B7908EBC041761187CC785526C2A3873FEAC3A642BB39F5351550AF9770C328AF7B\"),\n\t    SHEX(\"751EAAAFA4AEC8ACD26606D6439C55B5C66EC7DB807579EDC68994B300F7A077\"));\n  test_hash(&nettle_sha3_256, /* 250 octets */\n\t    SHEX(\"B3C5E74B69933C2533106C563B4CA20238F2B6E675E8681E34A389894785BDADE59652D4A73D80A5C85BD454FD1E9FFDAD1C3815F5038E9EF432AAC5C3C4FE840CC370CF86580A6011778BBEDAF511A51B56D1A2EB68394AA299E26DA9ADA6A2F39B9FAFF7FBA457689B9C1A577B2A1E505FDF75C7A0A64B1DF81B3A356001BF0DF4E02A1FC59F651C9D585EC6224BB279C6BEBA2966E8882D68376081B987468E7AED1EF90EBD090AE825795CDCA1B4F09A979C8DFC21A48D8A53CDBB26C4DB547FC06EFE2F9850EDD2685A4661CB4911F165D4B63EF25B87D0A96D3DFF6AB0758999AAD214D07BD4F133A6734FDE445FE474711B69A98F7E2B\"),\n\t    SHEX(\"90C2D5F8E26B0BDDEA719064BB02A6242F2CC5A42936B14FE17F861B47B7E186\"));\n  test_hash(&nettle_sha3_256, /* 251 octets */\n\t    SHEX(\"83AF34279CCB5430FEBEC07A81950D30F4B66F484826AFEE7456F0071A51E1BBC55570B5CC7EC6F9309C17BF5BEFDD7C6BA6E968CF218A2B34BD5CF927AB846E38A40BBD81759E9E33381016A755F699DF35D660007B5EADF292FEEFB735207EBF70B5BD17834F7BFA0E16CB219AD4AF524AB1EA37334AA66435E5D397FC0A065C411EBBCE32C240B90476D307CE802EC82C1C49BC1BEC48C0675EC2A6C6F3ED3E5B741D13437095707C565E10D8A20B8C20468FF9514FCF31B4249CD82DCEE58C0A2AF538B291A87E3390D737191A07484A5D3F3FB8C8F15CE056E5E5F8FEBE5E1FB59D6740980AA06CA8A0C20F5712B4CDE5D032E92AB89F0AE1\"),\n\t    SHEX(\"3298A95CFE59B9D6CAB99C36DC1324194C09F97F08944A02D9574BBCA3186B41\"));\n  test_hash(&nettle_sha3_256, /* 252 octets */\n\t    SHEX(\"A7ED84749CCC56BB1DFBA57119D279D412B8A986886D810F067AF349E8749E9EA746A60B03742636C464FC1EE233ACC52C1983914692B64309EDFDF29F1AB912EC3E8DA074D3F1D231511F5756F0B6EEAD3E89A6A88FE330A10FACE267BFFBFC3E3090C7FD9A850561F363AD75EA881E7244F80FF55802D5EF7A1A4E7B89FCFA80F16DF54D1B056EE637E6964B9E0FFD15B6196BDD7DB270C56B47251485348E49813B4EB9ED122A01B3EA45AD5E1A929DF61D5C0F3E77E1FDC356B63883A60E9CBB9FC3E00C2F32DBD469659883F690C6772E335F617BC33F161D6F6984252EE12E62B6000AC5231E0C9BC65BE223D8DFD94C5004A101AF9FD6C0FB\"),\n\t    SHEX(\"1C4172928CB10E16AB3CDB33F815103B000A6C7D62376CAD29AF03F4B2B0E103\"));\n  test_hash(&nettle_sha3_256, /* 253 octets */\n\t    SHEX(\"A6FE30DCFCDA1A329E82AB50E32B5F50EB25C873C5D2305860A835AECEE6264AA36A47429922C4B8B3AFD00DA16035830EDB897831C4E7B00F2C23FC0B15FDC30D85FB70C30C431C638E1A25B51CAF1D7E8B050B7F89BFB30F59F0F20FECFF3D639ABC4255B3868FC45DD81E47EB12AB40F2AAC735DF5D1DC1AD997CEFC4D836B854CEE9AC02900036F3867FE0D84AFFF37BDE3308C2206C62C4743375094108877C73B87B2546FE05EA137BEDFC06A2796274099A0D554DA8F7D7223A48CBF31B7DECAA1EBC8B145763E3673168C1B1B715C1CD99ECD3DDB238B06049885ECAD9347C2436DFF32C771F34A38587A44A82C5D3D137A03CAA27E66C8FF6\"),\n\t    SHEX(\"F5CFB4DF3F7C5A778F38A3B43B26479A0E8A49030C59AC19FB0CFA806081CA4A\"));\n  test_hash(&nettle_sha3_256, /* 254 octets */\n\t    SHEX(\"83167FF53704C3AA19E9FB3303539759C46DD4091A52DDAE9AD86408B69335989E61414BC20AB4D01220E35241EFF5C9522B079FBA597674C8D716FE441E566110B6211531CECCF8FD06BC8E511D00785E57788ED9A1C5C73524F01830D2E1148C92D0EDC97113E3B7B5CD3049627ABDB8B39DD4D6890E0EE91993F92B03354A88F52251C546E64434D9C3D74544F23FB93E5A2D2F1FB15545B4E1367C97335B0291944C8B730AD3D4789273FA44FB98D78A36C3C3764ABEEAC7C569C1E43A352E5B770C3504F87090DEE075A1C4C85C0C39CF421BDCC615F9EFF6CB4FE6468004AECE5F30E1ECC6DB22AD9939BB2B0CCC96521DFBF4AE008B5B46BC006E\"),\n\t    SHEX(\"06AB8FDBE4DCE935E42003C17FF60BA236F43A843995B7FEF3A29DFE0C82F1D4\"));\n  test_hash(&nettle_sha3_256, /* 255 octets */\n\t    SHEX(\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\"),\n\t    SHEX(\"C11F3522A8FB7B3532D80B6D40023A92B489ADDAD93BF5D64B23F35E9663521C\"));\n}",
      "lines": 773,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha3-384-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Extracted from ShortMsgKAT_384.txt using sha3.awk. */\n  test_hash(&nettle_sha3_384, /* 0 octets */\n\t    SHEX(\"\"),\n\t    SHEX(\"0C63A75B845E4F7D01107D852E4C2485C51A50AAAA94FC61995E71BBEE983A2AC3713831264ADB47FB6BD1E058D5F004\"));\n  test_hash(&nettle_sha3_384, /* 1 octets */\n\t    SHEX(\"CC\"),\n\t    SHEX(\"5EE7F374973CD4BB3DC41E3081346798497FF6E36CB9352281DFE07D07FC530CA9AD8EF7AAD56EF5D41BE83D5E543807\"));\n  test_hash(&nettle_sha3_384, /* 2 octets */\n\t    SHEX(\"41FB\"),\n\t    SHEX(\"1DD81609DCC290EFFD7AC0A95D4A20821580E56BD50DBD843920650BE7A80A1719577DA337CFDF86E51C764CAA2E10BD\"));\n  test_hash(&nettle_sha3_384, /* 3 octets */\n\t    SHEX(\"1F877C\"),\n\t    SHEX(\"14F6F486FB98ED46A4A198040DA8079E79E448DAACEBE905FB4CF0DF86EF2A7151F62FE095BF8516EB0677FE607734E2\"));\n  test_hash(&nettle_sha3_384, /* 4 octets */\n\t    SHEX(\"C1ECFDFC\"),\n\t    SHEX(\"D92BBD604BDD24B9889508F8558B13E96595AC90BC8A441DAF9B51D6ABC14FFD0835FB9366E3912504264CE87E421CB8\"));\n  test_hash(&nettle_sha3_384, /* 5 octets */\n\t    SHEX(\"21F134AC57\"),\n\t    SHEX(\"E248D6FF342D35A30EC230BA51CDB161025D6F1C251ACA6AE3531F0682C164A1FC0725B1BEFF808A200C131557A22809\"));\n  test_hash(&nettle_sha3_384, /* 6 octets */\n\t    SHEX(\"C6F50BB74E29\"),\n\t    SHEX(\"D6DD2ED08C1F644857A15DAFAF80538BEE597278C9ABE047BFBABFB8B1FCB7543E80AE9F7143D00F4DAAF39B138AB3FF\"));\n  test_hash(&nettle_sha3_384, /* 7 octets */\n\t    SHEX(\"119713CC83EEEF\"),\n\t    SHEX(\"49CA1EB8D71D1FDC7A72DAA320C8F9CA543671C2CB8FE9B2638A8416DF50A790A50D0BB6B88741D7816D6061F46AEA89\"));\n  test_hash(&nettle_sha3_384, /* 8 octets */\n\t    SHEX(\"4A4F202484512526\"),\n\t    SHEX(\"89DBF4C39B8FB46FDF0A6926CEC0355A4BDBF9C6A446E140B7C8BD08FF6F489F205DAF8EFFE160F437F67491EF897C23\"));\n  test_hash(&nettle_sha3_384, /* 9 octets */\n\t    SHEX(\"1F66AB4185ED9B6375\"),\n\t    SHEX(\"D6154641D7D9DF62F0CEDC2BD64EE82412B3A80F6EACE7C45F9703373379007EABF592D2D2116E093DC33DCBBA4649E9\"));\n  test_hash(&nettle_sha3_384, /* 10 octets */\n\t    SHEX(\"EED7422227613B6F53C9\"),\n\t    SHEX(\"2EE5DF2591CFC4CB1E1D0BD8B28727F0FA5359A75F7819A92A3CB80DDB5708E4705177B981396B4818D11E3CA615EC93\"));\n  test_hash(&nettle_sha3_384, /* 11 octets */\n\t    SHEX(\"EAEED5CDFFD89DECE455F1\"),\n\t    SHEX(\"786C3F73FB092BE184FC2B19F5920F3D94F25D4523165AE82F9B39B2C724FD62DC9A3263091A239D5EF1AD562DD4FD26\"));\n  test_hash(&nettle_sha3_384, /* 12 octets */\n\t    SHEX(\"5BE43C90F22902E4FE8ED2D3\"),\n\t    SHEX(\"79188139EC2CAD8D197D308B806CF383782C29A8C27EE29C5E31425B2DD18B2F5F491FBFB38D7078F58510125C064A0A\"));\n  test_hash(&nettle_sha3_384, /* 13 octets */\n\t    SHEX(\"A746273228122F381C3B46E4F1\"),\n\t    SHEX(\"0C82B8C75C5D540E7D624928281FBA8B8D0B1583D74F3F0EA4F200F1CE5475149C282E05DB695DC67BAF42DEFFDC3F55\"));\n  test_hash(&nettle_sha3_384, /* 14 octets */\n\t    SHEX(\"3C5871CD619C69A63B540EB5A625\"),\n\t    SHEX(\"830D2325C001623EDFEA97EA1D0E65982D4ED7ABB8E64EA61C85E9BC1882D11FC4153C30BE63FC66F5FBCE74BB394596\"));\n  test_hash(&nettle_sha3_384, /* 15 octets */\n\t    SHEX(\"FA22874BCC068879E8EF11A69F0722\"),\n\t    SHEX(\"1DBE1BC60A9C6FBE10A727E2A6D397930D547AD2C390286948C3167EE77FF6E275EC8431C5AD4B4E4E5AE67A4BC88D05\"));\n  test_hash(&nettle_sha3_384, /* 16 octets */\n\t    SHEX(\"52A608AB21CCDD8A4457A57EDE782176\"),\n\t    SHEX(\"FEEE2EF332515284E0BA247C62F264199044D03877C58E54B51A62E39E91C27AAAE384837EB9D479B4C0308CFC6B779B\"));\n  test_hash(&nettle_sha3_384, /* 17 octets */\n\t    SHEX(\"82E192E4043DDCD12ECF52969D0F807EED\"),\n\t    SHEX(\"1888E953727CB837DE40C69869560C20729C50638E4561B385937BFC4C297E789EA6C03EFCF2DF3290B1FD36BE268C32\"));\n  test_hash(&nettle_sha3_384, /* 18 octets */\n\t    SHEX(\"75683DCB556140C522543BB6E9098B21A21E\"),\n\t    SHEX(\"30DE7B544265422CE689E667F48498F455E8BF1055653F21294EAD7D2E898B05FA75EECA46DC2575C475C480AA49CA62\"));\n  test_hash(&nettle_sha3_384, /* 19 octets */\n\t    SHEX(\"06E4EFE45035E61FAAF4287B4D8D1F12CA97E5\"),\n\t    SHEX(\"041B7C89BD4B582A7D20E579C6FDB18BA0C1251DABACC687AF448EB49151BBC04ADCB81D797D4BC51F03BFFF230FFCC6\"));\n  test_hash(&nettle_sha3_384, /* 20 octets */\n\t    SHEX(\"E26193989D06568FE688E75540AEA06747D9F851\"),\n\t    SHEX(\"EAF751EE6E75AA2C56453F316C019BDA7D7AE1FDA03B79AC413BB1F2840D58AAAAC77F2DC106D22F1A71157F9F841C4B\"));\n  test_hash(&nettle_sha3_384, /* 21 octets */\n\t    SHEX(\"D8DC8FDEFBDCE9D44E4CBAFE78447BAE3B5436102A\"),\n\t    SHEX(\"16C4A7F7E8BA7EA13C59576BE602F885E21BE7C34B3AC05CAC4262BAAD8AA3F95BD9260F13F08550CE331EC773BA758C\"));\n  test_hash(&nettle_sha3_384, /* 22 octets */\n\t    SHEX(\"57085FD7E14216AB102D8317B0CB338A786D5FC32D8F\"),\n\t    SHEX(\"5119A4FC11DAF2EF5DEB7AEB35549162D9AFC827392A8868E7F8594A5C194D9C8F6A430CB386B8D825CC6DAB4EDB742A\"));\n  test_hash(&nettle_sha3_384, /* 23 octets */\n\t    SHEX(\"A05404DF5DBB57697E2C16FA29DEFAC8AB3560D6126FA0\"),\n\t    SHEX(\"A91F0170457E78B3BB15B0BDC0FF4EFE8D7313D2725D8E8DB875BCAFBC11314126559F45E86E78136EB214FF02764CAB\"));\n  test_hash(&nettle_sha3_384, /* 24 octets */\n\t    SHEX(\"AECBB02759F7433D6FCB06963C74061CD83B5B3FFA6F13C6\"),\n\t    SHEX(\"98FE81746CCF7CFE5571D6D8B09943ECAE44F606444F9DABF1A57FE4E871F6962266D18652FD4EEBDBE492CFC5B2B21F\"));\n  test_hash(&nettle_sha3_384, /* 25 octets */\n\t    SHEX(\"AAFDC9243D3D4A096558A360CC27C8D862F0BE73DB5E88AA55\"),\n\t    SHEX(\"3DD9054C105C40798DF45CFB5880F97A9536FA7BD13F1D816B8EE887FCBAFC102A7D4BDE9FE6E265538EEC2525B50D89\"));\n  test_hash(&nettle_sha3_384, /* 26 octets */\n\t    SHEX(\"7BC84867F6F9E9FDC3E1046CAE3A52C77ED485860EE260E30B15\"),\n\t    SHEX(\"DECD778B89B4295072DBF98689E2EB6066E406356EA4B7CAD550019F4A2ABB25163E9571D0ADB9ADC6A802B7E03C152C\"));\n  test_hash(&nettle_sha3_384, /* 27 octets */\n\t    SHEX(\"FAC523575A99EC48279A7A459E98FF901918A475034327EFB55843\"),\n\t    SHEX(\"37F14B317D46BDB3E5DD6F68986A08A098C46B9D85D1F254A17878C008F97926C8A13C3838721CFE3A58076F3992F26C\"));\n  test_hash(&nettle_sha3_384, /* 28 octets */\n\t    SHEX(\"0F8B2D8FCFD9D68CFFC17CCFB117709B53D26462A3F346FB7C79B85E\"),\n\t    SHEX(\"641A7AF13B889D1A0F1AA3E4E4FF8CC5903C47E1A52BDEA257D80E37E596564AB33EEAD06717CDB6B706CB6986293D4F\"));\n  test_hash(&nettle_sha3_384, /* 29 octets */\n\t    SHEX(\"A963C3E895FF5A0BE4824400518D81412F875FA50521E26E85EAC90C04\"),\n\t    SHEX(\"122B8B86103FE3C18FF28178A256ACB0CAB8518338D2CBA697E3F560ECFEE09B024B97D8D1F69632AD1F2C5F5628D3EF\"));\n  test_hash(&nettle_sha3_384, /* 30 octets */\n\t    SHEX(\"03A18688B10CC0EDF83ADF0A84808A9718383C4070C6C4F295098699AC2C\"),\n\t    SHEX(\"F35A292E197007E28CE652A067173F3659C51B70438AA9E433081D3DF71B4A11E3F3BE5AF32E2C08D23A0B44E30B0BDF\"));\n  test_hash(&nettle_sha3_384, /* 31 octets */\n\t    SHEX(\"84FB51B517DF6C5ACCB5D022F8F28DA09B10232D42320FFC32DBECC3835B29\"),\n\t    SHEX(\"2EA596B446D5CCD8F0927A2E3790911E00F1F52CFBFC41F12290CBACD1C903C74DEEF840FD1398E12EE863ACD92BAEBF\"));\n  test_hash(&nettle_sha3_384, /* 32 octets */\n\t    SHEX(\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\"),\n\t    SHEX(\"BAAE7AAED4FBF42F9316C7E8F722EEB06A598B509F184B22FBD5A81C93D95FFF711F5DE90847B3248B6DF76CABCE07EE\"));\n  test_hash(&nettle_sha3_384, /* 33 octets */\n\t    SHEX(\"DE8F1B3FAA4B7040ED4563C3B8E598253178E87E4D0DF75E4FF2F2DEDD5A0BE046\"),\n\t    SHEX(\"32CFC8A18A7116D4B9029051941808C3B332EFDB132C515F9110E19B8354355D94616C9965BC2D1F2489F8452AF7FB2F\"));\n  test_hash(&nettle_sha3_384, /* 34 octets */\n\t    SHEX(\"62F154EC394D0BC757D045C798C8B87A00E0655D0481A7D2D9FB58D93AEDC676B5A0\"),\n\t    SHEX(\"73443EA38A8801395C044E3CBECD45DD62D6E304C5440FA9FE9651A438C010A76712759BE20681F1416661E746E5EB77\"));\n  test_hash(&nettle_sha3_384, /* 35 octets */\n\t    SHEX(\"B2DCFE9FF19E2B23CE7DA2A4207D3E5EC7C6112A8A22AEC9675A886378E14E5BFBAD4E\"),\n\t    SHEX(\"6E82F460660F3D2CC33AA59A37F325EED0133FE29A9CB428A3C22572B6BF6C5DA2D0D4645C49135653A049795D4E2AD0\"));\n  test_hash(&nettle_sha3_384, /* 36 octets */\n\t    SHEX(\"47F5697AC8C31409C0868827347A613A3562041C633CF1F1F86865A576E02835ED2C2492\"),\n\t    SHEX(\"229160A61CF2842B37EA85788BB1CE8294DED9EAD266359D61DF3D6DF98EE155ED03AB1A51D6291B41680A00553298EB\"));\n  test_hash(&nettle_sha3_384, /* 37 octets */\n\t    SHEX(\"512A6D292E67ECB2FE486BFE92660953A75484FF4C4F2ECA2B0AF0EDCDD4339C6B2EE4E542\"),\n\t    SHEX(\"F5D838DEDF07AC3A5646221ADC6CA59045976DF9C33367FDAA0BE3AFC57EEF0D434EE92CD618B3FA26C7EABD18D78772\"));\n  test_hash(&nettle_sha3_384, /* 38 octets */\n\t    SHEX(\"973CF2B4DCF0BFA872B41194CB05BB4E16760A1840D8343301802576197EC19E2A1493D8F4FB\"),\n\t    SHEX(\"D41A324A1739BBCFC983A2B250750A1117E57BD26512CC5DCA7066D8B972AD9EB0BB3C7E36B9B84FC0E8129B69CD3847\"));\n  test_hash(&nettle_sha3_384, /* 39 octets */\n\t    SHEX(\"80BEEBCD2E3F8A9451D4499961C9731AE667CDC24EA020CE3B9AA4BBC0A7F79E30A934467DA4B0\"),\n\t    SHEX(\"170D73BAF77EAE7A852A1BB19BA6665F9EF425A66F2649E959B5CAA82D01FDB89C8C7FA6F40702F7C3391B146F6FA33E\"));\n  test_hash(&nettle_sha3_384, /* 40 octets */\n\t    SHEX(\"7ABAA12EC2A7347674E444140AE0FB659D08E1C66DECD8D6EAE925FA451D65F3C0308E29446B8ED3\"),\n\t    SHEX(\"A8F4A60A8FF5B3EBB4EADB9C46F1F403AB7FF632C7A11F80FC9153858B484291B3936713076955207D0C7E1964DC1346\"));\n  test_hash(&nettle_sha3_384, /* 41 octets */\n\t    SHEX(\"C88DEE9927679B8AF422ABCBACF283B904FF31E1CAC58C7819809F65D5807D46723B20F67BA610C2B7\"),\n\t    SHEX(\"5815D78ACA9600632239B7CE8385D7E837F883857601EFB78F9C2DAC9A96AE0BFD107526F268D06FB4227D4774A9E727\"));\n  test_hash(&nettle_sha3_384, /* 42 octets */\n\t    SHEX(\"01E43FE350FCEC450EC9B102053E6B5D56E09896E0DDD9074FE138E6038210270C834CE6EADC2BB86BF6\"),\n\t    SHEX(\"A5D91B01650D24B4753F41871FA700E997D5F1EF9C06D8F9B3A9B2D318716408E1566BB04B49B84E77F5F73D8F640541\"));\n  test_hash(&nettle_sha3_384, /* 43 octets */\n\t    SHEX(\"337023370A48B62EE43546F17C4EF2BF8D7ECD1D49F90BAB604B839C2E6E5BD21540D29BA27AB8E309A4B7\"),\n\t    SHEX(\"C7BA066881DB931E9C674D74CE2309B3002C6D5BC22056C454261CDBC5D93FE310EADD755E41FB1D789FDB9A73FDA28F\"));\n  test_hash(&nettle_sha3_384, /* 44 octets */\n\t    SHEX(\"6892540F964C8C74BD2DB02C0AD884510CB38AFD4438AF31FC912756F3EFEC6B32B58EBC38FC2A6B913596A8\"),\n\t    SHEX(\"A52CA3413BB83934B1EAD4686F639B90C5EE3CB5BE7E29A1A5293C868441D79BE2EF246B427FFCF0568D4D01BE54FF0D\"));\n  test_hash(&nettle_sha3_384, /* 45 octets */\n\t    SHEX(\"F5961DFD2B1FFFFDA4FFBF30560C165BFEDAB8CE0BE525845DEB8DC61004B7DB38467205F5DCFB34A2ACFE96C0\"),\n\t    SHEX(\"13E60554FA18CEF87CEABE147541886D97C2FB5F40F163D953306D2A26B013B33CB202D78AEF49FD47E7EC1C745920CD\"));\n  test_hash(&nettle_sha3_384, /* 46 octets */\n\t    SHEX(\"CA061A2EB6CEED8881CE2057172D869D73A1951E63D57261384B80CEB5451E77B06CF0F5A0EA15CA907EE1C27EBA\"),\n\t    SHEX(\"E4E03CCBA92BBD28182D005F69DE4E71C61C62CD323DECFB2ADDBEEFF7EE74933AA7A167E4E1DBB3DF7E5C91184F2D88\"));\n  test_hash(&nettle_sha3_384, /* 47 octets */\n\t    SHEX(\"1743A77251D69242750C4F1140532CD3C33F9B5CCDF7514E8584D4A5F9FBD730BCF84D0D4726364B9BF95AB251D9BB\"),\n\t    SHEX(\"9B26E9BF13B6FC33FD335DF976C8E1B781C800895EBD72E34F96EB875B41F04AAEE825CD8F0EB6C43D803F4E6EF688A9\"));\n  test_hash(&nettle_sha3_384, /* 48 octets */\n\t    SHEX(\"D8FABA1F5194C4DB5F176FABFFF856924EF627A37CD08CF55608BBA8F1E324D7C7F157298EABC4DCE7D89CE5162499F9\"),\n\t    SHEX(\"A127FEFCDD240F762CCE3F5F1551FC7E1CDEBC7950D1CD94C6888F490CB2285A10FD0EE797B168C5CA4761FA232AAF05\"));\n  test_hash(&nettle_sha3_384, /* 49 octets */\n\t    SHEX(\"BE9684BE70340860373C9C482BA517E899FC81BAAA12E5C6D7727975D1D41BA8BEF788CDB5CF4606C9C1C7F61AED59F97D\"),\n\t    SHEX(\"FEB5A24EDB05BEF846B0A1F3F48DA212DFC2D0BAC746890D4AD72FBE3A7B4FF8E2B542B827779467122271B1E0DF2BD2\"));\n  test_hash(&nettle_sha3_384, /* 50 octets */\n\t    SHEX(\"7E15D2B9EA74CA60F66C8DFAB377D9198B7B16DEB6A1BA0EA3C7EE2042F89D3786E779CF053C77785AA9E692F821F14A7F51\"),\n\t    SHEX(\"8DA4F3D1A13197171B02E1CCB07BF51CDBABD833FDC3C3797A113CFA5C71795782C47CE36C389FBAD461D0D5B59CA684\"));\n  test_hash(&nettle_sha3_384, /* 51 octets */\n\t    SHEX(\"9A219BE43713BD578015E9FDA66C0F2D83CAC563B776AB9F38F3E4F7EF229CB443304FBA401EFB2BDBD7ECE939102298651C86\"),\n\t    SHEX(\"D19FE4A5F93BCD483DAA7AF8CB636807962D40AF9A507DC4FA4E1FD480A6E8FA3C25FA30EB6B74979EE456C1644A5C1D\"));\n  test_hash(&nettle_sha3_384, /* 52 octets */\n\t    SHEX(\"C8F2B693BD0D75EF99CAEBDC22ADF4088A95A3542F637203E283BBC3268780E787D68D28CC3897452F6A22AA8573CCEBF245972A\"),\n\t    SHEX(\"63FF3053ACE687FB91070CA7FC6A51C259E13DA8AC0DD741AB36D1FA930E3BB9AC6A1FAD654F7238CFC4485C5F9F8252\"));\n  test_hash(&nettle_sha3_384, /* 53 octets */\n\t    SHEX(\"EC0F99711016C6A2A07AD80D16427506CE6F441059FD269442BAAA28C6CA037B22EEAC49D5D894C0BF66219F2C08E9D0E8AB21DE52\"),\n\t    SHEX(\"39DDE02A319B5E869F4C51A1D30FF4D4D88EBE504C54F155AA5FAD3316404FDBD1918074D35D14BAC88D6F359108A1DC\"));\n  test_hash(&nettle_sha3_384, /* 54 octets */\n\t    SHEX(\"0DC45181337CA32A8222FE7A3BF42FC9F89744259CFF653504D6051FE84B1A7FFD20CB47D4696CE212A686BB9BE9A8AB1C697B6D6A33\"),\n\t    SHEX(\"1959378F32117E58C0141160E16FACFE336590196BE805D149EB5AEEA641F9BB119B3EDDFEFD817701C82D2F528B823E\"));\n  test_hash(&nettle_sha3_384, /* 55 octets */\n\t    SHEX(\"DE286BA4206E8B005714F80FB1CDFAEBDE91D29F84603E4A3EBC04686F99A46C9E880B96C574825582E8812A26E5A857FFC6579F63742F\"),\n\t    SHEX(\"7B172A9BB311B1375E15ECE1C1E8F092BECFAFEC9F3144E93F596EB7E6ABFB34FCEDB08EDA7883EBBF40038B7A754F9F\"));\n  test_hash(&nettle_sha3_384, /* 56 octets */\n\t    SHEX(\"EEBCC18057252CBF3F9C070F1A73213356D5D4BC19AC2A411EC8CDEEE7A571E2E20EAF61FD0C33A0FFEB297DDB77A97F0A415347DB66BCAF\"),\n\t    SHEX(\"6BA32ECAAA0AA9C59E72173F2A7816AC51F313C467A017190DB9832C6311EC23B8D56B7B220FA09A9081962EFED5183E\"));\n  test_hash(&nettle_sha3_384, /* 57 octets */\n\t    SHEX(\"416B5CDC9FE951BD361BD7ABFC120A5054758EBA88FDD68FD84E39D3B09AC25497D36B43CBE7B85A6A3CEBDA8DB4E5549C3EE51BB6FCB6AC1E\"),\n\t    SHEX(\"55FDF2EC27D334B5B59EFB9B6D518E25BE0F5FF6379F7B97945F3E1235EC70295B39EBEABF70FCAF1E61EDB1C21A4C06\"));\n  test_hash(&nettle_sha3_384, /* 58 octets */\n\t    SHEX(\"5C5FAF66F32E0F8311C32E8DA8284A4ED60891A5A7E50FB2956B3CBAA79FC66CA376460E100415401FC2B8518C64502F187EA14BFC9503759705\"),\n\t    SHEX(\"D51A3F33919FE5DA0EFEA6EDAD201F01FA8416C385A89D96DF743D243A6AABA5B7690D187B95CAFFDACD1E85F56B813B\"));\n  test_hash(&nettle_sha3_384, /* 59 octets */\n\t    SHEX(\"7167E1E02BE1A7CA69D788666F823AE4EEF39271F3C26A5CF7CEE05BCA83161066DC2E217B330DF821103799DF6D74810EED363ADC4AB99F36046A\"),\n\t    SHEX(\"F1D6E8F95C497D5BEAFB4215E07CDB59E0E3709CF561618F67E301931D204C6CE477E0F750099584B645E2F718650813\"));\n  test_hash(&nettle_sha3_384, /* 60 octets */\n\t    SHEX(\"2FDA311DBBA27321C5329510FAE6948F03210B76D43E7448D1689A063877B6D14C4F6D0EAA96C150051371F7DD8A4119F7DA5C483CC3E6723C01FB7D\"),\n\t    SHEX(\"B1D347D057CCD72867B12BF00BF511F87DEFCD0FA6ADADAF4BB1AD790F06ECBB1F4488A0319B05C46A7874857370CE76\"));\n  test_hash(&nettle_sha3_384, /* 61 octets */\n\t    SHEX(\"95D1474A5AAB5D2422ACA6E481187833A6212BD2D0F91451A67DD786DFC91DFED51B35F47E1DEB8A8AB4B9CB67B70179CC26F553AE7B569969CE151B8D\"),\n\t    SHEX(\"4F192EDFA54FECE64AC0B3EC9E120B291ADE99948805A87BBB04947E928BB5EBA87E2EE599960C436EA7C7884187E78C\"));\n  test_hash(&nettle_sha3_384, /* 62 octets */\n\t    SHEX(\"C71BD7941F41DF044A2927A8FF55B4B467C33D089F0988AA253D294ADDBDB32530C0D4208B10D9959823F0C0F0734684006DF79F7099870F6BF53211A88D\"),\n\t    SHEX(\"75E23FED3B59DB6B1D3378B7E8772642CBBFF7710D8A91B249BB6C68E384CD416F19AC1E8ED92B71D0CA303D247EE9BD\"));\n  test_hash(&nettle_sha3_384, /* 63 octets */\n\t    SHEX(\"F57C64006D9EA761892E145C99DF1B24640883DA79D9ED5262859DCDA8C3C32E05B03D984F1AB4A230242AB6B78D368DC5AAA1E6D3498D53371E84B0C1D4BA\"),\n\t    SHEX(\"C8D1E6BE5485FC13BF433F11A580ABBE89B12A66D0E5CB141E1D62CDC6A367725793FB25840B36CB7003F2E7DF3E5F2F\"));\n  test_hash(&nettle_sha3_384, /* 64 octets */\n\t    SHEX(\"E926AE8B0AF6E53176DBFFCC2A6B88C6BD765F939D3D178A9BDE9EF3AA131C61E31C1E42CDFAF4B4DCDE579A37E150EFBEF5555B4C1CB40439D835A724E2FAE7\"),\n\t    SHEX(\"423BA134D3BCB5E440AC83372C7EDDBA3AE3BDDF1222F505C19CDE246AD76A2B0D07239A54E1D0934C9B3D29D49E5FBD\"));\n  test_hash(&nettle_sha3_384, /* 65 octets */\n\t    SHEX(\"16E8B3D8F988E9BB04DE9C96F2627811C973CE4A5296B4772CA3EEFEB80A652BDF21F50DF79F32DB23F9F73D393B2D57D9A0297F7A2F2E79CFDA39FA393DF1AC00\"),\n\t    SHEX(\"662C4851D311A786DE4CDA7E9EA1EFF0BFA462761FF6CF804E591ED9A15B0DC93A2BB6A6CFFDC8D7D23A233A52C86EAD\"));\n  test_hash(&nettle_sha3_384, /* 66 octets */\n\t    SHEX(\"FC424EEB27C18A11C01F39C555D8B78A805B88DBA1DC2A42ED5E2C0EC737FF68B2456D80EB85E11714FA3F8EABFB906D3C17964CB4F5E76B29C1765DB03D91BE37FC\"),\n\t    SHEX(\"5F54B1DAFA67ED9B498125E064F0B07F54E754E3F30720DD4A471E9BB6E307F05FB69BC81D391F503C95C3BB671E6973\"));\n  test_hash(&nettle_sha3_384, /* 67 octets */\n\t    SHEX(\"ABE3472B54E72734BDBA7D9158736464251C4F21B33FBBC92D7FAC9A35C4E3322FF01D2380CBAA4EF8FB07D21A2128B7B9F5B6D9F34E13F39C7FFC2E72E47888599BA5\"),\n\t    SHEX(\"A21B55DED8FE41FB2B193FA490420A8B62FCAE9A185DA85E253DAEFE85270B6904BA4ECC76BB5128926FFF9D79F728AD\"));\n  test_hash(&nettle_sha3_384, /* 68 octets */\n\t    SHEX(\"36F9F0A65F2CA498D739B944D6EFF3DA5EBBA57E7D9C41598A2B0E4380F3CF4B479EC2348D015FFE6256273511154AFCF3B4B4BF09D6C4744FDD0F62D75079D440706B05\"),\n\t    SHEX(\"341BE5677A05EED816A219669D680BBF185B31CF3EB0D289F90210FB1A7940D9BFF4909320AE4E3B7274E5BE479C46F1\"));\n  test_hash(&nettle_sha3_384, /* 69 octets */\n\t    SHEX(\"ABC87763CAE1CA98BD8C5B82CABA54AC83286F87E9610128AE4DE68AC95DF5E329C360717BD349F26B872528492CA7C94C2C1E1EF56B74DBB65C2AC351981FDB31D06C77A4\"),\n\t    SHEX(\"D70F78894E292B075A0FE56FB952B2CE87A94CA029347159FBB12B22103DD4DC4C265B7AE88950CCA89C40B531437AA4\"));\n  test_hash(&nettle_sha3_384, /* 70 octets */\n\t    SHEX(\"94F7CA8E1A54234C6D53CC734BB3D3150C8BA8C5F880EAB8D25FED13793A9701EBE320509286FD8E422E931D99C98DA4DF7E70AE447BAB8CFFD92382D8A77760A259FC4FBD72\"),\n\t    SHEX(\"89BD6B7CC9ADDDFFE46BF85C56B8CE66E1B1B46969B197ADBF2E34B7059D8BB05F9F53BD1A58A7E0A66E5EF208BF5695\"));\n  test_hash(&nettle_sha3_384, /* 71 octets */\n\t    SHEX(\"13BD2811F6ED2B6F04FF3895ACEED7BEF8DCD45EB121791BC194A0F806206BFFC3B9281C2B308B1A729CE008119DD3066E9378ACDCC50A98A82E20738800B6CDDBE5FE9694AD6D\"),\n\t    SHEX(\"AE651EF50A20B0F496F104F56F845206ED544B28D0374CBB779146DFF2EA5894EB29301FE33872F9B299A79C0C0F28C4\"));\n  test_hash(&nettle_sha3_384, /* 72 octets */\n\t    SHEX(\"1EED9CBA179A009EC2EC5508773DD305477CA117E6D569E66B5F64C6BC64801CE25A8424CE4A26D575B8A6FB10EAD3FD1992EDDDEEC2EBE7150DC98F63ADC3237EF57B91397AA8A7\"),\n\t    SHEX(\"A842918DFBBF3BFFCCC527B6DD2C0DF4EB3F100F0692727DA77DAF44A654876013B37031C493AC18950003EEBD107A29\"));\n  test_hash(&nettle_sha3_384, /* 73 octets */\n\t    SHEX(\"BA5B67B5EC3A3FFAE2C19DD8176A2EF75C0CD903725D45C9CB7009A900C0B0CA7A2967A95AE68269A6DBF8466C7B6844A1D608AC661F7EFF00538E323DB5F2C644B78B2D48DE1A08AA\"),\n\t    SHEX(\"20D16CC6AF5B4D5AECCEAD09F300B1DC1DA93A608370EE0B2CF15C316508B5EF8C9BE27D0F7288617B1E529FC2932038\"));\n  test_hash(&nettle_sha3_384, /* 74 octets */\n\t    SHEX(\"0EFA26AC5673167DCACAB860932ED612F65FF49B80FA9AE65465E5542CB62075DF1C5AE54FBA4DB807BE25B070033EFA223BDD5B1D3C94C6E1909C02B620D4B1B3A6C9FED24D70749604\"),\n\t    SHEX(\"69A3BB36F52EB650C6E8242DB05659573AF811A1A5DB908F773D65E74D327F5B65303DD0DD9BD07FF100D050E46FE97D\"));\n  test_hash(&nettle_sha3_384, /* 75 octets */\n\t    SHEX(\"BBFD933D1FD7BF594AC7F435277DC17D8D5A5B8E4D13D96D2F64E771ABBD51A5A8AEA741BECCBDDB177BCEA05243EBD003CFDEAE877CCA4DA94605B67691919D8B033F77D384CA01593C1B\"),\n\t    SHEX(\"D239F2FA1675A1A031E2F6E8A53D6E2F37D081CDB029727B3ACBDD7CBFC7D3581BDE8D3068AA9A300AE12B7245124508\"));\n  test_hash(&nettle_sha3_384, /* 76 octets */\n\t    SHEX(\"90078999FD3C35B8AFBF4066CBDE335891365F0FC75C1286CDD88FA51FAB94F9B8DEF7C9AC582A5DBCD95817AFB7D1B48F63704E19C2BAA4DF347F48D4A6D603013C23F1E9611D595EBAC37C\"),\n\t    SHEX(\"2F8D747DDF64320297B44F8547EF42FCE78A48F0A59A18DB1CFB9F43C049628F97C0BB93ADAAB9617155272424F74027\"));\n  test_hash(&nettle_sha3_384, /* 77 octets */\n\t    SHEX(\"64105ECA863515C20E7CFBAA0A0B8809046164F374D691CDBD6508AAABC1819F9AC84B52BAFC1B0FE7CDDBC554B608C01C8904C669D8DB316A0953A4C68ECE324EC5A49FFDB59A1BD6A292AA0E\"),\n\t    SHEX(\"714BE6F2F934E0B6FD69E392D99ACC98592B015E48A1637262F99286502B06774783BB9F371C760C3EB78AEADFBD0DF0\"));\n  test_hash(&nettle_sha3_384, /* 78 octets */\n\t    SHEX(\"D4654BE288B9F3B711C2D02015978A8CC57471D5680A092AA534F7372C71CEAAB725A383C4FCF4D8DEAA57FCA3CE056F312961ECCF9B86F14981BA5BED6AB5B4498E1F6C82C6CAE6FC14845B3C8A\"),\n\t    SHEX(\"22A41B117464F7F49682E8139A0D5BD23FE00D1190B1B419F27B490B729B56BBA9DE649DD7C988B6B308038661E1C362\"));\n  test_hash(&nettle_sha3_384, /* 79 octets */\n\t    SHEX(\"12D9394888305AC96E65F2BF0E1B18C29C90FE9D714DD59F651F52B88B3008C588435548066EA2FC4C101118C91F32556224A540DE6EFDDBCA296EF1FB00341F5B01FECFC146BDB251B3BDAD556CD2\"),\n\t    SHEX(\"77780F3646D288291790F2A5F4AA9C98A64A1115306994CD65C7620DDE06D35117CE4B79DAE08B5B4E798459010941BB\"));\n  test_hash(&nettle_sha3_384, /* 80 octets */\n\t    SHEX(\"871A0D7A5F36C3DA1DFCE57ACD8AB8487C274FAD336BC137EBD6FF4658B547C1DCFAB65F037AA58F35EF16AFF4ABE77BA61F65826F7BE681B5B6D5A1EA8085E2AE9CD5CF0991878A311B549A6D6AF230\"),\n\t    SHEX(\"5CED3B7368582DD6DEBFE41D6AFFD82B72894B51FF4C4ACCBA09C595B36E23E347AB4BAAB0E5191D86E26E6596D62E23\"));\n  test_hash(&nettle_sha3_384, /* 81 octets */\n\t    SHEX(\"E90B4FFEF4D457BC7711FF4AA72231CA25AF6B2E206F8BF859D8758B89A7CD36105DB2538D06DA83BAD5F663BA11A5F6F61F236FD5F8D53C5E89F183A3CEC615B50C7C681E773D109FF7491B5CC22296C5\"),\n\t    SHEX(\"1410EF9ABB8D98B1C65E113A61915B0E6933BC59DA31C8FCC39B7165E715919184375D822A07C778F63431BE2AEECD99\"));\n  test_hash(&nettle_sha3_384, /* 82 octets */\n\t    SHEX(\"E728DE62D75856500C4C77A428612CD804F30C3F10D36FB219C5CA0AA30726AB190E5F3F279E0733D77E7267C17BE27D21650A9A4D1E32F649627638DBADA9702C7CA303269ED14014B2F3CF8B894EAC8554\"),\n\t    SHEX(\"330ED51B045471DEA8CFF26510D68494611ECFD614D49E5A9CC8846A132519BBCF49907691AC5ACCFC0528DA0C14D49E\"));\n  test_hash(&nettle_sha3_384, /* 83 octets */\n\t    SHEX(\"6348F229E7B1DF3B770C77544E5166E081850FA1C6C88169DB74C76E42EB983FACB276AD6A0D1FA7B50D3E3B6FCD799EC97470920A7ABED47D288FF883E24CA21C7F8016B93BB9B9E078BDB9703D2B781B616E\"),\n\t    SHEX(\"387111A206FC6488F78D41786886A9E5EC9F73E1131D92F290F68512320A408D5F63EAA5ABA32D9853EB11B5B0887E62\"));\n  test_hash(&nettle_sha3_384, /* 84 octets */\n\t    SHEX(\"4B127FDE5DE733A1680C2790363627E63AC8A3F1B4707D982CAEA258655D9BF18F89AFE54127482BA01E08845594B671306A025C9A5C5B6F93B0A39522DC877437BE5C2436CBF300CE7AB6747934FCFC30AEAAF6\"),\n\t    SHEX(\"78573F5D075200D3823194A71E55880F4FE78489234DBF3DF3E3734CBCAE8DC1D8C1AE95F9EFA9903DC4C4581B59DDDE\"));\n  test_hash(&nettle_sha3_384, /* 85 octets */\n\t    SHEX(\"08461F006CFF4CC64B752C957287E5A0FAABC05C9BFF89D23FD902D324C79903B48FCB8F8F4B01F3E4DDB483593D25F000386698F5ADE7FAADE9615FDC50D32785EA51D49894E45BAA3DC707E224688C6408B68B11\"),\n\t    SHEX(\"FDFE4F1B034733C2C94A7B36E2B52774A95C2BDE22FCDDFCEF52F7FEF7C67F08E2F7B9B8967E447F76EF91960DA76288\"));\n  test_hash(&nettle_sha3_384, /* 86 octets */\n\t    SHEX(\"68C8F8849B120E6E0C9969A5866AF591A829B92F33CD9A4A3196957A148C49138E1E2F5C7619A6D5EDEBE995ACD81EC8BB9C7B9CFCA678D081EA9E25A75D39DB04E18D475920CE828B94E72241F24DB72546B352A0E4\"),\n\t    SHEX(\"48D66A4165AA54528ECE89BD9AA00EAB196F32DFDC4D76F236655835527AAA1642E6BF4EDF24F030F5EEEF07FA40F5D2\"));\n  test_hash(&nettle_sha3_384, /* 87 octets */\n\t    SHEX(\"B8D56472954E31FB54E28FCA743F84D8DC34891CB564C64B08F7B71636DEBD64CA1EDBDBA7FC5C3E40049CE982BBA8C7E0703034E331384695E9DE76B5104F2FBC4535ECBEEBC33BC27F29F18F6F27E8023B0FBB6F563C\"),\n\t    SHEX(\"3C2575372CE1F380A6E66BB075FBAE98FC2E6D3D267A20FF0313ABC3DE252E03FD5BDFA8BC2B79FC874CCDA4ABDBB4A6\"));\n  test_hash(&nettle_sha3_384, /* 88 octets */\n\t    SHEX(\"0D58AC665FA84342E60CEFEE31B1A4EACDB092F122DFC68309077AED1F3E528F578859EE9E4CEFB4A728E946324927B675CD4F4AC84F64DB3DACFE850C1DD18744C74CECCD9FE4DC214085108F404EAB6D8F452B5442A47D\"),\n\t    SHEX(\"0EE6AECA8DD80B74225AC4882E2BC1E6819C9B94F0D0BC0A1E21AABF4B11CB74DB4734BC8D1179D7DCEF535BE9F3DA28\"));\n  test_hash(&nettle_sha3_384, /* 89 octets */\n\t    SHEX(\"1755E2D2E5D1C1B0156456B539753FF416651D44698E87002DCF61DCFA2B4E72F264D9AD591DF1FDEE7B41B2EB00283C5AEBB3411323B672EAA145C5125185104F20F335804B02325B6DEA65603F349F4D5D8B782DD3469CCD\"),\n\t    SHEX(\"8027E5044923F8EEE1DF184865CD97B635A78DA199FD80AD3D343A5AE03D1B165E58D1B0BD093EF916A16D6641BDA17C\"));\n  test_hash(&nettle_sha3_384, /* 90 octets */\n\t    SHEX(\"B180DE1A611111EE7584BA2C4B020598CD574AC77E404E853D15A101C6F5A2E5C801D7D85DC95286A1804C870BB9F00FD4DCB03AA8328275158819DCAD7253F3E3D237AEAA7979268A5DB1C6CE08A9EC7C2579783C8AFC1F91A7\"),\n\t    SHEX(\"796818E047913D5AFB4AE4C5B7C5D5EF699A3A9EBEFB44462EE8FE603CA5628973369E4A9D8E10115FDD75C89707A8F9\"));\n  test_hash(&nettle_sha3_384, /* 91 octets */\n\t    SHEX(\"CF3583CBDFD4CBC17063B1E7D90B02F0E6E2EE05F99D77E24E560392535E47E05077157F96813544A17046914F9EFB64762A23CF7A49FE52A0A4C01C630CFE8727B81FB99A89FF7CC11DCA5173057E0417B8FE7A9EFBA6D95C555F\"),\n\t    SHEX(\"1E96EFF62E9F464B4802972FDAC77C3EA1131B2822619D2C5D863E357D0945C17F93EDE66AF05D46E63C2857A54F67F4\"));\n  test_hash(&nettle_sha3_384, /* 92 octets */\n\t    SHEX(\"072FC02340EF99115BAD72F92C01E4C093B9599F6CFC45CB380EE686CB5EB019E806AB9BD55E634AB10AA62A9510CC0672CD3EDDB589C7DF2B67FCD3329F61B1A4441ECA87A33C8F55DA4FBBAD5CF2B2527B8E983BB31A2FADEC7523\"),\n\t    SHEX(\"4CC41C2FB7D71DA1AD36D18029F755DAF342E732EC31F0C06E27091307718ACB53FA113AE508DF38B8C96834DE33F9F1\"));\n  test_hash(&nettle_sha3_384, /* 93 octets */\n\t    SHEX(\"76EECF956A52649F877528146DE33DF249CD800E21830F65E90F0F25CA9D6540FDE40603230ECA6760F1139C7F268DEBA2060631EEA92B1FFF05F93FD5572FBE29579ECD48BC3A8D6C2EB4A6B26E38D6C5FBF2C08044AEEA470A8F2F26\"),\n\t    SHEX(\"9A8D4B560421C82991BDFCA0898A29A59BDB09D20F8A5B279096723BAB382789F081EAD50D273ECA436C526ABA6D5CFC\"));\n  test_hash(&nettle_sha3_384, /* 94 octets */\n\t    SHEX(\"7ADC0B6693E61C269F278E6944A5A2D8300981E40022F839AC644387BFAC9086650085C2CDC585FEA47B9D2E52D65A2B29A7DC370401EF5D60DD0D21F9E2B90FAE919319B14B8C5565B0423CEFB827D5F1203302A9D01523498A4DB10374\"),\n\t    SHEX(\"367CB3FE03A3CBB50FAE1FE7EA883A0AE53CBE772F709DC5505F3C907564C08FC49707CFF9639B25C746B6039FF48AE9\"));\n  test_hash(&nettle_sha3_384, /* 95 octets */\n\t    SHEX(\"E1FFFA9826CCE8B86BCCEFB8794E48C46CDF372013F782ECED1E378269B7BE2B7BF51374092261AE120E822BE685F2E7A83664BCFBE38FE8633F24E633FFE1988E1BC5ACF59A587079A57A910BDA60060E85B5F5B6F776F0529639D9CCE4BD\"),\n\t    SHEX(\"BBBD05D69D7A082FCDA8ED535D7E4E5DE1377BD91E72D42DC95295C9DB780169E2F9620EC7A5AFF959FF2D946FD20A72\"));\n  test_hash(&nettle_sha3_384, /* 96 octets */\n\t    SHEX(\"69F9ABBA65592EE01DB4DCE52DBAB90B08FC04193602792EE4DAA263033D59081587B09BBE49D0B49C9825D22840B2FF5D9C5155F975F8F2C2E7A90C75D2E4A8040FE39F63BBAFB403D9E28CC3B86E04E394A9C9E8065BD3C85FA9F0C7891600\"),\n\t    SHEX(\"BE8BEC0C2EC721E0C326037CE86A1518FB395C3A9802DE01C3E234268EBB9AC9A39A6E404F25FB7FEBDCF1F7F25DC083\"));\n  test_hash(&nettle_sha3_384, /* 97 octets */\n\t    SHEX(\"38A10A352CA5AEDFA8E19C64787D8E9C3A75DBF3B8674BFAB29B5DBFC15A63D10FAE66CD1A6E6D2452D557967EAAD89A4C98449787B0B3164CA5B717A93F24EB0B506CEB70CBBCB8D72B2A72993F909AAD92F044E0B5A2C9AC9CB16A0CA2F81F49\"),\n\t    SHEX(\"2AEEAF292AD625221BA79A621217FD1B3F8978BA83FE7FF13B38574FCFAFFBD207298854B6F9C27D6677494204221FDA\"));\n  test_hash(&nettle_sha3_384, /* 98 octets */\n\t    SHEX(\"6D8C6E449BC13634F115749C248C17CD148B72157A2C37BF8969EA83B4D6BA8C0EE2711C28EE11495F43049596520CE436004B026B6C1F7292B9C436B055CBB72D530D860D1276A1502A5140E3C3F54A93663E4D20EDEC32D284E25564F624955B52\"),\n\t    SHEX(\"9A1761C5759CE67C9C093EC5C831C1FF7CAB64AC7C8002066EDCAED044DEF57CEA3EF6BE98578363D2CE3D1F5BA448F8\"));\n  test_hash(&nettle_sha3_384, /* 99 octets */\n\t    SHEX(\"6EFCBCAF451C129DBE00B9CEF0C3749D3EE9D41C7BD500ADE40CDC65DEDBBBADB885A5B14B32A0C0D087825201E303288A733842FA7E599C0C514E078F05C821C7A4498B01C40032E9F1872A1C925FA17CE253E8935E4C3C71282242CB716B2089CCC1\"),\n\t    SHEX(\"4A24A1AF68DB65C3977431EE81092C776F7CB33D6F08940100EA240A2D1F8623A41D07CE9937BCBEC8CA1072A1A78E8B\"));\n  test_hash(&nettle_sha3_384, /* 100 octets */\n\t    SHEX(\"433C5303131624C0021D868A30825475E8D0BD3052A022180398F4CA4423B98214B6BEAAC21C8807A2C33F8C93BD42B092CC1B06CEDF3224D5ED1EC29784444F22E08A55AA58542B524B02CD3D5D5F6907AFE71C5D7462224A3F9D9E53E7E0846DCBB4CE\"),\n\t    SHEX(\"928E94D19FC60065A5EF7E48018387C80F2D350F306D0F610173719D5C874D4A8ACC340FEAD4BE357E1F78124198AD77\"));\n  test_hash(&nettle_sha3_384, /* 101 octets */\n\t    SHEX(\"A873E0C67CA639026B6683008F7AA6324D4979550E9BCE064CA1E1FB97A30B147A24F3F666C0A72D71348EDE701CF2D17E2253C34D1EC3B647DBCEF2F879F4EB881C4830B791378C901EB725EA5C172316C6D606E0AF7DF4DF7F76E490CD30B2BADF45685F\"),\n\t    SHEX(\"78A18D62F8A7EFF5C6DD75B8CB073FD30EE68C878C2EC58AAD1C5DD0EB0AE43698A617BB0C670FCE2AA098E0ADF425B2\"));\n  test_hash(&nettle_sha3_384, /* 102 octets */\n\t    SHEX(\"006917B64F9DCDF1D2D87C8A6173B64F6587168E80FAA80F82D84F60301E561E312D9FBCE62F39A6FB476E01E925F26BCC91DE621449BE6504C504830AAE394096C8FC7694651051365D4EE9070101EC9B68086F2EA8F8AB7B811EA8AD934D5C9B62C60A4771\"),\n\t    SHEX(\"EEEB56C3E54FA833B985EFA5923C3F0225F419664CEDD898C79F64D72D2AD4B125A38BE0201846C442EAF0051D516DC9\"));\n  test_hash(&nettle_sha3_384, /* 103 octets */\n\t    SHEX(\"F13C972C52CB3CC4A4DF28C97F2DF11CE089B815466BE88863243EB318C2ADB1A417CB1041308598541720197B9B1CB5BA2318BD5574D1DF2174AF14884149BA9B2F446D609DF240CE335599957B8EC80876D9A085AE084907BC5961B20BF5F6CA58D5DAB38ADB\"),\n\t    SHEX(\"0A834E111B4E840E787C19748465A47D88B3F0F3DAAF15DB25536BDC6078FA9C05E6C953830274223968847DA8BFD20D\"));\n  test_hash(&nettle_sha3_384, /* 104 octets */\n\t    SHEX(\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\"),\n\t    SHEX(\"D1C0FA85C8D183BEFF99AD9D752B263E286B477F79F0710B010317017397813344B99DAF3BB7B1BC5E8D722BAC85943A\"));\n  test_hash(&nettle_sha3_384, /* 105 octets */\n\t    SHEX(\"64EC021C9585E01FFE6D31BB50D44C79B6993D72678163DB474947A053674619D158016ADB243F5C8D50AA92F50AB36E579FF2DABB780A2B529370DAA299207CFBCDD3A9A25006D19C4F1FE33E4B1EAEC315D8C6EE1E730623FD1941875B924EB57D6D0C2EDC4E78D6\"),\n\t    SHEX(\"6AEDCF4426B2483C0D0D04695BCC052BEDD04FA4D17A1BBB2797F6272FA476BFC138E4091409FEB1AC0E8BFF350A6663\"));\n  test_hash(&nettle_sha3_384, /* 106 octets */\n\t    SHEX(\"5954BAB512CF327D66B5D9F296180080402624AD7628506B555EEA8382562324CF452FBA4A2130DE3E165D11831A270D9CB97CE8C2D32A96F50D71600BB4CA268CF98E90D6496B0A6619A5A8C63DB6D8A0634DFC6C7EC8EA9C006B6C456F1B20CD19E781AF20454AC880\"),\n\t    SHEX(\"ACB7013CE75124388187DC0E7430CB74A314D601B6C8D7A7DE5CF03197A84F7874FF058808575CB2F10185F561BB06B1\"));\n  test_hash(&nettle_sha3_384, /* 107 octets */\n\t    SHEX(\"03D9F92B2C565709A568724A0AFF90F8F347F43B02338F94A03ED32E6F33666FF5802DA4C81BDCE0D0E86C04AFD4EDC2FC8B4141C2975B6F07639B1994C973D9A9AFCE3D9D365862003498513BFA166D2629E314D97441667B007414E739D7FEBF0FE3C32C17AA188A8683\"),\n\t    SHEX(\"F947469DB712EA26F25F709FF7879136EA2A79E0A2D0ED5EE4ADF0E167F106BC410C93AE1D986EC211E0FD9A40741857\"));\n  test_hash(&nettle_sha3_384, /* 108 octets */\n\t    SHEX(\"F31E8B4F9E0621D531D22A380BE5D9ABD56FAEC53CBD39B1FAB230EA67184440E5B1D15457BD25F56204FA917FA48E669016CB48C1FFC1E1E45274B3B47379E00A43843CF8601A5551411EC12503E5AAC43D8676A1B2297EC7A0800DBFEE04292E937F21C005F17411473041\"),\n\t    SHEX(\"65989BF4EBBF4C21B3DD34551D3F6167910236671BB7F348DC552ADB8028A468FA40EF4A8C1227A1A41C28105E64AC20\"));\n  test_hash(&nettle_sha3_384, /* 109 octets */\n\t    SHEX(\"758EA3FEA738973DB0B8BE7E599BBEF4519373D6E6DCD7195EA885FC991D896762992759C2A09002912FB08E0CB5B76F49162AEB8CF87B172CF3AD190253DF612F77B1F0C532E3B5FC99C2D31F8F65011695A087A35EE4EEE5E334C369D8EE5D29F695815D866DA99DF3F79403\"),\n\t    SHEX(\"B77A69E373AF0F733CDAD399C9B12642A046E1A7893D3382943A8367D37740DF53916F6DAF90517B39621C14343754A2\"));\n  test_hash(&nettle_sha3_384, /* 110 octets */\n\t    SHEX(\"47C6E0C2B74948465921868804F0F7BD50DD323583DC784F998A93CD1CA4C6EF84D41DC81C2C40F34B5BEE6A93867B3BDBA0052C5F59E6F3657918C382E771D33109122CC8BB0E1E53C4E3D13B43CE44970F5E0C079D2AD7D7A3549CD75760C21BB15B447589E86E8D76B1E9CED2\"),\n\t    SHEX(\"3D14B6FAE6156E7876367897A49269181EA58CC3CA9621C0F81D6A5FB6F615680D909B29F6AF7E62FAD04D70046BE997\"));\n  test_hash(&nettle_sha3_384, /* 111 octets */\n\t    SHEX(\"F690A132AB46B28EDFA6479283D6444E371C6459108AFD9C35DBD235E0B6B6FF4C4EA58E7554BD002460433B2164CA51E868F7947D7D7A0D792E4ABF0BE5F450853CC40D85485B2B8857EA31B5EA6E4CCFA2F3A7EF3380066D7D8979FDAC618AAD3D7E886DEA4F005AE4AD05E5065F\"),\n\t    SHEX(\"456AD01908E187CA2CE9E7A4DAED8788C909E9BC974EFD1C9A44AC36DB9B6DA985C947C7E0A47AB27BF10CD760FA48AF\"));\n  test_hash(&nettle_sha3_384, /* 112 octets */\n\t    SHEX(\"58D6A99BC6458824B256916770A8417040721CCCFD4B79EACD8B65A3767CE5BA7E74104C985AC56B8CC9AEBD16FEBD4CDA5ADB130B0FF2329CC8D611EB14DAC268A2F9E633C99DE33997FEA41C52A7C5E1317D5B5DAED35EBA7D5A60E45D1FA7EAABC35F5C2B0A0F2379231953322C4E\"),\n\t    SHEX(\"C26BDAC454E1ADC0D090D0C5254A29966611B6673014CBACA24D26B6F63EC7E8F993BA3DF7DF89770E902D5F6574F6A8\"));\n  test_hash(&nettle_sha3_384, /* 113 octets */\n\t    SHEX(\"BEFAB574396D7F8B6705E2D5B58B2C1C820BB24E3F4BAE3E8FBCD36DBF734EE14E5D6AB972AEDD3540235466E825850EE4C512EA9795ABFD33F330D9FD7F79E62BBB63A6EA85DE15BEAEEA6F8D204A28956059E2632D11861DFB0E65BC07AC8A159388D5C3277E227286F65FF5E5B5AEC1\"),\n\t    SHEX(\"1D85BF9AA2B6DCC3105E7D7F91069F01E4C998D6F03B77650D75839D65A7A049196FD935AFEFFDEB657BC8F96B7C17B5\"));\n  test_hash(&nettle_sha3_384, /* 114 octets */\n\t    SHEX(\"8E58144FA9179D686478622CE450C748260C95D1BA43B8F9B59ABECA8D93488DA73463EF40198B4D16FB0B0707201347E0506FF19D01BEA0F42B8AF9E71A1F1BD168781069D4D338FDEF00BF419FBB003031DF671F4A37979564F69282DE9C65407847DD0DA505AB1641C02DEA4F0D834986\"),\n\t    SHEX(\"085CFA581CF3F4F19416BEE3ED5AC2544662AA51BDF1D2E348D9BCC27343487DF20B18D9F6FB64565868504A6805D176\"));\n  test_hash(&nettle_sha3_384, /* 115 octets */\n\t    SHEX(\"B55C10EAE0EC684C16D13463F29291BF26C82E2FA0422A99C71DB4AF14DD9C7F33EDA52FD73D017CC0F2DBE734D831F0D820D06D5F89DACC485739144F8CFD4799223B1AFF9031A105CB6A029BA71E6E5867D85A554991C38DF3C9EF8C1E1E9A7630BE61CAABCA69280C399C1FB7A12D12AEFC\"),\n\t    SHEX(\"376088F09039CAA40BF19FF5E5F193FC9ECB6116A0ACB3237AAAB6CD807BD7AF45D804D837A18D2BD9A8C3DAA3A1D153\"));\n  test_hash(&nettle_sha3_384, /* 116 octets */\n\t    SHEX(\"2EEEA693F585F4ED6F6F8865BBAE47A6908AECD7C429E4BEC4F0DE1D0CA0183FA201A0CB14A529B7D7AC0E6FF6607A3243EE9FB11BCF3E2304FE75FFCDDD6C5C2E2A4CD45F63C962D010645058D36571404A6D2B4F44755434D76998E83409C3205AA1615DB44057DB991231D2CB42624574F545\"),\n\t    SHEX(\"CD40B35FBD90B04D0641F71088F7C6159D8EB16DE8AAE09F355877A0333B53150B81D36C5C2446BF5AC462EF84D4E572\"));\n  test_hash(&nettle_sha3_384, /* 117 octets */\n\t    SHEX(\"DAB11DC0B047DB0420A585F56C42D93175562852428499F66A0DB811FCDDDAB2F7CDFFED1543E5FB72110B64686BC7B6887A538AD44C050F1E42631BC4EC8A9F2A047163D822A38989EE4AAB01B4C1F161B062D873B1CFA388FD301514F62224157B9BEF423C7783B7AAC8D30D65CD1BBA8D689C2D\"),\n\t    SHEX(\"DB14442400597871FA56D10F53BE7BB4002C44624C44E89C99B95122676A76FF28840285239E2E4FBFB751E4179577D8\"));\n  test_hash(&nettle_sha3_384, /* 118 octets */\n\t    SHEX(\"42E99A2F80AEE0E001279A2434F731E01D34A44B1A8101726921C0590C30F3120EB83059F325E894A5AC959DCA71CE2214799916424E859D27D789437B9D27240BF8C35ADBAFCECC322B48AA205B293962D858652ABACBD588BCF6CBC388D0993BD622F96ED54614C25B6A9AA527589EAAFFCF17DDF7\"),\n\t    SHEX(\"4509ADB6177BC6DEBCA7E36948F07001159A57EC8CCA2B76C770735C5BCCC679DA6AB4E64D915D0E1A754C3FDA11B524\"));\n  test_hash(&nettle_sha3_384, /* 119 octets */\n\t    SHEX(\"3C9B46450C0F2CAE8E3823F8BDB4277F31B744CE2EB17054BDDC6DFF36AF7F49FB8A2320CC3BDF8E0A2EA29AD3A55DE1165D219ADEDDB5175253E2D1489E9B6FDD02E2C3D3A4B54D60E3A47334C37913C5695378A669E9B72DEC32AF5434F93F46176EBF044C4784467C700470D0C0B40C8A088C815816\"),\n\t    SHEX(\"193AF71BDD228AB3E8AE50E1B1CBF1984B0AF92AAC5A71CBE618AFD4187DED6B461411A39E72EA4E213FE0A5231C498D\"));\n  test_hash(&nettle_sha3_384, /* 120 octets */\n\t    SHEX(\"D1E654B77CB155F5C77971A64DF9E5D34C26A3CAD6C7F6B300D39DEB1910094691ADAA095BE4BA5D86690A976428635D5526F3E946F7DC3BD4DBC78999E653441187A81F9ADCD5A3C5F254BC8256B0158F54673DCC1232F6E918EBFC6C51CE67EAEB042D9F57EEC4BFE910E169AF78B3DE48D137DF4F2840\"),\n\t    SHEX(\"3E419569A4197BB71BAF416B38772EEDD9C1D5A3252111609F0FF8A18A749D5A56143A14925A82CD35C44400A49AFDFB\"));\n  test_hash(&nettle_sha3_384, /* 121 octets */\n\t    SHEX(\"626F68C18A69A6590159A9C46BE03D5965698F2DAC3DE779B878B3D9C421E0F21B955A16C715C1EC1E22CE3EB645B8B4F263F60660EA3028981EEBD6C8C3A367285B691C8EE56944A7CD1217997E1D9C21620B536BDBD5DE8925FF71DEC6FBC06624AB6B21E329813DE90D1E572DFB89A18120C3F606355D25\"),\n\t    SHEX(\"6215C070D0CB388A134766035C4BA95143E608D15CAF742796304FFA1A62E55660AB9AB1F6538B4AF1F3EA89BE7D51FF\"));\n  test_hash(&nettle_sha3_384, /* 122 octets */\n\t    SHEX(\"651A6FB3C4B80C7C68C6011675E6094EB56ABF5FC3057324EBC6477825061F9F27E7A94633ABD1FA598A746E4A577CAF524C52EC1788471F92B8C37F23795CA19D559D446CAB16CBCDCE90B79FA1026CEE77BF4AB1B503C5B94C2256AD75B3EAC6FD5DCB96ACA4B03A834BFB4E9AF988CECBF2AE597CB9097940\"),\n\t    SHEX(\"0E27ABAD85255A66217722B7D4E032BF29F638BAE965B99F8EAF309071FF8C107F5B6BBB6AB1985228E697DE60595DF6\"));\n  test_hash(&nettle_sha3_384, /* 123 octets */\n\t    SHEX(\"8AAF072FCE8A2D96BC10B3C91C809EE93072FB205CA7F10ABD82ECD82CF040B1BC49EA13D1857815C0E99781DE3ADBB5443CE1C897E55188CEAF221AA9681638DE05AE1B322938F46BCE51543B57ECDB4C266272259D1798DE13BE90E10EFEC2D07484D9B21A3870E2AA9E06C21AA2D0C9CF420080A80A91DEE16F\"),\n\t    SHEX(\"AB9FD51B3AA4CD944ABB6CDB063708B2D1203D65A1A2EBB48E0C19722A18B9EF54D7A11F7684462B995B6D38CDDC0463\"));\n  test_hash(&nettle_sha3_384, /* 124 octets */\n\t    SHEX(\"53F918FD00B1701BD504F8CDEA803ACCA21AC18C564AB90C2A17DA592C7D69688F6580575395551E8CD33E0FEF08CA6ED4588D4D140B3E44C032355DF1C531564D7F4835753344345A6781E11CD5E095B73DF5F82C8AE3AD00877936896671E947CC52E2B29DCD463D90A0C9929128DA222B5A211450BBC0E02448E2\"),\n\t    SHEX(\"03945325AC50E56BC8B515576529ABAA9A22BC2A7CED9142A75CE939A388AF0022A4E75A33964BBB3580564E0AF809D3\"));\n  test_hash(&nettle_sha3_384, /* 125 octets */\n\t    SHEX(\"A64599B8A61B5CCEC9E67AED69447459C8DA3D1EC6C7C7C82A7428B9B584FA67E90F68E2C00FBBED4613666E5168DA4A16F395F7A3C3832B3B134BFC9CBAA95D2A0FE252F44AC6681EB6D40AB91C1D0282FED6701C57463D3C5F2BB8C6A7301FB4576AA3B5F15510DB8956FF77478C26A7C09BEA7B398CFC83503F538E\"),\n\t    SHEX(\"59126910A3462E3B7AC22892F637D87D90686BC0A9BBD4A32E2C4C71A168BA685F2184560E125DB3DC23D90B9E820F1A\"));\n  test_hash(&nettle_sha3_384, /* 126 octets */\n\t    SHEX(\"0E3AB0E054739B00CDB6A87BD12CAE024B54CB5E550E6C425360C2E87E59401F5EC24EF0314855F0F56C47695D56A7FB1417693AF2A1ED5291F2FEE95F75EED54A1B1C2E81226FBFF6F63ADE584911C71967A8EB70933BC3F5D15BC91B5C2644D9516D3C3A8C154EE48E118BD1442C043C7A0DBA5AC5B1D5360AAE5B9065\"),\n\t    SHEX(\"D3239A33BAA55B0F21169E0FDE6114B08106BAF3F4BA0CA19D7B5CF44030057AC672CE529EB0F3BDA36819967819AAFA\"));\n  test_hash(&nettle_sha3_384, /* 127 octets */\n\t    SHEX(\"A62FC595B4096E6336E53FCDFC8D1CC175D71DAC9D750A6133D23199EAAC288207944CEA6B16D27631915B4619F743DA2E30A0C00BBDB1BBB35AB852EF3B9AEC6B0A8DCC6E9E1ABAA3AD62AC0A6C5DE765DE2C3711B769E3FDE44A74016FFF82AC46FA8F1797D3B2A726B696E3DEA5530439ACEE3A45C2A51BC32DD055650B\"),\n\t    SHEX(\"38A11581D874A574929C51F8DCC9E501900743864AEC3AC0889E62C1071CA5F8B6CCF9C0BDB3BB365916EB4340973DC7\"));\n  test_hash(&nettle_sha3_384, /* 128 octets */\n\t    SHEX(\"2B6DB7CED8665EBE9DEB080295218426BDAA7C6DA9ADD2088932CDFFBAA1C14129BCCDD70F369EFB149285858D2B1D155D14DE2FDB680A8B027284055182A0CAE275234CC9C92863C1B4AB66F304CF0621CD54565F5BFF461D3B461BD40DF28198E3732501B4860EADD503D26D6E69338F4E0456E9E9BAF3D827AE685FB1D817\"),\n\t    SHEX(\"8FD01909381EB713803419361D8E82E92476A08EDCC225BB8A135D215CB48D07B074624FCF2E73E666DBA59334719839\"));\n  test_hash(&nettle_sha3_384, /* 129 octets */\n\t    SHEX(\"10DB509B2CDCABA6C062AE33BE48116A29EB18E390E1BBADA5CA0A2718AFBCD23431440106594893043CC7F2625281BF7DE2655880966A23705F0C5155C2F5CCA9F2C2142E96D0A2E763B70686CD421B5DB812DACED0C6D65035FDE558E94F26B3E6DDE5BD13980CC80292B723013BD033284584BFF27657871B0CF07A849F4AE2\"),\n\t    SHEX(\"5D7DC5FC9DE88B1C0C46AA6D49273505FF7A76A179E31AB5D976A69D89B83DFA6DEAE9E1B93440EC055DE1CC824D6B15\"));\n  test_hash(&nettle_sha3_384, /* 130 octets */\n\t    SHEX(\"9334DE60C997BDA6086101A6314F64E4458F5FF9450C509DF006E8C547983C651CA97879175AABA0C539E82D05C1E02C480975CBB30118121061B1EBAC4F8D9A3781E2DB6B18042E01ECF9017A64A0E57447EC7FCBE6A7F82585F7403EE2223D52D37B4BF426428613D6B4257980972A0ACAB508A7620C1CB28EB4E9D30FC41361EC\"),\n\t    SHEX(\"3D6BBA145D7E69DBBB0F099D47A1F2138D4A00F26B07C62CF38471F0FB9CA022C61F7A769013A9BD8D5D87D8E01D9B4D\"));\n  test_hash(&nettle_sha3_384, /* 131 octets */\n\t    SHEX(\"E88AB086891693AA535CEB20E64C7AB97C7DD3548F3786339897A5F0C39031549CA870166E477743CCFBE016B4428D89738E426F5FFE81626137F17AECFF61B72DBEE2DC20961880CFE281DFAB5EE38B1921881450E16032DE5E4D55AD8D4FCA609721B0692BAC79BE5A06E177FE8C80C0C83519FB3347DE9F43D5561CB8107B9B5EDC\"),\n\t    SHEX(\"FBCEF80DD06E7E0B3B7A5485CA5BC2B388CB91A2890F181C857B3E0ABEFD6065499D82DD55F3FCD17E351C0A3636B859\"));\n  test_hash(&nettle_sha3_384, /* 132 octets */\n\t    SHEX(\"FD19E01A83EB6EC810B94582CB8FBFA2FCB992B53684FB748D2264F020D3B960CB1D6B8C348C2B54A9FCEA72330C2AAA9A24ECDB00C436ABC702361A82BB8828B85369B8C72ECE0082FE06557163899C2A0EFA466C33C04343A839417057399A63A3929BE1EE4805D6CE3E5D0D0967FE9004696A5663F4CAC9179006A2CEB75542D75D68\"),\n\t    SHEX(\"338AACBAC8AC5BCC13FAFC0EC6D2ECF4A871F9B09D7B1BC5BD6F8D7C9DD1354B8E28C68158A36551DDDAB8B684579EE1\"));\n  test_hash(&nettle_sha3_384, /* 133 octets */\n\t    SHEX(\"59AE20B6F7E0B3C7A989AFB28324A40FCA25D8651CF1F46AE383EF6D8441587AA1C04C3E3BF88E8131CE6145CFB8973D961E8432B202FA5AF3E09D625FAAD825BC19DA9B5C6C20D02ABDA2FCC58B5BD3FE507BF201263F30543819510C12BC23E2DDB4F711D087A86EDB1B355313363A2DE996B891025E147036087401CCF3CA7815BF3C49\"),\n\t    SHEX(\"FFC98D84C268BD09CAD09CD7B4BF9D35EDE97EC55885E839E557D21ECC0E28A855000386E68FAAE3E64A19B443B2587D\"));\n  test_hash(&nettle_sha3_384, /* 134 octets */\n\t    SHEX(\"77EE804B9F3295AB2362798B72B0A1B2D3291DCEB8139896355830F34B3B328561531F8079B79A6E9980705150866402FDC176C05897E359A6CB1A7AB067383EB497182A7E5AEF7038E4C96D133B2782917417E391535B5E1B51F47D8ED7E4D4025FE98DC87B9C1622614BFF3D1029E68E372DE719803857CA52067CDDAAD958951CB2068CC6\"),\n\t    SHEX(\"471465890C3B9C03EDFBF0F6883D565740BADA3B7628AD6A27F729C35C1A8666953E8B99D2C89EDE0BD2D5D70FDEF11B\"));\n  test_hash(&nettle_sha3_384, /* 135 octets */\n\t    SHEX(\"B771D5CEF5D1A41A93D15643D7181D2A2EF0A8E84D91812F20ED21F147BEF732BF3A60EF4067C3734B85BC8CD471780F10DC9E8291B58339A677B960218F71E793F2797AEA349406512829065D37BB55EA796FA4F56FD8896B49B2CD19B43215AD967C712B24E5032D065232E02C127409D2ED4146B9D75D763D52DB98D949D3B0FED6A8052FBB\"),\n\t    SHEX(\"0F8BA7214DE0E3A9E13C282BFA09CEA782C31C052F516D0AAA403D97716E0D08B1F7F9BB4085B555740C813C4ECE1B90\"));\n  test_hash(&nettle_sha3_384, /* 136 octets */\n\t    SHEX(\"B32D95B0B9AAD2A8816DE6D06D1F86008505BD8C14124F6E9A163B5A2ADE55F835D0EC3880EF50700D3B25E42CC0AF050CCD1BE5E555B23087E04D7BF9813622780C7313A1954F8740B6EE2D3F71F768DD417F520482BD3A08D4F222B4EE9DBD015447B33507DD50F3AB4247C5DE9A8ABD62A8DECEA01E3B87C8B927F5B08BEB37674C6F8E380C04\"),\n\t    SHEX(\"CAD2D28FBDCC3A5D71FB3ADCEEC52313AD41D4FF1F915CAA34EE127839DBF2E9A7B06E1C4ECD6255926C16C06E51EFD0\"));\n  test_hash(&nettle_sha3_384, /* 137 octets */\n\t    SHEX(\"04410E31082A47584B406F051398A6ABE74E4DA59BB6F85E6B49E8A1F7F2CA00DFBA5462C2CD2BFDE8B64FB21D70C083F11318B56A52D03B81CAC5EEC29EB31BD0078B6156786DA3D6D8C33098C5C47BB67AC64DB14165AF65B44544D806DDE5F487D5373C7F9792C299E9686B7E5821E7C8E2458315B996B5677D926DAC57B3F22DA873C601016A0D\"),\n\t    SHEX(\"5B192EBAB47215A8E9FB8E4D561B220B1DC36707A3F085F7BB0175335C393251E3467F945570420C743365D0F09B9E09\"));\n  test_hash(&nettle_sha3_384, /* 138 octets */\n\t    SHEX(\"8B81E9BADDE026F14D95C019977024C9E13DB7A5CD21F9E9FC491D716164BBACDC7060D882615D411438AEA056C340CDF977788F6E17D118DE55026855F93270472D1FD18B9E7E812BAE107E0DFDE7063301B71F6CFE4E225CAB3B232905A56E994F08EE2891BA922D49C3DAFEB75F7C69750CB67D822C96176C46BD8A29F1701373FB09A1A6E3C7158F\"),\n\t    SHEX(\"DF6F80B6D56CFFA8545A27A245A50E6C2D117FC3598F465B6CD78560F4B3C7D2123F28F67CA9E65BFE0B7F566C57B9EF\"));\n  test_hash(&nettle_sha3_384, /* 139 octets */\n\t    SHEX(\"FA6EED24DA6666A22208146B19A532C2EC9BA94F09F1DEF1E7FC13C399A48E41ACC2A589D099276296348F396253B57CB0E40291BD282773656B6E0D8BEA1CDA084A3738816A840485FCF3FB307F777FA5FEAC48695C2AF4769720258C77943FB4556C362D9CBA8BF103AEB9034BAA8EA8BFB9C4F8E6742CE0D52C49EA8E974F339612E830E9E7A9C29065\"),\n\t    SHEX(\"CE97E9DF08789D84151A95C8134F0DB74E5D4E076E0C15966825C371B79B3192FD7C9C6BDAE86B775804B5363D1152C7\"));\n  test_hash(&nettle_sha3_384, /* 140 octets */\n\t    SHEX(\"9BB4AF1B4F09C071CE3CAFA92E4EB73CE8A6F5D82A85733440368DEE4EB1CBC7B55AC150773B6FE47DBE036C45582ED67E23F4C74585DAB509DF1B83610564545642B2B1EC463E18048FC23477C6B2AA035594ECD33791AF6AF4CBC2A1166ABA8D628C57E707F0B0E8707CAF91CD44BDB915E0296E0190D56D33D8DDE10B5B60377838973C1D943C22ED335E\"),\n\t    SHEX(\"89BF889FBD7A384290D3B1D52709DBA686351E53937630B7C7F01BCDDA19B1517D317D65E799E686C71A0AB4D65B60B8\"));\n  test_hash(&nettle_sha3_384, /* 141 octets */\n\t    SHEX(\"2167F02118CC62043E9091A647CADBED95611A521FE0D64E8518F16C808AB297725598AE296880A773607A798F7C3CFCE80D251EBEC6885015F9ABF7EAABAE46798F82CB5926DE5C23F44A3F9F9534B3C6F405B5364C2F8A8BDC5CA49C749BED8CE4BA48897062AE8424CA6DDE5F55C0E42A95D1E292CA54FB46A84FBC9CD87F2D0C9E7448DE3043AE22FDD229\"),\n\t    SHEX(\"5D40E392C2E5B29C80C2D760A93AA1E193472D7EE59E203DD478FE24C5A6264E2873AF31ABDE81827862901AE59571BB\"));\n  test_hash(&nettle_sha3_384, /* 142 octets */\n\t    SHEX(\"94B7FA0BC1C44E949B1D7617D31B4720CBE7CA57C6FA4F4094D4761567E389ECC64F6968E4064DF70DF836A47D0C713336B5028B35930D29EB7A7F9A5AF9AD5CF441745BAEC9BB014CEEFF5A41BA5C1CE085FEB980BAB9CF79F2158E03EF7E63E29C38D7816A84D4F71E0F548B7FC316085AE38A060FF9B8DEC36F91AD9EBC0A5B6C338CBB8F6659D342A24368CF\"),\n\t    SHEX(\"7C63A0DC1C39CF4FAB2D22F62C1B00757AA4B89ED0D7128DA243D9082AD0C78784AC24DF34F5AB30375F1D581E7420BD\"));\n  test_hash(&nettle_sha3_384, /* 143 octets */\n\t    SHEX(\"EA40E83CB18B3A242C1ECC6CCD0B7853A439DAB2C569CFC6DC38A19F5C90ACBF76AEF9EA3742FF3B54EF7D36EB7CE4FF1C9AB3BC119CFF6BE93C03E208783335C0AB8137BE5B10CDC66FF3F89A1BDDC6A1EED74F504CBE7290690BB295A872B9E3FE2CEE9E6C67C41DB8EFD7D863CF10F840FE618E7936DA3DCA5CA6DF933F24F6954BA0801A1294CD8D7E66DFAFEC\"),\n\t    SHEX(\"ED085D830AFD2D8F79627281C2A8163C391FEC2C58268F66F74CFF9751BB29E0D071EA8FD2FCF943020D0AD758281BFD\"));\n  test_hash(&nettle_sha3_384, /* 144 octets */\n\t    SHEX(\"157D5B7E4507F66D9A267476D33831E7BB768D4D04CC3438DA12F9010263EA5FCAFBDE2579DB2F6B58F911D593D5F79FB05FE3596E3FA80FF2F761D1B0E57080055C118C53E53CDB63055261D7C9B2B39BD90ACC32520CBBDBDA2C4FD8856DBCEE173132A2679198DAF83007A9B5C51511AE49766C792A29520388444EBEFE28256FB33D4260439CBA73A9479EE00C63\"),\n\t    SHEX(\"29124752CCD4AC724A9C3D53B0B352AF2DBD76729F8C5C648B1E9D77819F32E2A7DE0E15286478A24DF9BB370F855C1C\"));\n  test_hash(&nettle_sha3_384, /* 145 octets */\n\t    SHEX(\"836B34B515476F613FE447A4E0C3F3B8F20910AC89A3977055C960D2D5D2B72BD8ACC715A9035321B86703A411DDE0466D58A59769672AA60AD587B8481DE4BBA552A1645779789501EC53D540B904821F32B0BD1855B04E4848F9F8CFE9EBD8911BE95781A759D7AD9724A7102DBE576776B7C632BC39B9B5E19057E226552A5994C1DBB3B5C7871A11F5537011044C53\"),\n\t    SHEX(\"FAEAB5687F39EC9894C5CCFFB57E82A84BBB7D493CC6AFC03D07AC7B4F181E61639B9A4771C99985ED7FA1773E1CA3F4\"));\n  test_hash(&nettle_sha3_384, /* 146 octets */\n\t    SHEX(\"CC7784A4912A7AB5AD3620AAB29BA87077CD3CB83636ADC9F3DC94F51EDF521B2161EF108F21A0A298557981C0E53CE6CED45BDF782C1EF200D29BAB81DD6460586964EDAB7CEBDBBEC75FD7925060F7DA2B853B2B089588FA0F8C16EC6498B14C55DCEE335CB3A91D698E4D393AB8E8EAC0825F8ADEBEEE196DF41205C011674E53426CAA453F8DE1CBB57932B0B741D4C6\"),\n\t    SHEX(\"E4E352B1D2D987A37C831629FE0C6AB9EAB2C35E401D1B5F443ADC54A96EF3C91D0876CCF46ADEF819C460369136DA87\"));\n  test_hash(&nettle_sha3_384, /* 147 octets */\n\t    SHEX(\"7639B461FFF270B2455AC1D1AFCE782944AEA5E9087EB4A39EB96BB5C3BAAF0E868C8526D3404F9405E79E77BFAC5FFB89BF1957B523E17D341D7323C302EA7083872DD5E8705694ACDDA36D5A1B895AAA16ECA6104C82688532C8BFE1790B5DC9F4EC5FE95BAED37E1D287BE710431F1E5E8EE105BC42ED37D74B1E55984BF1C09FE6A1FA13EF3B96FAEAED6A2A1950A12153\"),\n\t    SHEX(\"6C288FE4A74F0ED1B36D12F2DB697FBC44017BB57D38C9EBD45F5A8B4FEB59148060AE4BA1FFA162E10E6916CEA1A794\"));\n  test_hash(&nettle_sha3_384, /* 148 octets */\n\t    SHEX(\"EB6513FC61B30CFBA58D4D7E80F94D14589090CF1D80B1DF2E68088DC6104959BA0D583D585E9578AB0AEC0CF36C48435EB52ED9AB4BBCE7A5ABE679C97AE2DBE35E8CC1D45B06DDA3CF418665C57CBEE4BBB47FA4CAF78F4EE656FEC237FE4EEBBAFA206E1EF2BD0EE4AE71BD0E9B2F54F91DAADF1FEBFD7032381D636B733DCB3BF76FB14E23AFF1F68ED3DBCF75C9B99C6F26\"),\n\t    SHEX(\"E1B6DAC3F138B5F336F1F75894F825FFC197836C92BF359B55BB2A78239F24F9C4AA1E063C9C2B273B9CFA766FBFBAE5\"));\n  test_hash(&nettle_sha3_384, /* 149 octets */\n\t    SHEX(\"1594D74BF5DDE444265D4C04DAD9721FF3E34CBF622DAF341FE16B96431F6C4DF1F760D34F296EB97D98D560AD5286FEC4DCE1724F20B54FD7DF51D4BF137ADD656C80546FB1BF516D62EE82BAA992910EF4CC18B70F3F8698276FCFB44E0EC546C2C39CFD8EE91034FF9303058B4252462F86C823EB15BF481E6B79CC3A02218595B3658E8B37382BD5048EAED5FD02C37944E73B\"),\n\t    SHEX(\"6E07B59E93B22475633B5BA1AA6891119CFF690697AC679E9349E8694C654074D965F0C32FF517B10EE8F6993F6E4646\"));\n  test_hash(&nettle_sha3_384, /* 150 octets */\n\t    SHEX(\"4CFA1278903026F66FEDD41374558BE1B585D03C5C55DAC94361DF286D4BD39C7CB8037ED3B267B07C346626449D0CC5B0DD2CF221F7E4C3449A4BE99985D2D5E67BFF2923357DDEAB5ABCB4619F3A3A57B2CF928A022EB27676C6CF805689004FCA4D41EA6C2D0A4789C7605F7BB838DD883B3AD3E6027E775BCF262881428099C7FFF95B14C095EA130E0B9938A5E22FC52650F591\"),\n\t    SHEX(\"19EB2E15262A839538846F7252676971207913279B9AE9B6BA3650D8F3A8E558B13C35B31F1AB7429E376255338C4AA2\"));\n  test_hash(&nettle_sha3_384, /* 151 octets */\n\t    SHEX(\"D3E65CB92CFA79662F6AF493D696A07CCF32AAADCCEFF06E73E8D9F6F909209E66715D6E978788C49EFB9087B170ECF3AA86D2D4D1A065AE0EFC8924F365D676B3CB9E2BEC918FD96D0B43DEE83727C9A93BF56CA2B2E59ADBA85696546A815067FC7A78039629D4948D157E7B0D826D1BF8E81237BAB7321312FDAA4D521744F988DB6FDF04549D0FDCA393D639C729AF716E9C8BBA48\"),\n\t    SHEX(\"F4DA80B26FB5E6F7E5DFE47128EEE095D46D9ACEFBE76F74EFBC8A1AD68E8456634E9376025648EF7A3350299F366E29\"));\n  test_hash(&nettle_sha3_384, /* 152 octets */\n\t    SHEX(\"842CC583504539622D7F71E7E31863A2B885C56A0BA62DB4C2A3F2FD12E79660DC7205CA29A0DC0A87DB4DC62EE47A41DB36B9DDB3293B9AC4BAAE7DF5C6E7201E17F717AB56E12CAD476BE49608AD2D50309E7D48D2D8DE4FA58AC3CFEAFEEE48C0A9EEC88498E3EFC51F54D300D828DDDCCB9D0B06DD021A29CF5CB5B2506915BEB8A11998B8B886E0F9B7A80E97D91A7D01270F9A7717\"),\n\t    SHEX(\"BDBA7838A1E7A601D559F49EC1323B7C5FABE1E109FDCAFF3F7865F9AF4196ABBF60AC123097A7B860FE438684355EB0\"));\n  test_hash(&nettle_sha3_384, /* 153 octets */\n\t    SHEX(\"6C4B0A0719573E57248661E98FEBE326571F9A1CA813D3638531AE28B4860F23C3A3A8AC1C250034A660E2D71E16D3ACC4BF9CE215C6F15B1C0FC7E77D3D27157E66DA9CEEC9258F8F2BF9E02B4AC93793DD6E29E307EDE3695A0DF63CBDC0FC66FB770813EB149CA2A916911BEE4902C47C7802E69E405FE3C04CEB5522792A5503FA829F707272226621F7C488A7698C0D69AA561BE9F378\"),\n\t    SHEX(\"96DFE9996BFFA5E5D83C39B11F47F12D11210F7D4300B7180D1891EAAA7FE4809F9489B1E2407FF87FB2628DDF1FC020\"));\n  test_hash(&nettle_sha3_384, /* 154 octets */\n\t    SHEX(\"51B7DBB7CE2FFEB427A91CCFE5218FD40F9E0B7E24756D4C47CD55606008BDC27D16400933906FD9F30EFFDD4880022D081155342AF3FB6CD53672AB7FB5B3A3BCBE47BE1FD3A2278CAE8A5FD61C1433F7D350675DD21803746CADCA574130F01200024C6340AB0CC2CF74F2234669F34E9009EF2EB94823D62B31407F4BA46F1A1EEC41641E84D77727B59E746B8A671BEF936F05BE820759FA\"),\n\t    SHEX(\"79CF2A3017F82693C0A531A367186D055FCE63081EDF980C6A0B967B6ECCE75D635B98485E9B6B285B08336FF34E61C9\"));\n  test_hash(&nettle_sha3_384, /* 155 octets */\n\t    SHEX(\"83599D93F5561E821BD01A472386BC2FF4EFBD4AED60D5821E84AAE74D8071029810F5E286F8F17651CD27DA07B1EB4382F754CD1C95268783AD09220F5502840370D494BEB17124220F6AFCE91EC8A0F55231F9652433E5CE3489B727716CF4AEBA7DCDA20CD29AA9A859201253F948DD94395ABA9E3852BD1D60DDA7AE5DC045B283DA006E1CBAD83CC13292A315DB5553305C628DD091146597\"),\n\t    SHEX(\"0ED3CA1620CE3A923A22E9D13BBF7543ACEE05F66B67E6D6F435BC513F4698949C27528068F892F0871916FE2D0433C3\"));\n  test_hash(&nettle_sha3_384, /* 156 octets */\n\t    SHEX(\"2BE9BF526C9D5A75D565DD11EF63B979D068659C7F026C08BEA4AF161D85A462D80E45040E91F4165C074C43AC661380311A8CBED59CC8E4C4518E80CD2C78AB1CABF66BFF83EAB3A80148550307310950D034A6286C93A1ECE8929E6385C5E3BB6EA8A7C0FB6D6332E320E71CC4EB462A2A62E2BFE08F0CCAD93E61BEDB5DD0B786A728AB666F07E0576D189C92BF9FB20DCA49AC2D3956D47385E2\"),\n\t    SHEX(\"69A27BBF080E015592893D3B55D1957D267784569923A466165A6FB129613D8EA6F610F3760E349D46B09277CB854546\"));\n  test_hash(&nettle_sha3_384, /* 157 octets */\n\t    SHEX(\"CA76D3A12595A817682617006848675547D3E8F50C2210F9AF906C0E7CE50B4460186FE70457A9E879E79FD4D1A688C70A347361C847BA0DD6AA52936EAF8E58A1BE2F5C1C704E20146D366AEB3853BED9DE9BEFE9569AC8AAEA37A9FB7139A1A1A7D5C748605A8DEFB297869EBEDD71D615A5DA23496D11E11ABBB126B206FA0A7797EE7DE117986012D0362DCEF775C2FE145ADA6BDA1CCB326BF644\"),\n\t    SHEX(\"E9C8830140629669A1DC5C8EE27BE669B7122F4DC88224635CDE334AD99615F3FDC4869E56263E3C7F4420736F714E26\"));\n  test_hash(&nettle_sha3_384, /* 158 octets */\n\t    SHEX(\"F76B85DC67421025D64E93096D1D712B7BAF7FB001716F02D33B2160C2C882C310EF13A576B1C2D30EF8F78EF8D2F465007109AAD93F74CB9E7D7BEF7C9590E8AF3B267C89C15DB238138C45833C98CC4A471A7802723EF4C744A853CF80A0C2568DD4ED58A2C9644806F42104CEE53628E5BDF7B63B0B338E931E31B87C24B146C6D040605567CEEF5960DF9E022CB469D4C787F4CBA3C544A1AC91F95F\"),\n\t    SHEX(\"4DF060276105BF002F8E9F3F08D5B51F7C2ADFE5AAB9A1A683C053E045C89A883028B1093461368262EA85F5239AC7B1\"));\n  test_hash(&nettle_sha3_384, /* 159 octets */\n\t    SHEX(\"25B8C9C032EA6BCD733FFC8718FBB2A503A4EA8F71DEA1176189F694304F0FF68E862A8197B839957549EF243A5279FC2646BD4C009B6D1EDEBF24738197ABB4C992F6B1DC9BA891F570879ACCD5A6B18691A93C7D0A8D38F95B639C1DAEB48C4C2F15CCF5B9D508F8333C32DE78781B41850F261B855C4BEBCC125A380C54D501C5D3BD07E6B52102116088E53D76583B0161E2A58D0778F091206AABD5A1\"),\n\t    SHEX(\"816AA6DB9B663288E5F932F0FEAFF0EE7875C3B3E6FBAC0CDDC458BD646371969CF50D2D0942FCC7403573B01B05B455\"));\n  test_hash(&nettle_sha3_384, /* 160 octets */\n\t    SHEX(\"21CFDC2A7CCB7F331B3D2EEFFF37E48AD9FA9C788C3F3C200E0173D99963E1CBCA93623B264E920394AE48BB4C3A5BB96FFBC8F0E53F30E22956ADABC2765F57FB761E147ECBF8567533DB6E50C8A1F894310A94EDF806DD8CA6A0E141C0FA7C9FAE6C6AE65F18C93A8529E6E5B553BF55F25BE2E80A9882BD37F145FECBEB3D447A3C4E46C21524CC55CDD62F521AB92A8BA72B897996C49BB273198B7B1C9E\"),\n\t    SHEX(\"125B51C253391677C59C0332C6A13D07DE55EAB80857593F0839A56FA678C5E2F7CB2F934ABE5E5887804AAB5D8F13E1\"));\n  test_hash(&nettle_sha3_384, /* 161 octets */\n\t    SHEX(\"4E452BA42127DCC956EF4F8F35DD68CB225FB73B5BC7E1EC5A898BBA2931563E74FAFF3B67314F241EC49F4A7061E3BD0213AE826BAB380F1F14FAAB8B0EFDDD5FD1BB49373853A08F30553D5A55CCBBB8153DE4704F29CA2BDEEF0419468E05DD51557CCC80C0A96190BBCC4D77ECFF21C66BDF486459D427F986410F883A80A5BCC32C20F0478BB9A97A126FC5F95451E40F292A4614930D054C851ACD019CCF\"),\n\t    SHEX(\"130C4B06A55F11C80C41608ADFD7B4CE8795871BCF16900F20D2751E123B41D3B2048FD05267C2F9653ECE3630BDD330\"));\n  test_hash(&nettle_sha3_384, /* 162 octets */\n\t    SHEX(\"FA85671DF7DADF99A6FFEE97A3AB9991671F5629195049880497487867A6C446B60087FAC9A0F2FCC8E3B24E97E42345B93B5F7D3691829D3F8CCD4BB36411B85FC2328EB0C51CB3151F70860AD3246CE0623A8DC8B3C49F958F8690F8E3860E71EB2B1479A5CEA0B3F8BEFD87ACAF5362435EAECCB52F38617BC6C5C2C6E269EAD1FBD69E941D4AD2012DA2C5B21BCFBF98E4A77AB2AF1F3FDA3233F046D38F1DC8\"),\n\t    SHEX(\"3EA0FA3FC035EA40CBBE9A3C1C6F7E5A437BA20F26736F2895F81D53BEC92A186E74762910C4AA62565373D38B28D5FD\"));\n  test_hash(&nettle_sha3_384, /* 163 octets */\n\t    SHEX(\"E90847AE6797FBC0B6B36D6E588C0A743D725788CA50B6D792352EA8294F5BA654A15366B8E1B288D84F5178240827975A763BC45C7B0430E8A559DF4488505E009C63DA994F1403F407958203CEBB6E37D89C94A5EACF6039A327F6C4DBBC7A2A307D976AA39E41AF6537243FC218DFA6AB4DD817B6A397DF5CA69107A9198799ED248641B63B42CB4C29BFDD7975AC96EDFC274AC562D0474C60347A078CE4C25E88\"),\n\t    SHEX(\"7C1F1A46E409046B5A314767E8B7E7B1D9A92931443C5D02A581371B380AFA1867E554C3F7DF2E4557ACFD9F8E230C44\"));\n  test_hash(&nettle_sha3_384, /* 164 octets */\n\t    SHEX(\"F6D5C2B6C93954FC627602C00C4CA9A7D3ED12B27173F0B2C9B0E4A5939398A665E67E69D0B12FB7E4CEB253E8083D1CEB724AC07F009F094E42F2D6F2129489E846EAFF0700A8D4453EF453A3EDDC18F408C77A83275617FABC4EA3A2833AA73406C0E966276079D38E8E38539A70E194CC5513AAA457C699383FD1900B1E72BDFB835D1FD321B37BA80549B078A49EA08152869A918CA57F5B54ED71E4FD3AC5C06729\"),\n\t    SHEX(\"2AD23817002C8F0089D423760F5569EB67CBEED2F0F2AA12F8EDE7856EE22AA6EB684F86AE91741A4AA3C80AC97C4A0B\"));\n  test_hash(&nettle_sha3_384, /* 165 octets */\n\t    SHEX(\"CF8562B1BED89892D67DDAAF3DEEB28246456E972326DBCDB5CF3FB289ACA01E68DA5D59896E3A6165358B071B304D6AB3D018944BE5049D5E0E2BB819ACF67A6006111089E6767132D72DD85BEDDCBB2D64496DB0CC92955AB4C6234F1EEA24F2D51483F2E209E4589BF9519FAC51B4D061E801125E605F8093BB6997BC163D551596FE4AB7CFAE8FB9A90F6980480CE0C229FD1675409BD788354DAF316240CFE0AF93EB\"),\n\t    SHEX(\"D34974759C6A4AA9D1A4ED3DE341A2BA022DF127BE92EB0BBC1900EB5AC7B8AFE909B52DA5714668C3C4B7DB939F2436\"));\n  test_hash(&nettle_sha3_384, /* 166 octets */\n\t    SHEX(\"2ACE31ABB0A2E3267944D2F75E1559985DB7354C6E605F18DC8470423FCA30B7331D9B33C4A4326783D1CAAE1B4F07060EFF978E4746BF0C7E30CD61040BD5EC2746B29863EB7F103EBDA614C4291A805B6A4C8214230564A0557BC7102E0BD3ED23719252F7435D64D210EE2AAFC585BE903FA41E1968C50FD5D5367926DF7A05E3A42CF07E656FF92DE73B036CF8B19898C0CB34557C0C12C2D8B84E91181AF467BC75A9D1\"),\n\t    SHEX(\"0FB38AE233520D4F57469463E1E68D5518EA4E965755C03AD458DD285AFB2DF518C3D389BD361CBDCE46B654631A18C2\"));\n  test_hash(&nettle_sha3_384, /* 167 octets */\n\t    SHEX(\"0D8D09AED19F1013969CE5E7EB92F83A209AE76BE31C754844EA9116CEB39A22EBB6003017BBCF26555FA6624185187DB8F0CB3564B8B1C06BF685D47F3286EDA20B83358F599D2044BBF0583FAB8D78F854FE0A596183230C5EF8E54426750EAF2CC4E29D3BDD037E734D863C2BD9789B4C243096138F7672C232314EFFDFC6513427E2DA76916B5248933BE312EB5DDE4CF70804FB258AC5FB82D58D08177AC6F4756017FFF5\"),\n\t    SHEX(\"CB8F1CC9EB72465176B97B6226A87E69D77C65190114CCE1F830A3DFEFA5A8A278D5CF594B173AC58C06EC74958FF8C6\"));\n  test_hash(&nettle_sha3_384, /* 168 octets */\n\t    SHEX(\"C3236B73DEB7662BF3F3DAA58F137B358BA610560EF7455785A9BEFDB035A066E90704F929BD9689CEF0CE3BDA5ACF4480BCEB8D09D10B098AD8500D9B6071DFC3A14AF6C77511D81E3AA8844986C3BEA6F469F9E02194C92868CD5F51646256798FF0424954C1434BDFED9FACB390B07D342E992936E0F88BFD0E884A0DDB679D0547CCDEC6384285A45429D115AC7D235A717242021D1DC35641F5F0A48E8445DBA58E6CB2C8EA\"),\n\t    SHEX(\"87776D7022DC18592B578C534E2FCF57946E0F74C47DF85612F89C6593FD50A9E445C048D6CDA9A1D1D10EA3B3C973D0\"));\n  test_hash(&nettle_sha3_384, /* 169 octets */\n\t    SHEX(\"B39FEB8283EADC63E8184B51DF5AE3FD41AAC8A963BB0BE1CD08AA5867D8D910C669221E73243360646F6553D1CA05A84E8DC0DE05B6419EC349CA994480193D01C92525F3FB3DCEFB08AFC6D26947BDBBFD85193F53B50609C6140905C53A6686B58E53A319A57B962331EDE98149AF3DE3118A819DA4D76706A0424B4E1D2910B0ED26AF61D150EBCB46595D4266A0BD7F651BA47D0C7F179CA28545007D92E8419D48FDFBD744CE\"),\n\t    SHEX(\"83F4442147FEFC8E5BAD3E9EE4C6661A771AE8C87458AB67153DECD35DAF6756EEF28E4AE72E65EBFAE08886A6E773E0\"));\n  test_hash(&nettle_sha3_384, /* 170 octets */\n\t    SHEX(\"A983D54F503803E8C7999F4EDBBE82E9084F422143A932DDDDC47A17B0B7564A7F37A99D0786E99476428D29E29D3C197A72BFAB1342C12A0FC4787FD7017D7A6174049EA43B5779169EF7472BDBBD941DCB82FC73AAC45A8A94C9F2BD3477F61FD3B796F02A1B8264A214C6FEA74B7051B226C722099EC7883A462B83B6AFDD4009248B8A237F605FE5A08FE7D8B45321421EBBA67BD70A0B00DDBF94BAAB7F359D5D1EEA105F28DCFB\"),\n\t    SHEX(\"51358159074D960C0B9D73D5F12AFDAFB8F5D7905BDA62379A6E0D6727D03EFD26EEA51B434368E2E566CB4747D0BA35\"));\n  test_hash(&nettle_sha3_384, /* 171 octets */\n\t    SHEX(\"E4D1C1897A0A866CE564635B74222F9696BF2C7F640DD78D7E2ACA66E1B61C642BB03EA7536AAE597811E9BF4A7B453EDE31F97B46A5F0EF51A071A2B3918DF16B152519AE3776F9F1EDAB4C2A377C3292E96408359D3613844D5EB393000283D5AD3401A318B12FD1474B8612F2BB50FB6A8B9E023A54D7DDE28C43D6D8854C8D9D1155935C199811DBFC87E9E0072E90EB88681CC7529714F8FB8A2C9D88567ADFB974EE205A9BF7B848\"),\n\t    SHEX(\"3ECEA8CAF0D8EFA42D54AC5EF36E624237D9F5508ED6FCB6434D67F3FB788C538C635798F52B2F073A4A7376FD31C4A3\"));\n  test_hash(&nettle_sha3_384, /* 172 octets */\n\t    SHEX(\"B10C59723E3DCADD6D75DF87D0A1580E73133A9B7D00CB95EC19F5547027323BE75158B11F80B6E142C6A78531886D9047B08E551E75E6261E79785366D7024BD7CD9CF322D9BE7D57FB661069F2481C7BB759CD71B4B36CA2BC2DF6D3A328FAEBDB995A9794A8D72155ED551A1F87C80BF6059B43FC764900B18A1C2441F7487743CF84E565F61F8DD2ECE6B6CCC9444049197AAAF53E926FBEE3BFCA8BE588EC77F29D211BE89DE18B15F6\"),\n\t    SHEX(\"A8876FE4652ACF72DCC8FD5133E5D4CA4E3766AB987CF66EAE5E3770E252D2FD2A890525016623EE69064690828C727B\"));\n  test_hash(&nettle_sha3_384, /* 173 octets */\n\t    SHEX(\"DB11F609BABA7B0CA634926B1DD539C8CBADA24967D7ADD4D9876F77C2D80C0F4DCEFBD7121548373582705CCA2495BD2A43716FE64ED26D059CFB566B3364BD49EE0717BDD9810DD14D8FAD80DBBDC4CAFB37CC60FB0FE2A80FB4541B8CA9D59DCE457738A9D3D8F641AF8C3FD6DA162DC16FC01AAC527A4A0255B4D231C0BE50F44F0DB0B713AF03D968FE7F0F61ED0824C55C4B5265548FEBD6AAD5C5EEDF63EFE793489C39B8FD29D104CE\"),\n\t    SHEX(\"6A09735736780F199D75C60903AA24D7F8AA17516690854F7522EF0BBF47D41CBDC8BDB2CB2F3C5596510539677607E9\"));\n  test_hash(&nettle_sha3_384, /* 174 octets */\n\t    SHEX(\"BEBD4F1A84FC8B15E4452A54BD02D69E304B7F32616AADD90537937106AE4E28DE9D8AAB02D19BC3E2FDE1D651559E296453E4DBA94370A14DBBB2D1D4E2022302EE90E208321EFCD8528AD89E46DC839EA9DF618EA8394A6BFF308E7726BAE0C19BCD4BE52DA6258E2EF4E96AA21244429F49EF5CB486D7FF35CAC1BACB7E95711944BCCB2AB34700D42D1EB38B5D536B947348A458EDE3DC6BD6EC547B1B0CAE5B257BE36A7124E1060C170FFA\"),\n\t    SHEX(\"83FC2B91AB81D4B15363F15E53BF639063BAC55502B4421CF9A53BCAB9FF47FD77DE5AC6934F67A412EA1910FAD67768\"));\n  test_hash(&nettle_sha3_384, /* 175 octets */\n\t    SHEX(\"5ACA56A03A13784BDC3289D9364F79E2A85C12276B49B92DB0ADAA4F206D5028F213F678C3510E111F9DC4C1C1F8B6ACB17A6413AA227607C515C62A733817BA5E762CC6748E7E0D6872C984D723C9BB3B117EB8963185300A80BFA65CDE495D70A46C44858605FCCBED086C2B45CEF963D33294DBE9706B13AF22F1B7C4CD5A001CFEC251FBA18E722C6E1C4B1166918B4F6F48A98B64B3C07FC86A6B17A6D0480AB79D4E6415B520F1C484D675B1\"),\n\t    SHEX(\"77C0480B91F32EF809D8C23AB236581F0BCA8B9447A4D36228052B3ABB6AB69C61D19D720486A3FF497A4673B84CB951\"));\n  test_hash(&nettle_sha3_384, /* 176 octets */\n\t    SHEX(\"A5AAD0E4646A32C85CFCAC73F02FC5300F1982FABB2F2179E28303E447854094CDFC854310E5C0F60993CEFF54D84D6B46323D930ADB07C17599B35B505F09E784BCA5985E0172257797FB53649E2E9723EFD16865C31B5C3D5113B58BB0BFC8920FABDDA086D7537E66D709D050BD14D0C960873F156FAD5B3D3840CDFCDC9BE6AF519DB262A27F40896AB25CC39F96984D650611C0D5A3080D5B3A1BF186ABD42956588B3B58CD948970D298776060\"),\n\t    SHEX(\"781466E257D2FA594E39DC220A260C7478D2158BB70E426F9E9587F5A51A7C29FDC7AF23E7AB9C774E33C08AB38CEDB7\"));\n  test_hash(&nettle_sha3_384, /* 177 octets */\n\t    SHEX(\"06CBBE67E94A978203EAD6C057A1A5B098478B4B4CBEF5A97E93C8E42F5572713575FC2A884531D7622F8F879387A859A80F10EF02708CD8F7413AB385AFC357678B9578C0EBF641EF076A1A30F1F75379E9DCB2A885BDD295905EE80C0168A62A9597D10CF12DD2D8CEE46645C7E5A141F6E0E23AA482ABE5661C16E69EF1E28371E2E236C359BA4E92C25626A7B7FF13F6EA4AE906E1CFE163E91719B1F750A96CBDE5FBC953D9E576CD216AFC90323A\"),\n\t    SHEX(\"51BEBFB5AAFE777F390E2851B7EB9AA3809194FE3BA1689ABEE7E43D44A5874E0C252793DFD42C1270C63C407AEF6780\"));\n  test_hash(&nettle_sha3_384, /* 178 octets */\n\t    SHEX(\"F1C528CF7739874707D4D8AD5B98F7C77169DE0B57188DF233B2DC8A5B31EDA5DB4291DD9F68E6BAD37B8D7F6C9C0044B3BF74BBC3D7D1798E138709B0D75E7C593D3CCCDC1B20C7174B4E692ADD820ACE262D45CCFAE2077E878796347168060A162ECCA8C38C1A88350BD63BB539134F700FD4ADDD5959E255337DAA06BC86358FABCBEFDFB5BC889783D843C08AADC6C4F6C36F65F156E851C9A0F917E4A367B5AD93D874812A1DE6A7B93CD53AD97232\"),\n\t    SHEX(\"FCDF0032F34BA6C42D679B182D07B10F4DFF2189B0A5EF6642FBB71B16F910E3240ED9B502B1C6B395BEE74AD0FB4191\"));\n  test_hash(&nettle_sha3_384, /* 179 octets */\n\t    SHEX(\"9D9F3A7ECD51B41F6572FD0D0881E30390DFB780991DAE7DB3B47619134718E6F987810E542619DFAA7B505C76B7350C6432D8BF1CFEBDF1069B90A35F0D04CBDF130B0DFC7875F4A4E62CDB8E525AADD7CE842520A482AC18F09442D78305FE85A74E39E760A4837482ED2F437DD13B2EC1042AFCF9DECDC3E877E50FF4106AD10A525230D11920324A81094DA31DEAB6476AA42F20C84843CFC1C58545EE80352BDD3740DD6A16792AE2D86F11641BB717C2\"),\n\t    SHEX(\"92AADC02BB9795A48B031034EE6AB873DF481D232932FB5FD6C3762E50E58DA46D1F5E5E874597F15C83127F0A3042B1\"));\n  test_hash(&nettle_sha3_384, /* 180 octets */\n\t    SHEX(\"5179888724819FBAD3AFA927D3577796660E6A81C52D98E9303261D5A4A83232F6F758934D50AA83FF9E20A5926DFEBAAC49529D006EB923C5AE5048ED544EC471ED7191EDF46363383824F915769B3E688094C682B02151E5EE01E510B431C8865AFF8B6B6F2F59CB6D129DA79E97C6D2B8FA6C6DA3F603199D2D1BCAB547682A81CD6CF65F6551121391D78BCC23B5BD0E922EC6D8BF97C952E84DD28AEF909ABA31EDB903B28FBFC33B7703CD996215A11238\"),\n\t    SHEX(\"0D0CCDBFEB0A933F211EAA94EB452900324340505CCF8DB7AD93E976271F812FB8907805F6313D0B0931F5C9203BDBA5\"));\n  test_hash(&nettle_sha3_384, /* 181 octets */\n\t    SHEX(\"576EF3520D30B7A4899B8C0D5E359E45C5189ADD100E43BE429A02FB3DE5FF4F8FD0E79D9663ACCA72CD29C94582B19292A557C5B1315297D168FBB54E9E2ECD13809C2B5FCE998EDC6570545E1499DBE7FB74D47CD7F35823B212B05BF3F5A79CAA34224FDD670D335FCB106F5D92C3946F44D3AFCBAE2E41AC554D8E6759F332B76BE89A0324AA12C5482D1EA3EE89DED4936F3E3C080436F539FA137E74C6D3389BDF5A45074C47BC7B20B0948407A66D855E2F\"),\n\t    SHEX(\"FEF6B1F27B0CEBC4568588E627D28DD569A58A8F9A51A1D2887B40F5547B2C67C71917BE998D1987AC78E9077CC790AB\"));\n  test_hash(&nettle_sha3_384, /* 182 octets */\n\t    SHEX(\"0DF2152FA4F4357C8741529DD77E783925D3D76E95BAFA2B542A2C33F3D1D117D159CF473F82310356FEE4C90A9E505E70F8F24859656368BA09381FA245EB6C3D763F3093F0C89B972E66B53D59406D9F01AEA07F8B3B615CAC4EE4D05F542E7D0DAB45D67CCCCD3A606CCBEB31EA1FA7005BA07176E60DAB7D78F6810EF086F42F08E595F0EC217372B98970CC6321576D92CE38F7C397A403BADA1548D205C343AC09DECA86325373C3B76D9F32028FEA8EB32515\"),\n\t    SHEX(\"E9957732E7DAB64550F003EE6D0353AE89BDC6D69D05766024CFF189E4FC8FAA41DB72954E8E5AC0B29265C8F785E737\"));\n  test_hash(&nettle_sha3_384, /* 183 octets */\n\t    SHEX(\"3E15350D87D6EBB5C8AD99D42515CFE17980933C7A8F6B8BBBF0A63728CEFAAD2052623C0BD5931839112A48633FB3C2004E0749C87A41B26A8B48945539D1FF41A4B269462FD199BFECD45374756F55A9116E92093AC99451AEFB2AF9FD32D6D7F5FBC7F7A540D5097C096EBC3B3A721541DE073A1CC02F7FB0FB1B9327FB0B1218CA49C9487AB5396622A13AE546C97ABDEF6B56380DDA7012A8384091B6656D0AB272D363CEA78163FF765CDD13AB1738B940D16CAE\"),\n\t    SHEX(\"98D73B3555F003058F7B5A145D89FAEC46C17099A354EF3834A20142DBD50A0E8054598CE7941BF5DD4DF7CCF218F02F\"));\n  test_hash(&nettle_sha3_384, /* 184 octets */\n\t    SHEX(\"C38D6B0B757CB552BE40940ECE0009EF3B0B59307C1451686F1A22702922800D58BCE7A636C1727EE547C01B214779E898FC0E560F8AE7F61BEF4D75EAA696B921FD6B735D171535E9EDD267C192B99880C87997711002009095D8A7A437E258104A41A505E5EF71E5613DDD2008195F0C574E6BA3FE40099CFA116E5F1A2FA8A6DA04BADCB4E2D5D0DE31FDC4800891C45781A0AAC7C907B56D631FCA5CE8B2CDE620D11D1777ED9FA603541DE794DDC5758FCD5FAD78C0\"),\n\t    SHEX(\"3795DE490F43B9899947C1C305C30E26331BA0E611DCE7961172B2E4299932147BC9E241C32E61FA964D4F436ECCFD37\"));\n  test_hash(&nettle_sha3_384, /* 185 octets */\n\t    SHEX(\"8D2DE3F0B37A6385C90739805B170057F091CD0C7A0BC951540F26A5A75B3E694631BB64C7635EED316F51318E9D8DE13C70A2ABA04A14836855F35E480528B776D0A1E8A23B547C8B8D6A0D09B241D3BE9377160CCA4E6793D00A515DC2992CB7FC741DACA171431DA99CCE6F7789F129E2AC5CF65B40D703035CD2185BB936C82002DAF8CBC27A7A9E554B06196630446A6F0A14BA155ED26D95BD627B7205C072D02B60DB0FD7E49EA058C2E0BA202DAFF0DE91E845CF79\"),\n\t    SHEX(\"E9F289E671541FEC4599915A0D9935BF5C20A12C203BCDE88A46EAF5CAB2D437F9FCDEF67B98768BB80C9A874B3F46C7\"));\n  test_hash(&nettle_sha3_384, /* 186 octets */\n\t    SHEX(\"C464BBDAD275C50DCD983B65AD1019B9FF85A1E71C807F3204BB2C921DC31FBCD8C5FC45868AE9EF85B6C9B83BBA2A5A822201ED68586EC5EC27FB2857A5D1A2D09D09115F22DCC39FE61F5E1BA0FF6E8B4ACB4C6DA748BE7F3F0839739394FF7FA8E39F7F7E84A33C3866875C01BCB1263C9405D91908E9E0B50E7459FABB63D8C6BBB73D8E3483C099B55BC30FF092FF68B6ADEDFD477D63570C9F5515847F36E24BA0B705557130CEC57EBAD1D0B31A378E91894EE26E3A04\"),\n\t    SHEX(\"88C23BE040BE64D23AEE8D7EE962228A6F07831B0E05FBE2F25F07729F00C2C617EB6975F57B3F17DD540E8EBCA654A9\"));\n  test_hash(&nettle_sha3_384, /* 187 octets */\n\t    SHEX(\"8B8D68BB8A75732FE272815A68A1C9C5AA31B41DEDC8493E76525D1D013D33CEBD9E21A5BB95DB2616976A8C07FCF411F5F6BC6F7E0B57ACA78CC2790A6F9B898858AC9C79B165FF24E66677531E39F572BE5D81EB3264524181115F32780257BFB9AEEC6AF12AF28E587CAC068A1A2953B59AD680F4C245B2E3EC36F59940D37E1D3DB38E13EDB29B5C0F404F6FF87F80FC8BE7A225FF22FBB9C8B6B1D7330C57840D24BC75B06B80D30DAD6806544D510AF6C4785E823AC3E0B8\"),\n\t    SHEX(\"6C42DEE61CD97C50F5340CF4DC4F7E319FB5FAC7A26B41DEE66D789804BD1FEF1EF2911643C9C1E2C0485C979B36D927\"));\n  test_hash(&nettle_sha3_384, /* 188 octets */\n\t    SHEX(\"6B018710446F368E7421F1BC0CCF562D9C1843846BC8D98D1C9BF7D9D6FCB48BFC3BF83B36D44C4FA93430AF75CD190BDE36A7F92F867F58A803900DF8018150384D85D82132F123006AC2AEBA58E02A037FE6AFBD65ECA7C44977DD3DC74F48B6E7A1BFD5CC4DCF24E4D52E92BD4455848E4928B0EAC8B7476FE3CC03E862AA4DFF4470DBFED6DE48E410F25096487ECFC32A27277F3F5023B2725ADE461B1355889554A8836C9CF53BD767F5737D55184EEA1AB3F53EDD0976C485\"),\n\t    SHEX(\"720150FD5A1CF94A42F922EFCBB723FF948F74CA6D0A3F399AC54DA8B3BC07F39E6E2979C16C875866CF2F584CA7F2DB\"));\n  test_hash(&nettle_sha3_384, /* 189 octets */\n\t    SHEX(\"C9534A24714BD4BE37C88A3DA1082EDA7CABD154C309D7BD670DCCD95AA535594463058A29F79031D6ECAA9F675D1211E9359BE82669A79C855EA8D89DD38C2C761DDD0EC0CE9E97597432E9A1BEAE062CDD71EDFDFD464119BE9E69D18A7A7FD7CE0E2106F0C8B0ABF4715E2CA48EF9F454DC203C96656653B727083513F8EFB86E49C513BB758B3B052FE21F1C05BB33C37129D6CC81F1AEF6ADC45B0E8827A830FE545CF57D0955802C117D23CCB55EA28F95C0D8C2F9C5A242B33F\"),\n\t    SHEX(\"FA6F90935843D4F58E77CABE4BA662B4FABC1732725FAF952EEED70FA0AAD6A98FE67F3B6736A1C8F7C5BED4D9B017E0\"));\n  test_hash(&nettle_sha3_384, /* 190 octets */\n\t    SHEX(\"07906C87297B867ABF4576E9F3CC7F82F22B154AFCBF293B9319F1B0584DA6A40C27B32E0B1B7F412C4F1B82480E70A9235B12EC27090A5A33175A2BB28D8ADC475CEFE33F7803F8CE27967217381F02E67A3B4F84A71F1C5228E0C2AD971373F6F672624FCEA8D1A9F85170FAD30FA0BBD25035C3B41A6175D467998BD1215F6F3866F53847F9CF68EF3E2FBB54BC994DE2302B829C5EEA68EC441FCBAFD7D16AE4FE9FFF98BF00E5BC2AD54DD91FF9FDA4DD77B6C754A91955D1FBAAD0\"),\n\t    SHEX(\"4E2832FEE290D1917C15B31893F6578C1299445B99BC48708E13348A11EB2F27FE217A63F532583793D18CDECCAA78B9\"));\n  test_hash(&nettle_sha3_384, /* 191 octets */\n\t    SHEX(\"588E94B9054ABC2189DF69B8BA34341B77CDD528E7860E5DEFCAA79B0C9A452AD4B82AA306BE84536EB7CEDCBE058D7B84A6AEF826B028B8A0271B69AC3605A9635EA9F5EA0AA700F3EB7835BC54611B922964300C953EFE7491E3677C2CEBE0822E956CD16433B02C68C4A23252C3F9E151A416B4963257B783E038F6B4D5C9F110F871652C7A649A7BCEDCBCCC6F2D0725BB903CC196BA76C76AA9F10A190B1D1168993BAA9FFC96A1655216773458BEC72B0E39C9F2C121378FEAB4E76A\"),\n\t    SHEX(\"1FB97D6F42480E9F13C934C4A874877A808F1D73314C544D8570C0749F20FA35F53A0C0BDA1F10D1A10A029ABBB50BC7\"));\n  test_hash(&nettle_sha3_384, /* 192 octets */\n\t    SHEX(\"08959A7E4BAAE874928813364071194E2939772F20DB7C3157078987C557C2A6D5ABE68D520EEF3DC491692E1E21BCD880ADEBF63BB4213B50897FA005256ED41B5690F78F52855C8D9168A4B666FCE2DA2B456D7A7E7C17AB5F2FB1EE90B79E698712E963715983FD07641AE4B4E9DC73203FAC1AE11FA1F8C7941FCC82EAB247ADDB56E2638447E9D609E610B60CE086656AAEBF1DA3C8A231D7D94E2FD0AFE46B391FF14A72EAEB3F44AD4DF85866DEF43D4781A0B3578BC996C87970B132\"),\n\t    SHEX(\"86B3C81AA398C8819AFC4F282DFBCE24F4192B2530C267A78373D253C35C1DCC4F40835529563FD42A33FD2CBD680515\"));\n  test_hash(&nettle_sha3_384, /* 193 octets */\n\t    SHEX(\"CB2A234F45E2ECD5863895A451D389A369AAB99CFEF0D5C9FFCA1E6E63F763B5C14FB9B478313C8E8C0EFEB3AC9500CF5FD93791B789E67EAC12FD038E2547CC8E0FC9DB591F33A1E4907C64A922DDA23EC9827310B306098554A4A78F050262DB5B545B159E1FF1DCA6EB734B872343B842C57EAFCFDA8405EEDBB48EF32E99696D135979235C3A05364E371C2D76F1902F1D83146DF9495C0A6C57D7BF9EE77E80F9787AEE27BE1FE126CDC9EF893A4A7DCBBC367E40FE4E1EE90B42EA25AF01\"),\n\t    SHEX(\"A6BF548AB19FF60D6A8729FA62FDC9B59237843739AFFF877233ED374BCF70A017126974C2D1A3222D8D906BE850A25D\"));\n  test_hash(&nettle_sha3_384, /* 194 octets */\n\t    SHEX(\"D16BEADF02AB1D4DC6F88B8C4554C51E866DF830B89C06E786A5F8757E8909310AF51C840EFE8D20B35331F4355D80F73295974653DDD620CDDE4730FB6C8D0D2DCB2B45D92D4FBDB567C0A3E86BD1A8A795AF26FBF29FC6C65941CDDB090FF7CD230AC5268AB4606FCCBA9EDED0A2B5D014EE0C34F0B2881AC036E24E151BE89EEB6CD9A7A790AFCCFF234D7CB11B99EBF58CD0C589F20BDAC4F9F0E28F75E3E04E5B3DEBCE607A496D848D67FA7B49132C71B878FD5557E082A18ECA1FBDA94D4B\"),\n\t    SHEX(\"BA7D3B6AF5966C8C2723B1318820505D040DA810126ABC3E65088DC421E46D3E54DD31777C539AE083B7B8A4E2303836\"));\n  test_hash(&nettle_sha3_384, /* 195 octets */\n\t    SHEX(\"8F65F6BC59A85705016E2BAE7FE57980DE3127E5AB275F573D334F73F8603106EC3553016608EF2DD6E69B24BE0B7113BF6A760BA6E9CE1C48F9E186012CF96A1D4849D75DF5BB8315387FD78E9E153E76F8BA7EC6C8849810F59FB4BB9B004318210B37F1299526866F44059E017E22E96CBE418699D014C6EA01C9F0038B10299884DBEC3199BB05ADC94E955A1533219C1115FED0E5F21228B071F40DD57C4240D98D37B73E412FE0FA4703120D7C0C67972ED233E5DEB300A22605472FA3A3BA86\"),\n\t    SHEX(\"48CA5912C111DB667A77BE7C77F841E8B37130248377A19CD2FA3CD2EEC48B337CFE07C290F2690AD49E79CE3A9F9E53\"));\n  test_hash(&nettle_sha3_384, /* 196 octets */\n\t    SHEX(\"84891E52E0D451813210C3FD635B39A03A6B7A7317B221A7ABC270DFA946C42669AACBBBDF801E1584F330E28C729847EA14152BD637B3D0F2B38B4BD5BF9C791C58806281103A3EABBAEDE5E711E539E6A8B2CF297CF351C078B4FA8F7F35CF61BEBF8814BF248A01D41E86C5715EA40C63F7375379A7EB1D78F27622FB468AB784AAABA4E534A6DFD1DF6FA15511341E725ED2E87F98737CCB7B6A6DFAE416477472B046BF1811187D151BFA9F7B2BF9ACDB23A3BE507CDF14CFDF517D2CB5FB9E4AB6\"),\n\t    SHEX(\"4B3849B0916DD445B1856E1B908C414C752D280DE2183DD1F0193E73FD1BC02198599502391E8CA48D65E610D6EDCD8E\"));\n  test_hash(&nettle_sha3_384, /* 197 octets */\n\t    SHEX(\"FDD7A9433A3B4AFABD7A3A5E3457E56DEBF78E84B7A0B0CA0E8C6D53BD0C2DAE31B2700C6128334F43981BE3B213B1D7A118D59C7E6B6493A86F866A1635C12859CFB9AD17460A77B4522A5C1883C3D6ACC86E6162667EC414E9A104AA892053A2B1D72165A855BACD8FAF8034A5DD9B716F47A0818C09BB6BAF22AA503C06B4CA261F557761989D2AFBD88B6A678AD128AF68672107D0F1FC73C5CA740459297B3292B281E93BCEB761BDE7221C3A55708E5EC84472CDDCAA84ECF23723CC0991355C6280\"),\n\t    SHEX(\"02C90820D5FA9A91072991E87BFEEC7F18315F8CA1908EDBF19886C4CA5BD54AB9EC96A6AB7B815B58538F088867030F\"));\n  test_hash(&nettle_sha3_384, /* 198 octets */\n\t    SHEX(\"70A40BFBEF92277A1AAD72F6B79D0177197C4EBD432668CFEC05D099ACCB651062B5DFF156C0B27336687A94B26679CFDD9DAF7AD204338DD9C4D14114033A5C225BD11F217B5F4732DA167EE3F939262D4043FC9CBA92303B7B5E96AEA12ADDA64859DF4B86E9EE0B58E39091E6B188B408AC94E1294A8911245EE361E60E601EFF58D1D37639F3753BEC80EBB4EFDE25817436076623FC65415FE51D1B0280366D12C554D86743F3C3B6572E400361A60726131441BA493A83FBE9AFDA90F7AF1AE717238D\"),\n\t    SHEX(\"75967501FF781EFC3C9D597179C8CCAEE4373D9BF6AA6A5BED5118303EDC8B7478A47F2CEAF0A6B5B7224E53D5F1CDB3\"));\n  test_hash(&nettle_sha3_384, /* 199 octets */\n\t    SHEX(\"74356E449F4BF8644F77B14F4D67CB6BD9C1F5AE357621D5B8147E562B65C66585CAF2E491B48529A01A34D226D436959153815380D5689E30B35357CDAC6E08D3F2B0E88E200600D62BD9F5EAF488DF86A4470EA227006182E44809009868C4C280C43D7D64A5268FA719074960087B3A6ABC837882F882C837834535929389A12B2C78187E2EA07EF8B8EEF27DC85002C3AE35F1A50BEE6A1C48BA7E175F3316670B27983472AA6A61EED0A683A39EE323080620EA44A9F74411AE5CE99030528F9AB49C79F2\"),\n\t    SHEX(\"298387BA8A3EB88EE36B4206E54193BC5857F2A303CE41DFF7C3BD53EF7EE3D34AE7E0C714311A7BD8D25502CAB414B7\"));\n  test_hash(&nettle_sha3_384, /* 200 octets */\n\t    SHEX(\"8C3798E51BC68482D7337D3ABB75DC9FFE860714A9AD73551E120059860DDE24AB87327222B64CF774415A70F724CDF270DE3FE47DDA07B61C9EF2A3551F45A5584860248FABDE676E1CD75F6355AA3EAEABE3B51DC813D9FB2EAA4F0F1D9F834D7CAD9C7C695AE84B329385BC0BEF895B9F1EDF44A03D4B410CC23A79A6B62E4F346A5E8DD851C2857995DDBF5B2D717AEB847310E1F6A46AC3D26A7F9B44985AF656D2B7C9406E8A9E8F47DCB4EF6B83CAACF9AEFB6118BFCFF7E44BEF6937EBDDC89186839B77\"),\n\t    SHEX(\"27CEF65D1AECB7051BAD55DA0D601BC9D7A16D938A5715374A43109DD41B5C27D26C91CB44E4B47002D9B90ABA0584D1\"));\n  test_hash(&nettle_sha3_384, /* 201 octets */\n\t    SHEX(\"FA56BF730C4F8395875189C10C4FB251605757A8FECC31F9737E3C2503B02608E6731E85D7A38393C67DE516B85304824BFB135E33BF22B3A23B913BF6ACD2B7AB85198B8187B2BCD454D5E3318CACB32FD6261C31AE7F6C54EF6A7A2A4C9F3ECB81CE3555D4F0AD466DD4C108A90399D70041997C3B25345A9653F3C9A6711AB1B91D6A9D2216442DA2C973CBD685EE7643BFD77327A2F7AE9CB283620A08716DFB462E5C1D65432CA9D56A90E811443CD1ECB8F0DE179C9CB48BA4F6FEC360C66F252F6E64EDC96B\"),\n\t    SHEX(\"4AC9BDFD9F717D01598908BA457627D3AF7C8123F7110DD7FDB40E91EE6CAC201A8B728A384E663890847DFD4DE7FA76\"));\n  test_hash(&nettle_sha3_384, /* 202 octets */\n\t    SHEX(\"B6134F9C3E91DD8000740D009DD806240811D51AB1546A974BCB18D344642BAA5CD5903AF84D58EC5BA17301D5EC0F10CCD0509CBB3FD3FFF9172D193AF0F782252FD1338C7244D40E0E42362275B22D01C4C3389F19DD69BDF958EBE28E31A4FFE2B5F18A87831CFB7095F58A87C9FA21DB72BA269379B2DC2384B3DA953C7925761FED324620ACEA435E52B424A7723F6A2357374157A34CD8252351C25A1B232826CEFE1BD3E70FFC15A31E7C0598219D7F00436294D11891B82497BC78AA5363892A2495DF8C1EEF\"),\n\t    SHEX(\"F03FA03E4CF9C23443D7DBDBB66D9ABBAFEFB6500143FF0BFB5D7D6CA2BF1D7CD043A7BA7EFB48F15EBC68D1F94598E7\"));\n  test_hash(&nettle_sha3_384, /* 203 octets */\n\t    SHEX(\"C941CDB9C28AB0A791F2E5C8E8BB52850626AA89205BEC3A7E22682313D198B1FA33FC7295381354858758AE6C8EC6FAC3245C6E454D16FA2F51C4166FAB51DF272858F2D603770C40987F64442D487AF49CD5C3991CE858EA2A60DAB6A65A34414965933973AC2457089E359160B7CDEDC42F29E10A91921785F6B7224EE0B349393CDCFF6151B50B377D609559923D0984CDA6000829B916AB6896693EF6A2199B3C22F7DC5500A15B8258420E314C222BC000BC4E5413E6DD82C993F8330F5C6D1BE4BC79F08A1A0A46\"),\n\t    SHEX(\"9C779D981F9B7E491FF868BE22B37FA9DF72DE55672A0226A821B29C045DF4FF788FA7271D557EF6025EEA255809F241\"));\n  test_hash(&nettle_sha3_384, /* 204 octets */\n\t    SHEX(\"4499EFFFAC4BCEA52747EFD1E4F20B73E48758BE915C88A1FFE5299B0B005837A46B2F20A9CB3C6E64A9E3C564A27C0F1C6AD1960373036EC5BFE1A8FC6A435C2185ED0F114C50E8B3E4C7ED96B06A036819C9463E864A58D6286F785E32A804443A56AF0B4DF6ABC57ED5C2B185DDEE8489EA080DEEEE66AA33C2E6DAB36251C402682B6824821F998C32163164298E1FAFD31BABBCFFB594C91888C6219079D907FDB438ED89529D6D96212FD55ABE20399DBEFD342248507436931CDEAD496EB6E4A80358ACC78647D043\"),\n\t    SHEX(\"2C0BC54A67B00AD703FC595751074C4E447EFDE00CAAF8C8FCADF5768C330B6C7F1918F044F5C5C55810D078534A7BB3\"));\n  test_hash(&nettle_sha3_384, /* 205 octets */\n\t    SHEX(\"EECBB8FDFA4DA62170FD06727F697D81F83F601FF61E478105D3CB7502F2C89BF3E8F56EDD469D049807A38882A7EEFBC85FC9A950952E9FA84B8AFEBD3CE782D4DA598002827B1EB98882EA1F0A8F7AA9CE013A6E9BC462FB66C8D4A18DA21401E1B93356EB12F3725B6DB1684F2300A98B9A119E5D27FF704AFFB618E12708E77E6E5F34139A5A41131FD1D6336C272A8FC37080F041C71341BEE6AB550CB4A20A6DDB6A8E0299F2B14BC730C54B8B1C1C487B494BDCCFD3A53535AB2F231590BF2C4062FD2AD58F906A2D0D\"),\n\t    SHEX(\"2DB19CA557723CD3C17E7D8140CA301A5A2CB77E3F1F595F5B850A78943C7F36FC37056DCF2BADB90DDA77BFA969C0AA\"));\n  test_hash(&nettle_sha3_384, /* 206 octets */\n\t    SHEX(\"E64F3E4ACE5C8418D65FEC2BC5D2A303DD458034736E3B0DF719098BE7A206DEAF52D6BA82316CAF330EF852375188CDE2B39CC94AA449578A7E2A8E3F5A9D68E816B8D16889FBC0EBF0939D04F63033AE9AE2BDAB73B88C26D6BD25EE460EE1EF58FB0AFA92CC539F8C76D3D097E7A6A63EBB9B5887EDF3CF076028C5BBD5B9DB3211371AD3FE121D4E9BF44229F4E1ECF5A0F9F0EBA4D5CEB72878AB22C3F0EB5A625323AC66F7061F4A81FAC834471E0C59553F108475FE290D43E6A055AE3EE46FB67422F814A68C4BE3E8C9\"),\n\t    SHEX(\"71E5DD0755CF8B82BC79AED6FB61C9E4FF8361C9AFC5AD980808A8BC480E09D59B234074472851080714E0275CE72DC5\"));\n  test_hash(&nettle_sha3_384, /* 207 octets */\n\t    SHEX(\"D2CB2D733033F9E91395312808383CC4F0CA974E87EC68400D52E96B3FA6984AC58D9AD0938DDE5A973008D818C49607D9DE2284E7618F1B8AED8372FBD52ED54557AF4220FAC09DFA8443011699B97D743F8F2B1AEF3537EBB45DCC9E13DFB438428EE190A4EFDB3CAEB7F3933117BF63ABDC7E57BEB4171C7E1AD260AB0587806C4D137B6316B50ABC9CCE0DFF3ACADA47BBB86BE777E617BBE578FF4519844DB360E0A96C6701290E76BB95D26F0F804C8A4F2717EAC4E7DE9F2CFF3BBC55A17E776C0D02856032A6CD10AD2838\"),\n\t    SHEX(\"51F951B8F1013BA9BCED90478E248CD89D4DEBC6A19CEB6EF81BA1A5D8D3339D426D50A94C7CE3D143C45DECCEF94965\"));\n  test_hash(&nettle_sha3_384, /* 208 octets */\n\t    SHEX(\"F2998955613DD414CC111DF5CE30A995BB792E260B0E37A5B1D942FE90171A4AC2F66D4928D7AD377F4D0554CBF4C523D21F6E5F379D6F4B028CDCB9B1758D3B39663242FF3CB6EDE6A36A6F05DB3BC41E0D861B384B6DEC58BB096D0A422FD542DF175E1BE1571FB52AE66F2D86A2F6824A8CFAACBAC4A7492AD0433EEB15454AF8F312B3B2A577750E3EFBD370E8A8CAC1582581971FBA3BA4BD0D76E718DACF8433D33A59D287F8CC92234E7A271041B526E389EFB0E40B6A18B3AAF658E82ED1C78631FD23B4C3EB27C3FAEC8685\"),\n\t    SHEX(\"210EBC1556E31A27EAF60A5FE3E181135C5EA117E3FF21AF2D04BEAB9A243FFFF632E3D7778F9A6D0304C1ACF3659A3C\"));\n  test_hash(&nettle_sha3_384, /* 209 octets */\n\t    SHEX(\"447797E2899B72A356BA55BF4DF3ACCA6CDB1041EB477BD1834A9F9ACBC340A294D729F2F97DF3A610BE0FF15EDB9C6D5DB41644B9874360140FC64F52AA03F0286C8A640670067A84E017926A70438DB1BB361DEFEE7317021425F8821DEF26D1EFD77FC853B818545D055ADC9284796E583C76E6FE74C9AC2587AA46AA8F8804F2FEB5836CC4B3ABABAB8429A5783E17D5999F32242EB59EF30CD7ADABC16D72DBDB097623047C98989F88D14EAF02A7212BE16EC2D07981AAA99949DDF89ECD90333A77BC4E1988A82ABF7C7CAF3291\"),\n\t    SHEX(\"F5F659F6999BAD8CDC77C42901A8D64C1FA827F7848985136140BF5D4B3BBB3D964D2D8156F9FD02B6D382BC8410A88E\"));\n  test_hash(&nettle_sha3_384, /* 210 octets */\n\t    SHEX(\"9F2C18ADE9B380C784E170FB763E9AA205F64303067EB1BCEA93DF5DAC4BF5A2E00B78195F808DF24FC76E26CB7BE31DC35F0844CDED1567BBA29858CFFC97FB29010331B01D6A3FB3159CC1B973D255DA9843E34A0A4061CABDB9ED37F241BFABB3C20D32743F4026B59A4CCC385A2301F83C0B0A190B0F2D01ACB8F0D41111E10F2F4E149379275599A52DC089B35FDD5234B0CFB7B6D8AEBD563CA1FA653C5C021DFD6F5920E6F18BFAFDBECBF0AB00281333ED50B9A999549C1C8F8C63D7626C48322E9791D5FF72294049BDE91E73F8\"),\n\t    SHEX(\"B151BF98C52F63F294A4B1E990C86CB73C4BDD476B25C138CA66B2BA08447540B0A787DFDDAA3D38AF44CA8EBBED74D8\"));\n  test_hash(&nettle_sha3_384, /* 211 octets */\n\t    SHEX(\"AE159F3FA33619002AE6BCCE8CBBDD7D28E5ED9D61534595C4C9F43C402A9BB31F3B301CBFD4A43CE4C24CD5C9849CC6259ECA90E2A79E01FFBAC07BA0E147FA42676A1D668570E0396387B5BCD599E8E66AAED1B8A191C5A47547F61373021FA6DEADCB55363D233C24440F2C73DBB519F7C9FA5A8962EFD5F6252C0407F190DFEFAD707F3C7007D69FF36B8489A5B6B7C557E79DD4F50C06511F599F56C896B35C917B63BA35C6FF8092BAF7D1658E77FC95D8A6A43EEB4C01F33F03877F92774BE89C1114DD531C011E53A34DC248A2F0E6\"),\n\t    SHEX(\"47D74FDD9A19A5389313610643FA859FF0BD7B583B099FDDB9C980DCC000AFEB639DD99071EA31976DA35B7BC949BD4E\"));\n  test_hash(&nettle_sha3_384, /* 212 octets */\n\t    SHEX(\"3B8E97C5FFC2D6A40FA7DE7FCEFC90F3B12C940E7AB415321E29EE692DFAC799B009C99DCDDB708FCE5A178C5C35EE2B8617143EDC4C40B4D313661F49ABDD93CEA79D117518805496FE6ACF292C4C2A1F76B403A97D7C399DAF85B46AD84E16246C67D6836757BDE336C290D5D401E6C1386AB32797AF6BB251E9B2D8FE754C47482B72E0B394EAB76916126FD68EA7D65EB93D59F5B4C5AC40F7C3B37E7F3694F29424C24AF8C8F0EF59CD9DBF1D28E0E10F799A6F78CAD1D45B9DB3D7DEE4A7059ABE99182714983B9C9D44D7F5643596D4F3\"),\n\t    SHEX(\"9B809198DCCE24175E33098331D3A402A821AE9326E72775AAE34D1A9BB53D2B57863905CFD60543BBC42B454007C315\"));\n  test_hash(&nettle_sha3_384, /* 213 octets */\n\t    SHEX(\"3434EC31B10FAFDBFEEC0DD6BD94E80F7BA9DCA19EF075F7EB017512AF66D6A4BCF7D16BA0819A1892A6372F9B35BCC7CA8155EE19E8428BC22D214856ED5FA9374C3C09BDE169602CC219679F65A1566FC7316F4CC3B631A18FB4449FA6AFA16A3DB2BC4212EFF539C67CF184680826535589C7111D73BFFCE431B4C40492E763D9279560AAA38EB2DC14A212D723F994A1FE656FF4DD14551CE4E7C621B2AA5604A10001B2878A897A28A08095C325E10A26D2FB1A75BFD64C250309BB55A44F23BBAC0D5516A1C687D3B41EF2FBBF9CC56D4739\"),\n\t    SHEX(\"93C9834501FC728508A15EB9205E678983F3BDB0BA447EE739AE5082DB37F2F2D485088130E0B1CBF0039D18BDF429F7\"));\n  test_hash(&nettle_sha3_384, /* 214 octets */\n\t    SHEX(\"7C7953D81C8D208FD1C97681D48F49DD003456DE60475B84070EF4847C333B74575B1FC8D2A186964485A3B8634FEAA3595AAA1A2F4595A7D6B6153563DEE31BBAC443C8A33EED6D5D956A980A68366C2527B550EE950250DFB691EACBD5D56AE14B970668BE174C89DF2FEA43AE52F13142639C884FD62A3683C0C3792F0F24AB1318BCB27E21F4737FAB62C77EA38BC8FD1CF41F7DAB64C13FEBE7152BF5BB7AB5A78F5346D43CC741CB6F72B7B8980F268B68BF62ABDFB1577A52438FE14B591498CC95F071228460C7C5D5CEB4A7BDE588E7F21C\"),\n\t    SHEX(\"C0AD8C3E7EA595104D4BC0A08DCBC85042ED50DD8D9B01AB47C9F066F91AD3BFFEDE4107F1EB1F5B61CA7D4091D68327\"));\n  test_hash(&nettle_sha3_384, /* 215 octets */\n\t    SHEX(\"7A6A4F4FDC59A1D223381AE5AF498D74B7252ECF59E389E49130C7EAEE626E7BD9897EFFD92017F4CCDE66B0440462CDEDFD352D8153E6A4C8D7A0812F701CC737B5178C2556F07111200EB627DBC299CAA792DFA58F35935299FA3A3519E9B03166DFFA159103FFA35E8577F7C0A86C6B46FE13DB8E2CDD9DCFBA85BDDDCCE0A7A8E155F81F712D8E9FE646153D3D22C811BD39F830433B2213DD46301941B59293FD0A33E2B63ADBD95239BC01315C46FDB678875B3C81E053A40F581CFBEC24A1404B1671A1B88A6D06120229518FB13A74CA0AC5AE\"),\n\t    SHEX(\"AA8DAA02ABCBC5A4B3003BFF5CBC2C84594C5A0F84BD449A1A56BE59566E13EC6803010D422A4C244B99812F4537C93D\"));\n  test_hash(&nettle_sha3_384, /* 216 octets */\n\t    SHEX(\"D9FAA14CEBE9B7DE551B6C0765409A33938562013B5E8E0E1E0A6418DF7399D0A6A771FB81C3CA9BD3BB8E2951B0BC792525A294EBD1083688806FE5E7F1E17FD4E3A41D00C89E8FCF4A363CAEDB1ACB558E3D562F1302B3D83BB886ED27B76033798131DAB05B4217381EAAA7BA15EC820BB5C13B516DD640EAEC5A27D05FDFCA0F35B3A5312146806B4C0275BCD0AAA3B2017F346975DB566F9B4D137F4EE10644C2A2DA66DEECA5342E236495C3C6280528BFD32E90AF4CD9BB908F34012B52B4BC56D48CC8A6B59BAB014988EABD12E1A0A1C2E170E7\"),\n\t    SHEX(\"CAEB4F829A925679416F7CB177ED4C99721B851AB59D52979BFEC6D2AAA1E602F4310B15624F9D7BF2D351DB73BFB5EA\"));\n  test_hash(&nettle_sha3_384, /* 217 octets */\n\t    SHEX(\"2D8427433D0C61F2D96CFE80CF1E932265A191365C3B61AAA3D6DCC039F6BA2AD52A6A8CC30FC10F705E6B7705105977FA496C1C708A277A124304F1FC40911E7441D1B5E77B951AAD7B01FD5DB1B377D165B05BBF898042E39660CAF8B279FE5229D1A8DB86C0999ED65E53D01CCBC4B43173CCF992B3A14586F6BA42F5FE30AFA8AE40C5DF29966F9346DA5F8B35F16A1DE3AB6DE0F477D8D8660918060E88B9B9E9CA6A4207033B87A812DBF5544D39E4882010F82B6CE005F8E8FF6FE3C3806BC2B73C2B83AFB704345629304F9F86358712E9FAE3CA3E\"),\n\t    SHEX(\"FC1FC7F19F6C9D0AD1462B24C121C89B01B4E083EDAD02A8DBDEB990D98CAFE0AFE01E2EBA646872CD816B5203EE8A87\"));\n  test_hash(&nettle_sha3_384, /* 218 octets */\n\t    SHEX(\"5E19D97887FCAAC0387E22C6F803C34A3DACD2604172433F7A8A7A526CA4A2A1271ECFC5D5D7BE5AC0D85D921095350DFC65997D443C21C8094E0A3FEFD2961BCB94AED03291AE310CCDA75D8ACE4BC7D89E7D3E5D1650BDA5D668B8B50BFC8E608E184F4D3A9A2BADC4FF5F07E0C0BC8A9F2E0B2A26FD6D8C550008FAAAB75FD71AF2A424BEC9A7CD9D83FAD4C8E9319115656A8717D3B523A68FF8004258B9990ED362308461804BA3E3A7E92D8F2FFAE5C2FBA55BA5A3C27C0A2F71BD711D2FE1799C2ADB31B200035481E9EE5C4ADF2AB9C0FA50B23975CF\"),\n\t    SHEX(\"84803E50DEC901FF930C8A76EBC1F98EC72874DEEF0D249020B1DBEB4EA7D8C7DA4761EDE077158460E054A7F71D1994\"));\n  test_hash(&nettle_sha3_384, /* 219 octets */\n\t    SHEX(\"C8E976AB4638909387CE3B8D4E510C3230E5690E02C45093B1D297910ABC481E56EEA0F296F98379DFC9080AF69E73B2399D1C143BEE80AE1328162CE1BA7F6A8374679B20AACD380EB4E61382C99998704D62701AFA914F9A2705CDB065885F50D086C3EB5753700C387118BB142F3E6DA1E988DFB31AC75D7368931E45D1391A274B22F83CEB072F9BCABC0B216685BFD789F5023971024B1878A205442522F9EA7D8797A4102A3DF41703768251FD5E017C85D1200A464118AA35654E7CA39F3C375B8EF8CBE7534DBC64BC20BEFB417CF60EC92F63D9EE7397\"),\n\t    SHEX(\"05586BCB8077E19F3F43015216D623B1439C49ECDD3C53255553E9133FD1A9008891520D2EEBE5684C546028CA2CDDFE\"));\n  test_hash(&nettle_sha3_384, /* 220 octets */\n\t    SHEX(\"7145FA124B7429A1FC2231237A949BA7201BCC1822D3272DE005B682398196C25F7E5CC2F289FBF44415F699CB7FE6757791B1443410234AE061EDF623359E2B4E32C19BF88450432DD01CAA5EB16A1DC378F391CA5E3C4E5F356728BDDD4975DB7C890DA8BBC84CC73FF244394D0D48954978765E4A00B593F70F2CA082673A261ED88DBCEF1127728D8CD89BC2C597E9102CED6010F65FA75A14EBE467FA57CE3BD4948B6867D74A9DF5C0EC6F530CBF2EE61CE6F06BC8F2864DFF5583776B31DF8C7FFCB61428A56BF7BD37188B4A5123BBF338393AF46EDA85E6\"),\n\t    SHEX(\"A200D8EF3D120B917561EDC8420BDE022B3ACE792925C8FABF25AD9B0FA676D2260ABD8098F383C0F93043D5D3F56C47\"));\n  test_hash(&nettle_sha3_384, /* 221 octets */\n\t    SHEX(\"7FDFADCC9D29BAD23AE038C6C65CDA1AEF757221B8872ED3D75FF8DF7DA0627D266E224E812C39F7983E4558BFD0A1F2BEF3FEB56BA09120EF762917B9C093867948547AEE98600D10D87B20106878A8D22C64378BF634F7F75900C03986B077B0BF8B740A82447B61B99FEE5376C5EB6680EC9E3088F0BDD0C56883413D60C1357D3C811950E5890E7600103C916341B80C743C6A852B7B4FB60C3BA21F3BC15B8382437A68454779CF3CD7F9F90CCC8EF28D0B706535B1E4108EB5627BB45D719CB046839AEE311CA1ABDC8319E050D67972CB35A6B1601B25DBF487\"),\n\t    SHEX(\"A8905D1E9F4FC96F2D769D31C9A120DE43A0B20115C8D17BF0313206EB9CD87AE41DF2D444C9D75F9366998263D61C07\"));\n  test_hash(&nettle_sha3_384, /* 222 octets */\n\t    SHEX(\"988638219FD3095421F826F56E4F09E356296B628C3CE6930C9F2E758FD1A80C8273F2F61E4DAAE65C4F110D3E7CA0965AC7D24E34C0DC4BA2D6FF0BF5BBE93B3585F354D7543CB542A1AA54674D375077F2D360A8F4D42F3DB131C3B7AB7306267BA107659864A90C8C909460A73621D1F5D9D3FD95BEB19B23DB1CB6C0D0FBA91D36891529B8BD8263CAA1BAB56A4AFFAED44962DF096D8D5B1EB845EF31188B3E10F1AF811A13F156BEB7A288AAE593EBD1471B624AA1A7C6ADF01E2200B3D72D88A3AED3100C88231E41EFC376906F0B580DC895F080FDA5741DB1CB\"),\n\t    SHEX(\"88249AF84A7F1E49D144869A3D4FE8AA6E1A4874EE467BC99E9C33E2105AF2D097417D6B78537925392DB2C5CB1E0B92\"));\n  test_hash(&nettle_sha3_384, /* 223 octets */\n\t    SHEX(\"5AAB62756D307A669D146ABA988D9074C5A159B3DE85151A819B117CA1FF6597F6156E80FDD28C9C3176835164D37DA7DA11D94E09ADD770B68A6E081CD22CA0C004BFE7CD283BF43A588DA91F509B27A6584C474A4A2F3EE0F1F56447379240A5AB1FB77FDCA49B305F07BA86B62756FB9EFB4FC225C86845F026EA542076B91A0BC2CDD136E122C659BE259D98E5841DF4C2F60330D4D8CDEE7BF1A0A244524EECC68FF2AEF5BF0069C9E87A11C6E519DE1A4062A10C83837388F7EF58598A3846F49D499682B683C4A062B421594FAFBC1383C943BA83BDEF515EFCF10D\"),\n\t    SHEX(\"C46122D00B61E79DF025A4D525B8A602C7AC004304A993872E3A8AA37FC0E8EAAE5FAD9A220C5C6AFBD5A4783680013A\"));\n  test_hash(&nettle_sha3_384, /* 224 octets */\n\t    SHEX(\"47B8216AA0FBB5D67966F2E82C17C07AA2D6327E96FCD83E3DE7333689F3EE79994A1BF45082C4D725ED8D41205CB5BCDF5C341F77FACB1DA46A5B9B2CBC49EADF786BCD881F371A95FA17DF73F606519AEA0FF79D5A11427B98EE7F13A5C00637E2854134691059839121FEA9ABE2CD1BCBBBF27C74CAF3678E05BFB1C949897EA01F56FFA4DAFBE8644611685C617A3206C7A7036E4AC816799F693DAFE7F19F303CE4EBA09D21E03610201BFC665B72400A547A1E00FA9B7AD8D84F84B34AEF118515E74DEF11B9188BD1E1F97D9A12C30132EC2806339BDADACDA2FD8B78\"),\n\t    SHEX(\"ABA0EE3C16D3DC753F6E466C33A998A73282C0DBEAF51324979A58437636886E5521B567C9A62D405EE558FFEBAE91BC\"));\n  test_hash(&nettle_sha3_384, /* 225 octets */\n\t    SHEX(\"8CFF1F67FE53C098896D9136389BD8881816CCAB34862BB67A656E3D98896F3CE6FFD4DA73975809FCDF9666760D6E561C55238B205D8049C1CEDEEF374D1735DAA533147BFA960B2CCE4A4F254176BB4D1BD1E89654432B8DBE1A135C42115B394B024856A2A83DC85D6782BE4B444239567CCEC4B184D4548EAE3FF6A192F343292BA2E32A0F267F31CC26719EB85245D415FB897AC2DA433EE91A99424C9D7F1766A44171D1651001C38FC79294ACCC68CEB5665D36218454D3BA169AE058A831338C17743603F81EE173BFC0927464F9BD728DEE94C6AEAB7AAE6EE3A627E8\"),\n\t    SHEX(\"28B37125F233BA8D527E5284A16E6EFE9AE84D3EBC6EE4C88AEE0AB165C111A32FF2CDCC4213AC3267B0546DC0D74C84\"));\n  test_hash(&nettle_sha3_384, /* 226 octets */\n\t    SHEX(\"EACD07971CFF9B9939903F8C1D8CBB5D4DB1B548A85D04E037514A583604E787F32992BF2111B97AC5E8A938233552731321522AB5E8583561260B7D13EBEEF785B23A41FD8576A6DA764A8ED6D822D4957A545D5244756C18AA80E1AAD4D1F9C20D259DEE1711E2CC8FD013169FB7CC4CE38B362F8E0936AE9198B7E838DCEA4F7A5B9429BB3F6BBCF2DC92565E3676C1C5E6EB3DD2A0F86AA23EDD3D0891F197447692794B3DFA269611AD97F72B795602B4FDB198F3FD3EB41B415064256E345E8D8C51C555DC8A21904A9B0F1AD0EFFAB7786AAC2DA3B196507E9F33CA356427\"),\n\t    SHEX(\"258988E54D66E0C53B263BA68D9E3AA47D278DF87C51219CCE6F2547281EA6581540E28C1D7E069254791F0D385EA694\"));\n  test_hash(&nettle_sha3_384, /* 227 octets */\n\t    SHEX(\"23AC4E9A42C6EF45C3336CE6DFC2FF7DE8884CD23DC912FEF0F7756C09D335C189F3AD3A23697ABDA851A81881A0C8CCAFC980AB2C702564C2BE15FE4C4B9F10DFB2248D0D0CB2E2887FD4598A1D4ACDA897944A2FFC580FF92719C95CF2AA42DC584674CB5A9BC5765B9D6DDF5789791D15F8DD925AA12BFFAFBCE60827B490BB7DF3DDA6F2A143C8BF96ABC903D83D59A791E2D62814A89B8080A28060568CF24A80AE61179FE84E0FFAD00388178CB6A617D37EFD54CC01970A4A41D1A8D3DDCE46EDBBA4AB7C90AD565398D376F431189CE8C1C33E132FEAE6A8CD17A61C630012\"),\n\t    SHEX(\"F6A9399B482A3A5EA6FE79A2DB7BAE7E588C9B7DA03DD85C120112FDBC234350529A1F37ABBEBEB770299E141EEA7BA3\"));\n  test_hash(&nettle_sha3_384, /* 228 octets */\n\t    SHEX(\"0172DF732282C9D488669C358E3492260CBE91C95CFBC1E3FEA6C4B0EC129B45F242ACE09F152FC6234E1BEE8AAB8CD56E8B486E1DCBA9C05407C2F95DA8D8F1C0AF78EE2ED82A3A79EC0CB0709396EE62AADB84F8A4EE8A7CCCA3C1EE84E302A09EA802204AFECF04097E67D0F8E8A9D2651126C0A598A37081E42D168B0AE8A71951C524259E4E2054E535B779679BDADE566FE55700858618E626B4A0FAF895BCCE9011504A49E05FD56127EAE3D1F8917AFB548ECADABDA1020111FEC9314C413498A360B08640549A22CB23C731ACE743252A8227A0D2689D4C6001606678DFB921\"),\n\t    SHEX(\"C0F957E52E40F9B8EA945D40779286F7257AD463A934B049DF40C31D3547AEF41AEA2DD981FD2579327229B54EE04E66\"));\n  test_hash(&nettle_sha3_384, /* 229 octets */\n\t    SHEX(\"3875B9240CF3E0A8B59C658540F26A701CF188496E2C2174788B126FD29402D6A75453BA0635284D08835F40051A2A9683DC92AFB9383719191231170379BA6F4ADC816FECBB0F9C446B785BF520796841E58878B73C58D3EBB097CE4761FDEABE15DE2F319DFBAF1742CDEB389559C788131A6793E193856661376C81CE9568DA19AA6925B47FFD77A43C7A0E758C37D69254909FF0FBD415EF8EB937BCD49F91468B49974C07DC819ABD67395DB0E05874FF83DDDAB895344ABD0E7111B2DF9E58D76D85AD98106B36295826BE04D435615595605E4B4BB824B33C4AFEB5E7BB0D19F909\"),\n\t    SHEX(\"779EECF39311318051BF73C441FB799708912049E28DF3FADDE449E4CD820CC4CA1BD0F8513927D9A64F5D34FAABA039\"));\n  test_hash(&nettle_sha3_384, /* 230 octets */\n\t    SHEX(\"747CC1A59FEFBA94A9C75BA866C30DC5C1CB0C0F8E9361D98484956DD5D1A40F6184AFBE3DAC9F76028D1CAECCFBF69199C6CE2B4C092A3F4D2A56FE5A33A00757F4D7DEE5DFB0524311A97AE0668A47971B95766E2F6DD48C3F57841F91F04A00AD5EA70F2D479A2620DC5CD78EAAB3A3B011719B7E78D19DDF70D9423798AF77517EBC55392FCD01FC600D8D466B9E7A7A85BF33F9CC5419E9BD874DDFD60981150DDAF8D7FEBAA4374F0872A5628D318000311E2F5655365AD4D407C20E5C04DF17A222E7DEEC79C5AB1116D8572F91CD06E1CCC7CED53736FC867FD49ECEBE6BF8082E8A\"),\n\t    SHEX(\"3D6495EB3DA4E81D3470A050F416E2C8ABF657A26D4FD64AF35735B5782B611FB798A72FE7A61CE79D0496F69654CC80\"));\n  test_hash(&nettle_sha3_384, /* 231 octets */\n\t    SHEX(\"57AF971FCCAEC97435DC2EC9EF0429BCEDC6B647729EA168858A6E49AC1071E706F4A5A645CA14E8C7746D65511620682C906C8B86EC901F3DDED4167B3F00B06CBFAC6AEE3728051B3E5FF10B4F9ED8BD0B8DA94303C833755B3CA3AEDDF0B54BC8D6632138B5D25BAB03D17B3458A9D782108006F5BB7DE75B5C0BA854B423D8BB801E701E99DC4FEAAD59BC1C7112453B04D33EA3635639FB802C73C2B71D58A56BBD671B18FE34ED2E3DCA38827D63FDB1D4FB3285405004B2B3E26081A8FF08CD6D2B08F8E7B7E90A2AB1ED7A41B1D0128522C2F8BFF56A7FE67969422CE839A9D4608F03\"),\n\t    SHEX(\"F8188EAFD0E2F9C7F44E70B38DB1FE3E12B1469739CA6A13ED5A8661673A318296FFAF8D37F6FCEC22A2D00EEE2ABEBA\"));\n  test_hash(&nettle_sha3_384, /* 232 octets */\n\t    SHEX(\"04E16DEDC1227902BAAF332D3D08923601BDD64F573FAA1BB7201918CFE16B1E10151DAE875DA0C0D63C59C3DD050C4C6A874011B018421AFC4623AB0381831B2DA2A8BA42C96E4F70864AC44E106F94311051E74C77C1291BF5DB9539E69567BF6A11CF6932BBBAD33F8946BF5814C066D851633D1A513510039B349939BFD42B858C21827C8FF05F1D09B1B0765DC78A135B5CA4DFBA0801BCADDFA175623C8B647EACFB4444B85A44F73890607D06D507A4F8393658788669F6EF4DEB58D08C50CA0756D5E2F49D1A7AD73E0F0B3D3B5F090ACF622B1878C59133E4A848E05153592EA81C6FBF\"),\n\t    SHEX(\"7D83C3F2265C90FEF4BC6BD0D17A218F0E196489CB2D8455BBEE80AB989FFEA46DE753346EDBD5C88448FEDB0D4AAD4D\"));\n  test_hash(&nettle_sha3_384, /* 233 octets */\n\t    SHEX(\"7C815C384EEE0F288ECE27CCED52A01603127B079C007378BC5D1E6C5E9E6D1C735723ACBBD5801AC49854B2B569D4472D33F40BBB8882956245C366DC3582D71696A97A4E19557E41E54DEE482A14229005F93AFD2C4A7D8614D10A97A9DFA07F7CD946FA45263063DDD29DB8F9E34DB60DAA32684F0072EA2A9426ECEBFA5239FB67F29C18CBAA2AF6ED4BF4283936823AC1790164FEC5457A9CBA7C767CA59392D94CAB7448F50EB34E9A93A80027471CE59736F099C886DEA1AB4CBA4D89F5FC7AE2F21CCD27F611ECA4626B2D08DC22382E92C1EFB2F6AFDC8FDC3D2172604F5035C46B8197D3\"),\n\t    SHEX(\"FCC5FCFEF5BA874A317B73C9B1B4CF6877373D41F0B8080A5D4F021E0D67F3B9F8CCAACFD4244FC10BA58B3A470DB48B\"));\n  test_hash(&nettle_sha3_384, /* 234 octets */\n\t    SHEX(\"E29D505158DBDD937D9E3D2145658EE6F5992A2FC790F4F608D9CDB44A091D5B94B88E81FAC4FDF5C49442F13B911C55886469629551189EAFF62488F1A479B7DB11A1560E198DDCCCCF50159093425FF7F1CB8D1D1246D0978764087D6BAC257026B090EFAE8CEC5F22B6F21C59ACE1AC7386F5B8837CA6A12B6FBF5534DD0560EF05CA78104D3B943DDB220FEAEC89AA5E692A00F822A2AB9A2FE60350D75E7BE16FF2526DC643872502D01F42F188ABED0A6E9A6F5FD0D1CE7D5755C9FFA66B0AF0B20BD806F08E06156690D81AC811778CA3DAC2C249B96002017FCE93E507E3B953ACF99964B847\"),\n\t    SHEX(\"9B336B4C2B530F65C01AF3F0A46CF1B626D5DBF1B2E50F790B9F34CCA367315FDFBF7D9619CDA4DA22E39F9315303816\"));\n  test_hash(&nettle_sha3_384, /* 235 octets */\n\t    SHEX(\"D85588696F576E65ECA0155F395F0CFACD83F36A99111ED5768DF2D116D2121E32357BA4F54EDE927F189F297D3A97FAD4E9A0F5B41D8D89DD7FE20156799C2B7B6BF9C957BA0D6763F5C3BC5129747BBB53652B49290CFF1C87E2CDF2C4B95D8AAEE09BC8FBFA6883E62D237885810491BFC101F1D8C636E3D0EDE838AD05C207A3DF4FAD76452979EB99F29AFAECEDD1C63B8D36CF378454A1BB67A741C77AC6B6B3F95F4F02B64DABC15438613EA49750DF42EE90101F115AA9ABB9FF64324DDE9DABBB01054E1BD6B4BCDC7930A44C2300D87CA78C06924D0323AD7887E46C90E8C4D100ACD9EED21E\"),\n\t    SHEX(\"CAC442227F10C4935D42C2914043167890C3EE1F4556D38D20767E8402AEC4D70111F2034276E90F28102DE634E26AFD\"));\n  test_hash(&nettle_sha3_384, /* 236 octets */\n\t    SHEX(\"3A12F8508B40C32C74492B66323375DCFE49184C78F73179F3314B79E63376B8AC683F5A51F1534BD729B02B04D002F55CBD8E8FC9B5EC1EA6BBE6A0D0E7431518E6BA45D124035F9D3DCE0A8BB7BF1430A9F657E0B4EA9F20EB20C786A58181A1E20A96F1628F8728A13BDF7A4B4B32FC8AA7054CC4881AE7FA19AFA65C6C3EE1B3ADE3192AF42054A8A911B8EC1826865D46D93F1E7C5E2B7813C92A506E53886F3D4701BB93D2A681AD109C845904BB861AF8AF0646B6E399B38B614051D34F6842563A0F37EC00CB3D865FC5D746C4987DE2A65071100883A2A9C7A2BFE1E2DD603D9EA24DC7C5FD06BE\"),\n\t    SHEX(\"05E3FB83EE8D609874D5935283702F29E5E896BB090C48033489295989C45DD2C06F5BD558B6BC786AB1251F75664B06\"));\n  test_hash(&nettle_sha3_384, /* 237 octets */\n\t    SHEX(\"1861EDCE46FA5AD17E1FF1DEAE084DEC580F97D0A67885DFE834B9DFAC1AE076742CE9E267512CA51F6DF5A455AF0C5FD6ABF94ACEA103A3370C354485A7846FB84F3AC7C2904B5B2FBF227002CE512133BB7E1C4E50057BFD1E44DB33C7CDB969A99E284B184F50A14B068A1FC5009D9B298DBE92239572A7627AAC02ABE8F3E3B473417F36D4D2505D16B7577F4526C9D94A270A2DFE450D06DA8F6FA956879A0A55CFE99E742EA555EA477BA3E9B44CCD508C375423611AF92E55345DC215779B2D5119EBA49C71D49B9FE3F1569FA24E5CA3E332D042422A8B8158D3EC66A80012976F31FFDF305F0C9C5E\"),\n\t    SHEX(\"6E463C7FB5CF436B1444921AFE76D2FA4E7A23EDFC9D496AF1DC7E78A0173D797EFF80F2BB32CFD34DAF5633C4E6BCD6\"));\n  test_hash(&nettle_sha3_384, /* 238 octets */\n\t    SHEX(\"08D0FFDE3A6E4EF65608EA672E4830C12943D7187CCFF08F4941CFC13E545F3B9C7AD5EEBBE2B01642B486CAF855C2C73F58C1E4E3391DA8E2D63D96E15FD84953AE5C231911B00AD6050CD7AAFDAAC9B0F663AE6AAB45519D0F5391A541707D479034E73A6AD805AE3598096AF078F1393301493D663DD71F83869CA27BA508B7E91E81E128C1716DC3ACFE3084B2201E04CF8006617EECF1B640474A5D45CFDE9F4D3EF92D6D055B909892194D8A8218DB6D8203A84261D200D71473D7488F3427416B6896C137D455F231071CACBC86E0415AB88AEC841D96B7B8AF41E05BB461A40645BF176601F1E760DE5F\"),\n\t    SHEX(\"90457E3D33FCE103420056A1C712441E04856B17CF37A4E133841E6D9A944B5EBEF98CB1C1CCD575632CD3B5C177669E\"));\n  test_hash(&nettle_sha3_384, /* 239 octets */\n\t    SHEX(\"D782ABB72A5BE3392757BE02D3E45BE6E2099D6F000D042C8A543F50ED6EBC055A7F133B0DD8E9BC348536EDCAAE2E12EC18E8837DF7A1B3C87EC46D50C241DEE820FD586197552DC20BEEA50F445A07A38F1768A39E2B2FF05DDDEDF751F1DEF612D2E4D810DAA3A0CC904516F9A43AF660315385178A529E51F8AAE141808C8BC5D7B60CAC26BB984AC1890D0436EF780426C547E94A7B08F01ACBFC4A3825EAE04F520A9016F2FB8BF5165ED12736FC71E36A49A73614739EAA3EC834069B1B40F1350C2B3AB885C02C640B9F7686ED5F99527E41CFCD796FE4C256C9173186C226169FF257954EBDA81C0E5F99\"),\n\t    SHEX(\"E5FC73C70028D1B82A9AA976D34F5FC72916839027038E79DF2E29149E861F09A41A8203CE922203F710964B4F5BEC2E\"));\n  test_hash(&nettle_sha3_384, /* 240 octets */\n\t    SHEX(\"5FCE8109A358570E40983E1184E541833BB9091E280F258CFB144387B05D190E431CB19BAA67273BA0C58ABE91308E1844DCD0B3678BAA42F335F2FA05267A0240B3C718A5942B3B3E3BFA98A55C25A1466E8D7A603722CB2BBF03AFA54CD769A99F310735EE5A05DAE2C22D397BD95635F58C48A67F90E1B73AAFCD3F82117F0166657838691005B18DA6F341D6E90FC1CDB352B30FAE45D348294E501B63252DE14740F2B85AE5299DDEC3172DE8B6D0BA219A20A23BB5E10FF434D39DB3F583305E9F5C039D98569E377B75A70AB837D1DF269B8A4B566F40BB91B577455FD3C356C914FA06B9A7CE24C7317A172D\"),\n\t    SHEX(\"B0A1BBA912DAA6D80EDC6519B501B629456394D7BDA24D46AFC9FC1D93A0B5962FA4F95214273290D32B3EAEFF6F9DFE\"));\n  test_hash(&nettle_sha3_384, /* 241 octets */\n\t    SHEX(\"6172F1971A6E1E4E6170AFBAD95D5FEC99BF69B24B674BC17DD78011615E502DE6F56B86B1A71D3F4348087218AC7B7D09302993BE272E4A591968AEF18A1262D665610D1070EE91CC8DA36E1F841A69A7A682C580E836941D21D909A3AFC1F0B963E1CA5AB193E124A1A53DF1C587470E5881FB54DAE1B0D840F0C8F9D1B04C645BA1041C7D8DBF22030A623AA15638B3D99A2C400FF76F3252079AF88D2B37F35EE66C1AD7801A28D3D388AC450B97D5F0F79E4541755356B3B1A5696B023F39AB7AB5F28DF4202936BC97393B93BC915CB159EA1BD7A0A414CB4B7A1AC3AF68F50D79F0C9C7314E750F7D02FAA58BFA\"),\n\t    SHEX(\"FCE4637898BA0CBD9D7B636FEBDDC02A435901CBBEF8BF76D3E866D97D55354B71FC12E67A09E793D749316D714FE08C\"));\n  test_hash(&nettle_sha3_384, /* 242 octets */\n\t    SHEX(\"5668ECD99DFBE215C4118398AC9C9EAF1A1433FAB4CCDD3968064752B625EA944731F75D48A27D047D67547F14DD0FFAA55FA5E29F7AF0D161D85EAFC4F2029B717C918EAB9D304543290BDBA7158B68020C0BA4E079BC95B5BC0FC044A992B94B4CCD3BD66D0EABB5DBBAB904D62E00752C4E3B0091D773BCF4C14B4377DA3EFFF824B1CB2FA01B32D1E46C909E626ED2DAE920F4C7DBEB635BC754FACBD8D49BEBA3F23C1C41CCBFCD0EE0C114E69737F5597C0BF1D859F0C767E18002AE8E39C26261FFDE2920D3D0BAF0E906138696CFE5B7E32B600F45DF3AAA39932F3A7DF95B60FA8712A2271FCAF3911CE7B511B1\"),\n\t    SHEX(\"2B5471FAE3805852F4CF39541F8A0A3774818F79FE50476E225D89B62E43BE3255E96D19CBC334AEF04192840F075C7D\"));\n  test_hash(&nettle_sha3_384, /* 243 octets */\n\t    SHEX(\"03D625488354DF30E3F875A68EDFCF340E8366A8E1AB67F9D5C5486A96829DFAC0578289082B2A62117E1CF418B43B90E0ADC881FC6AE8105C888E9ECD21AEA1C9AE1A4038DFD17378FED71D02AE492087D7CDCD98F746855227967CB1AB4714261EE3BEAD3F4DB118329D3EBEF4BC48A875C19BA763966DA0EBEA800E01B2F50B00E9DD4CACA6DCB314D00184EF71EA2391D760C950710DB4A70F9212FFC54861F9DC752CE18867B8AD0C48DF8466EF7231E7AC567F0EB55099E622EBB86CB237520190A61C66AD34F1F4E289CB3282AE3EAAC6152ED24D2C92BAE5A7658252A53C49B7B02DFE54FDB2E90074B6CF310AC661\"),\n\t    SHEX(\"D4D3B49878AEC72E2E7FAFB687DA7EFE242CB60ADF5C65C577C444CFC95A2A2EC670000C8A78898A07400E3502D73F27\"));\n  test_hash(&nettle_sha3_384, /* 244 octets */\n\t    SHEX(\"2EDC282FFB90B97118DD03AAA03B145F363905E3CBD2D50ECD692B37BF000185C651D3E9726C690D3773EC1E48510E42B17742B0B0377E7DE6B8F55E00A8A4DB4740CEE6DB0830529DD19617501DC1E9359AA3BCF147E0A76B3AB70C4984C13E339E6806BB35E683AF8527093670859F3D8A0FC7D493BCBA6BB12B5F65E71E705CA5D6C948D66ED3D730B26DB395B3447737C26FAD089AA0AD0E306CB28BF0ACF106F89AF3745F0EC72D534968CCA543CD2CA50C94B1456743254E358C1317C07A07BF2B0ECA438A709367FAFC89A57239028FC5FECFD53B8EF958EF10EE0608B7F5CB9923AD97058EC067700CC746C127A61EE3\"),\n\t    SHEX(\"FE1C2143F2957819DF9C9DD05D004BE0E557EED8C5A2B7CE457D5856132B1C43EECEC36AD704A930A85485A34C3860FE\"));\n  test_hash(&nettle_sha3_384, /* 245 octets */\n\t    SHEX(\"90B28A6AA1FE533915BCB8E81ED6CACDC10962B7FF82474F845EEB86977600CF70B07BA8E3796141EE340E3FCE842A38A50AFBE90301A3BDCC591F2E7D9DE53E495525560B908C892439990A2CA2679C5539FFDF636777AD9C1CDEF809CDA9E8DCDB451ABB9E9C17EFA4379ABD24B182BD981CAFC792640A183B61694301D04C5B3EAAD694A6BD4CC06EF5DA8FA23B4FA2A64559C5A68397930079D250C51BCF00E2B16A6C49171433B0AADFD80231276560B80458DD77089B7A1BBCC9E7E4B9F881EACD6C92C4318348A13F4914EB27115A1CFC5D16D7FD94954C3532EFACA2CAB025103B2D02C6FD71DA3A77F417D7932685888A\"),\n\t    SHEX(\"4D1F626688E6899B5FCCD47FAAB45E96C61E169869CABEF40283B2418DFB2888FB80CC9F2C526497C50C5244784F195C\"));\n  test_hash(&nettle_sha3_384, /* 246 octets */\n\t    SHEX(\"2969447D175490F2AA9BB055014DBEF2E6854C95F8D60950BFE8C0BE8DE254C26B2D31B9E4DE9C68C9ADF49E4EE9B1C2850967F29F5D08738483B417BB96B2A56F0C8ACA632B552059C59AAC3F61F7B45C966B75F1D9931FF4E596406378CEE91AAA726A3A84C33F37E9CDBE626B5745A0B06064A8A8D56E53AAF102D23DD9DF0A3FDF7A638509A6761A33FA42FA8DDBD8E16159C93008B53765019C3F0E9F10B144CE2AC57F5D7297F9C9949E4FF68B70D339F87501CE8550B772F32C6DA8AD2CE2100A895D8B08FA1EEAD7C376B407709703C510B50F87E73E43F8E7348F87C3832A547EF2BBE5799ABEDCF5E1F372EA809233F006\"),\n\t    SHEX(\"A063D778B0A2A11D3A9CBA425EE5938FCAA6E2BF1F30A665FA811601444D5749AFA18766DB5F0426C5B8392238B7862E\"));\n  test_hash(&nettle_sha3_384, /* 247 octets */\n\t    SHEX(\"721645633A44A2C78B19024EAECF58575AB23C27190833C26875DC0F0D50B46AEA9C343D82EA7D5B3E50EC700545C615DAEAEA64726A0F05607576DCD396D812B03FB6551C641087856D050B10E6A4D5577B82A98AFB89CEE8594C9DC19E79FEFF0382FCFD127F1B803A4B9946F4AC9A4378E1E6E041B1389A53E3450CD32D9D2941B0CBABDB50DA8EA2513145164C3AB6BCBD251C448D2D4B087AC57A59C2285D564F16DA4ED5E607ED979592146FFB0EF3F3DB308FB342DF5EB5924A48256FC763141A278814C82D6D6348577545870AE3A83C7230AC02A1540FE1798F7EF09E335A865A2AE0949B21E4F748FB8A51F44750E213A8FB\"),\n\t    SHEX(\"470EE6D35157846890A01B3809EB923CC45DFFF2FCA2826F458325466C983B1C64BEA38BCAECA921C90DD00432ECCF89\"));\n  test_hash(&nettle_sha3_384, /* 248 octets */\n\t    SHEX(\"6B860D39725A14B498BB714574B4D37CA787404768F64C648B1751B353AC92BAC2C3A28EA909FDF0423336401A02E63EC24325300D823B6864BB701F9D7C7A1F8EC9D0AE3584AA6DD62EA1997CD831B4BABD9A4DA50932D4EFDA745C61E4130890E156AEE6113716DAF95764222A91187DB2EFFEA49D5D0596102D619BD26A616BBFDA8335505FBB0D90B4C180D1A2335B91538E1668F9F9642790B4E55F9CAB0FE2BDD2935D001EE6419ABAB5457880D0DBFF20ED8758F4C20FE759EFB33141CF0E892587FE8187E5FBC57786B7E8B089612C936DFC03D27EFBBE7C8673F1606BD51D5FF386F4A7AB68EDF59F385EB1291F117BFE717399\"),\n\t    SHEX(\"A8F0A3C89CF7E56ACC18ACE1638BCF133094FD9F75F05677C3CD0ED3614A593CBCEB09C78C86E350FD07FF4429A6A165\"));\n  test_hash(&nettle_sha3_384, /* 249 octets */\n\t    SHEX(\"6A01830AF3889A25183244DECB508BD01253D5B508AB490D3124AFBF42626B2E70894E9B562B288D0A2450CFACF14A0DDAE5C04716E5A0082C33981F6037D23D5E045EE1EF2283FB8B6378A914C5D9441627A722C282FF452E25A7EA608D69CEE4393A0725D17963D0342684F255496D8A18C2961145315130549311FC07F0312FB78E6077334F87EAA873BEE8AA95698996EB21375EB2B4EF53C14401207DEB4568398E5DD9A7CF97E8C9663E23334B46912F8344C19EFCF8C2BA6F04325F1A27E062B62A58D0766FC6DB4D2C6A1928604B0175D872D16B7908EBC041761187CC785526C2A3873FEAC3A642BB39F5351550AF9770C328AF7B\"),\n\t    SHEX(\"C8A9A24464F21B133EBE20BA421A81EE34DCEACD5F04DCFB66D219F7F4145633692C572B63007834A406ECFB938A14F6\"));\n  test_hash(&nettle_sha3_384, /* 250 octets */\n\t    SHEX(\"B3C5E74B69933C2533106C563B4CA20238F2B6E675E8681E34A389894785BDADE59652D4A73D80A5C85BD454FD1E9FFDAD1C3815F5038E9EF432AAC5C3C4FE840CC370CF86580A6011778BBEDAF511A51B56D1A2EB68394AA299E26DA9ADA6A2F39B9FAFF7FBA457689B9C1A577B2A1E505FDF75C7A0A64B1DF81B3A356001BF0DF4E02A1FC59F651C9D585EC6224BB279C6BEBA2966E8882D68376081B987468E7AED1EF90EBD090AE825795CDCA1B4F09A979C8DFC21A48D8A53CDBB26C4DB547FC06EFE2F9850EDD2685A4661CB4911F165D4B63EF25B87D0A96D3DFF6AB0758999AAD214D07BD4F133A6734FDE445FE474711B69A98F7E2B\"),\n\t    SHEX(\"91BADA31B57A4BF3D2EB19A34FF921DB10BD6406191486D25D5CA4DE5E00B5E2815DAE741064E5B877AC57511B949F91\"));\n  test_hash(&nettle_sha3_384, /* 251 octets */\n\t    SHEX(\"83AF34279CCB5430FEBEC07A81950D30F4B66F484826AFEE7456F0071A51E1BBC55570B5CC7EC6F9309C17BF5BEFDD7C6BA6E968CF218A2B34BD5CF927AB846E38A40BBD81759E9E33381016A755F699DF35D660007B5EADF292FEEFB735207EBF70B5BD17834F7BFA0E16CB219AD4AF524AB1EA37334AA66435E5D397FC0A065C411EBBCE32C240B90476D307CE802EC82C1C49BC1BEC48C0675EC2A6C6F3ED3E5B741D13437095707C565E10D8A20B8C20468FF9514FCF31B4249CD82DCEE58C0A2AF538B291A87E3390D737191A07484A5D3F3FB8C8F15CE056E5E5F8FEBE5E1FB59D6740980AA06CA8A0C20F5712B4CDE5D032E92AB89F0AE1\"),\n\t    SHEX(\"F310E80951C7BB6395CA168AAE7EC42DEFF6C4CD3F5BE9C8B49B85B405F731911AE8267FFEBD543DBDF409EC20A858D2\"));\n  test_hash(&nettle_sha3_384, /* 252 octets */\n\t    SHEX(\"A7ED84749CCC56BB1DFBA57119D279D412B8A986886D810F067AF349E8749E9EA746A60B03742636C464FC1EE233ACC52C1983914692B64309EDFDF29F1AB912EC3E8DA074D3F1D231511F5756F0B6EEAD3E89A6A88FE330A10FACE267BFFBFC3E3090C7FD9A850561F363AD75EA881E7244F80FF55802D5EF7A1A4E7B89FCFA80F16DF54D1B056EE637E6964B9E0FFD15B6196BDD7DB270C56B47251485348E49813B4EB9ED122A01B3EA45AD5E1A929DF61D5C0F3E77E1FDC356B63883A60E9CBB9FC3E00C2F32DBD469659883F690C6772E335F617BC33F161D6F6984252EE12E62B6000AC5231E0C9BC65BE223D8DFD94C5004A101AF9FD6C0FB\"),\n\t    SHEX(\"CFD05E080994FC6D7AEF2D8C6E44D8A5E90F5A231676E0FAE0D2B8CE162CA9D06712580C99997A7709A06180DD42FB91\"));\n  test_hash(&nettle_sha3_384, /* 253 octets */\n\t    SHEX(\"A6FE30DCFCDA1A329E82AB50E32B5F50EB25C873C5D2305860A835AECEE6264AA36A47429922C4B8B3AFD00DA16035830EDB897831C4E7B00F2C23FC0B15FDC30D85FB70C30C431C638E1A25B51CAF1D7E8B050B7F89BFB30F59F0F20FECFF3D639ABC4255B3868FC45DD81E47EB12AB40F2AAC735DF5D1DC1AD997CEFC4D836B854CEE9AC02900036F3867FE0D84AFFF37BDE3308C2206C62C4743375094108877C73B87B2546FE05EA137BEDFC06A2796274099A0D554DA8F7D7223A48CBF31B7DECAA1EBC8B145763E3673168C1B1B715C1CD99ECD3DDB238B06049885ECAD9347C2436DFF32C771F34A38587A44A82C5D3D137A03CAA27E66C8FF6\"),\n\t    SHEX(\"8FA26DD5A54BF94A037A165EC5CE3ED86147A08DCFE3B48818B0C0BEEEFA33B145323B598F761DE2B639D05127F1CF3E\"));\n  test_hash(&nettle_sha3_384, /* 254 octets */\n\t    SHEX(\"83167FF53704C3AA19E9FB3303539759C46DD4091A52DDAE9AD86408B69335989E61414BC20AB4D01220E35241EFF5C9522B079FBA597674C8D716FE441E566110B6211531CECCF8FD06BC8E511D00785E57788ED9A1C5C73524F01830D2E1148C92D0EDC97113E3B7B5CD3049627ABDB8B39DD4D6890E0EE91993F92B03354A88F52251C546E64434D9C3D74544F23FB93E5A2D2F1FB15545B4E1367C97335B0291944C8B730AD3D4789273FA44FB98D78A36C3C3764ABEEAC7C569C1E43A352E5B770C3504F87090DEE075A1C4C85C0C39CF421BDCC615F9EFF6CB4FE6468004AECE5F30E1ECC6DB22AD9939BB2B0CCC96521DFBF4AE008B5B46BC006E\"),\n\t    SHEX(\"283FD61D1E50572EF403BF9C554D76D694A54F902C49795D1CF506F0EE263E7BA994F72BDC4732531FA7194257F2DFDA\"));\n  test_hash(&nettle_sha3_384, /* 255 octets */\n\t    SHEX(\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\"),\n\t    SHEX(\"128DC611762BE9B135B3739484CFAADCA7481D68514F3DFD6F5D78BB1863AE68130835CDC7061A7ED964B32F1DB75EE1\"));\n}",
      "lines": 773,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha3-512-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        774,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* Extracted from ShortMsgKAT_512.txt using sha3.awk. */\n  test_hash(&nettle_sha3_512, /* 0 octets */\n\t    SHEX(\"\"),\n\t    SHEX(\"A69F73CCA23A9AC5C8B567DC185A756E97C982164FE25859E0D1DCC1475C80A615B2123AF1F5F94C11E3E9402C3AC558F500199D95B6D3E301758586281DCD26\"));\n  test_hash(&nettle_sha3_512, /* 1 octets */\n\t    SHEX(\"CC\"),\n\t    SHEX(\"3939FCC8B57B63612542DA31A834E5DCC36E2EE0F652AC72E02624FA2E5ADEECC7DD6BB3580224B4D6138706FC6E80597B528051230B00621CC2B22999EAA205\"));\n  test_hash(&nettle_sha3_512, /* 2 octets */\n\t    SHEX(\"41FB\"),\n\t    SHEX(\"AA092865A40694D91754DBC767B5202C546E226877147A95CB8B4C8F8709FE8CD6905256B089DA37896EA5CA19D2CD9AB94C7192FC39F7CD4D598975A3013C69\"));\n  test_hash(&nettle_sha3_512, /* 3 octets */\n\t    SHEX(\"1F877C\"),\n\t    SHEX(\"CB20DCF54955F8091111688BECCEF48C1A2F0D0608C3A575163751F002DB30F40F2F671834B22D208591CFAF1F5ECFE43C49863A53B3225BDFD7C6591BA7658B\"));\n  test_hash(&nettle_sha3_512, /* 4 octets */\n\t    SHEX(\"C1ECFDFC\"),\n\t    SHEX(\"D4B4BDFEF56B821D36F4F70AB0D231B8D0C9134638FD54C46309D14FADA92A2840186EED5415AD7CF3969BDFBF2DAF8CCA76ABFE549BE6578C6F4143617A4F1A\"));\n  test_hash(&nettle_sha3_512, /* 5 octets */\n\t    SHEX(\"21F134AC57\"),\n\t    SHEX(\"584219A84E8796076BF1178B14B9D1E2F96A4B4EF11F10CC516FBE1A29639D6BA74FB92815F9E3C5192ED4DCA20AEA5B109D52237C9956401FD44B221F82AB37\"));\n  test_hash(&nettle_sha3_512, /* 6 octets */\n\t    SHEX(\"C6F50BB74E29\"),\n\t    SHEX(\"4345B92A2AB7EADB6A24EE1D175AC258CCF2F694AC09EC9D47399E4D96F61F30B322C5438C51BACD0D597D00471A41ED8E9C9F146BBC807E6BC385F850FBABFE\"));\n  test_hash(&nettle_sha3_512, /* 7 octets */\n\t    SHEX(\"119713CC83EEEF\"),\n\t    SHEX(\"50081C93BF73ECC54A5FFE43FC14F8BAEEDBE7DA0302AC984C9E668389886BD064BAB26DDCB616EB4E0E726042B19F3FD50BDD0D2C5B34892E00E6F399DE254F\"));\n  test_hash(&nettle_sha3_512, /* 8 octets */\n\t    SHEX(\"4A4F202484512526\"),\n\t    SHEX(\"150D787D6EB49670C2A4CCD17E6CCE7A04C1FE30FCE03D1EF2501752D92AE04CB345FD42E51038C83B2B4F8FD438D1B4B55CC588C6B913132F1A658FB122CB52\"));\n  test_hash(&nettle_sha3_512, /* 9 octets */\n\t    SHEX(\"1F66AB4185ED9B6375\"),\n\t    SHEX(\"A13C951C6C51F236A0197A29A8994B1C7294E17BA518ED1029D6F54AD739D8765920281BBB854D16FBB60E0385AFD6E6E433E63AAA77E73B8BEE7FDE569D6875\"));\n  test_hash(&nettle_sha3_512, /* 10 octets */\n\t    SHEX(\"EED7422227613B6F53C9\"),\n\t    SHEX(\"5A566FB181BE53A4109275537D80E5FD0F314D68884529CA66B8B0E9F240A673B64B28FFFE4C1EC4A5CEF0F430229C5757EBD172B4B0B68A81D8C58A9E96E164\"));\n  test_hash(&nettle_sha3_512, /* 11 octets */\n\t    SHEX(\"EAEED5CDFFD89DECE455F1\"),\n\t    SHEX(\"7C77E30ECE98EF88964458683C5E0287B5896E166CCCA71D2BFD8D8BBC6D6FE589A0225EB1D6AA7B220F1410C9A9EC0672CCDDAA1732C3E2877FB5D232C2A428\"));\n  test_hash(&nettle_sha3_512, /* 12 octets */\n\t    SHEX(\"5BE43C90F22902E4FE8ED2D3\"),\n\t    SHEX(\"F5DF5952924E933330BD5BD7627A62C3672F24A4991DADAF78816E023769C91D1910537F9C19FCDE60FA6DE927982DD5F5970F74E30F2B040F67348A3394C48C\"));\n  test_hash(&nettle_sha3_512, /* 13 octets */\n\t    SHEX(\"A746273228122F381C3B46E4F1\"),\n\t    SHEX(\"80A1317EC534ED48D8A813E0BCA0CEE04F705A2F86352306A932EDC548B9A8F1CF79F95027F43BDADA8213449C54F68F4DD800B15C4ABAD87AD7A3B371A7C918\"));\n  test_hash(&nettle_sha3_512, /* 14 octets */\n\t    SHEX(\"3C5871CD619C69A63B540EB5A625\"),\n\t    SHEX(\"54C274C3DDF26D824F5FDFCB349A600890057EB2E2022245CBB8BDC0D2240CFA8348F02191FABC0E10F9287185211C9F569132EE6DDE4C396668B4BB50AEFC3F\"));\n  test_hash(&nettle_sha3_512, /* 15 octets */\n\t    SHEX(\"FA22874BCC068879E8EF11A69F0722\"),\n\t    SHEX(\"00767236A7352551B283A8ECF4C79274F8C4CEA553AB43FC71CF22FB2F6865AD02C88BF0092F213057340C85A5318F62F4991C00C63CB0558CBCF13D6D84E73D\"));\n  test_hash(&nettle_sha3_512, /* 16 octets */\n\t    SHEX(\"52A608AB21CCDD8A4457A57EDE782176\"),\n\t    SHEX(\"001618372E75147AF90C0CF16C3BBDAA069DDBC62483B392D028DED49F75084A5DFCC53AECD9F57DDBB73DAA041FD71089D8FB5EDF6CFAF6F1E4E25AD3DE266C\"));\n  test_hash(&nettle_sha3_512, /* 17 octets */\n\t    SHEX(\"82E192E4043DDCD12ECF52969D0F807EED\"),\n\t    SHEX(\"9644E3C90B67E22124E96DFEDCE53D33C460F132868F0975D18B22CFD59F637DD85AA405E39808A45570A498C0B8F2CBA59F8E1437EAEF89F20B88298ADFA2DE\"));\n  test_hash(&nettle_sha3_512, /* 18 octets */\n\t    SHEX(\"75683DCB556140C522543BB6E9098B21A21E\"),\n\t    SHEX(\"4739994390728F4A938DF7B3201CD63771858453F0FF1DDE9A2B9C38A27A0F6C868460D00EE03DDCB0F063F5F8BB7CB0959B7A222259DA0F2C57FA400B50985B\"));\n  test_hash(&nettle_sha3_512, /* 19 octets */\n\t    SHEX(\"06E4EFE45035E61FAAF4287B4D8D1F12CA97E5\"),\n\t    SHEX(\"AF69A46527C17117E6DFF32CBA289EDDD1EECDA13E5313E46678EB8006E7639854C3970DFEB4D907DB1151C1C5EE25CA6F195B09CA5A5CC97A4D64AC4C75578E\"));\n  test_hash(&nettle_sha3_512, /* 20 octets */\n\t    SHEX(\"E26193989D06568FE688E75540AEA06747D9F851\"),\n\t    SHEX(\"191CEF1C6AA009B1ABA674BE2B3F0DA418FDF9E6A7ECF2BE42AC14F7D6E07331425133A83B4E0161CC7DEBF9DCD7FE3787DCB6622A38475189EDFE1DE6B053D6\"));\n  test_hash(&nettle_sha3_512, /* 21 octets */\n\t    SHEX(\"D8DC8FDEFBDCE9D44E4CBAFE78447BAE3B5436102A\"),\n\t    SHEX(\"A60D7587424B7242D93BCCE515F1C75AE2BE7710F72ED3F4E5EA8BC2BA8D64099FE42B88A295E12FDAFAB441D772C4A9A7D794B27788EDEA271571A04305F253\"));\n  test_hash(&nettle_sha3_512, /* 22 octets */\n\t    SHEX(\"57085FD7E14216AB102D8317B0CB338A786D5FC32D8F\"),\n\t    SHEX(\"09FCAD97EA3CB6B7FC61580DE0968D238006B7E71F0BD58ABA2AA9D4ADB855D7606E7632138CCC0AA065CA0B92422262E029DA17D73CD3011FF285706C7FC1AE\"));\n  test_hash(&nettle_sha3_512, /* 23 octets */\n\t    SHEX(\"A05404DF5DBB57697E2C16FA29DEFAC8AB3560D6126FA0\"),\n\t    SHEX(\"F61FAAB080CF9A5F75407B081A03DEF4F49A601A2BB832E8C6401BE0C98B3CEB3F75C922A91BD5060B3217F737404EF4612B9A009B69CA648B1E37B2ED49229D\"));\n  test_hash(&nettle_sha3_512, /* 24 octets */\n\t    SHEX(\"AECBB02759F7433D6FCB06963C74061CD83B5B3FFA6F13C6\"),\n\t    SHEX(\"51DE0A622FC6FC702C7C2DB5CCB05CA0DDF792986E44B4D336A7A5DAF19A20A371D9BF7DDE822ECDD0A4CE28E4A0B46FE51A2AABEFA7865807EF3D3B1887F14D\"));\n  test_hash(&nettle_sha3_512, /* 25 octets */\n\t    SHEX(\"AAFDC9243D3D4A096558A360CC27C8D862F0BE73DB5E88AA55\"),\n\t    SHEX(\"6286C3DB87D3B45CFD4DE85A7ADD18E07AE22F1F0F4675E1D4E1FC77633734D7962818A9F3B96B37FE774FC26DEA787485317B9622275F63A7DD6D62D650D307\"));\n  test_hash(&nettle_sha3_512, /* 26 octets */\n\t    SHEX(\"7BC84867F6F9E9FDC3E1046CAE3A52C77ED485860EE260E30B15\"),\n\t    SHEX(\"8146C43A0FFE481872142F56A9CEA44332EDC76B4E99C2BDC39D7F80B2A6B554C7598F09855BF7ABC5E6C048BE76F5F369EBB2884E6E37F186E8719DF3D523E4\"));\n  test_hash(&nettle_sha3_512, /* 27 octets */\n\t    SHEX(\"FAC523575A99EC48279A7A459E98FF901918A475034327EFB55843\"),\n\t    SHEX(\"4B86FBF9DFB6767EB660AF9C30983ED65B6FD051247AB54767DFB49530EB3C01014EB26DF63E536CF55E0BCE2F62654FB2FCE3839B4BFD301570B1AB794DF67D\"));\n  test_hash(&nettle_sha3_512, /* 28 octets */\n\t    SHEX(\"0F8B2D8FCFD9D68CFFC17CCFB117709B53D26462A3F346FB7C79B85E\"),\n\t    SHEX(\"21132FC11F6040AD493D627027C752CE29816589DE7BE78562914B63D1A9219803DDBD9673AA749F37FF4D6E1B5AE2A12633BA8B0C9994E031EBF6C42E58A793\"));\n  test_hash(&nettle_sha3_512, /* 29 octets */\n\t    SHEX(\"A963C3E895FF5A0BE4824400518D81412F875FA50521E26E85EAC90C04\"),\n\t    SHEX(\"8A5374D92FF9A58E0451E609AA5C0C5C172BB2068C80562D0324F9CB6A037436910C6593F950C44374B4E5BF6F6D3A436ECE6DAAEB56D147D8CD839CCA35EAC3\"));\n  test_hash(&nettle_sha3_512, /* 30 octets */\n\t    SHEX(\"03A18688B10CC0EDF83ADF0A84808A9718383C4070C6C4F295098699AC2C\"),\n\t    SHEX(\"71025D089A39D27327C46C27BD4E7565DDBF9C286F185A08178601C3BAB4667F368A3A8BDDACF25B2B0AA5C9E0CD6C87DC32C854027A8954B5C6AFD3A85097AC\"));\n  test_hash(&nettle_sha3_512, /* 31 octets */\n\t    SHEX(\"84FB51B517DF6C5ACCB5D022F8F28DA09B10232D42320FFC32DBECC3835B29\"),\n\t    SHEX(\"DC29EB7130812A652AF3FF9B77629684634502EA6667E7E9F80090EC2A9D690C8C9A78645FB04D9CD269E706EE2C96E74207FBBDA559DC285C9BC52F15A256CA\"));\n  test_hash(&nettle_sha3_512, /* 32 octets */\n\t    SHEX(\"9F2FCC7C90DE090D6B87CD7E9718C1EA6CB21118FC2D5DE9F97E5DB6AC1E9C10\"),\n\t    SHEX(\"B087C90421AEBF87911647DE9D465CBDA166B672EC47CCD4054A7135A1EF885E7903B52C3F2C3FE722B1C169297A91B82428956A02C631A2240F12162C7BC726\"));\n  test_hash(&nettle_sha3_512, /* 33 octets */\n\t    SHEX(\"DE8F1B3FAA4B7040ED4563C3B8E598253178E87E4D0DF75E4FF2F2DEDD5A0BE046\"),\n\t    SHEX(\"D2A95C6FC0F39C8F7A86C4DD6261A79C940FCB313BCFBA9BF71527F5BC70EF827CD97DFA18280E5DDEE5CCBC1D63CE88CE2BCDD82DAB610F79867A7C20B11E4F\"));\n  test_hash(&nettle_sha3_512, /* 34 octets */\n\t    SHEX(\"62F154EC394D0BC757D045C798C8B87A00E0655D0481A7D2D9FB58D93AEDC676B5A0\"),\n\t    SHEX(\"AF8C0FBD72B3F807DB95C9231BC4E93153DC6608B22F4707316AAB3D69AF0E63291B569F118B5C9E693C5BAC4630C4A923A4743581246AD3446DDA4F9076FDDB\"));\n  test_hash(&nettle_sha3_512, /* 35 octets */\n\t    SHEX(\"B2DCFE9FF19E2B23CE7DA2A4207D3E5EC7C6112A8A22AEC9675A886378E14E5BFBAD4E\"),\n\t    SHEX(\"BFC7D968D45342069807C5F1B96425CFFFE99ED136D47665E902E026C118701BB7C3E7FD691785115CFDB2EF235A66BCC1384A1D088B8CCA90D9D560913549DE\"));\n  test_hash(&nettle_sha3_512, /* 36 octets */\n\t    SHEX(\"47F5697AC8C31409C0868827347A613A3562041C633CF1F1F86865A576E02835ED2C2492\"),\n\t    SHEX(\"9A348540AB669CDD8914426FBBAD192BA0DB16583E8D4E867B66CC78C6496E4D83DDBF7B972B0668DF7903B0FE9AB82B65153F947CF2AF2591121C9D1A78E515\"));\n  test_hash(&nettle_sha3_512, /* 37 octets */\n\t    SHEX(\"512A6D292E67ECB2FE486BFE92660953A75484FF4C4F2ECA2B0AF0EDCDD4339C6B2EE4E542\"),\n\t    SHEX(\"FFDB649D1AA7FF269B9BB0AE6192F7BCBC06612528DF0E68521D5C891E9BBA129271A07DC56393BB21218F5E2FB92CFFF833432066AA6380F3557A0748E65B33\"));\n  test_hash(&nettle_sha3_512, /* 38 octets */\n\t    SHEX(\"973CF2B4DCF0BFA872B41194CB05BB4E16760A1840D8343301802576197EC19E2A1493D8F4FB\"),\n\t    SHEX(\"9665808D39B4BECFDD9AA8020A0A72CFD4F823A15D670D51278A4AE95507E16020AEDED6E6C0E2DAB0BAD890A9E7552403D2AA8D1EBC0B8EAEC9A3A8DBB2A9EF\"));\n  test_hash(&nettle_sha3_512, /* 39 octets */\n\t    SHEX(\"80BEEBCD2E3F8A9451D4499961C9731AE667CDC24EA020CE3B9AA4BBC0A7F79E30A934467DA4B0\"),\n\t    SHEX(\"7ABA6B9F8F18D9D72B883EB988A5F4FFCC0217A3DA316AFF11B38976E90B0736CB000F522DBF2DDCBB61BA4BF44C356EC5B46FC86A5133F971A94FE2A9983260\"));\n  test_hash(&nettle_sha3_512, /* 40 octets */\n\t    SHEX(\"7ABAA12EC2A7347674E444140AE0FB659D08E1C66DECD8D6EAE925FA451D65F3C0308E29446B8ED3\"),\n\t    SHEX(\"589C46625A6AC9A2C9C9A884F427C3C032887AE53A69932B72E1E3796BB9568929D163395A3AA8B2AB23C564937CD729206D9B62CC60353B68A69A739616EB35\"));\n  test_hash(&nettle_sha3_512, /* 41 octets */\n\t    SHEX(\"C88DEE9927679B8AF422ABCBACF283B904FF31E1CAC58C7819809F65D5807D46723B20F67BA610C2B7\"),\n\t    SHEX(\"F7CD8737A1AB36B37612E57D1E5A3D4A269D18CF2CB7644A12540E3B184631794EC1A1DA118A109AEF514DB3590FE27BE0752EC0826ACAF458FB0A754BDC51F1\"));\n  test_hash(&nettle_sha3_512, /* 42 octets */\n\t    SHEX(\"01E43FE350FCEC450EC9B102053E6B5D56E09896E0DDD9074FE138E6038210270C834CE6EADC2BB86BF6\"),\n\t    SHEX(\"B21BDEDE484CA18F672058667CB2F2DC922C44351E95C2CDA75AF7E45577BF50E3F203139F6262279ADFC3221B94A072641F8BDB55DCC02F21D0879EB5E7466A\"));\n  test_hash(&nettle_sha3_512, /* 43 octets */\n\t    SHEX(\"337023370A48B62EE43546F17C4EF2BF8D7ECD1D49F90BAB604B839C2E6E5BD21540D29BA27AB8E309A4B7\"),\n\t    SHEX(\"DB56265B9346968A390E9841D5B7878A158BAED946068E808E456735A67E49220FAB66239D5D506DD75A58F2C56E25C9C105A3827C1434C67255CFC9101A5D09\"));\n  test_hash(&nettle_sha3_512, /* 44 octets */\n\t    SHEX(\"6892540F964C8C74BD2DB02C0AD884510CB38AFD4438AF31FC912756F3EFEC6B32B58EBC38FC2A6B913596A8\"),\n\t    SHEX(\"4C825FD9A795CCD20A0892DA1572B9B1F70BA05FF2D2DA3A4726A74F9AB5323CCBC4290459C1BB46F0A1E1FFC357FF4766F4F4879DAA91D31ECA986AA30C7B00\"));\n  test_hash(&nettle_sha3_512, /* 45 octets */\n\t    SHEX(\"F5961DFD2B1FFFFDA4FFBF30560C165BFEDAB8CE0BE525845DEB8DC61004B7DB38467205F5DCFB34A2ACFE96C0\"),\n\t    SHEX(\"8445A05766A30DDD0080589F8E8CBF7EC59FB7A3CE73C0209791B19CF712CF1635D63C8356822272309C6B9F01637088878DBFFBEDB26D2A566185225C4DA56B\"));\n  test_hash(&nettle_sha3_512, /* 46 octets */\n\t    SHEX(\"CA061A2EB6CEED8881CE2057172D869D73A1951E63D57261384B80CEB5451E77B06CF0F5A0EA15CA907EE1C27EBA\"),\n\t    SHEX(\"2DC25165CF317ED7DE2B4F2FD0995D7785978CA8581EA8033E912F2E44EE613DEBFC5535C48D63838F325D1416B9180C20BDE82614504B7161F9860530ECA70C\"));\n  test_hash(&nettle_sha3_512, /* 47 octets */\n\t    SHEX(\"1743A77251D69242750C4F1140532CD3C33F9B5CCDF7514E8584D4A5F9FBD730BCF84D0D4726364B9BF95AB251D9BB\"),\n\t    SHEX(\"CB6110A02D7CA636463F6E3502CCF0173B000482C7E002AD9277C1D10317BDDEBC3DA7F91D0173E3E2F9552BDFDEA4DD1AFBF7508B096AAB1804921E95754E78\"));\n  test_hash(&nettle_sha3_512, /* 48 octets */\n\t    SHEX(\"D8FABA1F5194C4DB5F176FABFFF856924EF627A37CD08CF55608BBA8F1E324D7C7F157298EABC4DCE7D89CE5162499F9\"),\n\t    SHEX(\"7EF3A2894C6ECBC4201B15348F90671515ACCBA3C8166621F864A9184BF08C3F5A895F6B599D3CB41F20A8A1DF25AE84F1A6D7C8DE74FB7CEF48F7E96FDE8D43\"));\n  test_hash(&nettle_sha3_512, /* 49 octets */\n\t    SHEX(\"BE9684BE70340860373C9C482BA517E899FC81BAAA12E5C6D7727975D1D41BA8BEF788CDB5CF4606C9C1C7F61AED59F97D\"),\n\t    SHEX(\"39C7AE0F80129D9D2980A6246E2B6F10A39EFAFD694DED12A6089509D95ECE506DC38C0A9DE487D9D401DB1F15193404911069533BCAE4C48C53F27BEE3CE0AC\"));\n  test_hash(&nettle_sha3_512, /* 50 octets */\n\t    SHEX(\"7E15D2B9EA74CA60F66C8DFAB377D9198B7B16DEB6A1BA0EA3C7EE2042F89D3786E779CF053C77785AA9E692F821F14A7F51\"),\n\t    SHEX(\"9B8A7D2F8519AD6DC3D2BC5B696B354C5A8B4796402CE1242C52638EEA6893A1269820A642BC9EFE56CD7E26DC46E97A7FC58FAF3F1A7A25F86ECDC1F2F17E64\"));\n  test_hash(&nettle_sha3_512, /* 51 octets */\n\t    SHEX(\"9A219BE43713BD578015E9FDA66C0F2D83CAC563B776AB9F38F3E4F7EF229CB443304FBA401EFB2BDBD7ECE939102298651C86\"),\n\t    SHEX(\"B5CEEF23F56BE807B616C7FDA4867A1D12D0A16845459FC704CE631AD3279AB222DCA7ADDAE595D289CBA8996D46655FA9B6BE58700302E655C51C825F31BB2E\"));\n  test_hash(&nettle_sha3_512, /* 52 octets */\n\t    SHEX(\"C8F2B693BD0D75EF99CAEBDC22ADF4088A95A3542F637203E283BBC3268780E787D68D28CC3897452F6A22AA8573CCEBF245972A\"),\n\t    SHEX(\"143D024FA75C8D46273589B8F78432D49EF14178E4AAA27DC366C9CB787F24B73F4197A722F13031181A6FA6E4F66127893DA7B23A579BB93FE7D737A4194093\"));\n  test_hash(&nettle_sha3_512, /* 53 octets */\n\t    SHEX(\"EC0F99711016C6A2A07AD80D16427506CE6F441059FD269442BAAA28C6CA037B22EEAC49D5D894C0BF66219F2C08E9D0E8AB21DE52\"),\n\t    SHEX(\"0F48D008DD3AA630E8261658A55B565B6773992426B08592B4C1D77A58B067F05E25974E501628A2DB632F2DDDD73673119ADA5674D0CE92C7AA908B9E9C435E\"));\n  test_hash(&nettle_sha3_512, /* 54 octets */\n\t    SHEX(\"0DC45181337CA32A8222FE7A3BF42FC9F89744259CFF653504D6051FE84B1A7FFD20CB47D4696CE212A686BB9BE9A8AB1C697B6D6A33\"),\n\t    SHEX(\"297498639FC7AA4152654E468E08F29AFFD7061D44E3F532BE4BAC169C877A2EA7B4D70D6BC0F678BE08AA064258EF57111310D13B889712D06530B690841DBE\"));\n  test_hash(&nettle_sha3_512, /* 55 octets */\n\t    SHEX(\"DE286BA4206E8B005714F80FB1CDFAEBDE91D29F84603E4A3EBC04686F99A46C9E880B96C574825582E8812A26E5A857FFC6579F63742F\"),\n\t    SHEX(\"1B6DA16151FCD18383372683480119A304796B2A5E54F7EDC6C7BC86817359E73F6FC5587C77BFC71B56EC67905FA7F15193F9F13CFA190BC7B05503A5782C8A\"));\n  test_hash(&nettle_sha3_512, /* 56 octets */\n\t    SHEX(\"EEBCC18057252CBF3F9C070F1A73213356D5D4BC19AC2A411EC8CDEEE7A571E2E20EAF61FD0C33A0FFEB297DDB77A97F0A415347DB66BCAF\"),\n\t    SHEX(\"B2F40935E7C9018814C4E2721D9B5AEEED3370690378E472BD29F227442CA4942B06189C346FDA498123ECE59018E42C8B7EE38191F97789B4AA93223A8D80EF\"));\n  test_hash(&nettle_sha3_512, /* 57 octets */\n\t    SHEX(\"416B5CDC9FE951BD361BD7ABFC120A5054758EBA88FDD68FD84E39D3B09AC25497D36B43CBE7B85A6A3CEBDA8DB4E5549C3EE51BB6FCB6AC1E\"),\n\t    SHEX(\"C8D242FB5FF1C6CD11A040AEAF35CC09E355A975E04DED1D8341878BED5DFF8BBBD1B69F4D122CE53309AC08753B95D2A57721DFD12E70A8EF12E11E16DE0FD9\"));\n  test_hash(&nettle_sha3_512, /* 58 octets */\n\t    SHEX(\"5C5FAF66F32E0F8311C32E8DA8284A4ED60891A5A7E50FB2956B3CBAA79FC66CA376460E100415401FC2B8518C64502F187EA14BFC9503759705\"),\n\t    SHEX(\"D1D5D5DD7D196B87BE4A38F2D9B4A69DF9DFE0A6E8CE71B08CF22C7F670ECF273EAF395D12FC63E1741DEF113CC7104970194A7C7C807E5319D7BB702F20B568\"));\n  test_hash(&nettle_sha3_512, /* 59 octets */\n\t    SHEX(\"7167E1E02BE1A7CA69D788666F823AE4EEF39271F3C26A5CF7CEE05BCA83161066DC2E217B330DF821103799DF6D74810EED363ADC4AB99F36046A\"),\n\t    SHEX(\"D812470B2D135B6E1BC0C85DC0652BF9F6C2F9EE707A2E667181CC9F689BC7DF9CC999B08716868AFAC78244B151B725A027D9250AB7A073A469E7F09BDB0B55\"));\n  test_hash(&nettle_sha3_512, /* 60 octets */\n\t    SHEX(\"2FDA311DBBA27321C5329510FAE6948F03210B76D43E7448D1689A063877B6D14C4F6D0EAA96C150051371F7DD8A4119F7DA5C483CC3E6723C01FB7D\"),\n\t    SHEX(\"203EF6BB5132A9D44EAE93C7202B1469C2C2B93706D0A31B29223C411A39550F60F39B9556FD040BFB5F9F7099313B8874C8ED677CFC5F93D9A2941A9B0139DE\"));\n  test_hash(&nettle_sha3_512, /* 61 octets */\n\t    SHEX(\"95D1474A5AAB5D2422ACA6E481187833A6212BD2D0F91451A67DD786DFC91DFED51B35F47E1DEB8A8AB4B9CB67B70179CC26F553AE7B569969CE151B8D\"),\n\t    SHEX(\"23BEAD09707A77B295FD22FE001282338C2D368302A05FB114BA2A012C4DEFCF06F3887D6DB7A0A1DE04BC399BDE92D6BE71904A9AA7B92BEDFA0203F1D8B06F\"));\n  test_hash(&nettle_sha3_512, /* 62 octets */\n\t    SHEX(\"C71BD7941F41DF044A2927A8FF55B4B467C33D089F0988AA253D294ADDBDB32530C0D4208B10D9959823F0C0F0734684006DF79F7099870F6BF53211A88D\"),\n\t    SHEX(\"93A8DB85774B321090801DF4DC3CC75E94AF63FF6DCF50BD210E5B65FB35E1BEAEDED55602EB32380726029834982D77B434E94179D0A3EE1059345910EE1DCC\"));\n  test_hash(&nettle_sha3_512, /* 63 octets */\n\t    SHEX(\"F57C64006D9EA761892E145C99DF1B24640883DA79D9ED5262859DCDA8C3C32E05B03D984F1AB4A230242AB6B78D368DC5AAA1E6D3498D53371E84B0C1D4BA\"),\n\t    SHEX(\"3B7D98FF3152B2024AAD4FA0B40DC642E842D453305ECEF278574E386172F3C164E4EFB9C2951A23FC73D83C16B4900FB92AEB8EFE06B58F918BC4A481E4C238\"));\n  test_hash(&nettle_sha3_512, /* 64 octets */\n\t    SHEX(\"E926AE8B0AF6E53176DBFFCC2A6B88C6BD765F939D3D178A9BDE9EF3AA131C61E31C1E42CDFAF4B4DCDE579A37E150EFBEF5555B4C1CB40439D835A724E2FAE7\"),\n\t    SHEX(\"EB5067BF762A291CF258AD69A816A0B089E0BD44F8E5B74CF60BCE64734E59853CCB8D091CD2E33F90AA063FB7942CF5965D459200144C1A0801ABD69A9A094A\"));\n  test_hash(&nettle_sha3_512, /* 65 octets */\n\t    SHEX(\"16E8B3D8F988E9BB04DE9C96F2627811C973CE4A5296B4772CA3EEFEB80A652BDF21F50DF79F32DB23F9F73D393B2D57D9A0297F7A2F2E79CFDA39FA393DF1AC00\"),\n\t    SHEX(\"B0E23D600BA4215F79D50047BBFED50DF7D6E769514D796AFD166DEECA88BD1CBE0AFC72A41E0317A223225B4F5882F723AFCBA3AF7C457EB525946DA6C53BB0\"));\n  test_hash(&nettle_sha3_512, /* 66 octets */\n\t    SHEX(\"FC424EEB27C18A11C01F39C555D8B78A805B88DBA1DC2A42ED5E2C0EC737FF68B2456D80EB85E11714FA3F8EABFB906D3C17964CB4F5E76B29C1765DB03D91BE37FC\"),\n\t    SHEX(\"83021062117DA99327E521D7C91331208BF3F0A972A6C755ECA46760C0984871FE03724A51FB5441C3CDD3D24FA1B8127510D6A42CFE18B08E8096ED702EF33C\"));\n  test_hash(&nettle_sha3_512, /* 67 octets */\n\t    SHEX(\"ABE3472B54E72734BDBA7D9158736464251C4F21B33FBBC92D7FAC9A35C4E3322FF01D2380CBAA4EF8FB07D21A2128B7B9F5B6D9F34E13F39C7FFC2E72E47888599BA5\"),\n\t    SHEX(\"BCA9F06B6B9AB8F76C4F3DBE677D5B4B3103423644484C77CDD8C5DD6C1A0BF717C76E83DA9B2B4EDFE4CC133C1FC86396E8C3A9E42FDD20519FCAA19969189F\"));\n  test_hash(&nettle_sha3_512, /* 68 octets */\n\t    SHEX(\"36F9F0A65F2CA498D739B944D6EFF3DA5EBBA57E7D9C41598A2B0E4380F3CF4B479EC2348D015FFE6256273511154AFCF3B4B4BF09D6C4744FDD0F62D75079D440706B05\"),\n\t    SHEX(\"DCDF7617F79DA8475B3A4DB1306C9CAF87F1AE85EC97721892D8E20D0E54EC82EE7A0F2D17F21A61AECD89A6C4CF5019D7B8077447EFE03DEF5208010A8A1E84\"));\n  test_hash(&nettle_sha3_512, /* 69 octets */\n\t    SHEX(\"ABC87763CAE1CA98BD8C5B82CABA54AC83286F87E9610128AE4DE68AC95DF5E329C360717BD349F26B872528492CA7C94C2C1E1EF56B74DBB65C2AC351981FDB31D06C77A4\"),\n\t    SHEX(\"9B8C7142180F0ED85359B6D186AE05B77B2DB7C3E1F066392E733B7EEFFD7C11F7A6C0C570273A1F3FEA1A0929D017C7A4FA00175B5ABA76861BCA7EE806458B\"));\n  test_hash(&nettle_sha3_512, /* 70 octets */\n\t    SHEX(\"94F7CA8E1A54234C6D53CC734BB3D3150C8BA8C5F880EAB8D25FED13793A9701EBE320509286FD8E422E931D99C98DA4DF7E70AE447BAB8CFFD92382D8A77760A259FC4FBD72\"),\n\t    SHEX(\"3AB73A0A75B997C0EE8329C33E6EF1389E9821711867F775AF29517EDFFBE410D037143C6431FDED3D8CE728086C3512E94F038B9243B50CB820DC2445535D91\"));\n  test_hash(&nettle_sha3_512, /* 71 octets */\n\t    SHEX(\"13BD2811F6ED2B6F04FF3895ACEED7BEF8DCD45EB121791BC194A0F806206BFFC3B9281C2B308B1A729CE008119DD3066E9378ACDCC50A98A82E20738800B6CDDBE5FE9694AD6D\"),\n\t    SHEX(\"DEF4AB6CDA8839729A03E000846604B17F03C5D5D7EC23C483670A13E11573C1E9347A63EC69A5ABB21305F9382ECDAAABC6850F92840E86F88F4DABFCD93CC0\"));\n  test_hash(&nettle_sha3_512, /* 72 octets */\n\t    SHEX(\"1EED9CBA179A009EC2EC5508773DD305477CA117E6D569E66B5F64C6BC64801CE25A8424CE4A26D575B8A6FB10EAD3FD1992EDDDEEC2EBE7150DC98F63ADC3237EF57B91397AA8A7\"),\n\t    SHEX(\"A3E168B0D6C143EE9E17EAE92930B97E6600356B73AEBB5D68005DD1D07494451A37052F7B39FF030C1AE1D7EFC4E0C3667EB7A76C627EC14354C4F6A796E2C6\"));\n  test_hash(&nettle_sha3_512, /* 73 octets */\n\t    SHEX(\"BA5B67B5EC3A3FFAE2C19DD8176A2EF75C0CD903725D45C9CB7009A900C0B0CA7A2967A95AE68269A6DBF8466C7B6844A1D608AC661F7EFF00538E323DB5F2C644B78B2D48DE1A08AA\"),\n\t    SHEX(\"635741B37F66CD5CE4DBD1F78ACCD907F96146E770B239046AFB9181910B612D0E65841FF866806EED83C3AE7012FC55E42C3FFC9C6E3D03CE2870442F293AB4\"));\n  test_hash(&nettle_sha3_512, /* 74 octets */\n\t    SHEX(\"0EFA26AC5673167DCACAB860932ED612F65FF49B80FA9AE65465E5542CB62075DF1C5AE54FBA4DB807BE25B070033EFA223BDD5B1D3C94C6E1909C02B620D4B1B3A6C9FED24D70749604\"),\n\t    SHEX(\"D6299A21CB1B31F0A6EB67D82D4E738249013B75C9BCB4A4FE419036A6043A7103E9CA9B7D25759177C4B64001377093CF39F35C9B1625C6819369FA375FA49D\"));\n  test_hash(&nettle_sha3_512, /* 75 octets */\n\t    SHEX(\"BBFD933D1FD7BF594AC7F435277DC17D8D5A5B8E4D13D96D2F64E771ABBD51A5A8AEA741BECCBDDB177BCEA05243EBD003CFDEAE877CCA4DA94605B67691919D8B033F77D384CA01593C1B\"),\n\t    SHEX(\"07F0A184734BA4BB721F36D7B1B383F6BF99CD5F75941ECF1FF2B325F03AF970D1DB1F035975702093F59A7610BF054D12017ECD6109177CF061AB1496F87860\"));\n  test_hash(&nettle_sha3_512, /* 76 octets */\n\t    SHEX(\"90078999FD3C35B8AFBF4066CBDE335891365F0FC75C1286CDD88FA51FAB94F9B8DEF7C9AC582A5DBCD95817AFB7D1B48F63704E19C2BAA4DF347F48D4A6D603013C23F1E9611D595EBAC37C\"),\n\t    SHEX(\"89070B8B1E322CCF9D6307EDC11FC34E13874C4977DA9F6035D06FAF647D7F7D54B8250B541744298AACD4C54D9B41B4085DD35C491A461D504BDB42FC12F03C\"));\n  test_hash(&nettle_sha3_512, /* 77 octets */\n\t    SHEX(\"64105ECA863515C20E7CFBAA0A0B8809046164F374D691CDBD6508AAABC1819F9AC84B52BAFC1B0FE7CDDBC554B608C01C8904C669D8DB316A0953A4C68ECE324EC5A49FFDB59A1BD6A292AA0E\"),\n\t    SHEX(\"6C3FBE32556445DAD430CF15FE1243B6AB44349EEC2BE1132B0680E5EDF0B08B55F1ABE473439C5E0750132996195FD120C267B9100C47777B339132EC34CC80\"));\n  test_hash(&nettle_sha3_512, /* 78 octets */\n\t    SHEX(\"D4654BE288B9F3B711C2D02015978A8CC57471D5680A092AA534F7372C71CEAAB725A383C4FCF4D8DEAA57FCA3CE056F312961ECCF9B86F14981BA5BED6AB5B4498E1F6C82C6CAE6FC14845B3C8A\"),\n\t    SHEX(\"6AE3E656CF94DB10AE3C185362A6625CEC53E0BA4DC7D1608A3F2FCA3C4F31F89FE1B06FE9CA345E3F5E967A3EBCF6A1A16E24521D5C4690D9B642483AC7A896\"));\n  test_hash(&nettle_sha3_512, /* 79 octets */\n\t    SHEX(\"12D9394888305AC96E65F2BF0E1B18C29C90FE9D714DD59F651F52B88B3008C588435548066EA2FC4C101118C91F32556224A540DE6EFDDBCA296EF1FB00341F5B01FECFC146BDB251B3BDAD556CD2\"),\n\t    SHEX(\"ADA8E78CE3E6D447BA2B7DCF98718FE7D43B38D68117E5779A41EDD8FA72198E3B3C1C0215925BC9D007FD2C355EDD668A0C27EF0FF89F76CF85363D4C9EE001\"));\n  test_hash(&nettle_sha3_512, /* 80 octets */\n\t    SHEX(\"871A0D7A5F36C3DA1DFCE57ACD8AB8487C274FAD336BC137EBD6FF4658B547C1DCFAB65F037AA58F35EF16AFF4ABE77BA61F65826F7BE681B5B6D5A1EA8085E2AE9CD5CF0991878A311B549A6D6AF230\"),\n\t    SHEX(\"3569D9A08DFB0001BE713940C464C119F5A4C1B9FF97D8297D04C7B2DCE2D684AEE16443C32E5BB2355AC8A336249D1BAAEAB4FBD04AB982D6B178DD0A5B5BC8\"));\n  test_hash(&nettle_sha3_512, /* 81 octets */\n\t    SHEX(\"E90B4FFEF4D457BC7711FF4AA72231CA25AF6B2E206F8BF859D8758B89A7CD36105DB2538D06DA83BAD5F663BA11A5F6F61F236FD5F8D53C5E89F183A3CEC615B50C7C681E773D109FF7491B5CC22296C5\"),\n\t    SHEX(\"1343E3CD162D7986431BABE66383B84029665691E36CAF97CDACA17EE9E97D74201D2A828D72E9FBBD5E07831D90F09EAF3C863BD102CDB1EDEBC8AD58A53ECE\"));\n  test_hash(&nettle_sha3_512, /* 82 octets */\n\t    SHEX(\"E728DE62D75856500C4C77A428612CD804F30C3F10D36FB219C5CA0AA30726AB190E5F3F279E0733D77E7267C17BE27D21650A9A4D1E32F649627638DBADA9702C7CA303269ED14014B2F3CF8B894EAC8554\"),\n\t    SHEX(\"BBA01DBEA9660F9C2AD74460B67A82440701EB995143FFCF7434B5D2DE4E35C82CC757DF776D46199DD8E7355AEB1F42A88F6F0BB50FD239C73898156E4DDBBC\"));\n  test_hash(&nettle_sha3_512, /* 83 octets */\n\t    SHEX(\"6348F229E7B1DF3B770C77544E5166E081850FA1C6C88169DB74C76E42EB983FACB276AD6A0D1FA7B50D3E3B6FCD799EC97470920A7ABED47D288FF883E24CA21C7F8016B93BB9B9E078BDB9703D2B781B616E\"),\n\t    SHEX(\"3268BC24E29392DDA1677B7A3CE3111994482D17BAD1C150AC885F1D29C308657C69FD4F7CE5967D04FCCB920DACB00D0CE09536EE92A6664CB20E692D91D8CE\"));\n  test_hash(&nettle_sha3_512, /* 84 octets */\n\t    SHEX(\"4B127FDE5DE733A1680C2790363627E63AC8A3F1B4707D982CAEA258655D9BF18F89AFE54127482BA01E08845594B671306A025C9A5C5B6F93B0A39522DC877437BE5C2436CBF300CE7AB6747934FCFC30AEAAF6\"),\n\t    SHEX(\"EC13E390FA65FDC11054E32C9F5BF5E6E97FBC34C28089346FF22D9762BEBF6A14FA7F9C2E6643D1ED7EC6925D0FA2098F8149058E99D02AD5CB61B4CCBA6467\"));\n  test_hash(&nettle_sha3_512, /* 85 octets */\n\t    SHEX(\"08461F006CFF4CC64B752C957287E5A0FAABC05C9BFF89D23FD902D324C79903B48FCB8F8F4B01F3E4DDB483593D25F000386698F5ADE7FAADE9615FDC50D32785EA51D49894E45BAA3DC707E224688C6408B68B11\"),\n\t    SHEX(\"6FD5A334D4B7F9C72A8DB1292CC8F19BF2A00F5C226C1636248024723CB876070A9657F48AB3B1D4229202B7BBC64053A48C3FF6B93AB11A2AF3237721C9CC09\"));\n  test_hash(&nettle_sha3_512, /* 86 octets */\n\t    SHEX(\"68C8F8849B120E6E0C9969A5866AF591A829B92F33CD9A4A3196957A148C49138E1E2F5C7619A6D5EDEBE995ACD81EC8BB9C7B9CFCA678D081EA9E25A75D39DB04E18D475920CE828B94E72241F24DB72546B352A0E4\"),\n\t    SHEX(\"016C80CBABED07C50F2C1B677C43E52DE8D11751E54E596E0C04B3837A7E34A9FF5D2E98E7C58182879C15847D18DCE88EA900337BC448112E98CE1118820C58\"));\n  test_hash(&nettle_sha3_512, /* 87 octets */\n\t    SHEX(\"B8D56472954E31FB54E28FCA743F84D8DC34891CB564C64B08F7B71636DEBD64CA1EDBDBA7FC5C3E40049CE982BBA8C7E0703034E331384695E9DE76B5104F2FBC4535ECBEEBC33BC27F29F18F6F27E8023B0FBB6F563C\"),\n\t    SHEX(\"A4E85FF86482C10C6AAABC79A573CBF89A0A927110D755F22B529BD7CF3F6CC6CB9861E509657242A78B0C0AF78FF97ABCC1A8388270D6C8D302D45C9BA58404\"));\n  test_hash(&nettle_sha3_512, /* 88 octets */\n\t    SHEX(\"0D58AC665FA84342E60CEFEE31B1A4EACDB092F122DFC68309077AED1F3E528F578859EE9E4CEFB4A728E946324927B675CD4F4AC84F64DB3DACFE850C1DD18744C74CECCD9FE4DC214085108F404EAB6D8F452B5442A47D\"),\n\t    SHEX(\"B97AFB77D39F8904AE8A5129A7DDC8EC9290AC40356E1B53DD057FA7584BA31AFAF9EF5B657097FC115EAA33E7EDE36DD00832D677EBD07C34B071E73580DD3A\"));\n  test_hash(&nettle_sha3_512, /* 89 octets */\n\t    SHEX(\"1755E2D2E5D1C1B0156456B539753FF416651D44698E87002DCF61DCFA2B4E72F264D9AD591DF1FDEE7B41B2EB00283C5AEBB3411323B672EAA145C5125185104F20F335804B02325B6DEA65603F349F4D5D8B782DD3469CCD\"),\n\t    SHEX(\"AB2FC59A43A2666C9206B9317479285E660B670C6F111F999556E8151E0EB8D12BC82C9A7E7B3F8D6F382A8D96775EA417F754FF552E1BAC271FBD08240F1B86\"));\n  test_hash(&nettle_sha3_512, /* 90 octets */\n\t    SHEX(\"B180DE1A611111EE7584BA2C4B020598CD574AC77E404E853D15A101C6F5A2E5C801D7D85DC95286A1804C870BB9F00FD4DCB03AA8328275158819DCAD7253F3E3D237AEAA7979268A5DB1C6CE08A9EC7C2579783C8AFC1F91A7\"),\n\t    SHEX(\"0A673AF84E2D2317B80A873BFE38B252872708B38AF9B956E3554AC2DCE2F77C815593D99930E7AA666C57B59730712E5C4A9B57849EDDD712A378040EB824D8\"));\n  test_hash(&nettle_sha3_512, /* 91 octets */\n\t    SHEX(\"CF3583CBDFD4CBC17063B1E7D90B02F0E6E2EE05F99D77E24E560392535E47E05077157F96813544A17046914F9EFB64762A23CF7A49FE52A0A4C01C630CFE8727B81FB99A89FF7CC11DCA5173057E0417B8FE7A9EFBA6D95C555F\"),\n\t    SHEX(\"1D34645463EBBD932C730E593D9C108AA86807DB6785F05C4CE80F3E8302F87EFBCCB1AB884E25F1DCD5485D385502995E7ABE2EF11BD3469E036D7EB93B4F39\"));\n  test_hash(&nettle_sha3_512, /* 92 octets */\n\t    SHEX(\"072FC02340EF99115BAD72F92C01E4C093B9599F6CFC45CB380EE686CB5EB019E806AB9BD55E634AB10AA62A9510CC0672CD3EDDB589C7DF2B67FCD3329F61B1A4441ECA87A33C8F55DA4FBBAD5CF2B2527B8E983BB31A2FADEC7523\"),\n\t    SHEX(\"3F57FA915A782E3CC69815BA219F42AA2C222CD7F309F10AF843384B3D3939AA0B92DD9571686C7961E06BFEE818127FC5B5F32C67F4AA2AF10D4FA38F65E90D\"));\n  test_hash(&nettle_sha3_512, /* 93 octets */\n\t    SHEX(\"76EECF956A52649F877528146DE33DF249CD800E21830F65E90F0F25CA9D6540FDE40603230ECA6760F1139C7F268DEBA2060631EEA92B1FFF05F93FD5572FBE29579ECD48BC3A8D6C2EB4A6B26E38D6C5FBF2C08044AEEA470A8F2F26\"),\n\t    SHEX(\"151382CA35FB20B895A9DC074D687F2F335EAF57456D357A685EF752DA59174D3F239AA9E04F142138D9413B21904665EF4DF2F63E663B490383660481F78362\"));\n  test_hash(&nettle_sha3_512, /* 94 octets */\n\t    SHEX(\"7ADC0B6693E61C269F278E6944A5A2D8300981E40022F839AC644387BFAC9086650085C2CDC585FEA47B9D2E52D65A2B29A7DC370401EF5D60DD0D21F9E2B90FAE919319B14B8C5565B0423CEFB827D5F1203302A9D01523498A4DB10374\"),\n\t    SHEX(\"23AA4B74C54E8F450054B6ABDBC6F6C3E44366AFCEC099B155775DE040BF3B9CDD0B875F9D490FAA694F18CCBFFEC6CAB7DE57A59EC6327240AC59D62D50B21C\"));\n  test_hash(&nettle_sha3_512, /* 95 octets */\n\t    SHEX(\"E1FFFA9826CCE8B86BCCEFB8794E48C46CDF372013F782ECED1E378269B7BE2B7BF51374092261AE120E822BE685F2E7A83664BCFBE38FE8633F24E633FFE1988E1BC5ACF59A587079A57A910BDA60060E85B5F5B6F776F0529639D9CCE4BD\"),\n\t    SHEX(\"3605CEC16A7AA8B2525479FCC1295411B6A952DCE233C9ACC856D6D17C9812C920178500CD0028B5998D07046C6A5CF398EE1EC97DF9182C33FCA86647861878\"));\n  test_hash(&nettle_sha3_512, /* 96 octets */\n\t    SHEX(\"69F9ABBA65592EE01DB4DCE52DBAB90B08FC04193602792EE4DAA263033D59081587B09BBE49D0B49C9825D22840B2FF5D9C5155F975F8F2C2E7A90C75D2E4A8040FE39F63BBAFB403D9E28CC3B86E04E394A9C9E8065BD3C85FA9F0C7891600\"),\n\t    SHEX(\"C5A526D75816D41B53BF164B0467E0B80A9984D1830EDB9D49F7EC3ECFEFB01A2C824A0F645753AA463D567CB2782AFCB2B2C2102EA664C56998F79062636FC1\"));\n  test_hash(&nettle_sha3_512, /* 97 octets */\n\t    SHEX(\"38A10A352CA5AEDFA8E19C64787D8E9C3A75DBF3B8674BFAB29B5DBFC15A63D10FAE66CD1A6E6D2452D557967EAAD89A4C98449787B0B3164CA5B717A93F24EB0B506CEB70CBBCB8D72B2A72993F909AAD92F044E0B5A2C9AC9CB16A0CA2F81F49\"),\n\t    SHEX(\"B239941A31100AB1B24AF2D1FEF149DBA300105A31B72A8F217E306A0602D722CCD593A23E6539D3E4195A7E12CA19AE2BAE8B8399F7A9D50DB30216E973F2BF\"));\n  test_hash(&nettle_sha3_512, /* 98 octets */\n\t    SHEX(\"6D8C6E449BC13634F115749C248C17CD148B72157A2C37BF8969EA83B4D6BA8C0EE2711C28EE11495F43049596520CE436004B026B6C1F7292B9C436B055CBB72D530D860D1276A1502A5140E3C3F54A93663E4D20EDEC32D284E25564F624955B52\"),\n\t    SHEX(\"D6AB0D0B416D1BBC85479F9850585761B91775A60307AFACF70943FEB58657740FE35DC760AB9CFA672C6B5552AA67BFA1F0D6A6F943B3912C229B8E0155C002\"));\n  test_hash(&nettle_sha3_512, /* 99 octets */\n\t    SHEX(\"6EFCBCAF451C129DBE00B9CEF0C3749D3EE9D41C7BD500ADE40CDC65DEDBBBADB885A5B14B32A0C0D087825201E303288A733842FA7E599C0C514E078F05C821C7A4498B01C40032E9F1872A1C925FA17CE253E8935E4C3C71282242CB716B2089CCC1\"),\n\t    SHEX(\"BC0A28450368C288013E2EB1196E58933CE05869CB55FA2BDA61D9D92F83B903E59DDE0B927CA6DBC46F5AF2EB7E8831E8668888BFEA46D78F4D274818D56328\"));\n  test_hash(&nettle_sha3_512, /* 100 octets */\n\t    SHEX(\"433C5303131624C0021D868A30825475E8D0BD3052A022180398F4CA4423B98214B6BEAAC21C8807A2C33F8C93BD42B092CC1B06CEDF3224D5ED1EC29784444F22E08A55AA58542B524B02CD3D5D5F6907AFE71C5D7462224A3F9D9E53E7E0846DCBB4CE\"),\n\t    SHEX(\"7820A20056DF741E19FF4D150663488CF86F936353E99E25B93220F5230BFBC13363B458D6DB92F9D211D705362B01782EC118ACFE53BAE4C6AC2C7E5D0111FB\"));\n  test_hash(&nettle_sha3_512, /* 101 octets */\n\t    SHEX(\"A873E0C67CA639026B6683008F7AA6324D4979550E9BCE064CA1E1FB97A30B147A24F3F666C0A72D71348EDE701CF2D17E2253C34D1EC3B647DBCEF2F879F4EB881C4830B791378C901EB725EA5C172316C6D606E0AF7DF4DF7F76E490CD30B2BADF45685F\"),\n\t    SHEX(\"0984A43286A3CB22FB59F7880E114E23E3AD3B0D43025F3987D0AA6FA8E53E6066F80F4769241DCD062431C7F6712C57C6E3275ED3F2BC591DB6DC20E5BE0953\"));\n  test_hash(&nettle_sha3_512, /* 102 octets */\n\t    SHEX(\"006917B64F9DCDF1D2D87C8A6173B64F6587168E80FAA80F82D84F60301E561E312D9FBCE62F39A6FB476E01E925F26BCC91DE621449BE6504C504830AAE394096C8FC7694651051365D4EE9070101EC9B68086F2EA8F8AB7B811EA8AD934D5C9B62C60A4771\"),\n\t    SHEX(\"A6300497F650859CD744679885CD5437A64CC3961574DCCE65E1611616A9F97190F39130BA532094BD62464D0B8B52297A2C9C279B2C9860C072CD44449A9CDF\"));\n  test_hash(&nettle_sha3_512, /* 103 octets */\n\t    SHEX(\"F13C972C52CB3CC4A4DF28C97F2DF11CE089B815466BE88863243EB318C2ADB1A417CB1041308598541720197B9B1CB5BA2318BD5574D1DF2174AF14884149BA9B2F446D609DF240CE335599957B8EC80876D9A085AE084907BC5961B20BF5F6CA58D5DAB38ADB\"),\n\t    SHEX(\"E2052884D112238807C02C135247F76E0E394BD6583BA83ED2731CF68F057276272B891A761CDEC6D8AD2E3F33E86AE9D9A234682BCE7A53816235692D2CF821\"));\n  test_hash(&nettle_sha3_512, /* 104 octets */\n\t    SHEX(\"E35780EB9799AD4C77535D4DDB683CF33EF367715327CF4C4A58ED9CBDCDD486F669F80189D549A9364FA82A51A52654EC721BB3AAB95DCEB4A86A6AFA93826DB923517E928F33E3FBA850D45660EF83B9876ACCAFA2A9987A254B137C6E140A21691E1069413848\"),\n\t    SHEX(\"FF6A7D0EFEA45E5F0ABCB173FCE2BE76B52D0F3FC363AFE31D219472742D73E56CEE2AB91A94D41335C4FA25CBDD6EBD1A087637CAA25099D5A9D60693CF62B9\"));\n  test_hash(&nettle_sha3_512, /* 105 octets */\n\t    SHEX(\"64EC021C9585E01FFE6D31BB50D44C79B6993D72678163DB474947A053674619D158016ADB243F5C8D50AA92F50AB36E579FF2DABB780A2B529370DAA299207CFBCDD3A9A25006D19C4F1FE33E4B1EAEC315D8C6EE1E730623FD1941875B924EB57D6D0C2EDC4E78D6\"),\n\t    SHEX(\"4183F96759E7C0628F2FC81979274F42111A43BD5DBB3685BB21704CE6B0ED3D164DECF28A3A991B303E1D7B86E2B175BA89945A8524F9C9318F12B160A1E4D1\"));\n  test_hash(&nettle_sha3_512, /* 106 octets */\n\t    SHEX(\"5954BAB512CF327D66B5D9F296180080402624AD7628506B555EEA8382562324CF452FBA4A2130DE3E165D11831A270D9CB97CE8C2D32A96F50D71600BB4CA268CF98E90D6496B0A6619A5A8C63DB6D8A0634DFC6C7EC8EA9C006B6C456F1B20CD19E781AF20454AC880\"),\n\t    SHEX(\"940C6F0BACF11E4B045F432003F889278709F9C3D8E420C9A17155F57E776D72B4306BBA4ADF721708F6EF457444AB12238372E207AB41D5EF5A68529ED0B26C\"));\n  test_hash(&nettle_sha3_512, /* 107 octets */\n\t    SHEX(\"03D9F92B2C565709A568724A0AFF90F8F347F43B02338F94A03ED32E6F33666FF5802DA4C81BDCE0D0E86C04AFD4EDC2FC8B4141C2975B6F07639B1994C973D9A9AFCE3D9D365862003498513BFA166D2629E314D97441667B007414E739D7FEBF0FE3C32C17AA188A8683\"),\n\t    SHEX(\"172F0C680310375156911C07B1819F0B9D124514EC2C3750CB2E39926A28A4636AB7ECDCDD9D6A960D16C864DD585645D87F145C5B315381F356656D617FE97D\"));\n  test_hash(&nettle_sha3_512, /* 108 octets */\n\t    SHEX(\"F31E8B4F9E0621D531D22A380BE5D9ABD56FAEC53CBD39B1FAB230EA67184440E5B1D15457BD25F56204FA917FA48E669016CB48C1FFC1E1E45274B3B47379E00A43843CF8601A5551411EC12503E5AAC43D8676A1B2297EC7A0800DBFEE04292E937F21C005F17411473041\"),\n\t    SHEX(\"410DBAA5E3453F2DAFCE135DC014F28FBF693C84EB7D4BECB80A3DB32E16E89062B3FF59C1DFDFAB32D84D20284632A2AC7F8F88D4B7023F879463BA18FF6553\"));\n  test_hash(&nettle_sha3_512, /* 109 octets */\n\t    SHEX(\"758EA3FEA738973DB0B8BE7E599BBEF4519373D6E6DCD7195EA885FC991D896762992759C2A09002912FB08E0CB5B76F49162AEB8CF87B172CF3AD190253DF612F77B1F0C532E3B5FC99C2D31F8F65011695A087A35EE4EEE5E334C369D8EE5D29F695815D866DA99DF3F79403\"),\n\t    SHEX(\"F93A099159C39617B75B188D527FC4DB287CBB4FDDDBA5AD4DCB4CFFC4DC59762BBC41A58D3A788EAE152AEA024BC4CC4F29FC7B8AB68065A68650A04B51818A\"));\n  test_hash(&nettle_sha3_512, /* 110 octets */\n\t    SHEX(\"47C6E0C2B74948465921868804F0F7BD50DD323583DC784F998A93CD1CA4C6EF84D41DC81C2C40F34B5BEE6A93867B3BDBA0052C5F59E6F3657918C382E771D33109122CC8BB0E1E53C4E3D13B43CE44970F5E0C079D2AD7D7A3549CD75760C21BB15B447589E86E8D76B1E9CED2\"),\n\t    SHEX(\"05E69984EE99AA2BC851083AA44EE56FEEF86C45888867CDCDD0C7A8049080AE7858B93C19953A881BE5C036BD8FE83628C2E3AA9939A288B4AC4BC2876C2FBC\"));\n  test_hash(&nettle_sha3_512, /* 111 octets */\n\t    SHEX(\"F690A132AB46B28EDFA6479283D6444E371C6459108AFD9C35DBD235E0B6B6FF4C4EA58E7554BD002460433B2164CA51E868F7947D7D7A0D792E4ABF0BE5F450853CC40D85485B2B8857EA31B5EA6E4CCFA2F3A7EF3380066D7D8979FDAC618AAD3D7E886DEA4F005AE4AD05E5065F\"),\n\t    SHEX(\"BE22F3E253C2563C3353E693D2D5A65DC6BAC2CBCDA8E43E8584F9D851E602D4374936403FD688F0135E363DE8099F249DD21C61695C109C27ED5F4F4C1808BF\"));\n  test_hash(&nettle_sha3_512, /* 112 octets */\n\t    SHEX(\"58D6A99BC6458824B256916770A8417040721CCCFD4B79EACD8B65A3767CE5BA7E74104C985AC56B8CC9AEBD16FEBD4CDA5ADB130B0FF2329CC8D611EB14DAC268A2F9E633C99DE33997FEA41C52A7C5E1317D5B5DAED35EBA7D5A60E45D1FA7EAABC35F5C2B0A0F2379231953322C4E\"),\n\t    SHEX(\"1D1836C4E2C3EB27A74A9CD600C064391BD9EDD45464A5795182C8794748BA51A345C6FAE2B91F5758401E4F427D50B6882B1DF0977976C2C9432C1A9B3AE03F\"));\n  test_hash(&nettle_sha3_512, /* 113 octets */\n\t    SHEX(\"BEFAB574396D7F8B6705E2D5B58B2C1C820BB24E3F4BAE3E8FBCD36DBF734EE14E5D6AB972AEDD3540235466E825850EE4C512EA9795ABFD33F330D9FD7F79E62BBB63A6EA85DE15BEAEEA6F8D204A28956059E2632D11861DFB0E65BC07AC8A159388D5C3277E227286F65FF5E5B5AEC1\"),\n\t    SHEX(\"CB0D33C173C765BBA3714D56A4CF48FD6320AB8C5317E7AB1A46472AFB756232CD27F51473DCF9BD7DAC1AA7F669353FD8F3D27D17D3FE3EB3386876ECA38A85\"));\n  test_hash(&nettle_sha3_512, /* 114 octets */\n\t    SHEX(\"8E58144FA9179D686478622CE450C748260C95D1BA43B8F9B59ABECA8D93488DA73463EF40198B4D16FB0B0707201347E0506FF19D01BEA0F42B8AF9E71A1F1BD168781069D4D338FDEF00BF419FBB003031DF671F4A37979564F69282DE9C65407847DD0DA505AB1641C02DEA4F0D834986\"),\n\t    SHEX(\"B579AD0C750B91E0671BB7F0482A519835D155AE1A4DB92112E66FBD158835E0C29E2F122A8C54C530F92633F6EC7B222CA3CED45B4B5A24426D99C59C1B6609\"));\n  test_hash(&nettle_sha3_512, /* 115 octets */\n\t    SHEX(\"B55C10EAE0EC684C16D13463F29291BF26C82E2FA0422A99C71DB4AF14DD9C7F33EDA52FD73D017CC0F2DBE734D831F0D820D06D5F89DACC485739144F8CFD4799223B1AFF9031A105CB6A029BA71E6E5867D85A554991C38DF3C9EF8C1E1E9A7630BE61CAABCA69280C399C1FB7A12D12AEFC\"),\n\t    SHEX(\"689C878D8A44C79EAF0579DC96C0E7FE7D33491F59A6058BEE60E14B8006BDF6A6070B2B6D3BB6D7C31CCAE09EC403DF49DD12BA72C8532A8E476B4B415D8369\"));\n  test_hash(&nettle_sha3_512, /* 116 octets */\n\t    SHEX(\"2EEEA693F585F4ED6F6F8865BBAE47A6908AECD7C429E4BEC4F0DE1D0CA0183FA201A0CB14A529B7D7AC0E6FF6607A3243EE9FB11BCF3E2304FE75FFCDDD6C5C2E2A4CD45F63C962D010645058D36571404A6D2B4F44755434D76998E83409C3205AA1615DB44057DB991231D2CB42624574F545\"),\n\t    SHEX(\"4E4DC49E414C794A4B6D8D2093FEAB46D91321CFD089B1FD8CB5154F3E342645F6233A9216DB04F080E5AF8B156E782AD16E0B15D814173E78FCF5E7CF8EA51F\"));\n  test_hash(&nettle_sha3_512, /* 117 octets */\n\t    SHEX(\"DAB11DC0B047DB0420A585F56C42D93175562852428499F66A0DB811FCDDDAB2F7CDFFED1543E5FB72110B64686BC7B6887A538AD44C050F1E42631BC4EC8A9F2A047163D822A38989EE4AAB01B4C1F161B062D873B1CFA388FD301514F62224157B9BEF423C7783B7AAC8D30D65CD1BBA8D689C2D\"),\n\t    SHEX(\"2C8F456F9091517CAFA9DF1D09EE621EDFEB2C00DAB944355D592DFDA128F837228578E3965D3767959D3CDDE4E7B67E02241F28C5417E33EA74E39032F938EA\"));\n  test_hash(&nettle_sha3_512, /* 118 octets */\n\t    SHEX(\"42E99A2F80AEE0E001279A2434F731E01D34A44B1A8101726921C0590C30F3120EB83059F325E894A5AC959DCA71CE2214799916424E859D27D789437B9D27240BF8C35ADBAFCECC322B48AA205B293962D858652ABACBD588BCF6CBC388D0993BD622F96ED54614C25B6A9AA527589EAAFFCF17DDF7\"),\n\t    SHEX(\"3AE18402AD4123AF1AD868450591C46F66431D422A29D932DF94AF9AB3E256F806575B3EB0D24EDC7531725E0336847B2E571AE667B619A9D79A3E168948AF5D\"));\n  test_hash(&nettle_sha3_512, /* 119 octets */\n\t    SHEX(\"3C9B46450C0F2CAE8E3823F8BDB4277F31B744CE2EB17054BDDC6DFF36AF7F49FB8A2320CC3BDF8E0A2EA29AD3A55DE1165D219ADEDDB5175253E2D1489E9B6FDD02E2C3D3A4B54D60E3A47334C37913C5695378A669E9B72DEC32AF5434F93F46176EBF044C4784467C700470D0C0B40C8A088C815816\"),\n\t    SHEX(\"6F3E1294B67D875165FD09DD493DD55924E9E28E53AFA2DA80916D7D54E19C1705121D617E53F56EBA4767D6435E986FEEAEB965EC4956FD3C02DE1288FBC661\"));\n  test_hash(&nettle_sha3_512, /* 120 octets */\n\t    SHEX(\"D1E654B77CB155F5C77971A64DF9E5D34C26A3CAD6C7F6B300D39DEB1910094691ADAA095BE4BA5D86690A976428635D5526F3E946F7DC3BD4DBC78999E653441187A81F9ADCD5A3C5F254BC8256B0158F54673DCC1232F6E918EBFC6C51CE67EAEB042D9F57EEC4BFE910E169AF78B3DE48D137DF4F2840\"),\n\t    SHEX(\"AA3398BC7DAEB4F22CA6D1937B0C6097A49ADB6DBC03FC0F5226A644F217296BF55747269B861FC7B22BC5956CE3D8DA28E9F25D8C9599BC653CD0EE0C852473\"));\n  test_hash(&nettle_sha3_512, /* 121 octets */\n\t    SHEX(\"626F68C18A69A6590159A9C46BE03D5965698F2DAC3DE779B878B3D9C421E0F21B955A16C715C1EC1E22CE3EB645B8B4F263F60660EA3028981EEBD6C8C3A367285B691C8EE56944A7CD1217997E1D9C21620B536BDBD5DE8925FF71DEC6FBC06624AB6B21E329813DE90D1E572DFB89A18120C3F606355D25\"),\n\t    SHEX(\"8BCBBE36DBE305FBB558EA46721D25DE7AAB7898E583E8BDF26701224387C524C683475C242C7DE090608A4F17663D217276F94F4188B942A03039B5E38D6AE3\"));\n  test_hash(&nettle_sha3_512, /* 122 octets */\n\t    SHEX(\"651A6FB3C4B80C7C68C6011675E6094EB56ABF5FC3057324EBC6477825061F9F27E7A94633ABD1FA598A746E4A577CAF524C52EC1788471F92B8C37F23795CA19D559D446CAB16CBCDCE90B79FA1026CEE77BF4AB1B503C5B94C2256AD75B3EAC6FD5DCB96ACA4B03A834BFB4E9AF988CECBF2AE597CB9097940\"),\n\t    SHEX(\"4782DFCAB650E7A8DAE9A010CB002DD0373BFBD31247FA9860876D7FFFD2D57C355F2054CB2EFEB45C5871F284F46B025798344A3719EFAB34D15152DD0BBC6C\"));\n  test_hash(&nettle_sha3_512, /* 123 octets */\n\t    SHEX(\"8AAF072FCE8A2D96BC10B3C91C809EE93072FB205CA7F10ABD82ECD82CF040B1BC49EA13D1857815C0E99781DE3ADBB5443CE1C897E55188CEAF221AA9681638DE05AE1B322938F46BCE51543B57ECDB4C266272259D1798DE13BE90E10EFEC2D07484D9B21A3870E2AA9E06C21AA2D0C9CF420080A80A91DEE16F\"),\n\t    SHEX(\"A4D538E449E2B3EBF9AAFC88D29E514BA0D2C8DE2706F3F6FA5A2C4F95F5DB5BAB59C1A69C16E4859A19730ABB2E6BF06152445EDA80E3BE5CE652023EA57E5E\"));\n  test_hash(&nettle_sha3_512, /* 124 octets */\n\t    SHEX(\"53F918FD00B1701BD504F8CDEA803ACCA21AC18C564AB90C2A17DA592C7D69688F6580575395551E8CD33E0FEF08CA6ED4588D4D140B3E44C032355DF1C531564D7F4835753344345A6781E11CD5E095B73DF5F82C8AE3AD00877936896671E947CC52E2B29DCD463D90A0C9929128DA222B5A211450BBC0E02448E2\"),\n\t    SHEX(\"8732D243F1B3349F900DF430659B9AB9ED99F626AD35CB2084B57D60E5A5B47213AD213859CD40964C5A267C236D0E38167525F778E67E37D4F623A8884128ED\"));\n  test_hash(&nettle_sha3_512, /* 125 octets */\n\t    SHEX(\"A64599B8A61B5CCEC9E67AED69447459C8DA3D1EC6C7C7C82A7428B9B584FA67E90F68E2C00FBBED4613666E5168DA4A16F395F7A3C3832B3B134BFC9CBAA95D2A0FE252F44AC6681EB6D40AB91C1D0282FED6701C57463D3C5F2BB8C6A7301FB4576AA3B5F15510DB8956FF77478C26A7C09BEA7B398CFC83503F538E\"),\n\t    SHEX(\"97DC2606E14F7BFFF1FCA497965E36CAA3A81CFD6459D0254529F64DA40FFE7442C08A151D6CEE3B46BF3414E80110A0F71EEE44D7940027DEE90E919E498D65\"));\n  test_hash(&nettle_sha3_512, /* 126 octets */\n\t    SHEX(\"0E3AB0E054739B00CDB6A87BD12CAE024B54CB5E550E6C425360C2E87E59401F5EC24EF0314855F0F56C47695D56A7FB1417693AF2A1ED5291F2FEE95F75EED54A1B1C2E81226FBFF6F63ADE584911C71967A8EB70933BC3F5D15BC91B5C2644D9516D3C3A8C154EE48E118BD1442C043C7A0DBA5AC5B1D5360AAE5B9065\"),\n\t    SHEX(\"DE5978EACE4E51F7D289F2BEFBECB3AAC8E9CAD48FA0F7310C673D52BBCAEEBDE49CB5A76D334D6DFDD51AC1AB24E9E1CDC915069DBDDB3D2E30B0B0C26B3EE1\"));\n  test_hash(&nettle_sha3_512, /* 127 octets */\n\t    SHEX(\"A62FC595B4096E6336E53FCDFC8D1CC175D71DAC9D750A6133D23199EAAC288207944CEA6B16D27631915B4619F743DA2E30A0C00BBDB1BBB35AB852EF3B9AEC6B0A8DCC6E9E1ABAA3AD62AC0A6C5DE765DE2C3711B769E3FDE44A74016FFF82AC46FA8F1797D3B2A726B696E3DEA5530439ACEE3A45C2A51BC32DD055650B\"),\n\t    SHEX(\"33ABCA29A8A7094CFB10BE4A80E81F8001EBB933C0D4B98A695B22AB553F94F07646ABCE6ADF491817D17B78C40747D56FAF88A613138CA0E596636C672397B4\"));\n  test_hash(&nettle_sha3_512, /* 128 octets */\n\t    SHEX(\"2B6DB7CED8665EBE9DEB080295218426BDAA7C6DA9ADD2088932CDFFBAA1C14129BCCDD70F369EFB149285858D2B1D155D14DE2FDB680A8B027284055182A0CAE275234CC9C92863C1B4AB66F304CF0621CD54565F5BFF461D3B461BD40DF28198E3732501B4860EADD503D26D6E69338F4E0456E9E9BAF3D827AE685FB1D817\"),\n\t    SHEX(\"4FAB45806B4628068458B5D0A2D4BF101B8BFC9276EF86AD5D883765C43F72CE8A5F7B4C5B535A915130BB185E699AB62228014E54DF790C0E93AADBE7E39E19\"));\n  test_hash(&nettle_sha3_512, /* 129 octets */\n\t    SHEX(\"10DB509B2CDCABA6C062AE33BE48116A29EB18E390E1BBADA5CA0A2718AFBCD23431440106594893043CC7F2625281BF7DE2655880966A23705F0C5155C2F5CCA9F2C2142E96D0A2E763B70686CD421B5DB812DACED0C6D65035FDE558E94F26B3E6DDE5BD13980CC80292B723013BD033284584BFF27657871B0CF07A849F4AE2\"),\n\t    SHEX(\"5F0BFB4146910CF0C320364B6AD8A02B0966229AB2676D9670F0DD241E8104DB02797EEFEA0B9CABBE90A44757B033755925B2FCCF3A00054F9AE8FBCEF752A8\"));\n  test_hash(&nettle_sha3_512, /* 130 octets */\n\t    SHEX(\"9334DE60C997BDA6086101A6314F64E4458F5FF9450C509DF006E8C547983C651CA97879175AABA0C539E82D05C1E02C480975CBB30118121061B1EBAC4F8D9A3781E2DB6B18042E01ECF9017A64A0E57447EC7FCBE6A7F82585F7403EE2223D52D37B4BF426428613D6B4257980972A0ACAB508A7620C1CB28EB4E9D30FC41361EC\"),\n\t    SHEX(\"D38EF3B12EAA0BF62A75B6B63CFF3C9EF171DE1B75F5D02629365BCFE65BA7DDD30FCEF7FEBB82F19F9BEDCC1CC4C679B4292EA62C2A90A7562DA9A1318FE278\"));\n  test_hash(&nettle_sha3_512, /* 131 octets */\n\t    SHEX(\"E88AB086891693AA535CEB20E64C7AB97C7DD3548F3786339897A5F0C39031549CA870166E477743CCFBE016B4428D89738E426F5FFE81626137F17AECFF61B72DBEE2DC20961880CFE281DFAB5EE38B1921881450E16032DE5E4D55AD8D4FCA609721B0692BAC79BE5A06E177FE8C80C0C83519FB3347DE9F43D5561CB8107B9B5EDC\"),\n\t    SHEX(\"60C95C274F99B8643A186344BC01D1279010BE55D1BE76F4E6F919F6B54D335EE0E1CA92133F3D7A2520CD82C4000E15EFED8D8A66F31B16B0977C63DE1BEB05\"));\n  test_hash(&nettle_sha3_512, /* 132 octets */\n\t    SHEX(\"FD19E01A83EB6EC810B94582CB8FBFA2FCB992B53684FB748D2264F020D3B960CB1D6B8C348C2B54A9FCEA72330C2AAA9A24ECDB00C436ABC702361A82BB8828B85369B8C72ECE0082FE06557163899C2A0EFA466C33C04343A839417057399A63A3929BE1EE4805D6CE3E5D0D0967FE9004696A5663F4CAC9179006A2CEB75542D75D68\"),\n\t    SHEX(\"9385D0ED9E73498E24B8C6E746A1C6BE8011EE30FCAC9BA17224EE2012378522C78F8737A224621FBA19C42040C5C7F38AC07B40E0E75EBC59D17975EE85D655\"));\n  test_hash(&nettle_sha3_512, /* 133 octets */\n\t    SHEX(\"59AE20B6F7E0B3C7A989AFB28324A40FCA25D8651CF1F46AE383EF6D8441587AA1C04C3E3BF88E8131CE6145CFB8973D961E8432B202FA5AF3E09D625FAAD825BC19DA9B5C6C20D02ABDA2FCC58B5BD3FE507BF201263F30543819510C12BC23E2DDB4F711D087A86EDB1B355313363A2DE996B891025E147036087401CCF3CA7815BF3C49\"),\n\t    SHEX(\"7487164D408874AFDF07EBDADE8C62E756147BEAB3238B8738AEED927F54FE6D33AF3917D4E181B50CBC88A379C73585F9FBA4C1B67B4BE449004EA0F66D11AD\"));\n  test_hash(&nettle_sha3_512, /* 134 octets */\n\t    SHEX(\"77EE804B9F3295AB2362798B72B0A1B2D3291DCEB8139896355830F34B3B328561531F8079B79A6E9980705150866402FDC176C05897E359A6CB1A7AB067383EB497182A7E5AEF7038E4C96D133B2782917417E391535B5E1B51F47D8ED7E4D4025FE98DC87B9C1622614BFF3D1029E68E372DE719803857CA52067CDDAAD958951CB2068CC6\"),\n\t    SHEX(\"0F41AB2D10C51E28638DAD178655F160B2F753DB44EED6CE4104693CC4A938D887617774AFECB33B890EE7FC577656CE168EEA42C604D152B952C9B772C9B530\"));\n  test_hash(&nettle_sha3_512, /* 135 octets */\n\t    SHEX(\"B771D5CEF5D1A41A93D15643D7181D2A2EF0A8E84D91812F20ED21F147BEF732BF3A60EF4067C3734B85BC8CD471780F10DC9E8291B58339A677B960218F71E793F2797AEA349406512829065D37BB55EA796FA4F56FD8896B49B2CD19B43215AD967C712B24E5032D065232E02C127409D2ED4146B9D75D763D52DB98D949D3B0FED6A8052FBB\"),\n\t    SHEX(\"7575A1FB4FC9A8F9C0466BD5FCA496D1CB78696773A212A5F62D02D14E3259D192A87EBA4407DD83893527331407B6DADAAD920DBC46489B677493CE5F20B595\"));\n  test_hash(&nettle_sha3_512, /* 136 octets */\n\t    SHEX(\"B32D95B0B9AAD2A8816DE6D06D1F86008505BD8C14124F6E9A163B5A2ADE55F835D0EC3880EF50700D3B25E42CC0AF050CCD1BE5E555B23087E04D7BF9813622780C7313A1954F8740B6EE2D3F71F768DD417F520482BD3A08D4F222B4EE9DBD015447B33507DD50F3AB4247C5DE9A8ABD62A8DECEA01E3B87C8B927F5B08BEB37674C6F8E380C04\"),\n\t    SHEX(\"2E293765022D48996CE8EFF0BE54E87EFB94A14C72DE5ACD10D0EB5ECE029CADFA3BA17A40B2FFA2163991B17786E51CABA79E5E0FFD34CF085E2A098BE8BACB\"));\n  test_hash(&nettle_sha3_512, /* 137 octets */\n\t    SHEX(\"04410E31082A47584B406F051398A6ABE74E4DA59BB6F85E6B49E8A1F7F2CA00DFBA5462C2CD2BFDE8B64FB21D70C083F11318B56A52D03B81CAC5EEC29EB31BD0078B6156786DA3D6D8C33098C5C47BB67AC64DB14165AF65B44544D806DDE5F487D5373C7F9792C299E9686B7E5821E7C8E2458315B996B5677D926DAC57B3F22DA873C601016A0D\"),\n\t    SHEX(\"BE8E14B6757FFE53C9B75F6DDE9A7B6C40474041DE83D4A60645A826D7AF1ABE1EEFCB7B74B62CA6A514E5F2697D585BFECECE12931BBE1D4ED7EBF7B0BE660E\"));\n  test_hash(&nettle_sha3_512, /* 138 octets */\n\t    SHEX(\"8B81E9BADDE026F14D95C019977024C9E13DB7A5CD21F9E9FC491D716164BBACDC7060D882615D411438AEA056C340CDF977788F6E17D118DE55026855F93270472D1FD18B9E7E812BAE107E0DFDE7063301B71F6CFE4E225CAB3B232905A56E994F08EE2891BA922D49C3DAFEB75F7C69750CB67D822C96176C46BD8A29F1701373FB09A1A6E3C7158F\"),\n\t    SHEX(\"6C7E64EE0D826073D4F44BCF1586A83BACF3E2E138DFDB65B8B8B35FD7DAE300EA6E32C6245CCA27C674FEB2196755945AB7C5DCE99EAB9158A75518AC27C431\"));\n  test_hash(&nettle_sha3_512, /* 139 octets */\n\t    SHEX(\"FA6EED24DA6666A22208146B19A532C2EC9BA94F09F1DEF1E7FC13C399A48E41ACC2A589D099276296348F396253B57CB0E40291BD282773656B6E0D8BEA1CDA084A3738816A840485FCF3FB307F777FA5FEAC48695C2AF4769720258C77943FB4556C362D9CBA8BF103AEB9034BAA8EA8BFB9C4F8E6742CE0D52C49EA8E974F339612E830E9E7A9C29065\"),\n\t    SHEX(\"5842D4DA2C309D9B2AA7CFAE702262F770A8E646620D65C17271416E9D7981FF93D228CD60DC1CC16921020D841E439E87F085E503D466C904ABF8CDD5ECCAA9\"));\n  test_hash(&nettle_sha3_512, /* 140 octets */\n\t    SHEX(\"9BB4AF1B4F09C071CE3CAFA92E4EB73CE8A6F5D82A85733440368DEE4EB1CBC7B55AC150773B6FE47DBE036C45582ED67E23F4C74585DAB509DF1B83610564545642B2B1EC463E18048FC23477C6B2AA035594ECD33791AF6AF4CBC2A1166ABA8D628C57E707F0B0E8707CAF91CD44BDB915E0296E0190D56D33D8DDE10B5B60377838973C1D943C22ED335E\"),\n\t    SHEX(\"F8B24527B5C84CA9A702DB2F535F78ED0323C2932A255DB24F872551CA7F5C0482B3690C62EEC8AD69308DB2D72308C4D615CDE3835B39B4F6FF115466F32763\"));\n  test_hash(&nettle_sha3_512, /* 141 octets */\n\t    SHEX(\"2167F02118CC62043E9091A647CADBED95611A521FE0D64E8518F16C808AB297725598AE296880A773607A798F7C3CFCE80D251EBEC6885015F9ABF7EAABAE46798F82CB5926DE5C23F44A3F9F9534B3C6F405B5364C2F8A8BDC5CA49C749BED8CE4BA48897062AE8424CA6DDE5F55C0E42A95D1E292CA54FB46A84FBC9CD87F2D0C9E7448DE3043AE22FDD229\"),\n\t    SHEX(\"08C6E3938DE48171A99646BD090B7D53FF422AE63F99850032BD131AC7BDFBA8F83466AD31FAD3169D8A320FD9548BDFF2C40BA20E0D031A8054019C40ED2662\"));\n  test_hash(&nettle_sha3_512, /* 142 octets */\n\t    SHEX(\"94B7FA0BC1C44E949B1D7617D31B4720CBE7CA57C6FA4F4094D4761567E389ECC64F6968E4064DF70DF836A47D0C713336B5028B35930D29EB7A7F9A5AF9AD5CF441745BAEC9BB014CEEFF5A41BA5C1CE085FEB980BAB9CF79F2158E03EF7E63E29C38D7816A84D4F71E0F548B7FC316085AE38A060FF9B8DEC36F91AD9EBC0A5B6C338CBB8F6659D342A24368CF\"),\n\t    SHEX(\"6978AD4BC4F0FC44C35C6691CA46627D840BAA572DE9B0216673C988197191CDF812CF21920E052CC9CE1D507D1BA7DB6F151D01620ADA702DC637BF90809C19\"));\n  test_hash(&nettle_sha3_512, /* 143 octets */\n\t    SHEX(\"EA40E83CB18B3A242C1ECC6CCD0B7853A439DAB2C569CFC6DC38A19F5C90ACBF76AEF9EA3742FF3B54EF7D36EB7CE4FF1C9AB3BC119CFF6BE93C03E208783335C0AB8137BE5B10CDC66FF3F89A1BDDC6A1EED74F504CBE7290690BB295A872B9E3FE2CEE9E6C67C41DB8EFD7D863CF10F840FE618E7936DA3DCA5CA6DF933F24F6954BA0801A1294CD8D7E66DFAFEC\"),\n\t    SHEX(\"3A8E938C45F3F177991296B24565D9A6605516615D96A062C8BE53A0D6C5A6487BE35D2A8F3CF6620D0C2DBA2C560D68295F284BE7F82F3B92919033C9CE5D80\"));\n  test_hash(&nettle_sha3_512, /* 144 octets */\n\t    SHEX(\"157D5B7E4507F66D9A267476D33831E7BB768D4D04CC3438DA12F9010263EA5FCAFBDE2579DB2F6B58F911D593D5F79FB05FE3596E3FA80FF2F761D1B0E57080055C118C53E53CDB63055261D7C9B2B39BD90ACC32520CBBDBDA2C4FD8856DBCEE173132A2679198DAF83007A9B5C51511AE49766C792A29520388444EBEFE28256FB33D4260439CBA73A9479EE00C63\"),\n\t    SHEX(\"FE45289874879720CE2A844AE34BB73522775DCB6019DCD22B8885994672A0889C69E8115C641DC8B83E39F7311815A164DC46E0BA2FCA344D86D4BC2EF2532C\"));\n  test_hash(&nettle_sha3_512, /* 145 octets */\n\t    SHEX(\"836B34B515476F613FE447A4E0C3F3B8F20910AC89A3977055C960D2D5D2B72BD8ACC715A9035321B86703A411DDE0466D58A59769672AA60AD587B8481DE4BBA552A1645779789501EC53D540B904821F32B0BD1855B04E4848F9F8CFE9EBD8911BE95781A759D7AD9724A7102DBE576776B7C632BC39B9B5E19057E226552A5994C1DBB3B5C7871A11F5537011044C53\"),\n\t    SHEX(\"AFF61C6E11B98E55AC213B1A0BC7DE0405221AC5EFB1229842E4614F4A029C9BD14A0ED7FD99AF3681429F3F309FDB53166AA9A3CD9F1F1223D04B4A9015E94A\"));\n  test_hash(&nettle_sha3_512, /* 146 octets */\n\t    SHEX(\"CC7784A4912A7AB5AD3620AAB29BA87077CD3CB83636ADC9F3DC94F51EDF521B2161EF108F21A0A298557981C0E53CE6CED45BDF782C1EF200D29BAB81DD6460586964EDAB7CEBDBBEC75FD7925060F7DA2B853B2B089588FA0F8C16EC6498B14C55DCEE335CB3A91D698E4D393AB8E8EAC0825F8ADEBEEE196DF41205C011674E53426CAA453F8DE1CBB57932B0B741D4C6\"),\n\t    SHEX(\"26410E1A0D1E3659438DDDB2953EB3AA082CEB02A327FA0098574D89F9236F5DFF9C17DEF37F6CE4B5DC1EE5F23F578FE191EE8B51F1B8034BCBBBB7B6A500A5\"));\n  test_hash(&nettle_sha3_512, /* 147 octets */\n\t    SHEX(\"7639B461FFF270B2455AC1D1AFCE782944AEA5E9087EB4A39EB96BB5C3BAAF0E868C8526D3404F9405E79E77BFAC5FFB89BF1957B523E17D341D7323C302EA7083872DD5E8705694ACDDA36D5A1B895AAA16ECA6104C82688532C8BFE1790B5DC9F4EC5FE95BAED37E1D287BE710431F1E5E8EE105BC42ED37D74B1E55984BF1C09FE6A1FA13EF3B96FAEAED6A2A1950A12153\"),\n\t    SHEX(\"5015DA2A2E1661D3A52A65D19F02933029839F72717A77B5045198665093F944CFF85E094D418396A51C574157EED9FB6BDD4ECA53278FAB62AF699B53C82F58\"));\n  test_hash(&nettle_sha3_512, /* 148 octets */\n\t    SHEX(\"EB6513FC61B30CFBA58D4D7E80F94D14589090CF1D80B1DF2E68088DC6104959BA0D583D585E9578AB0AEC0CF36C48435EB52ED9AB4BBCE7A5ABE679C97AE2DBE35E8CC1D45B06DDA3CF418665C57CBEE4BBB47FA4CAF78F4EE656FEC237FE4EEBBAFA206E1EF2BD0EE4AE71BD0E9B2F54F91DAADF1FEBFD7032381D636B733DCB3BF76FB14E23AFF1F68ED3DBCF75C9B99C6F26\"),\n\t    SHEX(\"B27828CFEBCF4D896EABF1F84D079827B7DCC7F308A20476474DE518829A89AAC3DC50272CFA976B0B5819C45C9EEFC51B87A27D11C9E5F9579121125A887542\"));\n  test_hash(&nettle_sha3_512, /* 149 octets */\n\t    SHEX(\"1594D74BF5DDE444265D4C04DAD9721FF3E34CBF622DAF341FE16B96431F6C4DF1F760D34F296EB97D98D560AD5286FEC4DCE1724F20B54FD7DF51D4BF137ADD656C80546FB1BF516D62EE82BAA992910EF4CC18B70F3F8698276FCFB44E0EC546C2C39CFD8EE91034FF9303058B4252462F86C823EB15BF481E6B79CC3A02218595B3658E8B37382BD5048EAED5FD02C37944E73B\"),\n\t    SHEX(\"42FC06DCF99B4E804BB349101B46D6A6A7366E47555406EA554248BAEF52E17AFA40829F5709D07FF407881DF106F156CA735622B0F051D8C372F6E811CDAE25\"));\n  test_hash(&nettle_sha3_512, /* 150 octets */\n\t    SHEX(\"4CFA1278903026F66FEDD41374558BE1B585D03C5C55DAC94361DF286D4BD39C7CB8037ED3B267B07C346626449D0CC5B0DD2CF221F7E4C3449A4BE99985D2D5E67BFF2923357DDEAB5ABCB4619F3A3A57B2CF928A022EB27676C6CF805689004FCA4D41EA6C2D0A4789C7605F7BB838DD883B3AD3E6027E775BCF262881428099C7FFF95B14C095EA130E0B9938A5E22FC52650F591\"),\n\t    SHEX(\"0CA89C9B7273DE384FF33F1BACBB8505628C4D3E30350B335361563AD416ADA523122D37ACBEC57721F7BC5D9B049E1F4FE3C4CFE047E33A0E448EF5D5536CF0\"));\n  test_hash(&nettle_sha3_512, /* 151 octets */\n\t    SHEX(\"D3E65CB92CFA79662F6AF493D696A07CCF32AAADCCEFF06E73E8D9F6F909209E66715D6E978788C49EFB9087B170ECF3AA86D2D4D1A065AE0EFC8924F365D676B3CB9E2BEC918FD96D0B43DEE83727C9A93BF56CA2B2E59ADBA85696546A815067FC7A78039629D4948D157E7B0D826D1BF8E81237BAB7321312FDAA4D521744F988DB6FDF04549D0FDCA393D639C729AF716E9C8BBA48\"),\n\t    SHEX(\"78C59A8CDF4D1D07A66BB2FAA7FFA2112D5C0FCABF7E3589E97623BDB922AF9AF24918C2CCFCE2B880BF64145C70DC9A4FDE78FDF0918DD2CE5FEA9CF99ACD41\"));\n  test_hash(&nettle_sha3_512, /* 152 octets */\n\t    SHEX(\"842CC583504539622D7F71E7E31863A2B885C56A0BA62DB4C2A3F2FD12E79660DC7205CA29A0DC0A87DB4DC62EE47A41DB36B9DDB3293B9AC4BAAE7DF5C6E7201E17F717AB56E12CAD476BE49608AD2D50309E7D48D2D8DE4FA58AC3CFEAFEEE48C0A9EEC88498E3EFC51F54D300D828DDDCCB9D0B06DD021A29CF5CB5B2506915BEB8A11998B8B886E0F9B7A80E97D91A7D01270F9A7717\"),\n\t    SHEX(\"CF4D52D20272DE014D367310775287EE5E5CB34CF9AF78E65D1D1FE7FB1F13B62DD9B83C382BAA6AB4F6949478C8598FEF78E8D535311FC19808CB75E22DADED\"));\n  test_hash(&nettle_sha3_512, /* 153 octets */\n\t    SHEX(\"6C4B0A0719573E57248661E98FEBE326571F9A1CA813D3638531AE28B4860F23C3A3A8AC1C250034A660E2D71E16D3ACC4BF9CE215C6F15B1C0FC7E77D3D27157E66DA9CEEC9258F8F2BF9E02B4AC93793DD6E29E307EDE3695A0DF63CBDC0FC66FB770813EB149CA2A916911BEE4902C47C7802E69E405FE3C04CEB5522792A5503FA829F707272226621F7C488A7698C0D69AA561BE9F378\"),\n\t    SHEX(\"33D632E403C9F9A9349B28AA4821A12B1DB557D8928003D30C57D701CFF1C49BAC9472CECFF450E4D91D36C6CD78221790EFF6F0FBF498034014CBBACE5DCF09\"));\n  test_hash(&nettle_sha3_512, /* 154 octets */\n\t    SHEX(\"51B7DBB7CE2FFEB427A91CCFE5218FD40F9E0B7E24756D4C47CD55606008BDC27D16400933906FD9F30EFFDD4880022D081155342AF3FB6CD53672AB7FB5B3A3BCBE47BE1FD3A2278CAE8A5FD61C1433F7D350675DD21803746CADCA574130F01200024C6340AB0CC2CF74F2234669F34E9009EF2EB94823D62B31407F4BA46F1A1EEC41641E84D77727B59E746B8A671BEF936F05BE820759FA\"),\n\t    SHEX(\"954C709ABCB0BB881592D93F5C2463CE8C060AD1DF3053302EA7B19F2B47BCF0FE359A832F9A865A8D3DBD3BE598DFD6D0FC1C574ECA0AEC78D8E3288399BE05\"));\n  test_hash(&nettle_sha3_512, /* 155 octets */\n\t    SHEX(\"83599D93F5561E821BD01A472386BC2FF4EFBD4AED60D5821E84AAE74D8071029810F5E286F8F17651CD27DA07B1EB4382F754CD1C95268783AD09220F5502840370D494BEB17124220F6AFCE91EC8A0F55231F9652433E5CE3489B727716CF4AEBA7DCDA20CD29AA9A859201253F948DD94395ABA9E3852BD1D60DDA7AE5DC045B283DA006E1CBAD83CC13292A315DB5553305C628DD091146597\"),\n\t    SHEX(\"A337062F5E5C9C35341A51224F2A59E6CF919A63BF59A6CFCE261194BBD660F28C2948D03CDCE5C7C151EC05B42AADD83051A16A62F0C7DF39AAA4EFC82CE4D3\"));\n  test_hash(&nettle_sha3_512, /* 156 octets */\n\t    SHEX(\"2BE9BF526C9D5A75D565DD11EF63B979D068659C7F026C08BEA4AF161D85A462D80E45040E91F4165C074C43AC661380311A8CBED59CC8E4C4518E80CD2C78AB1CABF66BFF83EAB3A80148550307310950D034A6286C93A1ECE8929E6385C5E3BB6EA8A7C0FB6D6332E320E71CC4EB462A2A62E2BFE08F0CCAD93E61BEDB5DD0B786A728AB666F07E0576D189C92BF9FB20DCA49AC2D3956D47385E2\"),\n\t    SHEX(\"43E9D0EA8E526E83234D7B63D8244C7E7B12AE2ACC8082F986367268F10156574300172873845B207A7252624246E7D32CE0F7282E00C4552F6180F34E590E2E\"));\n  test_hash(&nettle_sha3_512, /* 157 octets */\n\t    SHEX(\"CA76D3A12595A817682617006848675547D3E8F50C2210F9AF906C0E7CE50B4460186FE70457A9E879E79FD4D1A688C70A347361C847BA0DD6AA52936EAF8E58A1BE2F5C1C704E20146D366AEB3853BED9DE9BEFE9569AC8AAEA37A9FB7139A1A1A7D5C748605A8DEFB297869EBEDD71D615A5DA23496D11E11ABBB126B206FA0A7797EE7DE117986012D0362DCEF775C2FE145ADA6BDA1CCB326BF644\"),\n\t    SHEX(\"F7DA8D1E49D0D964400EE40F9C88E07025A8B0B00CADC624A63E2EA85B1598E22C8802BE0C1FF368519549A752E02546093D3B984E24600BA2AB7C792B9E074A\"));\n  test_hash(&nettle_sha3_512, /* 158 octets */\n\t    SHEX(\"F76B85DC67421025D64E93096D1D712B7BAF7FB001716F02D33B2160C2C882C310EF13A576B1C2D30EF8F78EF8D2F465007109AAD93F74CB9E7D7BEF7C9590E8AF3B267C89C15DB238138C45833C98CC4A471A7802723EF4C744A853CF80A0C2568DD4ED58A2C9644806F42104CEE53628E5BDF7B63B0B338E931E31B87C24B146C6D040605567CEEF5960DF9E022CB469D4C787F4CBA3C544A1AC91F95F\"),\n\t    SHEX(\"D9A42761F980C78C36CF54C4207B0A62954E15A907A7CEA149B37A4E0A6376202FF8F12E16EBAD3AECC7FF3A9D6AD093B068DFE272E3B9646B1AEDC04961DC81\"));\n  test_hash(&nettle_sha3_512, /* 159 octets */\n\t    SHEX(\"25B8C9C032EA6BCD733FFC8718FBB2A503A4EA8F71DEA1176189F694304F0FF68E862A8197B839957549EF243A5279FC2646BD4C009B6D1EDEBF24738197ABB4C992F6B1DC9BA891F570879ACCD5A6B18691A93C7D0A8D38F95B639C1DAEB48C4C2F15CCF5B9D508F8333C32DE78781B41850F261B855C4BEBCC125A380C54D501C5D3BD07E6B52102116088E53D76583B0161E2A58D0778F091206AABD5A1\"),\n\t    SHEX(\"BB65D8943413CEF89FDB05B35A55EC7503E4546A50FC3ECC825DABC1A1DAE6C771BB197F323625877E0BCCAA41253C99B6692976B99FC687B0B6B3E9AAB478C4\"));\n  test_hash(&nettle_sha3_512, /* 160 octets */\n\t    SHEX(\"21CFDC2A7CCB7F331B3D2EEFFF37E48AD9FA9C788C3F3C200E0173D99963E1CBCA93623B264E920394AE48BB4C3A5BB96FFBC8F0E53F30E22956ADABC2765F57FB761E147ECBF8567533DB6E50C8A1F894310A94EDF806DD8CA6A0E141C0FA7C9FAE6C6AE65F18C93A8529E6E5B553BF55F25BE2E80A9882BD37F145FECBEB3D447A3C4E46C21524CC55CDD62F521AB92A8BA72B897996C49BB273198B7B1C9E\"),\n\t    SHEX(\"540DF22180B69B9A83306619B2CA8CD8E07A34BBEB2219AC7CF88B468A947C4448489B303BD65506C9E1CE59348A9D863AAB5154848E95B5389783F6F5FB6AD8\"));\n  test_hash(&nettle_sha3_512, /* 161 octets */\n\t    SHEX(\"4E452BA42127DCC956EF4F8F35DD68CB225FB73B5BC7E1EC5A898BBA2931563E74FAFF3B67314F241EC49F4A7061E3BD0213AE826BAB380F1F14FAAB8B0EFDDD5FD1BB49373853A08F30553D5A55CCBBB8153DE4704F29CA2BDEEF0419468E05DD51557CCC80C0A96190BBCC4D77ECFF21C66BDF486459D427F986410F883A80A5BCC32C20F0478BB9A97A126FC5F95451E40F292A4614930D054C851ACD019CCF\"),\n\t    SHEX(\"062E4A11A79FDB9CBC3A0E4C5F9875CAAA568BC713066E02D2A9CA4D27886CE23F70083A2BF4D0E7C55B120FE6D197203DC1C2FD3469112A08836727859E1F83\"));\n  test_hash(&nettle_sha3_512, /* 162 octets */\n\t    SHEX(\"FA85671DF7DADF99A6FFEE97A3AB9991671F5629195049880497487867A6C446B60087FAC9A0F2FCC8E3B24E97E42345B93B5F7D3691829D3F8CCD4BB36411B85FC2328EB0C51CB3151F70860AD3246CE0623A8DC8B3C49F958F8690F8E3860E71EB2B1479A5CEA0B3F8BEFD87ACAF5362435EAECCB52F38617BC6C5C2C6E269EAD1FBD69E941D4AD2012DA2C5B21BCFBF98E4A77AB2AF1F3FDA3233F046D38F1DC8\"),\n\t    SHEX(\"9E1C6EE0C47B2D2CB77F602CAB53AC4C69C69778297894554196CB58060332C9FD8923F45C4B8EC26E16A5D04E6307FB99850A4540EA83E3F2626F3343E97225\"));\n  test_hash(&nettle_sha3_512, /* 163 octets */\n\t    SHEX(\"E90847AE6797FBC0B6B36D6E588C0A743D725788CA50B6D792352EA8294F5BA654A15366B8E1B288D84F5178240827975A763BC45C7B0430E8A559DF4488505E009C63DA994F1403F407958203CEBB6E37D89C94A5EACF6039A327F6C4DBBC7A2A307D976AA39E41AF6537243FC218DFA6AB4DD817B6A397DF5CA69107A9198799ED248641B63B42CB4C29BFDD7975AC96EDFC274AC562D0474C60347A078CE4C25E88\"),\n\t    SHEX(\"F18F0B072A6BF608A6C7420E891BE3795A6D19BA3E1276C826F1AE775CF125E428AE1A397CFD074BE0CD24F7100F51800F14471CCF4F485A6571E2B32E02611F\"));\n  test_hash(&nettle_sha3_512, /* 164 octets */\n\t    SHEX(\"F6D5C2B6C93954FC627602C00C4CA9A7D3ED12B27173F0B2C9B0E4A5939398A665E67E69D0B12FB7E4CEB253E8083D1CEB724AC07F009F094E42F2D6F2129489E846EAFF0700A8D4453EF453A3EDDC18F408C77A83275617FABC4EA3A2833AA73406C0E966276079D38E8E38539A70E194CC5513AAA457C699383FD1900B1E72BDFB835D1FD321B37BA80549B078A49EA08152869A918CA57F5B54ED71E4FD3AC5C06729\"),\n\t    SHEX(\"2859A3165F38CB59DE4275658BBAE9A0AD647D972CF98FA0EEC4C07EE75D576DBF9F5DD19A881DB4E4F7DB31EC0D77165911329CBE8A46D14D3EA7FDCB8A5C80\"));\n  test_hash(&nettle_sha3_512, /* 165 octets */\n\t    SHEX(\"CF8562B1BED89892D67DDAAF3DEEB28246456E972326DBCDB5CF3FB289ACA01E68DA5D59896E3A6165358B071B304D6AB3D018944BE5049D5E0E2BB819ACF67A6006111089E6767132D72DD85BEDDCBB2D64496DB0CC92955AB4C6234F1EEA24F2D51483F2E209E4589BF9519FAC51B4D061E801125E605F8093BB6997BC163D551596FE4AB7CFAE8FB9A90F6980480CE0C229FD1675409BD788354DAF316240CFE0AF93EB\"),\n\t    SHEX(\"9281BD03FE95545E5321A91A0AD8FA75A005B928C83450DF657419870C4E980E32484FCF1F598702ED20404FECE48A2EE9DBCF22120654AE402951605BED197E\"));\n  test_hash(&nettle_sha3_512, /* 166 octets */\n\t    SHEX(\"2ACE31ABB0A2E3267944D2F75E1559985DB7354C6E605F18DC8470423FCA30B7331D9B33C4A4326783D1CAAE1B4F07060EFF978E4746BF0C7E30CD61040BD5EC2746B29863EB7F103EBDA614C4291A805B6A4C8214230564A0557BC7102E0BD3ED23719252F7435D64D210EE2AAFC585BE903FA41E1968C50FD5D5367926DF7A05E3A42CF07E656FF92DE73B036CF8B19898C0CB34557C0C12C2D8B84E91181AF467BC75A9D1\"),\n\t    SHEX(\"6CA7023E20735624E83995A9E8AEBA66B9BC8D0A30DF67108EFF8AEDEB3B3CA484457BD0277C2552CBC7D63DC87EB556F2199C54EA73BAE647764DE18489B1F1\"));\n  test_hash(&nettle_sha3_512, /* 167 octets */\n\t    SHEX(\"0D8D09AED19F1013969CE5E7EB92F83A209AE76BE31C754844EA9116CEB39A22EBB6003017BBCF26555FA6624185187DB8F0CB3564B8B1C06BF685D47F3286EDA20B83358F599D2044BBF0583FAB8D78F854FE0A596183230C5EF8E54426750EAF2CC4E29D3BDD037E734D863C2BD9789B4C243096138F7672C232314EFFDFC6513427E2DA76916B5248933BE312EB5DDE4CF70804FB258AC5FB82D58D08177AC6F4756017FFF5\"),\n\t    SHEX(\"A965E699C1FFAEE369B3651C3A318582AE329AE51E6CCFB5275F58F748CEDB8F6B8434FAC4A1135AD9B555AA8CC1FF99A2220CBE83BFC1C374FFC927BB00ABD3\"));\n  test_hash(&nettle_sha3_512, /* 168 octets */\n\t    SHEX(\"C3236B73DEB7662BF3F3DAA58F137B358BA610560EF7455785A9BEFDB035A066E90704F929BD9689CEF0CE3BDA5ACF4480BCEB8D09D10B098AD8500D9B6071DFC3A14AF6C77511D81E3AA8844986C3BEA6F469F9E02194C92868CD5F51646256798FF0424954C1434BDFED9FACB390B07D342E992936E0F88BFD0E884A0DDB679D0547CCDEC6384285A45429D115AC7D235A717242021D1DC35641F5F0A48E8445DBA58E6CB2C8EA\"),\n\t    SHEX(\"4B44EC2D1848D0EC43AB0793390D24535F3328AD23C5F8FC43F5579BD16D84BBA08B233B0B5E24E22BF6CA2DEFEACA16BB98F8CDEAF26EECF2FC94AFE4604CF4\"));\n  test_hash(&nettle_sha3_512, /* 169 octets */\n\t    SHEX(\"B39FEB8283EADC63E8184B51DF5AE3FD41AAC8A963BB0BE1CD08AA5867D8D910C669221E73243360646F6553D1CA05A84E8DC0DE05B6419EC349CA994480193D01C92525F3FB3DCEFB08AFC6D26947BDBBFD85193F53B50609C6140905C53A6686B58E53A319A57B962331EDE98149AF3DE3118A819DA4D76706A0424B4E1D2910B0ED26AF61D150EBCB46595D4266A0BD7F651BA47D0C7F179CA28545007D92E8419D48FDFBD744CE\"),\n\t    SHEX(\"73169F0BE264565E45FB8F4665753E55F240846EB0D481CEF0274E4A3D859521767D9F675C0628DDCE155267BA686F2142805713F20C4C25E0B24398C65E3480\"));\n  test_hash(&nettle_sha3_512, /* 170 octets */\n\t    SHEX(\"A983D54F503803E8C7999F4EDBBE82E9084F422143A932DDDDC47A17B0B7564A7F37A99D0786E99476428D29E29D3C197A72BFAB1342C12A0FC4787FD7017D7A6174049EA43B5779169EF7472BDBBD941DCB82FC73AAC45A8A94C9F2BD3477F61FD3B796F02A1B8264A214C6FEA74B7051B226C722099EC7883A462B83B6AFDD4009248B8A237F605FE5A08FE7D8B45321421EBBA67BD70A0B00DDBF94BAAB7F359D5D1EEA105F28DCFB\"),\n\t    SHEX(\"9E1C196CB73D1EFA288D63902C64CE1A340BCDB8197F4AFECB1118DADD0D076B5FB7F6F809666CC58D2A8C1A68C65D0E91554C41D083F56D7B3DD37DF1B6C494\"));\n  test_hash(&nettle_sha3_512, /* 171 octets */\n\t    SHEX(\"E4D1C1897A0A866CE564635B74222F9696BF2C7F640DD78D7E2ACA66E1B61C642BB03EA7536AAE597811E9BF4A7B453EDE31F97B46A5F0EF51A071A2B3918DF16B152519AE3776F9F1EDAB4C2A377C3292E96408359D3613844D5EB393000283D5AD3401A318B12FD1474B8612F2BB50FB6A8B9E023A54D7DDE28C43D6D8854C8D9D1155935C199811DBFC87E9E0072E90EB88681CC7529714F8FB8A2C9D88567ADFB974EE205A9BF7B848\"),\n\t    SHEX(\"0C429CC164253C09538668135C9436FDBC79DA8E1FBE92E7BBC6EB30627591E7347CCB43F7AEC2D37FF3DABCFC9FA0C80629937C0C177C1C7ED0FC76A15DF075\"));\n  test_hash(&nettle_sha3_512, /* 172 octets */\n\t    SHEX(\"B10C59723E3DCADD6D75DF87D0A1580E73133A9B7D00CB95EC19F5547027323BE75158B11F80B6E142C6A78531886D9047B08E551E75E6261E79785366D7024BD7CD9CF322D9BE7D57FB661069F2481C7BB759CD71B4B36CA2BC2DF6D3A328FAEBDB995A9794A8D72155ED551A1F87C80BF6059B43FC764900B18A1C2441F7487743CF84E565F61F8DD2ECE6B6CCC9444049197AAAF53E926FBEE3BFCA8BE588EC77F29D211BE89DE18B15F6\"),\n\t    SHEX(\"700112FA90A1A2FD039A41B6485401634E757840E422AEB4A236634958192FFB2F2DDFA2253FC1ECB211C7E036098B714E62F7BF2B6975B1E95FAA9B8D02A73A\"));\n  test_hash(&nettle_sha3_512, /* 173 octets */\n\t    SHEX(\"DB11F609BABA7B0CA634926B1DD539C8CBADA24967D7ADD4D9876F77C2D80C0F4DCEFBD7121548373582705CCA2495BD2A43716FE64ED26D059CFB566B3364BD49EE0717BDD9810DD14D8FAD80DBBDC4CAFB37CC60FB0FE2A80FB4541B8CA9D59DCE457738A9D3D8F641AF8C3FD6DA162DC16FC01AAC527A4A0255B4D231C0BE50F44F0DB0B713AF03D968FE7F0F61ED0824C55C4B5265548FEBD6AAD5C5EEDF63EFE793489C39B8FD29D104CE\"),\n\t    SHEX(\"901C6D85509F01A47EA2E2792A5DB728EA39E5703EEDEAE41365EDF10A866B922B1093E52E687E312DB129DA1F053EF6848CB0B314C9A3A999EB3E75E14C9CC2\"));\n  test_hash(&nettle_sha3_512, /* 174 octets */\n\t    SHEX(\"BEBD4F1A84FC8B15E4452A54BD02D69E304B7F32616AADD90537937106AE4E28DE9D8AAB02D19BC3E2FDE1D651559E296453E4DBA94370A14DBBB2D1D4E2022302EE90E208321EFCD8528AD89E46DC839EA9DF618EA8394A6BFF308E7726BAE0C19BCD4BE52DA6258E2EF4E96AA21244429F49EF5CB486D7FF35CAC1BACB7E95711944BCCB2AB34700D42D1EB38B5D536B947348A458EDE3DC6BD6EC547B1B0CAE5B257BE36A7124E1060C170FFA\"),\n\t    SHEX(\"4CC9A61FFE08984417712B80F962365AF36ED66A8AAB2A788D22A5C6B23962D23584638E712E9183C0A271383DB0877F722D399116F9BEF79A56AB096EF21749\"));\n  test_hash(&nettle_sha3_512, /* 175 octets */\n\t    SHEX(\"5ACA56A03A13784BDC3289D9364F79E2A85C12276B49B92DB0ADAA4F206D5028F213F678C3510E111F9DC4C1C1F8B6ACB17A6413AA227607C515C62A733817BA5E762CC6748E7E0D6872C984D723C9BB3B117EB8963185300A80BFA65CDE495D70A46C44858605FCCBED086C2B45CEF963D33294DBE9706B13AF22F1B7C4CD5A001CFEC251FBA18E722C6E1C4B1166918B4F6F48A98B64B3C07FC86A6B17A6D0480AB79D4E6415B520F1C484D675B1\"),\n\t    SHEX(\"B36EA56BB6BF80D91D5A605F8409AE6B7D879EC40815B35C664CC6B01BF6C718AD464F15C34DD1315A79A5456B6C3F8ED89E60390BC71EF747E12CDC77706245\"));\n  test_hash(&nettle_sha3_512, /* 176 octets */\n\t    SHEX(\"A5AAD0E4646A32C85CFCAC73F02FC5300F1982FABB2F2179E28303E447854094CDFC854310E5C0F60993CEFF54D84D6B46323D930ADB07C17599B35B505F09E784BCA5985E0172257797FB53649E2E9723EFD16865C31B5C3D5113B58BB0BFC8920FABDDA086D7537E66D709D050BD14D0C960873F156FAD5B3D3840CDFCDC9BE6AF519DB262A27F40896AB25CC39F96984D650611C0D5A3080D5B3A1BF186ABD42956588B3B58CD948970D298776060\"),\n\t    SHEX(\"8ECB8F622DAB7087E9A95CD0341192FEA6B1C956DF9AD3DED823948B7849C4F3150C9559520953EBDE98ED76F6E43BFE4FB25FDA712525C6D3DAA80323BE8E4A\"));\n  test_hash(&nettle_sha3_512, /* 177 octets */\n\t    SHEX(\"06CBBE67E94A978203EAD6C057A1A5B098478B4B4CBEF5A97E93C8E42F5572713575FC2A884531D7622F8F879387A859A80F10EF02708CD8F7413AB385AFC357678B9578C0EBF641EF076A1A30F1F75379E9DCB2A885BDD295905EE80C0168A62A9597D10CF12DD2D8CEE46645C7E5A141F6E0E23AA482ABE5661C16E69EF1E28371E2E236C359BA4E92C25626A7B7FF13F6EA4AE906E1CFE163E91719B1F750A96CBDE5FBC953D9E576CD216AFC90323A\"),\n\t    SHEX(\"519215DA34ACFCD62DD617ECD5978365417D57C2671A7B48655B89F448B23B128D3AD04910A1BBBDC00E954A1E49765176A8ACA4C37D56ABF0E0B72E331A8D7C\"));\n  test_hash(&nettle_sha3_512, /* 178 octets */\n\t    SHEX(\"F1C528CF7739874707D4D8AD5B98F7C77169DE0B57188DF233B2DC8A5B31EDA5DB4291DD9F68E6BAD37B8D7F6C9C0044B3BF74BBC3D7D1798E138709B0D75E7C593D3CCCDC1B20C7174B4E692ADD820ACE262D45CCFAE2077E878796347168060A162ECCA8C38C1A88350BD63BB539134F700FD4ADDD5959E255337DAA06BC86358FABCBEFDFB5BC889783D843C08AADC6C4F6C36F65F156E851C9A0F917E4A367B5AD93D874812A1DE6A7B93CD53AD97232\"),\n\t    SHEX(\"0D1C1AD4E1CFEFEE854C4A739A0342E39D700DBAF4891978D7C839E87C680717D63AB4AA1ED7EB657CED9F8D2CF47204262E609610842FC5B219ACFF7EB188C4\"));\n  test_hash(&nettle_sha3_512, /* 179 octets */\n\t    SHEX(\"9D9F3A7ECD51B41F6572FD0D0881E30390DFB780991DAE7DB3B47619134718E6F987810E542619DFAA7B505C76B7350C6432D8BF1CFEBDF1069B90A35F0D04CBDF130B0DFC7875F4A4E62CDB8E525AADD7CE842520A482AC18F09442D78305FE85A74E39E760A4837482ED2F437DD13B2EC1042AFCF9DECDC3E877E50FF4106AD10A525230D11920324A81094DA31DEAB6476AA42F20C84843CFC1C58545EE80352BDD3740DD6A16792AE2D86F11641BB717C2\"),\n\t    SHEX(\"0A5D9EF40BA2B98EDBD7918CC6779483A1A00BD94CC1E1495495CAF6CD47C6239571C3828F4565A0D53786781D712C10EF7333227F651974628887D442A5EF9D\"));\n  test_hash(&nettle_sha3_512, /* 180 octets */\n\t    SHEX(\"5179888724819FBAD3AFA927D3577796660E6A81C52D98E9303261D5A4A83232F6F758934D50AA83FF9E20A5926DFEBAAC49529D006EB923C5AE5048ED544EC471ED7191EDF46363383824F915769B3E688094C682B02151E5EE01E510B431C8865AFF8B6B6F2F59CB6D129DA79E97C6D2B8FA6C6DA3F603199D2D1BCAB547682A81CD6CF65F6551121391D78BCC23B5BD0E922EC6D8BF97C952E84DD28AEF909ABA31EDB903B28FBFC33B7703CD996215A11238\"),\n\t    SHEX(\"EA83DE9AE057701F6EC68FF67E92E0334C18EBB79AF1953C2514408D58E69F105441642A1D5B7D6010F7CB15D131DD531855CA337A7B0B794FA6D6923F017AFA\"));\n  test_hash(&nettle_sha3_512, /* 181 octets */\n\t    SHEX(\"576EF3520D30B7A4899B8C0D5E359E45C5189ADD100E43BE429A02FB3DE5FF4F8FD0E79D9663ACCA72CD29C94582B19292A557C5B1315297D168FBB54E9E2ECD13809C2B5FCE998EDC6570545E1499DBE7FB74D47CD7F35823B212B05BF3F5A79CAA34224FDD670D335FCB106F5D92C3946F44D3AFCBAE2E41AC554D8E6759F332B76BE89A0324AA12C5482D1EA3EE89DED4936F3E3C080436F539FA137E74C6D3389BDF5A45074C47BC7B20B0948407A66D855E2F\"),\n\t    SHEX(\"6651C25D33D10B72535F1DB26A1DFE2EB99CDD505448018589B5B88B7CAB63EB439C31A474C6F1191DF14EFC7D0665CC7B82A7DC54A7C6B0C2FD1F75C30D6872\"));\n  test_hash(&nettle_sha3_512, /* 182 octets */\n\t    SHEX(\"0DF2152FA4F4357C8741529DD77E783925D3D76E95BAFA2B542A2C33F3D1D117D159CF473F82310356FEE4C90A9E505E70F8F24859656368BA09381FA245EB6C3D763F3093F0C89B972E66B53D59406D9F01AEA07F8B3B615CAC4EE4D05F542E7D0DAB45D67CCCCD3A606CCBEB31EA1FA7005BA07176E60DAB7D78F6810EF086F42F08E595F0EC217372B98970CC6321576D92CE38F7C397A403BADA1548D205C343AC09DECA86325373C3B76D9F32028FEA8EB32515\"),\n\t    SHEX(\"A754652247F7285CE2DD8A10035C69961E4F9C025E1FD087CBD3126E049A9E832C3F3A491FCDE338B8C01946CDD7DEC32A8FD7ED1CB3045BCAF3398905B1BB42\"));\n  test_hash(&nettle_sha3_512, /* 183 octets */\n\t    SHEX(\"3E15350D87D6EBB5C8AD99D42515CFE17980933C7A8F6B8BBBF0A63728CEFAAD2052623C0BD5931839112A48633FB3C2004E0749C87A41B26A8B48945539D1FF41A4B269462FD199BFECD45374756F55A9116E92093AC99451AEFB2AF9FD32D6D7F5FBC7F7A540D5097C096EBC3B3A721541DE073A1CC02F7FB0FB1B9327FB0B1218CA49C9487AB5396622A13AE546C97ABDEF6B56380DDA7012A8384091B6656D0AB272D363CEA78163FF765CDD13AB1738B940D16CAE\"),\n\t    SHEX(\"FC1127F6650F32638453AB773F5CE60F9F6165BC9928EFF18C7A3281540C7A615D2D62A92E557D4A1EC1229E84819D2DBF06CED4DE0FF90040ECB961D678E181\"));\n  test_hash(&nettle_sha3_512, /* 184 octets */\n\t    SHEX(\"C38D6B0B757CB552BE40940ECE0009EF3B0B59307C1451686F1A22702922800D58BCE7A636C1727EE547C01B214779E898FC0E560F8AE7F61BEF4D75EAA696B921FD6B735D171535E9EDD267C192B99880C87997711002009095D8A7A437E258104A41A505E5EF71E5613DDD2008195F0C574E6BA3FE40099CFA116E5F1A2FA8A6DA04BADCB4E2D5D0DE31FDC4800891C45781A0AAC7C907B56D631FCA5CE8B2CDE620D11D1777ED9FA603541DE794DDC5758FCD5FAD78C0\"),\n\t    SHEX(\"43C21BCCAC7ACEE8ED437B874ED7CDF20EA2E9DC98AB82124610DC4F8416248B51309045CDFBCE92EFA9E56C5B36D6E5D27580319CE69C22E5D6C87E551EED4A\"));\n  test_hash(&nettle_sha3_512, /* 185 octets */\n\t    SHEX(\"8D2DE3F0B37A6385C90739805B170057F091CD0C7A0BC951540F26A5A75B3E694631BB64C7635EED316F51318E9D8DE13C70A2ABA04A14836855F35E480528B776D0A1E8A23B547C8B8D6A0D09B241D3BE9377160CCA4E6793D00A515DC2992CB7FC741DACA171431DA99CCE6F7789F129E2AC5CF65B40D703035CD2185BB936C82002DAF8CBC27A7A9E554B06196630446A6F0A14BA155ED26D95BD627B7205C072D02B60DB0FD7E49EA058C2E0BA202DAFF0DE91E845CF79\"),\n\t    SHEX(\"893934B8C630A9BF713C64FFD1128EAC75D1CEFDEF6642FB27F20CB56694C2FA8BA6EFCF3E0E56C7789CFAAC6B2F7B247DEA8367FFD269E74B9CDFB0537031EA\"));\n  test_hash(&nettle_sha3_512, /* 186 octets */\n\t    SHEX(\"C464BBDAD275C50DCD983B65AD1019B9FF85A1E71C807F3204BB2C921DC31FBCD8C5FC45868AE9EF85B6C9B83BBA2A5A822201ED68586EC5EC27FB2857A5D1A2D09D09115F22DCC39FE61F5E1BA0FF6E8B4ACB4C6DA748BE7F3F0839739394FF7FA8E39F7F7E84A33C3866875C01BCB1263C9405D91908E9E0B50E7459FABB63D8C6BBB73D8E3483C099B55BC30FF092FF68B6ADEDFD477D63570C9F5515847F36E24BA0B705557130CEC57EBAD1D0B31A378E91894EE26E3A04\"),\n\t    SHEX(\"B4CB58D8497978916DC362D37ADE12C7A0D8FE3B08B370659B27218291E04EF343095A91887B040984CB80B0C8611FD12C18EAD37B95320D59EDDB32113E42A4\"));\n  test_hash(&nettle_sha3_512, /* 187 octets */\n\t    SHEX(\"8B8D68BB8A75732FE272815A68A1C9C5AA31B41DEDC8493E76525D1D013D33CEBD9E21A5BB95DB2616976A8C07FCF411F5F6BC6F7E0B57ACA78CC2790A6F9B898858AC9C79B165FF24E66677531E39F572BE5D81EB3264524181115F32780257BFB9AEEC6AF12AF28E587CAC068A1A2953B59AD680F4C245B2E3EC36F59940D37E1D3DB38E13EDB29B5C0F404F6FF87F80FC8BE7A225FF22FBB9C8B6B1D7330C57840D24BC75B06B80D30DAD6806544D510AF6C4785E823AC3E0B8\"),\n\t    SHEX(\"35C3F8F0DC28608EC942CB6287482219B42B2EBCBAD92B4C34E77E21B7D93B0E85EBF483DB2D4A979C48E58F746AC3DCF563CA7E1B2940371D8D83BF0795EC45\"));\n  test_hash(&nettle_sha3_512, /* 188 octets */\n\t    SHEX(\"6B018710446F368E7421F1BC0CCF562D9C1843846BC8D98D1C9BF7D9D6FCB48BFC3BF83B36D44C4FA93430AF75CD190BDE36A7F92F867F58A803900DF8018150384D85D82132F123006AC2AEBA58E02A037FE6AFBD65ECA7C44977DD3DC74F48B6E7A1BFD5CC4DCF24E4D52E92BD4455848E4928B0EAC8B7476FE3CC03E862AA4DFF4470DBFED6DE48E410F25096487ECFC32A27277F3F5023B2725ADE461B1355889554A8836C9CF53BD767F5737D55184EEA1AB3F53EDD0976C485\"),\n\t    SHEX(\"B90E0CC6BC53182C4F2D17AA51391C8250C3032A12DAF2FCC641B49AA81ED9449403567B75D4121376DD8CC2D2BDBAFA456308AD7C0C13BA85619D75350727E3\"));\n  test_hash(&nettle_sha3_512, /* 189 octets */\n\t    SHEX(\"C9534A24714BD4BE37C88A3DA1082EDA7CABD154C309D7BD670DCCD95AA535594463058A29F79031D6ECAA9F675D1211E9359BE82669A79C855EA8D89DD38C2C761DDD0EC0CE9E97597432E9A1BEAE062CDD71EDFDFD464119BE9E69D18A7A7FD7CE0E2106F0C8B0ABF4715E2CA48EF9F454DC203C96656653B727083513F8EFB86E49C513BB758B3B052FE21F1C05BB33C37129D6CC81F1AEF6ADC45B0E8827A830FE545CF57D0955802C117D23CCB55EA28F95C0D8C2F9C5A242B33F\"),\n\t    SHEX(\"99497355AE1791799D11536C73605CDD1496C74E3E930B6272A103C3AA8C984D2D74B01AE72C94F2A4D3A069EAC6E00984D21EAE3DD7B32AD082B396601093BA\"));\n  test_hash(&nettle_sha3_512, /* 190 octets */\n\t    SHEX(\"07906C87297B867ABF4576E9F3CC7F82F22B154AFCBF293B9319F1B0584DA6A40C27B32E0B1B7F412C4F1B82480E70A9235B12EC27090A5A33175A2BB28D8ADC475CEFE33F7803F8CE27967217381F02E67A3B4F84A71F1C5228E0C2AD971373F6F672624FCEA8D1A9F85170FAD30FA0BBD25035C3B41A6175D467998BD1215F6F3866F53847F9CF68EF3E2FBB54BC994DE2302B829C5EEA68EC441FCBAFD7D16AE4FE9FFF98BF00E5BC2AD54DD91FF9FDA4DD77B6C754A91955D1FBAAD0\"),\n\t    SHEX(\"C98265396F3278FC532125DED097A6851FC5BF37CA32EC26F43E64874241309F568A217119BA984C54099F8899AC94B7900A4DD9D3877E18371F5DAFD1921F08\"));\n  test_hash(&nettle_sha3_512, /* 191 octets */\n\t    SHEX(\"588E94B9054ABC2189DF69B8BA34341B77CDD528E7860E5DEFCAA79B0C9A452AD4B82AA306BE84536EB7CEDCBE058D7B84A6AEF826B028B8A0271B69AC3605A9635EA9F5EA0AA700F3EB7835BC54611B922964300C953EFE7491E3677C2CEBE0822E956CD16433B02C68C4A23252C3F9E151A416B4963257B783E038F6B4D5C9F110F871652C7A649A7BCEDCBCCC6F2D0725BB903CC196BA76C76AA9F10A190B1D1168993BAA9FFC96A1655216773458BEC72B0E39C9F2C121378FEAB4E76A\"),\n\t    SHEX(\"FC03BE193A5ED0E6B3502661C2D9E4E2A503CF3FDB231526A90C3C4C26089C787EE6CBF50D90AF61C17C5DF0B29C373B426740CD0D6FC370DE64EB2164BBAEB2\"));\n  test_hash(&nettle_sha3_512, /* 192 octets */\n\t    SHEX(\"08959A7E4BAAE874928813364071194E2939772F20DB7C3157078987C557C2A6D5ABE68D520EEF3DC491692E1E21BCD880ADEBF63BB4213B50897FA005256ED41B5690F78F52855C8D9168A4B666FCE2DA2B456D7A7E7C17AB5F2FB1EE90B79E698712E963715983FD07641AE4B4E9DC73203FAC1AE11FA1F8C7941FCC82EAB247ADDB56E2638447E9D609E610B60CE086656AAEBF1DA3C8A231D7D94E2FD0AFE46B391FF14A72EAEB3F44AD4DF85866DEF43D4781A0B3578BC996C87970B132\"),\n\t    SHEX(\"FB9C3A9183B6D251BF61FAF1843455CB9C1BE35EABDC131D5BF38E98337934968291E9D6DC104374BC234FF22CC23CD6F338E7A3B019CDC9DF6E3750B6B01FDE\"));\n  test_hash(&nettle_sha3_512, /* 193 octets */\n\t    SHEX(\"CB2A234F45E2ECD5863895A451D389A369AAB99CFEF0D5C9FFCA1E6E63F763B5C14FB9B478313C8E8C0EFEB3AC9500CF5FD93791B789E67EAC12FD038E2547CC8E0FC9DB591F33A1E4907C64A922DDA23EC9827310B306098554A4A78F050262DB5B545B159E1FF1DCA6EB734B872343B842C57EAFCFDA8405EEDBB48EF32E99696D135979235C3A05364E371C2D76F1902F1D83146DF9495C0A6C57D7BF9EE77E80F9787AEE27BE1FE126CDC9EF893A4A7DCBBC367E40FE4E1EE90B42EA25AF01\"),\n\t    SHEX(\"F7965B71198636F162D5A4E08D73E8C8A9AC1ADDBDFD7C180C489CCA7360B3FEE3A4286154460BF867923B348BFE32E79D9139A0CB52C46FA20785FAEAE0A8BC\"));\n  test_hash(&nettle_sha3_512, /* 194 octets */\n\t    SHEX(\"D16BEADF02AB1D4DC6F88B8C4554C51E866DF830B89C06E786A5F8757E8909310AF51C840EFE8D20B35331F4355D80F73295974653DDD620CDDE4730FB6C8D0D2DCB2B45D92D4FBDB567C0A3E86BD1A8A795AF26FBF29FC6C65941CDDB090FF7CD230AC5268AB4606FCCBA9EDED0A2B5D014EE0C34F0B2881AC036E24E151BE89EEB6CD9A7A790AFCCFF234D7CB11B99EBF58CD0C589F20BDAC4F9F0E28F75E3E04E5B3DEBCE607A496D848D67FA7B49132C71B878FD5557E082A18ECA1FBDA94D4B\"),\n\t    SHEX(\"5337477487A0AF43EB7B995293CA2BEF6EAB2432B1333DCAEAD7064406E22861FCEA623FD8B85B30465787352A36C943610F1458FD22E3F55DDD195A6ACAA374\"));\n  test_hash(&nettle_sha3_512, /* 195 octets */\n\t    SHEX(\"8F65F6BC59A85705016E2BAE7FE57980DE3127E5AB275F573D334F73F8603106EC3553016608EF2DD6E69B24BE0B7113BF6A760BA6E9CE1C48F9E186012CF96A1D4849D75DF5BB8315387FD78E9E153E76F8BA7EC6C8849810F59FB4BB9B004318210B37F1299526866F44059E017E22E96CBE418699D014C6EA01C9F0038B10299884DBEC3199BB05ADC94E955A1533219C1115FED0E5F21228B071F40DD57C4240D98D37B73E412FE0FA4703120D7C0C67972ED233E5DEB300A22605472FA3A3BA86\"),\n\t    SHEX(\"28AB5C6298A602AE51EEEC4080245F7CA10F9A8C304F22B5AA88D0E49226C01C2FD3CC5D8E99309767816E4F6D52719876065495DDB61DD113CFFF06B11D8604\"));\n  test_hash(&nettle_sha3_512, /* 196 octets */\n\t    SHEX(\"84891E52E0D451813210C3FD635B39A03A6B7A7317B221A7ABC270DFA946C42669AACBBBDF801E1584F330E28C729847EA14152BD637B3D0F2B38B4BD5BF9C791C58806281103A3EABBAEDE5E711E539E6A8B2CF297CF351C078B4FA8F7F35CF61BEBF8814BF248A01D41E86C5715EA40C63F7375379A7EB1D78F27622FB468AB784AAABA4E534A6DFD1DF6FA15511341E725ED2E87F98737CCB7B6A6DFAE416477472B046BF1811187D151BFA9F7B2BF9ACDB23A3BE507CDF14CFDF517D2CB5FB9E4AB6\"),\n\t    SHEX(\"2AEEAC015D93245F6BF727CD182894097B902CD407D7E0DD06DA1A63F4451C657FF39F925E7C8A894AE593D11EBC2D5D1DE3D9A18018806719277D993F7FABED\"));\n  test_hash(&nettle_sha3_512, /* 197 octets */\n\t    SHEX(\"FDD7A9433A3B4AFABD7A3A5E3457E56DEBF78E84B7A0B0CA0E8C6D53BD0C2DAE31B2700C6128334F43981BE3B213B1D7A118D59C7E6B6493A86F866A1635C12859CFB9AD17460A77B4522A5C1883C3D6ACC86E6162667EC414E9A104AA892053A2B1D72165A855BACD8FAF8034A5DD9B716F47A0818C09BB6BAF22AA503C06B4CA261F557761989D2AFBD88B6A678AD128AF68672107D0F1FC73C5CA740459297B3292B281E93BCEB761BDE7221C3A55708E5EC84472CDDCAA84ECF23723CC0991355C6280\"),\n\t    SHEX(\"D0A119617B7E30C2A85ECBB3BBF325DDD589431C8C2E2F9FC6E324A6ED8BAF11870A80556CC0688FEE4DB70F22B9424B4F37A0F1E7EA314684DA31BF473B3F34\"));\n  test_hash(&nettle_sha3_512, /* 198 octets */\n\t    SHEX(\"70A40BFBEF92277A1AAD72F6B79D0177197C4EBD432668CFEC05D099ACCB651062B5DFF156C0B27336687A94B26679CFDD9DAF7AD204338DD9C4D14114033A5C225BD11F217B5F4732DA167EE3F939262D4043FC9CBA92303B7B5E96AEA12ADDA64859DF4B86E9EE0B58E39091E6B188B408AC94E1294A8911245EE361E60E601EFF58D1D37639F3753BEC80EBB4EFDE25817436076623FC65415FE51D1B0280366D12C554D86743F3C3B6572E400361A60726131441BA493A83FBE9AFDA90F7AF1AE717238D\"),\n\t    SHEX(\"1C88789885DCCC9AE81029ACF0B6C9D083CDB9774C345F1C755E54C45E9AF63A70DC2ABAEFEB1AD416F1BD3D9B69D4C4404D22C85E636A4703769C0112B550B8\"));\n  test_hash(&nettle_sha3_512, /* 199 octets */\n\t    SHEX(\"74356E449F4BF8644F77B14F4D67CB6BD9C1F5AE357621D5B8147E562B65C66585CAF2E491B48529A01A34D226D436959153815380D5689E30B35357CDAC6E08D3F2B0E88E200600D62BD9F5EAF488DF86A4470EA227006182E44809009868C4C280C43D7D64A5268FA719074960087B3A6ABC837882F882C837834535929389A12B2C78187E2EA07EF8B8EEF27DC85002C3AE35F1A50BEE6A1C48BA7E175F3316670B27983472AA6A61EED0A683A39EE323080620EA44A9F74411AE5CE99030528F9AB49C79F2\"),\n\t    SHEX(\"F52D7DD7FF248A1BCA7B714F14A79DF5766FD67C0031A471CC509F3516D7C348C33F7D4B1CA331B9323896B7074E10A891CEA851F9AC20245812B8CFAA556352\"));\n  test_hash(&nettle_sha3_512, /* 200 octets */\n\t    SHEX(\"8C3798E51BC68482D7337D3ABB75DC9FFE860714A9AD73551E120059860DDE24AB87327222B64CF774415A70F724CDF270DE3FE47DDA07B61C9EF2A3551F45A5584860248FABDE676E1CD75F6355AA3EAEABE3B51DC813D9FB2EAA4F0F1D9F834D7CAD9C7C695AE84B329385BC0BEF895B9F1EDF44A03D4B410CC23A79A6B62E4F346A5E8DD851C2857995DDBF5B2D717AEB847310E1F6A46AC3D26A7F9B44985AF656D2B7C9406E8A9E8F47DCB4EF6B83CAACF9AEFB6118BFCFF7E44BEF6937EBDDC89186839B77\"),\n\t    SHEX(\"A8AEE42A77C9B6387DC97319581959D9BD878D061487FD069ACA04D6F84D347E23587A6C7C56329B2DF88C56C7100ED51ACE5B5F778D65478F059CAFD6C098FD\"));\n  test_hash(&nettle_sha3_512, /* 201 octets */\n\t    SHEX(\"FA56BF730C4F8395875189C10C4FB251605757A8FECC31F9737E3C2503B02608E6731E85D7A38393C67DE516B85304824BFB135E33BF22B3A23B913BF6ACD2B7AB85198B8187B2BCD454D5E3318CACB32FD6261C31AE7F6C54EF6A7A2A4C9F3ECB81CE3555D4F0AD466DD4C108A90399D70041997C3B25345A9653F3C9A6711AB1B91D6A9D2216442DA2C973CBD685EE7643BFD77327A2F7AE9CB283620A08716DFB462E5C1D65432CA9D56A90E811443CD1ECB8F0DE179C9CB48BA4F6FEC360C66F252F6E64EDC96B\"),\n\t    SHEX(\"4B961C4BB6035E7BDDA2E1A3B6F9CD52D1789866044C4A925693BEA88F65D046238BBEB4E7D3B060E47288041407392B291AE610BA70D6B4D64E74E7A7D0256F\"));\n  test_hash(&nettle_sha3_512, /* 202 octets */\n\t    SHEX(\"B6134F9C3E91DD8000740D009DD806240811D51AB1546A974BCB18D344642BAA5CD5903AF84D58EC5BA17301D5EC0F10CCD0509CBB3FD3FFF9172D193AF0F782252FD1338C7244D40E0E42362275B22D01C4C3389F19DD69BDF958EBE28E31A4FFE2B5F18A87831CFB7095F58A87C9FA21DB72BA269379B2DC2384B3DA953C7925761FED324620ACEA435E52B424A7723F6A2357374157A34CD8252351C25A1B232826CEFE1BD3E70FFC15A31E7C0598219D7F00436294D11891B82497BC78AA5363892A2495DF8C1EEF\"),\n\t    SHEX(\"C0515B65B640B3FFD0A1582A54F4C8FB35C109B7FB472666E043D3C00AE3E0E0FA156C4CEFB46B5B7B4C0E480623E1A26018BDAEDC3E27D9C0D44C3E1D862015\"));\n  test_hash(&nettle_sha3_512, /* 203 octets */\n\t    SHEX(\"C941CDB9C28AB0A791F2E5C8E8BB52850626AA89205BEC3A7E22682313D198B1FA33FC7295381354858758AE6C8EC6FAC3245C6E454D16FA2F51C4166FAB51DF272858F2D603770C40987F64442D487AF49CD5C3991CE858EA2A60DAB6A65A34414965933973AC2457089E359160B7CDEDC42F29E10A91921785F6B7224EE0B349393CDCFF6151B50B377D609559923D0984CDA6000829B916AB6896693EF6A2199B3C22F7DC5500A15B8258420E314C222BC000BC4E5413E6DD82C993F8330F5C6D1BE4BC79F08A1A0A46\"),\n\t    SHEX(\"45C584564D9E0B8239CC1284939BA407A8E5E981691EAB6A04D9354C9C855E400B3037151122CED237636E61A7FF2905E0213A6D07306C459E2189E3E6A9E0B8\"));\n  test_hash(&nettle_sha3_512, /* 204 octets */\n\t    SHEX(\"4499EFFFAC4BCEA52747EFD1E4F20B73E48758BE915C88A1FFE5299B0B005837A46B2F20A9CB3C6E64A9E3C564A27C0F1C6AD1960373036EC5BFE1A8FC6A435C2185ED0F114C50E8B3E4C7ED96B06A036819C9463E864A58D6286F785E32A804443A56AF0B4DF6ABC57ED5C2B185DDEE8489EA080DEEEE66AA33C2E6DAB36251C402682B6824821F998C32163164298E1FAFD31BABBCFFB594C91888C6219079D907FDB438ED89529D6D96212FD55ABE20399DBEFD342248507436931CDEAD496EB6E4A80358ACC78647D043\"),\n\t    SHEX(\"136723350857E03756F02E60451A28E711611927B8136DCFF3E567DC618FF36B3100737C9781B9C84A576745C1E6BE030DAC8803A71464AF39DB94D00253AF3E\"));\n  test_hash(&nettle_sha3_512, /* 205 octets */\n\t    SHEX(\"EECBB8FDFA4DA62170FD06727F697D81F83F601FF61E478105D3CB7502F2C89BF3E8F56EDD469D049807A38882A7EEFBC85FC9A950952E9FA84B8AFEBD3CE782D4DA598002827B1EB98882EA1F0A8F7AA9CE013A6E9BC462FB66C8D4A18DA21401E1B93356EB12F3725B6DB1684F2300A98B9A119E5D27FF704AFFB618E12708E77E6E5F34139A5A41131FD1D6336C272A8FC37080F041C71341BEE6AB550CB4A20A6DDB6A8E0299F2B14BC730C54B8B1C1C487B494BDCCFD3A53535AB2F231590BF2C4062FD2AD58F906A2D0D\"),\n\t    SHEX(\"C0F7713AA021A04525F751722A9AE5C4C7934D0A286F1FB05823D86A96251C04DECD960D8D4D66E2C565E6207A49612E1EFDE386536854B6AB9A4807B0A145BE\"));\n  test_hash(&nettle_sha3_512, /* 206 octets */\n\t    SHEX(\"E64F3E4ACE5C8418D65FEC2BC5D2A303DD458034736E3B0DF719098BE7A206DEAF52D6BA82316CAF330EF852375188CDE2B39CC94AA449578A7E2A8E3F5A9D68E816B8D16889FBC0EBF0939D04F63033AE9AE2BDAB73B88C26D6BD25EE460EE1EF58FB0AFA92CC539F8C76D3D097E7A6A63EBB9B5887EDF3CF076028C5BBD5B9DB3211371AD3FE121D4E9BF44229F4E1ECF5A0F9F0EBA4D5CEB72878AB22C3F0EB5A625323AC66F7061F4A81FAC834471E0C59553F108475FE290D43E6A055AE3EE46FB67422F814A68C4BE3E8C9\"),\n\t    SHEX(\"FE1CB67D77FB463F77747FED292A989A341044A8B65FA1DF1441AA41A5C795916626E0E479FD0BA7F9B1DC15FED245B99598D35359834E8FD25CF19685219BE2\"));\n  test_hash(&nettle_sha3_512, /* 207 octets */\n\t    SHEX(\"D2CB2D733033F9E91395312808383CC4F0CA974E87EC68400D52E96B3FA6984AC58D9AD0938DDE5A973008D818C49607D9DE2284E7618F1B8AED8372FBD52ED54557AF4220FAC09DFA8443011699B97D743F8F2B1AEF3537EBB45DCC9E13DFB438428EE190A4EFDB3CAEB7F3933117BF63ABDC7E57BEB4171C7E1AD260AB0587806C4D137B6316B50ABC9CCE0DFF3ACADA47BBB86BE777E617BBE578FF4519844DB360E0A96C6701290E76BB95D26F0F804C8A4F2717EAC4E7DE9F2CFF3BBC55A17E776C0D02856032A6CD10AD2838\"),\n\t    SHEX(\"4043CDD3F0EA793E49A8EC382F8071F6020B529CF8C82E969429117B362129B7689D3F1EA7FF77EE50263CECDAC5A43AA2AEE97CF3E665CCF535F6DE65AD0100\"));\n  test_hash(&nettle_sha3_512, /* 208 octets */\n\t    SHEX(\"F2998955613DD414CC111DF5CE30A995BB792E260B0E37A5B1D942FE90171A4AC2F66D4928D7AD377F4D0554CBF4C523D21F6E5F379D6F4B028CDCB9B1758D3B39663242FF3CB6EDE6A36A6F05DB3BC41E0D861B384B6DEC58BB096D0A422FD542DF175E1BE1571FB52AE66F2D86A2F6824A8CFAACBAC4A7492AD0433EEB15454AF8F312B3B2A577750E3EFBD370E8A8CAC1582581971FBA3BA4BD0D76E718DACF8433D33A59D287F8CC92234E7A271041B526E389EFB0E40B6A18B3AAF658E82ED1C78631FD23B4C3EB27C3FAEC8685\"),\n\t    SHEX(\"7392BD445F58CD5D7D3CA98579CBAA9A9437D0C95E7932B4004117F207F8AA39156BC42537B0C790150D443C2D68C2C43E362DF9D019601797162E63076936C3\"));\n  test_hash(&nettle_sha3_512, /* 209 octets */\n\t    SHEX(\"447797E2899B72A356BA55BF4DF3ACCA6CDB1041EB477BD1834A9F9ACBC340A294D729F2F97DF3A610BE0FF15EDB9C6D5DB41644B9874360140FC64F52AA03F0286C8A640670067A84E017926A70438DB1BB361DEFEE7317021425F8821DEF26D1EFD77FC853B818545D055ADC9284796E583C76E6FE74C9AC2587AA46AA8F8804F2FEB5836CC4B3ABABAB8429A5783E17D5999F32242EB59EF30CD7ADABC16D72DBDB097623047C98989F88D14EAF02A7212BE16EC2D07981AAA99949DDF89ECD90333A77BC4E1988A82ABF7C7CAF3291\"),\n\t    SHEX(\"9FF0F0D70CA076CA44C353A3C678C2095C89F619BB53EC9CB4888E2F14E50FBC146A7B521356369F1B9D5665836E45D5400F9856CC6DA3B3AFE6F3B0471FC9C6\"));\n  test_hash(&nettle_sha3_512, /* 210 octets */\n\t    SHEX(\"9F2C18ADE9B380C784E170FB763E9AA205F64303067EB1BCEA93DF5DAC4BF5A2E00B78195F808DF24FC76E26CB7BE31DC35F0844CDED1567BBA29858CFFC97FB29010331B01D6A3FB3159CC1B973D255DA9843E34A0A4061CABDB9ED37F241BFABB3C20D32743F4026B59A4CCC385A2301F83C0B0A190B0F2D01ACB8F0D41111E10F2F4E149379275599A52DC089B35FDD5234B0CFB7B6D8AEBD563CA1FA653C5C021DFD6F5920E6F18BFAFDBECBF0AB00281333ED50B9A999549C1C8F8C63D7626C48322E9791D5FF72294049BDE91E73F8\"),\n\t    SHEX(\"A981FAA9D3CAC492B2FA078D1158F81248DF8DB36ACBD5BAD3A6C633BBE500EB481D2937BEEE9A76C84EDCDFA0F997EDCE708F07851422A7597E2463FC1912CD\"));\n  test_hash(&nettle_sha3_512, /* 211 octets */\n\t    SHEX(\"AE159F3FA33619002AE6BCCE8CBBDD7D28E5ED9D61534595C4C9F43C402A9BB31F3B301CBFD4A43CE4C24CD5C9849CC6259ECA90E2A79E01FFBAC07BA0E147FA42676A1D668570E0396387B5BCD599E8E66AAED1B8A191C5A47547F61373021FA6DEADCB55363D233C24440F2C73DBB519F7C9FA5A8962EFD5F6252C0407F190DFEFAD707F3C7007D69FF36B8489A5B6B7C557E79DD4F50C06511F599F56C896B35C917B63BA35C6FF8092BAF7D1658E77FC95D8A6A43EEB4C01F33F03877F92774BE89C1114DD531C011E53A34DC248A2F0E6\"),\n\t    SHEX(\"89025C13BC6B61A1BFADB1D37D676E49E6754E9DFC00D52C5EF13BA57C845D14AC75D5AE6F06714028103C3424717F4C2FBF6D88D055690987620AC5B440576A\"));\n  test_hash(&nettle_sha3_512, /* 212 octets */\n\t    SHEX(\"3B8E97C5FFC2D6A40FA7DE7FCEFC90F3B12C940E7AB415321E29EE692DFAC799B009C99DCDDB708FCE5A178C5C35EE2B8617143EDC4C40B4D313661F49ABDD93CEA79D117518805496FE6ACF292C4C2A1F76B403A97D7C399DAF85B46AD84E16246C67D6836757BDE336C290D5D401E6C1386AB32797AF6BB251E9B2D8FE754C47482B72E0B394EAB76916126FD68EA7D65EB93D59F5B4C5AC40F7C3B37E7F3694F29424C24AF8C8F0EF59CD9DBF1D28E0E10F799A6F78CAD1D45B9DB3D7DEE4A7059ABE99182714983B9C9D44D7F5643596D4F3\"),\n\t    SHEX(\"1545D8334836F7436F77F21532F5D3058E351DB8357EFC1E089583A0C40AD3A6AF5F2FEE793D3FE1B4721F6817A373499B20912A35C4609FA9D84BD274E978FC\"));\n  test_hash(&nettle_sha3_512, /* 213 octets */\n\t    SHEX(\"3434EC31B10FAFDBFEEC0DD6BD94E80F7BA9DCA19EF075F7EB017512AF66D6A4BCF7D16BA0819A1892A6372F9B35BCC7CA8155EE19E8428BC22D214856ED5FA9374C3C09BDE169602CC219679F65A1566FC7316F4CC3B631A18FB4449FA6AFA16A3DB2BC4212EFF539C67CF184680826535589C7111D73BFFCE431B4C40492E763D9279560AAA38EB2DC14A212D723F994A1FE656FF4DD14551CE4E7C621B2AA5604A10001B2878A897A28A08095C325E10A26D2FB1A75BFD64C250309BB55A44F23BBAC0D5516A1C687D3B41EF2FBBF9CC56D4739\"),\n\t    SHEX(\"AFAF201BA353316C1A7B810F120CFF941BB658B0763EEF59433403D8313B8F00BF18177898AE71907D3B524E68BB028EA1442866856111B12089BCBED177FD46\"));\n  test_hash(&nettle_sha3_512, /* 214 octets */\n\t    SHEX(\"7C7953D81C8D208FD1C97681D48F49DD003456DE60475B84070EF4847C333B74575B1FC8D2A186964485A3B8634FEAA3595AAA1A2F4595A7D6B6153563DEE31BBAC443C8A33EED6D5D956A980A68366C2527B550EE950250DFB691EACBD5D56AE14B970668BE174C89DF2FEA43AE52F13142639C884FD62A3683C0C3792F0F24AB1318BCB27E21F4737FAB62C77EA38BC8FD1CF41F7DAB64C13FEBE7152BF5BB7AB5A78F5346D43CC741CB6F72B7B8980F268B68BF62ABDFB1577A52438FE14B591498CC95F071228460C7C5D5CEB4A7BDE588E7F21C\"),\n\t    SHEX(\"3FB4F21A231973D2247F206D47B19EE1551647FD4D4F21FBCD6F653577C1AC69EAE4DB432C0234ACBE17B2CED0238A56ACC34D7BB82FBC190903035B7C538857\"));\n  test_hash(&nettle_sha3_512, /* 215 octets */\n\t    SHEX(\"7A6A4F4FDC59A1D223381AE5AF498D74B7252ECF59E389E49130C7EAEE626E7BD9897EFFD92017F4CCDE66B0440462CDEDFD352D8153E6A4C8D7A0812F701CC737B5178C2556F07111200EB627DBC299CAA792DFA58F35935299FA3A3519E9B03166DFFA159103FFA35E8577F7C0A86C6B46FE13DB8E2CDD9DCFBA85BDDDCCE0A7A8E155F81F712D8E9FE646153D3D22C811BD39F830433B2213DD46301941B59293FD0A33E2B63ADBD95239BC01315C46FDB678875B3C81E053A40F581CFBEC24A1404B1671A1B88A6D06120229518FB13A74CA0AC5AE\"),\n\t    SHEX(\"0B1C53E68667314B5F3F0F30E25C622B1A86D10701D4A0473FD40F22C50ACB47D63EAFA582A2FBE5453A3F73BFBCA923680F4C2C7F99C98388C07DDD7AFF2C6E\"));\n  test_hash(&nettle_sha3_512, /* 216 octets */\n\t    SHEX(\"D9FAA14CEBE9B7DE551B6C0765409A33938562013B5E8E0E1E0A6418DF7399D0A6A771FB81C3CA9BD3BB8E2951B0BC792525A294EBD1083688806FE5E7F1E17FD4E3A41D00C89E8FCF4A363CAEDB1ACB558E3D562F1302B3D83BB886ED27B76033798131DAB05B4217381EAAA7BA15EC820BB5C13B516DD640EAEC5A27D05FDFCA0F35B3A5312146806B4C0275BCD0AAA3B2017F346975DB566F9B4D137F4EE10644C2A2DA66DEECA5342E236495C3C6280528BFD32E90AF4CD9BB908F34012B52B4BC56D48CC8A6B59BAB014988EABD12E1A0A1C2E170E7\"),\n\t    SHEX(\"D836D0CE3A28AD71C3A876796BF65AAB838D84E4802ED49AC04484AE06AA08ED31DEB5C38C1022F0ACEED49CB58E38D3AAB09EFECED9349FDC33379251259826\"));\n  test_hash(&nettle_sha3_512, /* 217 octets */\n\t    SHEX(\"2D8427433D0C61F2D96CFE80CF1E932265A191365C3B61AAA3D6DCC039F6BA2AD52A6A8CC30FC10F705E6B7705105977FA496C1C708A277A124304F1FC40911E7441D1B5E77B951AAD7B01FD5DB1B377D165B05BBF898042E39660CAF8B279FE5229D1A8DB86C0999ED65E53D01CCBC4B43173CCF992B3A14586F6BA42F5FE30AFA8AE40C5DF29966F9346DA5F8B35F16A1DE3AB6DE0F477D8D8660918060E88B9B9E9CA6A4207033B87A812DBF5544D39E4882010F82B6CE005F8E8FF6FE3C3806BC2B73C2B83AFB704345629304F9F86358712E9FAE3CA3E\"),\n\t    SHEX(\"61B8A7520DAB4D395044B1A9CCC4F5263EDAE0325767E3D2A0EF225933A81F7E3796280870DBDAB8457D585C4106315B537653DC3D77E915100F421DB39F43B3\"));\n  test_hash(&nettle_sha3_512, /* 218 octets */\n\t    SHEX(\"5E19D97887FCAAC0387E22C6F803C34A3DACD2604172433F7A8A7A526CA4A2A1271ECFC5D5D7BE5AC0D85D921095350DFC65997D443C21C8094E0A3FEFD2961BCB94AED03291AE310CCDA75D8ACE4BC7D89E7D3E5D1650BDA5D668B8B50BFC8E608E184F4D3A9A2BADC4FF5F07E0C0BC8A9F2E0B2A26FD6D8C550008FAAAB75FD71AF2A424BEC9A7CD9D83FAD4C8E9319115656A8717D3B523A68FF8004258B9990ED362308461804BA3E3A7E92D8F2FFAE5C2FBA55BA5A3C27C0A2F71BD711D2FE1799C2ADB31B200035481E9EE5C4ADF2AB9C0FA50B23975CF\"),\n\t    SHEX(\"B847B292818E800BAA415C2521A8158A6AB749934DB693D0D2E4613CDAE60BD56075CF2C29F587DC3530164190BC2C02D97CA32347FA2AA431E511BB7D1C87E8\"));\n  test_hash(&nettle_sha3_512, /* 219 octets */\n\t    SHEX(\"C8E976AB4638909387CE3B8D4E510C3230E5690E02C45093B1D297910ABC481E56EEA0F296F98379DFC9080AF69E73B2399D1C143BEE80AE1328162CE1BA7F6A8374679B20AACD380EB4E61382C99998704D62701AFA914F9A2705CDB065885F50D086C3EB5753700C387118BB142F3E6DA1E988DFB31AC75D7368931E45D1391A274B22F83CEB072F9BCABC0B216685BFD789F5023971024B1878A205442522F9EA7D8797A4102A3DF41703768251FD5E017C85D1200A464118AA35654E7CA39F3C375B8EF8CBE7534DBC64BC20BEFB417CF60EC92F63D9EE7397\"),\n\t    SHEX(\"95ED6D8567774E66404FC32B7A01E1C625FC8322AB9BE0CD7C936731638B04C09748973D95665A35B218D1531411F3AA5E5C47E65D857A43783E2BD3C9D29005\"));\n  test_hash(&nettle_sha3_512, /* 220 octets */\n\t    SHEX(\"7145FA124B7429A1FC2231237A949BA7201BCC1822D3272DE005B682398196C25F7E5CC2F289FBF44415F699CB7FE6757791B1443410234AE061EDF623359E2B4E32C19BF88450432DD01CAA5EB16A1DC378F391CA5E3C4E5F356728BDDD4975DB7C890DA8BBC84CC73FF244394D0D48954978765E4A00B593F70F2CA082673A261ED88DBCEF1127728D8CD89BC2C597E9102CED6010F65FA75A14EBE467FA57CE3BD4948B6867D74A9DF5C0EC6F530CBF2EE61CE6F06BC8F2864DFF5583776B31DF8C7FFCB61428A56BF7BD37188B4A5123BBF338393AF46EDA85E6\"),\n\t    SHEX(\"98350793FC1540AE72757C2D1BA0FA34DF1923C987F365752788E3C65931746C36D13FD293DB8EA1B6374872CCF74E9B0CFF67C6DEBB4263390CD96E2BDD864F\"));\n  test_hash(&nettle_sha3_512, /* 221 octets */\n\t    SHEX(\"7FDFADCC9D29BAD23AE038C6C65CDA1AEF757221B8872ED3D75FF8DF7DA0627D266E224E812C39F7983E4558BFD0A1F2BEF3FEB56BA09120EF762917B9C093867948547AEE98600D10D87B20106878A8D22C64378BF634F7F75900C03986B077B0BF8B740A82447B61B99FEE5376C5EB6680EC9E3088F0BDD0C56883413D60C1357D3C811950E5890E7600103C916341B80C743C6A852B7B4FB60C3BA21F3BC15B8382437A68454779CF3CD7F9F90CCC8EF28D0B706535B1E4108EB5627BB45D719CB046839AEE311CA1ABDC8319E050D67972CB35A6B1601B25DBF487\"),\n\t    SHEX(\"C2493D60E1EFA6B472933EDE64D1F49EFF773635F66C6454E57E47935A0F4C5B94548DA5C369BDAC7146E54F017C3FD674CE32F8D95151C7CBC3E3BBA3EBE0D3\"));\n  test_hash(&nettle_sha3_512, /* 222 octets */\n\t    SHEX(\"988638219FD3095421F826F56E4F09E356296B628C3CE6930C9F2E758FD1A80C8273F2F61E4DAAE65C4F110D3E7CA0965AC7D24E34C0DC4BA2D6FF0BF5BBE93B3585F354D7543CB542A1AA54674D375077F2D360A8F4D42F3DB131C3B7AB7306267BA107659864A90C8C909460A73621D1F5D9D3FD95BEB19B23DB1CB6C0D0FBA91D36891529B8BD8263CAA1BAB56A4AFFAED44962DF096D8D5B1EB845EF31188B3E10F1AF811A13F156BEB7A288AAE593EBD1471B624AA1A7C6ADF01E2200B3D72D88A3AED3100C88231E41EFC376906F0B580DC895F080FDA5741DB1CB\"),\n\t    SHEX(\"70D7BA6585CD2EF91BB261025F9DCC80F8359C9DC30C7C2961F0D1F6057B9C44E3AA67A4BC00F137886E3CF1316D75F8EBF651C79DF9A99CABD0383008372016\"));\n  test_hash(&nettle_sha3_512, /* 223 octets */\n\t    SHEX(\"5AAB62756D307A669D146ABA988D9074C5A159B3DE85151A819B117CA1FF6597F6156E80FDD28C9C3176835164D37DA7DA11D94E09ADD770B68A6E081CD22CA0C004BFE7CD283BF43A588DA91F509B27A6584C474A4A2F3EE0F1F56447379240A5AB1FB77FDCA49B305F07BA86B62756FB9EFB4FC225C86845F026EA542076B91A0BC2CDD136E122C659BE259D98E5841DF4C2F60330D4D8CDEE7BF1A0A244524EECC68FF2AEF5BF0069C9E87A11C6E519DE1A4062A10C83837388F7EF58598A3846F49D499682B683C4A062B421594FAFBC1383C943BA83BDEF515EFCF10D\"),\n\t    SHEX(\"B50D0DA9B3DB1545CC1D2F35465C74D07543B3564249F12C546A08797EEA73326CE624203A3D25C92CE636BCCE86DA9CB9F39BC755EC0F39C090A0E8A72DA70B\"));\n  test_hash(&nettle_sha3_512, /* 224 octets */\n\t    SHEX(\"47B8216AA0FBB5D67966F2E82C17C07AA2D6327E96FCD83E3DE7333689F3EE79994A1BF45082C4D725ED8D41205CB5BCDF5C341F77FACB1DA46A5B9B2CBC49EADF786BCD881F371A95FA17DF73F606519AEA0FF79D5A11427B98EE7F13A5C00637E2854134691059839121FEA9ABE2CD1BCBBBF27C74CAF3678E05BFB1C949897EA01F56FFA4DAFBE8644611685C617A3206C7A7036E4AC816799F693DAFE7F19F303CE4EBA09D21E03610201BFC665B72400A547A1E00FA9B7AD8D84F84B34AEF118515E74DEF11B9188BD1E1F97D9A12C30132EC2806339BDADACDA2FD8B78\"),\n\t    SHEX(\"83752A88C915D4193296725DECC50C9C05D25D6BBD9AF2E0EF06286ECFEE961DE959BEDBB130704D432C2BC89930208F450E0A022661724043D268CB24E7FC47\"));\n  test_hash(&nettle_sha3_512, /* 225 octets */\n\t    SHEX(\"8CFF1F67FE53C098896D9136389BD8881816CCAB34862BB67A656E3D98896F3CE6FFD4DA73975809FCDF9666760D6E561C55238B205D8049C1CEDEEF374D1735DAA533147BFA960B2CCE4A4F254176BB4D1BD1E89654432B8DBE1A135C42115B394B024856A2A83DC85D6782BE4B444239567CCEC4B184D4548EAE3FF6A192F343292BA2E32A0F267F31CC26719EB85245D415FB897AC2DA433EE91A99424C9D7F1766A44171D1651001C38FC79294ACCC68CEB5665D36218454D3BA169AE058A831338C17743603F81EE173BFC0927464F9BD728DEE94C6AEAB7AAE6EE3A627E8\"),\n\t    SHEX(\"7288424BA855A76C7480B606F8F32E94396799BAB8BB3FC8FD21D180966C64971071E2645622524EC7D1645EEA7B7C1FA21F7F5B6B90F3E5BEB99222F05EA905\"));\n  test_hash(&nettle_sha3_512, /* 226 octets */\n\t    SHEX(\"EACD07971CFF9B9939903F8C1D8CBB5D4DB1B548A85D04E037514A583604E787F32992BF2111B97AC5E8A938233552731321522AB5E8583561260B7D13EBEEF785B23A41FD8576A6DA764A8ED6D822D4957A545D5244756C18AA80E1AAD4D1F9C20D259DEE1711E2CC8FD013169FB7CC4CE38B362F8E0936AE9198B7E838DCEA4F7A5B9429BB3F6BBCF2DC92565E3676C1C5E6EB3DD2A0F86AA23EDD3D0891F197447692794B3DFA269611AD97F72B795602B4FDB198F3FD3EB41B415064256E345E8D8C51C555DC8A21904A9B0F1AD0EFFAB7786AAC2DA3B196507E9F33CA356427\"),\n\t    SHEX(\"E9399376D89C4DD4464E45825F4302CDCCD4C41DB4E8951BE17BCC6451858332398B7E4E7F5EEE6830C715451E4AACDB179DD5247BA6D5728CBD4060AEB77CB9\"));\n  test_hash(&nettle_sha3_512, /* 227 octets */\n\t    SHEX(\"23AC4E9A42C6EF45C3336CE6DFC2FF7DE8884CD23DC912FEF0F7756C09D335C189F3AD3A23697ABDA851A81881A0C8CCAFC980AB2C702564C2BE15FE4C4B9F10DFB2248D0D0CB2E2887FD4598A1D4ACDA897944A2FFC580FF92719C95CF2AA42DC584674CB5A9BC5765B9D6DDF5789791D15F8DD925AA12BFFAFBCE60827B490BB7DF3DDA6F2A143C8BF96ABC903D83D59A791E2D62814A89B8080A28060568CF24A80AE61179FE84E0FFAD00388178CB6A617D37EFD54CC01970A4A41D1A8D3DDCE46EDBBA4AB7C90AD565398D376F431189CE8C1C33E132FEAE6A8CD17A61C630012\"),\n\t    SHEX(\"CCEA447EFE6F8B06AC42076280377635F5FD0767F4AF8B245FE63B79FE4974E9156744E60E98D12018214C39F8A826D506D0D5948645E9F883C208D37D927A41\"));\n  test_hash(&nettle_sha3_512, /* 228 octets */\n\t    SHEX(\"0172DF732282C9D488669C358E3492260CBE91C95CFBC1E3FEA6C4B0EC129B45F242ACE09F152FC6234E1BEE8AAB8CD56E8B486E1DCBA9C05407C2F95DA8D8F1C0AF78EE2ED82A3A79EC0CB0709396EE62AADB84F8A4EE8A7CCCA3C1EE84E302A09EA802204AFECF04097E67D0F8E8A9D2651126C0A598A37081E42D168B0AE8A71951C524259E4E2054E535B779679BDADE566FE55700858618E626B4A0FAF895BCCE9011504A49E05FD56127EAE3D1F8917AFB548ECADABDA1020111FEC9314C413498A360B08640549A22CB23C731ACE743252A8227A0D2689D4C6001606678DFB921\"),\n\t    SHEX(\"7E03FCE3B67EBB28308823F56AA93DBB4D9EFDBD93300D97B1F99EFCB82C3684C5A5A5AA64E7A34C69B89399CAB05F22E8E88607B863336E4CBF8CF6E74B98C1\"));\n  test_hash(&nettle_sha3_512, /* 229 octets */\n\t    SHEX(\"3875B9240CF3E0A8B59C658540F26A701CF188496E2C2174788B126FD29402D6A75453BA0635284D08835F40051A2A9683DC92AFB9383719191231170379BA6F4ADC816FECBB0F9C446B785BF520796841E58878B73C58D3EBB097CE4761FDEABE15DE2F319DFBAF1742CDEB389559C788131A6793E193856661376C81CE9568DA19AA6925B47FFD77A43C7A0E758C37D69254909FF0FBD415EF8EB937BCD49F91468B49974C07DC819ABD67395DB0E05874FF83DDDAB895344ABD0E7111B2DF9E58D76D85AD98106B36295826BE04D435615595605E4B4BB824B33C4AFEB5E7BB0D19F909\"),\n\t    SHEX(\"6A457AE74F89C42BBD2BD2EBFFFBD71F036FF7B76C4AFDDFFBD52F32E588A9543CED09DA9A3E130AC1A19EF1ACB2FA68AC41917ED6BAD37A60982B16B5EB4FF3\"));\n  test_hash(&nettle_sha3_512, /* 230 octets */\n\t    SHEX(\"747CC1A59FEFBA94A9C75BA866C30DC5C1CB0C0F8E9361D98484956DD5D1A40F6184AFBE3DAC9F76028D1CAECCFBF69199C6CE2B4C092A3F4D2A56FE5A33A00757F4D7DEE5DFB0524311A97AE0668A47971B95766E2F6DD48C3F57841F91F04A00AD5EA70F2D479A2620DC5CD78EAAB3A3B011719B7E78D19DDF70D9423798AF77517EBC55392FCD01FC600D8D466B9E7A7A85BF33F9CC5419E9BD874DDFD60981150DDAF8D7FEBAA4374F0872A5628D318000311E2F5655365AD4D407C20E5C04DF17A222E7DEEC79C5AB1116D8572F91CD06E1CCC7CED53736FC867FD49ECEBE6BF8082E8A\"),\n\t    SHEX(\"91B8CD795D1A6828601E00DB0C91FF9A6F837444F53FCF89E990B88F5F3E34EB490E72A1795FAB84F78DA3F7AFC89896C7CDE5865D1BCD74D5639E4903C683FE\"));\n  test_hash(&nettle_sha3_512, /* 231 octets */\n\t    SHEX(\"57AF971FCCAEC97435DC2EC9EF0429BCEDC6B647729EA168858A6E49AC1071E706F4A5A645CA14E8C7746D65511620682C906C8B86EC901F3DDED4167B3F00B06CBFAC6AEE3728051B3E5FF10B4F9ED8BD0B8DA94303C833755B3CA3AEDDF0B54BC8D6632138B5D25BAB03D17B3458A9D782108006F5BB7DE75B5C0BA854B423D8BB801E701E99DC4FEAAD59BC1C7112453B04D33EA3635639FB802C73C2B71D58A56BBD671B18FE34ED2E3DCA38827D63FDB1D4FB3285405004B2B3E26081A8FF08CD6D2B08F8E7B7E90A2AB1ED7A41B1D0128522C2F8BFF56A7FE67969422CE839A9D4608F03\"),\n\t    SHEX(\"7635D79C1B32E4934EB0090C6D46C0B240F626C77D84F8EABF571BA8FDE924F4A1CF456704B101F667F912DEDBBCBEFF2180A419A68C7B790BA606E6602D5115\"));\n  test_hash(&nettle_sha3_512, /* 232 octets */\n\t    SHEX(\"04E16DEDC1227902BAAF332D3D08923601BDD64F573FAA1BB7201918CFE16B1E10151DAE875DA0C0D63C59C3DD050C4C6A874011B018421AFC4623AB0381831B2DA2A8BA42C96E4F70864AC44E106F94311051E74C77C1291BF5DB9539E69567BF6A11CF6932BBBAD33F8946BF5814C066D851633D1A513510039B349939BFD42B858C21827C8FF05F1D09B1B0765DC78A135B5CA4DFBA0801BCADDFA175623C8B647EACFB4444B85A44F73890607D06D507A4F8393658788669F6EF4DEB58D08C50CA0756D5E2F49D1A7AD73E0F0B3D3B5F090ACF622B1878C59133E4A848E05153592EA81C6FBF\"),\n\t    SHEX(\"DDD0C521ED60C55F65BAE241A9072D7F6F6CCA7F64624EC92C037BF8BC16F0602E75EE46879AF41F3EFF5CE235905F3856A031C3CC90A4851F4CD8463AAE6DE8\"));\n  test_hash(&nettle_sha3_512, /* 233 octets */\n\t    SHEX(\"7C815C384EEE0F288ECE27CCED52A01603127B079C007378BC5D1E6C5E9E6D1C735723ACBBD5801AC49854B2B569D4472D33F40BBB8882956245C366DC3582D71696A97A4E19557E41E54DEE482A14229005F93AFD2C4A7D8614D10A97A9DFA07F7CD946FA45263063DDD29DB8F9E34DB60DAA32684F0072EA2A9426ECEBFA5239FB67F29C18CBAA2AF6ED4BF4283936823AC1790164FEC5457A9CBA7C767CA59392D94CAB7448F50EB34E9A93A80027471CE59736F099C886DEA1AB4CBA4D89F5FC7AE2F21CCD27F611ECA4626B2D08DC22382E92C1EFB2F6AFDC8FDC3D2172604F5035C46B8197D3\"),\n\t    SHEX(\"C84C03564D024F90560001CA4CEF867AF77999943E313CA17328756C43D2FE31CF98812D3A7AAB1535C28ED29D692DB4824E8D6DCE06C9994DBCBE0F82633FBE\"));\n  test_hash(&nettle_sha3_512, /* 234 octets */\n\t    SHEX(\"E29D505158DBDD937D9E3D2145658EE6F5992A2FC790F4F608D9CDB44A091D5B94B88E81FAC4FDF5C49442F13B911C55886469629551189EAFF62488F1A479B7DB11A1560E198DDCCCCF50159093425FF7F1CB8D1D1246D0978764087D6BAC257026B090EFAE8CEC5F22B6F21C59ACE1AC7386F5B8837CA6A12B6FBF5534DD0560EF05CA78104D3B943DDB220FEAEC89AA5E692A00F822A2AB9A2FE60350D75E7BE16FF2526DC643872502D01F42F188ABED0A6E9A6F5FD0D1CE7D5755C9FFA66B0AF0B20BD806F08E06156690D81AC811778CA3DAC2C249B96002017FCE93E507E3B953ACF99964B847\"),\n\t    SHEX(\"B4563191675191ED4D6107E52FA15ADC9D70642358D8C3E34DF10274E25D373FD8D19E92472B823E28BBDD1D541A95FDDD0D43C79FCB3BA18A7EC038D3EF69A6\"));\n  test_hash(&nettle_sha3_512, /* 235 octets */\n\t    SHEX(\"D85588696F576E65ECA0155F395F0CFACD83F36A99111ED5768DF2D116D2121E32357BA4F54EDE927F189F297D3A97FAD4E9A0F5B41D8D89DD7FE20156799C2B7B6BF9C957BA0D6763F5C3BC5129747BBB53652B49290CFF1C87E2CDF2C4B95D8AAEE09BC8FBFA6883E62D237885810491BFC101F1D8C636E3D0EDE838AD05C207A3DF4FAD76452979EB99F29AFAECEDD1C63B8D36CF378454A1BB67A741C77AC6B6B3F95F4F02B64DABC15438613EA49750DF42EE90101F115AA9ABB9FF64324DDE9DABBB01054E1BD6B4BCDC7930A44C2300D87CA78C06924D0323AD7887E46C90E8C4D100ACD9EED21E\"),\n\t    SHEX(\"A30BD80CB3ACB3BFA7E037A3D0D2500974D71957F68135133020C32EB4D688F132D0FB045BE027F124B3D935CB889E3CBC4A4A420026BB2AC2A4B1B15C57BB64\"));\n  test_hash(&nettle_sha3_512, /* 236 octets */\n\t    SHEX(\"3A12F8508B40C32C74492B66323375DCFE49184C78F73179F3314B79E63376B8AC683F5A51F1534BD729B02B04D002F55CBD8E8FC9B5EC1EA6BBE6A0D0E7431518E6BA45D124035F9D3DCE0A8BB7BF1430A9F657E0B4EA9F20EB20C786A58181A1E20A96F1628F8728A13BDF7A4B4B32FC8AA7054CC4881AE7FA19AFA65C6C3EE1B3ADE3192AF42054A8A911B8EC1826865D46D93F1E7C5E2B7813C92A506E53886F3D4701BB93D2A681AD109C845904BB861AF8AF0646B6E399B38B614051D34F6842563A0F37EC00CB3D865FC5D746C4987DE2A65071100883A2A9C7A2BFE1E2DD603D9EA24DC7C5FD06BE\"),\n\t    SHEX(\"4A5809E457F54D9C7E8209F6C482D52A4EFE6D8A20C4C6FBA83687294929232D25CD7BF511D8E6FBF272E983F07D044F8723098D7A381F04E957B0787087EF02\"));\n  test_hash(&nettle_sha3_512, /* 237 octets */\n\t    SHEX(\"1861EDCE46FA5AD17E1FF1DEAE084DEC580F97D0A67885DFE834B9DFAC1AE076742CE9E267512CA51F6DF5A455AF0C5FD6ABF94ACEA103A3370C354485A7846FB84F3AC7C2904B5B2FBF227002CE512133BB7E1C4E50057BFD1E44DB33C7CDB969A99E284B184F50A14B068A1FC5009D9B298DBE92239572A7627AAC02ABE8F3E3B473417F36D4D2505D16B7577F4526C9D94A270A2DFE450D06DA8F6FA956879A0A55CFE99E742EA555EA477BA3E9B44CCD508C375423611AF92E55345DC215779B2D5119EBA49C71D49B9FE3F1569FA24E5CA3E332D042422A8B8158D3EC66A80012976F31FFDF305F0C9C5E\"),\n\t    SHEX(\"A79016C34BEE41AB5CB10278478A5B55D07C2E0831835DDE6F8FF8DAFAC37A5F88FBA07CCEFFE35849DBD123B06DF2335B002645D078FE1B08843C257A1BBE56\"));\n  test_hash(&nettle_sha3_512, /* 238 octets */\n\t    SHEX(\"08D0FFDE3A6E4EF65608EA672E4830C12943D7187CCFF08F4941CFC13E545F3B9C7AD5EEBBE2B01642B486CAF855C2C73F58C1E4E3391DA8E2D63D96E15FD84953AE5C231911B00AD6050CD7AAFDAAC9B0F663AE6AAB45519D0F5391A541707D479034E73A6AD805AE3598096AF078F1393301493D663DD71F83869CA27BA508B7E91E81E128C1716DC3ACFE3084B2201E04CF8006617EECF1B640474A5D45CFDE9F4D3EF92D6D055B909892194D8A8218DB6D8203A84261D200D71473D7488F3427416B6896C137D455F231071CACBC86E0415AB88AEC841D96B7B8AF41E05BB461A40645BF176601F1E760DE5F\"),\n\t    SHEX(\"603F7B09565634D4410B574A4DC9EA467437964517E5EFA51A362A30E8C632C55162A3351BB5532E40948AA9A1E3A8786C0422AEC3EC338C7F4B57679200452B\"));\n  test_hash(&nettle_sha3_512, /* 239 octets */\n\t    SHEX(\"D782ABB72A5BE3392757BE02D3E45BE6E2099D6F000D042C8A543F50ED6EBC055A7F133B0DD8E9BC348536EDCAAE2E12EC18E8837DF7A1B3C87EC46D50C241DEE820FD586197552DC20BEEA50F445A07A38F1768A39E2B2FF05DDDEDF751F1DEF612D2E4D810DAA3A0CC904516F9A43AF660315385178A529E51F8AAE141808C8BC5D7B60CAC26BB984AC1890D0436EF780426C547E94A7B08F01ACBFC4A3825EAE04F520A9016F2FB8BF5165ED12736FC71E36A49A73614739EAA3EC834069B1B40F1350C2B3AB885C02C640B9F7686ED5F99527E41CFCD796FE4C256C9173186C226169FF257954EBDA81C0E5F99\"),\n\t    SHEX(\"1018692D530C55BAA580AE1E7384351100D4637CD33869C71E6076A3D4E310D964B81D593E89718845AC7A89E8AD5073506427C6C8F7FADFA0C5DC3CFAA5D924\"));\n  test_hash(&nettle_sha3_512, /* 240 octets */\n\t    SHEX(\"5FCE8109A358570E40983E1184E541833BB9091E280F258CFB144387B05D190E431CB19BAA67273BA0C58ABE91308E1844DCD0B3678BAA42F335F2FA05267A0240B3C718A5942B3B3E3BFA98A55C25A1466E8D7A603722CB2BBF03AFA54CD769A99F310735EE5A05DAE2C22D397BD95635F58C48A67F90E1B73AAFCD3F82117F0166657838691005B18DA6F341D6E90FC1CDB352B30FAE45D348294E501B63252DE14740F2B85AE5299DDEC3172DE8B6D0BA219A20A23BB5E10FF434D39DB3F583305E9F5C039D98569E377B75A70AB837D1DF269B8A4B566F40BB91B577455FD3C356C914FA06B9A7CE24C7317A172D\"),\n\t    SHEX(\"E3C0EAFFC3567BD72CC02150A75F32DDE53DE2652C5313EB3E97018ADDDF629DA01D97D0A9E2519451A7292F5DE00EE4456FE6E4F14F96D5DE7E6F174EDB28C4\"));\n  test_hash(&nettle_sha3_512, /* 241 octets */\n\t    SHEX(\"6172F1971A6E1E4E6170AFBAD95D5FEC99BF69B24B674BC17DD78011615E502DE6F56B86B1A71D3F4348087218AC7B7D09302993BE272E4A591968AEF18A1262D665610D1070EE91CC8DA36E1F841A69A7A682C580E836941D21D909A3AFC1F0B963E1CA5AB193E124A1A53DF1C587470E5881FB54DAE1B0D840F0C8F9D1B04C645BA1041C7D8DBF22030A623AA15638B3D99A2C400FF76F3252079AF88D2B37F35EE66C1AD7801A28D3D388AC450B97D5F0F79E4541755356B3B1A5696B023F39AB7AB5F28DF4202936BC97393B93BC915CB159EA1BD7A0A414CB4B7A1AC3AF68F50D79F0C9C7314E750F7D02FAA58BFA\"),\n\t    SHEX(\"192AE7A0F7A816FD3D4020BDDCF2AAF52A64E6384DCA527F33AF4EE69099DCA97B890A99CFAB9D904A35F2707856696C30C6432DF70A6CEF704BB268055A6D07\"));\n  test_hash(&nettle_sha3_512, /* 242 octets */\n\t    SHEX(\"5668ECD99DFBE215C4118398AC9C9EAF1A1433FAB4CCDD3968064752B625EA944731F75D48A27D047D67547F14DD0FFAA55FA5E29F7AF0D161D85EAFC4F2029B717C918EAB9D304543290BDBA7158B68020C0BA4E079BC95B5BC0FC044A992B94B4CCD3BD66D0EABB5DBBAB904D62E00752C4E3B0091D773BCF4C14B4377DA3EFFF824B1CB2FA01B32D1E46C909E626ED2DAE920F4C7DBEB635BC754FACBD8D49BEBA3F23C1C41CCBFCD0EE0C114E69737F5597C0BF1D859F0C767E18002AE8E39C26261FFDE2920D3D0BAF0E906138696CFE5B7E32B600F45DF3AAA39932F3A7DF95B60FA8712A2271FCAF3911CE7B511B1\"),\n\t    SHEX(\"6BCD7E7C359FDD93A56D79F97FC2D534619F14FE443AC8C9E042C5105FBAF2777718DE07424A62333FFD43A501A8544449A7CAC3C8D821E380B0CB8172B9493B\"));\n  test_hash(&nettle_sha3_512, /* 243 octets */\n\t    SHEX(\"03D625488354DF30E3F875A68EDFCF340E8366A8E1AB67F9D5C5486A96829DFAC0578289082B2A62117E1CF418B43B90E0ADC881FC6AE8105C888E9ECD21AEA1C9AE1A4038DFD17378FED71D02AE492087D7CDCD98F746855227967CB1AB4714261EE3BEAD3F4DB118329D3EBEF4BC48A875C19BA763966DA0EBEA800E01B2F50B00E9DD4CACA6DCB314D00184EF71EA2391D760C950710DB4A70F9212FFC54861F9DC752CE18867B8AD0C48DF8466EF7231E7AC567F0EB55099E622EBB86CB237520190A61C66AD34F1F4E289CB3282AE3EAAC6152ED24D2C92BAE5A7658252A53C49B7B02DFE54FDB2E90074B6CF310AC661\"),\n\t    SHEX(\"1FCD1E38AB03C750366CF86DD72EC3BF22F5BBF7FEA0149D31B6A67B68B537B59BA37917FD88CED9AA8D2941A65F552B7928B3785C66D640F3B74AF039ED18CE\"));\n  test_hash(&nettle_sha3_512, /* 244 octets */\n\t    SHEX(\"2EDC282FFB90B97118DD03AAA03B145F363905E3CBD2D50ECD692B37BF000185C651D3E9726C690D3773EC1E48510E42B17742B0B0377E7DE6B8F55E00A8A4DB4740CEE6DB0830529DD19617501DC1E9359AA3BCF147E0A76B3AB70C4984C13E339E6806BB35E683AF8527093670859F3D8A0FC7D493BCBA6BB12B5F65E71E705CA5D6C948D66ED3D730B26DB395B3447737C26FAD089AA0AD0E306CB28BF0ACF106F89AF3745F0EC72D534968CCA543CD2CA50C94B1456743254E358C1317C07A07BF2B0ECA438A709367FAFC89A57239028FC5FECFD53B8EF958EF10EE0608B7F5CB9923AD97058EC067700CC746C127A61EE3\"),\n\t    SHEX(\"F39EF0626D3FBD9CD435A93E7EEE41E4A2FF5362F56C988B20870A3BEFA50470DC5FABE39895C0761289FAFD9147ABAB02561F300D0CEB9A732E14CA887CAF18\"));\n  test_hash(&nettle_sha3_512, /* 245 octets */\n\t    SHEX(\"90B28A6AA1FE533915BCB8E81ED6CACDC10962B7FF82474F845EEB86977600CF70B07BA8E3796141EE340E3FCE842A38A50AFBE90301A3BDCC591F2E7D9DE53E495525560B908C892439990A2CA2679C5539FFDF636777AD9C1CDEF809CDA9E8DCDB451ABB9E9C17EFA4379ABD24B182BD981CAFC792640A183B61694301D04C5B3EAAD694A6BD4CC06EF5DA8FA23B4FA2A64559C5A68397930079D250C51BCF00E2B16A6C49171433B0AADFD80231276560B80458DD77089B7A1BBCC9E7E4B9F881EACD6C92C4318348A13F4914EB27115A1CFC5D16D7FD94954C3532EFACA2CAB025103B2D02C6FD71DA3A77F417D7932685888A\"),\n\t    SHEX(\"81E8B59DDCD24811B405F7529DA125F0DC19AE21E8795CE9E6692DAB645B7959446ADCAA3061DC4642A51D8A562EFB03A7680AF0F52C01406D5C213EAAC6BE55\"));\n  test_hash(&nettle_sha3_512, /* 246 octets */\n\t    SHEX(\"2969447D175490F2AA9BB055014DBEF2E6854C95F8D60950BFE8C0BE8DE254C26B2D31B9E4DE9C68C9ADF49E4EE9B1C2850967F29F5D08738483B417BB96B2A56F0C8ACA632B552059C59AAC3F61F7B45C966B75F1D9931FF4E596406378CEE91AAA726A3A84C33F37E9CDBE626B5745A0B06064A8A8D56E53AAF102D23DD9DF0A3FDF7A638509A6761A33FA42FA8DDBD8E16159C93008B53765019C3F0E9F10B144CE2AC57F5D7297F9C9949E4FF68B70D339F87501CE8550B772F32C6DA8AD2CE2100A895D8B08FA1EEAD7C376B407709703C510B50F87E73E43F8E7348F87C3832A547EF2BBE5799ABEDCF5E1F372EA809233F006\"),\n\t    SHEX(\"63424B09069FBD2D0FAC00805AAD07FD56E30BB8116B5476AE90BF6ACEC84C3B45368A9EBB7FCEA8D65965F52514A2A59A06E6E06B07DC6AEE7F756BFC188E25\"));\n  test_hash(&nettle_sha3_512, /* 247 octets */\n\t    SHEX(\"721645633A44A2C78B19024EAECF58575AB23C27190833C26875DC0F0D50B46AEA9C343D82EA7D5B3E50EC700545C615DAEAEA64726A0F05607576DCD396D812B03FB6551C641087856D050B10E6A4D5577B82A98AFB89CEE8594C9DC19E79FEFF0382FCFD127F1B803A4B9946F4AC9A4378E1E6E041B1389A53E3450CD32D9D2941B0CBABDB50DA8EA2513145164C3AB6BCBD251C448D2D4B087AC57A59C2285D564F16DA4ED5E607ED979592146FFB0EF3F3DB308FB342DF5EB5924A48256FC763141A278814C82D6D6348577545870AE3A83C7230AC02A1540FE1798F7EF09E335A865A2AE0949B21E4F748FB8A51F44750E213A8FB\"),\n\t    SHEX(\"1E709FB3501FA818F57E70C365DB45CCF2EB8A8FA66DE9B5F211D6F0CC9722ADE963C965AD5F6937BA62EDC2D8983843E0F3679D9C97B30CD54F2409DDA5F474\"));\n  test_hash(&nettle_sha3_512, /* 248 octets */\n\t    SHEX(\"6B860D39725A14B498BB714574B4D37CA787404768F64C648B1751B353AC92BAC2C3A28EA909FDF0423336401A02E63EC24325300D823B6864BB701F9D7C7A1F8EC9D0AE3584AA6DD62EA1997CD831B4BABD9A4DA50932D4EFDA745C61E4130890E156AEE6113716DAF95764222A91187DB2EFFEA49D5D0596102D619BD26A616BBFDA8335505FBB0D90B4C180D1A2335B91538E1668F9F9642790B4E55F9CAB0FE2BDD2935D001EE6419ABAB5457880D0DBFF20ED8758F4C20FE759EFB33141CF0E892587FE8187E5FBC57786B7E8B089612C936DFC03D27EFBBE7C8673F1606BD51D5FF386F4A7AB68EDF59F385EB1291F117BFE717399\"),\n\t    SHEX(\"5B9F0C544627FAADEA82825A569DA33A75C5DA6CC169926DE0556A737E4DAA07ABF1DC3DB0704F5D67FCBC4CB62AAC442ECEC867A2C16846F1D53D205CB872AC\"));\n  test_hash(&nettle_sha3_512, /* 249 octets */\n\t    SHEX(\"6A01830AF3889A25183244DECB508BD01253D5B508AB490D3124AFBF42626B2E70894E9B562B288D0A2450CFACF14A0DDAE5C04716E5A0082C33981F6037D23D5E045EE1EF2283FB8B6378A914C5D9441627A722C282FF452E25A7EA608D69CEE4393A0725D17963D0342684F255496D8A18C2961145315130549311FC07F0312FB78E6077334F87EAA873BEE8AA95698996EB21375EB2B4EF53C14401207DEB4568398E5DD9A7CF97E8C9663E23334B46912F8344C19EFCF8C2BA6F04325F1A27E062B62A58D0766FC6DB4D2C6A1928604B0175D872D16B7908EBC041761187CC785526C2A3873FEAC3A642BB39F5351550AF9770C328AF7B\"),\n\t    SHEX(\"930AB42A9F5F5BC5F2222C748F2478A00F40C3B6D6487D6D7ED0D71100F40FCBB2C66566EA26AD0A417629F5A61DCA411CCD21F7367D308F3B1B24901824FA9B\"));\n  test_hash(&nettle_sha3_512, /* 250 octets */\n\t    SHEX(\"B3C5E74B69933C2533106C563B4CA20238F2B6E675E8681E34A389894785BDADE59652D4A73D80A5C85BD454FD1E9FFDAD1C3815F5038E9EF432AAC5C3C4FE840CC370CF86580A6011778BBEDAF511A51B56D1A2EB68394AA299E26DA9ADA6A2F39B9FAFF7FBA457689B9C1A577B2A1E505FDF75C7A0A64B1DF81B3A356001BF0DF4E02A1FC59F651C9D585EC6224BB279C6BEBA2966E8882D68376081B987468E7AED1EF90EBD090AE825795CDCA1B4F09A979C8DFC21A48D8A53CDBB26C4DB547FC06EFE2F9850EDD2685A4661CB4911F165D4B63EF25B87D0A96D3DFF6AB0758999AAD214D07BD4F133A6734FDE445FE474711B69A98F7E2B\"),\n\t    SHEX(\"08203943C58210D3F82758272BEFBB9234FE913409A07944645959B1A6AF2F4363ABD7451232623DAA8E65C87F34939C140608950FBDBBE83D66407944F5423A\"));\n  test_hash(&nettle_sha3_512, /* 251 octets */\n\t    SHEX(\"83AF34279CCB5430FEBEC07A81950D30F4B66F484826AFEE7456F0071A51E1BBC55570B5CC7EC6F9309C17BF5BEFDD7C6BA6E968CF218A2B34BD5CF927AB846E38A40BBD81759E9E33381016A755F699DF35D660007B5EADF292FEEFB735207EBF70B5BD17834F7BFA0E16CB219AD4AF524AB1EA37334AA66435E5D397FC0A065C411EBBCE32C240B90476D307CE802EC82C1C49BC1BEC48C0675EC2A6C6F3ED3E5B741D13437095707C565E10D8A20B8C20468FF9514FCF31B4249CD82DCEE58C0A2AF538B291A87E3390D737191A07484A5D3F3FB8C8F15CE056E5E5F8FEBE5E1FB59D6740980AA06CA8A0C20F5712B4CDE5D032E92AB89F0AE1\"),\n\t    SHEX(\"A24DD6A50333F289C175CD4EC185DA9906E38C287A339DC4DEFAFD71B2EA32A6F6AEFE758E25FC8F043E806F1B2EE019E13B85536CD3EFAA2A9B5994FCAE4788\"));\n  test_hash(&nettle_sha3_512, /* 252 octets */\n\t    SHEX(\"A7ED84749CCC56BB1DFBA57119D279D412B8A986886D810F067AF349E8749E9EA746A60B03742636C464FC1EE233ACC52C1983914692B64309EDFDF29F1AB912EC3E8DA074D3F1D231511F5756F0B6EEAD3E89A6A88FE330A10FACE267BFFBFC3E3090C7FD9A850561F363AD75EA881E7244F80FF55802D5EF7A1A4E7B89FCFA80F16DF54D1B056EE637E6964B9E0FFD15B6196BDD7DB270C56B47251485348E49813B4EB9ED122A01B3EA45AD5E1A929DF61D5C0F3E77E1FDC356B63883A60E9CBB9FC3E00C2F32DBD469659883F690C6772E335F617BC33F161D6F6984252EE12E62B6000AC5231E0C9BC65BE223D8DFD94C5004A101AF9FD6C0FB\"),\n\t    SHEX(\"CD1ED5FFF6FA3D453872510B6B2712EC9C6EBA9543734D88511ED475905E123ED6EF6624F220445FE89C257A9F9C5166A2772EF768B50E9290FB1D4761ECA6C8\"));\n  test_hash(&nettle_sha3_512, /* 253 octets */\n\t    SHEX(\"A6FE30DCFCDA1A329E82AB50E32B5F50EB25C873C5D2305860A835AECEE6264AA36A47429922C4B8B3AFD00DA16035830EDB897831C4E7B00F2C23FC0B15FDC30D85FB70C30C431C638E1A25B51CAF1D7E8B050B7F89BFB30F59F0F20FECFF3D639ABC4255B3868FC45DD81E47EB12AB40F2AAC735DF5D1DC1AD997CEFC4D836B854CEE9AC02900036F3867FE0D84AFFF37BDE3308C2206C62C4743375094108877C73B87B2546FE05EA137BEDFC06A2796274099A0D554DA8F7D7223A48CBF31B7DECAA1EBC8B145763E3673168C1B1B715C1CD99ECD3DDB238B06049885ECAD9347C2436DFF32C771F34A38587A44A82C5D3D137A03CAA27E66C8FF6\"),\n\t    SHEX(\"CFAA0EB1C9F02C0469EEFB31A1A53CA1A4765F78EC171CF15DA7D5C512817B8BF7D7CD7B1416B3DE2BBA05EDFB0B493495AC2107A4B686D5DD8D6AD41B4AA3D7\"));\n  test_hash(&nettle_sha3_512, /* 254 octets */\n\t    SHEX(\"83167FF53704C3AA19E9FB3303539759C46DD4091A52DDAE9AD86408B69335989E61414BC20AB4D01220E35241EFF5C9522B079FBA597674C8D716FE441E566110B6211531CECCF8FD06BC8E511D00785E57788ED9A1C5C73524F01830D2E1148C92D0EDC97113E3B7B5CD3049627ABDB8B39DD4D6890E0EE91993F92B03354A88F52251C546E64434D9C3D74544F23FB93E5A2D2F1FB15545B4E1367C97335B0291944C8B730AD3D4789273FA44FB98D78A36C3C3764ABEEAC7C569C1E43A352E5B770C3504F87090DEE075A1C4C85C0C39CF421BDCC615F9EFF6CB4FE6468004AECE5F30E1ECC6DB22AD9939BB2B0CCC96521DFBF4AE008B5B46BC006E\"),\n\t    SHEX(\"2BE71EE9ACE2DBCFD43D6D020C07244554DAC8A2CF1571D0FA1D004933739E8978323056797E04C333F5BF187E64F1D881E502672567F204DE0E73CE26E7190D\"));\n  test_hash(&nettle_sha3_512, /* 255 octets */\n\t    SHEX(\"3A3A819C48EFDE2AD914FBF00E18AB6BC4F14513AB27D0C178A188B61431E7F5623CB66B23346775D386B50E982C493ADBBFC54B9A3CD383382336A1A0B2150A15358F336D03AE18F666C7573D55C4FD181C29E6CCFDE63EA35F0ADF5885CFC0A3D84A2B2E4DD24496DB789E663170CEF74798AA1BBCD4574EA0BBA40489D764B2F83AADC66B148B4A0CD95246C127D5871C4F11418690A5DDF01246A0C80A43C70088B6183639DCFDA4125BD113A8F49EE23ED306FAAC576C3FB0C1E256671D817FC2534A52F5B439F72E424DE376F4C565CCA82307DD9EF76DA5B7C4EB7E085172E328807C02D011FFBF33785378D79DC266F6A5BE6BB0E4A92ECEEBAEB1\"),\n\t    SHEX(\"6E8B8BD195BDD560689AF2348BDC74AB7CD05ED8B9A57711E9BE71E9726FDA4591FEE12205EDACAF82FFBBAF16DFF9E702A708862080166C2FF6BA379BC7FFC2\"));\n}",
      "lines": 773,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha3-permute-test.c": {
    "display": {
      "start_point": [
        4,
        0
      ],
      "end_point": [
        15,
        1
      ],
      "content": "static void\ndisplay (const struct sha3_state *state)\n{\n  unsigned x, y;\n  for (x = 0; x < 5; x++)\n    {      \n      for (y = 0; y < 5; y++)\n\t/* Is there a simple and *portable* way to print uint64_t? */\n\tprintf (\"%8lx%08lx \", (unsigned long) (state->a[x +5*y] >> 32), (unsigned long) (state->a[x+5*y] & 0xffffffff));\n      printf(\"\\n\");\n    }\n}",
      "lines": 12,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        17,
        0
      ],
      "end_point": [
        54,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From KeccakPermutationIntermediateValues.txt */\n  static const struct sha3_state s1 =\n    { {\n\t0xF1258F7940E1DDE7ULL, 0x84D5CCF933C0478AULL, 0xD598261EA65AA9EEULL, 0xBD1547306F80494DULL, 0x8B284E056253D057ULL,\n\t0xFF97A42D7F8E6FD4ULL, 0x90FEE5A0A44647C4ULL, 0x8C5BDA0CD6192E76ULL, 0xAD30A6F71B19059CULL, 0x30935AB7D08FFC64ULL,\n\t0xEB5AA93F2317D635ULL, 0xA9A6E6260D712103ULL, 0x81A57C16DBCF555FULL, 0x43B831CD0347C826ULL, 0x01F22F1A11A5569FULL,\n\t0x05E5635A21D9AE61ULL, 0x64BEFEF28CC970F2ULL, 0x613670957BC46611ULL, 0xB87C5A554FD00ECBULL, 0x8C3EE88A1CCF32C8ULL,\n\t0x940C7922AE3A2614ULL, 0x1841F924A2C509E4ULL, 0x16F53526E70465C2ULL, 0x75F644E97F30A13BULL, 0xEAF1FF7B5CECA249ULL,\n      } };\n  static const struct sha3_state s2 =\n    { {\n\t0x2D5C954DF96ECB3CULL, 0x6A332CD07057B56DULL, 0x093D8D1270D76B6CULL, 0x8A20D9B25569D094ULL, 0x4F9C4F99E5E7F156ULL,\n\t0xF957B9A2DA65FB38ULL, 0x85773DAE1275AF0DULL, 0xFAF4F247C3D810F7ULL, 0x1F1B9EE6F79A8759ULL, 0xE4FECC0FEE98B425ULL,\n\t0x68CE61B6B9CE68A1ULL, 0xDEEA66C4BA8F974FULL, 0x33C43D836EAFB1F5ULL, 0xE00654042719DBD9ULL, 0x7CF8A9F009831265ULL,\n\t0xFD5449A6BF174743ULL, 0x97DDAD33D8994B40ULL, 0x48EAD5FC5D0BE774ULL, 0xE3B8C8EE55B7B03CULL, 0x91A0226E649E42E9ULL,\n\t0x900E3129E7BADD7BULL, 0x202A9EC5FAA3CCE8ULL, 0x5B3402464E1C3DB6ULL, 0x609F4E62A44C1059ULL, 0x20D06CD26A8FBF5CULL,\n      } };\n  struct sha3_state state;\n\n  memset (&state, 0, sizeof(state));\n  sha3_permute (&state);\n  if (!MEMEQ (sizeof(state), &state.a, &s1))\n    {\n      printf(\"Got:\\n\"); display (&state);\n      printf(\"Ref:\\n\"); display (&s1);\n      FAIL();\n    }\n  sha3_permute (&state);\n  if (!MEMEQ (sizeof(state), &state.a, &s2))\n    {\n      printf(\"Got:\\n\"); display (&state);\n      printf(\"Ref:\\n\"); display (&s2);\n      FAIL();\n    }  \n}",
      "lines": 38,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha384-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        53,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_sha384, SDATA(\"abc\"),\n\t    SHEX(\"cb00753f45a35e8b b5a03d699ac65007\"\n\t\t \"272c32ab0eded163 1a8b605a43ff5bed\"\n\t\t \"8086072ba1e7cc23 58baeca134c825a7\"));\n  \n  test_hash(&nettle_sha384,\n\t    SDATA(\"abcdefghbcdefghicdefghijdefg\"\n\t\t  \"hijkefghijklfghijklmghijklmn\"\n\t\t  \"hijklmnoijklmnopjklmnopqklmn\"\n\t\t  \"opqrlmnopqrsmnopqrstnopqrstu\"),\n\t    SHEX(\"09330c33f71147e8 3d192fc782cd1b47\"\n\t\t \"53111b173b3b05d2 2fa08086e3b0f712\"\n\t\t \"fcc7c71a557e2db9 66c3e9fa91746039\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  test_hash(&nettle_sha384, SDATA(\"\"),\n\t    SHEX(\"38b060a751ac9638 4cd9327eb1b1e36a\"\n\t\t \"21fdb71114be0743 4c0cc7bf63f6e1da\"\n\t\t \"274edebfe76f65fb d51ad2f14898b95b\"));\n  test_hash(&nettle_sha384, SDATA(\"a\"),\n\t    SHEX(\"54a59b9f22b0b808 80d8427e548b7c23\"\n\t\t \"abd873486e1f035d ce9cd697e8517503\"\n\t\t \"3caa88e6d57bc35e fae0b5afd3145f31\"));\n  test_hash(&nettle_sha384, SDATA(\"38\"),\n\t    SHEX(\"c071d202ad950b6a 04a5f15c24596a99\"\n\t\t \"3af8b212467958d5 70a3ffd478006063\"\n\t\t \"8e3a3d06637691d3 012bd31122071b2c\"));\n  test_hash(&nettle_sha384, SDATA(\"message digest\"),\n\t    SHEX(\"473ed35167ec1f5d 8e550368a3db39be\"\n\t\t \"54639f828868e945 4c239fc8b52e3c61\"\n\t\t \"dbd0d8b4de1390c2 56dcbb5d5fd99cd5\"));\n  test_hash(&nettle_sha384, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"feb67349df3db6f5 924815d6c3dc133f\"\n\t\t \"091809213731fe5c 7b5f4999e463479f\"\n\t\t \"f2877f5f2936fa63 bb43784b12f3ebb4\"));\n  test_hash(&nettle_sha384,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"\n\t\t  \"ghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"1761336e3f7cbfe5 1deb137f026f89e0\"\n\t\t \"1a448e3b1fafa640 39c1464ee8732f11\"\n\t\t \"a5341a6f41e0c202 294736ed64db1a84\"));\n  test_hash(&nettle_sha384,\n\t    SDATA(\"12345678901234567890123456789012\"\n\t\t  \"34567890123456789012345678901234\"\n\t\t  \"5678901234567890\"),\n\t    SHEX(\"b12932b0627d1c06 0942f54477641556\"\n\t\t \"55bd4da0c9afa6dd 9b9ef53129af1b8f\"\n\t\t \"b0195996d2de9ca0 df9d821ffee67026\"));\n}",
      "lines": 52,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha512-224-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA_All.pdf */\n  test_hash(&nettle_sha512_224, SDATA(\"abc\"),\n\t    SHEX(\"4634270F 707B6A54 DAAE7530 460842E2\"\n\t\t \"0E37ED26 5CEEE9A4 3E8924AA\"));\n\n  test_hash(&nettle_sha512_224, SDATA(\"abcdefghbcdefghicdefghijdefghijk\"\n\t\t\t\t      \"efghijklfghijklmghijklmnhijklmno\"\n\t\t\t\t      \"ijklmnopjklmnopqklmnopqrlmnopqrs\"\n\t\t\t\t      \"mnopqrstnopqrstu\"),\n\t    SHEX(\"23FEC5BB 94D60B23 30819264 0B0C4533\"\n\t\t \"35D66473 4FE40E72 68674AF9\"));\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha512-256-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From http://csrc.nist.gov/groups/ST/toolkit/documents/Examples/SHA_All.pdf */\n  test_hash(&nettle_sha512_256, SDATA(\"abc\"),\n\t    SHEX(\"53048E26 81941EF9 9B2E29B7 6B4C7DAB\"\n\t\t \"E4C2D0C6 34FC6D46 E0E2F131 07E7AF23\"));\n\n  test_hash(&nettle_sha512_256, SDATA(\"abcdefghbcdefghicdefghijdefghijk\"\n\t\t\t\t      \"efghijklfghijklmghijklmnhijklmno\"\n\t\t\t\t      \"ijklmnopjklmnopqklmnopqrlmnopqrs\"\n\t\t\t\t      \"mnopqrstnopqrstu\"),\n\t    SHEX(\"3928E184 FB8690F8 40DA3988 121D31BE\"\n\t\t \"65CB9D3E F83EE614 6FEAC861 E19B563A\"));\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/sha512-test.c": {
    "test_main": {
      "start_point": [
        2,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  test_hash(&nettle_sha512, SDATA(\"abc\"),\n\t    SHEX(\"ddaf35a193617aba cc417349ae204131\"\n\t\t \"12e6fa4e89a97ea2 0a9eeee64b55d39a\"\n\t\t \"2192992a274fc1a8 36ba3c23a3feebbd\"\n\t\t \"454d4423643ce80e 2a9ac94fa54ca49f\"));\n  \n  test_hash(&nettle_sha512,\n\t    SDATA(\"abcdefghbcdefghicdefghijdefg\"\n\t\t  \"hijkefghijklfghijklmghijklmn\"\n\t\t  \"hijklmnoijklmnopjklmnopqklmn\"\n\t\t  \"opqrlmnopqrsmnopqrstnopqrstu\"),\n\t    SHEX(\"8e959b75dae313da 8cf4f72814fc143f\"\n\t\t \"8f7779c6eb9f7fa1 7299aeadb6889018\"\n\t\t \"501d289e4900f7e4 331b99dec4b5433a\"\n\t\t \"c7d329eeb6dd2654 5e96e55b874be909\"));\n\n  /* NESSIE, Set 1, vector #6 */\n  test_hash(&nettle_sha512,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"),\n\t    SHEX(\"1E07BE23C26A86EA37EA810C8EC78093\"\n\t\t \"52515A970E9253C26F536CFC7A9996C4\"\n\t\t \"5C8370583E0A78FA4A90041D71A4CEAB\"\n\t\t \"7423F19C71B9D5A3E01249F0BEBD5894\"));\n  \n  /* NESSIE, Set 1, vector #7 */\n  test_hash(&nettle_sha512,\n\t    SDATA(\"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"),\n\t    SHEX(\"72EC1EF1124A45B047E8B7C75A932195\"\n\t\t \"135BB61DE24EC0D1914042246E0AEC3A\"\n\t\t \"2354E093D76F3048B456764346900CB1\"\n\t\t \"30D2A4FD5DD16ABB5E30BCB850DEE843\"));\n\n  /* Variants longer than one block (128 bytes), to test varying alignment. */\n  test_hash(&nettle_sha512,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"\n\t\t  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"\n\t\t  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t  \"abcdefghijklmnopqrstuvwxyz\"\n\t\t  \"0123456789\"),\n\t    SHEX(\"5338370f5655f4da14572d4fb471539b\"\n\t\t \"201485ecfb3d3204048dc6b83e61fab5\"\n\t\t \"05bcbbd73e644a1a5d159a32a0889cf3\"\n\t\t \"c9591b69b26d31be56c68838ce3cd63d\"));\n  test_hash(&nettle_sha512,\n\t    SDATA(\"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"\t    \n\t\t  \"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"\t    \n\t\t  \"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\"\t    \n\t\t  \"1234567890123456789012345678901234567890\"\n\t\t  \"1234567890123456789012345678901234567890\")\t    ,\n\t    SHEX(\"33f8901b053e4cc677d3cb4122d96ad9\"\n\t\t \"b96b13bf76194cf962488bb4de4998a7\"\n\t\t \"1455cb31582db527adf77a485b81cf5b\"\n\t\t \"722a5e8638eb6be487400f3aec006e7c\"));\n\n  /* Additional test vectors, from Daniel Kahn Gillmor */\n  test_hash(&nettle_sha512, SDATA(\"\"),\n\t    SHEX(\"cf83e1357eefb8bd f1542850d66d8007\"\n\t\t \"d620e4050b5715dc 83f4a921d36ce9ce\"\n\t\t \"47d0d13c5d85f2b0 ff8318d2877eec2f\"\n\t\t \"63b931bd47417a81 a538327af927da3e\"));\n  test_hash(&nettle_sha512, SDATA(\"a\"),\n\t    SHEX(\"1f40fc92da241694 750979ee6cf582f2\"\n\t\t \"d5d7d28e18335de0 5abc54d0560e0f53\"\n\t\t \"02860c652bf08d56 0252aa5e74210546\"\n\t\t \"f369fbbbce8c12cf c7957b2652fe9a75\"));\n  test_hash(&nettle_sha512, SDATA(\"38\"),\n\t    SHEX(\"caae34a5e8103126 8bcdaf6f1d8c04d3\"\n\t\t \"7b7f2c349afb705b 575966f63e2ebf0f\"\n\t\t \"d910c3b05160ba08 7ab7af35d40b7c71\"\n\t\t \"9c53cd8b947c9611 1f64105fd45cc1b2\"));\n  test_hash(&nettle_sha512, SDATA(\"message digest\"),\n\t    SHEX(\"107dbf389d9e9f71 a3a95f6c055b9251\"\n\t\t \"bc5268c2be16d6c1 3492ea45b0199f33\"\n\t\t \"09e16455ab1e9611 8e8a905d5597b720\"\n\t\t \"38ddb372a8982604 6de66687bb420e7c\"));\n  test_hash(&nettle_sha512, SDATA(\"abcdefghijklmnopqrstuvwxyz\"),\n\t    SHEX(\"4dbff86cc2ca1bae 1e16468a05cb9881\"\n\t\t \"c97f1753bce36190 34898faa1aabe429\"\n\t\t \"955a1bf8ec483d74 21fe3c1646613a59\"\n\t\t \"ed5441fb0f321389 f77f48a879c7b1f1\"));\n  test_hash(&nettle_sha512,\n\t    SDATA(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\"\n\t\t  \"ghijklmnopqrstuvwxyz0123456789\"),\n\t    SHEX(\"1e07be23c26a86ea 37ea810c8ec78093\"\n\t\t \"52515a970e9253c2 6f536cfc7a9996c4\"\n\t\t \"5c8370583e0a78fa 4a90041d71a4ceab\"\n\t\t \"7423f19c71b9d5a3 e01249f0bebd5894\"));\n  test_hash(&nettle_sha512,\n\t    SDATA(\"12345678901234567890123456789012\"\n\t\t  \"34567890123456789012345678901234\"\n\t\t  \"5678901234567890\"),\n\t    SHEX(\"72ec1ef1124a45b0 47e8b7c75a932195\"\n\t\t \"135bb61de24ec0d1 914042246e0aec3a\"\n\t\t \"2354e093d76f3048 b456764346900cb1\"\n\t\t \"30d2a4fd5dd16abb 5e30bcb850dee843\"));\n}",
      "lines": 109,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/testutils.c": {
    "die": {
      "start_point": [
        15,
        0
      ],
      "end_point": [
        24,
        1
      ],
      "content": "void\ndie(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n\n  abort ();\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xalloc": {
      "start_point": [
        26,
        0
      ],
      "end_point": [
        37,
        1
      ],
      "content": "void *\nxalloc(size_t size)\n{\n  void *p = malloc(size);\n  if (size && !p)\n    {\n      fprintf(stderr, \"Virtual memory exhausted.\\n\");\n      abort();\n    }\n\n  return p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "*\nxalloc(size_t size)",
        "*"
      ]
    },
    "tstring_alloc": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        51,
        1
      ],
      "content": "struct tstring *\ntstring_alloc (size_t length)\n{\n  struct tstring *s = xalloc(sizeof(struct tstring) + length);\n  s->length = length;\n  s->next = tstring_first;\n  /* NUL-terminate, for convenience. */\n  s->data[length] = '\\0';\n  tstring_first = s;\n  return s;\n}",
      "lines": 11,
      "depth": 11,
      "decorators": [
        "struct tstring",
        "struct",
        "tstring",
        "*\ntstring_alloc (size_t length)",
        "*"
      ]
    },
    "tstring_clear": {
      "start_point": [
        53,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "void\ntstring_clear(void)\n{\n  while (tstring_first)\n    {\n      struct tstring *s = tstring_first;\n      tstring_first = s->next;\n      free(s);\n    }\n}",
      "lines": 10,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "tstring_data": {
      "start_point": [
        64,
        0
      ],
      "end_point": [
        70,
        1
      ],
      "content": "struct tstring *\ntstring_data(size_t length, const uint8_t *data)\n{\n  struct tstring *s = tstring_alloc (length);\n  memcpy (s->data, data, length);\n  return s;\n}",
      "lines": 7,
      "depth": 7,
      "decorators": [
        "struct tstring",
        "struct",
        "tstring",
        "*\ntstring_data(size_t length, const uint8_t *data)",
        "*"
      ]
    },
    "tstring_hex": {
      "start_point": [
        72,
        0
      ],
      "end_point": [
        86,
        1
      ],
      "content": "struct tstring *\ntstring_hex(const char *hex)\n{\n  struct base16_decode_ctx ctx;\n  struct tstring *s;\n  size_t length = strlen(hex);\n\n  s = tstring_alloc(BASE16_DECODE_LENGTH (length));\n  base16_decode_init (&ctx);\n  ASSERT (base16_decode_update (&ctx, &s->length, s->data,\n\t\t\t\tlength, hex));\n  ASSERT (base16_decode_final (&ctx));\n\n  return s;\n}",
      "lines": 15,
      "depth": 10,
      "decorators": [
        "struct tstring",
        "struct",
        "tstring",
        "*\ntstring_hex(const char *hex)",
        "*"
      ]
    },
    "tstring_print_hex": {
      "start_point": [
        88,
        0
      ],
      "end_point": [
        92,
        1
      ],
      "content": "void\ntstring_print_hex(const struct tstring *s)\n{\n  print_hex (s->length, s->data);\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "void"
      ]
    },
    "print_hex": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        115,
        1
      ],
      "content": "void\nprint_hex(size_t length, const uint8_t *data)\n{\n  size_t i;\n  \n  for (i = 0; i < length; i++)\n    {\n      switch (i % 16)\n\t{\n\tdefault:\n\t  break;\n\tcase 0:\n\t  printf(\"\\n\");\n\t  break;\n\tcase 8:\n\t  printf(\" \");\n\t  break;\n\t}\n      printf(\"%02x\", data[i]);\n    }\n  printf(\"\\n\");\n}",
      "lines": 22,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "main": {
      "start_point": [
        119,
        0
      ],
      "end_point": [
        138,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  if (argc > 1)\n    {\n      if (argc == 2 && !strcmp(argv[1], \"-v\"))\n\tverbose = 1;\n      else\n\t{\n\t  fprintf(stderr, \"Invalid argument `%s', only accepted option is `-v'.\\n\",\n\t\t  argv[1]);\n\t  return 1;\n\t}\n    }\n\n  test_main();\n\n  tstring_clear();\n  return EXIT_SUCCESS;\n}",
      "lines": 20,
      "depth": 12,
      "decorators": [
        "int"
      ]
    },
    "test_cipher": {
      "start_point": [
        140,
        0
      ],
      "end_point": [
        184,
        1
      ],
      "content": "void\ntest_cipher(const struct nettle_cipher *cipher,\n\t    const struct tstring *key,\n\t    const struct tstring *cleartext,\n\t    const struct tstring *ciphertext)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *data = xalloc(cleartext->length);\n  size_t length;\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == cipher->key_size);\n  cipher->set_encrypt_key(ctx, key->data);\n  cipher->encrypt(ctx, length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"Encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_decrypt_key(ctx, key->data);\n  cipher->decrypt(ctx, length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(ctx);\n  free(data);\n}",
      "lines": 45,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_cipher_cbc": {
      "start_point": [
        186,
        0
      ],
      "end_point": [
        245,
        1
      ],
      "content": "void\ntest_cipher_cbc(const struct nettle_cipher *cipher,\n\t\tconst struct tstring *key,\n\t\tconst struct tstring *cleartext,\n\t\tconst struct tstring *ciphertext,\n\t\tconst struct tstring *iiv)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *data;\n  uint8_t *iv = xalloc(cipher->block_size);\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == cipher->key_size);\n  ASSERT (iiv->length == cipher->block_size);\n\n  data = xalloc(length);  \n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cbc_encrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CBC encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_decrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cbc_decrypt(ctx, cipher->decrypt,\n\t      cipher->block_size, iv,\n\t      length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"CBC decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(ctx);\n  free(data);\n  free(iv);\n}",
      "lines": 60,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_cipher_cfb": {
      "start_point": [
        247,
        0
      ],
      "end_point": [
        423,
        1
      ],
      "content": "void\ntest_cipher_cfb(const struct nettle_cipher *cipher,\n\t\tconst struct tstring *key,\n\t\tconst struct tstring *cleartext,\n\t\tconst struct tstring *ciphertext,\n\t\tconst struct tstring *iiv)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *data, *data2;\n  uint8_t *iv = xalloc(cipher->block_size);\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == cipher->key_size);\n  ASSERT (iiv->length == cipher->block_size);\n\n  data = xalloc(length);\n  data2 = xalloc(length);\n\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_encrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CFB encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_decrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data2, data);\n\n  if (!MEMEQ(length, data2, cleartext->data))\n    {\n      fprintf(stderr, \"CFB decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data2);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n  memcpy(data, cleartext->data, length);\n\n  cfb_encrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CFB inplace encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_decrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"CFB inplace decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  /* Repeat all tests with incomplete last block */\n  length -= 1;\n\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_encrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CFB encrypt failed:\\nInput:\");\n      print_hex(length, cleartext->data);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(length, ciphertext->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_decrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data2, data);\n\n  if (!MEMEQ(length, data2, cleartext->data))\n    {\n      fprintf(stderr, \"CFB decrypt failed:\\nInput:\");\n      print_hex(length, ciphertext->data);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data2);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(length, cleartext->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n  memcpy(data, cleartext->data, length);\n\n  cfb_encrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CFB inplace encrypt failed:\\nInput:\");\n      print_hex(length, cleartext->data);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(length, ciphertext->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(iv, iiv->data, cipher->block_size);\n\n  cfb_decrypt(ctx, cipher->encrypt,\n\t      cipher->block_size, iv,\n\t      length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"CFB inplace decrypt failed:\\nInput:\");\n      print_hex(length, ciphertext->data);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      print_hex(length, cleartext->data);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  free(ctx);\n  free(data);\n  free(data2);\n  free(iv);\n}",
      "lines": 177,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_cipher_ctr": {
      "start_point": [
        425,
        0
      ],
      "end_point": [
        503,
        1
      ],
      "content": "void\ntest_cipher_ctr(const struct nettle_cipher *cipher,\n\t\tconst struct tstring *key,\n\t\tconst struct tstring *cleartext,\n\t\tconst struct tstring *ciphertext,\n\t\tconst struct tstring *ictr)\n{\n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *data;\n  uint8_t *ctr = xalloc(cipher->block_size);\n  uint8_t *octr = xalloc(cipher->block_size);\n  size_t length, nblocks;\n  unsigned low;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == cipher->key_size);\n  ASSERT (ictr->length == cipher->block_size);\n\n  /* Compute expected counter value after the operation. */\n  nblocks = (length + cipher->block_size - 1) / cipher->block_size;\n  ASSERT (nblocks < 0x100);\n\n  memcpy (octr, ictr->data, cipher->block_size - 1);\n  low = ictr->data[cipher->block_size - 1] + nblocks;\n  octr[cipher->block_size - 1] = low;\n\n  if (low >= 0x100)\n    INCREMENT (cipher->block_size - 1, octr);\n\n  data = xalloc(length);  \n\n  cipher->set_encrypt_key(ctx, key->data);\n  memcpy(ctr, ictr->data, cipher->block_size);\n\n  ctr_crypt(ctx, cipher->encrypt,\n\t    cipher->block_size, ctr,\n\t    length, data, cleartext->data);\n\n  if (!MEMEQ(length, data, ciphertext->data))\n    {\n      fprintf(stderr, \"CTR encrypt failed:\\nInput:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  ASSERT (MEMEQ (cipher->block_size, ctr, octr));\n\n  memcpy(ctr, ictr->data, cipher->block_size);\n\n  ctr_crypt(ctx, cipher->encrypt,\n\t    cipher->block_size, ctr,\n\t    length, data, data);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"CTR decrypt failed:\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\n    }\n\n  ASSERT (MEMEQ (cipher->block_size, ctr, octr));\n\n  free(ctx);\n  free(data);\n  free(octr);\n  free(ctr);\n}",
      "lines": 79,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_cipher_stream": {
      "start_point": [
        506,
        0
      ],
      "end_point": [
        572,
        1
      ],
      "content": "void\ntest_cipher_stream(const struct nettle_cipher *cipher,\n\t\t   const struct tstring *key,\n\t\t   const struct tstring *cleartext,\n\t\t   const struct tstring *ciphertext)\n{\n  size_t block;\n  \n  void *ctx = xalloc(cipher->context_size);\n  uint8_t *data;\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  data = xalloc(length + 1);\n\n  for (block = 1; block <= length; block++)\n    {\n      size_t i;\n\n      memset(data, 0x17, length + 1);\n      cipher->set_encrypt_key(ctx, key->length, key->data);\n\n      for (i = 0; i + block < length; i += block)\n\t{\n\t  cipher->encrypt(ctx, block, data + i, cleartext->data + i);\n\t  ASSERT (data[i + block] == 0x17);\n\t}\n\n      cipher->encrypt(ctx, length - i, data + i, cleartext->data + i);\n      ASSERT (data[length] == 0x17);\n      \n      if (!MEMEQ(length, data, ciphertext->data))\n\t{\n\t  fprintf(stderr, \"Encrypt failed, block size %lu\\nInput:\",\n\t\t  (unsigned long) block);\n\t  tstring_print_hex(cleartext);\n\t  fprintf(stderr, \"\\nOutput: \");\n\t  print_hex(length, data);\n\t  fprintf(stderr, \"\\nExpected:\");\n\t  tstring_print_hex(ciphertext);\n\t  fprintf(stderr, \"\\n\");\n\t  FAIL();\t    \n\t}\n    }\n  \n  cipher->set_decrypt_key(ctx, key->length, key->data);\n  cipher->decrypt(ctx, length, data, data);\n\n  ASSERT (data[length] == 0x17);\n\n  if (!MEMEQ(length, data, cleartext->data))\n    {\n      fprintf(stderr, \"Decrypt failed\\nInput:\");\n      tstring_print_hex(ciphertext);\n      fprintf(stderr, \"\\nOutput: \");\n      print_hex(length, data);\n      fprintf(stderr, \"\\nExpected:\");\n      tstring_print_hex(cleartext);\n      fprintf(stderr, \"\\n\");\n      FAIL();\t    \n    }\n\n  free(ctx);\n  free(data);\n}",
      "lines": 67,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "test_aead": {
      "start_point": [
        575,
        0
      ],
      "end_point": [
        648,
        1
      ],
      "content": "void\ntest_aead(const struct nettle_aead *aead,\n\t  nettle_hash_update_func *set_nonce,\n\t  const struct tstring *key,\n\t  const struct tstring *authtext,\n\t  const struct tstring *cleartext,\n\t  const struct tstring *ciphertext,\n\t  const struct tstring *nonce,\n\t  const struct tstring *digest)\n{\n  void *ctx = xalloc(aead->context_size);\n  uint8_t *data;\n  uint8_t *buffer = xalloc(aead->digest_size);\n  size_t length;\n\n  ASSERT (cleartext->length == ciphertext->length);\n  length = cleartext->length;\n\n  ASSERT (key->length == aead->key_size);\n  ASSERT (digest->length <= aead->digest_size);\n\n  data = xalloc(length);\n  \n  /* encryption */\n  memset(buffer, 0, aead->digest_size);\n  aead->set_encrypt_key(ctx, key->data);\n\n  if (nonce->length != aead->nonce_size)\n    {\n      ASSERT (set_nonce);\n      set_nonce (ctx, nonce->length, nonce->data);\n    }\n  else\n    aead->set_nonce(ctx, nonce->data);\n\n  if (authtext->length)\n    aead->update(ctx, authtext->length, authtext->data);\n    \n  if (length)\n    aead->encrypt(ctx, length, data, cleartext->data);\n\n  aead->digest(ctx, digest->length, buffer);\n\n  ASSERT(MEMEQ(length, data, ciphertext->data));\n  ASSERT(MEMEQ(digest->length, buffer, digest->data));\n\n  /* decryption */\n  memset(buffer, 0, aead->digest_size);\n\n  aead->set_decrypt_key(ctx, key->data);\n\n  if (nonce->length != aead->nonce_size)\n    {\n      ASSERT (set_nonce);\n      set_nonce (ctx, nonce->length, nonce->data);\n    }\n  else\n    aead->set_nonce(ctx, nonce->data);\n\n  if (authtext->length)\n    aead->update(ctx, authtext->length, authtext->data);\n    \n  if (length)\n    aead->decrypt(ctx, length, data, data);\n\n  aead->digest(ctx, digest->length, buffer);\n\n  ASSERT(MEMEQ(length, data, cleartext->data));\n  ASSERT(MEMEQ(digest->length, buffer, digest->data));\n\n  free(ctx);\n  free(data);\n  free(buffer);\n}",
      "lines": 74,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_hash": {
      "start_point": [
        650,
        0
      ],
      "end_point": [
        703,
        1
      ],
      "content": "void\ntest_hash(const struct nettle_hash *hash,\n\t  const struct tstring *msg,\n\t  const struct tstring *digest)\n{\n  void *ctx = xalloc(hash->context_size);\n  uint8_t *buffer = xalloc(hash->digest_size);\n  uint8_t *input;\n  unsigned offset;\n\n  ASSERT (digest->length == hash->digest_size);\n\n  hash->init(ctx);\n  hash->update(ctx, msg->length, msg->data);\n  hash->digest(ctx, hash->digest_size, buffer);\n\n  if (MEMEQ(hash->digest_size, digest->data, buffer) == 0)\n    {\n      fprintf(stdout, \"\\nGot:\\n\");\n      print_hex(hash->digest_size, buffer);\n      fprintf(stdout, \"\\nExpected:\\n\");\n      print_hex(hash->digest_size, digest->data);\n      abort();\n    }\n\n  memset(buffer, 0, hash->digest_size);\n\n  hash->update(ctx, msg->length, msg->data);\n  hash->digest(ctx, hash->digest_size - 1, buffer);\n\n  ASSERT(MEMEQ(hash->digest_size - 1, digest->data, buffer));\n\n  ASSERT(buffer[hash->digest_size - 1] == 0);\n\n  input = xalloc (msg->length + 16);\n  for (offset = 0; offset < 16; offset++)\n    {\n      memset (input, 0, msg->length + 16);\n      memcpy (input + offset, msg->data, msg->length);\n      hash->update (ctx, msg->length, input + offset);\n      hash->digest (ctx, hash->digest_size, buffer);\n      if (MEMEQ(hash->digest_size, digest->data, buffer) == 0)\n\t{\n\t  fprintf(stdout, \"hash input address: %p\\nGot:\\n\", input + offset);\n\t  print_hex(hash->digest_size, buffer);\n\t  fprintf(stdout, \"\\nExpected:\\n\");\n\t  print_hex(hash->digest_size, digest->data);\n\t  abort();\n\t}      \n    }\n  free(ctx);\n  free(buffer);\n  free(input);\n}",
      "lines": 54,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "test_hash_large": {
      "start_point": [
        705,
        0
      ],
      "end_point": [
        738,
        1
      ],
      "content": "void\ntest_hash_large(const struct nettle_hash *hash,\n\t\tsize_t count, size_t length,\n\t\tuint8_t c,\n\t\tconst struct tstring *digest)\n{\n  void *ctx = xalloc(hash->context_size);\n  uint8_t *buffer = xalloc(hash->digest_size);\n  uint8_t *data = xalloc(length);\n  size_t i;\n\n  ASSERT (digest->length == hash->digest_size);\n\n  memset(data, c, length);\n\n  hash->init(ctx);\n  for (i = 0; i < count; i++)\n    {\n      hash->update(ctx, length, data);\n      if (i % (count / 50) == 0)\n\tfprintf (stderr, \".\");\n    }\n  fprintf (stderr, \"\\n\");\n  \n  hash->digest(ctx, hash->digest_size, buffer);\n\n  print_hex(hash->digest_size, buffer);\n\n  ASSERT (MEMEQ(hash->digest_size, digest->data, buffer));\n\n  free(ctx);\n  free(buffer);\n  free(data);\n}",
      "lines": 34,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "test_armor": {
      "start_point": [
        740,
        0
      ],
      "end_point": [
        783,
        1
      ],
      "content": "void\ntest_armor(const struct nettle_armor *armor,\n           size_t data_length,\n           const uint8_t *data,\n           const char *ascii)\n{\n  size_t ascii_length = strlen(ascii);\n  char *buffer = xalloc(1 + ascii_length);\n  uint8_t *check = xalloc(1 + armor->decode_length(ascii_length));\n  void *encode = xalloc(armor->encode_context_size);\n  void *decode = xalloc(armor->decode_context_size);\n  size_t done;\n\n  ASSERT(ascii_length\n\t <= (armor->encode_length(data_length) + armor->encode_final_length));\n  ASSERT(data_length <= armor->decode_length(ascii_length));\n  \n  memset(buffer, 0x33, 1 + ascii_length);\n  memset(check, 0x55, 1 + data_length);\n\n  armor->encode_init(encode);\n  \n  done = armor->encode_update(encode, buffer, data_length, data);\n  done += armor->encode_final(encode, buffer + done);\n  ASSERT(done == ascii_length);\n\n  ASSERT (MEMEQ(ascii_length, buffer, ascii));\n  ASSERT (0x33 == buffer[strlen(ascii)]);\n\n  armor->decode_init(decode);\n  done = armor->decode_length(ascii_length);\n\n  ASSERT(armor->decode_update(decode, &done, check, ascii_length, buffer));\n  ASSERT(done == data_length);\n  ASSERT(armor->decode_final(decode));\n  \n  ASSERT (MEMEQ(data_length, check, data));\n  ASSERT (0x55 == check[data_length]);\n\n  free(buffer);\n  free(check);\n  free(encode);\n  free(decode);\n}",
      "lines": 44,
      "depth": 11,
      "decorators": [
        "void"
      ]
    },
    "mpn_zero_p": {
      "start_point": [
        788,
        0
      ],
      "end_point": [
        797,
        1
      ],
      "content": "int\nmpn_zero_p (mp_srcptr ap, mp_size_t n)\n{\n  while (--n >= 0)\n    {\n      if (ap[n] != 0)\n\treturn 0;\n    }\n  return 1;\n}",
      "lines": 10,
      "depth": 9,
      "decorators": [
        "int"
      ]
    },
    "mpn_out_str": {
      "start_point": [
        800,
        0
      ],
      "end_point": [
        805,
        1
      ],
      "content": "void\nmpn_out_str (FILE *f, int base, const mp_limb_t *xp, mp_size_t xn)\n{\n  mpz_t x;\n  mpz_out_str (f, base, mpz_roinit_n (x, xp, xn));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "gmp_randinit_default": {
      "start_point": [
        808,
        0
      ],
      "end_point": [
        812,
        1
      ],
      "content": "void\ngmp_randinit_default (struct knuth_lfib_ctx *ctx)\n{\n  knuth_lfib_init (ctx, 17);\n}",
      "lines": 5,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "mpz_urandomb": {
      "start_point": [
        813,
        0
      ],
      "end_point": [
        823,
        1
      ],
      "content": "void\nmpz_urandomb (mpz_t r, struct knuth_lfib_ctx *ctx, mp_bitcnt_t bits)\n{\n  size_t bytes = (bits+7)/8;\n  uint8_t *buf = xalloc (bytes);\n\n  knuth_lfib_random (ctx, bytes, buf);\n  buf[0] &= 0xff >> (8*bytes - bits);\n  nettle_mpz_set_str_256_u (r, bytes, buf);\n  free (buf);\n}",
      "lines": 11,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "xalloc_limbs": {
      "start_point": [
        826,
        0
      ],
      "end_point": [
        830,
        1
      ],
      "content": "mp_limb_t *\nxalloc_limbs (mp_size_t n)\n{\n  return xalloc (n * sizeof (mp_limb_t));\n}",
      "lines": 5,
      "depth": 9,
      "decorators": [
        "mp_limb_t",
        "*\nxalloc_limbs (mp_size_t n)",
        "*"
      ]
    },
    "test_rsa_set_key_1": {
      "start_point": [
        866,
        0
      ],
      "end_point": [
        955,
        1
      ],
      "content": "void\ntest_rsa_set_key_1(struct rsa_public_key *pub,\n\t\t   struct rsa_private_key *key)\n{\n  /* Initialize key pair for test programs */\n  /* 1000-bit key, generated by\n   *\n   *   lsh-keygen -a rsa -l 1000 -f advanced-hex\n   *\n   * (private-key (rsa-pkcs1 \n   *        (n #69abd505285af665 36ddc7c8f027e6f0 ed435d6748b16088\n   *            4fd60842b3a8d7fb bd8a3c98f0cc50ae 4f6a9f7dd73122cc\n   *            ec8afa3f77134406 f53721973115fc2d 8cfbba23b145f28d\n   *            84f81d3b6ae8ce1e 2850580c026e809b cfbb52566ea3a3b3\n   *            df7edf52971872a7 e35c1451b8636d22 279a8fb299368238\n   *            e545fbb4cf#)\n   *        (e #0db2ad57#)\n   *        (d #3240a56f4cd0dcc2 4a413eb4ea545259 5c83d771a1c2ba7b\n   *            ec47c5b43eb4b374 09bd2aa1e236dd86 481eb1768811412f\n   *            f8d91be3545912af b55c014cb55ceac6 54216af3b85d5c4f\n   *            4a32894e3b5dfcde 5b2875aa4dc8d9a8 6afd0ca92ef50d35\n   *            bd09f1c47efb4c8d c631e07698d362aa 4a83fd304e66d6c5\n   *            468863c307#)\n   *        (p #0a66399919be4b4d e5a78c5ea5c85bf9 aba8c013cb4a8732\n   *            14557a12bd67711e bb4073fd39ad9a86 f4e80253ad809e5b\n   *            f2fad3bc37f6f013 273c9552c9f489#)\n   *        (q #0a294f069f118625 f5eae2538db9338c 776a298eae953329\n   *            9fd1eed4eba04e82 b2593bc98ba8db27 de034da7daaea795\n   *            2d55b07b5f9a5875 d1ca5f6dcab897#)\n   *        (a #011b6c48eb592eee e85d1bb35cfb6e07 344ea0b5e5f03a28\n   *            5b405396cbc78c5c 868e961db160ba8d 4b984250930cf79a\n   *            1bf8a9f28963de53 128aa7d690eb87#)\n   *        (b #0409ecf3d2557c88 214f1af5e1f17853 d8b2d63782fa5628\n   *            60cf579b0833b7ff 5c0529f2a97c6452 2fa1a8878a9635ab\n   *            ce56debf431bdec2 70b308fa5bf387#)\n   *        (c #04e103ee925cb5e6 6653949fa5e1a462 c9e65e1adcd60058\n   *            e2df9607cee95fa8 daec7a389a7d9afc 8dd21fef9d83805a\n   *            40d46f49676a2f6b 2926f70c572c00#)))\n   */\n  \n  mpz_set_str(pub->n,\n\t      \"69abd505285af665\" \"36ddc7c8f027e6f0\" \"ed435d6748b16088\"\n\t      \"4fd60842b3a8d7fb\" \"bd8a3c98f0cc50ae\" \"4f6a9f7dd73122cc\"\n\t      \"ec8afa3f77134406\" \"f53721973115fc2d\" \"8cfbba23b145f28d\"\n\t      \"84f81d3b6ae8ce1e\" \"2850580c026e809b\" \"cfbb52566ea3a3b3\"\n\t      \"df7edf52971872a7\" \"e35c1451b8636d22\" \"279a8fb299368238\"\n\t      \"e545fbb4cf\", 16);\n  mpz_set_str(pub->e, \"0db2ad57\", 16);\n\n  ASSERT (rsa_public_key_prepare(pub));\n  \n  /* d is not used */\n#if 0  \n  mpz_set_str(key->d,\n\t      \"3240a56f4cd0dcc2\" \"4a413eb4ea545259\" \"5c83d771a1c2ba7b\"\n\t      \"ec47c5b43eb4b374\" \"09bd2aa1e236dd86\" \"481eb1768811412f\"\n\t      \"f8d91be3545912af\" \"b55c014cb55ceac6\" \"54216af3b85d5c4f\"\n\t      \"4a32894e3b5dfcde\" \"5b2875aa4dc8d9a8\" \"6afd0ca92ef50d35\"\n\t      \"bd09f1c47efb4c8d\" \"c631e07698d362aa\" \"4a83fd304e66d6c5\"\n\t      \"468863c307\", 16);\n#endif\n  \n  mpz_set_str(key->p,\n\t      \"0a66399919be4b4d\" \"e5a78c5ea5c85bf9\" \"aba8c013cb4a8732\"\n\t      \"14557a12bd67711e\" \"bb4073fd39ad9a86\" \"f4e80253ad809e5b\"\n\t      \"f2fad3bc37f6f013\" \"273c9552c9f489\", 16);\n\n  mpz_set_str(key->q,\n\t      \"0a294f069f118625\" \"f5eae2538db9338c\" \"776a298eae953329\"\n\t      \"9fd1eed4eba04e82\" \"b2593bc98ba8db27\" \"de034da7daaea795\"\n\t      \"2d55b07b5f9a5875\" \"d1ca5f6dcab897\", 16);\n  \n  mpz_set_str(key->a,\n\t      \"011b6c48eb592eee\" \"e85d1bb35cfb6e07\" \"344ea0b5e5f03a28\"\n\t      \"5b405396cbc78c5c\" \"868e961db160ba8d\" \"4b984250930cf79a\"\n\t      \"1bf8a9f28963de53\" \"128aa7d690eb87\", 16);\n  \n  mpz_set_str(key->b,\n\t      \"0409ecf3d2557c88\" \"214f1af5e1f17853\" \"d8b2d63782fa5628\"\n\t      \"60cf579b0833b7ff\" \"5c0529f2a97c6452\" \"2fa1a8878a9635ab\"\n\t      \"ce56debf431bdec2\" \"70b308fa5bf387\", 16);\n  \n  mpz_set_str(key->c,\n\t      \"04e103ee925cb5e6\" \"6653949fa5e1a462\" \"c9e65e1adcd60058\"\n\t      \"e2df9607cee95fa8\" \"daec7a389a7d9afc\" \"8dd21fef9d83805a\"\n\t      \"40d46f49676a2f6b\" \"2926f70c572c00\", 16);\n\n  ASSERT (rsa_private_key_prepare(key));\n  ASSERT (pub->size == key->size);\n}",
      "lines": 90,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "test_rsa_md5": {
      "start_point": [
        957,
        0
      ],
      "end_point": [
        987,
        1
      ],
      "content": "void\ntest_rsa_md5(struct rsa_public_key *pub,\n\t     struct rsa_private_key *key,\n\t     mpz_t expected)\n{\n  struct md5_ctx md5;\n  struct knuth_lfib_ctx rstate;\n  uint8_t digest[MD5_DIGEST_SIZE];\n  mpz_t signature;\n\n  md5_init(&md5);\n  mpz_init(signature);\n  knuth_lfib_init (&rstate, 15);\n\n  SIGN(md5, \"The magic words are squeamish ossifrage\", expected);\n\n  /* Try bad data */\n  ASSERT (!VERIFY(pub, md5,\n\t\t  \"The magick words are squeamish ossifrage\", signature));\n\n  /* Try correct data */\n  ASSERT (VERIFY(pub, md5,\n\t\t \"The magic words are squeamish ossifrage\", signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!VERIFY(pub, md5,\n\t\t  \"The magic words are squeamish ossifrage\", signature));\n\n  mpz_clear(signature);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_rsa_sha1": {
      "start_point": [
        989,
        0
      ],
      "end_point": [
        1019,
        1
      ],
      "content": "void\ntest_rsa_sha1(struct rsa_public_key *pub,\n\t      struct rsa_private_key *key,\n\t      mpz_t expected)\n{\n  struct sha1_ctx sha1;\n  struct knuth_lfib_ctx rstate;\n  uint8_t digest[SHA1_DIGEST_SIZE];\n  mpz_t signature;\n\n  sha1_init(&sha1);\n  mpz_init(signature);\n  knuth_lfib_init (&rstate, 16);\n\n  SIGN(sha1, \"The magic words are squeamish ossifrage\", expected);\n\n  /* Try bad data */\n  ASSERT (!VERIFY(pub, sha1,\n\t\t  \"The magick words are squeamish ossifrage\", signature));\n\n  /* Try correct data */\n  ASSERT (VERIFY(pub, sha1,\n\t\t \"The magic words are squeamish ossifrage\", signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!VERIFY(pub, sha1,\n\t\t  \"The magic words are squeamish ossifrage\", signature));\n\n  mpz_clear(signature);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_rsa_sha256": {
      "start_point": [
        1021,
        0
      ],
      "end_point": [
        1051,
        1
      ],
      "content": "void\ntest_rsa_sha256(struct rsa_public_key *pub,\n\t\tstruct rsa_private_key *key,\n\t\tmpz_t expected)\n{\n  struct sha256_ctx sha256;\n  struct knuth_lfib_ctx rstate;\n  uint8_t digest[SHA256_DIGEST_SIZE];\n  mpz_t signature;\n\n  sha256_init(&sha256);\n  mpz_init(signature);\n  knuth_lfib_init (&rstate, 17);\n\n  SIGN(sha256, \"The magic words are squeamish ossifrage\", expected);\n\n  /* Try bad data */\n  ASSERT (!VERIFY(pub, sha256,\n\t\t  \"The magick words are squeamish ossifrage\", signature));\n\n  /* Try correct data */\n  ASSERT (VERIFY(pub, sha256,\n\t\t \"The magic words are squeamish ossifrage\", signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!VERIFY(pub, sha256,\n\t\t  \"The magic words are squeamish ossifrage\", signature));\n\n  mpz_clear(signature);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_rsa_sha512": {
      "start_point": [
        1053,
        0
      ],
      "end_point": [
        1083,
        1
      ],
      "content": "void\ntest_rsa_sha512(struct rsa_public_key *pub,\n\t\tstruct rsa_private_key *key,\n\t\tmpz_t expected)\n{\n  struct sha512_ctx sha512;\n  struct knuth_lfib_ctx rstate;\n  uint8_t digest[SHA512_DIGEST_SIZE];\n  mpz_t signature;\n\n  sha512_init(&sha512);\n  mpz_init(signature);\n  knuth_lfib_init (&rstate, 18);\n\n  SIGN(sha512, \"The magic words are squeamish ossifrage\", expected);\n\n  /* Try bad data */\n  ASSERT (!VERIFY(pub, sha512,\n\t\t  \"The magick words are squeamish ossifrage\", signature));\n\n  /* Try correct data */\n  ASSERT (VERIFY(pub, sha512,\n\t\t \"The magic words are squeamish ossifrage\", signature));\n\n  /* Try bad signature */\n  mpz_combit(signature, 17);\n  ASSERT (!VERIFY(pub, sha512,\n\t\t  \"The magic words are squeamish ossifrage\", signature));\n\n  mpz_clear(signature);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_rsa_key": {
      "start_point": [
        1088,
        0
      ],
      "end_point": [
        1152,
        1
      ],
      "content": "void\ntest_rsa_key(struct rsa_public_key *pub,\n\t     struct rsa_private_key *key)\n{\n  mpz_t tmp;\n  mpz_t phi;\n  \n  mpz_init(tmp); mpz_init(phi);\n  \n  if (verbose)\n    {\n      /* FIXME: Use gmp_printf */\n      fprintf(stderr, \"Public key: n=\");\n      mpz_out_str(stderr, 16, pub->n);\n      fprintf(stderr, \"\\n    e=\");\n      mpz_out_str(stderr, 16, pub->e);\n\n      fprintf(stderr, \"\\n\\nPrivate key: d=\");\n      mpz_out_str(stderr, 16, key->d);\n      fprintf(stderr, \"\\n    p=\");\n      mpz_out_str(stderr, 16, key->p);\n      fprintf(stderr, \"\\n    q=\");\n      mpz_out_str(stderr, 16, key->q);\n      fprintf(stderr, \"\\n    a=\");\n      mpz_out_str(stderr, 16, key->a);\n      fprintf(stderr, \"\\n    b=\");\n      mpz_out_str(stderr, 16, key->b);\n      fprintf(stderr, \"\\n    c=\");\n      mpz_out_str(stderr, 16, key->c);\n      fprintf(stderr, \"\\n\\n\");\n    }\n\n  /* Check n = p q */\n  mpz_mul(tmp, key->p, key->q);\n  ASSERT (mpz_cmp(tmp, pub->n)== 0);\n\n  /* Check c q = 1 mod p */\n  mpz_mul(tmp, key->c, key->q);\n  mpz_fdiv_r(tmp, tmp, key->p);\n  ASSERT (mpz_cmp_ui(tmp, 1) == 0);\n\n  /* Check ed = 1 (mod phi) */\n  mpz_sub_ui(phi, key->p, 1);\n  mpz_sub_ui(tmp, key->q, 1);\n\n  mpz_mul(phi, phi, tmp);\n\n  mpz_mul(tmp, pub->e, key->d);\n  mpz_fdiv_r(tmp, tmp, phi);\n  ASSERT (mpz_cmp_ui(tmp, 1) == 0);\n\n  /* Check a e = 1 (mod (p-1) ) */\n  mpz_sub_ui(phi, key->p, 1);\n  mpz_mul(tmp, pub->e, key->a);\n  mpz_fdiv_r(tmp, tmp, phi);\n  ASSERT (mpz_cmp_ui(tmp, 1) == 0);\n  \n  /* Check b e = 1 (mod (q-1) ) */\n  mpz_sub_ui(phi, key->q, 1);\n  mpz_mul(tmp, pub->e, key->b);\n  mpz_fdiv_r(tmp, tmp, phi);\n  ASSERT (mpz_cmp_ui(tmp, 1) == 0);\n  \n  mpz_clear(tmp); mpz_clear(phi);\n}",
      "lines": 65,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_dsa160": {
      "start_point": [
        1159,
        0
      ],
      "end_point": [
        1207,
        1
      ],
      "content": "void\ntest_dsa160(const struct dsa_public_key *pub,\n\t    const struct dsa_private_key *key,\n\t    const struct dsa_signature *expected)\n{\n  struct sha1_ctx sha1;\n  struct dsa_signature signature;\n  struct knuth_lfib_ctx lfib;\n  \n  sha1_init(&sha1);\n  dsa_signature_init(&signature);\n  knuth_lfib_init(&lfib, 1111);\n  \n  sha1_update(&sha1, LDATA(\"The magic words are squeamish ossifrage\"));\n  ASSERT (dsa_sha1_sign(pub, key,\n\t\t\t&lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t\t&sha1, &signature));\n\n  if (verbose)\n    {\n      fprintf(stderr, \"dsa160 signature: \");\n      mpz_out_str(stderr, 16, signature.r);\n      fprintf(stderr, \", \");\n      mpz_out_str(stderr, 16, signature.s);\n      fprintf(stderr, \"\\n\");\n    }\n\n  if (expected)\n    ASSERT (mpz_cmp (signature.r, expected->r) == 0\n\t    && mpz_cmp (signature.s, expected->s) == 0);\n  \n  /* Try bad data */\n  ASSERT (!DSA_VERIFY(pub, sha1,\n\t\t      \"The magick words are squeamish ossifrage\",\n\t\t      &signature));\n\n  /* Try correct data */\n  ASSERT (DSA_VERIFY(pub, sha1,\n\t\t     \"The magic words are squeamish ossifrage\",\n\t\t     &signature));\n\n  /* Try bad signature */\n  mpz_combit(signature.r, 17);\n  ASSERT (!DSA_VERIFY(pub, sha1,\n\t\t      \"The magic words are squeamish ossifrage\",\n\t\t      &signature));\n\n  dsa_signature_clear(&signature);\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "test_dsa256": {
      "start_point": [
        1209,
        0
      ],
      "end_point": [
        1257,
        1
      ],
      "content": "void\ntest_dsa256(const struct dsa_public_key *pub,\n\t    const struct dsa_private_key *key,\n\t    const struct dsa_signature *expected)\n{\n  struct sha256_ctx sha256;\n  struct dsa_signature signature;\n  struct knuth_lfib_ctx lfib;\n  \n  sha256_init(&sha256);\n  dsa_signature_init(&signature);\n  knuth_lfib_init(&lfib, 1111);\n  \n  sha256_update(&sha256, LDATA(\"The magic words are squeamish ossifrage\"));\n  ASSERT (dsa_sha256_sign(pub, key,\n\t\t\t&lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t\t&sha256, &signature));\n  \n  if (verbose)\n    {\n      fprintf(stderr, \"dsa256 signature: \");\n      mpz_out_str(stderr, 16, signature.r);\n      fprintf(stderr, \", \");\n      mpz_out_str(stderr, 16, signature.s);\n      fprintf(stderr, \"\\n\");\n    }\n\n  if (expected)\n    ASSERT (mpz_cmp (signature.r, expected->r) == 0\n\t    && mpz_cmp (signature.s, expected->s) == 0);\n  \n  /* Try bad data */\n  ASSERT (!DSA_VERIFY(pub, sha256,\n\t\t      \"The magick words are squeamish ossifrage\",\n\t\t      &signature));\n\n  /* Try correct data */\n  ASSERT (DSA_VERIFY(pub, sha256,\n\t\t     \"The magic words are squeamish ossifrage\",\n\t\t     &signature));\n\n  /* Try bad signature */\n  mpz_combit(signature.r, 17);\n  ASSERT (!DSA_VERIFY(pub, sha256,\n\t\t      \"The magic words are squeamish ossifrage\",\n\t\t      &signature));\n\n  dsa_signature_clear(&signature);\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "test_dsa_sign": {
      "start_point": [
        1260,
        0
      ],
      "end_point": [
        1315,
        1
      ],
      "content": "void\ntest_dsa_sign(const struct dsa_public_key *pub,\n\t      const struct dsa_private_key *key,\n\t      const struct nettle_hash *hash,\n\t      const struct dsa_signature *expected)\n{\n  void *ctx = xalloc (hash->context_size);\n  uint8_t *digest = xalloc (hash->digest_size);\n  uint8_t *bad_digest = xalloc (hash->digest_size);\n  struct dsa_signature signature;\n  struct knuth_lfib_ctx lfib;\n  \n  dsa_signature_init(&signature);\n  knuth_lfib_init(&lfib, 1111);\n\n  hash->init(ctx);\n  \n  hash->update(ctx, LDATA(\"The magic words are squeamish ossifrage\"));\n  hash->digest(ctx, hash->digest_size, digest);\n  ASSERT (dsa_sign(pub, key,\n\t\t   &lfib, (nettle_random_func *) knuth_lfib_random,\n\t\t   hash->digest_size, digest, &signature));\n  \n  if (verbose)\n    {\n      fprintf(stderr, \"dsa-%s signature: \", hash->name);\n      mpz_out_str(stderr, 16, signature.r);\n      fprintf(stderr, \", \");\n      mpz_out_str(stderr, 16, signature.s);\n      fprintf(stderr, \"\\n\");\n    }\n\n  if (expected)\n    ASSERT (mpz_cmp (signature.r, expected->r) == 0\n\t    && mpz_cmp (signature.s, expected->s) == 0);\n  \n  /* Try correct data */\n  ASSERT (dsa_verify(pub, hash->digest_size, digest,\n\t\t     &signature));\n  /* Try bad data */\n  hash->update(ctx, LDATA(\"The magick words are squeamish ossifrage\"));\n  hash->digest(ctx, hash->digest_size, bad_digest);\n  \n  ASSERT (!dsa_verify(pub, hash->digest_size, bad_digest,\n\t\t      &signature));\n\n  /* Try bad signature */\n  mpz_combit(signature.r, 17);\n  ASSERT (!dsa_verify(pub, hash->digest_size, digest,\n\t\t      &signature));\n\n  free (ctx);\n  free (digest);\n  free (bad_digest);\n  dsa_signature_clear(&signature);\n}",
      "lines": 56,
      "depth": 12,
      "decorators": [
        "void"
      ]
    },
    "test_dsa_verify": {
      "start_point": [
        1318,
        0
      ],
      "end_point": [
        1358,
        1
      ],
      "content": "void\ntest_dsa_verify(const struct dsa_params *params,\n\t\tconst mpz_t pub,\n\t\tconst struct nettle_hash *hash,\n\t\tstruct tstring *msg,\n\t\tconst struct dsa_signature *ref)\n{\n  void *ctx = xalloc (hash->context_size);\n  uint8_t *digest = xalloc (hash->digest_size);\n  struct dsa_signature signature;\n\n  dsa_signature_init (&signature);\n\n  hash->init(ctx);\n  \n  hash->update (ctx, msg->length, msg->data);\n  hash->digest (ctx, hash->digest_size, digest);\n\n  mpz_set (signature.r, ref->r);\n  mpz_set (signature.s, ref->s);\n\n  ASSERT (dsa_verify (params, pub,\n\t\t       hash->digest_size, digest,\n\t\t       &signature));\n\n  /* Try bad signature */\n  mpz_combit(signature.r, 17);\n  ASSERT (!dsa_verify (params, pub,\n\t\t       hash->digest_size, digest,\n\t\t       &signature));\n  \n  /* Try bad data */\n  digest[hash->digest_size / 2-1] ^= 8;\n  ASSERT (!dsa_verify (params, pub,\n\t\t       hash->digest_size, digest,\n\t\t       ref));\n\n  free (ctx);\n  free (digest);\n  dsa_signature_clear(&signature);  \n}",
      "lines": 41,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_dsa_key": {
      "start_point": [
        1360,
        0
      ],
      "end_point": [
        1390,
        1
      ],
      "content": "void\ntest_dsa_key(const struct dsa_params *params,\n\t     const mpz_t pub,\n\t     const mpz_t key,\n\t     unsigned q_size)\n{\n  mpz_t t;\n\n  mpz_init(t);\n\n  ASSERT(mpz_sizeinbase(params->q, 2) == q_size);\n  ASSERT(mpz_sizeinbase(params->p, 2) >= DSA_SHA1_MIN_P_BITS);\n  \n  ASSERT(mpz_probab_prime_p(params->p, 10));\n\n  ASSERT(mpz_probab_prime_p(params->q, 10));\n\n  mpz_fdiv_r(t, params->p, params->q);\n\n  ASSERT(0 == mpz_cmp_ui(t, 1));\n\n  ASSERT(mpz_cmp_ui(params->g, 1) > 0);\n  \n  mpz_powm(t, params->g, params->q, params->p);\n  ASSERT(0 == mpz_cmp_ui(t, 1));\n  \n  mpz_powm(t, params->g, key, params->p);\n  ASSERT(0 == mpz_cmp(t, pub));\n\n  mpz_clear(t);\n}",
      "lines": 31,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "test_mpn": {
      "start_point": [
        1402,
        0
      ],
      "end_point": [
        1415,
        1
      ],
      "content": "static int\ntest_mpn (const char *ref, const mp_limb_t *xp, mp_size_t n)\n{\n  mpz_t r;\n  int res;\n\n  mpz_init_set_str (r, ref, 16);\n  while (n > 0 && xp[n-1] == 0)\n    n--;\n  \n  res = (mpz_limbs_cmp (r, xp, n) == 0);\n  mpz_clear (r);\n  return res;\n}",
      "lines": 14,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "write_mpn": {
      "start_point": [
        1417,
        0
      ],
      "end_point": [
        1422,
        1
      ],
      "content": "void\nwrite_mpn (FILE *f, int base, const mp_limb_t *xp, mp_size_t n)\n{\n  mpz_t t;\n  mpz_out_str (f, base, mpz_roinit_n (t,xp, n));\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "test_ecc_point": {
      "start_point": [
        1424,
        0
      ],
      "end_point": [
        1444,
        1
      ],
      "content": "void\ntest_ecc_point (const struct ecc_curve *ecc,\n\t\tconst struct ecc_ref_point *ref,\n\t\tconst mp_limb_t *p)\n{\n  if (! (test_mpn (ref->x, p, ecc->p.size)\n\t && test_mpn (ref->y, p + ecc->p.size, ecc->p.size) ))\n    {\n      fprintf (stderr, \"Incorrect point!\\n\"\n\t       \"got: x = \");\n      write_mpn (stderr, 16, p, ecc->p.size);\n      fprintf (stderr, \"\\n\"\n\t       \"     y = \");\n      write_mpn (stderr, 16, p + ecc->p.size, ecc->p.size);\n      fprintf (stderr, \"\\n\"\n\t       \"ref: x = %s\\n\"\n\t       \"     y = %s\\n\",\n\t       ref->x, ref->y);\n      abort();\n    }\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "void"
      ]
    },
    "test_ecc_mul_a": {
      "start_point": [
        1446,
        0
      ],
      "end_point": [
        1556,
        1
      ],
      "content": "void\ntest_ecc_mul_a (unsigned curve, unsigned n, const mp_limb_t *p)\n{\n  /* For each curve, the points 2 g, 3 g and 4 g */\n  static const struct ecc_ref_point ref[6][3] = {\n    { { \"dafebf5828783f2ad35534631588a3f629a70fb16982a888\",\n\t\"dd6bda0d993da0fa46b27bbc141b868f59331afa5c7e93ab\" },\n      { \"76e32a2557599e6edcd283201fb2b9aadfd0d359cbb263da\",\n\t\"782c37e372ba4520aa62e0fed121d49ef3b543660cfd05fd\" },\n      { \"35433907297cc378b0015703374729d7a4fe46647084e4ba\",\n\t\"a2649984f2135c301ea3acb0776cd4f125389b311db3be32\" }\n    },\n    { { \"706a46dc76dcb76798e60e6d89474788d16dc18032d268fd1a704fa6\",\n\t\"1c2b76a7bc25e7702a704fa986892849fca629487acf3709d2e4e8bb\" },\n      { \"df1b1d66a551d0d31eff822558b9d2cc75c2180279fe0d08fd896d04\",\n\t\"a3f7f03cadd0be444c0aa56830130ddf77d317344e1af3591981a925\" },\n      { \"ae99feebb5d26945b54892092a8aee02912930fa41cd114e40447301\",\n\t\"482580a0ec5bc47e88bc8c378632cd196cb3fa058a7114eb03054c9\" },\n    },\n    { { \"7cf27b188d034f7e8a52380304b51ac3c08969e277f21b35a60b48fc47669978\",\n\t\"7775510db8ed040293d9ac69f7430dbba7dade63ce982299e04b79d227873d1\" },\n      { \"5ecbe4d1a6330a44c8f7ef951d4bf165e6c6b721efada985fb41661bc6e7fd6c\",\n\t\"8734640c4998ff7e374b06ce1a64a2ecd82ab036384fb83d9a79b127a27d5032\" },\n      { \"e2534a3532d08fbba02dde659ee62bd0031fe2db785596ef509302446b030852\",\n\t\"e0f1575a4c633cc719dfee5fda862d764efc96c3f30ee0055c42c23f184ed8c6\" },\n    },\n    { { \"8d999057ba3d2d969260045c55b97f089025959a6f434d651d207d19fb96e9e\"\n\t\"4fe0e86ebe0e64f85b96a9c75295df61\",\n\t\"8e80f1fa5b1b3cedb7bfe8dffd6dba74b275d875bc6cc43e904e505f256ab425\"\n\t\"5ffd43e94d39e22d61501e700a940e80\" },\n      { \"77a41d4606ffa1464793c7e5fdc7d98cb9d3910202dcd06bea4f240d3566da6\"\n\t\"b408bbae5026580d02d7e5c70500c831\",\n\t\"c995f7ca0b0c42837d0bbe9602a9fc998520b41c85115aa5f7684c0edc111eac\"\n\t\"c24abd6be4b5d298b65f28600a2f1df1\" },\n      { \"138251cd52ac9298c1c8aad977321deb97e709bd0b4ca0aca55dc8ad51dcfc9d\"\n\t\"1589a1597e3a5120e1efd631c63e1835\",\n\t\"cacae29869a62e1631e8a28181ab56616dc45d918abc09f3ab0e63cf792aa4dc\"\n\t\"ed7387be37bba569549f1c02b270ed67\" },\n    },\n    { { \"43\"\n\t\"3c219024277e7e682fcb288148c282747403279b1ccc06352c6e5505d769be97\"\n\t\"b3b204da6ef55507aa104a3a35c5af41cf2fa364d60fd967f43e3933ba6d783d\",\n\t\"f4\"\n\t\"bb8cc7f86db26700a7f3eceeeed3f0b5c6b5107c4da97740ab21a29906c42dbb\"\n\t\"b3e377de9f251f6b93937fa99a3248f4eafcbe95edc0f4f71be356d661f41b02\"\n      },\n      { \"1a7\"\n\t\"3d352443de29195dd91d6a64b5959479b52a6e5b123d9ab9e5ad7a112d7a8dd1\"\n\t\"ad3f164a3a4832051da6bd16b59fe21baeb490862c32ea05a5919d2ede37ad7d\",\n\t\"13e\"\n\t\"9b03b97dfa62ddd9979f86c6cab814f2f1557fa82a9d0317d2f8ab1fa355ceec\"\n\t\"2e2dd4cf8dc575b02d5aced1dec3c70cf105c9bc93a590425f588ca1ee86c0e5\" },\n      { \"35\"\n\t\"b5df64ae2ac204c354b483487c9070cdc61c891c5ff39afc06c5d55541d3ceac\"\n\t\"8659e24afe3d0750e8b88e9f078af066a1d5025b08e5a5e2fbc87412871902f3\",\n\t\"82\"\n\t\"096f84261279d2b673e0178eb0b4abb65521aef6e6e32e1b5ae63fe2f19907f2\"\n\t\"79f283e54ba385405224f750a95b85eebb7faef04699d1d9e21f47fc346e4d0d\" },\n    },\n    { { \"36ab384c9f5a046c3d043b7d1833e7ac080d8e4515d7a45f83c5a14e2843ce0e\",\n\t\"2260cdf3092329c21da25ee8c9a21f5697390f51643851560e5f46ae6af8a3c9\" },\n      { \"67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c\",\n\t\"1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4\" },\n      { \"203da8db56cff1468325d4b87a3520f91a739ec193ce1547493aa657c4c9f870\",\n\t\"47d0e827cb1595e1470eb88580d5716c4cf22832ea2f0ff0df38ab61ca32112f\" },\n    }\n  };\n  assert (curve < 6);\n  assert (n <= 4);\n  if (n == 0)\n    {\n      /* Makes sense for curve25519 only */\n      const struct ecc_curve *ecc = ecc_curves[curve];\n      assert (ecc->p.bit_size == 255);\n      if (!mpn_zero_p (p, ecc->p.size)\n\t  || mpn_cmp (p + ecc->p.size, ecc->unit, ecc->p.size) != 0)\n\t{\n\t  fprintf (stderr, \"Incorrect point (expected (0, 1))!\\n\"\n\t\t   \"got: x = \");\n\t  write_mpn (stderr, 16, p, ecc->p.size);\n\t  fprintf (stderr, \"\\n\"\n\t\t   \"     y = \");\n\t  write_mpn (stderr, 16, p + ecc->p.size, ecc->p.size);\n\t  fprintf (stderr, \"\\n\");\n\t  abort();\n\t}\n    }\n  else if (n == 1)\n    {\n      const struct ecc_curve *ecc = ecc_curves[curve];\n      if (mpn_cmp (p, ecc->g, 2*ecc->p.size) != 0)\n\t{\n\t  fprintf (stderr, \"Incorrect point (expected g)!\\n\"\n\t\t   \"got: x = \");\n\t  write_mpn (stderr, 16, p, ecc->p.size);\n\t  fprintf (stderr, \"\\n\"\n\t\t   \"     y = \");\n\t  write_mpn (stderr, 16, p + ecc->p.size, ecc->p.size);\n\t  fprintf (stderr, \"\\n\"\n\t\t   \"ref: x = \");\n\t  write_mpn (stderr, 16, ecc->g, ecc->p.size);\n\t  fprintf (stderr, \"\\n\"\n\t\t   \"     y = \");\n\t  write_mpn (stderr, 16, ecc->g + ecc->p.size, ecc->p.size);\n\t  fprintf (stderr, \"\\n\");\n\t  abort();\n\t}\n    }\n  else\n    test_ecc_point (ecc_curves[curve], &ref[curve][n-2], p);\n}",
      "lines": 111,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "test_ecc_mul_h": {
      "start_point": [
        1558,
        0
      ],
      "end_point": [
        1570,
        1
      ],
      "content": "void\ntest_ecc_mul_h (unsigned curve, unsigned n, const mp_limb_t *p)\n{\n  const struct ecc_curve *ecc = ecc_curves[curve];\n  mp_limb_t *np = xalloc_limbs (ecc_size_a (ecc));\n  mp_limb_t *scratch = xalloc_limbs (ecc->h_to_a_itch);\n  ecc->h_to_a (ecc, 0, np, p, scratch);\n\n  test_ecc_mul_a (curve, n, np);\n\n  free (np);\n  free (scratch);\n}",
      "lines": 13,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/testutils.h": {},
  "nettle/nettle-3.4.1/testsuite/twofish-test.c": {
    "test_main": {
      "start_point": [
        3,
        0
      ],
      "end_point": [
        25,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* 128 bit key */\n  test_cipher(&nettle_twofish128,\n\t      SHEX(\"0000000000000000 0000000000000000\"),\n\t      SHEX(\"0000000000000000 0000000000000000\"),\n\t      SHEX(\"9F589F5CF6122C32 B6BFEC2F2AE8C35A\"));\n\n  /* 192 bit key */\n  test_cipher(&nettle_twofish192,\n\t      SHEX(\"0123456789ABCDEF FEDCBA9876543210\"\n\t\t   \"0011223344556677\"),\n\t      SHEX(\"0000000000000000 0000000000000000\"),\n\t      SHEX(\"CFD1D2E5A9BE9CDF 501F13B892BD2248\"));\n\n  /* 256 bit key */\n  test_cipher(&nettle_twofish256,\n\t      SHEX(\"0123456789ABCDEF FEDCBA9876543210\"\n\t\t   \"0011223344556677 8899AABBCCDDEEFF\"),\n\t      SHEX(\"0000000000000000 0000000000000000\"),\n\t      SHEX(\"37527BE0052334B8 9F0CFCCAE87CFA20\"));\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/umac-test.c": {
    "update": {
      "start_point": [
        8,
        0
      ],
      "end_point": [
        16,
        1
      ],
      "content": "static void\nupdate (void *ctx, nettle_hash_update_func *f,\n\tconst struct tstring *msg,\n\tsize_t length)\n{\n  for (; length > msg->length; length -= msg->length)\n    f(ctx, msg->length, msg->data);\n  f(ctx, length, msg->data);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "check_digest": {
      "start_point": [
        18,
        0
      ],
      "end_point": [
        35,
        1
      ],
      "content": "static void\ncheck_digest (const char *name, void *ctx, nettle_hash_digest_func *f,\n\t      const struct tstring *msg, size_t length,\n\t      size_t tag_length, const uint8_t *ref)\n{\n  uint8_t tag[16];\n  f(ctx, tag_length, tag);\n  if (memcmp (tag, ref, tag_length) != 0)\n    {\n      printf (\"%s failed\\n\", name);\n      printf (\"msg: \"); print_hex (msg->length, msg->data);\n      printf (\"length: %lu\\n\", (unsigned long) length);\n      printf (\"tag: \"); print_hex (tag_length, tag);\n      printf (\"ref: \"); print_hex (tag_length, ref);\n      abort ();\n    }\n\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_umac": {
      "start_point": [
        37,
        0
      ],
      "end_point": [
        87,
        1
      ],
      "content": "static void\ntest_umac (const struct tstring *key,\n\t   const struct tstring *nonce,\n\t   const struct tstring *msg,\n\t   size_t length,\n\t   const struct tstring *ref32,\n\t   const struct tstring *ref64,\n\t   const struct tstring *ref128)\n{\n  struct umac32_ctx ctx32;\n  struct umac64_ctx ctx64;\n  struct umac96_ctx ctx96;\n  struct umac128_ctx ctx128;\n\n  ASSERT (key->length == UMAC_KEY_SIZE);\n  ASSERT (ref32->length == 4);\n  ASSERT (ref64->length == 8);\n  ASSERT (ref128->length == 16);\n\n  umac32_set_key (&ctx32, key->data);\n  umac32_set_nonce (&ctx32, nonce->length, nonce->data);\n\n  update(&ctx32, (nettle_hash_update_func *) umac32_update, msg, length);\n\n  check_digest (\"umac32\", &ctx32, (nettle_hash_digest_func *) umac32_digest,\n\t\tmsg, length, 4, ref32->data);\n\n  umac64_set_key (&ctx64, key->data);\n  umac64_set_nonce (&ctx64, nonce->length, nonce->data);\n\n  update(&ctx64, (nettle_hash_update_func *) umac64_update, msg, length);\n\n  check_digest (\"umac64\", &ctx64, (nettle_hash_digest_func *) umac64_digest,\n\t\tmsg, length, 8, ref64->data);\n\n  umac96_set_key (&ctx96, key->data);\n  umac96_set_nonce (&ctx96, nonce->length, nonce->data);\n\n  update(&ctx96, (nettle_hash_update_func *) umac96_update, msg, length);\n\n  check_digest (\"umac96\", &ctx96, (nettle_hash_digest_func *) umac96_digest,\n\t\tmsg, length, 12, ref128->data);\n\n  umac128_set_key (&ctx128, key->data);\n  umac128_set_nonce (&ctx128, nonce->length, nonce->data);\n\n  update(&ctx128, (nettle_hash_update_func *) umac128_update, msg, length);\n\n  check_digest (\"umac128\", &ctx128, (nettle_hash_digest_func *) umac128_digest,\n\t\tmsg, length, 16, ref128->data);\n}",
      "lines": 51,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_align": {
      "start_point": [
        89,
        0
      ],
      "end_point": [
        154,
        1
      ],
      "content": "static void\ntest_align(const struct tstring *key,\n\t   const struct tstring *nonce,\n\t   const struct tstring *msg,\n\t   size_t length,\n\t   const struct tstring *ref32,\n\t   const struct tstring *ref64,\n\t   const struct tstring *ref128)\n{\n  uint8_t *buffer = xalloc(length + 16);\n  unsigned offset;\n  for (offset = 0; offset < 16; offset++)\n    {\n      struct umac32_ctx ctx32;\n      struct umac64_ctx ctx64;\n      struct umac96_ctx ctx96;\n      struct umac128_ctx ctx128;\n\n      uint8_t *input;\n      size_t i;\n\n      memset(buffer, 17, length + 16);\n      input = buffer + offset;\n\n      for (i = 0; i + msg->length < length; i += msg->length)\n\tmemcpy (input + i, msg->data, msg->length);\n      memcpy (input + i, msg->data, length - i);\n\n      umac32_set_key (&ctx32, key->data);\n      umac32_set_nonce (&ctx32, nonce->length, nonce->data);\n\n      umac32_update(&ctx32, length, input);\n\n      check_digest (\"umac32 (alignment)\",\n\t\t    &ctx32, (nettle_hash_digest_func *) umac32_digest,\n\t\t    msg, length, 4, ref32->data);\n\n      umac64_set_key (&ctx64, key->data);\n      umac64_set_nonce (&ctx64, nonce->length, nonce->data);\n\n      umac64_update(&ctx64, length, input);\n\n      check_digest (\"umac64 (alignment)\",\n\t\t    &ctx64, (nettle_hash_digest_func *) umac64_digest,\n\t\t    msg, length, 8, ref64->data);\n\n      umac96_set_key (&ctx96, key->data);\n      umac96_set_nonce (&ctx96, nonce->length, nonce->data);\n\n      umac96_update(&ctx96, length, input);\n\n      check_digest (\"umac96 (alignment)\",\n\t\t    &ctx96, (nettle_hash_digest_func *) umac96_digest,\n\t\t    msg, length, 12, ref128->data);\n\n      umac128_set_key (&ctx128, key->data);\n      umac128_set_nonce (&ctx128, nonce->length, nonce->data);\n\n      umac128_update(&ctx128, length, input);\n\n      check_digest (\"umac128 (alignment)\",\n\t\t    &ctx128, (nettle_hash_digest_func *) umac128_digest,\n\t\t    msg, length, 16, ref128->data);\n    }\n  free (buffer);\n}",
      "lines": 66,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_incr": {
      "start_point": [
        156,
        0
      ],
      "end_point": [
        210,
        1
      ],
      "content": "static void\ntest_incr (const struct tstring *key,\n\t   const struct tstring *nonce,\n\t   unsigned count,\n\t   const struct tstring *msg,\n\t   const struct tstring *ref32,\n\t   const struct tstring *ref64,\n\t   const struct tstring *ref128)\n{\n  struct umac32_ctx ctx32;\n  struct umac64_ctx ctx64;\n  struct umac96_ctx ctx96;\n  struct umac128_ctx ctx128;\n\n  unsigned i;\n\n  ASSERT (key->length == UMAC_KEY_SIZE);\n  ASSERT (ref32->length == 4 * count);\n  ASSERT (ref64->length == 8 * count);\n  ASSERT (ref128->length == 16 * count);\n  umac32_set_key (&ctx32, key->data);\n  umac64_set_key (&ctx64, key->data);\n  umac96_set_key (&ctx96, key->data);\n  umac128_set_key (&ctx128, key->data);\n  if (nonce)\n    {\n      umac32_set_nonce (&ctx32, nonce->length, nonce->data);\n      umac64_set_nonce (&ctx64, nonce->length, nonce->data);\n      umac96_set_nonce (&ctx96, nonce->length, nonce->data);\n      umac128_set_nonce (&ctx128, nonce->length, nonce->data);\n    }\n  for (i = 0; i < count; i++)\n    {\n      umac32_update (&ctx32, msg->length, msg->data);\n      check_digest (\"umac32 incr\",\n\t\t    &ctx32, (nettle_hash_digest_func *) umac32_digest,\n\t\t    msg, i, 4, ref32->data + 4*i);\n\n      umac64_update (&ctx64, msg->length, msg->data);\n      check_digest (\"umac64 incr\",\n\t\t    &ctx64, (nettle_hash_digest_func *) umac64_digest,\n\t\t    msg, i, 8, ref64->data + 8*i);\n\n      umac96_update (&ctx96, msg->length, msg->data);\n      check_digest (\"umac96 incr\",\n\t\t    &ctx96, (nettle_hash_digest_func *) umac96_digest,\n\t\t    msg, i, 12, ref128->data + 16*i);\n\n      umac128_update (&ctx128, msg->length, msg->data);\n      check_digest (\"umac128 incr\",\n\t\t    &ctx128, (nettle_hash_digest_func *) umac128_digest,\n\t\t    msg, i, 16, ref128->data + 16*i);\n\n    }\n}",
      "lines": 55,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "test_main": {
      "start_point": [
        212,
        0
      ],
      "end_point": [
        468,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  /* From RFC 4418 (except that it lacks the last 32 bits of 128-bit\n     tags) */\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"\"), 0,\n\t     SHEX(\"113145FB\"),\n\t     SHEX(\"6E155FAD26900BE1\"),\n\t     SHEX(\"32fedb100c79ad58f07ff7643cc60465\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"a\"), 3,\n\t     SHEX(\"3B91D102\"),\n\t     SHEX(\"44B5CB542F220104\"),\n\t     SHEX(\"185e4fe905cba7bd85e4c2dc3d117d8d\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"a\"), 1<<10,\n\t     SHEX(\"599B350B\"),\n\t     SHEX(\"26BF2F5D60118BD9\"),\n\t     SHEX(\"7a54abe04af82d60fb298c3cbd195bcb\"));\n\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"aaaaaaaa\"), 1<<15,\n\t     SHEX(\"58DCF532\"),\n\t     SHEX(\"27F8EF643B0D118D\"),\n\t     SHEX(\"7b136bd911e4b734286ef2be501f2c3c\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"aaaaaaaa\"), 1<<20,\n\t     SHEX(\"DB6364D1\"),\n\t     SHEX(\"A4477E87E9F55853\"),\n\t     SHEX(\"f8acfa3ac31cfeea047f7b115b03bef5\"));\n  /* Needs POLY128 */\n  /* For the 'a' * 2^25 testcase, see errata\n     http://fastcrypto.org/umac/rfc4418.errata.txt */\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA (\"bcdefghi\"),\n\t     SDATA (\"aaaaaaaa\"), 1<<25,\n\t     SHEX(\"85EE5CAE\"),\n\t     SHEX(\"FACA46F856E9B45F\"),\n\t     SHEX(\"a621c2457c0012e64f3fdae9e7e1870c\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA (\"bcdefghi\"),\n\t     SDATA (\"abc\"), 3,\n\t     SHEX(\"ABF3A3A0\"),\n\t     SHEX(\"D4D7B9F6BD4FBFCF\"),\n\t     SHEX(\"883c3d4b97a61976ffcf232308cba5a5\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA (\"bcdefghi\"),\n\t     SDATA (\"abc\"), 1500,\n\t     SHEX(\"ABEB3C8B\"),\n\t     SHEX(\"D4CF26DDEFD5C01A\"),\n\t     SHEX(\"8824a260c53c66a36c9260a62cb83aa1\"));\n\n  test_incr (SDATA(\"abcdefghijklmnop\"), NULL, 6,\n\t     SDATA(\"zero\"),\n\t     SHEX(\"a0e94011 8c6fea51 6d897143 db1b28c5 a75e23b7 44ea26be\"),\n\t     SHEX(\"a0e940111c9c2cd5 6d8971434be8ee41 c9c9aef87e2be502\"\n\t\t  \"a0a112b593656107 a75e23b7d419e03a 950526f26a8cc07a\"),\n\t     SHEX(\"a0e940111c9c2cd5fa59090e3ac2061f\"\n\t\t  \"cbbf18b799fd0f4afb9216e52a89f247\"\n\t\t  \"c9c9aef87e2be50237716af8e24f8959\"\n\t\t  \"d6e96ef461f54d1c85aa66cbd76ca336\"\n\t\t  \"a75e23b7d419e03a02d55ebf1ba62824\"\n\t\t  \"2e63031d182a59b84f148d9a91de70a3\"));\n\n  test_incr (SDATA(\"abcdefghijklmnop\"), SDATA(\"a\"), 5,\n\t     SDATA(\"nonce-a\"),\n\t     SHEX(\"81b4ac24 b7e8aad0 f70246fe 0595f0bf a8e9fe85\"),\n\t     SHEX(\"b7e8aad0da6e7f99 138814c6a03bdadf fb77dd1cd4c7074f\"\n\t\t  \"0595f0bf8585c7e2 817c0b7757cb60f7\"),\n\t     SHEX(\"d7604bffb5e368da5fe564da0068d2cc\"\n\t\t  \"138814c6a03bdadff7f1666e1bd881aa\"\n\t\t  \"86a016d9e67957c8ab5ebb78a673e4e9\"\n\t\t  \"0595f0bf8585c7e28dfab00598d4e612\"\n\t\t  \"3266ec16a9d85b4f0dc74ec8272238a9\"));\n\n  test_incr (SDATA(\"abcdefghijklmnop\"), SHEX(\"beafcafe\"), 5,\n\t     SDATA(\"nonce-beaf-cafe\"),\n\t     SHEX(\"f19d9dc1 4604a56a 4ba9420e da86ff71 77facd79\"),\n\t     SHEX(\"9e878413aa079032 9cfd7af0bb107748 4ba9420e55b6ba13\"\n\t\t  \"77facd797b686e24 9000c0de4f5f7236\"),\n\t     SHEX(\"9e878413aa0790329604f3b6ae980e58\"\n\t\t  \"f2b2dd5dab08bb3bc5e9a83e1b4ab2e7\"\n\t\t  \"4ba9420e55b6ba137d03443f6ee01734\"\n\t\t  \"2721ca2e1bcda53a54ae65e0da139c0d\"\n\t\t  \"9000c0de4f5f7236b81ae1a52e78a821\"));\n\n  /* Tests exercising various sizes of nonce and data: All nonce\n     lengths from 1 to 16 bytes. Data sizes chosen for testing for\n     various off-by-one errors,\n\n       0, 1, 2, 3, 4,\n       1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027,\n       2046, 2047, 2048, 2049, 2050\n       16777212, 16777213, 16777214, 16777215, 16777216, 16777217,\n       16778239, 16778240, 16778241, 16778242, 16778243, 16778244\n  */\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"b\"),\n\t     SDATA(\"defdefdefdefdef\"), 0,\n\t     SHEX(\"3a58486b\"),\n\t     SHEX(\"9e38f67da91a08d9\"),\n\t     SHEX(\"9e38f67da91a08d9c980f4db4089c877\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bc\"),\n\t     SDATA(\"defdefdefdefdef\"), 1,\n\t     SHEX(\"d86b1512\"),\n\t     SHEX(\"fb0e207971b8e66a\"),\n\t     SHEX(\"ef406c2ec70d0222f59e860eabb79ed0\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcd\"),\n\t     SDATA(\"defdefdefdefdef\"), 2,\n\t     SHEX(\"1ae6e02d\"),\n\t     SHEX(\"1ae6e02d73aa9ab2\"),\n\t     SHEX(\"1ae6e02d73aa9ab2a27fb89e014dc07b\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcde\"),\n\t     SDATA(\"defdefdefdefdef\"), 3,\n\t     SHEX(\"e8c1eb59\"),\n\t     SHEX(\"c81cf22342e84302\"),\n\t     SHEX(\"82626d0d575e01038e5e2cc6408216f5\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdef\"),\n\t     SDATA(\"defdefdefdefdef\"), 4,\n\t     SHEX(\"8950f0d3\"),\n\t     SHEX(\"aba003e7bd673cc3\"),\n\t     SHEX(\"aba003e7bd673cc368ba8513cecf2e7c\"));\n\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefg\"),\n\t     SDATA(\"defdefdefdefdef\"), 1020,\n\t     SHEX(\"7412167c\"),\n\t     SHEX(\"f98828a161bb4ae3\"),\n\t     SHEX(\"d8b4811f747d588d7a913360960de7cf\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefgh\"),\n\t     SDATA(\"defdefdefdefdef\"), 1021,\n\t     SHEX(\"2d54936b\"),\n\t     SHEX(\"2d54936be5bff72d\"),\n\t     SHEX(\"2d54936be5bff72d2e1052361163b474\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"defdefdefdefdef\"), 1022,\n\t     SHEX(\"53ca8dd2\"),\n\t     SHEX(\"2cee9784556387b3\"),\n\t     SHEX(\"700513397f8a210a98938d3e7ac3bd88\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghij\"),\n\t     SDATA(\"defdefdefdefdef\"), 1023,\n\t     SHEX(\"26cc58df\"),\n\t     SHEX(\"24ac4284ca371f42\"),\n\t     SHEX(\"24ac4284ca371f4280f60bd274633d67\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijk\"),\n\t     SDATA(\"defdefdefdefdef\"), 1024,\n\t     SHEX(\"3cada45a\"),\n\t     SHEX(\"64c6a0fd14615a76\"),\n\t     SHEX(\"abc223116cedd2db5af365e641a97539\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijkl\"),\n\t     SDATA(\"defdefdefdefdef\"), 1025,\n\t     SHEX(\"93251e18\"),\n\t     SHEX(\"93251e18e56bbdc4\"),\n\t     SHEX(\"93251e18e56bbdc457de556f95c59931\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklm\"),\n\t     SDATA(\"defdefdefdefdef\"), 1026,\n\t     SHEX(\"24a4c3ab\"),\n\t     SHEX(\"5d98bd8dfaf16352\"),\n\t     SHEX(\"c1298672e52386753383a15ed58c0e42\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmn\"),\n\t     SDATA(\"defdefdefdefdef\"), 1027,\n\t     SHEX(\"e7e98945\"),\n\t     SHEX(\"5b0557c9fdcf661b\"),\n\t     SHEX(\"5b0557c9fdcf661b1758efc603516ebe\"));\n\n  /* Test varying the alignment of the buffer eventually passed to\n     _umac_nh and _umac_nh_n. */\n  test_align (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijk\"),\n\t      SDATA(\"defdefdefdefdef\"), 1024,\n\t      SHEX(\"3cada45a\"),\n\t      SHEX(\"64c6a0fd14615a76\"),\n\t      SHEX(\"abc223116cedd2db5af365e641a97539\"));\n\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmno\"),\n\t     SDATA(\"defdefdefdefdef\"), 2046,\n\t     SHEX(\"e12ddc9f\"),\n\t     SHEX(\"65e85d47447c2277\"),\n\t     SHEX(\"16bb5183017826ed47c9995c1e5834f3\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmnop\"),\n\t     SDATA(\"defdefdefdefdef\"), 2047,\n\t     SHEX(\"34d723a6\"),\n\t     SHEX(\"34d723a6cb1676d3\"),\n\t     SHEX(\"34d723a6cb1676d3547a5064dc5b0a37\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmnopq\"),\n\t     SDATA(\"defdefdefdefdef\"), 2048,\n\t     SHEX(\"21fd8802\"),\n\t     SHEX(\"3968d5d0af147884\"),\n\t     SHEX(\"84565620def1e3a614d274e87626f215\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"b\"),\n\t     SDATA(\"defdefdefdefdef\"), 2049,\n\t     SHEX(\"097e5abd\"),\n\t     SHEX(\"ad1ee4ab606061c5\"),\n\t     SHEX(\"ad1ee4ab606061c55e0d2ecfee59940a\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bc\"),\n\t     SDATA(\"defdefdefdefdef\"), 2050,\n\t     SHEX(\"a03a7fe9\"),\n\t     SHEX(\"835f4a8242100055\"),\n\t     SHEX(\"971106d5f4a5e41dce40a91704cfe1f3\"));\n\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcd\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777212,\n\t     SHEX(\"7ef41cf3\"),\n\t     SHEX(\"7ef41cf351960aaf\"),\n\t     SHEX(\"7ef41cf351960aaf729bb19fcee7d8c4\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcde\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777213,\n\t     SHEX(\"8bf81932\"),\n\t     SHEX(\"ab250048807ff640\"),\n\t     SHEX(\"e15b9f6695c9b441de035e9b10b8ac32\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdef\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777214,\n\t     SHEX(\"ddb2f0ab\"),\n\t     SHEX(\"ff42039fcfe1248e\"),\n\t     SHEX(\"ff42039fcfe1248e36c19efed14d7140\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefg\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777215,\n\t     SHEX(\"e67ad507\"),\n\t     SHEX(\"6be0ebda623d76df\"),\n\t     SHEX(\"4adc426477fb64b1ce5afd76d505f048\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefgh\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777216,\n\t     SHEX(\"42d8562a\"),\n\t     SHEX(\"42d8562a224a9e9a\"),\n\t     SHEX(\"42d8562a224a9e9a75c2f85d39462d07\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghi\"),\n\t     SDATA(\"defdefdefdefdef\"), 16777217,\n\t     SHEX(\"486b138d\"),\n\t     SHEX(\"374f09dbb0b84b88\"),\n\t     SHEX(\"6ba48d669a51ed3195ebc2aa562ee71b\"));\n\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghij\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778239,\n\t     SHEX(\"850cb2c5\"),\n\t     SHEX(\"876ca89ed045777b\"),\n\t     SHEX(\"876ca89ed045777bf7efa7934e1758c2\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijk\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778240,\n\t     SHEX(\"b9fc4f81\"),\n\t     SHEX(\"e1974b26fb35f2c6\"),\n\t     SHEX(\"2e93c8ca83b97a6b1a21082e2a4c540d\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijkl\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778241,\n\t     SHEX(\"ffced8f2\"),\n\t     SHEX(\"ffced8f2494d85bf\"),\n\t     SHEX(\"ffced8f2494d85bf0cb39408ddfe0295\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklm\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778242,\n\t     SHEX(\"1c99c5fb\"),\n\t     SHEX(\"65a5bbdda3b85368\"),\n\t     SHEX(\"f9148022bc6ab64f019e9db83704c17b\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmn\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778243,\n\t     SHEX(\"ec304be9\"),\n\t     SHEX(\"50dc9565fbfc4884\"),\n\t     SHEX(\" 50dc9565fbfc48844a4be34403804605\"));\n  test_umac (SDATA(\"abcdefghijklmnop\"), SDATA(\"bcdefghijklmno\"),\n\t     SDATA(\"defdefdefdefdef\"), 16778244,\n\t     SHEX(\"8034e26f\"),\n\t     SHEX(\"04f163b7c2d5d849\"),\n\t     SHEX(\"77a26f7387d1dcd39378a3220652cff7\"));\n}",
      "lines": 257,
      "depth": 10,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/version-test.c": {
    "test_main": {
      "start_point": [
        33,
        0
      ],
      "end_point": [
        40,
        1
      ],
      "content": "void\ntest_main (void)\n{\n  /* This also checks that we don't by accident link with a different\n     version of nettle which is installed on the system. */\n  ASSERT (nettle_version_major () == NETTLE_VERSION_MAJOR);\n  ASSERT (nettle_version_minor () == NETTLE_VERSION_MINOR);\n}",
      "lines": 8,
      "depth": 9,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/testsuite/yarrow-test.c": {
    "get_event": {
      "start_point": [
        16,
        0
      ],
      "end_point": [
        36,
        1
      ],
      "content": "static int\nget_event(FILE *f, struct sha256_ctx *hash,\n          unsigned *key, unsigned *time)\n{\n  static int t = 0;\n  uint8_t buf[1];\n  \n  int c = getc(f);\n  if (c == EOF)\n    return 0;\n\n  buf[0] = c;\n  sha256_update(hash, sizeof(buf), buf);\n    \n  *key = c;\n\n  t += (knuth_lfib_get(&lfib) % 10000);\n  *time = t;\n\n  return 1;\n}",
      "lines": 21,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "open_file": {
      "start_point": [
        38,
        0
      ],
      "end_point": [
        58,
        1
      ],
      "content": "static FILE *\nopen_file(const char *name)\n{\n  /* Tries opening the file in $srcdir, if set, otherwise the current\n   * working directory */\n\n  const char *srcdir = getenv(\"srcdir\");\n  if (srcdir && srcdir[0])\n    {\n      FILE *f;\n      char *buf = xalloc(strlen(name) + strlen(srcdir) + 10);\n      sprintf(buf, \"%s/%s\", srcdir, name);\n\n      f = fopen(buf, \"r\");\n      free(buf);\n      return f;\n    }\n\n  /* Opens the file in text mode. */\n  return fopen(name, \"r\");\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "FILE",
        "*\nopen_file(const char *name)",
        "*"
      ]
    },
    "test_main": {
      "start_point": [
        60,
        0
      ],
      "end_point": [
        211,
        1
      ],
      "content": "void\ntest_main(void)\n{\n  FILE *input;\n  \n  struct yarrow256_ctx yarrow;\n  struct yarrow_key_event_ctx estimator;\n\n  struct yarrow_source sources[2];\n\n  struct sha256_ctx output_hash;\n  struct sha256_ctx input_hash;\n  uint8_t digest[SHA256_DIGEST_SIZE];\n\n  uint8_t seed_file[YARROW256_SEED_FILE_SIZE];\n\n  const uint8_t *expected_output\n    = H(\"dd304aacac3dc95e 70d684a642967c89\"\n\t\"58501f7c8eb88b79 43b2ffccde6f0f79\");\n\n  const uint8_t *expected_input\n    = H(\"e0596cf006025506 65d1195f32a87e4a\"\n\t\"5c354910dfbd0a31 e2105b262f5ce3d8\");\n\n  const uint8_t *expected_seed_file\n    = H(\"b03518f32b1084dd 983e6a445d47bb6f\"\n\t\"13bb7b998740d570 503d6aaa62e28901\");\n  \n  unsigned c; unsigned t;\n\n  unsigned processed = 0;\n  unsigned output = 0;\n\n  unsigned i;\n  \n  static const char unsigned zeroes[100];\n\n  yarrow256_init(&yarrow, 2, sources);\n  \n  yarrow_key_event_init(&estimator);\n  sha256_init(&input_hash);\n  sha256_init(&output_hash);\n\n  knuth_lfib_init(&lfib, 31416);\n\n  /* Fake input to source 0 */\n  yarrow256_update(&yarrow, 0, 200, sizeof(zeroes), zeroes);\n\n  if (verbose)\n    printf(\"source 0 entropy: %d\\n\",\n\t   sources[0].estimate[YARROW_SLOW]);\n  \n  ASSERT(!yarrow256_is_seeded(&yarrow));\n\n  input = open_file(\"gold-bug.txt\");\n\n  if (!input)\n    {\n      fprintf(stderr, \"Couldn't open `gold-bug.txt', errno = %d\\n\",\n              errno);\n      FAIL();\n    }\n  \n  while (get_event(input, &input_hash, &c, &t))\n    {\n      uint8_t buf[8];\n\n      processed++;\n      \n      WRITE_UINT32(buf, c);\n      WRITE_UINT32(buf + 4, t);\n      yarrow256_update(&yarrow, 1,\n                       yarrow_key_event_estimate(&estimator, c, t),\n                       sizeof(buf), buf);\n\n      if (yarrow256_is_seeded(&yarrow))\n        {\n          static const unsigned sizes[4] = { 1, 16, 500, 37 };\n          unsigned size = sizes[processed % 4];\n          \n          uint8_t buf[500];\n\n          if (verbose && !output)\n            printf(\"Generator was seeded after %d events\\n\",\n\t\t   processed);\n          \n          yarrow256_random(&yarrow, size, buf);\n\n          sha256_update(&output_hash, size, buf);\n\n\t  if (verbose)\n\t    {\n\t      printf(\"%02x \", buf[0]);\n\t      if (! (processed % 16))\n\t\tprintf(\"\\n\");\n\t    }\n          output += size;\n        }\n    }\n\n  fclose(input);\n\n  if (verbose)\n    {\n      printf(\"\\n\");\n      \n      for (i = 0; i<2; i++)\n\tprintf(\"source %d, (fast, slow) entropy: (%d, %d)\\n\",\n\t       i,\n\t       sources[i].estimate[YARROW_FAST],\n\t       sources[i].estimate[YARROW_SLOW]); \n      \n      printf(\"Processed input: %d octets\\n\", processed);\n      printf(\"         sha256:\");\n    }\n\n  sha256_digest(&input_hash, sizeof(digest), digest);\n\n  if (verbose)\n    {\n      print_hex(sizeof(digest), digest);\n      printf(\"\\n\");\n    }\n  \n  ASSERT (memcmp(digest, expected_input, sizeof(digest)) == 0);\n\n  yarrow256_random(&yarrow, sizeof(seed_file), seed_file);\n  if (verbose)\n    {\n      printf(\"New seed file: \");\n      print_hex(sizeof(seed_file), seed_file);\n      printf(\"\\n\");\n    }\n\n  ASSERT (memcmp(seed_file, expected_seed_file, sizeof(seed_file)) == 0);\n  \n  if (verbose)\n    {\n      printf(\"Generated output: %d octets\\n\", output);\n      printf(\"          sha256:\");\n    }\n  \n  sha256_digest(&output_hash, sizeof(digest), digest);\n\n  if (verbose)\n    {\n      print_hex(sizeof(digest), digest);\n      printf(\"\\n\");\n    }\n  \n  ASSERT (memcmp(digest, expected_output, sizeof(digest)) == 0);\n}",
      "lines": 152,
      "depth": 14,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/input.c": {
    "sexp_input_init": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        47,
        1
      ],
      "content": "void\nsexp_input_init(struct sexp_input *input, FILE *f)\n{\n  input->f = f;\n  input->coding = NULL;\n}",
      "lines": 6,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sexp_get_raw_char": {
      "start_point": [
        49,
        0
      ],
      "end_point": [
        66,
        1
      ],
      "content": "static void\nsexp_get_raw_char(struct sexp_input *input)\n{\n  int c = getc(input->f);\n  \n  if (c < 0)\n    {\n      if (ferror(input->f))\n\tdie(\"Read error: %s\\n\", strerror(errno));\n      \n      input->ctype = SEXP_EOF_CHAR;\n    }\n  else\n    {\n      input->ctype = SEXP_NORMAL_CHAR;\n      input->c = c;\n    }\n}",
      "lines": 18,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_char": {
      "start_point": [
        68,
        0
      ],
      "end_point": [
        100,
        1
      ],
      "content": "void\nsexp_get_char(struct sexp_input *input)\n{\n  if (input->coding)\n    for (;;)\n      {\n\tsize_t done;\n\n\tsexp_get_raw_char(input);\n\tif (input->ctype == SEXP_EOF_CHAR)\n\t  die(\"Unexpected end of file in coded data.\\n\");\n\n\tif (input->c == input->terminator)\n\t  {\n\t    input->ctype = SEXP_END_CHAR;\n\t    return;\n\t  }\n\n\tdone = 1;\n\n\t/* Decodes in place. Should always work, when we decode one\n\t * character at a time. */\n\tif (!input->coding->decode_update(&input->state,\n\t\t\t\t\t  &done, &input->c,\n\t\t\t\t\t  1, (const char*) &input->c))\n\t  die(\"Invalid coded data.\\n\");\n\t\n\tif (done)\n\t  return;\n      }\n  else\n    sexp_get_raw_char(input);\n}",
      "lines": 33,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sexp_next_char": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        110,
        1
      ],
      "content": "static uint8_t\nsexp_next_char(struct sexp_input *input)\n{\n  sexp_get_char(input);\n  if (input->ctype != SEXP_NORMAL_CHAR)\n    die(\"Unexpected end of file.\\n\");\n\n  return input->c;\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "uint8_t"
      ]
    },
    "sexp_push_char": {
      "start_point": [
        112,
        0
      ],
      "end_point": [
        120,
        1
      ],
      "content": "static void\nsexp_push_char(struct sexp_input *input,\n\t       struct nettle_buffer *string)\n{\n  assert(input->ctype == SEXP_NORMAL_CHAR);\n    \n  if (!NETTLE_BUFFER_PUTC(string, input->c))\n    die(\"Virtual memory exhasuted.\\n\");\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_input_start_coding": {
      "start_point": [
        122,
        0
      ],
      "end_point": [
        132,
        1
      ],
      "content": "static void\nsexp_input_start_coding(struct sexp_input *input,\n\t\t\tconst struct nettle_armor *coding,\n\t\t\tuint8_t terminator)\n{\n  assert(!input->coding);\n  \n  input->coding = coding;\n  input->coding->decode_init(&input->state);\n  input->terminator = terminator;\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_input_end_coding": {
      "start_point": [
        134,
        0
      ],
      "end_point": [
        143,
        1
      ],
      "content": "static void\nsexp_input_end_coding(struct sexp_input *input)\n{\n  assert(input->coding);\n\n  if (!input->coding->decode_final(&input->state))\n    die(\"Invalid coded data.\\n\");\n  \n  input->coding = NULL;\n}",
      "lines": 10,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_quoted_char": {
      "start_point": [
        147,
        0
      ],
      "end_point": [
        186,
        1
      ],
      "content": "static int\nsexp_get_quoted_char(struct sexp_input *input)\n{\n  sexp_next_char(input);\n\n  switch (input->c)\n    {\n    default:\n      return 1;\n    case '\\\"':\n      return 0;\n    case '\\\\':\n      sexp_next_char(input);\n\t\n      switch (input->c)\n\t{\n\tcase 'b': input->c = '\\b'; return 1;\n\tcase 't': input->c = '\\t'; return 1;\n\tcase 'n': input->c = '\\n'; return 1;\n\tcase 'f': input->c = '\\f'; return 1;\n\tcase 'r': input->c = '\\r'; return 1;\n\tcase '\\\\': input->c = '\\\\'; return 1;\n\tcase 'o':\n\tcase 'x':\n\t  /* FIXME: Not implemnted */\n\t  abort();\n\tcase '\\n':\n\t  if (sexp_next_char(input) == '\\r')\n\t    sexp_next_char(input);\n\n\t  break;\n\tcase '\\r':\n\t  if (sexp_next_char(input) == '\\n')\n\t    sexp_next_char(input);\n\n\t  break;\n\t}\n      return 1;\n    }\n}",
      "lines": 40,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "sexp_get_token_string": {
      "start_point": [
        188,
        0
      ],
      "end_point": [
        206,
        1
      ],
      "content": "static void\nsexp_get_token_string(struct sexp_input *input,\n\t\t      struct nettle_buffer *string)\n{\n  assert(!input->coding);\n  assert(input->ctype == SEXP_NORMAL_CHAR);\n  \n  if (!TOKEN_CHAR(input->c))\n    die(\"Invalid token.\\n\");\n\n  do\n    {\n      sexp_push_char(input, string);\n      sexp_get_char(input);\n    }\n  while (input->ctype == SEXP_NORMAL_CHAR && TOKEN_CHAR(input->c));\n  \n  assert (string->size);\n}",
      "lines": 19,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_string": {
      "start_point": [
        208,
        0
      ],
      "end_point": [
        255,
        1
      ],
      "content": "static void\nsexp_get_string(struct sexp_input *input,\n\t\tstruct nettle_buffer *string)\n{\n  nettle_buffer_reset(string);\n  input->token = SEXP_STRING;\n  \n  switch (input->c)\n    {\n    case '\\\"':\n      while (sexp_get_quoted_char(input))\n\tsexp_push_char(input, string);\n      \n      sexp_get_char(input);\n      break;\n      \n    case '#':\n      sexp_input_start_coding(input, &nettle_base16, '#');\n      goto decode;\n\n    case '|':\n      sexp_input_start_coding(input, &nettle_base64, '|');\n\n    decode:\n      for (;;)\n\t{\n\t  sexp_get_char(input);\n\t  switch (input->ctype)\n\t    {\n\t    case SEXP_NORMAL_CHAR:\n\t      sexp_push_char(input, string);\n\t      break;\n\t    case SEXP_EOF_CHAR:\n\t      die(\"Unexpected end of file in coded string.\\n\");\n\t    case SEXP_END_CHAR:\n\t      sexp_input_end_coding(input);\n\t      sexp_get_char(input);\n\t      return;\n\t    }\n\t}\n\n      break;\n\n    default:\n      sexp_get_token_string(input, string);\n      break;\n    }\n}",
      "lines": 48,
      "depth": 16,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_string_length": {
      "start_point": [
        257,
        0
      ],
      "end_point": [
        341,
        1
      ],
      "content": "static void\nsexp_get_string_length(struct sexp_input *input, enum sexp_mode mode,\n\t\t       struct nettle_buffer *string)\n{\n  unsigned length;\n\n  nettle_buffer_reset(string);\n  input->token = SEXP_STRING;\n  \n  length = input->c - '0';\n  \n  if (!length)\n    /* There must be no more digits */\n    sexp_next_char(input);\n\n  else\n    {\n      assert(length < 10);\n      /* Get rest of digits */\n      for (;;)\n\t{\n\t  sexp_next_char(input);\n\t  \n\t  if (input->c < '0' || input->c > '9')\n\t    break;\n\t  \n\t  /* FIXME: Check for overflow? */\n\t  length = length * 10 + input->c - '0';\n\t}\n    }\n\n  if (input->c == ':')\n    /* Verbatim */\n    for (; length; length--)\n      {\n\tsexp_next_char(input);\n\tsexp_push_char(input, string);\n      }\n\n  else if (mode != SEXP_ADVANCED)\n    die(\"Encountered advanced string in canonical mode.\\n\");\n\n  else\n    switch(input->c)\n      {\n      case '\"':\n\tfor (; length; length--)\n\t  if (sexp_get_quoted_char(input))\n\t    sexp_push_char(input, string);\n\t  else\n\t    die(\"Unexpected end of string.\\n\");\n      \n\tif (sexp_get_quoted_char(input))\n\t  die(\"Quoted string longer than expected.\\n\");\n\n\tbreak;\n      \n      case '#':\n\tsexp_input_start_coding(input, &nettle_base16, '#');\n\tgoto decode;\n\n      case '|':\n\tsexp_input_start_coding(input, &nettle_base64, '|');\n\n      decode:\n\tfor (; length; length--)\n\t  {\n\t    sexp_next_char(input);\n\t    sexp_push_char(input, string);\n\t  }\n\tsexp_get_char(input);\n\tif (input->ctype != SEXP_END_CHAR)\n\t  die(\"Coded string too long.\\n\");\n\n\tsexp_input_end_coding(input);\n      \n\tbreak;\n      \n      default:\n\tdie(\"Invalid string.\\n\");\n      }\n\n  /* Skip the ending character. */\n  sexp_get_char(input);  \n}",
      "lines": 85,
      "depth": 14,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_comment": {
      "start_point": [
        343,
        0
      ],
      "end_point": [
        359,
        1
      ],
      "content": "static void\nsexp_get_comment(struct sexp_input *input, struct nettle_buffer *string)\n{\n  nettle_buffer_reset(string);\n\n  assert(input->ctype == SEXP_NORMAL_CHAR);\n  assert(input->c == ';');\n\n  do\n    {\n      sexp_push_char(input, string);\n      sexp_get_raw_char(input);\n    }\n  while (input->ctype == SEXP_NORMAL_CHAR && input->c != '\\n');\n\n  input->token = SEXP_COMMENT;\n}",
      "lines": 17,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_get_token": {
      "start_point": [
        366,
        0
      ],
      "end_point": [
        448,
        1
      ],
      "content": "void\nsexp_get_token(struct sexp_input *input, enum sexp_mode mode,\n\t       struct nettle_buffer *string)\n{\n  for(;;)\n    switch(input->ctype)\n      {\n      case SEXP_EOF_CHAR:\n\tinput->token = SEXP_EOF;\n\treturn;\n\n      case SEXP_END_CHAR:\n\tinput->token = SEXP_CODING_END;\n\tsexp_input_end_coding(input);\n\tsexp_get_char(input);\n\treturn;\n\n      case SEXP_NORMAL_CHAR:\n\tswitch(input->c)\n\t  {\n\t  case '0': case '1': case '2': case '3': case '4':\n\t  case '5': case '6': case '7': case '8': case '9':\n\t    sexp_get_string_length(input, mode, string);\n\t    return;\n\t  \n\t  case '(':\n\t    input->token = SEXP_LIST_START;\n\t    sexp_get_char(input);\n\t    return;\n\t  \n\t  case ')':\n\t    input->token = SEXP_LIST_END;\n\t    sexp_get_char(input);\n\t    return;\n\n\t  case '[':\n\t    input->token = SEXP_DISPLAY_START;\n\t    sexp_get_char(input);\n\t    return;\n\n\t  case ']':\n\t    input->token = SEXP_DISPLAY_END;\n\t    sexp_get_char(input);\n\t    return;\n\n\t  case '{':\n\t    if (mode == SEXP_CANONICAL)\n\t      die(\"Unexpected transport data in canonical mode.\\n\");\n\t    \n\t    sexp_input_start_coding(input, &nettle_base64, '}');\n\t    sexp_get_char(input);\n\n\t    input->token = SEXP_TRANSPORT_START;\n\t    \n\t    return;\n\t  \n\t  case ' ':  /* SPC, TAB, LF, CR */\n\t  case '\\t':\n\t  case '\\n':\n\t  case '\\r':\n\t    if (mode == SEXP_CANONICAL)\n\t      die(\"Whitespace encountered in canonical mode.\\n\");\n\n\t    sexp_get_char(input);\n\t    break;\n\n\t  case ';': /* Comments */\n\t    if (mode == SEXP_CANONICAL)\n\t      die(\"Comment encountered in canonical mode.\\n\");\n\n\t    sexp_get_comment(input, string);\n\t    return;\n\t  \n\t  default:\n\t    /* Ought to be a string */\n\t    if (mode != SEXP_ADVANCED)\n\t      die(\"Encountered advanced string in canonical mode.\\n\");\n\n\t    sexp_get_string(input, string);\n\t    return;\n\t  }\n      }\n}",
      "lines": 83,
      "depth": 15,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/input.h": {},
  "nettle/nettle-3.4.1/tools/misc.c": {
    "die": {
      "start_point": [
        41,
        0
      ],
      "end_point": [
        50,
        1
      ],
      "content": "void\ndie(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n\n  exit(EXIT_FAILURE);\n}",
      "lines": 10,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "werror": {
      "start_point": [
        52,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nwerror(const char *format, ...)\n{\n  va_list args;\n  va_start(args, format);\n  vfprintf(stderr, format, args);\n  va_end(args);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "xalloc": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        72,
        1
      ],
      "content": "void *\nxalloc(size_t size)\n{\n  void *p = malloc(size);\n  if (!p)\n    {\n      fprintf(stderr, \"Virtual memory exhausted.\\n\");\n      abort();\n    }\n\n  return p;\n}",
      "lines": 12,
      "depth": 9,
      "decorators": [
        "void",
        "*\nxalloc(size_t size)",
        "*"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/misc.h": {},
  "nettle/nettle-3.4.1/tools/nettle-hash.c": {
    "list_algorithms": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        60,
        1
      ],
      "content": "static void\nlist_algorithms (void)\n{\n  unsigned i;\n  const struct nettle_hash *alg;\n  printf (\"%10s digestsize (internal block size, context size), in units of octets\\n\", \"name\");\n\n  for (i = 0; (alg = nettle_hashes[i]); i++)\n    printf (\"%10s %d (%d, %d)\\n\",\n\t    alg->name, alg->digest_size, alg->block_size, alg->context_size);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "hash_file": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        77,
        1
      ],
      "content": "static int\nhash_file(const struct nettle_hash *hash, void *ctx, FILE *f)\n{\n  for (;;)\n    {\n      uint8_t buffer[BUFSIZE];\n      size_t res = fread(buffer, 1, sizeof(buffer), f);\n      if (ferror(f))\n\treturn 0;\n      \n      hash->update(ctx, res, buffer);\n      if (feof(f))\n\treturn 1;\n    }\n}",
      "lines": 15,
      "depth": 11,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "digest_file": {
      "start_point": [
        79,
        0
      ],
      "end_point": [
        121,
        1
      ],
      "content": "static int\ndigest_file(const struct nettle_hash *alg,\n\t    unsigned digest_length, int raw,\n\t    FILE *f)\n{\n  void *ctx;\n  uint8_t *digest;\n  ctx = xalloc(alg->context_size);\n\n  alg->init(ctx);\n\n  if (!hash_file (alg, ctx, f))\n    {\n      free (ctx);\n      return 0;\n    }\n\n  digest = xalloc(digest_length);\n  alg->digest(ctx, digest_length, digest);\n  free(ctx);\n\n  if (raw)\n    fwrite (digest, digest_length, 1, stdout);\n\n  else\n    {\n      unsigned i;\n      char hex[BASE16_ENCODE_LENGTH(8) + 1];\n      for (i = 0; i + 8 < digest_length; i += 8)\n\t{\n\t  base16_encode_update(hex, 8, digest + i);\n\t  hex[BASE16_ENCODE_LENGTH(8)] = 0;\n\t  printf(\"%s \", hex);\n\t}\n      base16_encode_update(hex, digest_length - i, digest + i);\n      hex[BASE16_ENCODE_LENGTH(digest_length - i)] = 0;\n      printf(\"%s %s\\n\", hex, alg->name);\n    }\n  \n  free(digest);\n\n  return 1;\n}",
      "lines": 43,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "usage": {
      "start_point": [
        123,
        0
      ],
      "end_point": [
        134,
        1
      ],
      "content": "static void\nusage (FILE *f)\n{\n  fprintf(f, \"Usage: nettle-hash -a ALGORITHM [OPTIONS] [FILE ...]\\n\"\n\t  \"Options:\\n\"\n\t  \"  --help              Show this help.\\n\"\n\t  \"  -V, --version       Show version information.\\n\"\n\t  \"  --list              List supported hash algorithms.\\n\"\n\t  \"  -a, --algorithm=ALG Hash algorithm to use.\\n\"\n\t  \"  -l, --length=LENGTH Desired digest length (octets)\\n\"\n\t  \"  --raw               Raw binary output.\\n\");\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        235,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  const char *alg_name = NULL;\n  const struct nettle_hash *alg;\n  unsigned length = 0;\n  int raw = 0;\n  int c;\n\n  enum { OPT_HELP = 0x300, OPT_RAW, OPT_LIST };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"version\", no_argument, NULL, 'V' },\n      { \"algorithm\", required_argument, NULL, 'a' },\n      { \"length\", required_argument, NULL, 'l' },\n      { \"list\", no_argument, NULL, OPT_LIST },\n      { \"raw\", no_argument, NULL, OPT_RAW },\n\n      { NULL, 0, NULL, 0 }\n    };\n\n  while ( (c = getopt_long(argc, argv, \"Va:l:\", options, NULL)) != -1)\n    switch (c)\n      {\n      default:\n\tabort();\n      case '?':\n\tusage (stderr);\n\treturn EXIT_FAILURE;\n      case OPT_HELP:\n\tusage (stdout);\n\treturn EXIT_SUCCESS;\n      case 'V':\n\tprintf(\"nettle-hash (\" PACKAGE_STRING \")\\n\");\n\treturn EXIT_SUCCESS;\n      case 'a':\n\talg_name = optarg;\n\tbreak;\n      case 'l':\n\t{\n\t  int arg;\n\t  arg = atoi (optarg);\n\t  if (arg <= 0)\n\t    die (\"Invalid length argument: `%s'\\n\", optarg);\n\t  length = arg;\n\t}\n\tbreak;\n      case OPT_RAW:\n\traw = 1;\n\tbreak;\n      case OPT_LIST:\n\tlist_algorithms();\n\treturn EXIT_SUCCESS;\n      }\n\n  if (!alg_name)\n    die(\"Algorithm argument (-a option) is mandatory.\\n\"\n\t\"See nettle-hash --help for further information.\\n\");\n      \n  alg = nettle_lookup_hash (alg_name);\n  if (!alg)\n    die(\"Hash algorithm `%s' not supported or .\\n\"\n\t\"Use nettle-hash --list to list available algorithms.\\n\",\n\talg_name);\n\n  if (length == 0)\n    length = alg->digest_size;\n  else if (length > alg->digest_size)\n    die (\"Length argument %d too large for selected algorithm.\\n\",\n\t length);\n    \n  argv += optind;\n  argc -= optind;\n\n  if (argc == 0)\n    digest_file (alg, length, raw, stdin);\n  else\n    {\n      int i;\n      for (i = 0; i < argc; i++)\n\t{\n\t  FILE *f = fopen (argv[i], \"rb\");\n\t  if (!f)\n\t    die (\"Cannot open `%s': %s\\n\", argv[i], STRERROR(errno));\n\t  printf(\"%s: \", argv[i]);\n\t  if (!digest_file (alg, length, raw, f))\n\t    die(\"Reading `%s' failed: %s\\n\", argv[i], STRERROR(errno));\n\t  fclose(f);\n\t}\n    }\n  if (fflush(stdout) != 0 )\n    die(\"Write failed: %s\\n\", STRERROR(errno));\n\n  return EXIT_SUCCESS;\n}",
      "lines": 97,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/nettle-lfib-stream.c": {
    "usage": {
      "start_point": [
        48,
        0
      ],
      "end_point": [
        52,
        1
      ],
      "content": "static void\nusage(void)\n{\n  fprintf(stderr, \"Usage: lfib-stream [SEED]\\n\");\n}",
      "lines": 5,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        54,
        0
      ],
      "end_point": [
        91,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct knuth_lfib_ctx ctx;\n  uint32_t seed;\n\n  if (argc == 1)\n    seed = time(NULL);\n\n  else if (argc == 2)\n    {\n      seed = atoi(argv[1]);\n      if (!seed)\n\t{\n\t  usage();\n\t  return EXIT_FAILURE;\n\t}\n    }\n  else\n    {\n      usage();\n      return EXIT_FAILURE;\n    }\n\n  knuth_lfib_init(&ctx, seed);\n\n  for (;;)\n    {\n      uint8_t buffer[BUFSIZE];\n      knuth_lfib_random(&ctx, sizeof(buffer), buffer);\n\n      if (fwrite(buffer, 1, sizeof(buffer), stdout) < sizeof(buffer)\n\t  || fflush(stdout) < 0)\n\treturn EXIT_FAILURE;\n    }\n\n  /* Not reached. This program is usually terminated by SIGPIPE */\n}",
      "lines": 38,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/nettle-pbkdf2.c": {
    "usage": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        62,
        1
      ],
      "content": "static void\nusage (FILE *f)\n{\n  fprintf(f, \"Usage: nettle-pbkdf2 [OPTIONS] SALT\\n\"\n\t  \"Options:\\n\"\n\t  \"  --help                 Show this help.\\n\"\n\t  \"  -V, --version          Show version information.\\n\"\n\t  \"  -i, --iterations=COUNT Desired iteration count (default %d).\\n\"\n\t  \"  -l, --length=LENGTH    Desired output length (octets, default %d)\\n\"\n\t  \"  --raw                  Raw binary output.\\n\"\n\t  \"  --hex-salt             Use hex encoding for the salt.\\n\",\n\t  DEFAULT_ITERATIONS, DEFAULT_LENGTH);\n}",
      "lines": 13,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        66,
        0
      ],
      "end_point": [
        194,
        1
      ],
      "content": "int\nmain (int argc, char **argv)\n{\n  unsigned iterations = DEFAULT_ITERATIONS;\n  unsigned output_length = DEFAULT_LENGTH;\n  char password[MAX_PASSWORD];\n  size_t password_length;\n  uint8_t *output;\n  size_t salt_length;\n  char *salt;\n  int raw = 0;\n  int hex_salt = 0;\n  int c;\n\n  enum { OPT_HELP = 0x300, OPT_RAW, OPT_HEX_SALT };\n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"version\", no_argument, NULL, 'V' },\n      { \"length\", required_argument, NULL, 'l' },\n      { \"iterations\", required_argument, NULL, 'i' },\n      { \"raw\", no_argument, NULL, OPT_RAW },\n      { \"hex-salt\", no_argument, NULL, OPT_HEX_SALT },\n\n      { NULL, 0, NULL, 0 }\n    };\n\n  while ( (c = getopt_long(argc, argv, \"Vl:i:\", options, NULL)) != -1)\n    switch (c)\n      {\n      default:\n\tabort();\n      case '?':\n\tusage (stderr);\n\treturn EXIT_FAILURE;\n      case OPT_HELP:\n\tusage (stdout);\n\treturn EXIT_SUCCESS;\n      case 'V':\n\tprintf(\"nettle-pbkdf2 (\" PACKAGE_STRING \")\\n\");\n\treturn EXIT_SUCCESS;\n      case 'l':\n\t{\n\t  int arg;\n\t  arg = atoi (optarg);\n\t  if (arg <= 0)\n\t    die (\"Invalid length argument: `%s'\\n\", optarg);\n\n\t  output_length = arg;\n\t}\n\tbreak;\n      case 'i':\n\t{\n\t  int arg;\n\t  arg = atoi (optarg);\n\t  if (arg <= 0)\n\t    die (\"Invalid iteration count: `%s'\\n\", optarg);\n\t  iterations = arg;\n\t}\n\tbreak;\n      case OPT_RAW:\n\traw = 1;\n\tbreak;\n      case OPT_HEX_SALT:\n\thex_salt = 1;\n\tbreak;\n      }\n  argv += optind;\n  argc -= optind;\n\n  if (argc != 1)\n    {\n      usage (stderr);\n      return EXIT_FAILURE;\n    }\n\n  salt = strdup (argv[0]);\n  salt_length = strlen(argv[0]);\n  \n  if (hex_salt)\n    {\n      struct base16_decode_ctx base16;\n\n      base16_decode_init (&base16);\n      if (!base16_decode_update (&base16,\n\t\t\t\t &salt_length, (uint8_t *) salt,\n\t\t\t\t salt_length, salt)\n\t  || !base16_decode_final (&base16))\n\tdie (\"Invalid salt (expecting hex encoding).\\n\");\n    }\n  \n  password_length = fread (password, 1, sizeof(password), stdin);\n  if (password_length == sizeof(password))\n    die (\"Password input too long. Current limit is %d characters.\\n\",\n\t (int) sizeof(password) - 1);\n  if (ferror (stdin))\n    die (\"Reading password input failed: %s.\\n\", strerror (errno));\n\n  output = xalloc (output_length);\n  pbkdf2_hmac_sha256 (password_length, (const uint8_t *) password,\n\t\t      iterations, salt_length, (const uint8_t*) salt,\n\t\t      output_length, output);\n\n  free (salt);\n\n  if (raw)\n    fwrite (output, output_length, 1, stdout);\n  else\n    {\n      unsigned i;\n      char hex[BASE16_ENCODE_LENGTH(8) + 1];\n      for (i = 0; i + 8 < output_length; i += 8)\n\t{\n\t  base16_encode_update(hex, 8, output + i);\n\t  hex[BASE16_ENCODE_LENGTH(8)] = 0;\n\t  printf(\"%s%c\", hex, i % 64 == 56 ? '\\n' : ' ');\n\t}\n      base16_encode_update(hex, output_length - i, output + i);\n      hex[BASE16_ENCODE_LENGTH(output_length - i)] = 0;\n      printf(\"%s\\n\", hex);\n    }\n  free (output);\n\n  if (fflush(stdout) != 0 )\n    die(\"Write failed: %s\\n\", STRERROR(errno));\n\n  return EXIT_SUCCESS;\n}",
      "lines": 129,
      "depth": 14,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/output.c": {
    "sexp_output_init": {
      "start_point": [
        46,
        0
      ],
      "end_point": [
        59,
        1
      ],
      "content": "void\nsexp_output_init(struct sexp_output *output, FILE *f,\n\t\t unsigned width, int prefer_hex)\n{\n  output->f = f;\n  output->line_width = width;\n  output->coding = NULL;\n  output->prefer_hex = prefer_hex;\n  output->hash = NULL;\n  output->ctx = NULL;\n  \n  output->pos = 0;\n  output->soft_newline = 0;\n}",
      "lines": 14,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sexp_output_hash_init": {
      "start_point": [
        61,
        0
      ],
      "end_point": [
        68,
        1
      ],
      "content": "void\nsexp_output_hash_init(struct sexp_output *output,\n\t\t      const struct nettle_hash *hash, void *ctx)\n{\n  output->hash = hash;\n  output->ctx = ctx;\n  hash->init(ctx);\n}",
      "lines": 8,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_raw_char": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        78,
        1
      ],
      "content": "static void\nsexp_put_raw_char(struct sexp_output *output, uint8_t c)\n{\n  if (putc(c, output->f) < 0)\n    die(\"Write failed: %s\\n\", strerror(errno));\n\n  output->pos++;\n  output->soft_newline = 0;\n}",
      "lines": 9,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_put_newline": {
      "start_point": [
        80,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "void\nsexp_put_newline(struct sexp_output *output,\n\t\t unsigned indent)\n{\n  if (output->soft_newline)\n    output->soft_newline = 0;\n  else\n    {\n      unsigned i;\n\n      sexp_put_raw_char(output, '\\n');\n      output->pos = 0;\n  \n      for(i = 0; i < indent; i++)\n\tsexp_put_raw_char(output, ' ');\n  \n      output->pos = indent;\n    }\n}",
      "lines": 19,
      "depth": 10,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_soft_newline": {
      "start_point": [
        102,
        0
      ],
      "end_point": [
        108,
        1
      ],
      "content": "void\nsexp_put_soft_newline(struct sexp_output *output,\n\t\t      unsigned indent)\n{\n  sexp_put_newline(output, indent);\n  output->soft_newline = 1;\n}",
      "lines": 7,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_char": {
      "start_point": [
        110,
        0
      ],
      "end_point": [
        139,
        1
      ],
      "content": "void\nsexp_put_char(struct sexp_output *output, uint8_t c)\n{\n  if (output->coding)\n    {\n      /* Two is enough for both base16 and base64. */\n      char encoded[2];\n      unsigned done;\n\n      unsigned i;\n\n      done = output->coding->encode_update(&output->base64, encoded,\n\t\t\t\t\t   1, &c);\n      assert(done <= sizeof(encoded));\n      \n      for (i = 0; i<done; i++)\n\t{\n\t  if (output->line_width\n\t      && output->pos >= output->line_width\n\t      && output->pos >= (output->coding_indent + 10))\n\t    sexp_put_newline(output, output->coding_indent);\n\t  \n\t  sexp_put_raw_char(output, encoded[i]);\n\t}\n    }\n  else if (output->hash)\n    output->hash->update(output->ctx, 1, &c);\n  else\n    sexp_put_raw_char(output, c);\n}",
      "lines": 30,
      "depth": 14,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_data": {
      "start_point": [
        141,
        0
      ],
      "end_point": [
        149,
        1
      ],
      "content": "void\nsexp_put_data(struct sexp_output *output,\n\t      unsigned length, const uint8_t *data)\n{\n  unsigned i;\n\n  for (i = 0; i<length; i++)\n    sexp_put_char(output, data[i]);\n}",
      "lines": 9,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_length": {
      "start_point": [
        151,
        0
      ],
      "end_point": [
        167,
        1
      ],
      "content": "static void\nsexp_put_length(struct sexp_output *output, \n\t\tunsigned length)\n{\n  unsigned digit = 1;\n\n  for (;;)\n    {\n      unsigned next = digit * 10;\n      if (next > length)\n\tbreak;\n      digit = next;\n    }\n\n  for (; digit; length %= digit, digit /= 10)\n    sexp_put_char(output, '0' + length / digit);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_put_code_start": {
      "start_point": [
        169,
        0
      ],
      "end_point": [
        179,
        1
      ],
      "content": "void\nsexp_put_code_start(struct sexp_output *output,\n\t\t    const struct nettle_armor *coding)\n{\n  assert(!output->coding);\n  \n  output->coding_indent = output->pos;\n  \n  output->coding = coding;\n  output->coding->encode_init(&output->base64);\n}",
      "lines": 11,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_code_end": {
      "start_point": [
        181,
        0
      ],
      "end_point": [
        197,
        1
      ],
      "content": "void\nsexp_put_code_end(struct sexp_output *output)\n{\n  /* Enough for both hex and base64 */\n  char encoded[BASE64_ENCODE_FINAL_LENGTH];\n  unsigned done;\n\n  assert(output->coding);\n\n  done = output->coding->encode_final(&output->base64, encoded);\n\n  assert(done <= sizeof(encoded));\n  \n  output->coding = NULL;\n\n  sexp_put_data(output, done, (const uint8_t*) encoded);\n}",
      "lines": 17,
      "depth": 9,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_string": {
      "start_point": [
        199,
        0
      ],
      "end_point": [
        295,
        1
      ],
      "content": "void\nsexp_put_string(struct sexp_output *output, enum sexp_mode mode,\n\t\tstruct nettle_buffer *string)\n{\n  if (!string->size)\n    sexp_put_data(output, 2,\n\t\t  (const uint8_t *) ((mode == SEXP_ADVANCED) ? \"\\\"\\\"\": \"0:\"));\n\n  else if (mode == SEXP_ADVANCED)\n    {\n      unsigned i;\n      int token = (string->contents[0] < '0' || string->contents[0] > '9');\n      int quote_friendly = 1;\n#define CONTROL_SIZE 0x20\n      static const char escape_names[CONTROL_SIZE] =\n\t{\n\t  0,0,0,0,0,0,0,0, 'b','t','n',0,'f','r',0,0,\n\t  0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0\n\t};\n\n      for (i = 0; i<string->size; i++)\n\t{\n\t  uint8_t c = string->contents[i];\n\t  \n\t  if (token & !TOKEN_CHAR(c))\n\t    token = 0;\n\t  \n\t  if (quote_friendly)\n\t    {\n\t      if (c >= 0x7f)\n\t\tquote_friendly = 0;\n\t      else if (c < CONTROL_SIZE && !escape_names[c])\n\t\tquote_friendly = 0;\n\t    }\n\t}\n      \n      if (token)\n\tsexp_put_data(output, string->size, string->contents);\n\n      else if (quote_friendly)\n\t{\n\t  sexp_put_char(output, '\"');\n\n\t  for (i = 0; i<string->size; i++)\n\t    {\n\t      int escape = 0;\n\t      uint8_t c = string->contents[i];\n\n\t      assert(c < 0x7f);\n\t      \n\t      if (c == '\\\\' || c == '\"')\n\t\tescape = 1;\n\t      else if (c < CONTROL_SIZE)\n\t\t{\n\t\t  escape = 1;\n\t\t  c = escape_names[c];\n\t\t  assert(c);\n\t\t}\n\t      if (escape)\n\t\tsexp_put_char(output, '\\\\');\n\n\t      sexp_put_char(output, c);\n\t    }\n\t  \n\t  sexp_put_char(output, '\"');\n\t}\n      else \n\t{\n\t  uint8_t delimiter;\n\t  const struct nettle_armor *coding;\n\t  \n\t  if (output->prefer_hex)\n\t    {\n\t      delimiter = '#';\n\t      coding = &nettle_base16;\n\t    }\n\t  else\n\t    {\n\t      delimiter = '|';\n\t      coding = &nettle_base64;\n\t    }\n\t  \n\t  sexp_put_char(output, delimiter);\n\t  sexp_put_code_start(output, coding);\n\t  sexp_put_data(output, string->size, string->contents);\n\t  sexp_put_code_end(output);\n\t  sexp_put_char(output, delimiter);\n\t}\n#undef CONTROL_SIZE\n    }\n  else\n    {\n      sexp_put_length(output, string->size);\n      sexp_put_char(output, ':');\n      sexp_put_data(output, string->size, string->contents);\n    }\n}",
      "lines": 97,
      "depth": 17,
      "decorators": [
        "void"
      ]
    },
    "sexp_put_digest": {
      "start_point": [
        297,
        0
      ],
      "end_point": [
        310,
        1
      ],
      "content": "void\nsexp_put_digest(struct sexp_output *output)\n{\n  TMP_DECL(digest, uint8_t, NETTLE_MAX_HASH_DIGEST_SIZE);\n  TMP_ALLOC(digest, output->hash->digest_size);\n  \n  assert(output->hash);\n\n  output->hash->digest(output->ctx, output->hash->digest_size, digest);\n\n  sexp_put_code_start(output, &nettle_base16);\n  sexp_put_data(output, output->hash->digest_size, digest);\n  sexp_put_code_end(output);\n}",
      "lines": 14,
      "depth": 8,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/output.h": {},
  "nettle/nettle-3.4.1/tools/parse.c": {
    "sexp_compound_token_init": {
      "start_point": [
        42,
        0
      ],
      "end_point": [
        48,
        1
      ],
      "content": "void\nsexp_compound_token_init(struct sexp_compound_token *token)\n{\n  token->type = 0;\n  nettle_buffer_init(&token->display);\n  nettle_buffer_init(&token->string);\n}",
      "lines": 7,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexp_compound_token_clear": {
      "start_point": [
        50,
        0
      ],
      "end_point": [
        55,
        1
      ],
      "content": "void\nsexp_compound_token_clear(struct sexp_compound_token *token)\n{\n  nettle_buffer_clear(&token->display);\n  nettle_buffer_clear(&token->string);\n}",
      "lines": 6,
      "depth": 8,
      "decorators": [
        "void"
      ]
    },
    "sexp_parse_init": {
      "start_point": [
        57,
        0
      ],
      "end_point": [
        71,
        1
      ],
      "content": "void\nsexp_parse_init(struct sexp_parser *parser,\n\t\tstruct sexp_input *input,\n\t\tenum sexp_mode mode)\n{\n  parser->input = input;\n  parser->mode = mode;\n\n  /* Start counting with 1 for the top level, to make comparisons\n   * between transport and level simpler.\n   *\n   * FIXME: Is that trick ugly? */\n  parser->level = 1;\n  parser->transport = 0;\n}",
      "lines": 15,
      "depth": 6,
      "decorators": [
        "void"
      ]
    },
    "sexp_check_token": {
      "start_point": [
        74,
        0
      ],
      "end_point": [
        85,
        1
      ],
      "content": "static void\nsexp_check_token(struct sexp_parser *parser,\n\t\t enum sexp_token token,\n\t\t struct nettle_buffer *string)\n{\n  sexp_get_token(parser->input,\n\t\t parser->transport ? SEXP_CANONICAL : parser->mode,\n\t\t string);\n\n  if (parser->input->token != token)\n    die(\"Syntax error.\\n\");\n}",
      "lines": 12,
      "depth": 8,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "sexp_parse": {
      "start_point": [
        94,
        0
      ],
      "end_point": [
        175,
        1
      ],
      "content": "void\nsexp_parse(struct sexp_parser *parser,\n\t   struct sexp_compound_token *token)\n{\n  for (;;)\n    {\n      sexp_get_token(parser->input,\n\t\t     parser->transport ? SEXP_CANONICAL : parser->mode,\n\t\t     &token->string);\n\n      switch(parser->input->token)\n\t{\n\tcase SEXP_LIST_END:\n\t  if (parser->level == parser->transport)\n\t    die(\"Unmatched end of list in transport encoded data.\\n\");\n\t  parser->level--;\n\n\t  if (!parser->level)\n\t    die(\"Unmatched end of list.\\n\");\n\n\t  token->type = SEXP_LIST_END;\n\n\tcheck_transport_end:\n\t  if (parser->level == parser->transport)\n\t    {\n\t      sexp_check_token(parser, SEXP_CODING_END, &token->string);\n\t      assert(parser->transport);\n\t      assert(parser->level == parser->transport);\n\n\t      parser->level--;\n\t      parser->transport = 0;\n\t    }\n\t  return;\n    \n\tcase SEXP_EOF:\n\t  if (parser->level > 1)\n\t    die(\"Unexpected end of file.\\n\");\n\n\t  token->type = SEXP_EOF;\n\t  return;\n\n\tcase SEXP_LIST_START:\n\t  parser->level++;\n\t  token->type = SEXP_LIST_START;\n\t  return;\n\n\tcase SEXP_DISPLAY_START:\n\t  sexp_check_token(parser, SEXP_STRING, &token->display);\n\t  sexp_check_token(parser, SEXP_DISPLAY_END, &token->display);\n\t  sexp_check_token(parser, SEXP_STRING, &token->string);\n\n\t  token->type = SEXP_DISPLAY;\n\t  goto check_transport_end;\n\n\tcase SEXP_STRING:\n\t  token->type = SEXP_STRING;\n\t  goto check_transport_end;\n\n\tcase SEXP_COMMENT:\n\t  token->type = SEXP_COMMENT;\n\t  return;\n\n\tcase SEXP_TRANSPORT_START:\n\t  if (parser->mode == SEXP_CANONICAL)\n\t    die(\"Base64 not allowed in canonical mode.\\n\");\n\t  parser->level++;\n\t  parser->transport = parser->level;\n\n\t  continue;\n\n\tcase SEXP_CODING_END:\n\t  die(\"Unexpected end of transport encoding.\\n\");\n\t  \n\tcase SEXP_DISPLAY_END:\n\t  die(\"Unexpected end of display tag.\\n\");\n\n\tcase SEXP_DISPLAY:\n\t  /* Internal error. */\n\t  abort();\n\t}\n    }\n}",
      "lines": 82,
      "depth": 16,
      "decorators": [
        "void"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/parse.h": {},
  "nettle/nettle-3.4.1/tools/pkcs1-conv.c": {
    "write_file": {
      "start_point": [
        63,
        0
      ],
      "end_point": [
        74,
        1
      ],
      "content": "static int\nwrite_file(struct nettle_buffer *buffer, FILE *f)\n{\n  size_t res = fwrite(buffer->contents, 1, buffer->size, f);\n  if (res < buffer->size)\n    {\n      werror(\"Write failed: %s.\\n\", strerror(errno));\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 12,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_line": {
      "start_point": [
        77,
        0
      ],
      "end_point": [
        98,
        1
      ],
      "content": "static int\nread_line(struct nettle_buffer *buffer, FILE *f)\n{\n  int c;\n  \n  while ((c = getc(f)) != EOF)\n    {\n      if (!NETTLE_BUFFER_PUTC(buffer, c))\n\treturn 0;\n\n      if (c == '\\n')\n\treturn 1;\n    }\n  if (ferror(f))\n    {\n      werror(\"Read failed: %s\\n\", strerror(errno));\n      return 0;\n    }\n  \n  else \n    return -1;\n}",
      "lines": 22,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_file": {
      "start_point": [
        100,
        0
      ],
      "end_point": [
        116,
        1
      ],
      "content": "static int\nread_file(struct nettle_buffer *buffer, FILE *f)\n{\n  int c;\n  \n  while ((c = getc(f)) != EOF)\n    if (!NETTLE_BUFFER_PUTC(buffer, c))\n      return 0;\n\n  if (ferror(f))\n    {\n      werror(\"Read failed: %s\\n\", strerror(errno));\n      return 0;\n    }\n  else\n    return 1;\n}",
      "lines": 17,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "match_pem_start": {
      "start_point": [
        139,
        0
      ],
      "end_point": [
        159,
        1
      ],
      "content": "static int\nmatch_pem_start(size_t length, const uint8_t *line,\n\t\tsize_t *marker_start,\n\t\tsize_t *marker_length)\n{\n  while (length > 0 && PEM_IS_SPACE(line[length - 1]))\n    length--;\n\n  if (length > (sizeof(pem_start_pattern) + sizeof(pem_trailer_pattern))\n      && memcmp(line, pem_start_pattern, sizeof(pem_start_pattern)) == 0\n      && memcmp(line + length - sizeof(pem_trailer_pattern),\n\t\tpem_trailer_pattern, sizeof(pem_trailer_pattern)) == 0)\n    {\n      *marker_start = 11;\n      *marker_length = length - (sizeof(pem_start_pattern) + sizeof(pem_trailer_pattern));\n\n      return 1;\n    }\n  else\n    return 0;\n}",
      "lines": 21,
      "depth": 13,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "match_pem_end": {
      "start_point": [
        163,
        0
      ],
      "end_point": [
        185,
        1
      ],
      "content": "static int\nmatch_pem_end(size_t length, const uint8_t *line,\n\t      size_t marker_length,\n\t      const uint8_t *marker)\n{\n  while (length > 0 && PEM_IS_SPACE(line[length - 1]))\n    length--;\n\n  if (length > (sizeof(pem_end_pattern) + sizeof(pem_trailer_pattern))\n      && memcmp(line, pem_end_pattern, sizeof(pem_end_pattern)) == 0\n      && memcmp(line + length - sizeof(pem_trailer_pattern),\n\t\tpem_trailer_pattern, sizeof(pem_trailer_pattern)) == 0)\n    {\n      /* Right form. Check marker */\n      if (length == marker_length + (sizeof(pem_end_pattern) + sizeof(pem_trailer_pattern))\n\t  && memcmp(line + sizeof(pem_end_pattern), marker, marker_length) == 0)\n\treturn 1;\n      else\n\treturn -1;\n    }\n  else\n    return 0;  \n}",
      "lines": 23,
      "depth": 15,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "read_pem": {
      "start_point": [
        196,
        0
      ],
      "end_point": [
        244,
        1
      ],
      "content": "static int\nread_pem(struct nettle_buffer *buffer, FILE *f,\n\t struct pem_info *info)\n{  \n  /* Find start line */\n  for (;;)\n    {\n      int res;\n\n      nettle_buffer_reset(buffer);\n\n      res = read_line(buffer, f);\n      if (res != 1)\n\treturn res;\n\n      if (match_pem_start(buffer->size, buffer->contents,\n\t\t\t  &info->marker_start, &info->marker_length))\n\tbreak;\n    }\n\n  /* NUL-terminate the marker. Don't care to check for embedded NULs. */\n  buffer->contents[info->marker_start + info->marker_length] = 0;\n\n  info->data_start = buffer->size;\n\n  for (;;)\n    {\n      size_t line_start = buffer->size;\n\n      if (read_line(buffer, f) != 1)\n\treturn 0;\n\n      switch (match_pem_end(buffer->size - line_start,\n\t\t\t    buffer->contents + line_start,\n\t\t\t    info->marker_length,\n\t\t\t    buffer->contents + info->marker_start))\n\t{\n\tcase 0:\n\t  break;\n\tcase -1:\n\t  werror(\"PEM END line doesn't match BEGIN.\\n\");\n\t  return 0;\n\tcase 1:\n\t  /* Return base 64 data; let caller do the decoding */ \n\t  info->data_length = line_start - info->data_start;\n\t  return 1;\n\t}\n    }\n}",
      "lines": 49,
      "depth": 12,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "base64_decode_in_place": {
      "start_point": [
        246,
        0
      ],
      "end_point": [
        252,
        1
      ],
      "content": "static inline int\nbase64_decode_in_place (struct base64_decode_ctx *ctx, size_t *dst_length,\n\t\t\tsize_t length, uint8_t *data)\n{\n  return base64_decode_update (ctx, dst_length,\n\t\t\t       data, length, (const char *) data);\n}",
      "lines": 7,
      "depth": 9,
      "decorators": [
        "static",
        "static",
        "inline",
        "inline",
        "int"
      ]
    },
    "decode_base64": {
      "start_point": [
        254,
        0
      ],
      "end_point": [
        273,
        1
      ],
      "content": "static int\ndecode_base64(struct nettle_buffer *buffer,\n\t      size_t start, size_t *length)\n{\n  struct base64_decode_ctx ctx;\n  \n  base64_decode_init(&ctx);\n\n  /* Decode in place */\n  if (base64_decode_in_place(&ctx, length,\n\t\t\t     *length, buffer->contents + start)\n      && base64_decode_final(&ctx))\n    return 1;\n  \n  else\n    {\n      werror(\"Invalid base64 date.\\n\");\n      return 0;\n    }\n}",
      "lines": 20,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_rsa_public_key": {
      "start_point": [
        275,
        0
      ],
      "end_point": [
        297,
        1
      ],
      "content": "static int\nconvert_rsa_public_key(struct nettle_buffer *buffer, size_t length, const uint8_t *data)\n{\n  struct rsa_public_key pub;\n  int res;\n  \n  rsa_public_key_init(&pub);\n\n  if (rsa_keypair_from_der(&pub, NULL, 0,\n\t\t\t   length, data))\n    {\n      /* Reuses the buffer */\n      nettle_buffer_reset(buffer);\n      res = rsa_keypair_to_sexp(buffer, NULL, &pub, NULL);\n    }\n  else\n    {\n      werror(\"Invalid PKCS#1 public key.\\n\");\n      res = 0;\n    }\n  rsa_public_key_clear(&pub);\n  return res;\n}",
      "lines": 23,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_rsa_private_key": {
      "start_point": [
        299,
        0
      ],
      "end_point": [
        325,
        1
      ],
      "content": "static int\nconvert_rsa_private_key(struct nettle_buffer *buffer, size_t length, const uint8_t *data)\n{\n  struct rsa_public_key pub;\n  struct rsa_private_key priv;\n  int res;\n  \n  rsa_public_key_init(&pub);\n  rsa_private_key_init(&priv);\n\n  if (rsa_keypair_from_der(&pub, &priv, 0,\n\t\t\t   length, data))\n    {\n      /* Reuses the buffer */\n      nettle_buffer_reset(buffer);\n      res = rsa_keypair_to_sexp(buffer, NULL, &pub, &priv);\n    }\n  else\n    {\n      werror(\"Invalid PKCS#1 private key.\\n\");\n      res = 0;\n    }\n  rsa_public_key_clear(&pub);\n  rsa_private_key_clear(&priv);\n\n  return res;\n}",
      "lines": 27,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_dsa_private_key": {
      "start_point": [
        327,
        0
      ],
      "end_point": [
        356,
        1
      ],
      "content": "static int\nconvert_dsa_private_key(struct nettle_buffer *buffer, size_t length, const uint8_t *data)\n{\n  struct dsa_params params;\n  mpz_t pub;\n  mpz_t priv;\n  int res;\n\n  dsa_params_init (&params);\n  mpz_init (pub);\n  mpz_init (priv);\n\n  if (dsa_openssl_private_key_from_der(&params, pub, priv, 0,\n\t\t\t\t       length, data))\n    {\n      /* Reuses the buffer */\n      nettle_buffer_reset(buffer);\n      res = dsa_keypair_to_sexp(buffer, NULL, &params, pub, priv);\n    }\n  else\n    {\n      werror(\"Invalid OpenSSL private key.\\n\");\n      res = 0;\n    }\n  dsa_params_clear (&params);\n  mpz_clear (pub);\n  mpz_clear (priv);\n\n  return res;\n}",
      "lines": 30,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_public_key": {
      "start_point": [
        359,
        0
      ],
      "end_point": [
        478,
        1
      ],
      "content": "static int\nconvert_public_key(struct nettle_buffer *buffer, size_t length, const uint8_t *data)\n{\n  /* SubjectPublicKeyInfo ::= SEQUENCE {\n         algorithm\t\tAlgorithmIdentifier,\n\t subjectPublicKey \tBIT STRING\n     }\n\n     AlgorithmIdentifier ::= SEQUENCE {\n         algorithm  \tOBJECT IDENTIFIER,\n\t parameters \tOPTIONAL\n     }\n  */\n  struct asn1_der_iterator i;\n  struct asn1_der_iterator j;\n  int res = 0;\n\n  if (asn1_der_iterator_first(&i, length, data) == ASN1_ITERATOR_CONSTRUCTED\n      && i.type == ASN1_SEQUENCE\n      && asn1_der_decode_constructed_last(&i) == ASN1_ITERATOR_CONSTRUCTED\n      && i.type == ASN1_SEQUENCE\n\n      /* Use the j iterator to parse the algorithm identifier */\n      && asn1_der_decode_constructed(&i, &j) == ASN1_ITERATOR_PRIMITIVE\n      && j.type == ASN1_IDENTIFIER\n      && asn1_der_iterator_next(&i) == ASN1_ITERATOR_PRIMITIVE\n      && i.type == ASN1_BITSTRING\n\n      /* Use i to parse the object wrapped in the bit string.*/\n      && asn1_der_decode_bitstring_last(&i))\n    {\n      /* pkcs-1 {\n\t     iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) pkcs-1(1)\n\t     modules(0) pkcs-1(1)\n\t }\n\n\t --\n\t -- When rsaEncryption is used in an AlgorithmIdentifier the\n\t -- parameters MUST be present and MUST be NULL.\n\t --\n\t rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }\n      */\n      static const uint8_t id_rsaEncryption[9] =\n\t{ 0x2A, 0x86, 0x48, 0x86, 0xF7, 0x0D, 0x01, 0x01, 0x01 };\n      /*\n\t --\n\t -- When dsa is used in an AlgorithmIdentifier the\n\t -- parameters MUST be present and MUST NOT be NULL.\n\t --\n\t dsa    OBJECT IDENTIFIER ::= { iso(1) member-body(2) us(840) x9-57(10040) x9algorithm(4) 1 }\n      */\n      static const uint8_t id_dsa[7] =\n\t{ 0x2A, 0x86, 0x48, 0xCE, 0x38, 0x04, 0x01 };\n\n      switch (j.length)\n\t{\n\tunknown:\n\tdefault:\n\t  werror(\"SubjectPublicKeyInfo: Unsupported algorithm.\\n\");\n\t  res = -1;\n\t  break;\n\t  \n\tcase 7:\n\t  if (memcmp(j.data, id_dsa, 7) == 0)\n\t    {\n\t      if (asn1_der_iterator_next(&j) == ASN1_ITERATOR_CONSTRUCTED\n\t\t  && asn1_der_decode_constructed_last(&j) == ASN1_ITERATOR_PRIMITIVE)\n\t\t{\n\t\t  struct dsa_params params;\n\t\t  mpz_t pub;\n\n\t\t  dsa_params_init (&params);\n\t\t  mpz_init (pub);\n\n\t\t  if (dsa_params_from_der_iterator(&params, 0, 0, &i)\n\t\t      && dsa_public_key_from_der_iterator(&params, pub, &j))\n\t\t    {\n\t\t      nettle_buffer_reset(buffer);\n\t\t      res = dsa_keypair_to_sexp(buffer, NULL,\n\t\t\t\t\t\t&params, pub, NULL) > 0;\n\t\t    }\n\t\t  dsa_params_clear(&params);\n\t\t  mpz_clear(pub);\n\t\t}\n\t      if (!res)\n\t\twerror(\"SubjectPublicKeyInfo: Invalid DSA key.\\n\");\n\t      break;\n\t    }\n\t  else goto unknown;\n\tcase 9:\n\t  if (memcmp(j.data, id_rsaEncryption, 9) == 0)\n\t    {\n\t      if (asn1_der_iterator_next(&j) == ASN1_ITERATOR_PRIMITIVE\n\t\t  && j.type == ASN1_NULL\n\t\t  && j.length == 0\n\t\t  && asn1_der_iterator_next(&j) == ASN1_ITERATOR_END)\n\t\t{\n\t\t  struct rsa_public_key pub;\n\n\t\t  rsa_public_key_init(&pub);\n\n\t\t  if (rsa_public_key_from_der_iterator(&pub, 0, &i))\n\t\t    {\n\t\t      nettle_buffer_reset(buffer);\n\t\t      res = rsa_keypair_to_sexp(buffer, NULL, &pub, NULL) > 0;\n\t\t    }\n\t\t  rsa_public_key_clear(&pub);\n\t\t}\n\t      if (!res)\n\t\twerror(\"SubjectPublicKeyInfo: Invalid RSA key.\\n\");\n\t      break;\n\t    }\n\t  else goto unknown;\n\t}\n    }\n  else\n    werror(\"SubjectPublicKeyInfo: Invalid object.\\n\");\n\n  return res;\n}",
      "lines": 120,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_type": {
      "start_point": [
        482,
        0
      ],
      "end_point": [
        515,
        1
      ],
      "content": "static int\nconvert_type(struct nettle_buffer *buffer,\n\t     enum object_type type,\n\t     size_t length, const uint8_t *data)\n{\n  int res;\n  \n  switch(type)\n    {\n    default:\n      abort();\n\n    case GENERAL_PUBLIC_KEY:\n      res = convert_public_key(buffer, length, data);\n      break;\n\n    case RSA_PUBLIC_KEY:\n      res = convert_rsa_public_key(buffer, length, data);\n      break;\n\n    case RSA_PRIVATE_KEY:\n      res = convert_rsa_private_key(buffer, length, data);\n      break;\n\n    case DSA_PRIVATE_KEY:\n      res = convert_dsa_private_key(buffer, length, data);\n      break;\n    }\n\n  if (res > 0)\n    res = write_file(buffer, stdout);\n\n  return res;\n}",
      "lines": 34,
      "depth": 10,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "convert_file": {
      "start_point": [
        517,
        0
      ],
      "end_point": [
        590,
        1
      ],
      "content": "static int\nconvert_file(struct nettle_buffer *buffer,\n\t     FILE *f,\n\t     enum object_type type,\n\t     int base64)\n{\n  if (type)\n    {\n      read_file(buffer, f);\n      if (base64 && !decode_base64(buffer, 0, &buffer->size))\n\treturn 0;\n      \n      if (convert_type(buffer, type,\n\t\t       buffer->size, buffer->contents) != 1)\n\treturn 0;\n\n      return 1;\n    }\n  else\n    {\n      /* PEM processing */\n      for (;;)\n\t{\n\t  struct pem_info info;\n\t  const uint8_t *marker;\n\t  \n\t  nettle_buffer_reset(buffer);\n\t  switch (read_pem(buffer, f, &info))\n\t    {\n\t    default:\n\t      return 0;\n\t    case 1:\n\t      break;\n\t    case -1:\n\t      /* EOF */\n\t      return 1;\n\t    }\n\n\t  if (!decode_base64(buffer, info.data_start, &info.data_length))\n\t    return 0;\n\n\t  marker = buffer->contents + info.marker_start;\n\n\t  type = 0;\n\t  switch (info.marker_length)\n\t    {\n\t    case 10:\n\t      if (memcmp(marker, \"PUBLIC KEY\", 10) == 0)\n\t\ttype = GENERAL_PUBLIC_KEY;\n\t      break;\n\n\t    case 14:\n\t      if (memcmp(marker, \"RSA PUBLIC KEY\", 14) == 0)\n\t\ttype = RSA_PUBLIC_KEY;\n\t      break;\n\n\t    case 15:\n\t      if (memcmp(marker, \"RSA PRIVATE KEY\", 15) == 0)\n\t\ttype = RSA_PRIVATE_KEY;\n\t      else if (memcmp(marker, \"DSA PRIVATE KEY\", 15) == 0)\n\t\ttype = DSA_PRIVATE_KEY;\n\t      break;\n\t    }\n\t  \n\t  if (!type)\n\t    werror(\"Ignoring unsupported object type `%s'.\\n\", marker);\n\n\t  else if (convert_type(buffer, type,\n\t\t\t\tinfo.data_length,\n\t\t\t\tbuffer->contents + info.data_start) != 1)\n\t    return 0;\n\t}\n    }\n}",
      "lines": 74,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "main": {
      "start_point": [
        592,
        0
      ],
      "end_point": [
        679,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct nettle_buffer buffer;\n  enum object_type type = 0;\n  int base64 = 0;\n  int c;\n\n  enum {\n    OPT_HELP = 0x300,\n    OPT_PRIVATE_RSA = RSA_PRIVATE_KEY,\n    OPT_PUBLIC_RSA = RSA_PUBLIC_KEY,\n    OPT_PRIVATE_DSA = DSA_PRIVATE_KEY,\n    OPT_PUBLIC_KEY = GENERAL_PUBLIC_KEY,\n  };\n  \n  static const struct option options[] =\n    {\n      /* Name, args, flag, val */\n      { \"help\", no_argument, NULL, OPT_HELP },\n      { \"version\", no_argument, NULL, 'V' },\n      { \"private-rsa-key\", no_argument, NULL, OPT_PRIVATE_RSA },\n      { \"public-rsa-key\", no_argument, NULL, OPT_PUBLIC_RSA },\n      { \"private-dsa-key\", no_argument, NULL, OPT_PRIVATE_DSA },\n      { \"public-key-info\", no_argument, NULL, OPT_PUBLIC_KEY },\n      { \"base-64\", no_argument, NULL, 'b' },\n      { NULL, 0, NULL, 0 }\n    };\n\n  while ( (c = getopt_long(argc, argv, \"Vb\", options, NULL)) != -1)\n    {\n      switch (c)\n\t{\n\tdefault:\n\t  abort();\n\n\tcase 'b':\n\t  base64 = 1;\n\t  break;\n\n\tcase OPT_PRIVATE_RSA:\n\tcase OPT_PUBLIC_RSA:\n\tcase OPT_PRIVATE_DSA:\n\tcase OPT_PUBLIC_KEY:\n\t  /* Same values as the type codes. */\n\t  type = c;\n\t  break;\n\n\tcase OPT_HELP:\n\t  printf(\"FIXME: Usage information.\\n\");\n\t  return EXIT_SUCCESS;\n\tcase '?':\n\t  return EXIT_FAILURE;\n\n\tcase 'V':\n\t  printf(\"pkcs1-conv (\" PACKAGE_STRING \")\\n\");\n\t  return EXIT_SUCCESS;\n\t}\n    }\n\n  nettle_buffer_init_realloc(&buffer, NULL, nettle_xrealloc);  \n\n  if (optind == argc)\n    {\n      if (!convert_file(&buffer, stdin, type, base64))\n\treturn EXIT_FAILURE;\n    }\n  else\n    {\n      int i;\n      const char *mode = (type || base64) ? \"r\" : \"rb\";\n      \n      for (i = optind; i < argc; i++)\n\t{\n\t  FILE *f = fopen(argv[i], mode);\n\t  if (!f)\n\t    die(\"Failed to open `%s': %s.\\n\", argv[i], strerror(errno));\n\n\t  if (!convert_file(&buffer, f, type, base64))\n\t    return EXIT_FAILURE;\n\n\t  fclose(f);\n\t}\n    }\n  nettle_buffer_clear (&buffer);\n\n  return EXIT_SUCCESS;\n}",
      "lines": 88,
      "depth": 13,
      "decorators": [
        "int"
      ]
    }
  },
  "nettle/nettle-3.4.1/tools/sexp-conv.c": {
    "sexp_convert_item": {
      "start_point": [
        70,
        0
      ],
      "end_point": [
        158,
        1
      ],
      "content": "static void\nsexp_convert_item(struct sexp_parser *parser,\n\t\t  struct sexp_compound_token *token,\n\t\t  struct sexp_output *output, enum sexp_mode mode_out,\n\t\t  unsigned indent)\n{\n  if (mode_out == SEXP_TRANSPORT)\n    {\n      sexp_put_char(output, '{');\n      sexp_put_code_start(output, &nettle_base64);\n      sexp_convert_item(parser, token, output, SEXP_CANONICAL, 0);\n      sexp_put_code_end(output);\n      sexp_put_char(output, '}');\n    }\n  else switch(token->type)\n    {\n    case SEXP_LIST_END:\n      die(\"Unmatched end of list.\\n\");\n    case SEXP_EOF:\n      die(\"Unexpected end of file.\\n\");\n    case SEXP_CODING_END:\n      die(\"Unexpected end of coding.\\n\");\n\n    case SEXP_LIST_START:\n      {\n\tunsigned item;\n\n\tsexp_put_char(output, '(');\n  \n\tfor (item = 0;\n\t     sexp_parse(parser, token), token->type != SEXP_LIST_END;\n\t     item++)\n\t  {\n\t    if (mode_out == SEXP_ADVANCED)\n\t      {\n\t\t/* FIXME: Adapt pretty printing to handle a big first\n\t\t * element. */\n\t\tswitch (item)\n\t\t  {\n\t\t  case 0:\n\t\t    if (token->type == SEXP_COMMENT)\n\t\t      {\n\t\t\tindent = output->pos;\n\t\t\t/* Disable the indentation setup for next item */\n\t\t\titem++;\n\t\t      }\n\t\t    break;\n\t\t    \n\t\t  case  1:\n\t\t    sexp_put_char(output, ' ');\n\t\t    indent = output->pos;\n\t\t    break;\n\n\t\t  default:\n\t\t    sexp_put_newline(output, indent);\n\t\t    break;\n\t\t  }\n\t      }\n\n\t    sexp_convert_item(parser, token, output, mode_out, indent);\n\t  }\n\tsexp_put_char(output, ')');\n\n\tbreak;\n      }      \n      \n    case SEXP_STRING:\n      sexp_put_string(output, mode_out, &token->string);\n      break;\n\n    case SEXP_DISPLAY:\n      sexp_put_char(output, '[');\n      sexp_put_string(output, mode_out, &token->display);\n      sexp_put_char(output, ']');\n      sexp_put_string(output, mode_out, &token->string);      \n      break;\n\n    case SEXP_COMMENT:\n      if (mode_out == SEXP_ADVANCED)\n\t{\n\t  sexp_put_data(output, token->string.size, token->string.contents);\n\t  sexp_put_soft_newline(output, indent);\n\t}\n      break;\n    default:\n      /* Internal error */\n      abort();\n    }\n}",
      "lines": 89,
      "depth": 20,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "match_argument": {
      "start_point": [
        215,
        0
      ],
      "end_point": [
        220,
        1
      ],
      "content": "static int\nmatch_argument(const char *given, const char *name)\n{\n  /* FIXME: Allow abbreviations */\n  return !strcmp(given, name);\n}",
      "lines": 6,
      "depth": 7,
      "decorators": [
        "static",
        "static",
        "int"
      ]
    },
    "parse_options": {
      "start_point": [
        222,
        0
      ],
      "end_point": [
        366,
        1
      ],
      "content": "static void\nparse_options(struct conv_options *o,\n\t      int argc, char **argv)\n{  \n  o->mode = SEXP_ADVANCED;\n  o->prefer_hex = 0;\n  o->once = 0;\n  o->lock = 0;\n  o->hash = NULL;\n  o->width = 72;\n  \n  for (;;)\n    {\n      static const struct nettle_hash *hashes[] =\n\t{ &nettle_md5, &nettle_sha1, &nettle_sha256, NULL };\n  \n      static const struct option options[] =\n\t{\n\t  /* Name, args, flag, val */\n\t  { \"help\", no_argument, NULL, OPT_HELP },\n\t  { \"version\", no_argument, NULL, 'V' },\n\t  { \"once\", no_argument, NULL, OPT_ONCE },\n\t  { \"syntax\", required_argument, NULL, 's' },\n\t  { \"hash\", optional_argument, NULL, OPT_HASH },\n\t  { \"raw-hash\", optional_argument, NULL, OPT_HASH },\n\t  { \"width\", required_argument, NULL, 'w' },\n#if HAVE_FCNTL_LOCKING\n\t  { \"lock\", no_argument, NULL, OPT_LOCK },\n#endif\n#if 0\n\t  /* Not yet implemented */\n\t  { \"replace\", required_argument, NULL, OPT_REPLACE },\n\t  { \"select\", required_argument, NULL, OPT_SELECT },\n\t  { \"spki-hash\", optional_argument, NULL, OPT_SPKI_HASH },\n#endif\n\t  { NULL, 0, NULL, 0 }\n\t};\n      int c;\n      int option_index = 0;\n      unsigned i;\n     \n      c = getopt_long(argc, argv, \"Vs:w:\", options, &option_index);\n\n      switch (c)\n\t{\n\tdefault:\n\t  abort();\n\t  \n\tcase -1:\n\t  if (optind != argc)\n\t    die(\"sexp-conv: Command line takes no arguments, only options.\\n\");\n\t  return;\n\n\tcase '?':\n\t  exit(EXIT_FAILURE);\n\t  \n\tcase 'w':\n\t  {\n\t    char *end;\n\t    int width = strtol(optarg, &end , 0);\n\t    if (!*optarg || *end || width < 0)\n\t      die(\"sexp-conv: Invalid width `%s'.\\n\", optarg);\n\n\t    o->width = width;\n\t    break;\n\t  }\n\tcase 's':\n\t  if (o->hash)\n\t    werror(\"sexp-conv: Combining --hash and -s usually makes no sense.\\n\");\n\t  if (match_argument(optarg, \"advanced\"))\n\t    o->mode = SEXP_ADVANCED;\n\t  else if (match_argument(optarg, \"transport\"))\n\t    o->mode = SEXP_TRANSPORT;\n\t  else if (match_argument(optarg, \"canonical\"))\n\t    o->mode = SEXP_CANONICAL;\n\t  else if (match_argument(optarg, \"hex\"))\n\t    {\n\t      o->mode = SEXP_ADVANCED;\n\t      o->prefer_hex = 1;\n\t    }\n\t  else\n\t    die(\"Available syntax variants: advanced, transport, canonical\\n\");\n\t  break;\n\n\tcase OPT_ONCE:\n\t  o->once = 1;\n\t  break;\n\t\n\tcase OPT_HASH:\n\t  o->mode = SEXP_CANONICAL;\n\t  if (!optarg)\n\t    o->hash = &nettle_sha1;\n\t  else\n\t    for (i = 0;; i++)\n\t      {\n\t\tif (!hashes[i])\n\t\t  die(\"sexp_conv: Unknown hash algorithm `%s'\\n\",\n\t\t      optarg);\n\t      \n\t\tif (match_argument(optarg, hashes[i]->name))\n\t\t  {\n\t\t    o->hash = hashes[i];\n\t\t    break;\n\t\t  }\n\t      }\n\t  break;\n#if HAVE_FCNTL_LOCKING\n\tcase OPT_LOCK:\n\t  o->lock = 1;\n\t  break;\n#endif\n\tcase OPT_HELP:\n\t  printf(\"Usage: sexp-conv [OPTION...]\\n\"\n\t\t \"  Conversion:     sexp-conv [OPTION...] <INPUT-SEXP\\n\"\n\t\t \"  Fingerprinting: sexp-conv --hash=HASH <INPUT-SEXP\\n\\n\"\n\t\t \"Reads an s-expression on stdin, and outputs the same\\n\"\n\t\t \"sexp on stdout, possibly with a different syntax.\\n\\n\"\n\t\t \"       --hash[=ALGORITHM]   Outputs only the hash of the expression.\\n\"\n\t\t \"                            Available hash algorithms:\\n\"\n\t\t \"                            \");\n\t  for(i = 0; hashes[i]; i++)\n\t    {\n\t      if (i) printf(\", \");\n\t      printf(\"%s\", hashes[i]->name);\n\t    }\n\t  printf(\" (default is sha1).\\n\"\n\t\t \"   -s, --syntax=SYNTAX      The syntax used for the output. Available\\n\"\n\t\t \"                            variants: advanced, hex, transport, canonical\\n\"\n\t\t \"       --once               Process only the first s-expression.\\n\"\n\t\t \"   -w, --width=WIDTH        Linewidth for base64 encoded data.\\n\"\n\t\t \"                            Zero means no limit.\\n\"\n#if HAVE_FCNTL_LOCKING\n\t\t \"       --lock               Lock output file.\\n\"\n#endif\n\t\t \"       --raw-hash           Alias for --hash, for compatibility\\n\"\n\t\t \"                            with lsh-1.x.\\n\\n\"\n\t\t \"Report bugs to \" BUG_ADDRESS \".\\n\");\n\t  exit(EXIT_SUCCESS);\n\n\tcase 'V':\n\t  printf(\"sexp-conv (\" PACKAGE_STRING \")\\n\");\n\t  exit (EXIT_SUCCESS);\n\t}\n    }\n}",
      "lines": 145,
      "depth": 17,
      "decorators": [
        "static",
        "static",
        "void"
      ]
    },
    "main": {
      "start_point": [
        368,
        0
      ],
      "end_point": [
        439,
        1
      ],
      "content": "int\nmain(int argc, char **argv)\n{\n  struct conv_options options;\n  struct sexp_input input;\n  struct sexp_parser parser;\n  struct sexp_compound_token token;\n  struct sexp_output output;\n\n  parse_options(&options, argc, argv);\n\n  sexp_input_init(&input, stdin);\n  sexp_parse_init(&parser, &input, SEXP_ADVANCED);\n  sexp_compound_token_init(&token);\n  sexp_output_init(&output, stdout,\n\t\t   options.width, options.prefer_hex);\n\n#if HAVE_FCNTL_LOCKING\n  if (options.lock)\n    {\n      struct flock fl;\n  \n      memset(&fl, 0, sizeof(fl));\n      fl.l_type = F_WRLCK;\n      fl.l_whence = SEEK_SET;\n      fl.l_start = 0;\n      fl.l_len = 0; /* Means entire file. */\n      \n      if (fcntl(STDOUT_FILENO, F_SETLKW, &fl) == -1)\n\tdie(\"Locking output file failed: %s\\n\", strerror(errno));\n    }\n#endif /* HAVE_FCNTL_LOCKING */\n  if (options.hash)\n    {\n      /* Leaks the context, but that doesn't matter */\n      void *ctx = xalloc(options.hash->context_size);\n      sexp_output_hash_init(&output, options.hash, ctx);\n    }\n  \n  sexp_get_char(&input);\n  \n  sexp_parse(&parser, &token);\n  \n  if (token.type == SEXP_EOF)\n    {\n      if (options.once)\n\tdie(\"sexp-conv: No input expression.\\n\");\n      return EXIT_SUCCESS;\n    }\n  \n  do \n    {\n      sexp_convert_item(&parser, &token, &output, options.mode, 0);\n      if (options.hash)\n\t{\n\t  sexp_put_digest(&output);\n\t  sexp_put_newline(&output, 0);\n\t}\n      else if (options.mode != SEXP_CANONICAL)\n\tsexp_put_newline(&output, 0);\n\t  \n      sexp_parse(&parser, &token);\n    }\n  while (!options.once && token.type != SEXP_EOF);\n\n  sexp_compound_token_clear(&token);\n  \n  if (fflush(output.f) < 0)\n    die(\"Final fflush failed: %s.\\n\", strerror(errno));\n  \n  return EXIT_SUCCESS;\n}",
      "lines": 72,
      "depth": 12,
      "decorators": [
        "int"
      ]
    }
  }
}